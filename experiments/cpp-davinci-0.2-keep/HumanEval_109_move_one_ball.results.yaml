language: cpp
name: HumanEval_109_move_one_ball
results:
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate()\n   \
    \ // Hint: You can use std::is_sorted()\n    if(arr.size()==0)\n        return\
    \ true;\n    for(int i=0;i<arr.size();i++){\n        std::rotate(arr.begin(),arr.begin()+1,arr.end());\n\
    \        if(std::is_sorted(arr.begin(),arr.end()))\n            return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp20mne8vy: /tmp/tmp20mne8vy.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> v;\n \
    \   for(long i=0;i<arr.size();i++)\n        v.push_back(arr[i]);\n    std::sort(v.begin(),v.end());\n\
    \    long count=0;\n    for(long i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=v[i])\n\
    \            count++;\n    }\n    if(count==1)\n        return true;\n    else\n\
    \        return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpjluz1cp4: /tmp/tmpjluz1cp4.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        max=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpu39l4nrt: /tmp/tmpu39l4nrt.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    int j=n-1;\n    while(i<j){\n        if(arr[i]>arr[j])\n         \
    \   return false;\n        i++;\n        j--;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpf5nsow72: /tmp/tmpf5nsow72.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\t// your code here\n\tif (arr.size() == 0)\n\t\treturn true;\n\tint i =\
    \ 0;\n\twhile (i < arr.size() - 1) {\n\t\tif (arr[i] > arr[i + 1])\n\t\t\tbreak;\n\
    \t\ti++;\n\t}\n\tif (i == arr.size() - 1)\n\t\treturn true;\n\tint j = i + 1;\n\
    \twhile (j < arr.size() - 1) {\n\t\tif (arr[j] < arr[j + 1])\n\t\t\tbreak;\n\t\
    \tj++;\n\t}\n\tif (j == arr.size() - 1)\n\t\treturn true;\n\treturn false;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmprwyo02ej: /tmp/tmprwyo02ej.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int n=arr.size();\n    std::vector<long>\
    \ temp(n);\n    for(int i=0;i<n;i++) temp[i]=arr[i];\n    std::sort(temp.begin(),temp.end());\n\
    \    int i=0;\n    while(i<n){\n        if(arr[i]==temp[i]) i++;\n        else{\n\
    \            if(arr[i]==temp[n-1]){\n                int j=i+1;\n            \
    \    while(j<n){\n                    if(arr[j]==temp[j]) j++;\n             \
    \       else break;\n                }\n                if(j==n) return true;\n\
    \                else return false;\n            }\n            else return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpjea7op8l: /tmp/tmpjea7op8l.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        else\n            max=arr[i];\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8kcg72el: /tmp/tmp8kcg72el.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptlg8lip2: /tmp/tmptlg8lip2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count==0)\n        return true;\n    if(count>1)\n        return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    int n = arr.size();\n    if(n == 0)\n        return true;\n    int i\
    \ = 0;\n    while(i < n - 1) {\n        if(arr[i] > arr[i + 1])\n            break;\n\
    \        i++;\n    }\n    if(i == n - 1)\n        return true;\n    int j = i\
    \ + 1;\n    while(j < n - 1) {\n        if(arr[j] < arr[j + 1])\n            break;\n\
    \        j++;\n    }\n    if(j == n - 1)\n        return true;\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpi4y4hcd5: /tmp/tmpi4y4hcd5.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tlong max = arr[0];\n\t\
    for (int i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < max) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t\tmax = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n   \
    \ auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpi2euzd3q: /tmp/tmpi2euzd3q.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptlg8lip2: /tmp/tmptlg8lip2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    std::vector<long> sorted_arr=arr;\n\
    \    std::sort(sorted_arr.begin(),sorted_arr.end());\n    for(int i=0;i<arr.size();i++){\n\
    \        if(arr[i]!=sorted_arr[i]) return false;\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpg82gbwel: /tmp/tmpg82gbwel.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size()==0)\n    return true;\n  int i=0;\n  while(i<arr.size()-1){\n\
    \    if(arr[i]>arr[i+1])\n      break;\n    i++;\n  }\n  if(i==arr.size()-1)\n\
    \    return true;\n  int j=i+1;\n  while(j<arr.size()-1){\n    if(arr[j]<arr[j+1])\n\
    \      return false;\n    j++;\n  }\n  return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpmx3t9_51: /tmp/tmpmx3t9_51.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111219
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    else\n        return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptlg8lip2: /tmp/tmptlg8lip2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp61_kxt5e: /tmp/tmp61_kxt5e.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // your code here\n    if(arr.size()==0)\n        return true;\n    int\
    \ i=0;\n    for(i=0;i<arr.size()-1;i++)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            break;\n    }\n    if(i==arr.size()-1)\n        return true;\n  \
    \  for(int j=i+1;j<arr.size();j++)\n    {\n        if(arr[j]<arr[i])\n       \
    \     return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp0awfvh6y: /tmp/tmp0awfvh6y.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpoxxixy99: /tmp/tmpoxxixy99.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ min=arr[0];\n    for(int i=1;i<n;i++){\n        if(arr[i]<min)\n           \
    \ return false;\n        if(arr[i]>min)\n            min=arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpcjz5jwfp: /tmp/tmpcjz5jwfp.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    int j=n-1;\n    while(i<n-1 && arr[i]<arr[i+1])\n        i++;\n  \
    \  while(j>0 && arr[j]>arr[j-1])\n        j--;\n    if(i==n-1)\n        return\
    \ true;\n    if(j==0)\n        return false;\n    if(i==j)\n        return true;\n\
    \    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n   \
    \ assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8h1q21cx: /tmp/tmp8h1q21cx.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size() == 0)\n        return true;\n    long max = arr[0];\n \
    \   for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < max)\n        \
    \    return false;\n        max = arr[i];\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpzoknq1gv: /tmp/tmpzoknq1gv.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate()\n   \
    \ // Hint: You can use std::is_sorted()\n    // Hint: You can use std::next_permutation()\n\
    \    // Hint: You can use std::prev_permutation()\n    // Hint: You can use std::sort()\n\
    \    // Hint: You can use std::reverse()\n    // Hint: You can use std::rotate()\n\
    \    // Hint: You can use std::is_sorted()\n    // Hint: You can use std::next_permutation()\n\
    \    // Hint: You can use std::prev_permutation()\n    // Hint: You can use std::sort()\n\
    \    // Hint: You can use std::reverse()\n    // Hint: You can use std::rotate()\n\
    \    // Hint: You can use std::is_sorted()\n    // Hint: You can use std::next_permutation()\n\
    \    // Hint: You can use std::prev_permutation()\n    // Hint: You can use std::sort()\n\
    \    // Hint: You can use std::reverse()\n    // Hint: You can use std::rotate()\n\
    \    // Hint: You can use std::is_sorted()\n    // Hint: You can use std::next_permutation()\n\
    \    // Hint: You can use std::prev_permutation()\n    // Hint: You can use std::sort()\n\
    \    // Hint: You can use std::reverse()\n    // Hint: You can use std::rotate()\n\
    \    // Hint: You can use std::is_sorted()\n    // Hint: You can use std::next_permutation()\n\
    \    // Hint: You can use std::prev_permutation()\n    // Hint: You can use std::sort()\n\
    \    // Hint: You can use std::reverse()\n    // Hint: You can use std::rotate()\n\
    \    // Hint: You can use std::is_sorted()\n    // Hint: You can use std::next_permutation()\n\
    \    // Hint: You can use std::prev_permutation()\n    //\n}\nint main() {\n \
    \   auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpb1m35iml: /tmp/tmpb1m35iml.cpp:62: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) return true;\n\tlong max = arr[0];\n\tfor (int i =\
    \ 1; i < arr.size(); i++) {\n\t\tif (arr[i] < max) return false;\n\t\tif (arr[i]\
    \ > max) max = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpltwaqeam: /tmp/tmpltwaqeam.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::sort(arr.begin(),arr.end());\n\
    \    for(int i=0;i<arr.size()-1;i++)\n    {\n        if(arr[i]==arr[i+1])\n  \
    \          return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptswba4_i: /tmp/tmptswba4_i.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate() function.\n\
    \    // Hint: You can use std::is_sorted() function.\n    if(arr.size()==0)\n\
    \        return true;\n    for(int i=0;i<arr.size();i++){\n        std::rotate(arr.begin(),arr.begin()+1,arr.end());\n\
    \        if(std::is_sorted(arr.begin(),arr.end()))\n            return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1]) return false;\n        i++;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp67c9a4o8: /tmp/tmp67c9a4o8.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        if(arr[i]<arr[i-1])\n            min=arr[i];\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpubew3wfv: /tmp/tmpubew3wfv.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> sorted_arr(arr);\n\
    \    std::sort(sorted_arr.begin(),sorted_arr.end());\n    int count=0;\n    for(int\
    \ i=0;i<arr.size();i++){\n        if(arr[i]!=sorted_arr[i])\n            count++;\n\
    \    }\n    if(count==1)\n        return true;\n    return false;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpft9z_tmr: /tmp/tmpft9z_tmr.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptlg8lip2: /tmp/tmptlg8lip2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use std::cout\n    // Example: std::cout << \"Hello world!\";\n    int\
    \ n = arr.size();\n    if(n==0)\n        return true;\n    int min = arr[0];\n\
    \    for(int i=1;i<n;i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpc6nvmdct: /tmp/tmpc6nvmdct.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ max=arr[0];\n    for(int i=1;i<n;i++){\n        if(arr[i]<max)\n           \
    \ return false;\n        if(arr[i]>max)\n            max=arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_ayiekfv: /tmp/tmp_ayiekfv.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use std::cout\n    // Example: std::cout << \"Hello world!\";\n    int\
    \ n = arr.size();\n    if(n == 0) return true;\n    if(n == 1) return true;\n\
    \    int count = 0;\n    for(int i = 0; i < n - 1; i++){\n        if(arr[i] >\
    \ arr[i + 1]){\n            count++;\n        }\n    }\n    if(count > 1) return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    int j=n-1;\n    while(i<j)\n    {\n        if(arr[i]<arr[j])\n   \
    \         return false;\n        i++;\n        j--;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp7ustpzyv: /tmp/tmp7ustpzyv.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n            return false;\n\
    \        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp4tkd8fi7: /tmp/tmp4tkd8fi7.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    long min=arr[0];\n    for(int i=1;i<arr.size();i++){\n\
    \        if(arr[i]<min) return false;\n        min=arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp74izoox6: /tmp/tmp74izoox6.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> v;\n \
    \   for(int i=0;i<arr.size();i++)\n        v.push_back(arr[i]);\n    std::sort(v.begin(),v.end());\n\
    \    for(int i=0;i<arr.size();i++)\n        if(arr[i]!=v[i])\n            return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_d26vlh8: /tmp/tmp_d26vlh8.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int count = 0;\n    for(int i=0;i<arr.size()-1;i++){\n\
    \        if(arr[i]>arr[i+1]){\n            count++;\n        }\n    }\n    if(count>1)\
    \ return false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tlong max = arr[0];\n\t\
    for (int i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < max) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t\telse {\n\t\t\tmax = arr[i];\n\t\t}\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpwsm4kz6a: /tmp/tmpwsm4kz6a.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // your code here\n    if(arr.size()==0)\n        return true;\n    long\
    \ min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp0z1bkvwz: /tmp/tmp0z1bkvwz.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use cout\n    // Example: cout << \"Hello world!\";\n    if(arr.size()==0)\n\
    \    {\n        return true;\n    }\n    int i=0;\n    int j=1;\n    while(j<arr.size())\n\
    \    {\n        if(arr[i]<=arr[j])\n        {\n            i++;\n            j++;\n\
    \        }\n        else\n        {\n            return false;\n        }\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_vno34ay: /tmp/tmp_vno34ay.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp=arr;\n\
    \    std::sort(temp.begin(),temp.end());\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=temp[i])\n            return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpri1qqa18: /tmp/tmpri1qqa18.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use std::cout\n    // Example: std::cout << \"Hello world!\";\n    if(arr.size()==0)\n\
    \        return true;\n    std::vector<long> temp(arr.size());\n    for(int i=0;i<arr.size();i++)\n\
    \        temp[i]=arr[i];\n    std::sort(temp.begin(),temp.end());\n    for(int\
    \ i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=temp[i])\n            return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp81j7tf4k: /tmp/tmp81j7tf4k.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use std::cout\n    // Example: std::cout << \"Hello world!\";\n    if(arr.size()==0)\n\
    \        return true;\n    int n=arr.size();\n    int count=0;\n    for(int i=0;i<n-1;i++)\n\
    \    {\n        if(arr[i]>arr[i+1])\n            count++;\n    }\n    if(count>1)\n\
    \        return false;\n    else\n        return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpoxxixy99: /tmp/tmpoxxixy99.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n            return false;\n\
    \        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp4tkd8fi7: /tmp/tmp4tkd8fi7.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> v;\n \
    \   for(int i=0;i<arr.size();i++)\n        v.push_back(arr[i]);\n    std::sort(v.begin(),v.end());\n\
    \    for(int i=0;i<arr.size();i++)\n        if(arr[i]!=v[i])\n            return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_d26vlh8: /tmp/tmp_d26vlh8.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    int n = arr.size();\n    if(n == 0)\n        return true;\n    int count\
    \ = 0;\n    for(int i = 0; i < n - 1; i++) {\n        if(arr[i] > arr[i + 1])\n\
    \            count++;\n    }\n    if(count > 1)\n        return false;\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(long\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        max=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp2tes21f8: /tmp/tmp2tes21f8.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n            return false;\n\
    \        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp4tkd8fi7: /tmp/tmp4tkd8fi7.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        if(arr[i]>min)\n            min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmprvhh6hzv: /tmp/tmprvhh6hzv.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    for(int i=0;i<arr.size()-1;i++){\n\
    \        if(arr[i]>arr[i+1]) return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpfcxkqpd6: /tmp/tmpfcxkqpd6.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111221
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp=arr;\n\
    \    std::sort(temp.begin(),temp.end());\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=temp[i])\n            return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpri1qqa18: /tmp/tmpri1qqa18.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    if(arr.size()==0)\n        return true;\n\
    \    int i=0;\n    int j=arr.size()-1;\n    while(i<j)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            return false;\n        if(arr[j]<arr[j-1])\n            return false;\n\
    \        i++;\n        j--;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpzmktzfch: /tmp/tmpzmktzfch.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    if(arr.size()==0)\n        return true;\n\
    \    long min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp39874k05: /tmp/tmp39874k05.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tlong min = arr[0];\n\t\
    for (int i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < min) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t\tmin = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n   \
    \ auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpd_oz4_7f: /tmp/tmpd_oz4_7f.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size()==0)\n    return true;\n  long min=arr[0];\n  for(int i=1;i<arr.size();i++){\n\
    \    if(arr[i]<min)\n      return false;\n    min=arr[i];\n  }\n  return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp2kzuafbx: /tmp/tmp2kzuafbx.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int count=0;\n    for(int i=0;i<arr.size()-1;i++){\n\
    \        if(arr[i]>arr[i+1]){\n            count++;\n        }\n    }\n    if(count==1)\
    \ return true;\n    else return false;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    if(arr.size()==0)\n        return true;\n\
    \    std::vector<long> temp;\n    for(int i=0;i<arr.size();i++)\n        temp.push_back(arr[i]);\n\
    \    std::sort(temp.begin(),temp.end());\n    int count=0;\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=temp[i])\n            count++;\n    }\n    if(count==1)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpd6hl56zx: /tmp/tmpd6hl56zx.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp;\n\
    \    for(int i=0;i<arr.size();i++)\n        temp.push_back(arr[i]);\n    std::sort(temp.begin(),temp.end());\n\
    \    for(int i=0;i<arr.size();i++)\n        if(arr[i]!=temp[i])\n            return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpsklq_t_x: /tmp/tmpsklq_t_x.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate() to rotate\
    \ the elements of the vector.\n    // Hint: You can use std::is_sorted() to check\
    \ if the vector is sorted.\n    // Hint: You can use std::prev_permutation() to\
    \ get the previous permutation\n    // of the vector.\n    // Hint: You can use\
    \ std::next_permutation() to get the next permutation\n    // of the vector.\n\
    \    // Hint: You can use std::sort() to sort the vector.\n    // Hint: You can\
    \ use std::reverse() to reverse the vector.\n    // Hint: You can use std::swap()\
    \ to swap the elements of the vector.\n    // Hint: You can use std::min_element()\
    \ to get the minimum element of the\n    // vector.\n    // Hint: You can use\
    \ std::max_element() to get the maximum element of the\n    // vector.\n    //\
    \ Hint: You can use std::find() to find the index of an element in the\n    //\
    \ vector.\n    // Hint: You can use std::count() to count the number of occurences\
    \ of an\n    // element in the vector.\n    // Hint: You can use std::lower_bound()\
    \ to get the index of the first\n    // occurence of an element in the vector.\n\
    \    // Hint: You can use std::upper_bound() to get the index of the last\n  \
    \  // occurence of an element in the vector.\n    // Hint: You can use std::unique()\
    \ to remove the duplicate elements from the\n    // vector.\n    // Hint: You\
    \ can use std::accumulate() to get the sum of the elements of the\n    // vector.\n\
    \    // Hint: You can use std::inner_product() to get the dot product of the\n\
    \    // vectors.\n    // Hint: You can use std::partial_sum() to get the partial\
    \ sum of the\n    // elements of the vector.\n    // Hint: You can use std::transform()\
    \ to apply a function to the elements of\n    // the vector.\n    // Hint: You\
    \ can use std::for_each() to apply a function to the elements of\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpaeyhxo_t: /tmp/tmpaeyhxo_t.cpp:59: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size()==0) return true;\n  long min=arr[0];\n  for(int i=1;i<arr.size();i++){\n\
    \    if(arr[i]<min) return false;\n    min=arr[i];\n  }\n  return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9qw3f2p7: /tmp/tmp9qw3f2p7.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1]){\n            return false;\n        }\n        i++;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpm6vx7zz5: /tmp/tmpm6vx7zz5.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tlong min = arr[0];\n\tfor (int\
    \ i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < min)\n\t\t\treturn false;\n\t\
    \tmin = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp4rx_0c1k: /tmp/tmp4rx_0c1k.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp;\n\
    \    for(int i=0;i<arr.size();i++)\n        temp.push_back(arr[i]);\n    std::sort(temp.begin(),temp.end());\n\
    \    int count=0;\n    for(int i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=temp[i])\n\
    \            count++;\n    }\n    if(count==1)\n        return true;\n    else\n\
    \        return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpu6wu65z6: /tmp/tmpu6wu65z6.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    std::vector<long> sorted_arr=arr;\n\
    \    std::sort(sorted_arr.begin(),sorted_arr.end());\n    int count=0;\n    for(int\
    \ i=0;i<arr.size();i++){\n        if(arr[i]!=sorted_arr[i]) count++;\n    }\n\
    \    if(count==1) return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpzwpart_2: /tmp/tmpzwpart_2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use Printf\n    // Example: Printf(\"%s\", \"Hello world!\");\n    if(arr.size()==0)\n\
    \        return true;\n    for(int i=0;i<arr.size()-1;i++)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpkn5wilm7: /tmp/tmpkn5wilm7.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use std::cout\n    // Example: std::cout << \"Hello world!\";\n    if(arr.size()==0)\n\
    \        return true;\n    int count=0;\n    for(int i=0;i<arr.size()-1;i++)\n\
    \    {\n        if(arr[i]>arr[i+1])\n            count++;\n    }\n    if(count==0)\n\
    \        return true;\n    else if(count==1)\n        return true;\n    else\n\
    \        return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int min=arr[0];\n    for(int i=1;i<arr.size();i++){\n\
    \        if(arr[i]<min) return false;\n        if(arr[i]<arr[i-1]) min=arr[i];\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqr5bf6mw: /tmp/tmpqr5bf6mw.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // your code here\n    if(arr.size()==0)\n        return true;\n    int\
    \ count=0;\n    for(int i=0;i<arr.size()-1;i++)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            count++;\n    }\n    if(count>1)\n        return false;\n    else\n\
    \        return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptlg8lip2: /tmp/tmptlg8lip2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp=arr;\n\
    \    std::sort(temp.begin(),temp.end());\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=temp[i])\n            return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpri1qqa18: /tmp/tmpri1qqa18.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    for(int i=0;i<arr.size()-1;i++){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmppp49hc8r: /tmp/tmppp49hc8r.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptlg8lip2: /tmp/tmptlg8lip2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tint count = 0;\n\tfor\
    \ (int i = 0; i < arr.size() - 1; i++) {\n\t\tif (arr[i] > arr[i + 1]) {\n\t\t\
    \tcount++;\n\t\t}\n\t}\n\tif (count > 1) {\n\t\treturn false;\n\t}\n\telse {\n\
    \t\treturn true;\n\t}\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\t// Write your code here\n\t// Hint: You can use std::rotate() function\
    \ to perform right shift operation.\n\t// Hint: You can use std::is_sorted() function\
    \ to check if the array is sorted\n\t// in non-decreasing order.\n\t// Hint: You\
    \ can use std::next_permutation() function to generate all\n\t// permutations\
    \ of the given array.\n\t// Hint: You can use std::sort() function to sort the\
    \ given array.\n\t// Hint: You can use std::reverse() function to reverse the\
    \ given array.\n\t// Hint: You can use std::prev_permutation() function to generate\
    \ all\n\t// permutations of the given array in reverse order.\n\t// Hint: You\
    \ can use std::equal() function to check if two arrays are equal.\n\t// Hint:\
    \ You can use std::swap() function to swap two elements of the array.\n\t// Hint:\
    \ You can use std::copy() function to copy elements of one array to\n\t// another\
    \ array.\n\t// Hint: You can use std::rotate_copy() function to copy elements\
    \ of one\n\t// array to another array after performing right shift operation.\n\
    \t// Hint: You can use std::unique() function to remove duplicate elements from\n\
    \t// the array.\n\t// Hint: You can use std::unique_copy() function to copy elements\
    \ of one\n\t// array to another array after removing duplicate elements.\n\t//\
    \ Hint: You can use std::rotate_copy() function to copy elements of one\n\t//\
    \ array to another array after performing right shift operation.\n\t// Hint: You\
    \ can use std::rotate_copy() function to copy elements of one\n\t// array to another\
    \ array after performing right shift operation.\n\t// Hint: You can use std::rotate_copy()\
    \ function to copy elements of one\n\t// array to another array after performing\
    \ right shift operation.\n\t// Hint: You can use std::rotate_copy() function to\
    \ copy elements of one\n\t// array to another array after performing right shift\
    \ operation.\n\t// Hint: You can use std::rotate_copy() function to copy elements\
    \ of one\n\t// array to another array after performing right shift operation.\n\
    \t// Hint:\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp1c8rixh2: /tmp/tmp1c8rixh2.cpp:57: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate()\n   \
    \ if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int i=1;i<arr.size();i++)\n\
    \    {\n        if(arr[i]<min)\n            return false;\n        min=arr[i];\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8_y21enb: /tmp/tmp8_y21enb.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    for(int i=0;i<arr.size()-1;i++){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmppp49hc8r: /tmp/tmppp49hc8r.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    if(arr.size()==0)\n        return true;\n\
    \    int i,j;\n    for(i=0;i<arr.size()-1;i++)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            break;\n    }\n    for(j=i+1;j<arr.size()-1;j++)\n    {\n       \
    \ if(arr[j]>arr[j+1])\n            return false;\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    if(arr.size()==0)\n        return true;\n\
    \    int i=0;\n    while(i<arr.size()-1){\n        if(arr[i]>arr[i+1])\n     \
    \       return false;\n        i++;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpnrefza42: /tmp/tmpnrefza42.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate()\n   \
    \ if(arr.size()==0)\n        return true;\n    for(int i=0;i<arr.size();i++){\n\
    \        std::rotate(arr.begin(),arr.begin()+1,arr.end());\n        if(std::is_sorted(arr.begin(),arr.end()))\n\
    \            return true;\n    }\n    return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n            return false;\n\
    \        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp4tkd8fi7: /tmp/tmp4tkd8fi7.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    int j=n-1;\n    while(i<j){\n        if(arr[i]>arr[j])\n         \
    \   return false;\n        i++;\n        j--;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpf5nsow72: /tmp/tmpf5nsow72.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    std::vector<long> temp;\n    for(int\
    \ i=0;i<arr.size();i++){\n        temp.push_back(arr[i]);\n    }\n    std::sort(temp.begin(),temp.end());\n\
    \    for(int i=0;i<arr.size();i++){\n        if(arr[i]!=temp[i]) return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpeyz0sg8v: /tmp/tmpeyz0sg8v.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    if(arr.size()==0)\n        return true;\n\
    \    int n=arr.size();\n    int min=arr[0];\n    for(int i=1;i<n;i++)\n    {\n\
    \        if(arr[i]<min)\n            return false;\n        min=arr[i];\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp__1hloxy: /tmp/tmp__1hloxy.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(long\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpxr6ck68b: /tmp/tmpxr6ck68b.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate()\n   \
    \ // Hint: You can use std::is_sorted()\n    if(arr.size()==0)\n        return\
    \ true;\n    for(int i=0;i<arr.size();i++){\n        std::rotate(arr.begin(),arr.begin()+1,arr.end());\n\
    \        if(std::is_sorted(arr.begin(),arr.end()))\n            return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // your code here\n    if(arr.size()==0)\n        return true;\n    std::vector<long>\
    \ arr1=arr;\n    std::sort(arr1.begin(),arr1.end());\n    int count=0;\n    for(int\
    \ i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=arr1[i])\n            count++;\n\
    \    }\n    if(count==1)\n        return true;\n    else\n        return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpvr2g7b3w: /tmp/tmpvr2g7b3w.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    long min=arr[0];\n    for(int i=1;i<arr.size();i++){\n\
    \        if(arr[i]<min) return false;\n        min=arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp74izoox6: /tmp/tmp74izoox6.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int n=arr.size();\n    int min=arr[0];\n\
    \    for(int i=1;i<n;i++){\n        if(arr[i]<min) return false;\n        if(arr[i]>min)\
    \ min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp7zg0ygyq: /tmp/tmp7zg0ygyq.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate() to rotate\
    \ the elements of the vector.\n    // Hint: You can use std::is_sorted() to check\
    \ if the vector is sorted or not.\n    if(arr.size()==0)\n        return true;\n\
    \    for(int i=0;i<arr.size();i++){\n        std::rotate(arr.begin(),arr.begin()+1,arr.end());\n\
    \        if(std::is_sorted(arr.begin(),arr.end()))\n            return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    long max=arr[0];\n    for(int i=1;i<arr.size();i++){\n\
    \        if(arr[i]<max) return false;\n        if(arr[i]>max) max=arr[i];\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp02uf3h9i: /tmp/tmp02uf3h9i.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tlong max = arr[0];\n\tfor (long\
    \ i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < max)\n\t\t\treturn false;\n\t\
    \telse\n\t\t\tmax = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpwhrl1xph: /tmp/tmpwhrl1xph.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> sorted_arr=arr;\n\
    \    std::sort(sorted_arr.begin(),sorted_arr.end());\n    int count=0;\n    for(int\
    \ i=0;i<arr.size();i++){\n        if(arr[i]!=sorted_arr[i])\n            count++;\n\
    \    }\n    if(count==1)\n        return true;\n    return false;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpnkrd4a3c: /tmp/tmpnkrd4a3c.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp20mne8vy: /tmp/tmp20mne8vy.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp=arr;\n\
    \    std::sort(temp.begin(),temp.end());\n    int count=0;\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=temp[i])\n            count++;\n    }\n    if(count==1)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpp5iztllu: /tmp/tmpp5iztllu.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    else\n        return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  // your code here\n  if(arr.size()==0)\n    return true;\n  int i=0;\n\
    \  while(i<arr.size()-1){\n    if(arr[i]>arr[i+1])\n      return false;\n    i++;\n\
    \  }\n  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n \
    \   assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpgmqgmvty: /tmp/tmpgmqgmvty.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> v;\n \
    \   for(int i=0;i<arr.size();i++)\n        v.push_back(arr[i]);\n    std::sort(v.begin(),v.end());\n\
    \    for(int i=0;i<arr.size();i++)\n        if(arr[i]!=v[i])\n            return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_d26vlh8: /tmp/tmp_d26vlh8.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    std::vector<long> arr2=arr;\n   \
    \ std::sort(arr2.begin(),arr2.end());\n    for(int i=0;i<arr.size();i++){\n  \
    \      if(arr[i]!=arr2[i]) return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp0fxh0a7z: /tmp/tmp0fxh0a7z.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpoxxixy99: /tmp/tmpoxxixy99.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int n=arr.size();\n    int i=0;\n\
    \    while(i<n-1){\n        if(arr[i]>arr[i+1]) break;\n        i++;\n    }\n\
    \    int j=i+1;\n    while(j<n-1){\n        if(arr[j]>arr[j+1]) return false;\n\
    \        j++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    std::vector<long>\
    \ v(n);\n    for(int i=0;i<n;i++)\n        v[i]=arr[i];\n    std::sort(v.begin(),v.end());\n\
    \    int count=0;\n    for(int i=0;i<n;i++)\n    {\n        if(arr[i]!=v[i])\n\
    \            count++;\n    }\n    if(count>2)\n        return false;\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpkf0eyljh: /tmp/tmpkf0eyljh.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptlg8lip2: /tmp/tmptlg8lip2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        max=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpu39l4nrt: /tmp/tmpu39l4nrt.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tstd::vector<long> sorted_arr\
    \ = arr;\n\tstd::sort(sorted_arr.begin(), sorted_arr.end());\n\tlong count = 0;\n\
    \tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] != sorted_arr[i]) {\n\
    \t\t\tcount++;\n\t\t}\n\t}\n\tif (count == 1) {\n\t\treturn true;\n\t}\n\treturn\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_6ztn70r: /tmp/tmp_6ztn70r.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tint count = 0;\n\tfor\
    \ (int i = 0; i < arr.size() - 1; i++) {\n\t\tif (arr[i] > arr[i + 1]) {\n\t\t\
    \tcount++;\n\t\t}\n\t}\n\tif (count > 1) {\n\t\treturn false;\n\t}\n\telse {\n\
    \t\treturn true;\n\t}\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // your code here\n    if(arr.size()==0)\n        return true;\n    int\
    \ max=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<max)\n\
    \            return false;\n        else\n            max=arr[i];\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpzupbl5hb: /tmp/tmpzupbl5hb.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    std::vector<long> sorted_arr=arr;\n\
    \    std::sort(sorted_arr.begin(),sorted_arr.end());\n    int count=0;\n    for(int\
    \ i=0;i<arr.size();i++){\n        if(arr[i]!=sorted_arr[i]) count++;\n    }\n\
    \    if(count==1) return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpzwpart_2: /tmp/tmpzwpart_2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        if(arr[i]<arr[i-1])\n            min=arr[i];\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpubew3wfv: /tmp/tmpubew3wfv.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp20mne8vy: /tmp/tmp20mne8vy.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ count=0;\n    for(int i=0;i<n-1;i++){\n        if(arr[i]>arr[i+1])\n       \
    \     count++;\n    }\n    if(count>1)\n        return false;\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tstd::vector<long> arr_copy\
    \ = arr;\n\tstd::sort(arr_copy.begin(), arr_copy.end());\n\tint count = 0;\n\t\
    for (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] != arr_copy[i]) {\n\t\t\
    \tcount++;\n\t\t}\n\t}\n\tif (count > 2) {\n\t\treturn false;\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpwfuymlyd: /tmp/tmpwfuymlyd.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int n=arr.size();\n    int count=0;\n\
    \    for(int i=0;i<n-1;i++){\n        if(arr[i]>arr[i+1]) count++;\n    }\n  \
    \  if(count>1) return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n            return false;\n\
    \        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp4tkd8fi7: /tmp/tmp4tkd8fi7.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp;\n\
    \    for(int i=0;i<arr.size();i++)\n        temp.push_back(arr[i]);\n    std::sort(temp.begin(),temp.end());\n\
    \    for(int i=0;i<arr.size();i++)\n        if(arr[i]!=temp[i])\n            return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpsklq_t_x: /tmp/tmpsklq_t_x.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp=arr;\n\
    \    std::sort(temp.begin(),temp.end());\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=temp[i])\n            return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpri1qqa18: /tmp/tmpri1qqa18.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tlong min = arr[0];\n\tfor (int\
    \ i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < min)\n\t\t\treturn false;\n\t\
    \tmin = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp4rx_0c1k: /tmp/tmp4rx_0c1k.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> arr1=arr;\n\
    \    std::sort(arr1.begin(),arr1.end());\n    int count=0;\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=arr1[i])\n            count++;\n    }\n    if(count==1)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpy7zcxjgu: /tmp/tmpy7zcxjgu.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        if(arr[i]>min)\n            min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmprvhh6hzv: /tmp/tmprvhh6hzv.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111222
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size()==0)\n    return true;\n  int count=0;\n  for(int i=0;i<arr.size()-1;i++){\n\
    \    if(arr[i]>arr[i+1])\n      count++;\n  }\n  if(count>1)\n    return false;\n\
    \  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111224
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size()==0) return true;\n  for(int i=0;i<arr.size()-1;i++){\n  \
    \  if(arr[i]>arr[i+1]) return false;\n  }\n  return true;\n}\nint main() {\n \
    \   auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp6i518hu0: /tmp/tmp6i518hu0.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111224
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int n=arr.size();\n    for(int i=0;i<n-1;i++){\n\
    \        if(arr[i]>arr[i+1]) return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp24vx7c0u: /tmp/tmp24vx7c0u.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111224
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size()==0) return true;\n  std::vector<long> temp;\n  temp=arr;\n\
    \  std::sort(temp.begin(),temp.end());\n  int count=0;\n  for(int i=0;i<arr.size();i++){\n\
    \    if(arr[i]!=temp[i]) count++;\n  }\n  if(count==1) return true;\n  else return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp53fbe4ux: /tmp/tmp53fbe4ux.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111224
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::sort(arr.begin(),arr.end());\n\
    \    for(int i=0;i<arr.size()-1;i++)\n        if(arr[i]>arr[i+1])\n          \
    \  return false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqhxw3mmw: /tmp/tmpqhxw3mmw.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111225
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tint count = 0;\n\tfor (int i\
    \ = 0; i < arr.size() - 1; i++) {\n\t\tif (arr[i] > arr[i + 1])\n\t\t\tcount++;\n\
    \t}\n\tif (count > 1)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111224
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size()==0)\n    return true;\n  int count=0;\n  for(int i=0;i<arr.size()-1;i++){\n\
    \    if(arr[i]>arr[i+1])\n      count++;\n  }\n  if(count==0)\n    return true;\n\
    \  else if(count==1)\n    return true;\n  else\n    return false;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111225
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n            return false;\n\
    \        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp4tkd8fi7: /tmp/tmp4tkd8fi7.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size() == 0) return true;\n  for(int i = 0; i < arr.size() - 1;\
    \ i++) {\n    if(arr[i] > arr[i + 1]) return false;\n  }\n  return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpcq5_c7_b: /tmp/tmpcq5_c7_b.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111225
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptlg8lip2: /tmp/tmptlg8lip2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    int n = arr.size();\n    if(n == 0) return true;\n    int min = arr[0];\n\
    \    for(int i = 1; i < n; i++) {\n        if(arr[i] < min) return false;\n  \
    \      min = std::min(min, arr[i]);\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5a4w0w4q.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp5a4w0w4q.cpp:28:35: error: no matching function for call\
    \ to \u2018min(int&, __gnu_cxx::__alloc_traits<std::allocator<long int>, long\
    \ int>::value_type&)\u2019\n   28 |         min = std::min(min, arr[i]);\n   \
    \   |                                   ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp5a4w0w4q.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:198:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const\
    \ _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:198:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp5a4w0w4q.cpp:28:35: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018int\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   28 |         min = std::min(min, arr[i]);\n\
    \      |                                   ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp5a4w0w4q.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp5a4w0w4q.cpp:28:35:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    int\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   28 |         min = std::min(min, arr[i]);\n\
    \      |                        "
  stdout: ''
  timestamp: 1660111224
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tint n = arr.size();\n\t\
    int count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] == i + 1) {\n\t\
    \t\tcount++;\n\t\t}\n\t}\n\tif (count == n) {\n\t\treturn true;\n\t}\n\telse {\n\
    \t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpt68jfctr: /tmp/tmpt68jfctr.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111224
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate() function\n\
    \    // Hint: You can use std::is_sorted() function\n    // Hint: You can use\
    \ std::next_permutation() function\n    // Hint: You can use std::prev_permutation()\
    \ function\n    // Hint: You can use std::sort() function\n    // Hint: You can\
    \ use std::reverse() function\n    // Hint: You can use std::rotate() function\n\
    \    // Hint: You can use std::is_sorted() function\n    // Hint: You can use\
    \ std::next_permutation() function\n    // Hint: You can use std::prev_permutation()\
    \ function\n    // Hint: You can use std::sort() function\n    // Hint: You can\
    \ use std::reverse() function\n    // Hint: You can use std::rotate() function\n\
    \    // Hint: You can use std::is_sorted() function\n    // Hint: You can use\
    \ std::next_permutation() function\n    // Hint: You can use std::prev_permutation()\
    \ function\n    // Hint: You can use std::sort() function\n    // Hint: You can\
    \ use std::reverse() function\n    // Hint: You can use std::rotate() function\n\
    \    // Hint: You can use std::is_sorted() function\n    // Hint: You can use\
    \ std::next_permutation() function\n    // Hint: You can use std::prev_permutation()\
    \ function\n    // Hint: You can use std::sort() function\n    // Hint: You can\
    \ use std::reverse() function\n    // Hint: You can use std::rotate() function\n\
    \    // Hint: You can use std::is_sorted() function\n    // Hint: You can use\
    \ std::next_permutation() function\n    // Hint: You can use std::prev_permutation()\
    \ function\n    // Hint: You can use std::sort() function\n    // Hint: You can\
    \ use std::reverse() function\n    // Hint: You can use std::rotate() function\n\
    \    // Hint: You can use std::is_sorted() function\n    //\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp95vulijf: /tmp/tmp95vulijf.cpp:60: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111225
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tint count = 0;\n\tfor\
    \ (int i = 0; i < arr.size() - 1; i++) {\n\t\tif (arr[i] > arr[i + 1]) {\n\t\t\
    \tcount++;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn true;\n\t}\n\telse if\
    \ (count == 1) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111224
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpoxxixy99: /tmp/tmpoxxixy99.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptlg8lip2: /tmp/tmptlg8lip2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tint i = 0;\n\twhile (i < arr.size()\
    \ - 1) {\n\t\tif (arr[i] > arr[i + 1])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i ==\
    \ arr.size() - 1)\n\t\treturn true;\n\tint j = i + 1;\n\twhile (j < arr.size()\
    \ - 1) {\n\t\tif (arr[j] < arr[j + 1])\n\t\t\treturn false;\n\t\tj++;\n\t}\n\t\
    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9x6d4z2h: /tmp/tmp9x6d4z2h.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111225
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    for(int\
    \ i=0;i<n-1;i++){\n        if(arr[i]>arr[i+1])\n            return false;\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp4p99m56w: /tmp/tmp4p99m56w.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111225
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp20mne8vy: /tmp/tmp20mne8vy.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tlong max = arr[0];\n\t\
    for (int i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < max) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t\telse {\n\t\t\tmax = arr[i];\n\t\t}\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpwsm4kz6a: /tmp/tmpwsm4kz6a.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> v;\n \
    \   for(long i=0;i<arr.size();i++)\n        v.push_back(arr[i]);\n    std::sort(v.begin(),v.end());\n\
    \    long count=0;\n    for(long i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=v[i])\n\
    \            count++;\n    }\n    if(count==1)\n        return true;\n    else\n\
    \        return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpjluz1cp4: /tmp/tmpjluz1cp4.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) return true;\n\tlong min = arr[0];\n\tfor (int i =\
    \ 1; i < arr.size(); i++) {\n\t\tif (arr[i] < min) return false;\n\t\tmin = arr[i];\n\
    \t}\n\treturn true;\n}\nint main() {\n    auto candidate = move_one_ball;\n  \
    \  assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmph_e1s3tj: /tmp/tmph_e1s3tj.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111225
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> arr1=arr;\n\
    \    std::sort(arr1.begin(),arr1.end());\n    long count=0;\n    for(long i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=arr1[i])\n            count++;\n    }\n    if(count==1)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp5ontppwo: /tmp/tmp5ontppwo.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111225
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp=arr;\n\
    \    std::sort(temp.begin(),temp.end());\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=temp[i])\n            return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpri1qqa18: /tmp/tmpri1qqa18.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate() function\
    \ to perform right shift operation.\n    // Hint: You can use std::is_sorted()\
    \ function to check if the array is sorted.\n    if(arr.size()==0)\n        return\
    \ true;\n    for(int i=0;i<arr.size();i++){\n        std::rotate(arr.begin(),arr.begin()+1,arr.end());\n\
    \        if(std::is_sorted(arr.begin(),arr.end()))\n            return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111224
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp;\n\
    \    temp=arr;\n    std::sort(temp.begin(),temp.end());\n    int count=0;\n  \
    \  for(int i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=temp[i])\n       \
    \     count++;\n    }\n    if(count==1)\n        return true;\n    else\n    \
    \    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n   \
    \ assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpwvzwge3r: /tmp/tmpwvzwge3r.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111224
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tfor (int i = 0; i < arr.size()\
    \ - 1; i++) {\n\t\tif (arr[i] > arr[i + 1])\n\t\t\treturn false;\n\t}\n\treturn\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpfliwesty: /tmp/tmpfliwesty.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111224
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use std::cout\n    // Example: std::cout << \"Hello world!\";\n    int\
    \ n = arr.size();\n    if(n==0)\n        return true;\n    int i = 0;\n    while(i<n-1){\n\
    \        if(arr[i]>arr[i+1])\n            break;\n        i++;\n    }\n    if(i==n-1)\n\
    \        return true;\n    int j = i+1;\n    while(j<n-1){\n        if(arr[j]<arr[j+1])\n\
    \            return false;\n        j++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpuzryj1ge: /tmp/tmpuzryj1ge.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111224
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) return true;\n\tlong min = arr[0];\n\tfor (int i =\
    \ 1; i < arr.size(); i++) {\n\t\tif (arr[i] < min) return false;\n\t\tmin = arr[i];\n\
    \t}\n\treturn true;\n}\nint main() {\n    auto candidate = move_one_ball;\n  \
    \  assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmph_e1s3tj: /tmp/tmph_e1s3tj.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111225
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate()\n   \
    \ if(arr.size()==0)\n        return true;\n    std::sort(arr.begin(),arr.end());\n\
    \    for(int i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=i+1)\n         \
    \   return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpxx12wz5k: /tmp/tmpxx12wz5k.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111225
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptlg8lip2: /tmp/tmptlg8lip2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  // your code here\n  if(arr.size()==0)\n    return true;\n  long max=arr[0];\n\
    \  for(int i=1;i<arr.size();i++)\n  {\n    if(arr[i]<max)\n      return false;\n\
    \    else\n      max=arr[i];\n  }\n  return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp3i0em7un: /tmp/tmp3i0em7un.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111224
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> arr1=arr;\n\
    \    std::sort(arr1.begin(),arr1.end());\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=arr1[i])\n            return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpaunb9_y3: /tmp/tmpaunb9_y3.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111225
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tlong min = arr[0];\n\tfor (int\
    \ i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < min)\n\t\t\treturn false;\n\t\
    \tmin = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp4rx_0c1k: /tmp/tmp4rx_0c1k.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptlg8lip2: /tmp/tmptlg8lip2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ min=arr[0];\n    for(int i=1;i<n;i++){\n        if(arr[i]<min)\n           \
    \ return false;\n        if(arr[i]>min)\n            min=arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpcjz5jwfp: /tmp/tmpcjz5jwfp.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111219
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int count=0;\n    for(int i=0;i<arr.size()-1;i++){\n\
    \        if(arr[i]>arr[i+1]) count++;\n    }\n    if(count>1) return false;\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111225
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> v;\n \
    \   for(int i=0;i<arr.size();i++)\n        v.push_back(arr[i]);\n    std::sort(v.begin(),v.end());\n\
    \    for(int i=0;i<arr.size();i++)\n        if(arr[i]!=v[i])\n            return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_d26vlh8: /tmp/tmp_d26vlh8.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) return true;\n\tstd::vector<long> sorted_arr = arr;\n\
    \tstd::sort(sorted_arr.begin(), sorted_arr.end());\n\tint count = 0;\n\tfor (int\
    \ i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] != sorted_arr[i]) count++;\n\t\
    }\n\tif (count == 1) return true;\n\treturn false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp6jpwm6d3: /tmp/tmp6jpwm6d3.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111224
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        max=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpu39l4nrt: /tmp/tmpu39l4nrt.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tstd::vector<long> sorted_arr\
    \ = arr;\n\tstd::sort(sorted_arr.begin(), sorted_arr.end());\n\tint count = 0;\n\
    \tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] != sorted_arr[i]) {\n\
    \t\t\tcount++;\n\t\t}\n\t}\n\tif (count > 2) {\n\t\treturn false;\n\t}\n\treturn\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8wh8f4qt: /tmp/tmp8wh8f4qt.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111225
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> sorted_arr=arr;\n\
    \    std::sort(sorted_arr.begin(),sorted_arr.end());\n    int count=0;\n    for(int\
    \ i=0;i<arr.size();i++){\n        if(arr[i]!=sorted_arr[i])\n            count++;\n\
    \    }\n    if(count>2)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqtfxsd_o: /tmp/tmpqtfxsd_o.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111225
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    for(i=0;i<arr.size()-1;i++)\n\
    \    {\n        if(arr[i]>arr[i+1])\n            break;\n    }\n    if(i==arr.size()-1)\n\
    \        return true;\n    for(int j=i+1;j<arr.size();j++)\n    {\n        if(arr[j]<arr[i])\n\
    \            return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpryqdqfzm: /tmp/tmpryqdqfzm.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111225
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8zrydh8g: /tmp/tmp8zrydh8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptlg8lip2: /tmp/tmptlg8lip2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111220
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tlong min = arr[0];\n\tfor (int\
    \ i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < min)\n\t\t\treturn false;\n\t\
    \tmin = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp4rx_0c1k: /tmp/tmp4rx_0c1k.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111223
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    int n = arr.size();\n    if(n == 0) return true;\n    int min = arr[0];\n\
    \    for(int i = 1; i < n; i++) {\n        if(arr[i] < min) return false;\n  \
    \      min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmphucdt55k: /tmp/tmphucdt55k.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111225
