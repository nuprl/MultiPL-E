name: HumanEval_109_move_one_ball
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate()\n   \
    \ // Hint: You can use std::is_sorted()\n    if(arr.size()==0)\n        return\
    \ true;\n    for(int i=0;i<arr.size();i++){\n        std::rotate(arr.begin(),arr.begin()+1,arr.end());\n\
    \        if(std::is_sorted(arr.begin(),arr.end()))\n            return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpzssg4urq: /tmp/tmpzssg4urq.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpb_o6j0g8: /tmp/tmpb_o6j0g8.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> v;\n \
    \   for(long i=0;i<arr.size();i++)\n        v.push_back(arr[i]);\n    std::sort(v.begin(),v.end());\n\
    \    long count=0;\n    for(long i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=v[i])\n\
    \            count++;\n    }\n    if(count==1)\n        return true;\n    else\n\
    \        return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp0h6xq5y4: /tmp/tmp0h6xq5y4.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        max=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpejd4w6uu: /tmp/tmpejd4w6uu.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    int j=n-1;\n    while(i<j){\n        if(arr[i]>arr[j])\n         \
    \   return false;\n        i++;\n        j--;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp30noc4p0: /tmp/tmp30noc4p0.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\t// your code here\n\tif (arr.size() == 0)\n\t\treturn true;\n\tint i =\
    \ 0;\n\twhile (i < arr.size() - 1) {\n\t\tif (arr[i] > arr[i + 1])\n\t\t\tbreak;\n\
    \t\ti++;\n\t}\n\tif (i == arr.size() - 1)\n\t\treturn true;\n\tint j = i + 1;\n\
    \twhile (j < arr.size() - 1) {\n\t\tif (arr[j] < arr[j + 1])\n\t\t\tbreak;\n\t\
    \tj++;\n\t}\n\tif (j == arr.size() - 1)\n\t\treturn true;\n\treturn false;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmplutz6t_u: /tmp/tmplutz6t_u.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int n=arr.size();\n    std::vector<long>\
    \ temp(n);\n    for(int i=0;i<n;i++) temp[i]=arr[i];\n    std::sort(temp.begin(),temp.end());\n\
    \    int i=0;\n    while(i<n){\n        if(arr[i]==temp[i]) i++;\n        else{\n\
    \            if(arr[i]==temp[n-1]){\n                int j=i+1;\n            \
    \    while(j<n){\n                    if(arr[j]==temp[j]) j++;\n             \
    \       else break;\n                }\n                if(j==n) return true;\n\
    \                else return false;\n            }\n            else return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp5y3vlgp4: /tmp/tmp5y3vlgp4.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        else\n            max=arr[i];\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpzsg7x7mw: /tmp/tmpzsg7x7mw.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpmunzwstr: /tmp/tmpmunzwstr.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count==0)\n        return true;\n    if(count>1)\n        return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    int n = arr.size();\n    if(n == 0)\n        return true;\n    int i\
    \ = 0;\n    while(i < n - 1) {\n        if(arr[i] > arr[i + 1])\n            break;\n\
    \        i++;\n    }\n    if(i == n - 1)\n        return true;\n    int j = i\
    \ + 1;\n    while(j < n - 1) {\n        if(arr[j] < arr[j + 1])\n            break;\n\
    \        j++;\n    }\n    if(j == n - 1)\n        return true;\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpfhd5uahh: /tmp/tmpfhd5uahh.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tlong max = arr[0];\n\t\
    for (int i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < max) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t\tmax = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n   \
    \ auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp25jwv_j4: /tmp/tmp25jwv_j4.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp8lv6mwyi: /tmp/tmp8lv6mwyi.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    std::vector<long> sorted_arr=arr;\n\
    \    std::sort(sorted_arr.begin(),sorted_arr.end());\n    for(int i=0;i<arr.size();i++){\n\
    \        if(arr[i]!=sorted_arr[i]) return false;\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp5y7ln3kx: /tmp/tmp5y7ln3kx.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size()==0)\n    return true;\n  int i=0;\n  while(i<arr.size()-1){\n\
    \    if(arr[i]>arr[i+1])\n      break;\n    i++;\n  }\n  if(i==arr.size()-1)\n\
    \    return true;\n  int j=i+1;\n  while(j<arr.size()-1){\n    if(arr[j]<arr[j+1])\n\
    \      return false;\n    j++;\n  }\n  return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpnm05p8p6: /tmp/tmpnm05p8p6.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    else\n        return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp6mrh_y9f: /tmp/tmp6mrh_y9f.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpccto_3dp: /tmp/tmpccto_3dp.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // your code here\n    if(arr.size()==0)\n        return true;\n    int\
    \ i=0;\n    for(i=0;i<arr.size()-1;i++)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            break;\n    }\n    if(i==arr.size()-1)\n        return true;\n  \
    \  for(int j=i+1;j<arr.size();j++)\n    {\n        if(arr[j]<arr[i])\n       \
    \     return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpwbhqywdg: /tmp/tmpwbhqywdg.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpatwksxpb: /tmp/tmpatwksxpb.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ min=arr[0];\n    for(int i=1;i<n;i++){\n        if(arr[i]<min)\n           \
    \ return false;\n        if(arr[i]>min)\n            min=arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp0yw7poux: /tmp/tmp0yw7poux.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    int j=n-1;\n    while(i<n-1 && arr[i]<arr[i+1])\n        i++;\n  \
    \  while(j>0 && arr[j]>arr[j-1])\n        j--;\n    if(i==n-1)\n        return\
    \ true;\n    if(j==0)\n        return false;\n    if(i==j)\n        return true;\n\
    \    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n   \
    \ assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpfln7npr0: /tmp/tmpfln7npr0.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size() == 0)\n        return true;\n    long max = arr[0];\n \
    \   for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < max)\n        \
    \    return false;\n        max = arr[i];\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp41cwrb9s: /tmp/tmp41cwrb9s.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate()\n   \
    \ // Hint: You can use std::is_sorted()\n    // Hint: You can use std::next_permutation()\n\
    \    // Hint: You can use std::prev_permutation()\n    // Hint: You can use std::sort()\n\
    \    // Hint: You can use std::reverse()\n    // Hint: You can use std::rotate()\n\
    \    // Hint: You can use std::is_sorted()\n    // Hint: You can use std::next_permutation()\n\
    \    // Hint: You can use std::prev_permutation()\n    // Hint: You can use std::sort()\n\
    \    // Hint: You can use std::reverse()\n    // Hint: You can use std::rotate()\n\
    \    // Hint: You can use std::is_sorted()\n    // Hint: You can use std::next_permutation()\n\
    \    // Hint: You can use std::prev_permutation()\n    // Hint: You can use std::sort()\n\
    \    // Hint: You can use std::reverse()\n    // Hint: You can use std::rotate()\n\
    \    // Hint: You can use std::is_sorted()\n    // Hint: You can use std::next_permutation()\n\
    \    // Hint: You can use std::prev_permutation()\n    // Hint: You can use std::sort()\n\
    \    // Hint: You can use std::reverse()\n    // Hint: You can use std::rotate()\n\
    \    // Hint: You can use std::is_sorted()\n    // Hint: You can use std::next_permutation()\n\
    \    // Hint: You can use std::prev_permutation()\n    // Hint: You can use std::sort()\n\
    \    // Hint: You can use std::reverse()\n    // Hint: You can use std::rotate()\n\
    \    // Hint: You can use std::is_sorted()\n    // Hint: You can use std::next_permutation()\n\
    \    // Hint: You can use std::prev_permutation()\n    //\n}\nint main() {\n \
    \   auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp_40nlm7v: /tmp/tmp_40nlm7v.cpp:62: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) return true;\n\tlong max = arr[0];\n\tfor (int i =\
    \ 1; i < arr.size(); i++) {\n\t\tif (arr[i] < max) return false;\n\t\tif (arr[i]\
    \ > max) max = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp1ki_e75k: /tmp/tmp1ki_e75k.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::sort(arr.begin(),arr.end());\n\
    \    for(int i=0;i<arr.size()-1;i++)\n    {\n        if(arr[i]==arr[i+1])\n  \
    \          return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpi0u42uqo: /tmp/tmpi0u42uqo.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate() function.\n\
    \    // Hint: You can use std::is_sorted() function.\n    if(arr.size()==0)\n\
    \        return true;\n    for(int i=0;i<arr.size();i++){\n        std::rotate(arr.begin(),arr.begin()+1,arr.end());\n\
    \        if(std::is_sorted(arr.begin(),arr.end()))\n            return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1]) return false;\n        i++;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpq152ijsd: /tmp/tmpq152ijsd.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        if(arr[i]<arr[i-1])\n            min=arr[i];\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp_t_g8ne6: /tmp/tmp_t_g8ne6.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> sorted_arr(arr);\n\
    \    std::sort(sorted_arr.begin(),sorted_arr.end());\n    int count=0;\n    for(int\
    \ i=0;i<arr.size();i++){\n        if(arr[i]!=sorted_arr[i])\n            count++;\n\
    \    }\n    if(count==1)\n        return true;\n    return false;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpf16yzirp: /tmp/tmpf16yzirp.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpz_fsyvnx: /tmp/tmpz_fsyvnx.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use std::cout\n    // Example: std::cout << \"Hello world!\";\n    int\
    \ n = arr.size();\n    if(n==0)\n        return true;\n    int min = arr[0];\n\
    \    for(int i=1;i<n;i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpxzrx2_kt: /tmp/tmpxzrx2_kt.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ max=arr[0];\n    for(int i=1;i<n;i++){\n        if(arr[i]<max)\n           \
    \ return false;\n        if(arr[i]>max)\n            max=arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpiqsrelsp: /tmp/tmpiqsrelsp.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use std::cout\n    // Example: std::cout << \"Hello world!\";\n    int\
    \ n = arr.size();\n    if(n == 0) return true;\n    if(n == 1) return true;\n\
    \    int count = 0;\n    for(int i = 0; i < n - 1; i++){\n        if(arr[i] >\
    \ arr[i + 1]){\n            count++;\n        }\n    }\n    if(count > 1) return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    int j=n-1;\n    while(i<j)\n    {\n        if(arr[i]<arr[j])\n   \
    \         return false;\n        i++;\n        j--;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpnlmgxj4e: /tmp/tmpnlmgxj4e.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n            return false;\n\
    \        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpd9bn_ggi: /tmp/tmpd9bn_ggi.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    long min=arr[0];\n    for(int i=1;i<arr.size();i++){\n\
    \        if(arr[i]<min) return false;\n        min=arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpbmb91f5x: /tmp/tmpbmb91f5x.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> v;\n \
    \   for(int i=0;i<arr.size();i++)\n        v.push_back(arr[i]);\n    std::sort(v.begin(),v.end());\n\
    \    for(int i=0;i<arr.size();i++)\n        if(arr[i]!=v[i])\n            return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpj0_okh9z: /tmp/tmpj0_okh9z.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int count = 0;\n    for(int i=0;i<arr.size()-1;i++){\n\
    \        if(arr[i]>arr[i+1]){\n            count++;\n        }\n    }\n    if(count>1)\
    \ return false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tlong max = arr[0];\n\t\
    for (int i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < max) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t\telse {\n\t\t\tmax = arr[i];\n\t\t}\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpek_xvd33: /tmp/tmpek_xvd33.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // your code here\n    if(arr.size()==0)\n        return true;\n    long\
    \ min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmplrtt06qo: /tmp/tmplrtt06qo.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use cout\n    // Example: cout << \"Hello world!\";\n    if(arr.size()==0)\n\
    \    {\n        return true;\n    }\n    int i=0;\n    int j=1;\n    while(j<arr.size())\n\
    \    {\n        if(arr[i]<=arr[j])\n        {\n            i++;\n            j++;\n\
    \        }\n        else\n        {\n            return false;\n        }\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpw3s98z42: /tmp/tmpw3s98z42.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp=arr;\n\
    \    std::sort(temp.begin(),temp.end());\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=temp[i])\n            return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpqfdugsrw: /tmp/tmpqfdugsrw.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use std::cout\n    // Example: std::cout << \"Hello world!\";\n    if(arr.size()==0)\n\
    \        return true;\n    std::vector<long> temp(arr.size());\n    for(int i=0;i<arr.size();i++)\n\
    \        temp[i]=arr[i];\n    std::sort(temp.begin(),temp.end());\n    for(int\
    \ i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=temp[i])\n            return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpalo7texd: /tmp/tmpalo7texd.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use std::cout\n    // Example: std::cout << \"Hello world!\";\n    if(arr.size()==0)\n\
    \        return true;\n    int n=arr.size();\n    int count=0;\n    for(int i=0;i<n-1;i++)\n\
    \    {\n        if(arr[i]>arr[i+1])\n            count++;\n    }\n    if(count>1)\n\
    \        return false;\n    else\n        return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp_b0fghss: /tmp/tmp_b0fghss.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n            return false;\n\
    \        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpx3iv_66u: /tmp/tmpx3iv_66u.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> v;\n \
    \   for(int i=0;i<arr.size();i++)\n        v.push_back(arr[i]);\n    std::sort(v.begin(),v.end());\n\
    \    for(int i=0;i<arr.size();i++)\n        if(arr[i]!=v[i])\n            return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpbnioldhj: /tmp/tmpbnioldhj.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpn94q_rn2: /tmp/tmpn94q_rn2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    int n = arr.size();\n    if(n == 0)\n        return true;\n    int count\
    \ = 0;\n    for(int i = 0; i < n - 1; i++) {\n        if(arr[i] > arr[i + 1])\n\
    \            count++;\n    }\n    if(count > 1)\n        return false;\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(long\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        max=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpteiifm5n: /tmp/tmpteiifm5n.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n            return false;\n\
    \        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpfozvh6j5: /tmp/tmpfozvh6j5.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        if(arr[i]>min)\n            min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp_xl5n4oc: /tmp/tmp_xl5n4oc.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    for(int i=0;i<arr.size()-1;i++){\n\
    \        if(arr[i]>arr[i+1]) return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp2ordofa5: /tmp/tmp2ordofa5.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp=arr;\n\
    \    std::sort(temp.begin(),temp.end());\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=temp[i])\n            return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpxn1qzql0: /tmp/tmpxn1qzql0.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    if(arr.size()==0)\n        return true;\n\
    \    int i=0;\n    int j=arr.size()-1;\n    while(i<j)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            return false;\n        if(arr[j]<arr[j-1])\n            return false;\n\
    \        i++;\n        j--;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpy909_nv7: /tmp/tmpy909_nv7.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    if(arr.size()==0)\n        return true;\n\
    \    long min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpi82mdzd_: /tmp/tmpi82mdzd_.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tlong min = arr[0];\n\t\
    for (int i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < min) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t\tmin = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n   \
    \ auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmplvq6brt8: /tmp/tmplvq6brt8.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size()==0)\n    return true;\n  long min=arr[0];\n  for(int i=1;i<arr.size();i++){\n\
    \    if(arr[i]<min)\n      return false;\n    min=arr[i];\n  }\n  return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp0xiag0hf: /tmp/tmp0xiag0hf.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmppk5fs2p8: /tmp/tmppk5fs2p8.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int count=0;\n    for(int i=0;i<arr.size()-1;i++){\n\
    \        if(arr[i]>arr[i+1]){\n            count++;\n        }\n    }\n    if(count==1)\
    \ return true;\n    else return false;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    if(arr.size()==0)\n        return true;\n\
    \    std::vector<long> temp;\n    for(int i=0;i<arr.size();i++)\n        temp.push_back(arr[i]);\n\
    \    std::sort(temp.begin(),temp.end());\n    int count=0;\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=temp[i])\n            count++;\n    }\n    if(count==1)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp9gb5t5e1: /tmp/tmp9gb5t5e1.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpt3gel3hz: /tmp/tmpt3gel3hz.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp;\n\
    \    for(int i=0;i<arr.size();i++)\n        temp.push_back(arr[i]);\n    std::sort(temp.begin(),temp.end());\n\
    \    for(int i=0;i<arr.size();i++)\n        if(arr[i]!=temp[i])\n            return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpkqge75op: /tmp/tmpkqge75op.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate() to rotate\
    \ the elements of the vector.\n    // Hint: You can use std::is_sorted() to check\
    \ if the vector is sorted.\n    // Hint: You can use std::prev_permutation() to\
    \ get the previous permutation\n    // of the vector.\n    // Hint: You can use\
    \ std::next_permutation() to get the next permutation\n    // of the vector.\n\
    \    // Hint: You can use std::sort() to sort the vector.\n    // Hint: You can\
    \ use std::reverse() to reverse the vector.\n    // Hint: You can use std::swap()\
    \ to swap the elements of the vector.\n    // Hint: You can use std::min_element()\
    \ to get the minimum element of the\n    // vector.\n    // Hint: You can use\
    \ std::max_element() to get the maximum element of the\n    // vector.\n    //\
    \ Hint: You can use std::find() to find the index of an element in the\n    //\
    \ vector.\n    // Hint: You can use std::count() to count the number of occurences\
    \ of an\n    // element in the vector.\n    // Hint: You can use std::lower_bound()\
    \ to get the index of the first\n    // occurence of an element in the vector.\n\
    \    // Hint: You can use std::upper_bound() to get the index of the last\n  \
    \  // occurence of an element in the vector.\n    // Hint: You can use std::unique()\
    \ to remove the duplicate elements from the\n    // vector.\n    // Hint: You\
    \ can use std::accumulate() to get the sum of the elements of the\n    // vector.\n\
    \    // Hint: You can use std::inner_product() to get the dot product of the\n\
    \    // vectors.\n    // Hint: You can use std::partial_sum() to get the partial\
    \ sum of the\n    // elements of the vector.\n    // Hint: You can use std::transform()\
    \ to apply a function to the elements of\n    // the vector.\n    // Hint: You\
    \ can use std::for_each() to apply a function to the elements of\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpw7jfy7bf: /tmp/tmpw7jfy7bf.cpp:59: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size()==0) return true;\n  long min=arr[0];\n  for(int i=1;i<arr.size();i++){\n\
    \    if(arr[i]<min) return false;\n    min=arr[i];\n  }\n  return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp0qfc30ru: /tmp/tmp0qfc30ru.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1]){\n            return false;\n        }\n        i++;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpbz9820jn: /tmp/tmpbz9820jn.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tlong min = arr[0];\n\tfor (int\
    \ i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < min)\n\t\t\treturn false;\n\t\
    \tmin = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpps5j0dpa: /tmp/tmpps5j0dpa.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpmyw9wlhh: /tmp/tmpmyw9wlhh.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp;\n\
    \    for(int i=0;i<arr.size();i++)\n        temp.push_back(arr[i]);\n    std::sort(temp.begin(),temp.end());\n\
    \    int count=0;\n    for(int i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=temp[i])\n\
    \            count++;\n    }\n    if(count==1)\n        return true;\n    else\n\
    \        return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpn3x3vx5c: /tmp/tmpn3x3vx5c.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    std::vector<long> sorted_arr=arr;\n\
    \    std::sort(sorted_arr.begin(),sorted_arr.end());\n    int count=0;\n    for(int\
    \ i=0;i<arr.size();i++){\n        if(arr[i]!=sorted_arr[i]) count++;\n    }\n\
    \    if(count==1) return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmprkk2ylbs: /tmp/tmprkk2ylbs.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use Printf\n    // Example: Printf(\"%s\", \"Hello world!\");\n    if(arr.size()==0)\n\
    \        return true;\n    for(int i=0;i<arr.size()-1;i++)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpu8pscd6c: /tmp/tmpu8pscd6c.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use std::cout\n    // Example: std::cout << \"Hello world!\";\n    if(arr.size()==0)\n\
    \        return true;\n    int count=0;\n    for(int i=0;i<arr.size()-1;i++)\n\
    \    {\n        if(arr[i]>arr[i+1])\n            count++;\n    }\n    if(count==0)\n\
    \        return true;\n    else if(count==1)\n        return true;\n    else\n\
    \        return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int min=arr[0];\n    for(int i=1;i<arr.size();i++){\n\
    \        if(arr[i]<min) return false;\n        if(arr[i]<arr[i-1]) min=arr[i];\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp0donflbg: /tmp/tmp0donflbg.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // your code here\n    if(arr.size()==0)\n        return true;\n    int\
    \ count=0;\n    for(int i=0;i<arr.size()-1;i++)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            count++;\n    }\n    if(count>1)\n        return false;\n    else\n\
    \        return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpytygszqx: /tmp/tmpytygszqx.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp=arr;\n\
    \    std::sort(temp.begin(),temp.end());\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=temp[i])\n            return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp3yo_e7ci: /tmp/tmp3yo_e7ci.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    for(int i=0;i<arr.size()-1;i++){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpnvfvof3d: /tmp/tmpnvfvof3d.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp1vbxt7to: /tmp/tmp1vbxt7to.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tint count = 0;\n\tfor\
    \ (int i = 0; i < arr.size() - 1; i++) {\n\t\tif (arr[i] > arr[i + 1]) {\n\t\t\
    \tcount++;\n\t\t}\n\t}\n\tif (count > 1) {\n\t\treturn false;\n\t}\n\telse {\n\
    \t\treturn true;\n\t}\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\t// Write your code here\n\t// Hint: You can use std::rotate() function\
    \ to perform right shift operation.\n\t// Hint: You can use std::is_sorted() function\
    \ to check if the array is sorted\n\t// in non-decreasing order.\n\t// Hint: You\
    \ can use std::next_permutation() function to generate all\n\t// permutations\
    \ of the given array.\n\t// Hint: You can use std::sort() function to sort the\
    \ given array.\n\t// Hint: You can use std::reverse() function to reverse the\
    \ given array.\n\t// Hint: You can use std::prev_permutation() function to generate\
    \ all\n\t// permutations of the given array in reverse order.\n\t// Hint: You\
    \ can use std::equal() function to check if two arrays are equal.\n\t// Hint:\
    \ You can use std::swap() function to swap two elements of the array.\n\t// Hint:\
    \ You can use std::copy() function to copy elements of one array to\n\t// another\
    \ array.\n\t// Hint: You can use std::rotate_copy() function to copy elements\
    \ of one\n\t// array to another array after performing right shift operation.\n\
    \t// Hint: You can use std::unique() function to remove duplicate elements from\n\
    \t// the array.\n\t// Hint: You can use std::unique_copy() function to copy elements\
    \ of one\n\t// array to another array after removing duplicate elements.\n\t//\
    \ Hint: You can use std::rotate_copy() function to copy elements of one\n\t//\
    \ array to another array after performing right shift operation.\n\t// Hint: You\
    \ can use std::rotate_copy() function to copy elements of one\n\t// array to another\
    \ array after performing right shift operation.\n\t// Hint: You can use std::rotate_copy()\
    \ function to copy elements of one\n\t// array to another array after performing\
    \ right shift operation.\n\t// Hint: You can use std::rotate_copy() function to\
    \ copy elements of one\n\t// array to another array after performing right shift\
    \ operation.\n\t// Hint: You can use std::rotate_copy() function to copy elements\
    \ of one\n\t// array to another array after performing right shift operation.\n\
    \t// Hint:\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpbxvfj2em: /tmp/tmpbxvfj2em.cpp:57: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpqqq_wkbv: /tmp/tmpqqq_wkbv.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate()\n   \
    \ if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int i=1;i<arr.size();i++)\n\
    \    {\n        if(arr[i]<min)\n            return false;\n        min=arr[i];\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpadjc1yr2: /tmp/tmpadjc1yr2.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    for(int i=0;i<arr.size()-1;i++){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpg3jo4oqz: /tmp/tmpg3jo4oqz.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    if(arr.size()==0)\n        return true;\n\
    \    int i,j;\n    for(i=0;i<arr.size()-1;i++)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            break;\n    }\n    for(j=i+1;j<arr.size()-1;j++)\n    {\n       \
    \ if(arr[j]>arr[j+1])\n            return false;\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp_h13umcq: /tmp/tmp_h13umcq.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    if(arr.size()==0)\n        return true;\n\
    \    int i=0;\n    while(i<arr.size()-1){\n        if(arr[i]>arr[i+1])\n     \
    \       return false;\n        i++;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmphksm4n9a: /tmp/tmphksm4n9a.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate()\n   \
    \ if(arr.size()==0)\n        return true;\n    for(int i=0;i<arr.size();i++){\n\
    \        std::rotate(arr.begin(),arr.begin()+1,arr.end());\n        if(std::is_sorted(arr.begin(),arr.end()))\n\
    \            return true;\n    }\n    return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n            return false;\n\
    \        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmptu6rj7q6: /tmp/tmptu6rj7q6.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    int j=n-1;\n    while(i<j){\n        if(arr[i]>arr[j])\n         \
    \   return false;\n        i++;\n        j--;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpaexw_iah: /tmp/tmpaexw_iah.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpya0zr6pn: /tmp/tmpya0zr6pn.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    std::vector<long> temp;\n    for(int\
    \ i=0;i<arr.size();i++){\n        temp.push_back(arr[i]);\n    }\n    std::sort(temp.begin(),temp.end());\n\
    \    for(int i=0;i<arr.size();i++){\n        if(arr[i]!=temp[i]) return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp52wzcg8y: /tmp/tmp52wzcg8y.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    if(arr.size()==0)\n        return true;\n\
    \    int n=arr.size();\n    int min=arr[0];\n    for(int i=1;i<n;i++)\n    {\n\
    \        if(arr[i]<min)\n            return false;\n        min=arr[i];\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpip_z169u: /tmp/tmpip_z169u.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(long\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpctnyncmg: /tmp/tmpctnyncmg.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate()\n   \
    \ // Hint: You can use std::is_sorted()\n    if(arr.size()==0)\n        return\
    \ true;\n    for(int i=0;i<arr.size();i++){\n        std::rotate(arr.begin(),arr.begin()+1,arr.end());\n\
    \        if(std::is_sorted(arr.begin(),arr.end()))\n            return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // your code here\n    if(arr.size()==0)\n        return true;\n    std::vector<long>\
    \ arr1=arr;\n    std::sort(arr1.begin(),arr1.end());\n    int count=0;\n    for(int\
    \ i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=arr1[i])\n            count++;\n\
    \    }\n    if(count==1)\n        return true;\n    else\n        return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpqi47vvsm: /tmp/tmpqi47vvsm.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpjv0p1n8z: /tmp/tmpjv0p1n8z.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    long min=arr[0];\n    for(int i=1;i<arr.size();i++){\n\
    \        if(arr[i]<min) return false;\n        min=arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpu526hegx: /tmp/tmpu526hegx.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int n=arr.size();\n    int min=arr[0];\n\
    \    for(int i=1;i<n;i++){\n        if(arr[i]<min) return false;\n        if(arr[i]>min)\
    \ min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpond37xvj: /tmp/tmpond37xvj.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate() to rotate\
    \ the elements of the vector.\n    // Hint: You can use std::is_sorted() to check\
    \ if the vector is sorted or not.\n    if(arr.size()==0)\n        return true;\n\
    \    for(int i=0;i<arr.size();i++){\n        std::rotate(arr.begin(),arr.begin()+1,arr.end());\n\
    \        if(std::is_sorted(arr.begin(),arr.end()))\n            return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    long max=arr[0];\n    for(int i=1;i<arr.size();i++){\n\
    \        if(arr[i]<max) return false;\n        if(arr[i]>max) max=arr[i];\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpbv4vuvt_: /tmp/tmpbv4vuvt_.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tlong max = arr[0];\n\tfor (long\
    \ i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < max)\n\t\t\treturn false;\n\t\
    \telse\n\t\t\tmax = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpa_eya20x: /tmp/tmpa_eya20x.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpzxituiv3: /tmp/tmpzxituiv3.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> sorted_arr=arr;\n\
    \    std::sort(sorted_arr.begin(),sorted_arr.end());\n    int count=0;\n    for(int\
    \ i=0;i<arr.size();i++){\n        if(arr[i]!=sorted_arr[i])\n            count++;\n\
    \    }\n    if(count==1)\n        return true;\n    return false;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp1fxghlei: /tmp/tmp1fxghlei.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpklbwp76k: /tmp/tmpklbwp76k.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp=arr;\n\
    \    std::sort(temp.begin(),temp.end());\n    int count=0;\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=temp[i])\n            count++;\n    }\n    if(count==1)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmph0akxmuq: /tmp/tmph0akxmuq.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    else\n        return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  // your code here\n  if(arr.size()==0)\n    return true;\n  int i=0;\n\
    \  while(i<arr.size()-1){\n    if(arr[i]>arr[i+1])\n      return false;\n    i++;\n\
    \  }\n  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n \
    \   assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp7cy0uelb: /tmp/tmp7cy0uelb.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> v;\n \
    \   for(int i=0;i<arr.size();i++)\n        v.push_back(arr[i]);\n    std::sort(v.begin(),v.end());\n\
    \    for(int i=0;i<arr.size();i++)\n        if(arr[i]!=v[i])\n            return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp3wa5t8i0: /tmp/tmp3wa5t8i0.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    std::vector<long> arr2=arr;\n   \
    \ std::sort(arr2.begin(),arr2.end());\n    for(int i=0;i<arr.size();i++){\n  \
    \      if(arr[i]!=arr2[i]) return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpnd0kmu0n: /tmp/tmpnd0kmu0n.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp_8nyu6ve: /tmp/tmp_8nyu6ve.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int n=arr.size();\n    int i=0;\n\
    \    while(i<n-1){\n        if(arr[i]>arr[i+1]) break;\n        i++;\n    }\n\
    \    int j=i+1;\n    while(j<n-1){\n        if(arr[j]>arr[j+1]) return false;\n\
    \        j++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    std::vector<long>\
    \ v(n);\n    for(int i=0;i<n;i++)\n        v[i]=arr[i];\n    std::sort(v.begin(),v.end());\n\
    \    int count=0;\n    for(int i=0;i<n;i++)\n    {\n        if(arr[i]!=v[i])\n\
    \            count++;\n    }\n    if(count>2)\n        return false;\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp_objzb8l: /tmp/tmp_objzb8l.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp6sptrnum: /tmp/tmp6sptrnum.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        max=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmppzvyd1_k: /tmp/tmppzvyd1_k.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpdhf2b6qv: /tmp/tmpdhf2b6qv.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tstd::vector<long> sorted_arr\
    \ = arr;\n\tstd::sort(sorted_arr.begin(), sorted_arr.end());\n\tlong count = 0;\n\
    \tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] != sorted_arr[i]) {\n\
    \t\t\tcount++;\n\t\t}\n\t}\n\tif (count == 1) {\n\t\treturn true;\n\t}\n\treturn\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmprz175i7t: /tmp/tmprz175i7t.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tint count = 0;\n\tfor\
    \ (int i = 0; i < arr.size() - 1; i++) {\n\t\tif (arr[i] > arr[i + 1]) {\n\t\t\
    \tcount++;\n\t\t}\n\t}\n\tif (count > 1) {\n\t\treturn false;\n\t}\n\telse {\n\
    \t\treturn true;\n\t}\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // your code here\n    if(arr.size()==0)\n        return true;\n    int\
    \ max=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<max)\n\
    \            return false;\n        else\n            max=arr[i];\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpiqnubtbn: /tmp/tmpiqnubtbn.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    std::vector<long> sorted_arr=arr;\n\
    \    std::sort(sorted_arr.begin(),sorted_arr.end());\n    int count=0;\n    for(int\
    \ i=0;i<arr.size();i++){\n        if(arr[i]!=sorted_arr[i]) count++;\n    }\n\
    \    if(count==1) return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp273iag6r: /tmp/tmp273iag6r.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        if(arr[i]<arr[i-1])\n            min=arr[i];\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpojzcv3fg: /tmp/tmpojzcv3fg.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpvw4bzctb: /tmp/tmpvw4bzctb.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ count=0;\n    for(int i=0;i<n-1;i++){\n        if(arr[i]>arr[i+1])\n       \
    \     count++;\n    }\n    if(count>1)\n        return false;\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tstd::vector<long> arr_copy\
    \ = arr;\n\tstd::sort(arr_copy.begin(), arr_copy.end());\n\tint count = 0;\n\t\
    for (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] != arr_copy[i]) {\n\t\t\
    \tcount++;\n\t\t}\n\t}\n\tif (count > 2) {\n\t\treturn false;\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp15w3yf_u: /tmp/tmp15w3yf_u.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int n=arr.size();\n    int count=0;\n\
    \    for(int i=0;i<n-1;i++){\n        if(arr[i]>arr[i+1]) count++;\n    }\n  \
    \  if(count>1) return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n            return false;\n\
    \        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpoq3z3yr8: /tmp/tmpoq3z3yr8.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp;\n\
    \    for(int i=0;i<arr.size();i++)\n        temp.push_back(arr[i]);\n    std::sort(temp.begin(),temp.end());\n\
    \    for(int i=0;i<arr.size();i++)\n        if(arr[i]!=temp[i])\n            return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpxatviaxx: /tmp/tmpxatviaxx.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp=arr;\n\
    \    std::sort(temp.begin(),temp.end());\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=temp[i])\n            return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpifabkoku: /tmp/tmpifabkoku.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tlong min = arr[0];\n\tfor (int\
    \ i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < min)\n\t\t\treturn false;\n\t\
    \tmin = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpw_iu37vw: /tmp/tmpw_iu37vw.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> arr1=arr;\n\
    \    std::sort(arr1.begin(),arr1.end());\n    int count=0;\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=arr1[i])\n            count++;\n    }\n    if(count==1)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpb3bk58s6: /tmp/tmpb3bk58s6.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        if(arr[i]>min)\n            min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmprvh7wlq3: /tmp/tmprvh7wlq3.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size()==0)\n    return true;\n  int count=0;\n  for(int i=0;i<arr.size()-1;i++){\n\
    \    if(arr[i]>arr[i+1])\n      count++;\n  }\n  if(count>1)\n    return false;\n\
    \  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size()==0) return true;\n  for(int i=0;i<arr.size()-1;i++){\n  \
    \  if(arr[i]>arr[i+1]) return false;\n  }\n  return true;\n}\nint main() {\n \
    \   auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmphbesw1rh: /tmp/tmphbesw1rh.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int n=arr.size();\n    for(int i=0;i<n-1;i++){\n\
    \        if(arr[i]>arr[i+1]) return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmptrmamjrv: /tmp/tmptrmamjrv.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size()==0) return true;\n  std::vector<long> temp;\n  temp=arr;\n\
    \  std::sort(temp.begin(),temp.end());\n  int count=0;\n  for(int i=0;i<arr.size();i++){\n\
    \    if(arr[i]!=temp[i]) count++;\n  }\n  if(count==1) return true;\n  else return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp4qi6nlw3: /tmp/tmp4qi6nlw3.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::sort(arr.begin(),arr.end());\n\
    \    for(int i=0;i<arr.size()-1;i++)\n        if(arr[i]>arr[i+1])\n          \
    \  return false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpq04cgi_0: /tmp/tmpq04cgi_0.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tint count = 0;\n\tfor (int i\
    \ = 0; i < arr.size() - 1; i++) {\n\t\tif (arr[i] > arr[i + 1])\n\t\t\tcount++;\n\
    \t}\n\tif (count > 1)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size()==0)\n    return true;\n  int count=0;\n  for(int i=0;i<arr.size()-1;i++){\n\
    \    if(arr[i]>arr[i+1])\n      count++;\n  }\n  if(count==0)\n    return true;\n\
    \  else if(count==1)\n    return true;\n  else\n    return false;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n            return false;\n\
    \        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpg0pmm1pu: /tmp/tmpg0pmm1pu.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  if(arr.size() == 0) return true;\n  for(int i = 0; i < arr.size() - 1;\
    \ i++) {\n    if(arr[i] > arr[i + 1]) return false;\n  }\n  return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpi78pypar: /tmp/tmpi78pypar.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpi1i6okp2: /tmp/tmpi1i6okp2.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    int n = arr.size();\n    if(n == 0) return true;\n    int min = arr[0];\n\
    \    for(int i = 1; i < n; i++) {\n        if(arr[i] < min) return false;\n  \
    \      min = std::min(min, arr[i]);\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4hobze1x.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp4hobze1x.cpp:28:23: error: no matching function for call\
    \ to \u2018min(int&, __gnu_cxx::__alloc_traits<std::allocator<long int>, long\
    \ int>::value_type&)\u2019\n   28 |         min = std::min(min, arr[i]);\n   \
    \   |               ~~~~~~~~^~~~~~~~~~~~~\nIn file included from /usr/include/c++/11/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/11/cmath:1935,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/11/bits/stdc++.h:41,\n                 from\
    \ /tmp/tmp4hobze1x.cpp:2:\n/usr/include/c++/11/bits/stl_algobase.h:230:5: note:\
    \ candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&,\
    \ const _Tp&)\u2019\n  230 |     min(const _Tp& __a, const _Tp& __b)\n      |\
    \     ^~~\n/usr/include/c++/11/bits/stl_algobase.h:230:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp4hobze1x.cpp:28:23: note:   deduced\
    \ conflicting types for parameter \u2018const _Tp\u2019 (\u2018int\u2019 and \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   28 |         min = std::min(min, arr[i]);\n\
    \      |               ~~~~~~~~^~~~~~~~~~~~~\nIn file included from /usr/include/c++/11/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/11/cmath:1935,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/11/bits/stdc++.h:41,\n                 from\
    \ /tmp/tmp4hobze1x.cpp:2:\n/usr/include/c++/11/bits/stl_algobase.h:278:5: note:\
    \ candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const\
    \ _Tp&, const _Tp&, _Compare)\u2019\n  278 |     min(const _Tp& __a, const _Tp&\
    \ __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/11/bits/stl_algobase.h:278:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp4hobze1x.cpp:28:23:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    int\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   28 |         min = std::min(min, arr[i]);\n\
    \      |               ~~~~~~~~^~~~~~~~~~~~~\nIn file included from /us"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tint n = arr.size();\n\t\
    int count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] == i + 1) {\n\t\
    \t\tcount++;\n\t\t}\n\t}\n\tif (count == n) {\n\t\treturn true;\n\t}\n\telse {\n\
    \t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpkp0exio8: /tmp/tmpkp0exio8.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate() function\n\
    \    // Hint: You can use std::is_sorted() function\n    // Hint: You can use\
    \ std::next_permutation() function\n    // Hint: You can use std::prev_permutation()\
    \ function\n    // Hint: You can use std::sort() function\n    // Hint: You can\
    \ use std::reverse() function\n    // Hint: You can use std::rotate() function\n\
    \    // Hint: You can use std::is_sorted() function\n    // Hint: You can use\
    \ std::next_permutation() function\n    // Hint: You can use std::prev_permutation()\
    \ function\n    // Hint: You can use std::sort() function\n    // Hint: You can\
    \ use std::reverse() function\n    // Hint: You can use std::rotate() function\n\
    \    // Hint: You can use std::is_sorted() function\n    // Hint: You can use\
    \ std::next_permutation() function\n    // Hint: You can use std::prev_permutation()\
    \ function\n    // Hint: You can use std::sort() function\n    // Hint: You can\
    \ use std::reverse() function\n    // Hint: You can use std::rotate() function\n\
    \    // Hint: You can use std::is_sorted() function\n    // Hint: You can use\
    \ std::next_permutation() function\n    // Hint: You can use std::prev_permutation()\
    \ function\n    // Hint: You can use std::sort() function\n    // Hint: You can\
    \ use std::reverse() function\n    // Hint: You can use std::rotate() function\n\
    \    // Hint: You can use std::is_sorted() function\n    // Hint: You can use\
    \ std::next_permutation() function\n    // Hint: You can use std::prev_permutation()\
    \ function\n    // Hint: You can use std::sort() function\n    // Hint: You can\
    \ use std::reverse() function\n    // Hint: You can use std::rotate() function\n\
    \    // Hint: You can use std::is_sorted() function\n    //\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp_g8hcna4: /tmp/tmp_g8hcna4.cpp:60: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tint count = 0;\n\tfor\
    \ (int i = 0; i < arr.size() - 1; i++) {\n\t\tif (arr[i] > arr[i + 1]) {\n\t\t\
    \tcount++;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn true;\n\t}\n\telse if\
    \ (count == 1) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmptauua52n: /tmp/tmptauua52n.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpl652lnub: /tmp/tmpl652lnub.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpthgrxz3y: /tmp/tmpthgrxz3y.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tint i = 0;\n\twhile (i < arr.size()\
    \ - 1) {\n\t\tif (arr[i] > arr[i + 1])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i ==\
    \ arr.size() - 1)\n\t\treturn true;\n\tint j = i + 1;\n\twhile (j < arr.size()\
    \ - 1) {\n\t\tif (arr[j] < arr[j + 1])\n\t\t\treturn false;\n\t\tj++;\n\t}\n\t\
    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpx16m_ihg: /tmp/tmpx16m_ihg.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    for(int\
    \ i=0;i<n-1;i++){\n        if(arr[i]>arr[i+1])\n            return false;\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpl708dsl1: /tmp/tmpl708dsl1.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        if(arr[i]>max)\n            max=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp57wfgs4_: /tmp/tmp57wfgs4_.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tlong max = arr[0];\n\t\
    for (int i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < max) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t\telse {\n\t\t\tmax = arr[i];\n\t\t}\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp6ycrltg7: /tmp/tmp6ycrltg7.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> v;\n \
    \   for(long i=0;i<arr.size();i++)\n        v.push_back(arr[i]);\n    std::sort(v.begin(),v.end());\n\
    \    long count=0;\n    for(long i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=v[i])\n\
    \            count++;\n    }\n    if(count==1)\n        return true;\n    else\n\
    \        return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmppw1bkcpm: /tmp/tmppw1bkcpm.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) return true;\n\tlong min = arr[0];\n\tfor (int i =\
    \ 1; i < arr.size(); i++) {\n\t\tif (arr[i] < min) return false;\n\t\tmin = arr[i];\n\
    \t}\n\treturn true;\n}\nint main() {\n    auto candidate = move_one_ball;\n  \
    \  assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp70j4gkku: /tmp/tmp70j4gkku.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> arr1=arr;\n\
    \    std::sort(arr1.begin(),arr1.end());\n    long count=0;\n    for(long i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=arr1[i])\n            count++;\n    }\n    if(count==1)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpyh6az397: /tmp/tmpyh6az397.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp=arr;\n\
    \    std::sort(temp.begin(),temp.end());\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=temp[i])\n            return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpgj4lcd92: /tmp/tmpgj4lcd92.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate() function\
    \ to perform right shift operation.\n    // Hint: You can use std::is_sorted()\
    \ function to check if the array is sorted.\n    if(arr.size()==0)\n        return\
    \ true;\n    for(int i=0;i<arr.size();i++){\n        std::rotate(arr.begin(),arr.begin()+1,arr.end());\n\
    \        if(std::is_sorted(arr.begin(),arr.end()))\n            return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> temp;\n\
    \    temp=arr;\n    std::sort(temp.begin(),temp.end());\n    int count=0;\n  \
    \  for(int i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=temp[i])\n       \
    \     count++;\n    }\n    if(count==1)\n        return true;\n    else\n    \
    \    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n   \
    \ assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp_41p_251: /tmp/tmp_41p_251.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tfor (int i = 0; i < arr.size()\
    \ - 1; i++) {\n\t\tif (arr[i] > arr[i + 1])\n\t\t\treturn false;\n\t}\n\treturn\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmplnntw7xs: /tmp/tmplnntw7xs.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // To print results to the standard output\
    \ you can use std::cout\n    // Example: std::cout << \"Hello world!\";\n    int\
    \ n = arr.size();\n    if(n==0)\n        return true;\n    int i = 0;\n    while(i<n-1){\n\
    \        if(arr[i]>arr[i+1])\n            break;\n        i++;\n    }\n    if(i==n-1)\n\
    \        return true;\n    int j = i+1;\n    while(j<n-1){\n        if(arr[j]<arr[j+1])\n\
    \            return false;\n        j++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp4cxihbna: /tmp/tmp4cxihbna.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) return true;\n\tlong min = arr[0];\n\tfor (int i =\
    \ 1; i < arr.size(); i++) {\n\t\tif (arr[i] < min) return false;\n\t\tmin = arr[i];\n\
    \t}\n\treturn true;\n}\nint main() {\n    auto candidate = move_one_ball;\n  \
    \  assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp7id8lt3l: /tmp/tmp7id8lt3l.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmplri3gict: /tmp/tmplri3gict.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    // Write your code here\n    // Hint: You can use std::rotate()\n   \
    \ if(arr.size()==0)\n        return true;\n    std::sort(arr.begin(),arr.end());\n\
    \    for(int i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=i+1)\n         \
    \   return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp0bzpiycb: /tmp/tmp0bzpiycb.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpl83p8fjm: /tmp/tmpl83p8fjm.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n  // your code here\n  if(arr.size()==0)\n    return true;\n  long max=arr[0];\n\
    \  for(int i=1;i<arr.size();i++)\n  {\n    if(arr[i]<max)\n      return false;\n\
    \    else\n      max=arr[i];\n  }\n  return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp29hzexex: /tmp/tmp29hzexex.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> arr1=arr;\n\
    \    std::sort(arr1.begin(),arr1.end());\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]!=arr1[i])\n            return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpvdbzr_3e: /tmp/tmpvdbzr_3e.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpuj2g4ha_: /tmp/tmpuj2g4ha_.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tlong min = arr[0];\n\tfor (int\
    \ i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < min)\n\t\t\treturn false;\n\t\
    \tmin = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpdnv4_9m6: /tmp/tmpdnv4_9m6.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpwqftil6l: /tmp/tmpwqftil6l.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int n=arr.size();\n    int\
    \ min=arr[0];\n    for(int i=1;i<n;i++){\n        if(arr[i]<min)\n           \
    \ return false;\n        if(arr[i]>min)\n            min=arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpk81mlelk: /tmp/tmpk81mlelk.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    if(count>1)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpk4k9heph: /tmp/tmpk4k9heph.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0) return true;\n    int count=0;\n    for(int i=0;i<arr.size()-1;i++){\n\
    \        if(arr[i]>arr[i+1]) count++;\n    }\n    if(count>1) return false;\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> v;\n \
    \   for(int i=0;i<arr.size();i++)\n        v.push_back(arr[i]);\n    std::sort(v.begin(),v.end());\n\
    \    for(int i=0;i<arr.size();i++)\n        if(arr[i]!=v[i])\n            return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpn471lprs: /tmp/tmpn471lprs.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) return true;\n\tstd::vector<long> sorted_arr = arr;\n\
    \tstd::sort(sorted_arr.begin(), sorted_arr.end());\n\tint count = 0;\n\tfor (int\
    \ i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] != sorted_arr[i]) count++;\n\t\
    }\n\tif (count == 1) return true;\n\treturn false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpq42unjj4: /tmp/tmpq42unjj4.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long max=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<max)\n            return false;\n\
    \        max=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpw6nsytym: /tmp/tmpw6nsytym.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tstd::vector<long> sorted_arr\
    \ = arr;\n\tstd::sort(sorted_arr.begin(), sorted_arr.end());\n\tint count = 0;\n\
    \tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] != sorted_arr[i]) {\n\
    \t\t\tcount++;\n\t\t}\n\t}\n\tif (count > 2) {\n\t\treturn false;\n\t}\n\treturn\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmp1kz4i1sj: /tmp/tmp1kz4i1sj.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    std::vector<long> sorted_arr=arr;\n\
    \    std::sort(sorted_arr.begin(),sorted_arr.end());\n    int count=0;\n    for(int\
    \ i=0;i<arr.size();i++){\n        if(arr[i]!=sorted_arr[i])\n            count++;\n\
    \    }\n    if(count>2)\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpelx473s0: /tmp/tmpelx473s0.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    for(i=0;i<arr.size()-1;i++)\n\
    \    {\n        if(arr[i]>arr[i+1])\n            break;\n    }\n    if(i==arr.size()-1)\n\
    \        return true;\n    for(int j=i+1;j<arr.size();j++)\n    {\n        if(arr[j]<arr[i])\n\
    \            return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpc52woolx: /tmp/tmpc52woolx.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    int i=0;\n    while(i<arr.size()-1){\n\
    \        if(arr[i]>arr[i+1])\n            return false;\n        i++;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmptsw8smxk: /tmp/tmptsw8smxk.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    if(arr.size()==0)\n        return true;\n    long min=arr[0];\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]<min)\n            return false;\n\
    \        min=arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpfav5b00k: /tmp/tmpfav5b00k.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n\tif (arr.size() == 0)\n\t\treturn true;\n\tlong min = arr[0];\n\tfor (int\
    \ i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < min)\n\t\t\treturn false;\n\t\
    \tmin = arr[i];\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpka1z94a1: /tmp/tmpka1z94a1.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n// be achieved for the given\
    \ array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not\
    \ possible to get non-decreasing order for the given\n// array by performing any\
    \ number of right shift operations.\nbool move_one_ball(std::vector<long> arr)\
    \ {\n    int n = arr.size();\n    if(n == 0) return true;\n    int min = arr[0];\n\
    \    for(int i = 1; i < n; i++) {\n        if(arr[i] < min) return false;\n  \
    \      min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: "tmpbhwy4qwr: /tmp/tmpbhwy4qwr.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true)' failed.\n"
  exit_code: -6
  status: Exception
