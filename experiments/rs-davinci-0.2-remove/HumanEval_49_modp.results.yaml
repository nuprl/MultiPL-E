language: rs
name: HumanEval_49_modp
results:
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut two\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * two)\
    \ % p;\n        }\n        two = (two * two) % p;\n        n /= 2;\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut r = 1;\n    let mut b = 2;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            r = (r * b) % p;\n  \
    \      }\n        n = n / 2;\n        b = (b * b) % p;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut n = n;\n    let mut\
    \ p = p;\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpms6qq4wr.rs:8:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut k = n;\n    let mut b = 2;\n\
    \    while k > 0 {\n        if k % 2 == 1 {\n            r = (r * b) % p;\n  \
    \      }\n        k = k / 2;\n        b = (b * b) % p;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut k = n;\n    let mut m = p;\n\
    \    while k > 0 {\n        if k % 2 == 1 {\n            r = (r * n) % p;\n  \
    \      }\n        k = k / 2;\n        n = (n * n) % p;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unused variable: `m`\n --> /tmp/tmppw8ww3tp.rs:5:13\n  |\n5 |\
    \     let mut m = p;\n  |             ^ help: if this is intentional, prefix it\
    \ with an underscore: `_m`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\
    \nwarning: variable does not need to be mutable\n --> /tmp/tmppw8ww3tp.rs:5:9\n\
    \  |\n5 |     let mut m = p;\n  |         ----^\n  |         |\n  |         help:\
    \ remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmppw8ww3tp.rs:11:9\n  \
    \ |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n11 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659749291
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut n = n;\n    let mut p = p;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            r = (r * n) % p;\n  \
    \      }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmp8turp8fd.rs:8:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut two\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * two)\
    \ % p;\n        }\n        two = (two * two) % p;\n        n /= 2;\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        exp = exp / 2;\n        base = (base\
    \ * base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 ==\
    \ 0 {\n        let m = modp(n / 2, p);\n        return (m * m) % p;\n    }\n \
    \   return (2 * modp(n - 1, p)) % p;\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut n = n;\n    let mut\
    \ base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            result =\
    \ (result * base) % p;\n        }\n        n = n / 2;\n        base = (base *\
    \ base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut x =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        exp = exp / 2;\n        base = (base\
    \ * base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut x =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut k = n;\n    let mut m = p;\n\
    \    while k > 0 {\n        if k % 2 == 1 {\n            r = (r * m) % p;\n  \
    \      }\n        k /= 2;\n        m = (m * m) % p;\n    }\n    r\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpagrxda6r.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut res = 1;\n    let mut base\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * base)\
    \ % p;\n        }\n        n /= 2;\n        base = (base * base) % p;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        exp /= 2;\n        base = (base *\
    \ base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut n = n;\n    let mut\
    \ base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            result =\
    \ (result * base) % p;\n        }\n        n /= 2;\n        base = (base * base)\
    \ % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut n = n;\n    let mut\
    \ base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            result =\
    \ (result * base) % p;\n        }\n        n = n / 2;\n        base = (base *\
    \ base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        exp /= 2;\n        base = (base *\
    \ base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * k)\
    \ % p;\n        }\n        k = (k * k) % p;\n        n = n / 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ p - 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res *\
    \ n) % p;\n        }\n        n = (n * n) % p;\n        k /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpkq7jcfw1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut m = 1;\n    let mut i = 0;\n    while i < n {\n\
    \        m = (m * 2) % p;\n        i += 1;\n    }\n    m\n}\n\nfn main() {\n \
    \   let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut x =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut res = 1;\n    let mut base\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * base)\
    \ % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * k)\
    \ % p;\n        }\n        k = (k * k) % p;\n        n = n / 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut b =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * b)\
    \ % p;\n        }\n        n /= 2;\n        b = (b * b) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        exp = exp / 2;\n        base = (base\
    \ * base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut b =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * b)\
    \ % p;\n        }\n        n = n / 2;\n        b = (b * b) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut k = n;\n    let mut m = p;\n\
    \    while k > 0 {\n        if k % 2 == 1 {\n            r = (r * n) % p;\n  \
    \      }\n        k = k / 2;\n        n = (n * n) % p;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unused variable: `m`\n --> /tmp/tmppw8ww3tp.rs:5:13\n  |\n5 |\
    \     let mut m = p;\n  |             ^ help: if this is intentional, prefix it\
    \ with an underscore: `_m`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\
    \nwarning: variable does not need to be mutable\n --> /tmp/tmppw8ww3tp.rs:5:9\n\
    \  |\n5 |     let mut m = p;\n  |         ----^\n  |         |\n  |         help:\
    \ remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmppw8ww3tp.rs:11:9\n  \
    \ |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n11 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659749291
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ p - 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res *\
    \ n) % p;\n        }\n        n = (n * n) % p;\n        k /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpkq7jcfw1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        exp = exp / 2;\n        base = (base\
    \ * base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ p - 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res *\
    \ n) % p;\n        }\n        n = (n * n) % p;\n        k /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpkq7jcfw1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut r = 1;\n    let mut b = 2;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            r = (r * b) % p;\n  \
    \      }\n        n /= 2;\n        b = (b * b) % p;\n    }\n    r\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut k = n;\n    let mut b =\
    \ 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res * b)\
    \ % p;\n        }\n        k /= 2;\n        b = (b * b) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        exp /= 2;\n        base = (base *\
    \ base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut two\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * two)\
    \ % p;\n        }\n        two = (two * two) % p;\n        n /= 2;\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ p - 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res *\
    \ n) % p;\n        }\n        n = (n * n) % p;\n        k /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpkq7jcfw1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut k = n;\n    let mut a = 2;\n\
    \    while k > 0 {\n        if k % 2 == 1 {\n            r = (r * a) % p;\n  \
    \      }\n        k = k / 2;\n        a = (a * a) % p;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut res = 1;\n    let mut k =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * k)\
    \ % p;\n        }\n        k = (k * k) % p;\n        n = n / 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749293
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ p - 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res *\
    \ n) % p;\n        }\n        n = (n * n) % p;\n        k = k / 2;\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp0dh9w10f.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut result = 1;\n    let mut\
    \ base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            result =\
    \ (result * base) % p;\n        }\n        n /= 2;\n        base = (base * base)\
    \ % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut r\
    \ = modp(n / 2, p);\n    r = r * r % p;\n    if n % 2 == 1 {\n        r = r *\
    \ 2 % p;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut two\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * two)\
    \ % p;\n        }\n        two = (two * two) % p;\n        n /= 2;\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut b =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * b)\
    \ % p;\n        }\n        n /= 2;\n        b = (b * b) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut two\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * two)\
    \ % p;\n        }\n        two = (two * two) % p;\n        n /= 2;\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut k = n;\n    let mut m = p;\n\
    \    while k > 0 {\n        if k % 2 == 1 {\n            r = (r * n) % p;\n  \
    \      }\n        k = k / 2;\n        n = (n * n) % p;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unused variable: `m`\n --> /tmp/tmppw8ww3tp.rs:5:13\n  |\n5 |\
    \     let mut m = p;\n  |             ^ help: if this is intentional, prefix it\
    \ with an underscore: `_m`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\
    \nwarning: variable does not need to be mutable\n --> /tmp/tmppw8ww3tp.rs:5:9\n\
    \  |\n5 |     let mut m = p;\n  |         ----^\n  |         |\n  |         help:\
    \ remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmppw8ww3tp.rs:11:9\n  \
    \ |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n11 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659749291
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * k)\
    \ % p;\n        }\n        k = (k * k) % p;\n        n = n / 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ p - 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res *\
    \ n) % p;\n        }\n        n = (n * n) % p;\n        k /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpkq7jcfw1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut result = 1;\n    let mut\
    \ base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            result =\
    \ (result * base) % p;\n        }\n        n /= 2;\n        base = (base * base)\
    \ % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut r = 1;\n    let mut b = 2;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            r = (r * b) % p;\n  \
    \      }\n        n = n / 2;\n        b = (b * b) % p;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ p - 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res *\
    \ n) % p;\n        }\n        n = (n * n) % p;\n        k /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpkq7jcfw1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut two\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * two)\
    \ % p;\n        }\n        two = (two * two) % p;\n        n /= 2;\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut two\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * two)\
    \ % p;\n        }\n        two = (two * two) % p;\n        n /= 2;\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut x =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * k)\
    \ % p;\n        }\n        k = (k * k) % p;\n        n = n / 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n >> 1;\n        p = (p * p) % MOD;\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `MOD` in this scope\n  --> /tmp/tmp2a7gz_pd.rs:11:23\n\
    \   |\n11 |         p = (p * p) % MOD;\n   |                       ^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut x =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * k)\
    \ % p;\n        }\n        k = (k * k) % p;\n        n = n / 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut res = 1;\n    let mut base\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * base)\
    \ % p;\n        }\n        n /= 2;\n        base = (base * base) % p;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        exp = exp / 2;\n        base = (base\
    \ * base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut res = 1;\n    let mut base\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * base)\
    \ % p;\n        }\n        n /= 2;\n        base = (base * base) % p;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ p - 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res *\
    \ n) % p;\n        }\n        n = (n * n) % p;\n        k /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpkq7jcfw1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut res\
    \ = modp(n / 2, p);\n    res = (res * res) % p;\n    if n % 2 == 1 {\n       \
    \ res = (res * 2) % p;\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749293
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut k = n;\n    let mut m = p\
    \ - 2;\n    while m > 0 {\n        if m % 2 == 1 {\n            r = (r * k) %\
    \ p;\n        }\n        k = (k * k) % p;\n        m /= 2;\n    }\n    r\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpru_kz_h8.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        exp = exp / 2;\n        base = (base\
    \ * base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ p - 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res *\
    \ n) % p;\n        }\n        n = (n * n) % p;\n        k /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpkq7jcfw1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut x =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut two\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * two)\
    \ % p;\n        }\n        two = (two * two) % p;\n        n /= 2;\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut res\
    \ = modp(n / 2, p);\n    res = (res * res) % p;\n    if n % 2 == 1 {\n       \
    \ res = (res * 2) % p;\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749293
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut n = n;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            r = (r * 2) % p;\n        }\n        n /=\
    \ 2;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpljt195q6.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut x =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut res = 1;\n    let mut base\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * base)\
    \ % p;\n        }\n        n /= 2;\n        base = (base * base) % p;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut res\
    \ = modp(n / 2, p);\n    res = (res * res) % p;\n    if n % 2 == 1 {\n       \
    \ res = (res * 2) % p;\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749293
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut x =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut k = n;\n    let mut two\
    \ = 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res * two)\
    \ % p;\n        }\n        two = (two * two) % p;\n        k /= 2;\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749293
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut two\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * two)\
    \ % p;\n        }\n        two = (two * two) % p;\n        n /= 2;\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut res = 1;\n    let mut k =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * k)\
    \ % p;\n        }\n        k = (k * k) % p;\n        n = n / 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749293
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut n = n;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            r = (r * 2) % p;\n        }\n        n /=\
    \ 2;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpljt195q6.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut a =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * a)\
    \ % p;\n        }\n        a = (a * a) % p;\n        n /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut x =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut x =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut x =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        exp = exp / 2;\n        base = (base\
    \ * base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ p - 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res *\
    \ n) % p;\n        }\n        n = (n * n) % p;\n        k /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpkq7jcfw1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        exp = exp / 2;\n        base = (base\
    \ * base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpux41_xb_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * k)\
    \ % p;\n        }\n        k = (k * k) % p;\n        n = n / 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut n = n;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            r = (r * 2) % p;\n        }\n        n /=\
    \ 2;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpljt195q6.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpcxunehqh.rs:8:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749292
