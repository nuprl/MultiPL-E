name: HumanEval_115_max_fill
language: rs
prompt: "/// You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n/// and\
  \ all buckets have the same capacity.\n/// Your task is to use the buckets to empty\
  \ the wells.\n/// Output the number of times you need to lower the buckets.\n///\
  \ Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
  \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
  \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
  \ Vec<Vec<isize>>, capacity: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
  \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
  \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n   \
  \ assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
  \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1,\
  \ 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
completions: ["    let mut max_fill = 0;\n    let mut fill = 0;\n    for row in grid\
    \ {\n        for &col in row.iter() {\n            fill += col;\n            if\
    \ fill > capacity {\n                max_fill += 1;\n                fill = 0;\n\
    \            }\n        }\n        max_fill += 1;\n        fill = 0;\n    }\n\
    \    max_fill", "    let mut count = 0;\n    for row in grid {\n        let mut\
    \ sum = 0;\n        for &well in row.iter() {\n            sum += well;\n    \
    \        if sum == capacity {\n                count += 1;\n                sum\
    \ = 0;\n            }\n        }\n        if sum > 0 {\n            count += 1;\n\
    \        }\n    }\n    count", "    let mut grid = grid;\n    let mut count =\
    \ 0;\n    let rows = grid.len();\n    let cols = grid[0].len();\n    for i in\
    \ 0..rows {\n        for j in 0..cols {\n            if grid[i][j] == 1 {\n  \
    \              count += 1;\n                let mut curr_row = i;\n          \
    \      while curr_row < rows && grid[curr_row][j] == 1 {\n                   \
    \ grid[curr_row][j] = 0;\n                    curr_row += 1;\n               \
    \ }\n            }\n        }\n    }\n    count", "    let mut result = 0;\n \
    \   let mut row_max = vec![0; grid.len()];\n    for row in grid {\n        let\
    \ mut max = 0;\n        for &x in row.iter() {\n            max = max.max(x);\n\
    \        }\n        row_max.push(max);\n    }\n    for &max in row_max.iter()\
    \ {\n        result += max / capacity;\n        if max % capacity != 0 {\n   \
    \         result += 1;\n        }\n    }\n    result", "    let mut result = 0;\n\
    \    let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n\
    \        for well in row {\n            if well == 1 {\n                fill +=\
    \ 1;\n            } else {\n                if fill > max_fill {\n           \
    \         max_fill = fill;\n                }\n                fill = 0;\n   \
    \         }\n        }\n        if fill > max_fill {\n            max_fill = fill;\n\
    \        }\n        result += max_fill / capacity;\n        if max_fill % capacity\
    \ != 0 {\n            result += 1;\n        }\n        max_fill = 0;\n    }\n\
    \    result", "    let mut result = 0;\n    let mut row = 0;\n    let mut col\
    \ = 0;\n    let mut max_row = 0;\n    let mut max_col = 0;\n    let mut max_val\
    \ = 0;\n    let mut max_val_row = 0;\n    let mut max_val_col = 0;\n    let mut\
    \ max_row_val = 0;\n    let mut max_col_val = 0;\n    let mut max_row_val_row\
    \ = 0;\n    let mut max_col_val_col = 0;\n    let mut max_row_val_col = 0;\n \
    \   let mut max_col_val_row = 0;\n    let mut max_row_val_row_col = 0;\n    let\
    \ mut max_col_val_row_col = 0;\n    let mut max_row_val_row_col_val = 0;\n   \
    \ let mut max_col_val_row_col_val = 0;\n    let mut max_row_val_row_col_val_row\
    \ = 0;\n    let mut max_col_val_row_col_val_row = 0;\n    let mut max_row_val_row_col_val_row_col\
    \ = 0;\n    let mut max_col_val_row_col_val_row_col = 0;\n    let mut max_row_val_row_col_val_row_col_val\
    \ = 0;\n    let mut max_col_val_row_col_val_row_col_val = 0;\n    let mut max_row_val_row_col_val_row_col_val_row\
    \ = 0;\n    let mut max_col_val_row_col_val_row_col_val_row = 0;\n    let mut\
    \ max_row_val_row_col_val_row_col_val_row_col = 0;\n    let mut max_col_val_row_col_val_row_col_val_row_col\
    \ = 0;\n    let mut max_row_val_row_col_val_row_col_val_row_col_val = 0;\n   \
    \ let mut max_col_val_row_col_val_", "    let mut count = 0;\n    let mut max_row\
    \ = 0;\n    let mut max_col = 0;\n    for row in grid.iter() {\n        let mut\
    \ row_count = 0;\n        for col in row.iter() {\n            if *col == 1 {\n\
    \                row_count += 1;\n            }\n        }\n        if row_count\
    \ > max_row {\n            max_row = row_count;\n        }\n    }\n    for col\
    \ in 0..grid[0].len() {\n        let mut col_count = 0;\n        for row in grid.iter()\
    \ {\n            if row[col] == 1 {\n                col_count += 1;\n       \
    \     }\n        }\n        if col_count > max_col {\n            max_col = col_count;\n\
    \        }\n    }\n    if max_row > capacity {\n        count += max_row / capacity;\n\
    \        if max_row % capacity != 0 {\n            count += 1;\n        }\n  \
    \  } else {\n        count += 1;\n    }\n    if max_col > capacity {\n       \
    \ count += max_col / capacity;\n        if max_col % capacity != 0 {\n       \
    \     count += 1;\n        }\n    } else {\n        count += 1;\n    }\n    count",
  "    let mut count = 0;\n    for row in grid {\n        let mut sum = 0;\n     \
    \   for &cell in row.iter() {\n            sum += cell;\n            if sum ==\
    \ capacity {\n                count += 1;\n                sum = 0;\n        \
    \    }\n        }\n        if sum > 0 {\n            count += 1;\n        }\n\
    \    }\n    count", "    let mut result = 0;\n    let mut max_fill = 0;\n    for\
    \ row in grid {\n        for &well in &row {\n            max_fill += well;\n\
    \        }\n    }\n    while max_fill > 0 {\n        let mut fill = 0;\n     \
    \   for row in grid.iter() {\n            let mut row_fill = 0;\n            for\
    \ &well in row {\n                if well > 0 {\n                    row_fill\
    \ += 1;\n                }\n            }\n            fill += row_fill;\n   \
    \         if fill > capacity {\n                break;\n            }\n      \
    \  }\n        if fill > capacity {\n            result += 1;\n            for\
    \ row in grid.iter_mut() {\n                for well in row.iter_mut() {\n   \
    \                 if *well > 0 {\n                        *well -= 1;\n      \
    \              }\n                }\n            }\n        } else {\n       \
    \     max_fill = 0;\n        }\n    }\n    result", "    let mut grid = grid;\n\
    \    let mut count = 0;\n    for row in grid.iter_mut() {\n        let mut row_sum\
    \ = 0;\n        for cell in row.iter_mut() {\n            row_sum += *cell;\n\
    \            *cell = 0;\n        }\n        count += row_sum / capacity;\n   \
    \     if row_sum % capacity != 0 {\n            count += 1;\n        }\n    }\n\
    \    count", "    let mut result = 0;\n    let mut max_height = 0;\n    for row\
    \ in grid {\n        let mut height = 0;\n        for &cell in row.iter() {\n\
    \            if cell == 1 {\n                height += 1;\n            }\n   \
    \     }\n        max_height = max(max_height, height);\n    }\n    for height\
    \ in 0..max_height {\n        let mut fill = 0;\n        for row in grid {\n \
    \           for &cell in row.iter() {\n                if cell == 1 {\n      \
    \              fill += 1;\n                }\n                if fill == capacity\
    \ {\n                    result += 1;\n                    fill = 0;\n       \
    \         }\n            }\n        }\n        if fill > 0 {\n            result\
    \ += 1;\n        }\n    }\n    result", "    let mut max_fill = 0;\n    for row\
    \ in grid {\n        let mut fill = 0;\n        for &well in row.iter() {\n  \
    \          fill += well;\n            if fill > capacity {\n                fill\
    \ = capacity;\n            }\n        }\n        max_fill = max(max_fill, fill);\n\
    \    }\n    max_fill", "    let mut grid = grid;\n    let mut count = 0;\n   \
    \ for row in grid.iter_mut() {\n        for cell in row.iter_mut() {\n       \
    \     if *cell == 1 {\n                *cell = capacity;\n                count\
    \ += 1;\n            }\n        }\n    }\n    let mut result = 0;\n    let mut\
    \ row = 0;\n    while row < grid.len() {\n        let mut col = 0;\n        while\
    \ col < grid[row].len() {\n            if grid[row][col] > 0 {\n             \
    \   result += 1;\n                let mut i = row;\n                while i <\
    \ grid.len() && grid[i][col] > 0 {\n                    grid[i][col] -= 1;\n \
    \                   i += 1;\n                }\n            }\n            col\
    \ += 1;\n        }\n        row += 1;\n    }\n    result", "    let mut res =\
    \ 0;\n    let mut row_max = vec![0; grid.len()];\n    for row in grid {\n    \
    \    let mut max = 0;\n        for &col in row.iter() {\n            max = max.max(col);\n\
    \        }\n        row_max.push(max);\n    }\n    for &max in row_max.iter()\
    \ {\n        res += max / capacity;\n        if max % capacity != 0 {\n      \
    \      res += 1;\n        }\n    }\n    res", "    let mut grid = grid;\n    let\
    \ mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        let mut height = 0;\n        for cell in row.iter_mut() {\n     \
    \       if *cell == 1 {\n                height += 1;\n            } else {\n\
    \                height = 0;\n            }\n            *cell = height;\n   \
    \     }\n        max_height = max(max_height, height);\n    }\n    for height\
    \ in 1..=max_height {\n        for row in grid.iter_mut() {\n            let mut\
    \ filled = false;\n            for cell in row.iter_mut() {\n                if\
    \ *cell >= height {\n                    *cell -= 1;\n                    filled\
    \ = true;\n                }\n            }\n            if filled {\n       \
    \         count += 1;\n            }\n        }\n    }\n    count", "    let mut\
    \ count = 0;\n    let mut wells = grid.iter().map(|row| row.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    while wells.iter().any(|&w| w > 0) {\n        let mut filled = 0;\n     \
    \   for w in wells.iter_mut() {\n            if *w > capacity {\n            \
    \    *w -= capacity;\n                filled += capacity;\n            } else\
    \ {\n                filled += *w;\n                *w = 0;\n            }\n \
    \       }\n        count += 1;\n        for w in wells.iter_mut() {\n        \
    \    if *w > 0 {\n                let fill = std::cmp::min(*w, filled);\n    \
    \            *w -= fill;\n                filled -= fill;\n            }\n   \
    \     }\n    }\n    count", "    let mut result = 0;\n    let mut row = 0;\n \
    \   let mut col = 0;\n    let mut max_row = 0;\n    let mut max_col = 0;\n   \
    \ let mut max_val = 0;\n    let mut max_val_row = 0;\n    let mut max_val_col\
    \ = 0;\n    let mut max_val_row_col = 0;\n    let mut max_val_col_row = 0;\n \
    \   let mut max_val_row_col_row = 0;\n    let mut max_val_col_row_col = 0;\n \
    \   let mut max_val_row_col_row_col = 0;\n    let mut max_val_col_row_col_row\
    \ = 0;\n    let mut max_val_row_col_row_col_row = 0;\n    let mut max_val_col_row_col_row_col\
    \ = 0;\n    let mut max_val_row_col_row_col_row_col = 0;\n    let mut max_val_col_row_col_row_col_row\
    \ = 0;\n    let mut max_val_row_col_row_col_row_col_row = 0;\n    let mut max_val_col_row_col_row_col_row_col\
    \ = 0;\n    let mut max_val_row_col_row_col_row_col_row_col = 0;\n    let mut\
    \ max_val_col_row_col_row_col_row_col_row = 0;\n    let mut max_val_row_col_row_col_row_col_row_col_row\
    \ = 0;\n    let mut max_val_col_row_col_row_col_row_col_row_col = 0;\n    let\
    \ mut max_val_row_col_row_col_row_col_row_col_row_col = 0;\n    let mut max_val_col_row_col_row_col_row_col_row_col_row\
    \ = 0;\n    let mut max_val_row_col_row_col_row_col_row_col_row_col_row = 0;\n\
    \    let mut max_", "    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in row.iter() {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill",
  "    let mut count = 0;\n    let mut max_fill = 0;\n    for row in grid {\n    \
    \    for cell in row {\n            if cell == 1 {\n                max_fill +=\
    \ 1;\n            }\n        }\n    }\n    while max_fill > 0 {\n        for row\
    \ in grid {\n            for cell in row {\n                if cell == 1 {\n \
    \                   max_fill -= 1;\n                    count += 1;\n        \
    \        }\n            }\n        }\n    }\n    count", "    let mut grid = grid;\n\
    \    let mut count = 0;\n    let mut i = 0;\n    while i < grid.len() {\n    \
    \    let mut j = 0;\n        while j < grid[i].len() {\n            if grid[i][j]\
    \ == 1 {\n                let mut k = i;\n                while k < grid.len()\
    \ && grid[k][j] == 1 {\n                    grid[k][j] = 0;\n                \
    \    k += 1;\n                }\n                count += 1;\n            }\n\
    \            j += 1;\n        }\n        i += 1;\n    }\n    count", "    let\
    \ mut grid = grid;\n    let mut count = 0;\n    let mut i = 0;\n    while i <\
    \ grid.len() {\n        let mut j = 0;\n        while j < grid[i].len() {\n  \
    \          if grid[i][j] == 1 {\n                grid[i][j] = 0;\n           \
    \     count += 1;\n                let mut k = i + 1;\n                while k\
    \ < grid.len() && capacity > 0 {\n                    if grid[k][j] == 1 {\n \
    \                       grid[k][j] = 0;\n                        capacity -= 1;\n\
    \                    }\n                    k += 1;\n                }\n     \
    \       }\n            j += 1;\n        }\n        i += 1;\n    }\n    count",
  "    let mut grid = grid;\n    let mut count = 0;\n    let mut max_row = 0;\n  \
    \  for row in grid.iter_mut() {\n        let mut sum = 0;\n        for col in\
    \ row.iter_mut() {\n            sum += *col;\n        }\n        max_row = max(max_row,\
    \ sum);\n    }\n    for _ in 0..max_row {\n        for row in grid.iter_mut()\
    \ {\n            let mut sum = 0;\n            for col in row.iter_mut() {\n \
    \               sum += *col;\n            }\n            if sum > capacity {\n\
    \                *row = row.iter().map(|x| x - 1).collect();\n               \
    \ count += 1;\n            }\n        }\n    }\n    count", "    let mut result\
    \ = 0;\n    let mut water = 0;\n    for row in grid {\n        for &well in &row\
    \ {\n            water += well;\n            if water == capacity {\n        \
    \        result += 1;\n                water = 0;\n            } else if water\
    \ > capacity {\n                result += 1;\n                water = well;\n\
    \            }\n        }\n        if water > 0 {\n            result += 1;\n\
    \            water = 0;\n        }\n    }\n    result", "    let mut max_fill\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for well in\
    \ row {\n            fill += well;\n            if fill > capacity {\n       \
    \         max_fill += 1;\n                fill = well;\n            }\n      \
    \  }\n        max_fill += 1;\n    }\n    max_fill", "    let mut count = 0;\n\
    \    let mut row = 0;\n    let mut col = 0;\n    let mut row_max = 0;\n    let\
    \ mut col_max = 0;\n    let mut row_sum = 0;\n    let mut col_sum = 0;\n    let\
    \ mut row_max_index = 0;\n    let mut col_max_index = 0;\n    let mut row_sum_index\
    \ = 0;\n    let mut col_sum_index = 0;\n    let mut row_max_count = 0;\n    let\
    \ mut col_max_count = 0;\n    let mut row_sum_count = 0;\n    let mut col_sum_count\
    \ = 0;\n    let mut row_max_count_index = 0;\n    let mut col_max_count_index\
    \ = 0;\n    let mut row_sum_count_index = 0;\n    let mut col_sum_count_index\
    \ = 0;\n    let mut row_max_count_index_max = 0;\n    let mut col_max_count_index_max\
    \ = 0;\n    let mut row_sum_count_index_max = 0;\n    let mut col_sum_count_index_max\
    \ = 0;\n    let mut row_max_count_index_max_count = 0;\n    let mut col_max_count_index_max_count\
    \ = 0;\n    let mut row_sum_count_index_max_count = 0;\n    let mut col_sum_count_index_max_count\
    \ = 0;\n    let mut row_max_count_index_max_count_index = 0;\n    let mut col_max_count_index_max_count_index\
    \ = 0;\n    let mut row_sum_count_index_max_count_index = 0;\n    let mut col_sum_count_index_max_count_index\
    \ = 0;\n    let mut row_max_count_index_max_count_index_max = 0;\n    let mut\
    \ col_max_count_index_max_count_index_max = 0;\n    let mut row_sum_count_index_max_count_index_max\
    \ = 0;\n    let mut col_sum_count_index_max_", "    let mut count = 0;\n    let\
    \ mut wells = grid.clone();\n    let mut i = 0;\n    while i < wells.len() {\n\
    \        let mut j = 0;\n        while j < wells[i].len() {\n            if wells[i][j]\
    \ == 1 {\n                let mut k = i;\n                while k < wells.len()\
    \ && wells[k][j] == 1 {\n                    wells[k][j] = 0;\n              \
    \      k += 1;\n                }\n                count += 1;\n            }\n\
    \            j += 1;\n        }\n        i += 1;\n    }\n    count", "    let\
    \ mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n      \
    \  for &well in row.iter() {\n            fill += well;\n            if fill >\
    \ capacity {\n                fill = capacity;\n            }\n        }\n   \
    \     max_fill = max(max_fill, fill);\n    }\n    max_fill", "    let mut count\
    \ = 0;\n    let mut grid = grid;\n    let mut row = 0;\n    let mut col = 0;\n\
    \    let mut row_max = 0;\n    let mut col_max = 0;\n    let mut row_max_index\
    \ = 0;\n    let mut col_max_index = 0;\n    let mut row_max_count = 0;\n    let\
    \ mut col_max_count = 0;\n    let mut row_max_count_index = 0;\n    let mut col_max_count_index\
    \ = 0;\n    let mut row_max_count_index_max = 0;\n    let mut col_max_count_index_max\
    \ = 0;\n    let mut row_max_count_max = 0;\n    let mut col_max_count_max = 0;\n\
    \    let mut row_max_count_index_max_count = 0;\n    let mut col_max_count_index_max_count\
    \ = 0;\n    let mut row_max_count_index_max_count_max = 0;\n    let mut col_max_count_index_max_count_max\
    \ = 0;\n    let mut row_max_count_index_max_count_max_count = 0;\n    let mut\
    \ col_max_count_index_max_count_max_count = 0;\n    let mut row_max_count_index_max_count_max_count_max\
    \ = 0;\n    let mut col_max_count_index_max_count_max_count_max = 0;\n    let\
    \ mut row_max_count_index_max_count_max_count_max_count = 0;\n    let mut col_max_count_index_max_count_max_count_max_count\
    \ = 0;\n    let mut row_max_count_index_max_count_max_count_max_count_max = 0;\n\
    \    let mut col_max_count_index_max_count_max_count_max_count_max = 0;\n    let\
    \ mut row_max_count_index_max_count_max_count_max_count_max_count = 0;\n    let\
    \ mut col_max_count_index_max_count_max_", "    let mut result = 0;\n    let mut\
    \ current = 0;\n    for row in grid {\n        for col in row {\n            if\
    \ col == 1 {\n                current += 1;\n            }\n        }\n      \
    \  result += current / capacity;\n        current = current % capacity;\n    }\n\
    \    result", "    let mut count = 0;\n    let mut max_fill = 0;\n    for row\
    \ in grid {\n        for &well in row.iter() {\n            if well == 1 {\n \
    \               max_fill += 1;\n            }\n        }\n    }\n    let mut fill\
    \ = 0;\n    for row in grid {\n        for &well in row.iter() {\n           \
    \ if well == 1 {\n                fill += 1;\n            }\n            if fill\
    \ == max_fill {\n                count += 1;\n                fill = 0;\n    \
    \        }\n        }\n    }\n    count", "    let mut max_fill = 0;\n    for\
    \ row in grid {\n        let mut fill = 0;\n        for &well in row.iter() {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ max_fill += 1;\n                fill = well;\n            }\n        }\n   \
    \     max_fill += fill / capacity;\n    }\n    max_fill", "    let mut count =\
    \ 0;\n    for row in grid {\n        let mut filled = 0;\n        for &cell in\
    \ row.iter() {\n            filled += cell;\n            if filled == capacity\
    \ {\n                count += 1;\n                filled = 0;\n            }\n\
    \        }\n        if filled > 0 {\n            count += 1;\n        }\n    }\n\
    \    count", "    let mut max_fill = 0;\n    for row in grid {\n        let mut\
    \ fill = 0;\n        for &well in row.iter() {\n            fill += well;\n  \
    \          if fill > capacity {\n                fill = capacity;\n          \
    \  }\n        }\n        max_fill = std::cmp::max(max_fill, fill);\n    }\n  \
    \  max_fill", "    let mut result = 0;\n    let mut row_max = vec![0; grid.len()];\n\
    \    for row in grid {\n        let mut row_max_val = 0;\n        for (i, &val)\
    \ in row.iter().enumerate() {\n            row_max_val = std::cmp::max(row_max_val,\
    \ val);\n            row_max[i] = std::cmp::max(row_max[i], val);\n        }\n\
    \        result += row_max_val;\n    }\n    for &val in row_max.iter() {\n   \
    \     result += val;\n    }\n    result - capacity * grid.len() as isize", " \
    \   let mut count = 0;\n    let mut row_max = vec![0; grid.len()];\n    for (i,\
    \ row) in grid.iter().enumerate() {\n        let mut max = 0;\n        for &c\
    \ in row {\n            max = max.max(c);\n        }\n        row_max[i] = max;\n\
    \    }\n    let mut col_max = vec![0; grid[0].len()];\n    for j in 0..grid[0].len()\
    \ {\n        let mut max = 0;\n        for i in 0..grid.len() {\n            max\
    \ = max.max(grid[i][j]);\n        }\n        col_max[j] = max;\n    }\n    for\
    \ i in 0..grid.len() {\n        for j in 0..grid[0].len() {\n            let max\
    \ = row_max[i].min(col_max[j]);\n            if grid[i][j] < max {\n         \
    \       count += max - grid[i][j];\n            }\n        }\n    }\n    count",
  "    let mut grid = grid;\n    let mut count = 0;\n    let mut max_height = 0;\n\
    \    for row in grid.iter_mut() {\n        let mut row_max = 0;\n        for cell\
    \ in row.iter_mut() {\n            if *cell == 1 {\n                row_max +=\
    \ 1;\n            }\n        }\n        if row_max > max_height {\n          \
    \  max_height = row_max;\n        }\n    }\n    for _ in 0..max_height {\n   \
    \     for row in grid.iter_mut() {\n            for cell in row.iter_mut() {\n\
    \                if *cell == 1 {\n                    *cell = 0;\n           \
    \         count += 1;\n                }\n            }\n        }\n    }\n  \
    \  count", "    let mut grid = grid;\n    let mut count = 0;\n    let mut max_row\
    \ = 0;\n    let mut max_col = 0;\n    let mut max_val = 0;\n    let mut max_row_idx\
    \ = 0;\n    let mut max_col_idx = 0;\n    let mut max_val_idx = 0;\n    let mut\
    \ max_val_idx_row = 0;\n    let mut max_val_idx_col = 0;\n    let mut max_val_idx_row_idx\
    \ = 0;\n    let mut max_val_idx_col_idx = 0;\n    let mut max_val_idx_row_idx_col\
    \ = 0;\n    let mut max_val_idx_row_idx_col_idx = 0;\n    let mut max_val_idx_row_idx_col_idx_val\
    \ = 0;\n    let mut max_val_idx_row_idx_col_idx_val_row = 0;\n    let mut max_val_idx_row_idx_col_idx_val_row_idx\
    \ = 0;\n    let mut max_val_idx_row_idx_col_idx_val_row_idx_col = 0;\n    let\
    \ mut max_val_idx_row_idx_col_idx_val_row_idx_col_idx = 0;\n    let mut max_val_idx_row_idx_col_idx_val_row_idx_col_idx_val\
    \ = 0;\n    let mut max_val_idx_row_idx_col_idx_val_row_idx_col_idx_val_row =\
    \ 0;\n    let mut max_val_idx_row_idx_col_idx_val_row_idx_col_idx_val_row_idx\
    \ = 0;\n    let mut max_val_idx_row_idx_col_idx_val_row_idx_col_idx_val_row_idx_col\
    \ = 0;\n    let mut max_val", "    let mut count = 0;\n    let mut grid = grid;\n\
    \    let mut full = vec![false; grid.len()];\n    let mut empty = vec![false;\
    \ grid.len()];\n    let mut i = 0;\n    while i < grid.len() {\n        if full[i]\
    \ {\n            i += 1;\n            continue;\n        }\n        let mut j\
    \ = 0;\n        while j < grid[i].len() {\n            if grid[i][j] == 1 {\n\
    \                grid[i][j] = 0;\n                if j == grid[i].len() - 1 {\n\
    \                    full[i] = true;\n                }\n                if capacity\
    \ == 1 {\n                    count += 1;\n                }\n            } else\
    \ {\n                if capacity > 1 {\n                    count += 1;\n    \
    \            }\n                if j == grid[i].len() - 1 {\n                \
    \    empty[i] = true;\n                }\n            }\n            j += 1;\n\
    \        }\n        i += 1;\n    }\n    let mut i = 0;\n    while i < grid.len()\
    \ {\n        if empty[i] {\n            i += 1;\n            continue;\n     \
    \   }\n        let mut j = 0;\n        while j < grid[i].len() {\n           \
    \ if grid[i][j] == 1 {\n                grid[i][j] = 0;\n                if j\
    \ == grid[i].len() - 1 {\n                    empty[i] = true;\n             \
    \   }\n                if capacity == 1 {\n                    count += 1;\n \
    \               }\n            } else {\n                if capacity > 1 {\n \
    \                   count += 1;\n                }\n                if j == grid[i].len()\
    \ - 1 {\n                    full[i] = true;\n                }\n            }\n\
    \            j += 1;\n        }\n        i += 1;\n    }\n    count", "    let\
    \ mut count = 0;\n    for row in grid {\n        let mut sum = 0;\n        for\
    \ cell in row {\n            sum += cell;\n            if sum == capacity {\n\
    \                count += 1;\n                sum = 0;\n            }\n      \
    \  }\n        if sum > 0 {\n            count += 1;\n        }\n    }\n    count",
  "    let mut count = 0;\n    let mut max_row = 0;\n    let mut max_col = 0;\n  \
    \  let mut max_val = 0;\n    for (row, cols) in grid.iter().enumerate() {\n  \
    \      for (col, val) in cols.iter().enumerate() {\n            if *val > max_val\
    \ {\n                max_val = *val;\n                max_row = row;\n       \
    \         max_col = col;\n            }\n        }\n    }\n    let mut grid =\
    \ grid;\n    while max_val > 0 {\n        let mut bucket = capacity;\n       \
    \ for row in 0..grid.len() {\n            for col in 0..grid[row].len() {\n  \
    \              if grid[row][col] > 0 {\n                    if bucket > grid[row][col]\
    \ {\n                        bucket -= grid[row][col];\n                     \
    \   grid[row][col] = 0;\n                    } else {\n                      \
    \  grid[row][col] -= bucket;\n                        bucket = 0;\n          \
    \          }\n                }\n            }\n        }\n        count += 1;\n\
    \        max_val = 0;\n        for (row, cols) in grid.iter().enumerate() {\n\
    \            for (col, val) in cols.iter().enumerate() {\n                if *val\
    \ > max_val {\n                    max_val = *val;\n                    max_row\
    \ = row;\n                    max_col = col;\n                }\n            }\n\
    \        }\n    }\n    count", "    let mut max_fill = 0;\n    for row in grid\
    \ {\n        let mut fill = 0;\n        for &well in row.iter() {\n          \
    \  if well == 1 {\n                fill += 1;\n            } else {\n        \
    \        max_fill = max_fill.max(fill);\n                fill = 0;\n         \
    \   }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    (max_fill\
    \ as f64 / capacity as f64).ceil() as isize", "    let mut max_fill = 0;\n   \
    \ for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = 0;\n            }\n        }\n  \
    \      if fill > 0 {\n            max_fill += 1;\n        }\n    }\n    max_fill",
  "    let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n \
    \       for well in row {\n            if well == 1 {\n                fill +=\
    \ 1;\n            }\n        }\n        max_fill = std::cmp::max(max_fill, fill);\n\
    \    }\n    max_fill / capacity + if max_fill % capacity == 0 { 0 } else { 1 }",
  "    let mut count = 0;\n    let mut row_max = vec![0; grid.len()];\n    for row\
    \ in grid {\n        let max = row.iter().max().unwrap();\n        row_max.push(*max);\n\
    \    }\n    let max = row_max.iter().max().unwrap();\n    while max > 0 {\n  \
    \      for row in grid {\n            for col in row {\n                if col\
    \ > 0 {\n                    count += 1;\n                }\n            }\n \
    \       }\n    }\n    count", "    let mut grid = grid;\n    let mut count = 0;\n\
    \    let mut max_height = 0;\n    for row in grid.iter_mut() {\n        max_height\
    \ = max_height.max(row.iter().sum());\n    }\n    for height in 1..=max_height\
    \ {\n        for row in grid.iter_mut() {\n            for cell in row.iter_mut()\
    \ {\n                if *cell >= height {\n                    *cell -= capacity;\n\
    \                    count += 1;\n                }\n            }\n        }\n\
    \    }\n    count", "    let mut result = 0;\n    let mut max_level = 0;\n   \
    \ for row in grid {\n        let mut level = 0;\n        for &cell in &row {\n\
    \            if cell == 1 {\n                level += 1;\n            }\n    \
    \    }\n        max_level = max(max_level, level);\n    }\n    for level in 1..=max_level\
    \ {\n        let mut count = 0;\n        for row in grid {\n            let mut\
    \ level_count = 0;\n            for &cell in &row {\n                if cell ==\
    \ 1 {\n                    level_count += 1;\n                }\n            }\n\
    \            if level_count >= level {\n                count += 1;\n        \
    \    }\n        }\n        result += count / capacity;\n        if count % capacity\
    \ != 0 {\n            result += 1;\n        }\n    }\n    result", "    let mut\
    \ grid = grid;\n    let mut count = 0;\n    let mut max_height = 0;\n    for row\
    \ in grid.iter_mut() {\n        for cell in row.iter_mut() {\n            if *cell\
    \ == 1 {\n                max_height += 1;\n            }\n        }\n    }\n\
    \    for i in 0..max_height {\n        let mut filled = 0;\n        for row in\
    \ grid.iter_mut() {\n            for cell in row.iter_mut() {\n              \
    \  if *cell == 1 {\n                    *cell = 0;\n                    filled\
    \ += 1;\n                }\n            }\n        }\n        if filled > 0 {\n\
    \            count += 1;\n        }\n        if filled > capacity {\n        \
    \    for row in grid.iter_mut() {\n                for cell in row.iter_mut()\
    \ {\n                    if *cell == 0 {\n                        *cell = 1;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   count", "    let mut fill_count = 0;\n    let mut grid = grid;\n    let mut\
    \ row_max = vec![0; grid.len()];\n    for row in grid.iter_mut() {\n        let\
    \ mut max = 0;\n        for cell in row.iter_mut() {\n            if *cell ==\
    \ 1 {\n                *cell = capacity;\n                max += capacity;\n \
    \           }\n        }\n        row_max.push(max);\n    }\n    let mut col_max\
    \ = vec![0; grid[0].len()];\n    for col in 0..grid[0].len() {\n        let mut\
    \ max = 0;\n        for row in 0..grid.len() {\n            if grid[row][col]\
    \ == 1 {\n                grid[row][col] = capacity;\n                max += capacity;\n\
    \            }\n        }\n        col_max.push(max);\n    }\n    let mut row_index\
    \ = 0;\n    let mut col_index = 0;\n    while row_index < grid.len() && col_index\
    \ < grid[0].len() {\n        let row_max = row_max[row_index];\n        let col_max\
    \ = col_max[col_index];\n        if row_max > col_max {\n            for col in\
    \ 0..grid[0].len() {\n                if grid[row_index][col] == capacity {\n\
    \                    grid[row_index][col] = 0;\n                    col_max[col]\
    \ -= capacity;\n                }\n            }\n            row_index += 1;\n\
    \        } else {\n            for row in 0..grid.len() {\n                if\
    \ grid[row][col_index] == capacity {\n                    grid[row][col_index]\
    \ = 0;\n                    row_max[row] -= capacity;\n                }\n   \
    \         }\n            col_index += 1;\n        }\n        fill_count += 1;\n\
    \    }\n    fill_count", "    let mut result = 0;\n    let mut row_max = vec![0;\
    \ grid.len()];\n    for row in grid {\n        let mut max = 0;\n        for &cell\
    \ in row.iter() {\n            max = std::cmp::max(max, cell);\n        }\n  \
    \      row_max.push(max);\n    }\n    let mut row_max = row_max.into_iter().rev();\n\
    \    let mut row_max = row_max.peekable();\n    while let Some(max) = row_max.next()\
    \ {\n        if max == 0 {\n            continue;\n        }\n        let mut\
    \ fill = capacity;\n        while fill > 0 {\n            if let Some(next) =\
    \ row_max.peek() {\n                if *next == 0 {\n                    break;\n\
    \                }\n            }\n            fill -= max;\n            result\
    \ += 1;\n        }\n    }\n    result", "    let mut max_fill = 0;\n    for row\
    \ in grid {\n        let mut fill = 0;\n        for &well in row.iter() {\n  \
    \          fill += well;\n            if fill > capacity {\n                fill\
    \ = capacity;\n            }\n        }\n        max_fill = max(max_fill, fill);\n\
    \    }\n    max_fill", "    let mut count = 0;\n    let mut row_max = vec![0;\
    \ grid.len()];\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            if grid[i][j] == 1 {\n                row_max[i] = j as isize;\n\
    \            }\n        }\n    }\n    let mut col_max = vec![0; grid[0].len()];\n\
    \    for j in 0..grid[0].len() {\n        for i in 0..grid.len() {\n         \
    \   if grid[i][j] == 1 {\n                col_max[j] = i as isize;\n         \
    \   }\n        }\n    }\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            if grid[i][j] == 1 {\n                let mut fill = capacity;\n\
    \                let mut row_max_fill = row_max[i];\n                let mut col_max_fill\
    \ = col_max[j];\n                while fill > 0 {\n                    if row_max_fill\
    \ > col_max_fill {\n                        row_max_fill -= 1;\n             \
    \       } else {\n                        col_max_fill -= 1;\n               \
    \     }\n                    fill -= 1;\n                }\n                if\
    \ row_max_fill < 0 {\n                    row_max_fill = 0;\n                }\n\
    \                if col_max_fill < 0 {\n                    col_max_fill = 0;\n\
    \                }\n                count += (row_max_fill + col_max_fill) as\
    \ isize;\n            }\n        }\n    }\n    count", "    let mut grid = grid;\n\
    \    let mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        max_height = max_height.max(row.iter().sum());\n    }\n    for height\
    \ in 0..max_height {\n        for row in grid.iter_mut() {\n            for cell\
    \ in row.iter_mut() {\n                if *cell > 0 {\n                    *cell\
    \ -= 1;\n                    count += 1;\n                }\n            }\n \
    \       }\n    }\n    count", "    let mut max_fill = 0;\n    for row in grid\
    \ {\n        let mut fill = 0;\n        for &well in row.iter() {\n          \
    \  fill += well;\n            if fill > capacity {\n                max_fill +=\
    \ 1;\n                fill = well;\n            }\n        }\n        max_fill\
    \ += 1;\n    }\n    max_fill", "    let mut grid = grid;\n    let mut count =\
    \ 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut() {\n        let\
    \ mut height = 0;\n        for cell in row.iter_mut() {\n            if *cell\
    \ == 1 {\n                height += 1;\n            } else {\n               \
    \ height = 0;\n            }\n            *cell = height;\n        }\n       \
    \ max_height = max_height.max(height);\n    }\n    for row in grid.iter() {\n\
    \        let mut height = 0;\n        for cell in row.iter() {\n            height\
    \ = height.max(*cell);\n            if height == max_height {\n              \
    \  break;\n            }\n        }\n        count += capacity - height;\n   \
    \ }\n    count", "    let mut result = 0;\n    let mut max_height = 0;\n    for\
    \ row in grid {\n        let mut height = 0;\n        for &cell in row.iter()\
    \ {\n            if cell == 1 {\n                height += 1;\n            }\n\
    \        }\n        max_height = max(max_height, height);\n    }\n    for height\
    \ in 0..max_height {\n        let mut fill = 0;\n        for row in grid {\n \
    \           for &cell in row.iter() {\n                if cell == 1 {\n      \
    \              fill += 1;\n                }\n                if fill == capacity\
    \ {\n                    result += 1;\n                    fill = 0;\n       \
    \         }\n            }\n        }\n        if fill > 0 {\n            result\
    \ += 1;\n        }\n    }\n    result", "    let mut max_fill = 0;\n    for row\
    \ in grid {\n        let mut fill = 0;\n        for &well in row.iter() {\n  \
    \          fill += well;\n            if fill > capacity {\n                max_fill\
    \ += 1;\n                fill = well;\n            }\n        }\n        max_fill\
    \ += 1;\n    }\n    max_fill", "    let mut grid = grid;\n    let mut count =\
    \ 0;\n    let mut max_row = 0;\n    let mut max_col = 0;\n    for row in grid.iter()\
    \ {\n        let mut sum = 0;\n        for col in row.iter() {\n            sum\
    \ += col;\n        }\n        if sum > max_row {\n            max_row = sum;\n\
    \        }\n    }\n    for col in 0..grid[0].len() {\n        let mut sum = 0;\n\
    \        for row in 0..grid.len() {\n            sum += grid[row][col];\n    \
    \    }\n        if sum > max_col {\n            max_col = sum;\n        }\n  \
    \  }\n    let mut max = max_row;\n    if max_col > max_row {\n        max = max_col;\n\
    \    }\n    let mut row_count = 0;\n    let mut col_count = 0;\n    while max\
    \ > 0 {\n        for row in 0..grid.len() {\n            for col in 0..grid[0].len()\
    \ {\n                if grid[row][col] > 0 {\n                    grid[row][col]\
    \ -= 1;\n                    row_count += 1;\n                }\n            }\n\
    \        }\n        for col in 0..grid[0].len() {\n            for row in 0..grid.len()\
    \ {\n                if grid[row][col] > 0 {\n                    grid[row][col]\
    \ -= 1;\n                    col_count += 1;\n                }\n            }\n\
    \        }\n        max -= 1;\n    }\n    count = row_count + col_count;\n   \
    \ count", "    let mut max_fill = 0;\n    for row in grid {\n        let mut fill\
    \ = 0;\n        for well in row {\n            fill += well;\n            if fill\
    \ > capacity {\n                max_fill += 1;\n                fill = 0;\n  \
    \          }\n        }\n        if fill > 0 {\n            max_fill += 1;\n \
    \       }\n    }\n    max_fill", "    let mut result = 0;\n    let mut current\
    \ = 0;\n    for row in grid {\n        for &cell in row.iter() {\n           \
    \ current += cell;\n            if current == capacity {\n                result\
    \ += 1;\n                current = 0;\n            } else if current > capacity\
    \ {\n                result += 1;\n                current = cell;\n         \
    \   }\n        }\n        if current > 0 {\n            result += 1;\n       \
    \     current = 0;\n        }\n    }\n    result", "    let mut count = 0;\n \
    \   let mut max_height = 0;\n    for row in grid {\n        let mut height = 0;\n\
    \        for cell in row {\n            if cell == 1 {\n                height\
    \ += 1;\n            }\n        }\n        if height > max_height {\n        \
    \    max_height = height;\n        }\n    }\n    for height in 0..max_height {\n\
    \        let mut row_count = 0;\n        for row in grid {\n            let mut\
    \ cell_count = 0;\n            for cell in row {\n                if cell == 1\
    \ {\n                    cell_count += 1;\n                }\n            }\n\
    \            if cell_count > height {\n                row_count += 1;\n     \
    \       }\n        }\n        count += row_count / capacity;\n        if row_count\
    \ % capacity != 0 {\n            count += 1;\n        }\n    }\n    count", " \
    \   let mut grid = grid;\n    let mut count = 0;\n    let mut i = 0;\n    while\
    \ i < grid.len() {\n        let mut j = 0;\n        while j < grid[i].len() {\n\
    \            if grid[i][j] == 1 {\n                let mut k = i;\n          \
    \      while k < grid.len() && grid[k][j] == 1 {\n                    grid[k][j]\
    \ = 0;\n                    k += 1;\n                }\n                count\
    \ += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n\
    \    count", "    let mut grid = grid;\n    let mut count = 0;\n    for i in 0..grid.len()\
    \ {\n        for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n \
    \               count += 1;\n                let mut k = i;\n                while\
    \ k < grid.len() && grid[k][j] == 1 {\n                    grid[k][j] = 0;\n \
    \                   k += 1;\n                }\n            }\n        }\n   \
    \ }\n    count", "    let mut count = 0;\n    let mut row = 0;\n    let mut col\
    \ = 0;\n    let mut row_max = 0;\n    let mut col_max = 0;\n    let mut row_sum\
    \ = 0;\n    let mut col_sum = 0;\n    let mut row_max_index = 0;\n    let mut\
    \ col_max_index = 0;\n    let mut row_max_sum = 0;\n    let mut col_max_sum =\
    \ 0;\n    let mut row_max_index_sum = 0;\n    let mut col_max_index_sum = 0;\n\
    \    let mut row_max_index_sum_max = 0;\n    let mut col_max_index_sum_max = 0;\n\
    \    let mut row_max_index_sum_max_index = 0;\n    let mut col_max_index_sum_max_index\
    \ = 0;\n    let mut row_max_index_sum_max_index_sum = 0;\n    let mut col_max_index_sum_max_index_sum\
    \ = 0;\n    let mut row_max_index_sum_max_index_sum_max = 0;\n    let mut col_max_index_sum_max_index_sum_max\
    \ = 0;\n    let mut row_max_index_sum_max_index_sum_max_index = 0;\n    let mut\
    \ col_max_index_sum_max_index_sum_max_index = 0;\n    let mut row_max_index_sum_max_index_sum_max_index_sum\
    \ = 0;\n    let mut col_max_index_sum_max_index_sum_max_index_sum = 0;\n    let\
    \ mut row_max_index_sum_max_index_sum_max_index_sum_max = 0;\n    let mut col_max_index_sum_max_index_sum_max_index_sum_max\
    \ = 0;\n    let mut row_max_index_sum_max_index_sum_max_index_sum_max_index =\
    \ 0;\n    let mut col_max_index_sum_max_index_sum_max_index_sum_max_index = 0;\n\
    \    let mut", "    let mut count = 0;\n    let mut row_max = 0;\n    for row\
    \ in grid {\n        let mut row_fill = 0;\n        for cell in row {\n      \
    \      if cell == 1 {\n                row_fill += 1;\n            }\n       \
    \ }\n        if row_fill > row_max {\n            row_max = row_fill;\n      \
    \  }\n    }\n    let mut col_max = 0;\n    for col in 0..grid[0].len() {\n   \
    \     let mut col_fill = 0;\n        for row in grid {\n            if row[col]\
    \ == 1 {\n                col_fill += 1;\n            }\n        }\n        if\
    \ col_fill > col_max {\n            col_max = col_fill;\n        }\n    }\n  \
    \  let mut row_fill = 0;\n    let mut col_fill = 0;\n    for row in grid {\n \
    \       for cell in row {\n            if cell == 1 {\n                row_fill\
    \ += 1;\n                col_fill += 1;\n            }\n        }\n        if\
    \ row_fill > capacity {\n            count += row_fill / capacity;\n         \
    \   row_fill = row_fill % capacity;\n        }\n        if col_fill > capacity\
    \ {\n            count += col_fill / capacity;\n            col_fill = col_fill\
    \ % capacity;\n        }\n    }\n    if row_fill > 0 {\n        count += 1;\n\
    \    }\n    if col_fill > 0 {\n        count += 1;\n    }\n    count", "    let\
    \ mut count = 0;\n    let mut max_height = 0;\n    for row in grid {\n       \
    \ let mut row_height = 0;\n        for cell in row {\n            if cell == 1\
    \ {\n                row_height += 1;\n            }\n        }\n        max_height\
    \ = max(max_height, row_height);\n    }\n    for _ in 0..max_height {\n      \
    \  for row in grid {\n            for cell in row {\n                if cell ==\
    \ 1 {\n                    count += 1;\n                }\n            }\n   \
    \     }\n    }\n    count", "    let mut fill = 0;\n    for row in grid {\n  \
    \      let mut row_fill = 0;\n        for well in row {\n            if well ==\
    \ 1 {\n                row_fill += 1;\n            }\n        }\n        fill\
    \ += (row_fill + capacity - 1) / capacity;\n    }\n    fill", "    let mut fill_count\
    \ = 0;\n    let mut wells = grid;\n    let mut bucket = capacity;\n    let mut\
    \ i = 0;\n    while i < wells.len() {\n        let mut j = 0;\n        while j\
    \ < wells[i].len() {\n            if wells[i][j] == 1 {\n                if bucket\
    \ > 0 {\n                    bucket -= 1;\n                    wells[i][j] = 0;\n\
    \                } else {\n                    fill_count += 1;\n            \
    \        bucket = capacity;\n                    j -= 1;\n                }\n\
    \            }\n            j += 1;\n        }\n        i += 1;\n    }\n    fill_count",
  "    let mut grid = grid;\n    let mut count = 0;\n    let mut row_max = vec![0;\
    \ grid.len()];\n    for row in grid.iter_mut() {\n        let mut max = 0;\n \
    \       for cell in row.iter_mut() {\n            if *cell == 1 {\n          \
    \      max += 1;\n            }\n            *cell = max;\n        }\n    }\n\
    \    for (i, row) in grid.iter().enumerate() {\n        let mut max = 0;\n   \
    \     for cell in row.iter() {\n            if *cell > max {\n               \
    \ max = *cell;\n            }\n        }\n        row_max[i] = max;\n    }\n \
    \   for row in grid.iter_mut() {\n        for cell in row.iter_mut() {\n     \
    \       if *cell > 0 {\n                *cell = 1;\n            }\n        }\n\
    \    }\n    for row in row_max.iter() {\n        count += row / capacity;\n  \
    \      if row % capacity > 0 {\n            count += 1;\n        }\n    }\n  \
    \  count", "    let mut grid = grid;\n    let mut count = 0;\n    let mut max\
    \ = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut() {\n\
    \            if *cell == 1 {\n                *cell = capacity;\n            }\n\
    \        }\n    }\n    let mut done = false;\n    while !done {\n        done\
    \ = true;\n        for row in grid.iter_mut() {\n            for cell in row.iter_mut()\
    \ {\n                if *cell > 0 {\n                    done = false;\n     \
    \               *cell -= 1;\n                }\n            }\n        }\n   \
    \     count += 1;\n    }\n    count - 1", "    let mut result = 0;\n    let mut\
    \ filled = vec![0; grid.len()];\n    for row in grid {\n        for (i, &cell)\
    \ in row.iter().enumerate() {\n            if cell == 1 {\n                if\
    \ filled[i] < capacity {\n                    filled[i] += 1;\n              \
    \  } else {\n                    result += 1;\n                }\n           \
    \ }\n        }\n    }\n    result", "    let mut grid = grid;\n    let mut count\
    \ = 0;\n    let mut max = 0;\n    for row in grid.iter_mut() {\n        let mut\
    \ row_max = 0;\n        for cell in row.iter_mut() {\n            if *cell ==\
    \ 1 {\n                row_max += 1;\n            }\n        }\n        if row_max\
    \ > max {\n            max = row_max;\n        }\n    }\n    let mut row_max =\
    \ 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut() {\n\
    \            if *cell == 1 {\n                row_max += 1;\n            }\n \
    \       }\n        if row_max == max {\n            count += 1;\n            row_max\
    \ = 0;\n        }\n    }\n    count", "    let mut count = 0;\n    let mut wells\
    \ = grid.iter().map(|row| row.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    let mut bucket = capacity;\n    for well in wells.iter_mut() {\n        if\
    \ *well > 0 {\n            if bucket >= *well {\n                bucket -= *well;\n\
    \                *well = 0;\n            } else {\n                *well -= bucket;\n\
    \                bucket = capacity;\n                count += 1;\n           \
    \ }\n        }\n    }\n    count", "    let mut grid = grid;\n    let mut count\
    \ = 0;\n    let mut max = 0;\n    for row in grid.iter_mut() {\n        let mut\
    \ sum = 0;\n        for cell in row.iter_mut() {\n            sum += *cell;\n\
    \            *cell = 0;\n        }\n        max = max.max(sum);\n    }\n    while\
    \ max > 0 {\n        count += 1;\n        for row in grid.iter_mut() {\n     \
    \       let mut sum = 0;\n            for cell in row.iter_mut() {\n         \
    \       sum += *cell;\n                if sum < capacity {\n                 \
    \   *cell = 1;\n                } else {\n                    *cell = 0;\n   \
    \             }\n            }\n        }\n        max = 0;\n        for row in\
    \ grid.iter() {\n            let mut sum = 0;\n            for cell in row.iter()\
    \ {\n                sum += *cell;\n            }\n            max = max.max(sum);\n\
    \        }\n    }\n    count", "    let mut max_fill = 0;\n    for row in grid\
    \ {\n        let mut fill = 0;\n        for &well in row.iter() {\n          \
    \  fill += well;\n            if fill > capacity {\n                fill = capacity;\n\
    \            }\n        }\n        max_fill = std::cmp::max(max_fill, fill);\n\
    \    }\n    max_fill", "    let mut count = 0;\n    let mut max_row = vec![0;\
    \ grid[0].len()];\n    for row in grid {\n        for (i, &cell) in row.iter().enumerate()\
    \ {\n            if cell == 1 {\n                max_row[i] += 1;\n          \
    \  }\n        }\n    }\n    for &max in max_row.iter() {\n        count += (max\
    \ + capacity - 1) / capacity;\n    }\n    count", "    let mut result = 0;\n \
    \   let mut row = 0;\n    let mut col = 0;\n    let mut max_row = 0;\n    let\
    \ mut max_col = 0;\n    let mut max_val = 0;\n    let mut curr_val = 0;\n    let\
    \ mut curr_row = 0;\n    let mut curr_col = 0;\n    let mut curr_max_val = 0;\n\
    \    let mut curr_max_row = 0;\n    let mut curr_max_col = 0;\n    let mut curr_max_row_val\
    \ = 0;\n    let mut curr_max_col_val = 0;\n    let mut curr_max_row_col = 0;\n\
    \    let mut curr_max_col_row = 0;\n    let mut curr_max_row_col_val = 0;\n  \
    \  let mut curr_max_col_row_val = 0;\n    let mut curr_max_row_col_val_row = 0;\n\
    \    let mut curr_max_col_row_val_col = 0;\n    let mut curr_max_row_col_val_row_col\
    \ = 0;\n    let mut curr_max_col_row_val_col_row = 0;\n    let mut curr_max_row_col_val_row_col_val\
    \ = 0;\n    let mut curr_max_col_row_val_col_row_val = 0;\n    let mut curr_max_row_col_val_row_col_val_row\
    \ = 0;\n    let mut curr_max_col_row_val_col_row_val_col = 0;\n    let mut curr_max_row_col_val_row_col_val_row_col\
    \ = 0;\n    let mut curr_max_col_row_val_col_row_val_col_row = 0;\n    let mut\
    \ curr_max_row_col_val_row_col_val_row_col_val = 0;\n    let mut curr_max_col_row_val_col_row_val_col_row_val\
    \ = 0;\n    let mut", "    let mut max_fill = 0;\n    for row in grid {\n    \
    \    let mut fill = 0;\n        for &well in row.iter() {\n            fill +=\
    \ well;\n            if fill > capacity {\n                max_fill += 1;\n  \
    \              fill = well;\n            }\n        }\n        max_fill += 1;\n\
    \    }\n    max_fill", "    let mut count = 0;\n    let mut row = 0;\n    let\
    \ mut col = 0;\n    let mut sum = 0;\n    let mut max_sum = 0;\n    let mut max_row\
    \ = 0;\n    let mut max_col = 0;\n    let mut max_count = 0;\n    let mut max_count_row\
    \ = 0;\n    let mut max_count_col = 0;\n    let mut max_count_sum = 0;\n    let\
    \ mut max_count_max_sum = 0;\n    let mut max_count_max_row = 0;\n    let mut\
    \ max_count_max_col = 0;\n    let mut max_count_max_count = 0;\n    let mut max_count_max_count_row\
    \ = 0;\n    let mut max_count_max_count_col = 0;\n    let mut max_count_max_count_sum\
    \ = 0;\n    let mut max_count_max_count_max_sum = 0;\n    let mut max_count_max_count_max_row\
    \ = 0;\n    let mut max_count_max_count_max_col = 0;\n    let mut max_count_max_count_max_count\
    \ = 0;\n    let mut max_count_max_count_max_count_row = 0;\n    let mut max_count_max_count_max_count_col\
    \ = 0;\n    let mut max_count_max_count_max_count_sum = 0;\n    let mut max_count_max_count_max_count_max_sum\
    \ = 0;\n    let mut max_count_max_count_max_count_max_row = 0;\n    let mut max_count_max_count_max_count_max_col\
    \ = 0;\n    let mut max_count_max_count_max_count_max_count = 0;\n    let mut\
    \ max_count_max_count_max_count_max_count_row = 0;\n    let mut max_count_max_count_max_count_max_count_col\
    \ = 0;\n    let mut max_count_max_count_max_count_max_count_sum = 0;\n    let\
    \ mut max_count_", "    let mut max_fill = 0;\n    for row in grid {\n       \
    \ let mut fill = 0;\n        for &well in row.iter() {\n            if well ==\
    \ 1 {\n                fill += 1;\n            } else {\n                fill\
    \ = 0;\n            }\n            if fill > max_fill {\n                max_fill\
    \ = fill;\n            }\n        }\n    }\n    (max_fill + capacity - 1) / capacity",
  "    let mut count = 0;\n    let mut wells = grid.clone();\n    let mut row_max\
    \ = vec![0; wells.len()];\n    for i in 0..wells.len() {\n        for j in 0..wells[i].len()\
    \ {\n            if wells[i][j] == 1 {\n                row_max[i] = j;\n    \
    \        }\n        }\n    }\n    let mut max_col = 0;\n    for i in 0..wells.len()\
    \ {\n        if row_max[i] > max_col {\n            max_col = row_max[i];\n  \
    \      }\n    }\n    for i in 0..max_col + 1 {\n        let mut col_max = 0;\n\
    \        for j in 0..wells.len() {\n            if wells[j][i] == 1 {\n      \
    \          col_max = j;\n            }\n        }\n        for j in 0..col_max\
    \ + 1 {\n            if wells[j][i] == 1 {\n                wells[j][i] = 0;\n\
    \                count += 1;\n            }\n        }\n    }\n    count", " \
    \   let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n\
    \        for &well in row.iter() {\n            fill += well;\n            if\
    \ fill > capacity {\n                max_fill += 1;\n                fill = well;\n\
    \            }\n        }\n        max_fill += 1;\n    }\n    max_fill", "   \
    \ let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n  \
    \      for well in row {\n            if well == 1 {\n                fill +=\
    \ 1;\n            }\n        }\n        max_fill = std::cmp::max(max_fill, fill);\n\
    \    }\n    max_fill / capacity + if max_fill % capacity == 0 { 0 } else { 1 }",
  "    let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n \
    \       for well in row {\n            fill += well;\n            if fill > capacity\
    \ {\n                max_fill += 1;\n                fill = 0;\n            }\n\
    \        }\n        if fill > 0 {\n            max_fill += 1;\n        }\n   \
    \ }\n    max_fill", "    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid.iter_mut() {\n        let mut sum = 0;\n \
    \       for cell in row.iter_mut() {\n            sum += *cell;\n            *cell\
    \ = 0;\n        }\n        if sum > max {\n            max = sum;\n        }\n\
    \    }\n    while max > 0 {\n        for row in grid.iter_mut() {\n          \
    \  for cell in row.iter_mut() {\n                if *cell < capacity {\n     \
    \               *cell += 1;\n                }\n            }\n        }\n   \
    \     count += 1;\n        max -= capacity;\n    }\n    count", "    let mut count\
    \ = 0;\n    let mut max_fill = 0;\n    for row in grid {\n        for cell in\
    \ row {\n            if cell == 1 {\n                max_fill += 1;\n        \
    \    }\n        }\n    }\n    let mut fill = 0;\n    while fill < max_fill {\n\
    \        for row in grid {\n            for cell in row {\n                if\
    \ cell == 1 {\n                    fill += 1;\n                    if fill ==\
    \ max_fill {\n                        return count;\n                    }\n \
    \               }\n            }\n            count += 1;\n        }\n    }\n\
    \    count", "    let mut res = 0;\n    let mut row_max = vec![0; grid.len()];\n\
    \    for row in grid {\n        let mut max = 0;\n        for &col in row.iter()\
    \ {\n            max = max.max(col);\n        }\n        row_max.push(max);\n\
    \    }\n    for &max in row_max.iter() {\n        res += max / capacity;\n   \
    \     if max % capacity != 0 {\n            res += 1;\n        }\n    }\n    res",
  "    let mut grid = grid;\n    let mut count = 0;\n    let mut max_height = 0;\n\
    \    for row in grid.iter_mut() {\n        let mut row_max = 0;\n        for cell\
    \ in row.iter_mut() {\n            if *cell == 1 {\n                row_max +=\
    \ 1;\n            }\n        }\n        if row_max > max_height {\n          \
    \  max_height = row_max;\n        }\n    }\n    for _ in 0..max_height {\n   \
    \     let mut row_max = 0;\n        for row in grid.iter_mut() {\n           \
    \ let mut row_max_here = 0;\n            for cell in row.iter_mut() {\n      \
    \          if *cell == 1 {\n                    row_max_here += 1;\n         \
    \       }\n            }\n            if row_max_here > row_max {\n          \
    \      row_max = row_max_here;\n            }\n        }\n        if row_max >\
    \ capacity {\n            count += row_max / capacity;\n            if row_max\
    \ % capacity != 0 {\n                count += 1;\n            }\n        } else\
    \ {\n            count += 1;\n        }\n        for row in grid.iter_mut() {\n\
    \            for cell in row.iter_mut() {\n                if *cell == 1 {\n \
    \                   *cell = 0;\n                }\n            }\n        }\n\
    \    }\n    count", "    let mut count = 0;\n    let mut max_row = 0;\n    for\
    \ row in grid {\n        let mut sum = 0;\n        for &cell in row.iter() {\n\
    \            sum += cell;\n        }\n        max_row = max(max_row, sum);\n \
    \   }\n    for _ in 0..max_row {\n        for row in grid {\n            for &cell\
    \ in row.iter() {\n                if cell > 0 {\n                    count +=\
    \ 1;\n                    break;\n                }\n            }\n        }\n\
    \    }\n    count", "    let mut result = 0;\n    let mut row_max = 0;\n    for\
    \ row in grid {\n        let mut row_sum = 0;\n        for &cell in row.iter()\
    \ {\n            row_sum += cell;\n        }\n        row_max = std::cmp::max(row_max,\
    \ row_sum);\n        result += row_sum;\n    }\n    result - row_max * capacity",
  "    let mut total = 0;\n    let mut fill = 0;\n    for row in grid {\n        for\
    \ cell in row {\n            if cell == 1 {\n                fill += 1;\n    \
    \        } else {\n                if fill > 0 {\n                    let bucket_fill\
    \ = std::cmp::min(fill, capacity);\n                    total += 1;\n        \
    \            fill -= bucket_fill;\n                }\n            }\n        }\n\
    \        if fill > 0 {\n            total += 1;\n            fill = 0;\n     \
    \   }\n    }\n    total", "    let mut result = 0;\n    let mut row_max = vec![0;\
    \ grid.len()];\n    for row in grid {\n        let mut max = 0;\n        for &col\
    \ in row.iter() {\n            max = max.max(col);\n        }\n        row_max.push(max);\n\
    \    }\n    for &max in row_max.iter() {\n        result += max / capacity;\n\
    \        if max % capacity != 0 {\n            result += 1;\n        }\n    }\n\
    \    result", "    let mut fill = 0;\n    for row in grid {\n        let mut water\
    \ = 0;\n        for well in row {\n            water += well;\n            if\
    \ water > capacity {\n                fill += 1;\n                water = capacity;\n\
    \            }\n        }\n    }\n    fill", "    let mut fill = 0;\n    let mut\
    \ row_max = 0;\n    for row in grid {\n        for cell in row {\n           \
    \ if cell > row_max {\n                row_max = cell;\n            }\n      \
    \  }\n        fill += row_max / capacity;\n        if row_max % capacity != 0\
    \ {\n            fill += 1;\n        }\n        row_max = 0;\n    }\n    fill",
  "    let mut grid = grid;\n    let mut count = 0;\n    let mut max_row = 0;\n  \
    \  let mut max_col = 0;\n    for row in grid.iter() {\n        let mut row_sum\
    \ = 0;\n        for col in row.iter() {\n            row_sum += col;\n       \
    \ }\n        if row_sum > max_row {\n            max_row = row_sum;\n        }\n\
    \    }\n    for col in 0..grid[0].len() {\n        let mut col_sum = 0;\n    \
    \    for row in grid.iter() {\n            col_sum += row[col];\n        }\n \
    \       if col_sum > max_col {\n            max_col = col_sum;\n        }\n  \
    \  }\n    let mut max_fill = max_row;\n    if max_col > max_row {\n        max_fill\
    \ = max_col;\n    }\n    if max_fill > capacity {\n        max_fill = capacity;\n\
    \    }\n    for row in grid.iter_mut() {\n        for col in row.iter_mut() {\n\
    \            if *col > 0 {\n                *col -= max_fill;\n              \
    \  count += 1;\n            }\n        }\n    }\n    count", "    let mut fill\
    \ = 0;\n    let mut max_fill = 0;\n    for row in grid {\n        for &well in\
    \ row.iter() {\n            fill += well;\n            if fill > capacity {\n\
    \                max_fill += 1;\n                fill = 0;\n            }\n  \
    \      }\n        max_fill += 1;\n        fill = 0;\n    }\n    max_fill", " \
    \   let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n\
    \        for &well in row.iter() {\n            fill += well;\n            if\
    \ fill > capacity {\n                max_fill += 1;\n                fill = well;\n\
    \            }\n        }\n        max_fill += 1;\n    }\n    max_fill", "   \
    \ let mut grid = grid;\n    let mut count = 0;\n    let mut max_height = 0;\n\
    \    for row in grid.iter_mut() {\n        let mut row_max = 0;\n        for cell\
    \ in row.iter_mut() {\n            if *cell == 1 {\n                row_max +=\
    \ 1;\n            }\n        }\n        if row_max > max_height {\n          \
    \  max_height = row_max;\n        }\n    }\n    for _ in 0..max_height {\n   \
    \     for row in grid.iter_mut() {\n            for cell in row.iter_mut() {\n\
    \                if *cell == 1 {\n                    *cell = 0;\n           \
    \         count += 1;\n                }\n            }\n        }\n    }\n  \
    \  count", "    let mut count = 0;\n    let mut row_max = vec![0; grid.len()];\n\
    \    for row in grid {\n        let mut max = 0;\n        for &val in row.iter()\
    \ {\n            max = max.max(val);\n        }\n        row_max.push(max);\n\
    \    }\n    for &max in row_max.iter() {\n        count += max / capacity;\n \
    \       if max % capacity != 0 {\n            count += 1;\n        }\n    }\n\
    \    count", "    let mut max_fill = 0;\n    for row in grid {\n        let mut\
    \ fill = 0;\n        for &well in row.iter() {\n            fill += well;\n  \
    \          if fill > capacity {\n                max_fill += 1;\n            \
    \    fill = well;\n            }\n        }\n        max_fill += 1;\n    }\n \
    \   max_fill", "    let mut grid = grid;\n    let mut count = 0;\n    let mut\
    \ max_height = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell == 1 {\n                *cell = capacity;\n        \
    \        max_height = max_height.max(capacity);\n            }\n        }\n  \
    \  }\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut() {\n\
    \            if *cell > 0 {\n                *cell -= 1;\n                count\
    \ += 1;\n            }\n        }\n    }\n    count + max_height", "    let mut\
    \ result = 0;\n    let mut water = 0;\n    let mut row = 0;\n    let mut col =\
    \ 0;\n    let rows = grid.len();\n    let cols = grid[0].len();\n    while row\
    \ < rows {\n        while col < cols {\n            water += grid[row][col];\n\
    \            if water == capacity {\n                result += 1;\n          \
    \      water = 0;\n            } else if water > capacity {\n                result\
    \ += 1;\n                water = 1;\n            }\n            col += 1;\n  \
    \      }\n        col = 0;\n        row += 1;\n    }\n    if water > 0 {\n   \
    \     result += 1;\n    }\n    result", "    let mut count = 0;\n    for row in\
    \ grid {\n        let mut filled = 0;\n        for cell in row {\n           \
    \ filled += cell;\n            if filled == capacity {\n                count\
    \ += 1;\n                filled = 0;\n            }\n        }\n        if filled\
    \ > 0 {\n            count += 1;\n        }\n    }\n    count", "    let mut count\
    \ = 0;\n    let mut row_max = vec![0; grid.len()];\n    for row in grid {\n  \
    \      let mut max = 0;\n        for &col in row.iter() {\n            max = max.max(col);\n\
    \        }\n        row_max.push(max);\n    }\n    for &max in row_max.iter()\
    \ {\n        let mut fill = max;\n        while fill > 0 {\n            count\
    \ += 1;\n            fill -= capacity;\n        }\n    }\n    count", "    let\
    \ mut fill = 0;\n    let mut max_fill = 0;\n    for row in grid {\n        for\
    \ &well in row.iter() {\n            fill += well;\n            if fill > capacity\
    \ {\n                max_fill += 1;\n                fill = 0;\n            }\n\
    \        }\n        max_fill += 1;\n        fill = 0;\n    }\n    max_fill", " \
    \   let mut res = 0;\n    for row in grid {\n        let mut well = 0;\n     \
    \   for &cell in &row {\n            if cell == 1 {\n                well += 1;\n\
    \            }\n        }\n        res += well / capacity;\n        if well %\
    \ capacity != 0 {\n            res += 1;\n        }\n    }\n    res", "    let\
    \ mut max = 0;\n    for row in grid {\n        let mut sum = 0;\n        for &cell\
    \ in row.iter() {\n            sum += cell;\n            if sum > capacity {\n\
    \                max += 1;\n                sum = cell;\n            }\n     \
    \   }\n    }\n    max", "    let mut grid = grid;\n    let mut count = 0;\n  \
    \  let mut max_height = 0;\n    for row in grid.iter_mut() {\n        let mut\
    \ height = 0;\n        for cell in row.iter_mut() {\n            if *cell == 1\
    \ {\n                height += 1;\n            } else {\n                height\
    \ = 0;\n            }\n            *cell = height;\n        }\n        max_height\
    \ = max(max_height, height);\n    }\n    for height in 1..=max_height {\n    \
    \    let mut row_count = 0;\n        for row in grid.iter() {\n            let\
    \ mut row_height = 0;\n            for cell in row.iter() {\n                if\
    \ *cell >= height {\n                    row_height += 1;\n                } else\
    \ {\n                    row_height = 0;\n                }\n                if\
    \ row_height == capacity {\n                    row_count += 1;\n            \
    \        row_height = 0;\n                }\n            }\n        }\n      \
    \  count += row_count;\n    }\n    count", "    let mut max_fill = 0;\n    let\
    \ mut fill = 0;\n    for row in grid {\n        for col in row {\n           \
    \ if col == 1 {\n                fill += 1;\n            }\n        }\n      \
    \  max_fill = max(max_fill, fill);\n        fill = 0;\n    }\n    max_fill / capacity\
    \ + if max_fill % capacity == 0 { 0 } else { 1 }", "    let mut max_fill = 0;\n\
    \    let mut max_fill_count = 0;\n    for row in grid {\n        let mut fill\
    \ = 0;\n        for &cell in row.iter() {\n            fill += cell;\n       \
    \     if fill > capacity {\n                max_fill_count += 1;\n           \
    \     fill = capacity;\n            }\n        }\n        max_fill = max_fill.max(fill);\n\
    \    }\n    max_fill_count + max_fill", "    let mut count = 0;\n    let mut max\
    \ = 0;\n    for row in grid {\n        for col in row {\n            if col ==\
    \ 1 {\n                max += 1;\n            }\n        }\n    }\n    let mut\
    \ filled = 0;\n    while filled < max {\n        filled = 0;\n        for row\
    \ in grid {\n            let mut row_filled = 0;\n            for col in row {\n\
    \                if col == 1 {\n                    row_filled += 1;\n       \
    \         }\n            }\n            if row_filled > capacity {\n         \
    \       filled += capacity;\n            } else {\n                filled += row_filled;\n\
    \            }\n        }\n        count += 1;\n    }\n    count", "    let mut\
    \ count = 0;\n    let mut row_max = vec![0; grid.len()];\n    for row in grid\
    \ {\n        let mut max = 0;\n        for &col in row.iter() {\n            max\
    \ = max.max(col);\n        }\n        row_max.push(max);\n    }\n    for &max\
    \ in row_max.iter() {\n        count += max / capacity;\n        if max % capacity\
    \ != 0 {\n            count += 1;\n        }\n    }\n    count", "    let mut\
    \ wells = grid.iter().map(|row| row.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    let mut count = 0;\n    while wells.iter().any(|&w| w > 0) {\n        for\
    \ i in 0..wells.len() {\n            if wells[i] > 0 {\n                wells[i]\
    \ -= capacity;\n                count += 1;\n            }\n        }\n    }\n\
    \    count", "    let mut count = 0;\n    for row in grid {\n        let mut fill\
    \ = 0;\n        for &well in row.iter() {\n            fill += well;\n       \
    \     if fill == capacity {\n                count += 1;\n                fill\
    \ = 0;\n            }\n        }\n        if fill > 0 {\n            count +=\
    \ 1;\n        }\n    }\n    count", "    let mut result = 0;\n    let mut max_height\
    \ = 0;\n    for row in grid {\n        for &height in &row {\n            if height\
    \ > max_height {\n                max_height = height;\n            }\n      \
    \  }\n    }\n    for height in 0..max_height {\n        let mut fill = 0;\n  \
    \      for row in &grid {\n            for &well in row {\n                if\
    \ well > height {\n                    fill += 1;\n                }\n       \
    \     }\n        }\n        result += (fill + capacity - 1) / capacity;\n    }\n\
    \    result", "    let mut grid = grid;\n    let mut count = 0;\n    let mut row\
    \ = 0;\n    while row < grid.len() {\n        let mut col = 0;\n        while\
    \ col < grid[row].len() {\n            if grid[row][col] == 1 {\n            \
    \    let mut col_next = col + 1;\n                while col_next < grid[row].len()\
    \ && grid[row][col_next] == 1 {\n                    col_next += 1;\n        \
    \        }\n                let mut row_next = row + 1;\n                while\
    \ row_next < grid.len() && grid[row_next][col] == 1 {\n                    row_next\
    \ += 1;\n                }\n                let mut row_cur = row;\n         \
    \       while row_cur < row_next {\n                    let mut col_cur = col;\n\
    \                    while col_cur < col_next {\n                        grid[row_cur][col_cur]\
    \ = 0;\n                        col_cur += 1;\n                    }\n       \
    \             row_cur += 1;\n                }\n                count += 1;\n\
    \                col = col_next;\n            } else {\n                col +=\
    \ 1;\n            }\n        }\n        row += 1;\n    }\n    count", "    let\
    \ mut count = 0;\n    let mut wells = grid.clone();\n    let mut row_max = vec![0;\
    \ wells.len()];\n    for i in 0..wells.len() {\n        row_max[i] = wells[i].iter().max().unwrap();\n\
    \    }\n    let mut col_max = vec![0; wells[0].len()];\n    for j in 0..wells[0].len()\
    \ {\n        col_max[j] = wells.iter().map(|row| row[j]).max().unwrap();\n   \
    \ }\n    let mut row_max_idx = vec![0; wells.len()];\n    for i in 0..wells.len()\
    \ {\n        row_max_idx[i] = wells[i].iter().position(|&x| x == row_max[i]).unwrap();\n\
    \    }\n    let mut col_max_idx = vec![0; wells[0].len()];\n    for j in 0..wells[0].len()\
    \ {\n        col_max_idx[j] = wells.iter().position(|row| row[j] == col_max[j]).unwrap();\n\
    \    }\n    let mut row_max_idx_set = HashSet::new();\n    let mut col_max_idx_set\
    \ = HashSet::new();\n    for i in 0..wells.len() {\n        row_max_idx_set.insert(row_max_idx[i]);\n\
    \    }\n    for j in 0..wells[0].len() {\n        col_max_idx_set.insert(col_max_idx[j]);\n\
    \    }\n    let mut row_max_idx_set_iter = row_max_idx_set.iter();\n    let mut\
    \ col_max_idx_set_iter = col_max_idx_set.iter();\n    let mut row_max_idx_set_iter_next\
    \ = row_max_idx_set_iter.next();\n    let mut col_max_idx_set_iter_next = col_max_idx_set_iter.next();\n",
  "    let mut wells = grid.iter().map(|row| row.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    let mut count = 0;\n    while wells.iter().any(|&w| w > 0) {\n        for\
    \ w in wells.iter_mut() {\n            if *w > capacity {\n                *w\
    \ -= capacity;\n            } else {\n                *w = 0;\n            }\n\
    \        }\n        count += 1;\n    }\n    count", "    let mut result = 0;\n\
    \    let mut row_max = vec![0; grid.len()];\n    for i in 0..grid.len() {\n  \
    \      for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n       \
    \         row_max[i] = j as isize;\n            }\n        }\n    }\n    let mut\
    \ col_max = vec![0; grid[0].len()];\n    for j in 0..grid[0].len() {\n       \
    \ for i in 0..grid.len() {\n            if grid[i][j] == 1 {\n               \
    \ col_max[j] = i as isize;\n            }\n        }\n    }\n    for i in 0..grid.len()\
    \ {\n        for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n \
    \               let mut fill = capacity;\n                let mut row_fill = capacity;\n\
    \                let mut col_fill = capacity;\n                if row_max[i] >\
    \ j as isize {\n                    row_fill = capacity - (row_max[i] - j as isize);\n\
    \                }\n                if col_max[j] > i as isize {\n           \
    \         col_fill = capacity - (col_max[j] - i as isize);\n                }\n\
    \                fill = std::cmp::min(row_fill, col_fill);\n                result\
    \ += fill;\n            }\n        }\n    }\n    result", "    let mut max_fill\
    \ = 0;\n    let mut fill = 0;\n    for row in grid {\n        for well in row\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = 0;\n            }\n        }\n  \
    \      max_fill += 1;\n        fill = 0;\n    }\n    max_fill", "    let mut fill\
    \ = 0;\n    let mut row_max = vec![0; grid.len()];\n    for row in grid {\n  \
    \      let mut max = 0;\n        for &cell in row.iter() {\n            max =\
    \ max.max(cell);\n        }\n        row_max.push(max);\n    }\n    for &max in\
    \ row_max.iter() {\n        fill += max / capacity;\n        if max % capacity\
    \ != 0 {\n            fill += 1;\n        }\n    }\n    fill", "    let mut result\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in\
    \ row.iter() {\n            fill += well;\n            if fill == capacity {\n\
    \                result += 1;\n                fill = 0;\n            }\n    \
    \    }\n        if fill > 0 {\n            result += 1;\n        }\n    }\n  \
    \  result", "    let mut result = 0;\n    for row in grid {\n        let mut fill\
    \ = 0;\n        for &cell in row.iter() {\n            fill += cell;\n       \
    \     if fill == capacity {\n                result += 1;\n                fill\
    \ = 0;\n            }\n        }\n        if fill > 0 {\n            result +=\
    \ 1;\n        }\n    }\n    result", "    let mut max_fill = 0;\n    let mut fill\
    \ = 0;\n    for row in grid {\n        for cell in row {\n            fill +=\
    \ cell;\n            if fill > capacity {\n                max_fill += 1;\n  \
    \              fill = cell;\n            }\n        }\n        max_fill += 1;\n\
    \        fill = 0;\n    }\n    max_fill", "    let mut max_fill = 0;\n    for\
    \ row in grid {\n        let mut fill = 0;\n        for &well in row.iter() {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ fill = capacity;\n            }\n        }\n        max_fill = max(max_fill,\
    \ fill);\n    }\n    max_fill", "    let mut result = 0;\n    let mut row_max\
    \ = 0;\n    for row in grid {\n        for col in row {\n            if col >\
    \ row_max {\n                row_max = col;\n            }\n        }\n      \
    \  result += row_max / capacity;\n        if row_max % capacity != 0 {\n     \
    \       result += 1;\n        }\n        row_max = 0;\n    }\n    result", " \
    \   let mut fill = 0;\n    let mut max_fill = 0;\n    for row in grid {\n    \
    \    for cell in row {\n            if cell == 1 {\n                fill += 1;\n\
    \            }\n        }\n        max_fill = std::cmp::max(max_fill, fill);\n\
    \        fill = 0;\n    }\n    max_fill / capacity + if max_fill % capacity ==\
    \ 0 { 0 } else { 1 }", "    let mut result = 0;\n    let mut max = 0;\n    for\
    \ row in grid {\n        for &cell in row.iter() {\n            if cell == 1 {\n\
    \                max += 1;\n            }\n        }\n    }\n    let mut fill\
    \ = 0;\n    for row in grid {\n        for &cell in row.iter() {\n           \
    \ if cell == 1 {\n                fill += 1;\n            }\n        }\n     \
    \   if fill == max {\n            break;\n        }\n        result += 1;\n  \
    \      fill = 0;\n    }\n    result", "    let mut max_fill = 0;\n    for row\
    \ in grid {\n        let mut fill = 0;\n        for &well in row.iter() {\n  \
    \          fill += well;\n            if fill > capacity {\n                max_fill\
    \ += 1;\n                fill = well;\n            }\n        }\n        max_fill\
    \ += 1;\n    }\n    max_fill", "    let mut grid = grid;\n    let mut count =\
    \ 0;\n    for row in grid.iter_mut() {\n        let mut sum = 0;\n        for\
    \ col in row.iter_mut() {\n            sum += *col;\n            *col = 0;\n \
    \       }\n        count += sum / capacity;\n        if sum % capacity != 0 {\n\
    \            count += 1;\n        }\n    }\n    count", "    let mut result =\
    \ 0;\n    let mut row_max = vec![0; grid.len()];\n    let mut col_max = vec![0;\
    \ grid[0].len()];\n    for (i, row) in grid.iter().enumerate() {\n        for\
    \ (j, &cell) in row.iter().enumerate() {\n            row_max[i] = row_max[i].max(cell);\n\
    \            col_max[j] = col_max[j].max(cell);\n        }\n    }\n    for (i,\
    \ row) in grid.iter().enumerate() {\n        for (j, &cell) in row.iter().enumerate()\
    \ {\n            let max_fill = row_max[i].min(col_max[j]);\n            result\
    \ += max_fill - cell;\n        }\n    }\n    result", "    let mut max_fill =\
    \ 0;\n    for row in grid {\n        let mut fill = 0;\n        for cell in row\
    \ {\n            if cell == 1 {\n                fill += 1;\n            }\n \
    \       }\n        max_fill = max(max_fill, fill);\n    }\n    max_fill / capacity\
    \ + if max_fill % capacity == 0 { 0 } else { 1 }", "    let mut result = 0;\n\
    \    let mut row_max = vec![0; grid.len()];\n    for row in grid {\n        let\
    \ mut row_max = 0;\n        for &col in row.iter() {\n            row_max = std::cmp::max(row_max,\
    \ col);\n        }\n        result += row_max;\n    }\n    result", "    let mut\
    \ max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n        for\
    \ &col in row.iter() {\n            fill += col;\n            if fill > capacity\
    \ {\n                max_fill += 1;\n                fill = col;\n           \
    \ }\n        }\n        max_fill += 1;\n    }\n    max_fill", "    let mut count\
    \ = 0;\n    let mut max = 0;\n    for row in grid {\n        for cell in row {\n\
    \            if cell == 1 {\n                max += 1;\n            }\n      \
    \  }\n    }\n    while max > 0 {\n        let mut current = 0;\n        for row\
    \ in grid {\n            for cell in row {\n                if cell == 1 {\n \
    \                   current += 1;\n                }\n            }\n        \
    \    if current > capacity {\n                current = capacity;\n          \
    \  }\n            max -= current;\n            count += 1;\n        }\n    }\n\
    \    count", "    let mut count = 0;\n    let mut wells = grid.iter().map(|row|\
    \ {\n        let mut sum = 0;\n        for &c in row {\n            sum += c;\n\
    \        }\n        sum\n    }).collect::<Vec<isize>>();\n    while wells.iter().any(|&w|\
    \ w > 0) {\n        count += 1;\n        for w in wells.iter_mut() {\n       \
    \     if *w > capacity {\n                *w -= capacity;\n            } else\
    \ {\n                *w = 0;\n            }\n        }\n    }\n    count", " \
    \   let mut count = 0;\n    let mut wells = grid.iter().map(|row| row.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    while wells.iter().any(|&w| w > 0) {\n        let mut i = 0;\n        while\
    \ i < wells.len() {\n            if wells[i] > 0 {\n                wells[i] -=\
    \ capacity;\n                count += 1;\n            }\n            i += 1;\n\
    \        }\n    }\n    count", "    let mut grid = grid;\n    let mut count =\
    \ 0;\n    let mut row = 0;\n    let mut col = 0;\n    let mut col_max = 0;\n \
    \   let mut row_max = 0;\n    let mut col_min = 0;\n    let mut row_min = 0;\n\
    \    let mut row_sum = 0;\n    let mut col_sum = 0;\n    let mut row_max_index\
    \ = 0;\n    let mut col_max_index = 0;\n    let mut row_min_index = 0;\n    let\
    \ mut col_min_index = 0;\n    let mut row_sum_index = 0;\n    let mut col_sum_index\
    \ = 0;\n    let mut row_max_index_temp = 0;\n    let mut col_max_index_temp =\
    \ 0;\n    let mut row_min_index_temp = 0;\n    let mut col_min_index_temp = 0;\n\
    \    let mut row_sum_index_temp = 0;\n    let mut col_sum_index_temp = 0;\n  \
    \  let mut row_max_temp = 0;\n    let mut col_max_temp = 0;\n    let mut row_min_temp\
    \ = 0;\n    let mut col_min_temp = 0;\n    let mut row_sum_temp = 0;\n    let\
    \ mut col_sum_temp = 0;\n    let mut row_max_temp_temp = 0;\n    let mut col_max_temp_temp\
    \ = 0;\n    let mut row_min_temp_temp = 0;\n    let mut col_min_temp_temp = 0;\n\
    \    let mut row_sum_temp_temp = 0;\n    let mut col_sum_temp_temp = 0;\n    let\
    \ mut row_max_temp_temp_temp = 0;\n    let mut col_max_temp_temp_temp = 0;\n \
    \   let mut row_min_temp_temp_temp = 0;\n    let mut col_min_temp_temp_temp =\
    \ 0;\n    let mut row_sum_temp_temp_temp = 0;\n    let mut col_sum_temp_temp_temp\
    \ = 0;\n    let mut row_max_temp_temp_", "    let mut result = 0;\n    let mut\
    \ wells = grid.iter().map(|row| row.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    let mut filled = wells.iter().map(|_| 0).collect::<Vec<isize>>();\n    let\
    \ mut bucket = capacity;\n    loop {\n        let mut i = 0;\n        while i\
    \ < wells.len() {\n            if wells[i] > 0 {\n                if bucket >\
    \ 0 {\n                    let amount = bucket.min(wells[i]);\n              \
    \      bucket -= amount;\n                    wells[i] -= amount;\n          \
    \          filled[i] += amount;\n                } else {\n                  \
    \  bucket = capacity;\n                    result += 1;\n                }\n \
    \           }\n            i += 1;\n        }\n        if wells.iter().sum::<isize>()\
    \ == 0 {\n            break;\n        }\n    }\n    result", "    let mut fill\
    \ = 0;\n    let mut max_fill = 0;\n    for row in grid {\n        for &well in\
    \ row.iter() {\n            fill += well;\n            if fill > capacity {\n\
    \                max_fill += 1;\n                fill = 0;\n            }\n  \
    \      }\n        max_fill += 1;\n        fill = 0;\n    }\n    max_fill", " \
    \   let mut fill = 0;\n    let mut row_max = 0;\n    for row in grid {\n     \
    \   let mut row_fill = 0;\n        for &well in row.iter() {\n            if well\
    \ == 1 {\n                row_fill += 1;\n            }\n        }\n        if\
    \ row_fill > row_max {\n            row_max = row_fill;\n        }\n        fill\
    \ += row_fill;\n    }\n    fill - row_max * capacity", "    let mut grid = grid;\n\
    \    let mut count = 0;\n    for row in grid.iter_mut() {\n        let mut water\
    \ = 0;\n        for cell in row.iter_mut() {\n            if *cell == 1 {\n  \
    \              *cell = 0;\n                water += 1;\n            }\n      \
    \      if water > 0 {\n                *cell = 1;\n                water -= 1;\n\
    \            }\n        }\n        count += water / capacity;\n        if water\
    \ % capacity > 0 {\n            count += 1;\n        }\n    }\n    count", " \
    \   let mut grid = grid;\n    let mut count = 0;\n    let mut row = 0;\n    while\
    \ row < grid.len() {\n        let mut col = 0;\n        while col < grid[row].len()\
    \ {\n            if grid[row][col] == 1 {\n                count += 1;\n     \
    \           let mut row_ = row;\n                while row_ < grid.len() && grid[row_][col]\
    \ == 1 {\n                    grid[row_][col] = 0;\n                    row_ +=\
    \ 1;\n                }\n            }\n            col += 1;\n        }\n   \
    \     row += 1;\n    }\n    count", "    let mut grid = grid;\n    let mut count\
    \ = 0;\n    let mut max_fill = 0;\n    let mut max_fill_index = 0;\n    for i\
    \ in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if grid[i][j]\
    \ == 1 {\n                max_fill += 1;\n            }\n        }\n        if\
    \ max_fill > max_fill_index {\n            max_fill_index = max_fill;\n      \
    \  }\n        max_fill = 0;\n    }\n    for i in 0..grid.len() {\n        for\
    \ j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n                grid[i][j]\
    \ = 0;\n                count += 1;\n            }\n        }\n        if count\
    \ == max_fill_index {\n            break;\n        }\n        count = 0;\n   \
    \ }\n    count", "    let mut result = 0;\n    let mut water = 0;\n    for row\
    \ in grid {\n        for &well in &row {\n            water += well;\n       \
    \     if water == capacity {\n                result += 1;\n                water\
    \ = 0;\n            } else if water > capacity {\n                result += 1;\n\
    \                water = well;\n            }\n        }\n        if water > 0\
    \ {\n            result += 1;\n            water = 0;\n        }\n    }\n    result",
  "    let mut fill = 0;\n    let mut row = 0;\n    let mut col = 0;\n    let mut\
    \ max_row = 0;\n    let mut max_col = 0;\n    let mut max_fill = 0;\n    let mut\
    \ max_fill_row = 0;\n    let mut max_fill_col = 0;\n    let mut max_fill_count\
    \ = 0;\n    let mut max_fill_count_row = 0;\n    let mut max_fill_count_col =\
    \ 0;\n    let mut max_fill_count_fill = 0;\n    let mut max_fill_count_fill_row\
    \ = 0;\n    let mut max_fill_count_fill_col = 0;\n    let mut max_fill_count_fill_count\
    \ = 0;\n    let mut max_fill_count_fill_count_row = 0;\n    let mut max_fill_count_fill_count_col\
    \ = 0;\n    let mut max_fill_count_fill_count_fill = 0;\n    let mut max_fill_count_fill_count_fill_row\
    \ = 0;\n    let mut max_fill_count_fill_count_fill_col = 0;\n    let mut max_fill_count_fill_count_fill_count\
    \ = 0;\n    let mut max_fill_count_fill_count_fill_count_row = 0;\n    let mut\
    \ max_fill_count_fill_count_fill_count_col = 0;\n    let mut max_fill_count_fill_count_fill_count_fill\
    \ = 0;\n    let mut max_fill_count_fill_count_fill_count_fill_row = 0;\n    let\
    \ mut max_fill_count_fill_count_fill_count_fill_col = 0;\n    let mut max_fill_count_fill_count_fill_count_fill_count\
    \ = 0;\n    let mut max_fill_count_fill_count_fill_count_fill_count_row = 0;\n\
    \    let mut max_fill_count_fill_count_fill_count_fill_count_col = 0;\n    let\
    \ mut max_fill_count_fill_count_fill_count_fill_count_fill = 0;\n   ", "    let\
    \ mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n      \
    \  for &well in row.iter() {\n            fill += well;\n            if fill >\
    \ capacity {\n                fill = capacity;\n            }\n        }\n   \
    \     max_fill = max(max_fill, fill);\n    }\n    max_fill", "    let mut count\
    \ = 0;\n    let mut row_max = vec![0; grid.len()];\n    for i in 0..grid.len()\
    \ {\n        let mut max = 0;\n        for j in 0..grid[i].len() {\n         \
    \   if grid[i][j] == 1 {\n                max = max.max(j);\n            }\n \
    \       }\n        row_max[i] = max;\n    }\n    let mut col_max = vec![0; grid[0].len()];\n\
    \    for j in 0..grid[0].len() {\n        let mut max = 0;\n        for i in 0..grid.len()\
    \ {\n            if grid[i][j] == 1 {\n                max = max.max(i);\n   \
    \         }\n        }\n        col_max[j] = max;\n    }\n    let mut row_fill\
    \ = vec![0; grid.len()];\n    let mut col_fill = vec![0; grid[0].len()];\n   \
    \ let mut row_fill_max = vec![0; grid.len()];\n    let mut col_fill_max = vec![0;\
    \ grid[0].len()];\n    let mut row_fill_min = vec![0; grid.len()];\n    let mut\
    \ col_fill_min = vec![0; grid[0].len()];\n    let mut row_fill_max_index = vec![0;\
    \ grid.len()];\n    let mut col_fill_max_index = vec![0; grid[0].len()];\n   \
    \ let mut row_fill_min_index = vec![0; grid.len()];\n    let mut col_fill_min_index\
    \ = vec![0; grid[0].len()];\n    loop {\n        let mut row_max_index = 0;\n\
    \        let mut col_max_index = 0;\n        let mut row_max_value = 0;\n    \
    \    let mut col_max_value = 0;\n        for i in 0..grid.len() {\n          \
    \  if row_max[i] > row_max_value {\n                row_max_value = row_max[i];\n\
    \                row_max_", "    let mut count = 0;\n    let mut wells = grid.clone();\n\
    \    let mut bucket = capacity;\n    while bucket > 0 {\n        let mut row =\
    \ 0;\n        while row < wells.len() {\n            let mut col = 0;\n      \
    \      while col < wells[row].len() {\n                if wells[row][col] == 1\
    \ {\n                    wells[row][col] = 0;\n                    bucket -= 1;\n\
    \                }\n                col += 1;\n            }\n            row\
    \ += 1;\n        }\n        count += 1;\n        bucket = capacity;\n    }\n \
    \   count", "    let mut max_fill = 0;\n    for row in grid {\n        let mut\
    \ fill = 0;\n        for well in row {\n            fill += well;\n          \
    \  if fill > capacity {\n                max_fill += 1;\n                fill\
    \ = 0;\n            }\n        }\n        if fill > 0 {\n            max_fill\
    \ += 1;\n        }\n    }\n    max_fill", "    let mut grid = grid;\n    let mut\
    \ count = 0;\n    for row in grid.iter_mut() {\n        let mut sum = 0;\n   \
    \     for cell in row.iter_mut() {\n            sum += *cell;\n            *cell\
    \ = 0;\n        }\n        count += sum / capacity;\n    }\n    count", "    let\
    \ mut result = 0;\n    let mut max_depth = 0;\n    for row in grid {\n       \
    \ let mut depth = 0;\n        for &well in row.iter() {\n            depth +=\
    \ well;\n        }\n        max_depth = max(max_depth, depth);\n        result\
    \ += depth / capacity;\n        if depth % capacity != 0 {\n            result\
    \ += 1;\n        }\n    }\n    result * max_depth", "    let mut count = 0;\n\
    \    let mut wells = grid.clone();\n    let mut bucket = capacity;\n    for row\
    \ in wells.iter_mut() {\n        for well in row.iter_mut() {\n            if\
    \ *well == 1 {\n                if bucket == 0 {\n                    bucket =\
    \ capacity;\n                    count += 1;\n                }\n            \
    \    bucket -= 1;\n                *well = 0;\n            }\n        }\n    }\n\
    \    count", "    let mut count = 0;\n    let mut max_row = 0;\n    let mut max_col\
    \ = 0;\n    let mut max_val = 0;\n    for row in grid.iter() {\n        for (col,\
    \ &val) in row.iter().enumerate() {\n            if val > max_val {\n        \
    \        max_val = val;\n                max_row = row.len();\n              \
    \  max_col = col;\n            }\n        }\n    }\n    let mut grid = grid;\n\
    \    while max_val > 0 {\n        let mut row = 0;\n        let mut col = max_col;\n\
    \        while row < max_row {\n            if grid[row][col] > 0 {\n        \
    \        grid[row][col] -= 1;\n                count += 1;\n            }\n  \
    \          row += 1;\n        }\n        max_val -= 1;\n    }\n    count", " \
    \   let mut result = 0;\n    let mut row_max = vec![0; grid.len()];\n    for i\
    \ in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if grid[i][j]\
    \ == 1 {\n                row_max[i] = j as isize;\n            }\n        }\n\
    \    }\n    row_max.sort();\n    let mut last_max = 0;\n    for i in 0..row_max.len()\
    \ {\n        if row_max[i] > last_max {\n            result += (row_max[i] - last_max)\
    \ / capacity;\n            if (row_max[i] - last_max) % capacity != 0 {\n    \
    \            result += 1;\n            }\n            last_max = row_max[i];\n\
    \        }\n    }\n    result", "    let mut max_fill = 0;\n    for row in grid\
    \ {\n        let mut fill = 0;\n        for &well in row.iter() {\n          \
    \  fill += well;\n            if fill > capacity {\n                fill = capacity;\n\
    \            }\n        }\n        max_fill = max(max_fill, fill);\n    }\n  \
    \  max_fill", "    let mut max_fill = 0;\n    for row in grid {\n        let mut\
    \ fill = 0;\n        for &well in row.iter() {\n            fill += well;\n  \
    \          if fill > capacity {\n                max_fill += 1;\n            \
    \    fill = well;\n            }\n        }\n        max_fill += 1;\n    }\n \
    \   max_fill", "    let mut res = 0;\n    for row in grid {\n        let mut curr\
    \ = 0;\n        for &cell in &row {\n            if cell == 1 {\n            \
    \    curr += 1;\n            } else {\n                if curr > 0 {\n       \
    \             res += 1;\n                    curr = 0;\n                }\n  \
    \          }\n        }\n        if curr > 0 {\n            res += 1;\n      \
    \  }\n    }\n    res", "    let mut result = 0;\n    let mut max_height = 0;\n\
    \    for row in grid {\n        for &cell in &row {\n            max_height =\
    \ max_height.max(cell);\n        }\n    }\n    for height in 0..=max_height {\n\
    \        for row in &grid {\n            for &cell in row {\n                if\
    \ cell >= height {\n                    result += 1;\n                }\n    \
    \        }\n        }\n    }\n    result", "    let mut result = 0;\n    for row\
    \ in grid {\n        let mut sum = 0;\n        for &cell in &row {\n         \
    \   sum += cell;\n            if sum == capacity {\n                result +=\
    \ 1;\n                sum = 0;\n            }\n        }\n        if sum > 0 {\n\
    \            result += 1;\n        }\n    }\n    result", "    let mut count =\
    \ 0;\n    let mut wells = grid.clone();\n    let mut row_max = vec![0; wells.len()];\n\
    \    for (i, row) in wells.iter().enumerate() {\n        row_max[i] = *row.iter().max().unwrap();\n\
    \    }\n    let mut col_max = vec![0; wells[0].len()];\n    for j in 0..wells[0].len()\
    \ {\n        col_max[j] = wells.iter().map(|row| row[j]).max().unwrap();\n   \
    \ }\n    let mut row_max_idx = vec![0; wells.len()];\n    for (i, row) in wells.iter().enumerate()\
    \ {\n        row_max_idx[i] = row.iter().position(|&x| x == row_max[i]).unwrap();\n\
    \    }\n    let mut col_max_idx = vec![0; wells[0].len()];\n    for j in 0..wells[0].len()\
    \ {\n        col_max_idx[j] = wells.iter().position(|row| row[j] == col_max[j]).unwrap();\n\
    \    }\n    let mut row_max_idx_set = HashSet::new();\n    for i in 0..wells.len()\
    \ {\n        row_max_idx_set.insert(row_max_idx[i]);\n    }\n    let mut col_max_idx_set\
    \ = HashSet::new();\n    for j in 0..wells[0].len() {\n        col_max_idx_set.insert(col_max_idx[j]);\n\
    \    }\n    let mut row_max_idx_set_iter = row_max_idx_set.iter();\n    let mut\
    \ col_max_idx_set_iter = col_max_idx_set.iter();\n    let mut row_max_idx_set_iter_next\
    \ = row_max_idx_set_iter.next();\n    let mut col_max_idx_set_iter_next = col_max_idx_",
  "    let mut count = 0;\n    let mut water = 0;\n    for row in grid {\n       \
    \ for cell in row {\n            water += cell;\n            if water == capacity\
    \ {\n                count += 1;\n                water = 0;\n            } else\
    \ if water > capacity {\n                count += 1;\n                water =\
    \ cell;\n            }\n        }\n        if water > 0 {\n            count +=\
    \ 1;\n            water = 0;\n        }\n    }\n    count", "    let mut fill_count\
    \ = 0;\n    for row in grid {\n        let mut fill = 0;\n        for &well in\
    \ row.iter() {\n            fill += well;\n            if fill == capacity {\n\
    \                fill_count += 1;\n                fill = 0;\n            }\n\
    \        }\n        if fill > 0 {\n            fill_count += 1;\n        }\n \
    \   }\n    fill_count", "    let mut count = 0;\n    let mut max_fill = 0;\n \
    \   for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1;\n            }\n        }\n    }\n    let mut\
    \ fill = 0;\n    for row in grid {\n        for cell in row {\n            if\
    \ cell == 1 {\n                fill += 1;\n            }\n        }\n        if\
    \ fill == max_fill {\n            break;\n        }\n        count += 1;\n   \
    \     fill = 0;\n    }\n    count", "    let mut grid = grid;\n    let mut count\
    \ = 0;\n    let mut max_height = 0;\n    for row in &grid {\n        max_height\
    \ = max_height.max(row.iter().sum());\n    }\n    for _ in 0..max_height {\n \
    \       let mut row_count = 0;\n        for row in &mut grid {\n            let\
    \ mut row_max = 0;\n            for cell in row {\n                if *cell >\
    \ 0 {\n                    row_max += 1;\n                    *cell -= 1;\n  \
    \              }\n            }\n            row_count += row_max;\n        }\n\
    \        count += row_count / capacity;\n        if row_count % capacity > 0 {\n\
    \            count += 1;\n        }\n    }\n    count", "    let mut count = 0;\n\
    \    for row in grid {\n        let mut water = 0;\n        for &well in row.iter()\
    \ {\n            water += well;\n            if water == capacity {\n        \
    \        count += 1;\n                water = 0;\n            } else if water\
    \ > capacity {\n                count += 1;\n                water = well;\n \
    \           }\n        }\n        if water > 0 {\n            count += 1;\n  \
    \      }\n    }\n    count", "    let mut count = 0;\n    let mut grid = grid;\n\
    \    let mut row = 0;\n    let mut col = 0;\n    while row < grid.len() {\n  \
    \      while col < grid[row].len() {\n            if grid[row][col] == 1 {\n \
    \               count += 1;\n                let mut row_ = row;\n           \
    \     while row_ < grid.len() && grid[row_][col] == 1 {\n                    grid[row_][col]\
    \ = 0;\n                    row_ += 1;\n                }\n            }\n   \
    \         col += 1;\n        }\n        row += 1;\n        col = 0;\n    }\n \
    \   count", "    let mut count = 0;\n    for row in grid {\n        let mut sum\
    \ = 0;\n        for &well in row.iter() {\n            sum += well;\n        \
    \    if sum == capacity {\n                count += 1;\n                sum =\
    \ 0;\n            }\n        }\n        if sum > 0 {\n            count += 1;\n\
    \        }\n    }\n    count", "    let mut max_fill = 0;\n    for row in grid\
    \ {\n        let mut fill = 0;\n        for &cell in row.iter() {\n          \
    \  fill += cell;\n            if fill > capacity {\n                max_fill +=\
    \ 1;\n                fill = capacity;\n            }\n        }\n        max_fill\
    \ += fill;\n    }\n    max_fill", "    let mut count = 0;\n    let mut grid =\
    \ grid;\n    let mut row = 0;\n    let mut col = 0;\n    let mut row_len = grid.len();\n\
    \    let mut col_len = grid[0].len();\n    while row < row_len {\n        if grid[row][col]\
    \ == 1 {\n            count += 1;\n            let mut i = 0;\n            while\
    \ i < row_len {\n                grid[i][col] = 0;\n                i += 1;\n\
    \            }\n            col += 1;\n            col_len -= 1;\n        } else\
    \ {\n            row += 1;\n        }\n    }\n    count", "    let mut count =\
    \ 0;\n    let mut wells = grid.iter().map(|row| row.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    while wells.iter().any(|&w| w > 0) {\n        let mut bucket = capacity;\n\
    \        for well in wells.iter_mut() {\n            if bucket > 0 {\n       \
    \         let fill = std::cmp::min(bucket, *well);\n                bucket -=\
    \ fill;\n                *well -= fill;\n            }\n        }\n        count\
    \ += 1;\n    }\n    count", "    let mut max_fill = 0;\n    let mut fill = 0;\n\
    \    for row in grid {\n        for &well in row.iter() {\n            fill +=\
    \ well;\n            if fill > capacity {\n                max_fill += 1;\n  \
    \              fill = well;\n            }\n        }\n        max_fill += 1;\n\
    \        fill = 0;\n    }\n    max_fill", "    let mut count = 0;\n    for row\
    \ in grid {\n        let mut sum = 0;\n        for &cell in row.iter() {\n   \
    \         sum += cell;\n            if sum == capacity {\n                count\
    \ += 1;\n                sum = 0;\n            }\n        }\n        if sum >\
    \ 0 {\n            count += 1;\n        }\n    }\n    count", "    let mut count\
    \ = 0;\n    let mut grid = grid;\n    let mut row = 0;\n    let mut col = 0;\n\
    \    let mut row_max = 0;\n    let mut col_max = 0;\n    let mut row_min = 0;\n\
    \    let mut col_min = 0;\n    let mut row_sum = 0;\n    let mut col_sum = 0;\n\
    \    let mut row_max_idx = 0;\n    let mut col_max_idx = 0;\n    let mut row_min_idx\
    \ = 0;\n    let mut col_min_idx = 0;\n    let mut row_max_idx_prev = 0;\n    let\
    \ mut col_max_idx_prev = 0;\n    let mut row_min_idx_prev = 0;\n    let mut col_min_idx_prev\
    \ = 0;\n    let mut row_max_prev = 0;\n    let mut col_max_prev = 0;\n    let\
    \ mut row_min_prev = 0;\n    let mut col_min_prev = 0;\n    let mut row_sum_prev\
    \ = 0;\n    let mut col_sum_prev = 0;\n    let mut row_max_idx_prev_prev = 0;\n\
    \    let mut col_max_idx_prev_prev = 0;\n    let mut row_min_idx_prev_prev = 0;\n\
    \    let mut col_min_idx_prev_prev = 0;\n    let mut row_max_prev_prev = 0;\n\
    \    let mut col_max_prev_prev = 0;\n    let mut row_min_prev_prev = 0;\n    let\
    \ mut col_min_prev_prev = 0;\n    let mut row_sum_prev_prev = 0;\n    let mut\
    \ col_sum_prev_prev = 0;\n    let mut row_max_idx_prev_prev_prev = 0;\n    let\
    \ mut col_max_idx_prev_prev_prev = 0;\n    let mut row_min_idx_prev_prev_prev\
    \ = 0;\n    let mut col_min_idx_prev_prev_prev = 0;\n    let mut row_max_", " \
    \   let mut grid = grid;\n    let mut count = 0;\n    for row in grid.iter_mut()\
    \ {\n        let mut filled = 0;\n        for cell in row.iter_mut() {\n     \
    \       if *cell == 1 {\n                *cell = 0;\n                filled +=\
    \ 1;\n            }\n            if filled == capacity {\n                break;\n\
    \            }\n        }\n        if filled > 0 {\n            count += 1;\n\
    \        }\n    }\n    count", "    let mut grid = grid;\n    let mut count =\
    \ 0;\n    while !grid.iter().all(|row| row.iter().all(|&x| x == 0)) {\n      \
    \  for row in &mut grid {\n            for cell in row {\n                if *cell\
    \ > 0 {\n                    *cell -= capacity;\n                    if *cell\
    \ < 0 {\n                        *cell = 0;\n                    }\n         \
    \       }\n            }\n        }\n        count += 1;\n    }\n    count", " \
    \   let mut result = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut max_i\
    \ = 0;\n    let mut max_j = 0;\n    let mut max_value = 0;\n    let mut max_value_i\
    \ = 0;\n    let mut max_value_j = 0;\n    let mut max_value_count = 0;\n    let\
    \ mut max_value_count_i = 0;\n    let mut max_value_count_j = 0;\n    let mut\
    \ max_value_count_value = 0;\n    let mut max_value_count_value_i = 0;\n    let\
    \ mut max_value_count_value_j = 0;\n    let mut max_value_count_value_count =\
    \ 0;\n    let mut max_value_count_value_count_i = 0;\n    let mut max_value_count_value_count_j\
    \ = 0;\n    let mut max_value_count_value_count_value = 0;\n    let mut max_value_count_value_count_value_i\
    \ = 0;\n    let mut max_value_count_value_count_value_j = 0;\n    let mut max_value_count_value_count_value_count\
    \ = 0;\n    let mut max_value_count_value_count_value_count_i = 0;\n    let mut\
    \ max_value_count_value_count_value_count_j = 0;\n    let mut max_value_count_value_count_value_count_value\
    \ = 0;\n    let mut max_value_count_value_count_value_count_value_i = 0;\n   \
    \ let mut max_value_count_value_count_value_count_value_j = 0;\n    let mut max_value_count_value_count_value_count_value_count\
    \ = 0;\n    let mut max_value_count_value_count_value_count_value_count_i = 0;\n\
    \    let mut max_value_count_value_count_value_count_value_count_j = 0;\n    let\
    \ mut max_value_count_value_count_value_count_value_count_value = 0;\n   ", " \
    \   let mut fill_count = 0;\n    let mut row_max = vec![0; grid.len()];\n    for\
    \ row in grid {\n        let mut row_fill = 0;\n        for (i, &x) in row.iter().enumerate()\
    \ {\n            if x == 1 {\n                row_fill += 1;\n            } else\
    \ {\n                row_max[i] = row_max[i].max(row_fill);\n                row_fill\
    \ = 0;\n            }\n        }\n        row_max[row.len() - 1] = row_max[row.len()\
    \ - 1].max(row_fill);\n    }\n    for &x in row_max.iter() {\n        fill_count\
    \ += (x + capacity - 1) / capacity;\n    }\n    fill_count", "    let mut fill\
    \ = 0;\n    let mut wells = grid.clone();\n    let mut bucket = capacity;\n  \
    \  let mut i = 0;\n    while i < wells.len() {\n        let mut j = 0;\n     \
    \   while j < wells[i].len() {\n            if wells[i][j] == 1 {\n          \
    \      if bucket == 0 {\n                    bucket = capacity;\n            \
    \        fill += 1;\n                }\n                bucket -= 1;\n       \
    \         wells[i][j] = 0;\n            }\n            j += 1;\n        }\n  \
    \      i += 1;\n    }\n    fill", "    let mut result = 0;\n    let mut row =\
    \ 0;\n    let mut col = 0;\n    let mut max_row = 0;\n    let mut max_col = 0;\n\
    \    let mut max_fill = 0;\n    let mut max_fill_row = 0;\n    let mut max_fill_col\
    \ = 0;\n    let mut max_fill_count = 0;\n    let mut max_fill_count_row = 0;\n\
    \    let mut max_fill_count_col = 0;\n    let mut max_fill_count_row_count = 0;\n\
    \    let mut max_fill_count_col_count = 0;\n    let mut max_fill_count_row_count_row\
    \ = 0;\n    let mut max_fill_count_col_count_col = 0;\n    let mut max_fill_count_row_count_row_count\
    \ = 0;\n    let mut max_fill_count_col_count_col_count = 0;\n    let mut max_fill_count_row_count_row_count_row\
    \ = 0;\n    let mut max_fill_count_col_count_col_count_col = 0;\n    let mut max_fill_count_row_count_row_count_row_count\
    \ = 0;\n    let mut max_fill_count_col_count_col_count_col_count = 0;\n    let\
    \ mut max_fill_count_row_count_row_count_row_count_row = 0;\n    let mut max_fill_count_col_count_col_count_col_count_col\
    \ = 0;\n    let mut max_fill_count_row_count_row_count_row_count_row_count = 0;\n\
    \    let mut max_fill_count_col_count_col_count_col_count_col_count = 0;\n   \
    \ let mut max_fill_count_row_count_row_count_row_count_row_count_row = 0;\n  \
    \  let mut max_fill_count_col_count_col_count_col_count_col_count_col = 0;\n \
    \   let mut max_fill_count_row_count_row_count_row_count_row_count_", "    let\
    \ mut result = 0;\n    let mut water = 0;\n    for row in grid {\n        for\
    \ &well in &row {\n            water += well;\n            if water == capacity\
    \ {\n                result += 1;\n                water = 0;\n            } else\
    \ if water > capacity {\n                result += 1;\n                water =\
    \ well;\n            }\n        }\n        if water > 0 {\n            result\
    \ += 1;\n            water = 0;\n        }\n    }\n    result", "    let mut count\
    \ = 0;\n    for row in grid {\n        let mut sum = 0;\n        for &well in\
    \ row.iter() {\n            sum += well;\n            if sum == capacity {\n \
    \               count += 1;\n                sum = 0;\n            }\n       \
    \ }\n        if sum > 0 {\n            count += 1;\n        }\n    }\n    count",
  "    let mut count = 0;\n    for row in grid {\n        let mut sum = 0;\n     \
    \   for &cell in row.iter() {\n            sum += cell;\n            if sum ==\
    \ capacity {\n                count += 1;\n                sum = 0;\n        \
    \    }\n        }\n        if sum > 0 {\n            count += 1;\n        }\n\
    \    }\n    count", "    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid.iter_mut() {\n        max_height =\
    \ max_height.max(row.iter().sum());\n    }\n    for height in 0..max_height {\n\
    \        for row in grid.iter_mut() {\n            let mut filled = 0;\n     \
    \       for cell in row.iter_mut() {\n                if *cell > 0 {\n       \
    \             *cell -= 1;\n                    filled += 1;\n                }\n\
    \            }\n            if filled > 0 {\n                count += 1;\n   \
    \         }\n        }\n    }\n    count", "    let mut count = 0;\n    let mut\
    \ row_max = vec![0; grid.len()];\n    let mut col_max = vec![0; grid[0].len()];\n\
    \    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n         \
    \   row_max[i] = row_max[i].max(grid[i][j]);\n            col_max[j] = col_max[j].max(grid[i][j]);\n\
    \        }\n    }\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            let max_fill = row_max[i].min(col_max[j]);\n            count\
    \ += max_fill - grid[i][j];\n        }\n    }\n    count", "    let mut max_fill\
    \ = 0;\n    let mut fill = 0;\n    for row in grid {\n        for well in row\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = well;\n            }\n        }\n\
    \        max_fill += 1;\n        fill = 0;\n    }\n    max_fill", "    let mut\
    \ grid = grid;\n    let mut count = 0;\n    let mut max_height = 0;\n    for row\
    \ in grid.iter_mut() {\n        let mut height = 0;\n        for cell in row.iter_mut()\
    \ {\n            if *cell == 1 {\n                height += 1;\n            }\
    \ else {\n                height = 0;\n            }\n            *cell = height;\n\
    \        }\n        max_height = max(max_height, height);\n    }\n    for height\
    \ in 1..=max_height {\n        for row in grid.iter_mut() {\n            for cell\
    \ in row.iter_mut() {\n                if *cell >= height {\n                \
    \    *cell -= height;\n                    count += 1;\n                }\n  \
    \          }\n        }\n    }\n    count", "    let mut count = 0;\n    let mut\
    \ max_height = 0;\n    for row in grid {\n        let mut height = 0;\n      \
    \  for &cell in row.iter() {\n            if cell == 1 {\n                height\
    \ += 1;\n            }\n        }\n        if height > max_height {\n        \
    \    max_height = height;\n        }\n    }\n    for _ in 0..max_height {\n  \
    \      for row in grid {\n            for &cell in row.iter() {\n            \
    \    if cell == 1 {\n                    count += 1;\n                }\n    \
    \        }\n        }\n    }\n    count", "    let mut max_fill = 0;\n    for\
    \ row in grid {\n        let mut fill = 0;\n        for &cell in row.iter() {\n\
    \            fill += cell;\n            if fill > capacity {\n               \
    \ max_fill += 1;\n                fill = cell;\n            }\n        }\n   \
    \     max_fill += 1;\n    }\n    max_fill", "    let mut max_fill = 0;\n    for\
    \ row in grid {\n        let mut fill = 0;\n        for &well in row.iter() {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ fill = capacity;\n            }\n        }\n        max_fill = max(max_fill,\
    \ fill);\n    }\n    max_fill", "    let mut max_fill = 0;\n    for row in grid\
    \ {\n        let mut fill = 0;\n        for &cell in row.iter() {\n          \
    \  fill += cell;\n            if fill > capacity {\n                fill = capacity;\n\
    \            }\n        }\n        max_fill = max(max_fill, fill);\n    }\n  \
    \  max_fill", "    let mut max_fill = 0;\n    for row in grid {\n        let mut\
    \ fill = 0;\n        for &cell in row.iter() {\n            fill += cell;\n  \
    \          if fill > capacity {\n                max_fill += 1;\n            \
    \    fill = cell;\n            }\n        }\n        max_fill += 1;\n    }\n \
    \   max_fill", "    let mut result = 0;\n    let mut row_max = vec![0; grid.len()];\n\
    \    for row in grid {\n        for (i, &v) in row.iter().enumerate() {\n    \
    \        row_max[i] = std::cmp::max(row_max[i], v);\n        }\n    }\n    for\
    \ row in grid {\n        for (i, &v) in row.iter().enumerate() {\n           \
    \ let diff = row_max[i] - v;\n            if diff > 0 {\n                result\
    \ += diff;\n            }\n        }\n    }\n    result", "    let mut count =\
    \ 0;\n    let mut wells = grid.iter().map(|row| row.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    while wells.iter().any(|&x| x > 0) {\n        for well in wells.iter_mut()\
    \ {\n            if *well > 0 {\n                *well -= capacity;\n        \
    \    }\n        }\n        count += 1;\n    }\n    count", "    let mut fill =\
    \ 0;\n    let mut max_fill = 0;\n    for row in grid {\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = 0;\n            }\n        }\n  \
    \      max_fill += 1;\n        fill = 0;\n    }\n    max_fill", "    let mut count\
    \ = 0;\n    for row in grid {\n        let mut sum = 0;\n        for &cell in\
    \ row.iter() {\n            sum += cell;\n            if sum == capacity {\n \
    \               count += 1;\n                sum = 0;\n            }\n       \
    \ }\n        if sum > 0 {\n            count += 1;\n        }\n    }\n    count",
  "    let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n \
    \       for &well in row.iter() {\n            if well == 1 {\n              \
    \  fill += 1;\n            } else {\n                if fill > max_fill {\n  \
    \                  max_fill = fill;\n                }\n                fill =\
    \ 0;\n            }\n        }\n        if fill > max_fill {\n            max_fill\
    \ = fill;\n        }\n    }\n    if max_fill == 0 {\n        return 0;\n    }\n\
    \    if max_fill <= capacity {\n        return 1;\n    }\n    max_fill / capacity\
    \ + if max_fill % capacity == 0 { 0 } else { 1 }", "    let mut count = 0;\n \
    \   let mut grid = grid;\n    let mut row = 0;\n    let mut col = 0;\n    while\
    \ row < grid.len() {\n        while col < grid[row].len() {\n            if grid[row][col]\
    \ == 1 {\n                count += 1;\n                grid[row][col] = 0;\n \
    \               let mut bucket = capacity;\n                while bucket > 0 &&\
    \ col < grid[row].len() {\n                    if grid[row][col] == 1 {\n    \
    \                    grid[row][col] = 0;\n                        bucket -= 1;\n\
    \                    }\n                    col += 1;\n                }\n   \
    \         }\n            col += 1;\n        }\n        row += 1;\n        col\
    \ = 0;\n    }\n    count", "    let mut count = 0;\n    let mut max_row = 0;\n\
    \    let mut max_col = 0;\n    for row in grid.iter() {\n        let mut row_sum\
    \ = 0;\n        for col in row.iter() {\n            row_sum += col;\n       \
    \ }\n        if row_sum > max_row {\n            max_row = row_sum;\n        }\n\
    \    }\n    for col in 0..grid[0].len() {\n        let mut col_sum = 0;\n    \
    \    for row in grid.iter() {\n            col_sum += row[col];\n        }\n \
    \       if col_sum > max_col {\n            max_col = col_sum;\n        }\n  \
    \  }\n    count += max_row / capacity;\n    count += max_col / capacity;\n   \
    \ if max_row % capacity != 0 {\n        count += 1;\n    }\n    if max_col % capacity\
    \ != 0 {\n        count += 1;\n    }\n    count", "    let mut fill = 0;\n   \
    \ let mut row_max = 0;\n    for row in grid {\n        for &cell in row.iter()\
    \ {\n            row_max = std::cmp::max(row_max, cell);\n        }\n        fill\
    \ += row_max;\n        row_max = 0;\n    }\n    fill / capacity", "    let mut\
    \ count = 0;\n    let mut max_height = 0;\n    for row in grid {\n        let\
    \ mut height = 0;\n        for &cell in row.iter() {\n            if cell == 1\
    \ {\n                height += 1;\n            }\n        }\n        if height\
    \ > max_height {\n            max_height = height;\n        }\n    }\n    for\
    \ h in 0..max_height {\n        for row in grid.iter() {\n            for &cell\
    \ in row.iter() {\n                if cell == 1 {\n                    count +=\
    \ 1;\n                }\n            }\n        }\n    }\n    count"]
stop_tokens:
- "\n}"
