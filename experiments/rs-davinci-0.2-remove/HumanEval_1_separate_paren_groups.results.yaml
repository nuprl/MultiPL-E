language: rs
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n\n        if open_parens\
    \ == 0 {\n            if current_group.len() > 0 {\n                paren_groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    paren_groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpjh9lde_s.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                paren_count += 1;\n\
    \                current_group.push(c);\n            }\n            ')' => {\n\
    \                paren_count -= 1;\n                current_group.push(c);\n \
    \               if paren_count == 0 {\n                    paren_groups.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if paren_count > 0 {\n        \
    \            current_group.push(c);\n                }\n            }\n      \
    \  }\n    }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpi6thxu54.rs:40:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if !current_group.is_empty()\
    \ {\n        result.push(current_group);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpit58rbqx.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_stack = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                paren_stack.push(c);\n\
    \                current_group.push(c);\n            }\n            ')' => {\n\
    \                if paren_stack.is_empty() {\n                    panic!(\"Unbalanced\
    \ parentheses\");\n                }\n                paren_stack.pop();\n   \
    \             current_group.push(c);\n                if paren_stack.is_empty()\
    \ {\n                    result.push(current_group);\n                    current_group\
    \ = String::new();\n                }\n            }\n            _ => {\n   \
    \             current_group.push(c);\n            }\n        }\n    }\n    if\
    \ !paren_stack.is_empty() {\n        panic!(\"Unbalanced parentheses\");\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpz6xi5x4_.rs:39:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if c == ')' {\n                result.push(current_group);\n         \
    \       current_group = String::new();\n            }\n        } else {\n    \
    \        current_group.push(c);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp4t2jtjo8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if c == ')' {\n                result.push(current_group);\n         \
    \       current_group = String::new();\n            }\n        } else {\n    \
    \        current_group.push(c);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp4t2jtjo8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n        if c == ' ' {\n\
    \            continue;\n        }\n        group.push(c);\n        if open_parens\
    \ == 0 {\n            groups.push(group);\n            group = String::new();\n\
    \        }\n    }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            groups.push(current_group);\n            current_group =\
    \ String::new();\n        } else {\n            current_group.push(c);\n     \
    \   }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpvg749a4q.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            paren_groups.push(current_group);\n            current_group\
    \ = String::new();\n        } else {\n            current_group.push(c);\n   \
    \     }\n    }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpysxmo4bt.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp1iis8n35.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n\n        if open_parens\
    \ == 0 {\n            if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    result\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp5t0852u2.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                open_parens += 1;\n\
    \                current_group.push(c);\n            }\n            ')' => {\n\
    \                open_parens -= 1;\n                current_group.push(c);\n \
    \               if open_parens == 0 {\n                    paren_groups.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if open_parens > 0 {\n        \
    \            current_group.push(c);\n                }\n            }\n      \
    \  }\n    }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp22kwmdmq.rs:40:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            if current_group.len() > 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp27zl2bpm.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n\n        if open_parens\
    \ == 0 {\n            result.push(current_group);\n            current_group =\
    \ String::new();\n        } else {\n            current_group.push(c);\n     \
    \   }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp5538k582.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n        } else if c == ')' {\n  \
    \          open_parens -= 1;\n        }\n        if open_parens == 0 {\n     \
    \       if current_group.len() > 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if current_group.len()\
    \ > 0 {\n        result.push(current_group);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmps00cz06e.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n\n        if open_parens\
    \ == 0 {\n            if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    result\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp5t0852u2.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut paren_string = paren_string.chars().collect::<Vec<char>>();\n\
    \    let mut start = 0;\n    let mut end = 0;\n    let mut count = 0;\n    while\
    \ end < paren_string.len() {\n        if paren_string[end] == '(' {\n        \
    \    count += 1;\n        } else if paren_string[end] == ')' {\n            count\
    \ -= 1;\n        }\n        if count == 0 {\n            result.push(paren_string[start..end\
    \ + 1].iter().collect());\n            start = end + 1;\n        }\n        end\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmptz1i5tek.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_stack: Vec<char> = Vec::new();\n\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            paren_stack.push(c);\n\
    \        } else if c == ')' {\n            paren_stack.pop();\n        }\n\n \
    \       current_group.push(c);\n\n        if paren_stack.is_empty() {\n      \
    \      paren_groups.push(current_group.clone());\n            current_group.clear();\n\
    \        }\n    }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpkssfgne4.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp1iis8n35.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut current_depth = 0;\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                current_depth += 1;\n     \
    \           current_group.push(c);\n            }\n            ')' => {\n    \
    \            current_depth -= 1;\n                current_group.push(c);\n   \
    \             if current_depth == 0 {\n                    result.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if current_depth > 0 {\n      \
    \              current_group.push(c);\n                }\n            }\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpjjifgtdq.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n        } else if c == ')' {\n  \
    \          open_parens -= 1;\n        }\n        if open_parens == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpc6wzqfar.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if c == ')' {\n                result.push(current_group);\n         \
    \       current_group = String::new();\n            }\n        } else {\n    \
    \        current_group.push(c);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp4t2jtjo8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n\n        if open_parens\
    \ == 0 {\n            if current_group.len() > 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    result\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpfg3j42i9.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp1iis8n35.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n\n        if open_parens\
    \ == 0 {\n            if current_group.len() > 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    result\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpfg3j42i9.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            if current_group.len() > 0 {\n                paren_groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    if current_group.len()\
    \ > 0 {\n        paren_groups.push(current_group);\n    }\n\n    paren_groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpzgkv762q.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if !current_group.is_empty()\
    \ {\n        result.push(current_group);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpit58rbqx.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut group: String\
    \ = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            groups.push(group.clone());\n            group = String::new();\n\
    \        } else {\n            group.push(c);\n        }\n    }\n    groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp22mmhtjw.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_paren_count: i32 = 0;\n    for c in\
    \ paren_string.chars() {\n        if c == '(' {\n            open_paren_count\
    \ += 1;\n        } else if c == ')' {\n            open_paren_count -= 1;\n  \
    \      }\n        current_group.push(c);\n        if open_paren_count == 0 {\n\
    \            paren_groups.push(current_group);\n            current_group = String::new();\n\
    \        }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp6dcfc8ks.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpmnd5_jhf.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n        } else if c == ')' {\n  \
    \          open_parens -= 1;\n        }\n        if open_parens == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpc6wzqfar.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n\n        if paren_count == 0 {\n   \
    \         if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    result\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmppc5hp3tx.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n        if open_parens ==\
    \ 0 {\n            if !group.is_empty() {\n                groups.push(group);\n\
    \                group = String::new();\n            }\n        } else {\n   \
    \         group.push(c);\n        }\n    }\n    groups\n}\n\nfn main() {\n   \
    \ let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp28wtafda.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_string:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            if c == ')' {\n                result.push(current_string);\n\
    \                current_string = String::new();\n            }\n        } else\
    \ {\n            current_string.push(c);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp0md6y_yd.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if open_parens > 0 {\n            current_group.push(c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp351vr1jq.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut current_depth = 0;\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                current_depth += 1;\n     \
    \           current_group.push(c);\n            }\n            ')' => {\n    \
    \            current_depth -= 1;\n                current_group.push(c);\n   \
    \             if current_depth == 0 {\n                    result.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if current_depth > 0 {\n      \
    \              current_group.push(c);\n                }\n            }\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpjjifgtdq.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut group = String::new();\n  \
    \  let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            open_parens += 1;\n        } else if c == ')' {\n    \
    \        open_parens -= 1;\n        }\n        if c == ' ' {\n            continue;\n\
    \        }\n        group.push(c);\n        if open_parens == 0 {\n          \
    \  result.push(group);\n            group = String::new();\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            if current_group.len() > 0 {\n                groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    if current_group.len()\
    \ > 0 {\n        groups.push(current_group);\n    }\n\n    groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpgvebhe7c.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if c == ')' {\n                result.push(current_group);\n         \
    \       current_group = String::new();\n            }\n        } else {\n    \
    \        current_group.push(c);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp4t2jtjo8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"separate the nested paren groups in the string {:?}\"\
    , paren_string)\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: separate the nested paren
    groups in the string "(()()) ((())) () ((())()())"'', /tmp/tmp2kbo7y2z.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpkf7o4k6p.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n\n        if open_parens\
    \ == 0 {\n            if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    result\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp5t0852u2.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut depth = 0;\n    for c in paren_string.chars() {\n        match c\
    \ {\n            '(' => {\n                depth += 1;\n                current_group.push(c);\n\
    \            }\n            ')' => {\n                depth -= 1;\n          \
    \      current_group.push(c);\n                if depth == 0 {\n             \
    \       result.push(current_group);\n                    current_group = String::new();\n\
    \                }\n            }\n            _ => {\n                if depth\
    \ > 0 {\n                    current_group.push(c);\n                }\n     \
    \       }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpd058ppwz.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n\n        if open_parens\
    \ == 0 {\n            if current_group.len() > 0 {\n                paren_groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    paren_groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpjh9lde_s.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                open_parens += 1;\n\
    \                current_group.push(c);\n            }\n            ')' => {\n\
    \                open_parens -= 1;\n                current_group.push(c);\n \
    \               if open_parens == 0 {\n                    result.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if open_parens > 0 {\n        \
    \            current_group.push(c);\n                }\n            }\n      \
    \  }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpxdphfjt5.rs:40:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut stack = Vec::new();\n    let mut result = Vec::new();\n    let\
    \ mut current_string = String::new();\n\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            stack.push(c);\n        } else if c == ')'\
    \ {\n            stack.pop();\n        }\n\n        if stack.is_empty() {\n  \
    \          if c != ' ' {\n                current_string.push(c);\n          \
    \  } else {\n                result.push(current_string);\n                current_string\
    \ = String::new();\n            }\n        } else {\n            current_string.push(c);\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \"((()))\", \"()\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmpdvv_d4uv.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut depth: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              current_group.push(c);\n            }\n            ')' => {\n \
    \               depth -= 1;\n                current_group.push(c);\n        \
    \        if depth == 0 {\n                    groups.push(current_group);\n  \
    \                  current_group = String::new();\n                }\n       \
    \     }\n            _ => {\n                if depth > 0 {\n                \
    \    current_group.push(c);\n                }\n            }\n        }\n   \
    \ }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpdd_q6xrc.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut group = String::new();\n  \
    \  let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n    \
    \        paren_count -= 1;\n        }\n        if paren_count == 0 {\n       \
    \     if !group.is_empty() {\n                result.push(group);\n          \
    \      group = String::new();\n            }\n        } else {\n            group.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp2klkyfc7.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                open_parens += 1;\n\
    \                current_group.push(c);\n            }\n            ')' => {\n\
    \                open_parens -= 1;\n                current_group.push(c);\n \
    \               if open_parens == 0 {\n                    paren_groups.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if open_parens > 0 {\n        \
    \            current_group.push(c);\n                }\n            }\n      \
    \  }\n    }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp22kwmdmq.rs:40:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_paren_count: u32 = 0;\n\n    for c\
    \ in paren_string.chars() {\n        if c == '(' {\n            open_paren_count\
    \ += 1;\n        } else if c == ')' {\n            open_paren_count -= 1;\n  \
    \      }\n\n        if open_paren_count == 0 {\n            result.push(current_group);\n\
    \            current_group = String::new();\n        } else {\n            current_group.push(c);\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp6mmajpok.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp1iis8n35.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp1iis8n35.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpkf7o4k6p.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            if c == ' ' {\n                continue;\n            }\n \
    \           if c == ')' {\n                result.push(current_group);\n     \
    \           current_group = String::new();\n            }\n        } else {\n\
    \            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp1les6ed0.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp1iis8n35.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp1iis8n35.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                open_parens += 1;\n\
    \                current_group.push(c);\n            }\n            ')' => {\n\
    \                open_parens -= 1;\n                current_group.push(c);\n \
    \               if open_parens == 0 {\n                    result.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if open_parens > 0 {\n        \
    \            current_group.push(c);\n                }\n            }\n      \
    \  }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpxdphfjt5.rs:40:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                open_parens += 1;\n\
    \                current_group.push(c);\n            }\n            ')' => {\n\
    \                open_parens -= 1;\n                current_group.push(c);\n \
    \               if open_parens == 0 {\n                    groups.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            ' ' => {}\n            _ => {\n                current_group.push(c);\n\
    \            }\n        }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n        if open_parens ==\
    \ 0 {\n            groups.push(group.clone());\n            group = String::new();\n\
    \        } else {\n            group.push(c);\n        }\n    }\n    groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpxyt48s6r.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut paren_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                paren_count += 1;\n\
    \                paren_group.push(c);\n            }\n            ')' => {\n \
    \               paren_count -= 1;\n                paren_group.push(c);\n    \
    \        }\n            _ => {\n                if paren_count == 0 {\n      \
    \              if paren_group.len() > 0 {\n                        paren_groups.push(paren_group);\n\
    \                        paren_group = String::new();\n                    }\n\
    \                } else {\n                    paren_group.push(c);\n        \
    \        }\n            }\n        }\n    }\n\n    if paren_group.len() > 0 {\n\
    \        paren_groups.push(paren_group);\n    }\n\n    paren_groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpc2pbjqw0.rs:45:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            if current_group.len() > 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if current_group.len()\
    \ > 0 {\n        result.push(current_group);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpktrypwiq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            if current_group.len() > 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp27zl2bpm.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut current_depth: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_depth +=\
    \ 1;\n                current_group.push(c);\n            }\n            ')' =>\
    \ {\n                current_depth -= 1;\n                current_group.push(c);\n\
    \                if current_depth == 0 {\n                    paren_groups.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if current_depth > 0 {\n      \
    \              current_group.push(c);\n                }\n            }\n    \
    \    }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpnf19mp8p.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut current_group_depth: i32 = 0;\n    for\
    \ c in paren_string.chars() {\n        match c {\n            '(' => {\n     \
    \           current_group_depth += 1;\n                current_group.push(c);\n\
    \            }\n            ')' => {\n                current_group_depth -= 1;\n\
    \                current_group.push(c);\n                if current_group_depth\
    \ == 0 {\n                    paren_groups.push(current_group);\n            \
    \        current_group = String::new();\n                }\n            }\n  \
    \          _ => {\n                if current_group_depth > 0 {\n            \
    \        current_group.push(c);\n                }\n            }\n        }\n\
    \    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpg2t3cxhb.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            if current_group.len() > 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp27zl2bpm.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if !current_group.is_empty()\
    \ {\n        result.push(current_group);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpit58rbqx.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if c == ')' {\n                result.push(current_group);\n         \
    \       current_group = String::new();\n            }\n        } else {\n    \
    \        current_group.push(c);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp4t2jtjo8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp1iis8n35.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_stack: Vec<char> = Vec::new();\n\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            paren_stack.push(c);\n\
    \        } else if c == ')' {\n            paren_stack.pop();\n        }\n\n \
    \       if paren_stack.is_empty() {\n            if !current_group.is_empty()\
    \ {\n                paren_groups.push(current_group);\n                current_group\
    \ = String::new();\n            }\n        } else {\n            current_group.push(c);\n\
    \        }\n    }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp44vxhmhq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                open_parens += 1;\n\
    \                current_group.push(c);\n            }\n            ')' => {\n\
    \                open_parens -= 1;\n                current_group.push(c);\n \
    \               if open_parens == 0 {\n                    paren_groups.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if open_parens > 0 {\n        \
    \            current_group.push(c);\n                }\n            }\n      \
    \  }\n    }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp22kwmdmq.rs:40:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n\n        if open_parens\
    \ == 0 {\n            groups.push(current_group);\n            current_group =\
    \ String::new();\n        } else {\n            current_group.push(c);\n     \
    \   }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpgc5o6tdk.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpkf7o4k6p.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n        } else if c == ')' {\n  \
    \          open_parens -= 1;\n        }\n        if open_parens == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpc6wzqfar.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp1iis8n35.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            if c == ')' {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpv8a3_4y8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            groups.push(current_group);\n            current_group =\
    \ String::new();\n        } else {\n            current_group.push(c);\n     \
    \   }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpvg749a4q.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut current_depth = 0;\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                current_depth += 1;\n     \
    \           current_group.push(c);\n            }\n            ')' => {\n    \
    \            current_depth -= 1;\n                current_group.push(c);\n   \
    \             if current_depth == 0 {\n                    result.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if current_depth > 0 {\n      \
    \              current_group.push(c);\n                }\n            }\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpjjifgtdq.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut current_level: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_level +=\
    \ 1;\n                current_group.push(c);\n            }\n            ')' =>\
    \ {\n                current_level -= 1;\n                current_group.push(c);\n\
    \                if current_level == 0 {\n                    groups.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                current_group.push(c);\n      \
    \      }\n        }\n    }\n    groups\n}\n\nfn main() {\n    let candidate =\
    \ separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpq3xue6k1.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n        } else if c == ')' {\n  \
    \          open_parens -= 1;\n        }\n\n        if open_parens == 0 {\n   \
    \         if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    if !current_group.is_empty()\
    \ {\n        result.push(current_group);\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpobp1oydg.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            if open_parens == 0 {\n                current_group.clear();\n\
    \            }\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group.clone());\n\
    \            }\n        } else if c != ' ' {\n            current_group.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if !current_group.is_empty()\
    \ {\n        result.push(current_group);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpit58rbqx.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            if current_group.len() > 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if current_group.len()\
    \ > 0 {\n        result.push(current_group);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpktrypwiq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp1iis8n35.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            if c == ')' {\n                paren_groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            if c != ' ' {\n                current_group.push(c);\n     \
    \       }\n        }\n    }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpip5r14kw.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if open_parens > 0 {\n            current_group.push(c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpenzx1z2d.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_paren_count: u32 = 0;\n\n    for c\
    \ in paren_string.chars() {\n        if c == '(' {\n            open_paren_count\
    \ += 1;\n        } else if c == ')' {\n            open_paren_count -= 1;\n  \
    \      }\n\n        if open_paren_count == 0 {\n            if !current_group.is_empty()\
    \ {\n                result.push(current_group);\n                current_group\
    \ = String::new();\n            }\n        } else {\n            current_group.push(c);\n\
    \        }\n    }\n\n    if !current_group.is_empty() {\n        result.push(current_group);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpf2f2k2du.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n        } else if c == ')' {\n  \
    \          open_parens -= 1;\n        }\n        if open_parens == 0 {\n     \
    \       if current_group.len() > 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if current_group.len()\
    \ > 0 {\n        result.push(current_group);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmps00cz06e.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_stack: Vec<char> = Vec::new();\n\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            paren_stack.push(c);\n\
    \        } else if c == ')' {\n            paren_stack.pop();\n        }\n\n \
    \       if paren_stack.is_empty() {\n            if c == ')' {\n             \
    \   groups.push(current_group);\n                current_group = String::new();\n\
    \            } else {\n                current_group.push(c);\n            }\n\
    \        }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \" \", \" \", \" \"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"\
    ((())()())\"]`', /tmp/tmphfgx87jm.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if !current_group.is_empty()\
    \ {\n        result.push(current_group);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpit58rbqx.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            if current_group.len() > 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if current_group.len()\
    \ > 0 {\n        result.push(current_group);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpktrypwiq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            if c == ')' {\n                paren_groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            if c != ' ' {\n                current_group.push(c);\n     \
    \       }\n        }\n    }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpip5r14kw.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n\n        if open_parens\
    \ == 0 {\n            result.push(current_group);\n            current_group =\
    \ String::new();\n        } else {\n            current_group.push(c);\n     \
    \   }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp5538k582.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            if c == ')' {\n                current_group.push(c);\n\
    \                paren_groups.push(current_group);\n                current_group\
    \ = String::new();\n            }\n        } else {\n            if c != ' ' {\n\
    \                current_group.push(c);\n            }\n        }\n    }\n\n \
    \   paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut group: String\
    \ = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            if group.len() > 0 {\n                groups.push(group);\n\
    \                group = String::new();\n            }\n        } else {\n   \
    \         group.push(c);\n        }\n    }\n    if group.len() > 0 {\n       \
    \ groups.push(group);\n    }\n    groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpl5wdobbi.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                open_parens += 1;\n\
    \                current_group.push(c);\n            }\n            ')' => {\n\
    \                open_parens -= 1;\n                current_group.push(c);\n \
    \               if open_parens == 0 {\n                    groups.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if open_parens > 0 {\n        \
    \            current_group.push(c);\n                }\n            }\n      \
    \  }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpn3wok1m9.rs:40:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: usize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n        if open_parens ==\
    \ 0 {\n            if current_group.len() > 0 {\n                paren_groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if current_group.len()\
    \ > 0 {\n        paren_groups.push(current_group);\n    }\n    paren_groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp70hupipk.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n\n        if open_parens\
    \ == 0 {\n            if !current_group.is_empty() {\n                groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpppkthd7t.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // TODO: Implement me!\n    unimplemented!()\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpghc5mke1.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp1iis8n35.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut current_group_depth: i32 = 0;\n    for\
    \ c in paren_string.chars() {\n        match c {\n            '(' => {\n     \
    \           current_group_depth += 1;\n                current_group.push(c);\n\
    \            }\n            ')' => {\n                current_group_depth -= 1;\n\
    \                current_group.push(c);\n                if current_group_depth\
    \ == 0 {\n                    paren_groups.push(current_group);\n            \
    \        current_group = String::new();\n                }\n            }\n  \
    \          _ => {\n                if current_group_depth > 0 {\n            \
    \        current_group.push(c);\n                }\n            }\n        }\n\
    \    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpg2t3cxhb.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut paren_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            if !paren_group.is_empty() {\n                paren_groups.push(paren_group);\n\
    \                paren_group = String::new();\n            }\n        } else {\n\
    \            paren_group.push(c);\n        }\n    }\n\n    paren_groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpidwmconu.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            paren_groups.push(current_group);\n            current_group\
    \ = String::new();\n        } else {\n            current_group.push(c);\n   \
    \     }\n    }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpysxmo4bt.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut current_group_depth = 0;\n    for c in paren_string.chars() {\n \
    \       match c {\n            '(' => {\n                current_group_depth +=\
    \ 1;\n                current_group.push(c);\n            }\n            ')' =>\
    \ {\n                current_group_depth -= 1;\n                current_group.push(c);\n\
    \                if current_group_depth == 0 {\n                    result.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if current_group_depth > 0 {\n\
    \                    current_group.push(c);\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp29rj542c.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            groups.push(current_group);\n            current_group =\
    \ String::new();\n        } else {\n            current_group.push(c);\n     \
    \   }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpvg749a4q.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            groups.push(current_group);\n            current_group =\
    \ String::new();\n        } else {\n            current_group.push(c);\n     \
    \   }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpvg749a4q.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                open_parens += 1;\n\
    \                current_group.push(c);\n            }\n            ')' => {\n\
    \                open_parens -= 1;\n                current_group.push(c);\n \
    \               if open_parens == 0 {\n                    paren_groups.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if open_parens > 0 {\n        \
    \            current_group.push(c);\n                }\n            }\n      \
    \  }\n    }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp22kwmdmq.rs:40:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            if current_group.len() > 0 {\n                paren_groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    paren_groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpv63n_u2d.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n        } else if c == ')' {\n  \
    \          open_parens -= 1;\n        }\n        if open_parens == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpc6wzqfar.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut group: String\
    \ = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            groups.push(group.clone());\n            group = String::new();\n\
    \        } else {\n            group.push(c);\n        }\n    }\n    groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp22mmhtjw.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp1iis8n35.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n        } else if c == ')' {\n  \
    \          open_parens -= 1;\n        }\n        if open_parens == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpc6wzqfar.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n        if open_parens ==\
    \ 0 {\n            groups.push(group.clone());\n            group = String::new();\n\
    \        } else {\n            group.push(c);\n        }\n    }\n    groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpxyt48s6r.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n        } else if c == ')' {\n  \
    \          open_parens -= 1;\n        }\n        if open_parens == 0 {\n     \
    \       result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp13f0ejpp.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut current_group_depth = 0;\n    for c in paren_string.chars() {\n \
    \       match c {\n            '(' => {\n                current_group_depth +=\
    \ 1;\n                current_group.push(c);\n            }\n            ')' =>\
    \ {\n                current_group_depth -= 1;\n                current_group.push(c);\n\
    \                if current_group_depth == 0 {\n                    result.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if current_group_depth > 0 {\n\
    \                    current_group.push(c);\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp29rj542c.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            if current_group.len() > 0 {\n                groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    if current_group.len()\
    \ > 0 {\n        groups.push(current_group);\n    }\n\n    groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpgvebhe7c.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if !current_group.is_empty()\
    \ {\n        result.push(current_group);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpit58rbqx.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if c == ')' {\n                result.push(current_group);\n         \
    \       current_group = String::new();\n            }\n        } else {\n    \
    \        current_group.push(c);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp4t2jtjo8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_stack = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                paren_stack.push(c);\n\
    \                current_group.push(c);\n            }\n            ')' => {\n\
    \                paren_stack.pop();\n                current_group.push(c);\n\
    \                if paren_stack.is_empty() {\n                    result.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if !paren_stack.is_empty() {\n\
    \                    current_group.push(c);\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpe4pt9rks.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            if open_parens == 0 {\n                current_group.clear();\n\
    \            }\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group.clone());\n\
    \            }\n        } else if open_parens > 0 {\n            current_group.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmps26d42x7.rs:34:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut paren_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            if paren_group.len() > 0 {\n                paren_groups.push(paren_group);\n\
    \                paren_group = String::new();\n            }\n        } else {\n\
    \            paren_group.push(c);\n        }\n    }\n\n    paren_groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpuuyn3u1b.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut curr_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            curr_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            curr_group.push(c);\n\
    \            if open_parens == 0 {\n                groups.push(curr_group);\n\
    \                curr_group = String::new();\n            }\n        } else if\
    \ c != ' ' {\n            curr_group.push(c);\n        }\n    }\n    groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747931
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            if open_parens == 0 {\n                current_group.clear();\n\
    \            }\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group.clone());\n\
    \            }\n        } else if c != ' ' {\n            current_group.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747931
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    if !current_group.is_empty()\
    \ {\n        result.push(current_group);\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp5j772rnx.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            groups.push(current_group);\n            current_group =\
    \ String::new();\n        } else {\n            current_group.push(c);\n     \
    \   }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpvg749a4q.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            if !current_group.is_empty() {\n                paren_groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    if !current_group.is_empty()\
    \ {\n        paren_groups.push(current_group);\n    }\n\n    paren_groups\n}\n\
    \nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpdqd05xrq.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if !current_group.is_empty()\
    \ {\n        result.push(current_group);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpit58rbqx.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut output: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            if c == ')' {\n                output.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    output\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpgym6ie9y.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut group = String::new();\n  \
    \  let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            open_parens += 1;\n        } else if c == ')' {\n    \
    \        open_parens -= 1;\n        }\n        if open_parens == 0 {\n       \
    \     result.push(group);\n            group = String::new();\n        } else\
    \ {\n            group.push(c);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpps8zuntn.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            if open_parens == 0 {\n                current_group.clear();\n\
    \            }\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group.clone());\n\
    \            }\n        } else if c != ' ' {\n            current_group.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            groups.push(current_group);\n            current_group =\
    \ String::new();\n        } else {\n            current_group.push(c);\n     \
    \   }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpvg749a4q.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n\n        if open_parens\
    \ == 0 {\n            result.push(current_group);\n            current_group =\
    \ String::new();\n        } else {\n            current_group.push(c);\n     \
    \   }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp5538k582.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if !current_group.is_empty()\
    \ {\n        result.push(current_group);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpit58rbqx.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            if open_parens == 0 {\n                current_group.clear();\n\
    \            }\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group.clone());\n\
    \            }\n        } else if c != ' ' {\n            current_group.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpviyn_wi7.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n\n        if open_parens\
    \ == 0 {\n            if current_group.len() > 0 {\n                paren_groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    paren_groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpjh9lde_s.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                paren_count += 1;\n\
    \                current_group.push(c);\n            }\n            ')' => {\n\
    \                paren_count -= 1;\n                current_group.push(c);\n \
    \           }\n            _ => {\n                if paren_count == 0 {\n   \
    \                 if current_group.len() > 0 {\n                        groups.push(current_group);\n\
    \                        current_group = String::new();\n                    }\n\
    \                } else {\n                    current_group.push(c);\n      \
    \          }\n            }\n        }\n    }\n\n    if current_group.len() >\
    \ 0 {\n        groups.push(current_group);\n    }\n\n    groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpgio8fnto.rs:45:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if !current_group.is_empty()\
    \ {\n        result.push(current_group);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpit58rbqx.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut output: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            output.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpbg4h05s0.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut current_group_paren_count: u32 = 0;\n \
    \   for c in paren_string.chars() {\n        if c == '(' {\n            current_group_paren_count\
    \ += 1;\n        } else if c == ')' {\n            current_group_paren_count -=\
    \ 1;\n        }\n        current_group.push(c);\n        if current_group_paren_count\
    \ == 0 {\n            paren_groups.push(current_group);\n            current_group\
    \ = String::new();\n        }\n    }\n    paren_groups\n}\n\nfn main() {\n   \
    \ let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpmeyqgiz2.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_paren_count = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            open_paren_count += 1;\n        } else if c ==\
    \ ')' {\n            open_paren_count -= 1;\n        }\n        if open_paren_count\
    \ == 0 {\n            if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp4s2njq1y.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    if !current_group.is_empty()\
    \ {\n        result.push(current_group);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpit58rbqx.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n\n        if open_parens\
    \ == 0 {\n            if current_group.len() > 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n\n    if current_group.len()\
    \ > 0 {\n        result.push(current_group);\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmps5s5sbjz.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if open_parens > 0 {\n            current_group.push(c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp351vr1jq.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if c == ')' {\n                result.push(current_group);\n         \
    \       current_group = String::new();\n            }\n        } else {\n    \
    \        current_group.push(c);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp4t2jtjo8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if open_parens > 0 {\n            current_group.push(c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp351vr1jq.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp1iis8n35.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            paren_groups.push(current_group);\n            current_group\
    \ = String::new();\n        } else {\n            current_group.push(c);\n   \
    \     }\n    }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpysxmo4bt.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_string = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       result.push(current_string);\n            current_string = String::new();\n\
    \        } else {\n            current_string.push(c);\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp2xke84j_.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9okpub8o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747930
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747930
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut group: String\
    \ = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            if c == ')' {\n                group.push(c);\n           \
    \     groups.push(group);\n                group = String::new();\n          \
    \  }\n        } else {\n            group.push(c);\n        }\n    }\n    groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmphlrc6ok6.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if paren_count\
    \ == 0 {\n            if c == ')' {\n                paren_groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            if c != ' ' {\n                current_group.push(c);\n     \
    \       }\n        }\n    }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpip5r14kw.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747931
