language: rs
name: HumanEval_127_intersection
results:
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let (start, end) =\
    \ (start1.max(start2), end1.min(end2));\n    if start == end {\n        return\
    \ \"YES\".to_string();\n    }\n    if start == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..start {\n        if start % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp05cibf6r.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (start, end) = (max(start1,\
    \ start2), min(end1, end2));\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    let mut is_prime = true;\n    for i in 2..len {\n  \
    \      if len % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp7qlxkoji.rs:17:25\n\
    \   |\n17 |     let (start, end) = (max(start1, start2), min(end1, end2));\n \
    \  |                         ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `min` in this scope\n  --> /tmp/tmp7qlxkoji.rs:17:46\n\
    \   |\n17 |     let (start, end) = (max(start1, start2), min(end1, end2));\n \
    \  |                                              ^^^\n...\n39 | fn main() {\n\
    \   | --------- similarly named function `main` defined here\n   |\nhelp: a function\
    \ with a similar name exists\n   |\n17 |     let (start, end) = (max(start1, start2),\
    \ main(end1, end2));\n   |                                              ~~~~\n\
    help: consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start == end {\n\
    \        return \"YES\".to_string();\n    }\n    let mut is_prime = true;\n  \
    \  for i in 2..start {\n        if start % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..end {\n        if end % i == 0 {\n     \
    \       is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp5wls81kf.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let length = end - start + 1;\n\
    \    if length == 1 {\n        return \"NO\".to_string();\n    }\n    if length\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..length {\n\
    \        if length % i == 0 {\n            return \"NO\".to_string();\n      \
    \  }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpyj2l5pr5.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i1_start, i1_end)\
    \ = interval1;\n    let (i2_start, i2_end) = interval2;\n    let (mut start, mut\
    \ end) = (0, 0);\n    if i1_start <= i2_start {\n        start = i2_start;\n \
    \   } else {\n        start = i1_start;\n    }\n    if i1_end <= i2_end {\n  \
    \      end = i1_end;\n    } else {\n        end = i2_end;\n    }\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n\
    \    for i in 2..end {\n        if start % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp4y16zlpj.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start == end {\n\
    \        return \"YES\".to_string();\n    }\n    let length = end - start + 1;\n\
    \    if length == 2 {\n        return \"YES\".to_string();\n    }\n    for i in\
    \ 2..length {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp47hk83ll.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i1_start, i1_end)\
    \ = interval1;\n    let (i2_start, i2_end) = interval2;\n    let mut start = i1_start;\n\
    \    let mut end = i1_end;\n    if i2_start > i1_start {\n        start = i2_start;\n\
    \    }\n    if i2_end < i1_end {\n        end = i2_end;\n    }\n    if start >\
    \ end {\n        return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n\
    \    for i in 2..(end - start + 1) {\n        if (end - start + 1) % i == 0 {\n\
    \            is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpzjv947mh.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    let length = end - start + 1;\n    if length\
    \ < 2 {\n        return \"NO\".to_string();\n    }\n    if length == 2 {\n   \
    \     return \"YES\".to_string();\n    }\n    for i in 2..length {\n        if\
    \ length % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpkpcihw93.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let mut start = start1;\n\
    \    let mut end = end1;\n    if start2 > start1 {\n        start = start2;\n\
    \    }\n    if end2 < end1 {\n        end = end2;\n    }\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n   \
    \ for i in 2..end {\n        if end % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp68i20tfh.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start\
    \ + 1) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqq3ac_hn.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpt6btv1_d.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    let length = end - start + 1;\n    if length\
    \ <= 1 {\n        return \"NO\".to_string();\n    }\n    if length == 2 {\n  \
    \      return \"YES\".to_string();\n    }\n    for i in 2..length {\n        if\
    \ length % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpm7xnotvi.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let mut start = a;\n    let mut end = b;\n \
    \   if c > a {\n        start = c;\n    }\n    if d < b {\n        end = d;\n\
    \    }\n    if start > end {\n        return \"NO\".to_string();\n    }\n    let\
    \ mut is_prime = true;\n    for i in 2..end {\n        if start % i == 0 {\n \
    \           is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp48qvusph.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n    }\n    if len\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n\
    \        if len % i == 0 {\n            return \"NO\".to_string();\n        }\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpbb_ukal1.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (start, end) = if\
    \ start1 > start2 {\n        (start1, end1)\n    } else {\n        (start2, end2)\n\
    \    };\n    let (start, end) = if start < end2 {\n        (start, end2)\n   \
    \ } else {\n        (start, end)\n    };\n    let (start, end) = if start > end1\
    \ {\n        (start, end)\n    } else {\n        (start, end1)\n    };\n    if\
    \ start > end {\n        return \"NO\".to_string();\n    }\n    let length = end\
    \ - start + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n   \
    \ }\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..length {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpjq8x6hmn.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut start,\
    \ mut end) = (interval1.0, interval1.1);\n    if interval2.0 > start {\n     \
    \   start = interval2.0;\n    }\n    if interval2.1 < end {\n        end = interval2.1;\n\
    \    }\n    if start > end {\n        return \"NO\".to_string();\n    }\n    if\
    \ is_prime(end - start + 1) {\n        return \"YES\".to_string();\n    }\n  \
    \  \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n \
    \   assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp35j98up7.rs:25:8\n\
    \   |\n25 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let (mut start, mut end) = (a, b);\n    if a < c {\n        start\
    \ = c;\n    }\n    if b > d {\n        end = d;\n    }\n    if start == end {\n\
    \        return \"YES\".to_string();\n    }\n    let mut i = start;\n    while\
    \ i < end {\n        i += 1;\n        if i == 2 || i == 3 || i == 5 || i == 7\
    \ {\n            continue;\n        }\n        if i % 2 == 0 || i % 3 == 0 ||\
    \ i % 5 == 0 || i % 7 == 0 {\n            continue;\n        }\n        return\
    \ \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp23dg7oxl.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let mut x = c;\n    if a > x {\n        x = a;\n    }\n    let mut\
    \ y = d;\n    if b < y {\n        y = b;\n    }\n    let n = y - x + 1;\n    if\
    \ n <= 1 {\n        return \"NO\".to_string();\n    }\n    for i in 2..n {\n \
    \       if n % i == 0 {\n            return \"NO\".to_string();\n        }\n \
    \   }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp5a5y6vl3.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start\
    \ + 1) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqq3ac_hn.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (mut start, mut end) = (0, 0);\n    if a\
    \ <= c && c <= b {\n        start = c;\n    } else if c <= a && a <= d {\n   \
    \     start = a;\n    }\n    if a <= d && d <= b {\n        end = d;\n    } else\
    \ if c <= b && b <= d {\n        end = b;\n    }\n    if start == 0 || end ==\
    \ 0 {\n        return \"NO\".to_string();\n    }\n    if start == end {\n    \
    \    return \"YES\".to_string();\n    }\n    let mut count = 0;\n    for i in\
    \ start..end {\n        if i == 1 {\n            continue;\n        }\n      \
    \  if end % i == 0 {\n            count += 1;\n        }\n    }\n    if count\
    \ == 0 {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp95oa231r.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (start, end) = if a > c { (a, b) } else\
    \ { (c, d) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start >\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpq2mbz8pl.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (mut start, mut end) = (0, 0);\n    if a\
    \ <= c && c <= b {\n        start = c;\n    } else if c <= a && a <= d {\n   \
    \     start = a;\n    } else {\n        return \"NO\".to_string();\n    }\n  \
    \  if a <= d && d <= b {\n        end = d;\n    } else if c <= b && b <= d {\n\
    \        end = b;\n    } else {\n        return \"NO\".to_string();\n    }\n \
    \   let len = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp1a_19l9h.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpv8pwxpze.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let length = end - start + 1;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..length {\n        if length % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp6dr7qs99.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = if start1\
    \ > start2 { start1 } else { start2 };\n    let end = if end1 < end2 { end1 }\
    \ else { end2 };\n    let length = end - start + 1;\n    if length == 1 {\n  \
    \      return \"NO\".to_string();\n    }\n    for i in 2..length {\n        if\
    \ length % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp82mi4v72.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let (start, end) =\
    \ if start1 > start2 {\n        (start1, end1)\n    } else {\n        (start2,\
    \ end2)\n    };\n    let length = end - start + 1;\n    if length == 2 {\n   \
    \     return \"YES\".to_string();\n    }\n    if length % 2 == 0 {\n        return\
    \ \"NO\".to_string();\n    }\n    for i in 3..(length as f64).sqrt() as isize\
    \ + 1 {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpyphu5_sh.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let length = end - start\
    \ + 1;\n    if length <= 1 {\n        return \"NO\".to_string();\n    }\n    if\
    \ length == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..length\
    \ {\n        if length % i == 0 {\n            return \"NO\".to_string();\n  \
    \      }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpkxk0cdhd.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n  \
    \  if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpnet9ii__.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (start, end) = if a > c {\n        (a, b)\n\
    \    } else {\n        (c, d)\n    };\n    let (start, end) = if start > end {\n\
    \        (end, start)\n    } else {\n        (start, end)\n    };\n    let (a,\
    \ b) = interval1;\n    let (c, d) = interval2;\n    let (start, end) = if a >\
    \ c {\n        (a, b)\n    } else {\n        (c, d)\n    };\n    let (start, end)\
    \ = if start > end {\n        (end, start)\n    } else {\n        (start, end)\n\
    \    };\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n    let (start,\
    \ end) = if a > c {\n        (a, b)\n    } else {\n        (c, d)\n    };\n  \
    \  let (start, end) = if start > end {\n        (end, start)\n    } else {\n \
    \       (start, end)\n    };\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a > c {\n        (a, b)\n    } else {\n        (c,\
    \ d)\n    };\n    let (start, end) = if start > end {\n        (end, start)\n\
    \    } else {\n        (start, end)\n    };\n    let (a, b) = interval1;\n   \
    \ let (c, d) = interval2;\n    let (start, end) = if a > c {\n        (a, b)\n\
    \    } else {\n        (c, d)\n    };\n    let (start, end) = if start > end {\n\
    \        (end, start)\n    } else {\n        (start, end)\n    };\n    let (a,\
    \ b) = interval1;\n    let (c, d) = interval2;\n    let (start, end)\n}\n\nfn\
    \ main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb48d49ct.rs:77:21\n   |\n\
    77 |     let (start, end)\n   |                     ^ help: add `;` here\n78 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb48d49ct.rs:14:74\n\
    \   |\n14 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |    ------------                                          \
    \                ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start\
    \ + 1) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqq3ac_hn.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i1_start, i1_end)\
    \ = interval1;\n    let (i2_start, i2_end) = interval2;\n    let mut intersection\
    \ = (0, 0);\n    if i1_start <= i2_start && i2_start <= i1_end {\n        intersection.0\
    \ = i2_start;\n    } else if i2_start <= i1_start && i1_start <= i2_end {\n  \
    \      intersection.0 = i1_start;\n    }\n    if i1_start <= i2_end && i2_end\
    \ <= i1_end {\n        intersection.1 = i2_end;\n    } else if i2_start <= i1_end\
    \ && i1_end <= i2_end {\n        intersection.1 = i1_end;\n    }\n    if intersection.0\
    \ == 0 || intersection.1 == 0 {\n        return \"NO\".to_string();\n    }\n \
    \   let mut is_prime = true;\n    let length = intersection.1 - intersection.0;\n\
    \    for i in 2..length {\n        if length % i == 0 {\n            is_prime\
    \ = false;\n            break;\n        }\n    }\n    if is_prime {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp5de30l1b.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let diff = end - start\
    \ + 1;\n    if diff <= 1 {\n        return \"NO\".to_string();\n    }\n    if\
    \ diff == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..diff\
    \ {\n        if diff % i == 0 {\n            return \"NO\".to_string();\n    \
    \    }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp4u8c767z.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (mut start, mut end) = (0, 0);\n    if a\
    \ <= c && c <= b {\n        start = c;\n    } else if c <= a && a <= d {\n   \
    \     start = a;\n    }\n    if a <= d && d <= b {\n        end = d;\n    } else\
    \ if c <= b && b <= d {\n        end = b;\n    }\n    if start == 0 || end ==\
    \ 0 {\n        return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n\
    \    for i in 2..(end - start) {\n        if (end - start) % i == 0 {\n      \
    \      is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpcwqkx2xq.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let start = if a > c { a } else { c };\n    let end = if b < d { b\
    \ } else { d };\n    let len = end - start + 1;\n    if len == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmplq0_higt.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp7uv4z7y0.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (start, end) = if\
    \ start1 > start2 {\n        (start1, end1)\n    } else {\n        (start2, end2)\n\
    \    };\n    let (start, end) = if start > end {\n        (end, start)\n    }\
    \ else {\n        (start, end)\n    };\n    if start > end {\n        return \"\
    NO\".to_string();\n    }\n    let mut length = end - start;\n    if length ==\
    \ 0 {\n        return \"NO\".to_string();\n    }\n    if length == 1 {\n     \
    \   return \"YES\".to_string();\n    }\n    let mut is_prime = true;\n    for\
    \ i in 2..length {\n        if length % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpqerzyumi.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpt6btv1_d.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    if is_prime(end - start + 1) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpjt0qn4_z.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = max(start1,\
    \ start2);\n    let end = min(end1, end2);\n    if is_prime(end - start + 1) {\n\
    \        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpyysauaux.rs:20:17\n\
    \   |\n20 |     let start = max(start1, start2);\n   |                 ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min` in this\
    \ scope\n  --> /tmp/tmpyysauaux.rs:21:15\n   |\n21 |     let end = min(end1, end2);\n\
    \   |               ^^^\n...\n29 | fn main() {\n   | --------- similarly named\
    \ function `main` defined here\n   |\nhelp: a function with a similar name exists\n\
    \   |\n21 |     let end = main(end1, end2);\n   |               ~~~~\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]:\
    \ cannot find function `is_prime` in this scope\n  --> /tmp/tmpyysauaux.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (start, end) = (start1.max(start2),\
    \ end1.min(end2));\n    if start >= end {\n        return \"NO\".to_string();\n\
    \    }\n    let length = end - start + 1;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..length {\n        if length % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpb0wgoxh3.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = if start1\
    \ > start2 { start1 } else { start2 };\n    let end = if end1 < end2 { end1 }\
    \ else { end2 };\n    let length = end - start + 1;\n    if length == 1 {\n  \
    \      return \"NO\".to_string();\n    }\n    for i in 2..length {\n        if\
    \ length % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp82mi4v72.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let length = end - start + 1;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..length {\n        if length % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp6dr7qs99.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start == end {\n\
    \        return \"YES\".to_string();\n    }\n    let mut is_prime = true;\n  \
    \  for i in 2..end {\n        if end % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp9zcds5vx.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = if start1\
    \ > start2 { start1 } else { start2 };\n    let end = if end1 < end2 { end1 }\
    \ else { end2 };\n    if start == end {\n        return \"YES\".to_string();\n\
    \    }\n    let mut is_prime = true;\n    for i in 2..end {\n        if end %\
    \ i == 0 {\n            is_prime = false;\n            break;\n        }\n   \
    \ }\n    if is_prime {\n        \"YES\".to_string()\n    } else {\n        \"\
    NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp1ro5vf3b.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (start, end) = (start1.max(start2),\
    \ end1.min(end2));\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpr30dwwbu.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpt6btv1_d.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let (mut start, mut end) = (a, b);\n    if c > a {\n        start\
    \ = c;\n    }\n    if d < b {\n        end = d;\n    }\n    let len = end - start\
    \ + 1;\n    if len < 2 {\n        return \"NO\".to_string();\n    }\n    for i\
    \ in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpuzl_s894.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (x, y) = (max(a, c), min(b, d));\n    if\
    \ x > y {\n        return \"NO\".to_string();\n    }\n    let len = y - x + 1;\n\
    \    if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2\
    \ {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n     \
    \   if len % i == 0 {\n            return \"NO\".to_string();\n        }\n   \
    \ }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmprdfg8u7e.rs:17:19\n\
    \   |\n17 |     let (x, y) = (max(a, c), min(b, d));\n   |                   ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min` in this\
    \ scope\n  --> /tmp/tmprdfg8u7e.rs:17:30\n   |\n17 |     let (x, y) = (max(a,\
    \ c), min(b, d));\n   |                              ^^^\n...\n36 | fn main()\
    \ {\n   | --------- similarly named function `main` defined here\n   |\nhelp:\
    \ a function with a similar name exists\n   |\n17 |     let (x, y) = (max(a, c),\
    \ main(b, d));\n   |                              ~~~~\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut start,\
    \ mut end) = (interval1.0, interval1.1);\n    if interval1.0 > interval2.0 {\n\
    \        start = interval2.0;\n    }\n    if interval1.1 < interval2.1 {\n   \
    \     end = interval2.1;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpwr68rg5x.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start\
    \ + 1) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqq3ac_hn.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let (start, end) =\
    \ (start1.max(start2), end1.min(end2));\n    if start == end {\n        return\
    \ \"YES\".to_string();\n    }\n    if is_prime(end - start) {\n        return\
    \ \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp9713fxvp.rs:24:8\n\
    \   |\n24 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let length = end - start\
    \ + 1;\n    if length < 2 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..length {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpo_6qhwou.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = if start1\
    \ > start2 { start1 } else { start2 };\n    let end = if end1 < end2 { end1 }\
    \ else { end2 };\n    if start > end {\n        return \"NO\".to_string();\n \
    \   }\n    let length = end - start + 1;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    let mut i = 2;\n    while i * i <= length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n        i += 1;\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpy0mgxpxw.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp7uv4z7y0.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (start, end) = if\
    \ start1 > start2 {\n        (start1, end1)\n    } else {\n        (start2, end2)\n\
    \    };\n    let mut length = 0;\n    if start <= end {\n        length = end\
    \ - start;\n    }\n    if length == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    if is_prime(length) {\n        return \"YES\".to_string();\n    }\n\
    \    return \"NO\".to_string();\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp3sw2fss6.rs:29:8\n\
    \   |\n29 |     if is_prime(length) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let length = end - start\
    \ + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..length {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpkmzgzsk9.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let mut start = start1;\n\
    \    let mut end = end1;\n    if start2 > start1 {\n        start = start2;\n\
    \    }\n    if end2 < end1 {\n        end = end2;\n    }\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n   \
    \ for i in 2..end {\n        if end % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp68i20tfh.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = if start1\
    \ > start2 { start1 } else { start2 };\n    let end = if end1 < end2 { end1 }\
    \ else { end2 };\n    if start > end {\n        return \"NO\".to_string();\n \
    \   }\n    let length = end - start + 1;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..length {\n        if length % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp0w3to1ui.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n    }\n    let\
    \ mut is_prime = true;\n    for i in 2..len {\n        if len % i == 0 {\n   \
    \         is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmps37qfzp3.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    let length = end - start + 1;\n    if length\
    \ == 1 {\n        return \"NO\".to_string();\n    }\n    for i in 2..length {\n\
    \        if length % i == 0 {\n            return \"NO\".to_string();\n      \
    \  }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp3ru5m3mm.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let mut start = start1;\n\
    \    let mut end = end1;\n    if start2 > start1 {\n        start = start2;\n\
    \    }\n    if end2 < end1 {\n        end = end2;\n    }\n    let len = end -\
    \ start + 1;\n    if len < 2 {\n        return \"NO\".to_string();\n    }\n  \
    \  if len == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..len\
    \ {\n        if len % i == 0 {\n            return \"NO\".to_string();\n     \
    \   }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp8sruiz3o.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpt6btv1_d.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start\
    \ + 1) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqq3ac_hn.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let mut start = a;\n    let mut end = b;\n \
    \   if a > c {\n        start = c;\n    }\n    if b < d {\n        end = d;\n\
    \    }\n    if start > end {\n        return \"NO\".to_string();\n    }\n    let\
    \ mut res = \"YES\".to_string();\n    for i in 2..(end - start + 1) {\n      \
    \  if (end - start + 1) % i == 0 {\n            res = \"NO\".to_string();\n  \
    \          break;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp07ch3qah.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start\
    \ + 1) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqq3ac_hn.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpg8gxjrbk.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut start,\
    \ mut end) = (interval1.0, interval1.1);\n    if interval2.0 > start {\n     \
    \   start = interval2.0;\n    }\n    if interval2.1 < end {\n        end = interval2.1;\n\
    \    }\n    if start > end {\n        return \"NO\".to_string();\n    }\n    if\
    \ is_prime(end - start + 1) {\n        return \"YES\".to_string();\n    }\n  \
    \  \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n \
    \   assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp35j98up7.rs:25:8\n\
    \   |\n25 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let mut start = start1;\n\
    \    let mut end = end1;\n    if start2 > start1 {\n        start = start2;\n\
    \    }\n    if end2 < end1 {\n        end = end2;\n    }\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    let length = end - start + 1;\n\
    \    if length == 1 {\n        return \"NO\".to_string();\n    }\n    if length\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..length {\n\
    \        if length % i == 0 {\n            return \"NO\".to_string();\n      \
    \  }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpm7vyshsp.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start == end {\n\
    \        return \"YES\".to_string();\n    }\n    let mut is_prime = true;\n  \
    \  for i in 2..end {\n        if start % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp1_o42pm0.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (start, end) = if\
    \ start1 > start2 {\n        (start1, end1)\n    } else {\n        (start2, end2)\n\
    \    };\n    if end < start {\n        return \"NO\".to_string();\n    }\n   \
    \ let mut length = end - start;\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n   \
    \ let mut i = 2;\n    while i * i <= length {\n        if length % i == 0 {\n\
    \            return \"NO\".to_string();\n        }\n        i += 1;\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmpgee8vqwu.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let (start, end) =\
    \ (start1.max(start2), end1.min(end2));\n    let len = end - start + 1;\n    if\
    \ len < 2 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n  \
    \      return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if len\
    \ % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"\
    YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp2_3c82km.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (start, end) = (max(start1,\
    \ start2), min(end1, end2));\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpxhz73l7l.rs:17:25\n\
    \   |\n17 |     let (start, end) = (max(start1, start2), min(end1, end2));\n \
    \  |                         ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `min` in this scope\n  --> /tmp/tmpxhz73l7l.rs:17:46\n\
    \   |\n17 |     let (start, end) = (max(start1, start2), min(end1, end2));\n \
    \  |                                              ^^^\n...\n33 | fn main() {\n\
    \   | --------- similarly named function `main` defined here\n   |\nhelp: a function\
    \ with a similar name exists\n   |\n17 |     let (start, end) = (max(start1, start2),\
    \ main(end1, end2));\n   |                                              ~~~~\n\
    help: consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let length = end - start + 1;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..length {\n        if length % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp6dr7qs99.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    let diff = end - start + 1;\n    if diff ==\
    \ 1 {\n        return \"NO\".to_string();\n    }\n    if diff == 2 {\n       \
    \ return \"YES\".to_string();\n    }\n    if diff % 2 == 0 {\n        return \"\
    NO\".to_string();\n    }\n    for i in 3..diff {\n        if diff % i == 0 {\n\
    \            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpqd0jzo4j.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let mut x = c;\n    if a > x {\n        x = a;\n    }\n    let mut\
    \ y = d;\n    if b < y {\n        y = b;\n    }\n    if x > y {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut is_prime = true;\n    for i in 2..(y\
    \ - x + 1) {\n        if (y - x + 1) % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        return \"YES\"\
    .to_string();\n    }\n    return \"NO\".to_string();\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmppfjin__f.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    let length = end - start + 1;\n    if length\
    \ <= 1 {\n        return \"NO\".to_string();\n    }\n    if length == 2 {\n  \
    \      return \"YES\".to_string();\n    }\n    for i in 2..length {\n        if\
    \ length % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpm7xnotvi.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    let length = end - start + 1;\n    if length\
    \ <= 1 {\n        return \"NO\".to_string();\n    }\n    if length == 2 {\n  \
    \      return \"YES\".to_string();\n    }\n    for i in 2..length {\n        if\
    \ length % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpm7xnotvi.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n  \
    \  if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpnet9ii__.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpt6btv1_d.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut start,\
    \ mut end) = (interval1.0, interval1.1);\n    if start > end {\n        start\
    \ = interval1.1;\n        end = interval1.0;\n    }\n    let (mut start2, mut\
    \ end2) = (interval2.0, interval2.1);\n    if start2 > end2 {\n        start2\
    \ = interval2.1;\n        end2 = interval2.0;\n    }\n    if start > end2 || start2\
    \ > end {\n        return \"NO\".to_string();\n    }\n    if start2 > start {\n\
    \        start = start2;\n    }\n    if end2 < end {\n        end = end2;\n  \
    \  }\n    if end - start == 1 {\n        return \"NO\".to_string();\n    }\n \
    \   let mut is_prime = true;\n    for i in 2..end {\n        if i == start {\n\
    \            continue;\n        }\n        if end % i == 0 {\n            is_prime\
    \ = false;\n            break;\n        }\n    }\n    if is_prime {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpcg6lagam.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let length = end - start\
    \ + 1;\n    if length <= 1 {\n        return \"NO\".to_string();\n    }\n    if\
    \ length == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..length\
    \ {\n        if length % i == 0 {\n            return \"NO\".to_string();\n  \
    \      }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpkxk0cdhd.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n    }\n    let\
    \ mut is_prime = true;\n    for i in 2..len {\n        if len % i == 0 {\n   \
    \         is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp3nqkihkh.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i1_start, i1_end)\
    \ = interval1;\n    let (i2_start, i2_end) = interval2;\n    let start = if i1_start\
    \ > i2_start { i1_start } else { i2_start };\n    let end = if i1_end < i2_end\
    \ { i1_end } else { i2_end };\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpgq6mzn5e.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let mut start = a;\n    let mut end = b;\n    if c > a {\n       \
    \ start = c;\n    }\n    if d < b {\n        end = d;\n    }\n    let length =\
    \ end - start + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n   \
    \ for i in 2..length {\n        if length % i == 0 {\n            return \"NO\"\
    .to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpi8o71gf2.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (x, y) = (max(a, c), min(b, d));\n    if\
    \ x > y {\n        return \"NO\".to_string();\n    }\n    let len = y - x + 1;\n\
    \    if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2\
    \ {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n     \
    \   if len % i == 0 {\n            return \"NO\".to_string();\n        }\n   \
    \ }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmprdfg8u7e.rs:17:19\n\
    \   |\n17 |     let (x, y) = (max(a, c), min(b, d));\n   |                   ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min` in this\
    \ scope\n  --> /tmp/tmprdfg8u7e.rs:17:30\n   |\n17 |     let (x, y) = (max(a,\
    \ c), min(b, d));\n   |                              ^^^\n...\n36 | fn main()\
    \ {\n   | --------- similarly named function `main` defined here\n   |\nhelp:\
    \ a function with a similar name exists\n   |\n17 |     let (x, y) = (max(a, c),\
    \ main(b, d));\n   |                              ~~~~\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = if start1\
    \ > start2 { start1 } else { start2 };\n    let end = if end1 < end2 { end1 }\
    \ else { end2 };\n    if start > end {\n        return \"NO\".to_string();\n \
    \   }\n    let length = end - start + 1;\n    if is_prime(length) {\n        return\
    \ \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp0waxprr6.rs:23:8\n\
    \   |\n23 |     if is_prime(length) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let start = if a > c { a } else { c };\n    let end = if b < d { b\
    \ } else { d };\n    let len = end - start + 1;\n    if len <= 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut is_prime = true;\n    for i in 2..len\
    \ {\n        if len % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpmr1msimw.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    let len = end - start + 1;\n    if len <=\
    \ 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..len {\n        if len % i == 0\
    \ {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpl2c73yj6.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (start, end) = if a > c {\n        (a, b)\n\
    \    } else {\n        (c, d)\n    };\n    let (start, end) = if start > end {\n\
    \        (end, start)\n    } else {\n        (start, end)\n    };\n    let (a,\
    \ b) = interval1;\n    let (c, d) = interval2;\n    let (start, end) = if a >\
    \ c {\n        (a, b)\n    } else {\n        (c, d)\n    };\n    let (start, end)\
    \ = if start > end {\n        (end, start)\n    } else {\n        (start, end)\n\
    \    };\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n    let (start,\
    \ end) = if a > c {\n        (a, b)\n    } else {\n        (c, d)\n    };\n  \
    \  let (start, end) = if start > end {\n        (end, start)\n    } else {\n \
    \       (start, end)\n    };\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a > c {\n        (a, b)\n    } else {\n        (c,\
    \ d)\n    };\n    let (start, end) = if start > end {\n        (end, start)\n\
    \    } else {\n        (start, end)\n    };\n    let (a, b) = interval1;\n   \
    \ let (c, d) = interval2;\n    let (start, end) = if a > c {\n        (a, b)\n\
    \    } else {\n        (c, d)\n    };\n    let (start, end) = if start > end {\n\
    \        (end, start)\n    } else {\n        (start, end)\n    };\n    let (a,\
    \ b) = interval1;\n    let (c, d) = interval2;\n    let (start, end)\n}\n\nfn\
    \ main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb48d49ct.rs:77:21\n   |\n\
    77 |     let (start, end)\n   |                     ^ help: add `;` here\n78 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb48d49ct.rs:14:74\n\
    \   |\n14 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |    ------------                                          \
    \                ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut start,\
    \ mut end) = (interval1.0, interval1.1);\n    if start > end {\n        start\
    \ = interval1.1;\n        end = interval1.0;\n    }\n    let (mut start2, mut\
    \ end2) = (interval2.0, interval2.1);\n    if start2 > end2 {\n        start2\
    \ = interval2.1;\n        end2 = interval2.0;\n    }\n    if start > end2 || start2\
    \ > end {\n        return \"NO\".to_string();\n    }\n    if start2 > start {\n\
    \        start = start2;\n    }\n    if end2 < end {\n        end = end2;\n  \
    \  }\n    if start == end {\n        return \"NO\".to_string();\n    }\n    let\
    \ mut is_prime = true;\n    for i in 2..end {\n        if end % i == 0 {\n   \
    \         is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpyws5idym.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut start,\
    \ mut end) = (interval1.0, interval1.1);\n    if start > end {\n        std::mem::swap(&mut\
    \ start, &mut end);\n    }\n    let (mut start2, mut end2) = (interval2.0, interval2.1);\n\
    \    if start2 > end2 {\n        std::mem::swap(&mut start2, &mut end2);\n   \
    \ }\n    if start > end2 || start2 > end {\n        return \"NO\".to_string();\n\
    \    }\n    let (mut start, mut end) = (std::cmp::max(start, start2), std::cmp::min(end,\
    \ end2));\n    if start == end {\n        return \"NO\".to_string();\n    }\n\
    \    let mut is_prime = true;\n    for i in 2..end {\n        if start % i ==\
    \ 0 {\n            is_prime = false;\n            break;\n        }\n    }\n \
    \   if is_prime {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp93k47rsx.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if is_prime(end - start + 1) {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpo39x8w7y.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let mut start = start1;\n\
    \    let mut end = end1;\n    if start2 > start1 {\n        start = start2;\n\
    \    }\n    if end2 < end1 {\n        end = end2;\n    }\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    let length = end - start + 1;\n\
    \    if length == 1 {\n        return \"NO\".to_string();\n    }\n    if length\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..length {\n\
    \        if length % i == 0 {\n            return \"NO\".to_string();\n      \
    \  }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpm7vyshsp.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = if start1\
    \ > start2 { start1 } else { start2 };\n    let end = if end1 < end2 { end1 }\
    \ else { end2 };\n    let length = end - start + 1;\n    if length < 2 {\n   \
    \     return \"NO\".to_string();\n    }\n    if length == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpimnorpzz.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n  \
    \  if len == 1 {\n        return \"NO\".to_string();\n    }\n    for i in 2..len\
    \ {\n        if len % i == 0 {\n            return \"NO\".to_string();\n     \
    \   }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpuwqat97h.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start\
    \ + 1) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqq3ac_hn.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (mut start, mut end) = (0, 0);\n    if a\
    \ > c {\n        start = a;\n    } else {\n        start = c;\n    }\n    if b\
    \ < d {\n        end = b;\n    } else {\n        end = d;\n    }\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    let mut count = 0;\n\
    \    for i in start..end + 1 {\n        count += 1;\n    }\n    if is_prime(count)\
    \ {\n        return \"YES\".to_string();\n    } else {\n        return \"NO\"\
    .to_string();\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n  \
    \  assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpe9i_17f5.rs:35:8\n\
    \   |\n35 |     if is_prime(count) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n  \
    \  if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpnet9ii__.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (start, end) = if\
    \ start1 > start2 {\n        (start1, end1)\n    } else {\n        (start2, end2)\n\
    \    };\n    let mut intersection = (start, end);\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    if start1 > start2\
    \ {\n        intersection = (start2, end1);\n    }\n    if start2 > start1 {\n\
    \        intersection = (start1, end2);\n    }\n    if intersection.1 - intersection.0\
    \ == 1 {\n        return \"NO\".to_string();\n    }\n    if is_prime(intersection.1\
    \ - intersection.0) {\n        return \"YES\".to_string();\n    }\n    \"NO\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp5eqfxsxg.rs:35:8\n\
    \   |\n35 |     if is_prime(intersection.1 - intersection.0) {\n   |        ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = if start1\
    \ > start2 { start1 } else { start2 };\n    let end = if end1 < end2 { end1 }\
    \ else { end2 };\n    let length = end - start + 1;\n    if length < 2 {\n   \
    \     return \"NO\".to_string();\n    }\n    if length == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpimnorpzz.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpt6btv1_d.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    let length = end - start + 1;\n    if length\
    \ <= 1 {\n        return \"NO\".to_string();\n    }\n    if length == 2 {\n  \
    \      return \"YES\".to_string();\n    }\n    for i in 2..length {\n        if\
    \ length % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpm7xnotvi.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i1_start, i1_end)\
    \ = interval1;\n    let (i2_start, i2_end) = interval2;\n    let (start, end)\
    \ = if i1_start > i2_start {\n        (i1_start, i2_end)\n    } else {\n     \
    \   (i2_start, i1_end)\n    };\n    if start > end {\n        \"NO\".to_string()\n\
    \    } else {\n        let length = end - start + 1;\n        if length == 1 {\n\
    \            \"NO\".to_string()\n        } else {\n            let mut is_prime\
    \ = true;\n            for i in 2..length {\n                if length % i ==\
    \ 0 {\n                    is_prime = false;\n                    break;\n   \
    \             }\n            }\n            if is_prime {\n                \"\
    YES\".to_string()\n            } else {\n                \"NO\".to_string()\n\
    \            }\n        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpipjn6egs.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let length = end - start\
    \ + 1;\n    if length <= 1 {\n        return \"NO\".to_string();\n    }\n    if\
    \ length == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..length\
    \ {\n        if length % i == 0 {\n            return \"NO\".to_string();\n  \
    \      }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpkxk0cdhd.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let mut x = c;\n    if a > x {\n        x = a;\n    }\n    let mut\
    \ y = d;\n    if b < y {\n        y = b;\n    }\n    if x > y {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut z = y - x + 1;\n    if z == 1 {\n  \
    \      return \"YES\".to_string();\n    }\n    let mut i = 2;\n    while i * i\
    \ <= z {\n        if z % i == 0 {\n            return \"NO\".to_string();\n  \
    \      }\n        i += 1;\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp6ez7ax3g.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpg8gxjrbk.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    let mut is_prime = true;\n    for i in 2..len {\n  \
    \      if len % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpikdgdb2h.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut start,\
    \ mut end) = (interval1.0, interval1.1);\n    if interval1.0 > interval2.0 {\n\
    \        start = interval2.0;\n    }\n    if interval1.1 < interval2.1 {\n   \
    \     end = interval2.1;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp0gd1uldl.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let (mut start, mut end) = (a, b);\n    if c > a {\n        start\
    \ = c;\n    }\n    if d < b {\n        end = d;\n    }\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n \
    \   if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2\
    \ {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n     \
    \   if len % i == 0 {\n            return \"NO\".to_string();\n        }\n   \
    \ }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpa58q4d91.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpg2oivhkp.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start == end {\n        return \"YES\"\
    .to_string();\n    }\n    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    if primes.contains(&(end\
    \ - start + 1)) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpr1f12ptn.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > b || c > d {\n        return \"NO\".to_string();\n\
    \    }\n    let (mut start, mut end) = (a, b);\n    if a < c {\n        start\
    \ = c;\n    }\n    if b > d {\n        end = d;\n    }\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n   \
    \ for i in 2..end {\n        if end % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp6h4pjv0x.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (start, end) = if a > c { (a, b) } else\
    \ { (c, d) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start >\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpq2mbz8pl.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let (mut start, mut end) = (a, b);\n    if c > a {\n        start\
    \ = c;\n    }\n    if d < b {\n        end = d;\n    }\n    if start == end {\n\
    \        return \"YES\".to_string();\n    }\n    let mut is_prime = true;\n  \
    \  for i in 2..start {\n        if start % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        return \"YES\"\
    .to_string();\n    }\n    for i in start + 1..end {\n        is_prime = true;\n\
    \        for j in 2..i {\n            if i % j == 0 {\n                is_prime\
    \ = false;\n                break;\n            }\n        }\n        if is_prime\
    \ {\n            return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmps8tw36_w.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (start, end) = if\
    \ start1 > start2 {\n        (start1, end1)\n    } else {\n        (start2, end2)\n\
    \    };\n    let (start, end) = if start > end {\n        (end, start)\n    }\
    \ else {\n        (start, end)\n    };\n    if start > end {\n        return \"\
    NO\".to_string();\n    }\n    let length = end - start + 1;\n    if length ==\
    \ 1 {\n        return \"NO\".to_string();\n    }\n    if length == 2 {\n     \
    \   return \"YES\".to_string();\n    }\n    if length % 2 == 0 {\n        return\
    \ \"NO\".to_string();\n    }\n    for i in 3..(length as f64).sqrt() as isize\
    \ + 1 {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpiraxqx17.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n  \
    \  if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpnet9ii__.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n\
    \        if len % i == 0 {\n            return \"NO\".to_string();\n        }\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp_yceb9tn.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (start, end) = if\
    \ start1 > start2 {\n        (start1, end1)\n    } else {\n        (start2, end2)\n\
    \    };\n    let mut intersection = (start, end);\n    if start > end {\n    \
    \    intersection = (end, start);\n    }\n    if intersection.0 > intersection.1\
    \ {\n        return \"NO\".to_string();\n    }\n    let mut primes = vec![2, 3,\
    \ 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,\
    \ 83, 89, 97];\n    let mut i = 0;\n    let mut is_prime = false;\n    while i\
    \ < primes.len() {\n        if primes[i] == intersection.1 - intersection.0 +\
    \ 1 {\n            is_prime = true;\n            break;\n        }\n        i\
    \ += 1;\n    }\n    if is_prime {\n        \"YES\".to_string()\n    } else {\n\
    \        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpr_xba5j6.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let (mut start, mut end) = (a, b);\n    if c > a {\n        start\
    \ = c;\n    }\n    if d < b {\n        end = d;\n    }\n    let len = end - start\
    \ + 1;\n    if len < 2 {\n        return \"NO\".to_string();\n    }\n    if len\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n\
    \        if len % i == 0 {\n            return \"NO\".to_string();\n        }\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp4da6k542.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (start, end) = (start1.max(start2),\
    \ end1.min(end2));\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpr30dwwbu.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = if start1\
    \ > start2 { start1 } else { start2 };\n    let end = if end1 < end2 { end1 }\
    \ else { end2 };\n    let length = end - start + 1;\n    if length == 1 {\n  \
    \      return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n    for\
    \ i in 2..length {\n        if length % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp6nlegzn5.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = if start1\
    \ > start2 { start1 } else { start2 };\n    let end = if end1 < end2 { end1 }\
    \ else { end2 };\n    let length = end - start + 1;\n    if length == 1 {\n  \
    \      return \"NO\".to_string();\n    }\n    if length == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp3lmsfd6n.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut start,\
    \ mut end) = (interval1.0, interval1.1);\n    if interval2.0 > start {\n     \
    \   start = interval2.0;\n    }\n    if interval2.1 < end {\n        end = interval2.1;\n\
    \    }\n    if start > end {\n        return \"NO\".to_string();\n    }\n    if\
    \ is_prime(end - start + 1) {\n        return \"YES\".to_string();\n    }\n  \
    \  \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n \
    \   assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp35j98up7.rs:25:8\n\
    \   |\n25 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp7uv4z7y0.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i1_start, i1_end)\
    \ = interval1;\n    let (i2_start, i2_end) = interval2;\n    let mut start = i1_start;\n\
    \    let mut end = i1_end;\n    if i2_start > start {\n        start = i2_start;\n\
    \    }\n    if i2_end < end {\n        end = i2_end;\n    }\n    if start > end\
    \ {\n        return \"NO\".to_string();\n    }\n    let mut length = end - start\
    \ + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n    let\
    \ mut is_prime = true;\n    for i in 2..length {\n        if length % i == 0 {\n\
    \            is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpjzojr07x.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let mut x = c;\n    if a > x {\n        x = a;\n    }\n    let mut\
    \ y = d;\n    if b < y {\n        y = b;\n    }\n    if x > y {\n        return\
    \ \"NO\".to_string();\n    }\n    let z = y - x + 1;\n    if z == 1 {\n      \
    \  return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n    for i\
    \ in 2..z {\n        if z % i == 0 {\n            is_prime = false;\n        \
    \    break;\n        }\n    }\n    if is_prime {\n        return \"YES\".to_string();\n\
    \    }\n    return \"NO\".to_string();\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpcn6crvfq.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let (start, end) =\
    \ if start1 > start2 {\n        (start1, end1)\n    } else {\n        (start2,\
    \ end2)\n    };\n    let len = end - start + 1;\n    if len == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut is_prime = true;\n    for i in 2..len\
    \ {\n        if len % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp2cl62e4i.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let (mut start, mut end) = (a, b);\n    if c > a {\n        start\
    \ = c;\n    }\n    if d < b {\n        end = d;\n    }\n    let len = end - start\
    \ + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n    }\n    let\
    \ mut is_prime = true;\n    for i in 2..len {\n        if len % i == 0 {\n   \
    \         is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp61k1n1lc.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start == end {\n\
    \        return \"YES\".to_string();\n    }\n    let mut is_prime = true;\n  \
    \  for i in 2..end {\n        if start % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp1_o42pm0.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let length = end - start\
    \ + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n    if\
    \ length == 2 {\n        return \"YES\".to_string();\n    }\n    if length % 2\
    \ == 0 {\n        return \"NO\".to_string();\n    }\n    for i in 3..length {\n\
    \        if length % i == 0 {\n            return \"NO\".to_string();\n      \
    \  }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpm9ds5zpr.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start\
    \ + 1) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqq3ac_hn.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    let length = end - start + 1;\n    if length\
    \ == 1 {\n        return \"NO\".to_string();\n    }\n    if length == 2 {\n  \
    \      return \"YES\".to_string();\n    }\n    for i in 2..length {\n        if\
    \ length % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpz05tuey9.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (mut start, mut end) = (0, 0);\n    if a\
    \ <= c && c <= b {\n        start = c;\n    } else if c <= a && a <= d {\n   \
    \     start = a;\n    }\n    if a <= d && d <= b {\n        end = d;\n    } else\
    \ if c <= b && b <= d {\n        end = b;\n    }\n    if start == 0 && end ==\
    \ 0 {\n        return \"NO\".to_string();\n    }\n    let len = end - start;\n\
    \    if len == 1 {\n        return \"NO\".to_string();\n    }\n    for i in 2..len\
    \ {\n        if len % i == 0 {\n            return \"NO\".to_string();\n     \
    \   }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpgg0k0jyk.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let mut start = start1;\n\
    \    let mut end = end1;\n    if start2 > start1 {\n        start = start2;\n\
    \    }\n    if end2 < end1 {\n        end = end2;\n    }\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    let length = end - start + 1;\n\
    \    if length == 1 {\n        return \"NO\".to_string();\n    }\n    for i in\
    \ 2..length {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpadrzno3m.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut start =\
    \ interval1.0;\n    let mut end = interval1.1;\n    if interval2.0 > start {\n\
    \        start = interval2.0;\n    }\n    if interval2.1 < end {\n        end\
    \ = interval2.1;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let mut count = 0;\n    for i in start..end + 1 {\n        count +=\
    \ 1;\n    }\n    if is_prime(count) {\n        return \"YES\".to_string();\n \
    \   }\n    return \"NO\".to_string();\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp56fjxbd3.rs:30:8\n\
    \   |\n30 |     if is_prime(count) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp7uv4z7y0.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let mut start = std::cmp::max(start1,\
    \ start2);\n    let mut end = std::cmp::min(end1, end2);\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n   \
    \ for i in 2..end {\n        if start % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpb_d9lpdf.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpg2oivhkp.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if is_prime(end - start + 1) {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpo39x8w7y.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start == end {\n        return \"YES\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 2 {\n    \
    \    return \"YES\".to_string();\n    }\n    if len % 2 == 0 {\n        return\
    \ \"NO\".to_string();\n    }\n    for i in 3..len {\n        if len % i == 0 {\n\
    \            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmplx0e0eb6.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (start, end) = (start1.max(start2),\
    \ end1.min(end2));\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp3pais_fc.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let length = end - start + 1;\n\
    \    if is_prime(length) {\n        return \"YES\".to_string();\n    }\n    return\
    \ \"NO\".to_string();\n}\n\nfn main() {\n    let candidate = intersection;\n \
    \   assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpzu8cbklm.rs:23:8\n\
    \   |\n23 |     if is_prime(length) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let length = end - start + 1;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut is_prime = true;\n    for i in 2..length\
    \ {\n        if length % i == 0 {\n            is_prime = false;\n           \
    \ break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n \
    \   } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp8k8_ghjw.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start\
    \ + 1) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqq3ac_hn.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let length = end - start\
    \ + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..length {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpkmzgzsk9.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 0
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (start, end) = if a > c { (a, b) } else\
    \ { (c, d) };\n    let (x, y) = if a < c { (a, b) } else { (c, d) };\n    if x\
    \ > end || y < start {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ count = 0;\n    for i in x..=y {\n        if i >= start && i <= end {\n    \
    \        count += 1;\n        }\n    }\n    if count == 1 || count == 2 {\n  \
    \      return \"NO\".to_string();\n    }\n    for i in 2..count {\n        if\
    \ count % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let mut start = start1;\n\
    \    let mut end = end1;\n    if start2 > start1 {\n        start = start2;\n\
    \    }\n    if end2 < end1 {\n        end = end2;\n    }\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n \
    \   if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2\
    \ {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n     \
    \   if len % i == 0 {\n            return \"NO\".to_string();\n        }\n   \
    \ }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmplz7z754k.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let mut x = a;\n    if c > x {\n        x = c;\n    }\n    let mut\
    \ y = b;\n    if d < y {\n        y = d;\n    }\n    let mut is_prime = true;\n\
    \    for i in 2..(y - x) {\n        if (y - x) % i == 0 {\n            is_prime\
    \ = false;\n            break;\n        }\n    }\n    if is_prime {\n        return\
    \ \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp1qhsrvku.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let mut start = start1;\n\
    \    let mut end = end1;\n    if start2 > start1 {\n        start = start2;\n\
    \    }\n    if end2 < end1 {\n        end = end2;\n    }\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    if is_prime(end - start + 1) {\n\
    \        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqx7id4tm.rs:28:8\n\
    \   |\n28 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (start, end) = if a > c {\n        (a, b)\n\
    \    } else {\n        (c, d)\n    };\n    let (start, end) = if start > end {\n\
    \        (end, start)\n    } else {\n        (start, end)\n    };\n    let (start,\
    \ end) = if start > end {\n        (end, start)\n    } else {\n        (start,\
    \ end)\n    };\n    let (start, end) = if start > end {\n        (end, start)\n\
    \    } else {\n        (start, end)\n    };\n    let (start, end) = if start >\
    \ end {\n        (end, start)\n    } else {\n        (start, end)\n    };\n  \
    \  let (start, end) = if start > end {\n        (end, start)\n    } else {\n \
    \       (start, end)\n    };\n    let (start, end) = if start > end {\n      \
    \  (end, start)\n    } else {\n        (start, end)\n    };\n    let (start, end)\
    \ = if start > end {\n        (end, start)\n    } else {\n        (start, end)\n\
    \    };\n    let (start, end) = if start > end {\n        (end, start)\n    }\
    \ else {\n        (start, end)\n    };\n    let (start, end) = if start > end\
    \ {\n        (end, start)\n    } else {\n        (start, end)\n    };\n    let\
    \ (start, end) = if start > end {\n        (end, start)\n    } else {\n      \
    \  (start, end)\n    };\n    let (start, end) = if start > end {\n        (end,\
    \ start)\n    } else {\n        (start, end)\n    };\n    let (start, end) = if\
    \ start > end {\n        (end, start)\n    } else {\n        (start, end)\n  \
    \  };\n    let (start, end) = if start > end {\n        (end, start\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpkac4kluw.rs:96:3\n\
    \   |\n14 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n82 |     let (start, end) =\
    \ if start > end {\n   |                                       - this delimiter\
    \ might not be properly closed...\n83 |         (end, start\n84 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n96 | }\n   |   ^\n\n\
    error: expected one of `.`, `;`, `?`, `else`, or an operator, found keyword `fn`\n\
    \  --> /tmp/tmpkac4kluw.rs:86:1\n   |\n84 | }\n   |  - expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n85 | \n86 | fn main() {\n   | ^^ unexpected token\n\
    \nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpkac4kluw.rs:83:9\n \
    \  |\n14 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - closing delimiter possibly meant for this\n...\n83 |\
    \         (end, start\n   |         ^ unclosed delimiter\n84 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n\
    \        if len % i == 0 {\n            return \"NO\".to_string();\n        }\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp_yceb9tn.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        \"NO\".to_string()\n    } else {\n        let start = std::cmp::max(start1,\
    \ start2);\n        let end = std::cmp::min(end1, end2);\n        let length =\
    \ end - start + 1;\n        if length == 1 {\n            \"NO\".to_string()\n\
    \        } else {\n            let mut is_prime = true;\n            for i in\
    \ 2..length {\n                if length % i == 0 {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if is_prime {\n                \"YES\".to_string()\n            } else\
    \ {\n                \"NO\".to_string()\n            }\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpm13vw7xz.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut start,\
    \ mut end) = (interval1.0, interval1.1);\n    if interval2.0 > start {\n     \
    \   start = interval2.0;\n    }\n    if interval2.1 < end {\n        end = interval2.1;\n\
    \    }\n    if start > end {\n        return \"NO\".to_string();\n    }\n    let\
    \ len = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpbft3b4tu.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start == end {\n        return \"YES\"\
    .to_string();\n    }\n    let length = end - start + 1;\n    if length == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..length {\n      \
    \  if length % i == 0 {\n            return \"NO\".to_string();\n        }\n \
    \   }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpeevxvl4q.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let length = end - start\
    \ + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n    let\
    \ mut is_prime = true;\n    for i in 2..length {\n        if length % i == 0 {\n\
    \            is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpzjqqptem.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = if start1\
    \ > start2 { start1 } else { start2 };\n    let end = if end1 < end2 { end1 }\
    \ else { end2 };\n    let len = end - start + 1;\n    if len == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpg4a_8wsb.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let start = interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    if is_prime(end - start + 1) {\n        \"YES\".to_string()\n    } else {\n\
    \        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpj1r_tmtp.rs:20:8\n\
    \   |\n20 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n    }\n    let\
    \ mut is_prime = true;\n    for i in 2..len {\n        if len % i == 0 {\n   \
    \         is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmps37qfzp3.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start\
    \ + 1) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqq3ac_hn.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut start,\
    \ mut end) = (interval1.0, interval1.1);\n    if interval1.0 > interval2.0 {\n\
    \        start = interval2.0;\n    }\n    if interval1.1 < interval2.1 {\n   \
    \     end = interval2.1;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let length = end - start + 1;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpd5w44xe9.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let mut x = c;\n    if a > x {\n        x = a;\n    }\n    let mut\
    \ y = d;\n    if b < y {\n        y = b;\n    }\n    let mut z = y - x + 1;\n\
    \    if z == 1 {\n        return \"NO\".to_string();\n    }\n    if z == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    let mut i = 2;\n    while i *\
    \ i <= z {\n        if z % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n        i += 1;\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpje80_plf.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpv8pwxpze.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    let len = end - start + 1;\n    if len < 2\
    \ {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..len {\n        if len % i == 0\
    \ {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpba3qzikc.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let mut x = c.max(a);\n    let mut y = b.min(d);\n    if x > y {\n\
    \        return \"NO\".to_string();\n    }\n    if x == y {\n        return \"\
    YES\".to_string();\n    }\n    while x <= y {\n        if x == 2 || x == 3 ||\
    \ x == 5 || x == 7 {\n            return \"YES\".to_string();\n        }\n   \
    \     if x % 2 == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n        x += 1;\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpg4e48_52.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let length = end - start + 1;\n\
    \    if length == 1 {\n        return \"NO\".to_string();\n    }\n    if length\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..length {\n\
    \        if length % i == 0 {\n            return \"NO\".to_string();\n      \
    \  }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpyj2l5pr5.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (start, end) = if a > c { (a, b) } else\
    \ { (c, d) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start >\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpq2mbz8pl.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    let len = end - start + 1;\n    if len ==\
    \ 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..len {\n        if len % i == 0\
    \ {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpag4_8q_q.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpt6btv1_d.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let mut start = start1;\n\
    \    let mut end = end1;\n    if start2 > start1 {\n        start = start2;\n\
    \    }\n    if end2 < end1 {\n        end = end2;\n    }\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    let length = end - start + 1;\n\
    \    if length == 1 {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ is_prime = true;\n    for i in 2..length {\n        if length % i == 0 {\n \
    \           is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpyefw8jmh.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let (start, end) = (c.max(a), b.min(d));\n    let len = end - start\
    \ + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n    }\n    if len\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    if len % 2 == 0 {\n\
    \        return \"NO\".to_string();\n    }\n    for i in 3..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp3xzw1gtl.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    let len = end - start + 1;\n    if len == 1\
    \ {\n        return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n\
    \    for i in 2..len {\n        if len % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpfv88aa9y.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let (mut start, mut end) = (a, b);\n    if c > a {\n        start\
    \ = c;\n    }\n    if d < b {\n        end = d;\n    }\n    let len = end - start\
    \ + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpdm22hp_y.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    let len = end - start + 1;\n    if len ==\
    \ 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..len {\n        if len % i == 0\
    \ {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpag4_8q_q.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    let length = end - start + 1;\n    if length\
    \ <= 1 {\n        return \"NO\".to_string();\n    }\n    if length == 2 {\n  \
    \      return \"YES\".to_string();\n    }\n    for i in 2..length {\n        if\
    \ length % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpm7xnotvi.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (start, end) = if a > c {\n        (a, b)\n\
    \    } else {\n        (c, d)\n    };\n    let (start, end) = if start > end {\n\
    \        (end, start)\n    } else {\n        (start, end)\n    };\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    let mut primes = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut i = 0;\n    while i < primes.len() {\n       \
    \ if primes[i] >= start && primes[i] <= end {\n            return \"YES\".to_string();\n\
    \        }\n        i += 1;\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpvaz25f95.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let len = end - start\
    \ + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n    }\n    if len\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n\
    \        if len % i == 0 {\n            return \"NO\".to_string();\n        }\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpbb_ukal1.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let (start, end) = if a > c { (a, b) } else { (c, d) };\n    let (start,\
    \ end) = if b < d { (start, b) } else { (start, d) };\n    let length = end -\
    \ start + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n\
    \    let mut is_prime = true;\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            is_prime = false;\n            break;\n        }\n    }\n\
    \    if is_prime {\n        \"YES\".to_string()\n    } else {\n        \"NO\"\
    .to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n   \
    \ assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpzke8koha.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let mut start = start1;\n\
    \    let mut end = end1;\n    if start2 > start1 {\n        start = start2;\n\
    \    }\n    if end2 < end1 {\n        end = end2;\n    }\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    if is_prime(end - start + 1) {\n\
    \        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqx7id4tm.rs:28:8\n\
    \   |\n28 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (mut start, mut end) = (0, 0);\n    if a\
    \ <= c && c <= b {\n        start = c;\n    } else if c <= a && a <= d {\n   \
    \     start = a;\n    }\n    if a <= d && d <= b {\n        end = d;\n    } else\
    \ if c <= b && b <= d {\n        end = b;\n    }\n    if start == 0 || end ==\
    \ 0 {\n        return \"NO\".to_string();\n    }\n    let len = end - start +\
    \ 1;\n    if len <= 2 {\n        return \"NO\".to_string();\n    }\n    for i\
    \ in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmpnpuc85nw.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start\
    \ + 1) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqq3ac_hn.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    if is_prime(end - start + 1) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpjt0qn4_z.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let mut start = a;\n    let mut end = b;\n    if c > a {\n       \
    \ start = c;\n    }\n    if d < b {\n        end = d;\n    }\n    let mut count\
    \ = 0;\n    for i in start..=end {\n        count += 1;\n    }\n    if is_prime(count)\
    \ {\n        return \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpsw2kbfkv.rs:32:8\n\
    \   |\n32 |     if is_prime(count) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (start, end) = (start1.max(start2),\
    \ end1.min(end2));\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp3pais_fc.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let (start, end) = (a.max(c), b.min(d));\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    if is_prime(end - start + 1) {\n\
    \        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpmcjwa7p5.rs:24:8\n\
    \   |\n24 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n  \
    \  if len == 1 {\n        return \"NO\".to_string();\n    }\n    let mut is_prime\
    \ = true;\n    for i in 2..len {\n        if len % i == 0 {\n            is_prime\
    \ = false;\n            break;\n        }\n    }\n    if is_prime {\n        return\
    \ \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp3s026wpc.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start\
    \ + 1) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqq3ac_hn.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start == end {\n\
    \        return \"YES\".to_string();\n    }\n    let mut is_prime = true;\n  \
    \  for i in 2..end {\n        if start % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp1_o42pm0.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp7uv4z7y0.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start == end {\n        return \"YES\"\
    .to_string();\n    }\n    let length = end - start + 1;\n    if length == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    if length % 2 == 0 {\n      \
    \  return \"NO\".to_string();\n    }\n    for i in 3..(length as f64).sqrt() as\
    \ isize + 1 {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpxhkdtl_d.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start\
    \ + 1) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqq3ac_hn.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    let length = end - start + 1;\n    if length\
    \ <= 1 {\n        return \"NO\".to_string();\n    }\n    if length == 2 {\n  \
    \      return \"YES\".to_string();\n    }\n    for i in 2..length {\n        if\
    \ length % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpm7xnotvi.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = if start1\
    \ > start2 { start1 } else { start2 };\n    let end = if end1 < end2 { end1 }\
    \ else { end2 };\n    let len = end - start + 1;\n    if len == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpg4a_8wsb.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp7uv4z7y0.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let length = end - start + 1;\n    if is_prime(length) {\n       \
    \ return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpphjnezja.rs:23:8\n\
    \   |\n23 |     if is_prime(length) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (start, end) = if a > c { (a, b) } else\
    \ { (c, d) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start < end { (start, end) } else { (end,\
    \ start) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start < end { (start, end) } else { (end,\
    \ start) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start < end { (start, end) } else { (end,\
    \ start) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start < end { (start, end) } else { (end,\
    \ start) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start < end { (start, end) } else { (end,\
    \ start) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start < end { (start, end) } else { (end,\
    \ start) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start < end { (start, end) } else { (end,\
    \ start) };\n    let (start, end) = if start > end { (end, start) } else { (start,\
    \ end) };\n    let (start, end) = if start < end { (start, end) } else { (end,\
    \ start) };\n    let (start, end) = if start >\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp9dmlzcx3.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp7uv4z7y0.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = if start1\
    \ > start2 { start1 } else { start2 };\n    let end = if end1 < end2 { end1 }\
    \ else { end2 };\n    let len = end - start + 1;\n    if len == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpg4a_8wsb.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start == end {\n        return \"YES\"\
    .to_string();\n    }\n    let length = end - start + 1;\n    if length == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    if length % 2 == 0 {\n      \
    \  return \"NO\".to_string();\n    }\n    for i in 3..(length as f64).sqrt() as\
    \ isize + 1 {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpxhkdtl_d.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    let length = end - start + 1;\n    if length\
    \ < 2 {\n        return \"NO\".to_string();\n    }\n    if length == 2 {\n   \
    \     return \"YES\".to_string();\n    }\n    for i in 2..length {\n        if\
    \ length % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpkpcihw93.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let (mut start, mut end) = (a, b);\n    if c > a {\n        start\
    \ = c;\n    }\n    if d < b {\n        end = d;\n    }\n    let len = end - start\
    \ + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n    }\n    if len\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n\
    \        if len % i == 0 {\n            return \"NO\".to_string();\n        }\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpyeebusq6.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805427
