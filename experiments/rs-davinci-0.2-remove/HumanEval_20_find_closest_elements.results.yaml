language: rs
name: HumanEval_20_find_closest_elements
results:
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut min_diff = numbers[1] - numbers[0];\n\
    \    let mut min_pair = (numbers[0], numbers[1]);\n    for i in 0..numbers.len()\
    \ - 1 {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            min_pair = (numbers[i], numbers[i\
    \ + 1]);\n        }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    // TODO: Implement this function\n    let mut min_diff\
    \ = numbers[1] - numbers[0];\n    let mut min_pair = (numbers[0], numbers[1]);\n\
    \    for i in 0..numbers.len()-1 {\n        for j in i+1..numbers.len() {\n  \
    \          let diff = numbers[j] - numbers[i];\n            if diff < min_diff\
    \ {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpy181ppo3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = numbers[1] - numbers[0];\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_distance = distance;\n                closest_elements = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpvkgmsdgg.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpkk4l_6ng.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n         \
    \   let distance = (numbers[j] - numbers[i]).abs();\n            if distance <\
    \ closest_distance {\n                closest_distance = distance;\n         \
    \       closest_elements = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpqddvbyma.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp1te5xmyh.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = numbers[1] - numbers[0];\n    for i in 1..numbers.len()\
    \ - 1 {\n        let distance = numbers[i + 1] - numbers[i];\n        if distance\
    \ < closest_distance {\n            closest_pair = (numbers[i], numbers[i + 1]);\n\
    \            closest_distance = distance;\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        panic!(\"Need at least\
    \ two numbers to find closest elements\");\n    }\n\n    let mut closest_elements\
    \ = (numbers[0], numbers[1]);\n    let mut closest_distance = closest_elements.1\
    \ - closest_elements.0;\n\n    for i in 0..numbers.len() {\n        for j in (i\
    \ + 1)..numbers.len() {\n            let distance = numbers[j] - numbers[i];\n\
    \            if distance < closest_distance {\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n                closest_distance = distance;\n\
    \            }\n        }\n    }\n\n    closest_elements\n}\n\nfn main() {\n \
    \   let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpf7be_mkh.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n\
    \            let distance = numbers[j] - numbers[i];\n            if distance\
    \ < closest_distance {\n                closest_distance = distance;\n       \
    \         closest_elements = (numbers[i], numbers[j]);\n            }\n      \
    \  }\n    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp_cymyn2q.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptu06r3se.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    // TODO: Implement this function\n    let mut min_diff\
    \ = numbers[1] - numbers[0];\n    let mut min_pair = (numbers[0], numbers[1]);\n\
    \    for i in 0..numbers.len() {\n        for j in i+1..numbers.len() {\n    \
    \        let diff = numbers[j] - numbers[i];\n            if diff < min_diff {\n\
    \                min_diff = diff;\n                min_pair = (numbers[i], numbers[j]);\n\
    \            }\n        }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpzn0pur5x.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxyspq91l.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpjrm4lkrv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut closest_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpa7c8altt.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpjetn027k.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp5wnl4nf0.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i+1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmprpyf_cdt.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxyspq91l.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptu06r3se.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (0.0, 0.0);\n    let mut closest_distance\
    \ = std::f64::MAX;\n\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < closest_distance {\n                closest_distance = distance;\n\
    \                closest_pair = (numbers[i], numbers[j]);\n            }\n   \
    \     }\n    }\n\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpuxl02dlc.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_diff_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_diff_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    min_diff_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpm3raof2v.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp5wnl4nf0.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptu06r3se.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut min_diff = numbers[1] - numbers[0];\n\
    \    let mut min_pair = (numbers[0], numbers[1]);\n    for i in 1..numbers.len()\
    \ - 1 {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            min_pair = (numbers[i], numbers[i\
    \ + 1]);\n        }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptu06r3se.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp5wnl4nf0.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() - 1 {\n        let current_distance = numbers[i + 1] - numbers[i];\n\
    \        if current_distance < closest_distance {\n            closest_pair =\
    \ (numbers[i], numbers[i + 1]);\n            closest_distance = current_distance;\n\
    \        }\n    }\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp6djmp4bi.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_difference = numbers[1] - numbers[0];\n\
    \    let mut closest_pair = (numbers[0], numbers[1]);\n    for i in 1..numbers.len()\
    \ - 1 {\n        let difference = numbers[i + 1] - numbers[i];\n        if difference\
    \ < closest_difference {\n            closest_difference = difference;\n     \
    \       closest_pair = (numbers[i], numbers[i + 1]);\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() - 1 {\n        let distance = numbers[i + 1] - numbers[i];\n\
    \        if distance < closest_distance {\n            closest_distance = distance;\n\
    \            closest_pair = (numbers[i], numbers[i + 1]);\n        }\n    }\n\
    \    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in (i + 1)..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpys75vwbs.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpjrm4lkrv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = closest_elements.1 - closest_elements.0;\n\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let difference = numbers[j] - numbers[i];\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpxb1ddqb4.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_diff = numbers[1] - numbers[0];\n\
    \    let mut closest_elements = (numbers[0], numbers[1]);\n    for i in 1..numbers.len()\
    \ - 1 {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < closest_diff\
    \ {\n            closest_diff = diff;\n            closest_elements = (numbers[i],\
    \ numbers[i + 1]);\n        }\n    }\n    closest_elements\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = numbers[1] - numbers[0];\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpdia38z1z.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_numbers = (numbers[0], numbers[1]);\n \
    \   let mut closest_difference = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < closest_difference {\n                closest_numbers = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n\n    closest_numbers\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpt23ekid7.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxyspq91l.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpars39dvm.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i\
    \ in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n       \
    \     let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp4a8aant7.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() - 1 {\n        let distance = numbers[i + 1] - numbers[i];\n\
    \        if distance < closest_distance {\n            closest_distance = distance;\n\
    \            closest_pair = (numbers[i], numbers[i + 1]);\n        }\n    }\n\
    \    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = closest_elements.1 - closest_elements.0;\n\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let difference = numbers[j] - numbers[i];\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpxb1ddqb4.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n \
    \           let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmps4280g03.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = numbers[1] - numbers[0];\n    let mut\
    \ min_pair = (numbers[0], numbers[1]);\n    for i in 0..numbers.len() {\n    \
    \    for j in i + 1..numbers.len() {\n            let diff = numbers[j] - numbers[i];\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpvtez57jn.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxyspq91l.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpars39dvm.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptu06r3se.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptu06r3se.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_distance = numbers[1] - numbers[0];\n\
    \    let mut closest_elements = (numbers[0], numbers[1]);\n    for i in 1..numbers.len()\
    \ - 1 {\n        let distance = numbers[i + 1] - numbers[i];\n        if distance\
    \ < closest_distance {\n            closest_distance = distance;\n           \
    \ closest_elements = (numbers[i], numbers[i + 1]);\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp5wnl4nf0.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = numbers[j] - numbers[i];\n            if diff < min_diff\
    \ {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp_1bifkuc.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut min_distance_elements\
    \ = (0.0, 0.0);\n\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             min_distance_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n\n    min_distance_elements\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpei1oku62.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i+1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmprpyf_cdt.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (0.0, 0.0);\n  \
    \  let mut closest_distance: f64 = std::f64::MAX;\n\n    for (i, n) in numbers.iter().enumerate()\
    \ {\n        for m in numbers.iter().skip(i + 1) {\n            let distance =\
    \ (n - m).abs();\n            if distance < closest_distance {\n             \
    \   closest_distance = distance;\n                closest_elements = (*n, *m);\n\
    \            }\n        }\n    }\n\n    closest_elements\n}\n\nfn main() {\n \
    \   let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpyr6uv_uu.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = numbers[1] - numbers[0];\n\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_distance = distance;\n                closest_elements = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpve920di9.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in 0..numbers.len()\
    \ {\n        for j in (i + 1)..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpuwkofr9c.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp5wnl4nf0.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut min_diff = numbers[1] - numbers[0];\n\
    \    let mut min_pair = (numbers[0], numbers[1]);\n    for i in 1..numbers.len()\
    \ - 1 {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            min_pair = (numbers[i], numbers[i\
    \ + 1]);\n        }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp5wnl4nf0.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n       \
    \     let distance = (numbers[j] - numbers[i]).abs();\n            if distance\
    \ < closest_distance {\n                closest_distance = distance;\n       \
    \         closest_elements = (numbers[i], numbers[j]);\n            }\n      \
    \  }\n    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw7uc5_41.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp6djmp4bi.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptu06r3se.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n         \
    \   let distance = (numbers[j] - numbers[i]).abs();\n            if distance <\
    \ closest_distance {\n                closest_distance = distance;\n         \
    \       closest_elements = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpqddvbyma.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n\
    \            let distance = numbers[j] - numbers[i];\n            if distance\
    \ < closest_distance {\n                closest_distance = distance;\n       \
    \         closest_elements = (numbers[i], numbers[j]);\n            }\n      \
    \  }\n    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp_cymyn2q.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp6djmp4bi.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp1te5xmyh.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxyspq91l.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpars39dvm.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut min_diff = numbers[1] - numbers[0];\n\
    \    let mut min_pair = (numbers[0], numbers[1]);\n    for i in 1..numbers.len()\
    \ - 1 {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            min_pair = (numbers[i], numbers[i\
    \ + 1]);\n        }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut min_diff = numbers[1] - numbers[0];\n\
    \    let mut min_pair = (numbers[0], numbers[1]);\n    for i in 1..numbers.len()\
    \ - 1 {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            min_pair = (numbers[i], numbers[i\
    \ + 1]);\n        }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = closest_elements.1 - closest_elements.0;\n\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let difference = numbers[j] - numbers[i];\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpxb1ddqb4.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i+1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpnz7w3g7s.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp5wnl4nf0.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest_difference = std::f64::MAX;\n    let mut\
    \ closest_elements = (0.0, 0.0);\n\n    for i in 0..numbers.len() {\n        for\
    \ j in i + 1..numbers.len() {\n            let difference = (numbers[i] - numbers[j]).abs();\n\
    \            if difference < smallest_difference {\n                smallest_difference\
    \ = difference;\n                closest_elements = (numbers[i], numbers[j]);\n\
    \            }\n        }\n    }\n\n    closest_elements\n}\n\nfn main() {\n \
    \   let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxwztxdox.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_diff_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_diff_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    min_diff_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpm3raof2v.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_diff_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_diff_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    min_diff_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpm3raof2v.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = (numbers[1] - numbers[0]).abs();\n\n    for\
    \ i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n         \
    \   let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpqxm15e1e.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in (i + 1)..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpys75vwbs.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxyspq91l.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptu06r3se.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxyspq91l.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_difference = numbers[1] - numbers[0];\n\
    \    let mut closest_elements = (numbers[0], numbers[1]);\n    for i in 1..numbers.len()\
    \ - 1 {\n        let difference = numbers[i + 1] - numbers[i];\n        if difference\
    \ < closest_difference {\n            closest_difference = difference;\n     \
    \       closest_elements = (numbers[i], numbers[i + 1]);\n        }\n    }\n \
    \   closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_diff_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_diff_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    min_diff_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpm3raof2v.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut smallest_difference = closest_elements.1 - closest_elements.0;\n\n\
    \    for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n\
    \            let difference = numbers[j] - numbers[i];\n            if difference\
    \ < smallest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                smallest_difference = difference;\n            }\n        }\n\
    \    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmphnl13t6i.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp6djmp4bi.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpjrm4lkrv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp1te5xmyh.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n         \
    \   let distance = (numbers[j] - numbers[i]).abs();\n            if distance <\
    \ closest_distance {\n                closest_distance = distance;\n         \
    \       closest_elements = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpqddvbyma.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() - 1 {\n        let distance = numbers[i + 1] - numbers[i];\n\
    \        if distance < closest_distance {\n            closest_distance = distance;\n\
    \            closest_pair = (numbers[i], numbers[i + 1]);\n        }\n    }\n\
    \    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n \
    \           let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_distance = distance;\n         \
    \       closest_elements = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpha3nymwi.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut smallest_difference = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let difference = numbers[j]\
    \ - numbers[i];\n            if difference < smallest_difference {\n         \
    \       closest_pair = (numbers[i], numbers[j]);\n                smallest_difference\
    \ = difference;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpvhxxtipi.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpu7g5bj5h.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmppne3gc8p.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptu06r3se.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i+1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpgu6r7f68.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpuryxob0s.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp5wnl4nf0.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n \
    \           let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_distance = distance;\n         \
    \       closest_elements = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpha3nymwi.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp1te5xmyh.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptu06r3se.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i+1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp3diveren.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxyspq91l.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = closest_elements.1 - closest_elements.0;\n\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let difference = numbers[j] - numbers[i];\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpxb1ddqb4.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptu06r3se.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxyspq91l.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = numbers[1] - numbers[0];\n\n    for i in 0..numbers.len()\
    \ {\n        for j in (i + 1)..numbers.len() {\n            let difference = numbers[j]\
    \ - numbers[i];\n            if difference < closest_difference {\n          \
    \      closest_elements = (numbers[i], numbers[j]);\n                closest_difference\
    \ = difference;\n            }\n        }\n    }\n\n    closest_elements\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpjpbuz0ci.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxyspq91l.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = closest_elements.1 - closest_elements.0;\n\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let difference = numbers[j] - numbers[i];\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpxb1ddqb4.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp5wnl4nf0.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             closest_elements = (numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpii6lrdew.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpuryxob0s.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpjrm4lkrv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() - 1 {\n        let distance = numbers[i + 1] - numbers[i];\n\
    \        if distance < closest_distance {\n            closest_pair = (numbers[i],\
    \ numbers[i + 1]);\n            closest_distance = distance;\n        }\n    }\n\
    \    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp1te5xmyh.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut min_diff = numbers[1] - numbers[0];\n\
    \    let mut min_pair = (numbers[0], numbers[1]);\n    for i in 1..numbers.len()\
    \ - 1 {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            min_pair = (numbers[i], numbers[i\
    \ + 1]);\n        }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpjrm4lkrv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = closest_elements.1 - closest_elements.0;\n\n\
    \    for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n\
    \            let difference = numbers[j] - numbers[i];\n            if difference\
    \ < closest_difference {\n                closest_difference = difference;\n \
    \               closest_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpsth9gwur.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = (numbers[1] - numbers[0]).abs();\n\n    for\
    \ i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n     \
    \       let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmptqiskkcl.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = numbers[1] - numbers[0];\n    for i in 0..numbers.len()\
    \ - 1 {\n        let distance = numbers[i + 1] - numbers[i];\n        if distance\
    \ < closest_distance {\n            closest_distance = distance;\n           \
    \ closest_pair = (numbers[i], numbers[i + 1]);\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut closest_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpcguptjae.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpkk4l_6ng.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for (i, a) in numbers.iter().enumerate() {\n        for b\
    \ in numbers.iter().skip(i + 1) {\n            let diff = (a - b).abs();\n   \
    \         if diff < min_diff {\n                min_diff = diff;\n           \
    \     closest_elements = (*a, *b);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpphmg2jyn.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() - 1 {\n        let distance = numbers[i + 1] - numbers[i];\n\
    \        if distance < closest_distance {\n            closest_pair = (numbers[i],\
    \ numbers[i + 1]);\n            closest_distance = distance;\n        }\n    }\n\
    \    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptu06r3se.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp5wnl4nf0.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptu06r3se.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp6djmp4bi.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    // TODO: Implement this function.\n    // Hint: You may\
    \ want to use the `sort` function.\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut closest = (numbers[0], numbers[1]);\n\
    \    let mut diff = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ - 1 {\n        if (numbers[i + 1] - numbers[i]).abs() < diff {\n           \
    \ closest = (numbers[i], numbers[i + 1]);\n            diff = (numbers[i + 1]\
    \ - numbers[i]).abs();\n        }\n    }\n    closest\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp1te5xmyh.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpjrm4lkrv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = numbers[1] - numbers[0];\n    for i in 0..numbers.len()\
    \ - 1 {\n        let distance = numbers[i + 1] - numbers[i];\n        if distance\
    \ < closest_distance {\n            closest_distance = distance;\n           \
    \ closest_pair = (numbers[i], numbers[i + 1]);\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxyspq91l.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut min_distance_elements\
    \ = (0.0, 0.0);\n\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             min_distance_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n\n    min_distance_elements\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpei1oku62.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmjjin9dv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptu06r3se.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = numbers[1] - numbers[0];\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpdia38z1z.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph_i6f7v3.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = numbers[1] - numbers[0];\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let difference = numbers[j]\
    \ - numbers[i];\n            if difference < closest_difference {\n          \
    \      closest_elements = (numbers[i], numbers[j]);\n                closest_difference\
    \ = difference;\n            }\n        }\n    }\n\n    closest_elements\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplqjovnei.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp5wnl4nf0.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = (numbers[1] - numbers[0]).abs();\n\n    for\
    \ i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n         \
    \   let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpqxm15e1e.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmppne3gc8p.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmptu06r3se.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxyspq91l.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_numbers = (numbers[0], numbers[1]);\n \
    \   let mut closest_difference = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < closest_difference {\n                closest_numbers = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n\n    closest_numbers\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpt23ekid7.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n\n    for i in 0..numbers.len()\
    \ {\n        for j in (i + 1)..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpys75vwbs.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748797
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i+1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxgb8vd1j.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i+1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxgb8vd1j.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748798
