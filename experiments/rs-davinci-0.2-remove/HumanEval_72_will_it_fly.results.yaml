language: rs
name: HumanEval_72_will_it_fly
results:
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut q_rev = q.clone();\n  \
    \  q_rev.reverse();\n    if q == q_rev && q.iter().sum::<isize>() <= w {\n   \
    \     true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        if q == q.iter().rev().cloned().collect::<Vec<isize>>()\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let is_palindrome\
    \ = q.iter().rev().eq(q.iter());\n    sum <= w && is_palindrome\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    if q == q_rev {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum > w {\n        return\
    \ false;\n    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n    if\
    \ q == q_rev {\n        return true;\n    }\n    return false;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpsu_g2tb4.rs:20:21\n\
    \    |\n11  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n14  |\
    \     for i in q {\n    |              -\n    |              |\n    |        \
    \      `q` moved due to this implicit call to `.into_iter()`\n    |          \
    \    help: consider borrowing to avoid moving into the for loop: `&q`\n...\n20\
    \  |     let mut q_rev = q.clone();\n    |                     ^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `q`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749353
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let mut q_rev\
    \ = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        if q ==\
    \ q.iter().rev().collect::<Vec<_>>() {\n            return true;\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpmi5b1hpd.rs:18:14\n\
    \   |\n18 |         if q == q.iter().rev().collect::<Vec<_>>() {\n   |       \
    \       ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait\
    \ `PartialEq<&isize>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749353
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    let mut q_rev\
    \ = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        if q == q.iter().rev().collect::<Vec<&isize>>()\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpqc7g5yqp.rs:16:14\n\
    \   |\n16 |         if q == q.iter().rev().collect::<Vec<&isize>>() {\n   |  \
    \            ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749353
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut sum = 0;\n    while !q.is_empty()\
    \ {\n        sum += q.pop().unwrap();\n        if sum > w {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_3yhtukx.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        return true;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa_k48hmz.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        return true;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa_k48hmz.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        if q == q.iter().rev().collect::<Vec<&isize>>()\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpqc7g5yqp.rs:16:14\n\
    \   |\n16 |         if q == q.iter().rev().collect::<Vec<&isize>>() {\n   |  \
    \            ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749353
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    if q == q_rev {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    if sum > w\
    \ {\n        return false;\n    }\n    let mut q = q.clone();\n    q.reverse();\n\
    \    q == q\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_3l54rrn.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n  \
    \      q_rev.reverse();\n        if q == q_rev {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum > w {\n        return\
    \ false;\n    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n    q ==\
    \ q_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpis7ouoz2.rs:20:21\n\
    \    |\n11  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n14  |\
    \     for i in q {\n    |              -\n    |              |\n    |        \
    \      `q` moved due to this implicit call to `.into_iter()`\n    |          \
    \    help: consider borrowing to avoid moving into the for loop: `&q`\n...\n20\
    \  |     let mut q_rev = q.clone();\n    |                     ^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `q`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749353
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n  \
    \      q_rev.reverse();\n        if q == q_rev {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        q == q_rev\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmphg2lgete.rs:18:25\n\
    \    |\n11  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n14  |\
    \     for i in q {\n    |              -\n    |              |\n    |        \
    \      `q` moved due to this implicit call to `.into_iter()`\n    |          \
    \    help: consider borrowing to avoid moving into the for loop: `&q`\n...\n18\
    \  |         let mut q_rev = q.clone();\n    |                         ^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `q`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749353
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut q = q;\n    while !q.is_empty()\
    \ {\n        sum += q.pop().unwrap();\n        if sum > w {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqknj_5w4.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut q_rev = q.clone();\n  \
    \  q_rev.reverse();\n    if q == q_rev && q.iter().sum::<isize>() <= w {\n   \
    \     true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n  \
    \      q_rev.reverse();\n        if q == q_rev {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.reverse();\n \
    \   let mut sum = 0;\n    for i in q {\n        sum += i;\n        if sum > w\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9w22jlcz.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.reverse();\n \
    \   let mut sum = 0;\n    for i in q {\n        sum += i;\n        if sum > w\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9w22jlcz.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 {\n        return true;\n    }\n  \
    \  let mut sum = 0;\n    for i in q.iter() {\n        sum += i;\n    }\n    if\
    \ sum > w {\n        return false;\n    }\n    let mut left = 0;\n    let mut\
    \ right = q.len() - 1;\n    while left < right {\n        if q[left] != q[right]\
    \ {\n            return false;\n        }\n        left += 1;\n        right -=\
    \ 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut sum = 0;\n    while !q.is_empty()\
    \ {\n        sum += q.pop().unwrap();\n        if sum > w {\n            return\
    \ false;\n        }\n    }\n    sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptr4arl7c.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut w = w;\n    let mut i =\
    \ 0;\n    let mut j = q.len() - 1;\n    let mut sum = 0;\n    while i < j {\n\
    \        if q[i] != q[j] {\n            return false;\n        }\n        i +=\
    \ 1;\n        j -= 1;\n    }\n    for i in q {\n        sum += i;\n    }\n   \
    \ if sum <= w {\n        return true;\n    }\n    false\n}\n\nfn main() {\n  \
    \  let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        if q == q.iter().rev().collect::<Vec<&isize>>()\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpqc7g5yqp.rs:16:14\n\
    \   |\n16 |         if q == q.iter().rev().collect::<Vec<&isize>>() {\n   |  \
    \            ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749353
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        if q == q.iter().rev().collect::<Vec<&isize>>()\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpqc7g5yqp.rs:16:14\n\
    \   |\n16 |         if q == q.iter().rev().collect::<Vec<&isize>>() {\n   |  \
    \            ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749353
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut sum = 0;\n    while q.len()\
    \ > 1 {\n        let first = q.remove(0);\n        let last = q.pop().unwrap();\n\
    \        if first != last {\n            return false;\n        }\n        sum\
    \ += first + last;\n    }\n    if q.len() == 1 {\n        sum += q[0];\n    }\n\
    \    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n  \
    \      q_rev.reverse();\n        if q == q_rev {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n  \
    \      q_rev.reverse();\n        if q == q_rev {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut sum = 0;\n    for i in\
    \ q.iter() {\n        sum += i;\n    }\n    if sum > w {\n        return false;\n\
    \    }\n    q.reverse();\n    q == q\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpt8lnv2gz.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in &q {\n        sum +=\
    \ i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut q_rev\
    \ = q.clone();\n    q_rev.reverse();\n    q == q_rev\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        return true;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa_k48hmz.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        if q == q.iter().rev().cloned().collect::<Vec<isize>>()\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut sum = 0;\n    while !q.is_empty()\
    \ {\n        sum += q.pop().unwrap();\n        if sum > w {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjogc780l.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n  \
    \      q_rev.reverse();\n        if q == q_rev {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut q_rev = q.clone();\n\
    \    q_rev.reverse();\n    for (x, y) in q.iter().zip(q_rev.iter()) {\n      \
    \  if x != y {\n            return false;\n        }\n        sum += x;\n    }\n\
    \    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut palindrome = true;\n  \
    \      for i in 0..q.len()/2 {\n            if q[i] != q[q.len()-1-i] {\n    \
    \            palindrome = false;\n            }\n        }\n        return palindrome;\n\
    \    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let mut q_rev\
    \ = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmps3nzb7qb.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8q4j4iq2.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        if q == q_rev {\n    \
    \        return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpr1ty1_e6.rs:18:25\n\
    \    |\n11  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n14  |\
    \     for i in q {\n    |              -\n    |              |\n    |        \
    \      `q` moved due to this implicit call to `.into_iter()`\n    |          \
    \    help: consider borrowing to avoid moving into the for loop: `&q`\n...\n18\
    \  |         let mut q_rev = q.clone();\n    |                         ^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `q`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut sum = 0;\n    while !q.is_empty()\
    \ {\n        sum += q.pop().unwrap();\n        if !q.is_empty() {\n          \
    \  sum += q.remove(0);\n        }\n    }\n    sum <= w && q.is_empty()\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcwtn1fc8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut q_rev = q.clone();\n  \
    \  q_rev.reverse();\n    q == q_rev && q.iter().sum::<isize>() <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut left = 0;\n    let mut right = q.len() - 1;\n    while left < right\
    \ {\n        if q[left] != q[right] {\n            return false;\n        }\n\
    \        left += 1;\n        right -= 1;\n    }\n    sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl6uc314a.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut sum = 0;\n    let mut is_palindrome\
    \ = true;\n    while !q.is_empty() {\n        sum += q.pop().unwrap();\n     \
    \   if !q.is_empty() {\n            sum += q.remove(0);\n        }\n        if\
    \ q.len() > 1 && q[0] != q[q.len() - 1] {\n            is_palindrome = false;\n\
    \        }\n    }\n    sum <= w && is_palindrome\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpw43elesi.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in &q {\n        sum +=\
    \ i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut q_rev\
    \ = q.clone();\n    q_rev.reverse();\n    q == q_rev\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    if q == q_rev {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut q_rev = q.clone();\n\
    \    q_rev.reverse();\n    for i in 0..q.len() {\n        if q[i] != q_rev[i]\
    \ {\n            return false;\n        }\n        sum += q[i];\n    }\n    sum\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut rev = q.clone();\n    \
    \    rev.reverse();\n        if rev == q {\n            return true;\n       \
    \ }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n  \
    \      q_rev.reverse();\n        if q == q_rev {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n  \
    \      q_rev.reverse();\n        if q == q_rev {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut q_copy = q.clone();\n\
    \    q_copy.reverse();\n    for i in 0..q.len() {\n        if q[i] != q_copy[i]\
    \ {\n            return false;\n        }\n        sum += q[i];\n    }\n    if\
    \ sum <= w {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        if q == q.iter().rev().collect::<Vec<&isize>>()\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpqc7g5yqp.rs:16:14\n\
    \   |\n16 |         if q == q.iter().rev().collect::<Vec<&isize>>() {\n   |  \
    \            ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749353
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().fold(0,\
    \ |acc, x| acc + x) <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp1n2l2juc.rs:13:50\n\
    \   |\n13 |     q.iter().fold(0, |acc, x| acc + x) <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                                  ^^ no implementation for\
    \ `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ palindrome = true;\n    for i in 0..q.len() / 2 {\n        if q[i] != q[q.len()\
    \ - 1 - i] {\n            palindrome = false;\n            break;\n        }\n\
    \    }\n    return palindrome;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    let mut q_rev\
    \ = q.clone();\n    q_rev.reverse();\n    q == q_rev && sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in 0..q.len() {\n        sum += q[i];\n        if sum > w {\n     \
    \       return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpf32g151r.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut i = 0;\n        let mut\
    \ j = q.len() - 1;\n        while i < j {\n            if q[i] != q[j] {\n   \
    \             return false;\n            }\n            i += 1;\n            j\
    \ -= 1;\n        }\n        return true;\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut rev = q.clone();\n    \
    \    rev.reverse();\n        if rev == q {\n            return true;\n       \
    \ }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut q_rev = q.clone();\n\
    \    q_rev.reverse();\n    for i in 0..q.len() {\n        sum += q[i];\n     \
    \   if sum > w {\n            return false;\n        }\n        if q[i] != q_rev[i]\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut reverse = q.clone();\n\
    \        reverse.reverse();\n        if q == reverse {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        return true;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa_k48hmz.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmps3nzb7qb.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_copy = q.clone();\n \
    \       q_copy.reverse();\n        if q_copy == q {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let mut q_rev\
    \ = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in 0..q.len() {\n        sum += q[i];\n        if sum > w {\n     \
    \       return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpf32g151r.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        if q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpn_sqes8w.rs:16:14\n\
    \   |\n16 |         if q == q.iter().rev().collect::<Vec<_>>() {\n   |       \
    \       ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait\
    \ `PartialEq<&isize>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut q_rev = q.clone();\n\
    \    q_rev.reverse();\n    for i in 0..q.len() {\n        sum += q[i];\n     \
    \   if sum > w {\n            return false;\n        }\n        if q[i] != q_rev[i]\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    if q == q_rev {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n  \
    \      q_rev.reverse();\n        q == q_rev\n    } else {\n        false\n   \
    \ }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum > w {\n        return\
    \ false;\n    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n    q ==\
    \ q_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpis7ouoz2.rs:20:21\n\
    \    |\n11  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n14  |\
    \     for i in q {\n    |              -\n    |              |\n    |        \
    \      `q` moved due to this implicit call to `.into_iter()`\n    |          \
    \    help: consider borrowing to avoid moving into the for loop: `&q`\n...\n20\
    \  |     let mut q_rev = q.clone();\n    |                     ^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `q`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749353
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut sum = 0;\n    while !q.is_empty()\
    \ {\n        sum += q.pop().unwrap();\n        if sum > w {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_3yhtukx.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n  \
    \      q_rev.reverse();\n        if q == q_rev {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let sum: isize =\
    \ q.iter().sum();\n    let mut i = 0;\n    let mut j = q.len() - 1;\n    while\
    \ i < j {\n        if q[i] != q[j] {\n            return false;\n        }\n \
    \       i += 1;\n        j -= 1;\n    }\n    return sum <= w;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4nz31sa3.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum > w {\n        return\
    \ false;\n    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n    q ==\
    \ q_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpis7ouoz2.rs:20:21\n\
    \    |\n11  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n14  |\
    \     for i in q {\n    |              -\n    |              |\n    |        \
    \      `q` moved due to this implicit call to `.into_iter()`\n    |          \
    \    help: consider borrowing to avoid moving into the for loop: `&q`\n...\n20\
    \  |     let mut q_rev = q.clone();\n    |                     ^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `q`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749353
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut sum = 0;\n    for i in\
    \ q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut q_rev\
    \ = q.clone();\n        q_rev.reverse();\n        if q == q_rev {\n          \
    \  return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut sum = 0;\n    for i in\
    \ q.iter() {\n        sum += i;\n    }\n    if sum > w {\n        return false;\n\
    \    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n    if q == q_rev\
    \ {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum > w {\n        return\
    \ false;\n    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n    q ==\
    \ q_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpis7ouoz2.rs:20:21\n\
    \    |\n11  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n14  |\
    \     for i in q {\n    |              -\n    |              |\n    |        \
    \      `q` moved due to this implicit call to `.into_iter()`\n    |          \
    \    help: consider borrowing to avoid moving into the for loop: `&q`\n...\n20\
    \  |     let mut q_rev = q.clone();\n    |                     ^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `q`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749353
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    if q == q_rev {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let sum: isize =\
    \ q.iter().sum();\n    let mut left = 0;\n    let mut right = q.len() - 1;\n \
    \   while left < right {\n        if q[left] != q[right] {\n            return\
    \ false;\n        }\n        left += 1;\n        right -= 1;\n    }\n    sum <=\
    \ w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3icu2bjg.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().fold(0,\
    \ |acc, x| acc + x) <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp1n2l2juc.rs:13:50\n\
    \   |\n13 |     q.iter().fold(0, |acc, x| acc + x) <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                                  ^^ no implementation for\
    \ `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n  \
    \      q_rev.reverse();\n        if q == q_rev {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum > w {\n        return\
    \ false;\n    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n    if\
    \ q == q_rev {\n        return true;\n    }\n    return false;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpsu_g2tb4.rs:20:21\n\
    \    |\n11  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n14  |\
    \     for i in q {\n    |              -\n    |              |\n    |        \
    \      `q` moved due to this implicit call to `.into_iter()`\n    |          \
    \    help: consider borrowing to avoid moving into the for loop: `&q`\n...\n20\
    \  |     let mut q_rev = q.clone();\n    |                     ^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `q`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749353
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut sum = 0;\n    let mut i\
    \ = 0;\n    let mut j = q.len() - 1;\n    while i < j {\n        sum += q[i] +\
    \ q[j];\n        if sum > w {\n            return false;\n        }\n        i\
    \ += 1;\n        j -= 1;\n    }\n    if i == j {\n        sum += q[i];\n    }\n\
    \    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgmdd5nzu.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let sum: isize =\
    \ q.iter().sum();\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl79rcvmr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749355
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut q_rev = q.clone();\n  \
    \  q_rev.reverse();\n    q == q_rev && q.iter().sum::<isize>() <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut q_rev = q.clone();\n\
    \    q_rev.reverse();\n    for i in 0..q.len() {\n        sum += q[i];\n     \
    \   if sum > w {\n            return false;\n        }\n        if q[i] != q_rev[i]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749355
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        if q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpn_sqes8w.rs:16:14\n\
    \   |\n16 |         if q == q.iter().rev().collect::<Vec<_>>() {\n   |       \
    \       ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait\
    \ `PartialEq<&isize>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n  \
    \      q_rev.reverse();\n        q_rev == q\n    } else {\n        false\n   \
    \ }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749355
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    if q == q_rev {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    if q == q_rev {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n  \
    \      q_rev.reverse();\n        if q == q_rev {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    if q == q_rev {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q2 = q.clone();\n        q2.reverse();\n        if q == q2 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpmqhth5eu.rs:18:22\n\
    \    |\n11  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n14  |\
    \     for i in q {\n    |              -\n    |              |\n    |        \
    \      `q` moved due to this implicit call to `.into_iter()`\n    |          \
    \    help: consider borrowing to avoid moving into the for loop: `&q`\n...\n18\
    \  |         let mut q2 = q.clone();\n    |                      ^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `q`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let mut q_rev\
    \ = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut w = w;\n    let mut sum\
    \ = 0;\n    let mut balanced = true;\n    while !q.is_empty() {\n        let x\
    \ = q.pop().unwrap();\n        if sum + x > w {\n            return false;\n \
    \       }\n        sum += x;\n        if !q.is_empty() {\n            let y =\
    \ q.pop().unwrap();\n            if sum + y > w {\n                return false;\n\
    \            }\n            sum += y;\n            if x != y {\n             \
    \   balanced = false;\n            }\n        }\n    }\n    balanced\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmporfw0smb.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749355
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut q_rev = q.clone();\n\
    \    q_rev.reverse();\n    for i in 0..q.len() {\n        sum += q[i];\n     \
    \   if sum > w {\n            return false;\n        }\n        if q[i] != q_rev[i]\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut w = w;\n    let mut sum\
    \ = 0;\n    while !q.is_empty() {\n        let mut i = 0;\n        let mut j =\
    \ q.len() - 1;\n        while i < j {\n            if q[i] != q[j] {\n       \
    \         return false;\n            }\n            i += 1;\n            j -=\
    \ 1;\n        }\n        sum += q.pop().unwrap();\n        if sum > w {\n    \
    \        return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvcar6gde.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749355
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum();\n    let mut q_rev = q.clone();\n\
    \    q_rev.reverse();\n    sum <= w && q == q_rev\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpo78ervrq.rs:11:9\n\
    \   |\n11 |     let sum = q.iter().sum();\n   |         ^^^ consider giving `sum`\
    \ a type\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut sum = 0;\n    while !q.is_empty()\
    \ {\n        sum += q.pop().unwrap();\n        if sum > w {\n            return\
    \ false;\n        }\n    }\n    sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptr4arl7c.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        return true;\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfihgo9v8.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749355
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n  \
    \      q_rev.reverse();\n        if q == q_rev {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().fold(0,\
    \ |acc, x| acc + x) <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp1n2l2juc.rs:13:50\n\
    \   |\n13 |     q.iter().fold(0, |acc, x| acc + x) <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                                  ^^ no implementation for\
    \ `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut q_rev = q.clone();\n\
    \    q_rev.reverse();\n    for i in 0..q.len() {\n        sum += q[i];\n     \
    \   if sum > w {\n            return false;\n        }\n        if q[i] != q_rev[i]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749355
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_copy = q.clone();\n \
    \       q_copy.reverse();\n        if q_copy == q {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        if q == q_rev {\n    \
    \        return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpr1ty1_e6.rs:18:25\n\
    \    |\n11  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n14  |\
    \     for i in q {\n    |              -\n    |              |\n    |        \
    \      `q` moved due to this implicit call to `.into_iter()`\n    |          \
    \    help: consider borrowing to avoid moving into the for loop: `&q`\n...\n18\
    \  |         let mut q_rev = q.clone();\n    |                         ^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `q`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut left = 0;\n    let mut right = q.len() - 1;\n    while left < right\
    \ {\n        if q[left] != q[right] {\n            return false;\n        }\n\
    \        left += 1;\n        right -= 1;\n    }\n    sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl6uc314a.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut sum = 0;\n    while !q.is_empty()\
    \ {\n        sum += q.pop().unwrap();\n        if sum > w {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_3yhtukx.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let sum: isize =\
    \ q.iter().sum();\n    let mut i = 0;\n    let mut j = q.len() - 1;\n    while\
    \ i < j {\n        if q[i] != q[j] {\n            return false;\n        }\n \
    \       i += 1;\n        j -= 1;\n    }\n    sum <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp96tyz837.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749355
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum > w {\n        return\
    \ false;\n    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n    q ==\
    \ q_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpis7ouoz2.rs:20:21\n\
    \    |\n11  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n14  |\
    \     for i in q {\n    |              -\n    |              |\n    |        \
    \      `q` moved due to this implicit call to `.into_iter()`\n    |          \
    \    help: consider borrowing to avoid moving into the for loop: `&q`\n...\n20\
    \  |     let mut q_rev = q.clone();\n    |                     ^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `q`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749353
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut q_rev = q.clone();\n  \
    \  q_rev.reverse();\n    if q == q_rev && q.iter().sum::<isize>() <= w {\n   \
    \     true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ reverse = q.clone();\n    reverse.reverse();\n    if q == reverse {\n      \
    \  return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749355
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy58nfr1u.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749355
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.reverse();\n \
    \   let mut sum = 0;\n    for i in q {\n        sum += i;\n        if sum > w\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9w22jlcz.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n  \
    \      q_rev.reverse();\n        if q == q_rev {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut sum = 0;\n    let mut balanced\
    \ = true;\n    while !q.is_empty() {\n        let first = q.remove(0);\n     \
    \   let last = q.pop();\n        match last {\n            Some(last) => {\n \
    \               sum += first + last;\n                if first != last {\n   \
    \                 balanced = false;\n                }\n            }\n      \
    \      None => {\n                sum += first;\n            }\n        }\n  \
    \  }\n    balanced && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749355
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut q_rev = q.clone();\n  \
    \  q_rev.reverse();\n    q == q_rev && q.iter().sum::<isize>() <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfg2jvgiw.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut w = w;\n    let mut sum\
    \ = 0;\n    while !q.is_empty() {\n        if q.len() == 1 {\n            sum\
    \ += q.pop().unwrap();\n            break;\n        }\n        let a = q.pop().unwrap();\n\
    \        let b = q.pop().unwrap();\n        if a != b {\n            return false;\n\
    \        }\n        sum += a + b;\n    }\n    sum <= w\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxcyyq53z.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749355
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplgg79zmt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut q_rev = q.clone();\n  \
    \  q_rev.reverse();\n    q == q_rev && q.iter().sum::<isize>() <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in 0..q.len() {\n        sum += q[i];\n        if sum > w {\n     \
    \       return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpf32g151r.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ajop7wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749354
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut sum = 0;\n\
    \    for i in q {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy58nfr1u.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749355
