language: rs
name: HumanEval_18_how_many_times
results:
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    while\
    \ start < string.len() {\n        let index = string[start..].find(&substring);\n\
    \        if index.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        start += index.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp7tm9nfyr.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let pos = string[index..].find(&substring);\n\
    \        if pos.is_none() {\n            break;\n        }\n        count += 1;\n\
    \        index += pos.unwrap() + substring.len();\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpkgkxlijs.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_len = substring.len();\n    let string_len\
    \ = string.len();\n    while index < string_len {\n        let found = string.find(&substring);\n\
    \        match found {\n            Some(pos) => {\n                count += 1;\n\
    \                index = pos + substring_len;\n                string = string[index..].to_string();\n\
    \            }\n            None => {\n                break;\n            }\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3tjcn6xf.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let found =\
    \ string.find(&substring);\n        if found.is_none() {\n            break;\n\
    \        }\n        let found = found.unwrap();\n        count += 1;\n       \
    \ string = string.split_off(found + substring.len());\n        index += found\
    \ + substring.len();\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpx3hv5rtw.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index != -1 {\n        index = string.find(&substring).unwrap_or(-1);\n\
    \        if index != -1 {\n            count += 1;\n            string = string[index\
    \ + substring.len()..].to_string();\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n --> /tmp/tmpp9jq9qqp.rs:7:51\n\
    \  |\n7 |         index = string.find(&substring).unwrap_or(-1);\n  |        \
    \                                           ^^\n  |                          \
    \                         |\n  |                                             \
    \      cannot apply unary operator `-`\n  |                                  \
    \                 help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \  |\n  = note: unsigned values cannot be negated\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n --> /tmp/tmpp9jq9qqp.rs:6:20\n  |\n6 |     while\
    \ index != -1 {\n  |                    ^^ the trait `Neg` is not implemented\
    \ for `usize`\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \ --> /tmp/tmpp9jq9qqp.rs:8:21\n  |\n8 |         if index != -1 {\n  |       \
    \              ^^\n  |                     |\n  |                     cannot apply\
    \ unary operator `-`\n  |                     help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n  |\n  = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_len = substring.len();\n    while index\
    \ < string.len() {\n        if string.starts_with(&substring) {\n            count\
    \ += 1;\n            string = string[substring_len..].to_string();\n        }\
    \ else {\n            string = string[1..].to_string();\n        }\n        index\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp87i8b_e3.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        if let Some(i) = string[index..].find(&substring)\
    \ {\n            count += 1;\n            index += i + substring.len();\n    \
    \    } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl78jot_2.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut last_index = 0;\n    while index != -1 {\n        index = string[last_index..].find(&substring).unwrap_or(-1);\n\
    \        if index != -1 {\n            count += 1;\n            last_index = index\
    \ + 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n --> /tmp/tmpjlsy0awl.rs:7:65\n\
    \  |\n7 |         index = string[last_index..].find(&substring).unwrap_or(-1);\n\
    \  |                                                                 ^^\n  | \
    \                                                                |\n  |      \
    \                                                           cannot apply unary\
    \ operator `-`\n  |                                                          \
    \       help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \  |\n  = note: unsigned values cannot be negated\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n --> /tmp/tmpjlsy0awl.rs:6:20\n  |\n6 |     while\
    \ index != -1 {\n  |                    ^^ the trait `Neg` is not implemented\
    \ for `usize`\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \ --> /tmp/tmpjlsy0awl.rs:8:21\n  |\n8 |         if index != -1 {\n  |       \
    \              ^^\n  |                     |\n  |                     cannot apply\
    \ unary operator `-`\n  |                     help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n  |\n  = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        let index_of_substring = index_of_substring.unwrap();\n\
    \        count += 1;\n        index += index_of_substring + substring.len();\n\
    \        string = string[index_of_substring + substring.len()..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpd7gp8up8.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut substring_char = substring_chars.next();\n    let mut string_char\
    \ = string_chars.next();\n    while string_char != None {\n        if string_char\
    \ == substring_char {\n            index += 1;\n            substring_char = substring_chars.next();\n\
    \            if substring_char == None {\n                count += 1;\n      \
    \          substring_char = substring_chars.next();\n                index = 0;\n\
    \            }\n        } else {\n            substring_char = substring.chars().nth(index);\n\
    \            index = 0;\n        }\n        string_char = string_chars.next();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for i in 0..substring.len()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if substring.chars().nth(i).unwrap() != string.chars().nth(index\
    \ + i).unwrap() {\n                break;\n            }\n            if i ==\
    \ substring.len() - 1 {\n                found = true;\n            }\n      \
    \  }\n        if found {\n            count += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpbx4nhhax.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let mut substring = substring;\n    while index <\
    \ string.len() {\n        if string.starts_with(&substring) {\n            count\
    \ += 1;\n            string = string.chars().skip(substring.len()).collect();\n\
    \        } else {\n            string = string.chars().skip(1).collect();\n  \
    \      }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpzxxv3np1.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while let Some(i) = string.find(&substring) {\n  \
    \      count += 1;\n        index += i + 1;\n        string = string[index..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    /tmp/tmpow_x2n6y.rs:9:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let mut index_substring\
    \ = string.find(&substring);\n        if index_substring.is_none() {\n       \
    \     break;\n        }\n        index_substring = index_substring.unwrap();\n\
    \        count += 1;\n        string = string.split_off(index_substring + substring.len());\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprxqc9lvu.rs:11:27\n   |\n\
    11 |         index_substring = index_substring.unwrap();\n   |               \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\n   |                           |\n   |\
    \                           expected enum `Option`, found `usize`\n   |      \
    \                     help: try using a variant of the expected enum: `Some(index_substring.unwrap())`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    \nerror[E0369]: cannot add `usize` to `Option<usize>`\n  --> /tmp/tmprxqc9lvu.rs:13:51\n\
    \   |\n13 |         string = string.split_off(index_substring + substring.len());\n\
    \   |                                   --------------- ^ --------------- usize\n\
    \   |                                   |\n   |                              \
    \     Option<usize>\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0369.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let sub_index = string[index..].find(&substring);\n\
    \        if sub_index.is_none() {\n            break;\n        }\n        count\
    \ += 1;\n        index += sub_index.unwrap() + substring.len();\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpdr5c6auw.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_len = substring.len();\n    while index\
    \ < string.len() {\n        if string.starts_with(&substring) {\n            count\
    \ += 1;\n            string = string[substring_len..].to_string();\n        }\
    \ else {\n            string = string[1..].to_string();\n        }\n        index\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp87i8b_e3.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for i in 0..substring.len()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if substring.chars().nth(i).unwrap() != string.chars().nth(index\
    \ + i).unwrap() {\n                break;\n            }\n            if i ==\
    \ substring.len() - 1 {\n                found = true;\n            }\n      \
    \  }\n        if found {\n            count += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpbx4nhhax.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_len = substring.len();\n    while index\
    \ < string.len() {\n        let index_opt = string.find(&substring);\n       \
    \ match index_opt {\n            Some(index) => {\n                count += 1;\n\
    \                string = string[index + substring_len..].to_string();\n     \
    \       }\n            None => {\n                break;\n            }\n    \
    \    }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpik83on9r.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let found =\
    \ string.find(&substring);\n        if found.is_none() {\n            break;\n\
    \        }\n        let found = found.unwrap();\n        count += 1;\n       \
    \ string = string.split_off(found + substring.len());\n        index += found\
    \ + substring.len();\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpx3hv5rtw.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut found = false;\n    while end <= string.len()\
    \ {\n        let sub = &string[start..end];\n        if sub == substring {\n \
    \           count += 1;\n            found = true;\n        }\n        start +=\
    \ 1;\n        end += 1;\n    }\n    if found {\n        count\n    } else {\n\
    \        -1\n    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `0`', /tmp/tmpk_mwdd4h.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut found = false;\n    while end <= string.len()\
    \ {\n        let sub = &string[start..end];\n        if sub == substring {\n \
    \           count += 1;\n            start += 1;\n            end += 1;\n    \
    \        found = true;\n        } else {\n            if found {\n           \
    \     start += 1;\n                end += 1;\n            } else {\n         \
    \       start += 1;\n                end += 1;\n            }\n        }\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let mut found\
    \ = false;\n        for i in 0..substring.len() {\n            if string.chars().nth(index\
    \ + i) == substring.chars().nth(i) {\n                found = true;\n        \
    \    } else {\n                found = false;\n                break;\n      \
    \      }\n        }\n        if found {\n            count += 1;\n           \
    \ string = string.replace_range(index..index + substring.len(), \"\");\n     \
    \   } else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkm2x0dg6.rs:18:22\n   |\n\
    18 |             string = string.replace_range(index..index + substring.len(),\
    \ \"\");\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `replace_range` modifies\
    \ its receiver in-place\n  --> /tmp/tmpkm2x0dg6.rs:18:29\n   |\n18 |         \
    \    string = string.replace_range(index..index + substring.len(), \"\");\n  \
    \ |                      ------ ^^^^^^^^^^^^^ this call modifies `string` in-place\n\
    \   |                      |\n   |                      you probably want to use\
    \ this value after calling the method...\n   = note: ...instead of the `()` output\
    \ of method `replace_range`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_len = substring.len();\n    while let\
    \ Some(i) = string.find(&substring) {\n        count += 1;\n        index += i\
    \ + substring_len;\n        string = string[index..].to_string();\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    /tmp/tmpf8r20o68.rs:10:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        if &string[index..index + substring.len()] ==\
    \ substring {\n            count += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    /tmp/tmpf16heey7.rs:6:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for (i, c) in\
    \ substring.chars().enumerate() {\n            if index + i >= string.len() {\n\
    \                break;\n            }\n            if string.chars().nth(index\
    \ + i).unwrap() == c {\n                found = true;\n            } else {\n\
    \                found = false;\n                break;\n            }\n     \
    \   }\n        if found {\n            count += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpl8dgr6sl.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        count += 1;\n        let index_of_substring\
    \ = index_of_substring.unwrap();\n        index += index_of_substring + substring.len();\n\
    \        string = string[index_of_substring + substring.len()..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpzvqiszoz.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while let Some(i) = string.find(&substring) {\n  \
    \      count += 1;\n        index += i;\n        string = string[(index + substring.len())..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 3 is out of bounds of `x`'', /tmp/tmpeeypfwvn.rs:9:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748176
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut last_index = 0;\n  \
    \  let mut index = string.find(&substring);\n    while index.is_some() {\n   \
    \     count += 1;\n        last_index = index.unwrap() + 1;\n        index = string[last_index..].find(&substring);\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659748181
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while let Some(i) = string.find(&substring) {\n  \
    \      count += 1;\n        index += i + 1;\n        string = string[index..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    /tmp/tmpow_x2n6y.rs:9:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for i in 0..substring.len()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if string.chars().nth(index + i).unwrap() != substring.chars().nth(i).unwrap()\
    \ {\n                break;\n            }\n            if i == substring.len()\
    \ - 1 {\n                found = true;\n            }\n        }\n        if found\
    \ {\n            count += 1;\n            index += substring.len();\n        }\
    \ else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpygxclf7u.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for (i, c) in\
    \ substring.chars().enumerate() {\n            if index + i < string.len() &&\
    \ string.chars().nth(index + i).unwrap() == c {\n                found = true;\n\
    \            } else {\n                found = false;\n                break;\n\
    \            }\n        }\n        if found {\n            count += 1;\n     \
    \       index += substring.len();\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpfjlxg87x.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut string_chars = string.chars();\n   \
    \ let mut substring_chars = substring.chars();\n    let mut string_chars_iter\
    \ = string_chars.by_ref();\n    let mut substring_chars_iter = substring_chars.by_ref();\n\
    \    let mut string_chars_iter_clone = string_chars_iter.clone();\n    let mut\
    \ substring_chars_iter_clone = substring_chars_iter.clone();\n    let mut string_chars_iter_clone_clone\
    \ = string_chars_iter_clone.clone();\n    let mut substring_chars_iter_clone_clone\
    \ = substring_chars_iter_clone.clone();\n    let mut string_chars_iter_clone_clone_clone\
    \ = string_chars_iter_clone_clone.clone();\n    let mut substring_chars_iter_clone_clone_clone\
    \ = substring_chars_iter_clone_clone.clone();\n    let mut string_chars_iter_clone_clone_clone_clone\
    \ = string_chars_iter_clone_clone_clone.clone();\n    let mut substring_chars_iter_clone_clone_clone_clone\
    \ = substring_chars_iter_clone_clone_clone.clone();\n    let mut string_chars_iter_clone_clone_clone_clone_clone\
    \ = string_chars_iter_clone_clone_clone_clone.clone();\n    let mut substring_chars_iter_clone_clone_clone_clone_clone\
    \ = substring_chars_iter_clone_clone_clone_clone.clone();\n    let mut string_chars_iter_clone_clone_clone_clone_clone_clone\
    \ = string_chars_iter_clone_clone_clone_clone_clone.clone();\n    let mut substring_chars_iter_clone_clone_clone_clone_clone_clone\
    \ = substring_chars_iter_clone_clone_clone_clone_clone.clone();\n    let mut string_chars_iter_clone_clone_clone_\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfll7w001.rs:22:49\n   |\n\
    22 |     let mut string_chars_iter_clone_clone_clone_\n   |                  \
    \                               ^ help: add `;` here\n23 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfll7w001.rs:2:57\n  |\n\
    2 | fn how_many_times(string: String, substring: String) -> isize {\n  |    --------------\
    \                                       ^^^^^ expected `isize`, found `()`\n \
    \ |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let index_of_substring = string[index..].find(&substring);\n\
    \        if index_of_substring.is_none() {\n            break;\n        }\n  \
    \      let index_of_substring = index_of_substring.unwrap();\n        count +=\
    \ 1;\n        index += index_of_substring + substring.len();\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpix4d3v6p.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = true;\n        for (i, c) in\
    \ substring.chars().enumerate() {\n            if string.chars().nth(index + i)\
    \ != Some(c) {\n                found = false;\n                break;\n     \
    \       }\n        }\n        if found {\n            count += 1;\n          \
    \  index += substring.len();\n        } else {\n            index += 1;\n    \
    \    }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1ggq8e3z.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut found = false;\n    while end <= string.len()\
    \ {\n        let slice = &string[start..end];\n        if slice == substring {\n\
    \            count += 1;\n            found = true;\n        }\n        start\
    \ += 1;\n        end += 1;\n    }\n    if found {\n        count\n    } else {\n\
    \        -1\n    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `0`', /tmp/tmp1luo58kj.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        let index_of_substring = index_of_substring.unwrap();\n\
    \        count += 1;\n        index += index_of_substring + substring.len();\n\
    \        string = string[index_of_substring + substring.len()..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpd7gp8up8.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut current_char = string_chars.next();\n    let mut current_substring_char\
    \ = substring_chars.next();\n    while current_char.is_some() {\n        if current_char.unwrap()\
    \ == current_substring_char.unwrap() {\n            if substring_chars.clone().count()\
    \ == 0 {\n                count += 1;\n                current_substring_char\
    \ = substring_chars.next();\n            } else {\n                current_substring_char\
    \ = substring_chars.next();\n            }\n        } else {\n            current_substring_char\
    \ = substring_chars.next();\n        }\n        current_char = string_chars.next();\n\
    \        index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpr1ustw9n.rs:10:60

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        index +=\
    \ found.unwrap() + 1;\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        if let Some(i) = string[index..].find(&substring)\
    \ {\n            count += 1;\n            index += i + substring.len();\n    \
    \    } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl78jot_2.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ string_len = string.len();\n    let substring_len = substring.len();\n    while\
    \ index < string_len {\n        let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp10gnk4wt.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        index +=\
    \ found.unwrap() + 1;\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    while let Some(string_char) = string_chars.next() {\n        if string_char\
    \ == substring_chars.next().unwrap() {\n            index += 1;\n            if\
    \ index == substring.len() {\n                count += 1;\n                index\
    \ = 0;\n                substring_chars = substring.chars();\n            }\n\
    \        } else {\n            index = 0;\n            substring_chars = substring.chars();\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp6abfp8_k.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut string_vec: Vec<char> = string.chars().collect();\n\
    \    let mut substring_vec: Vec<char> = substring.chars().collect();\n    while\
    \ end <= string_vec.len() {\n        if string_vec[start..end] == substring_vec\
    \ {\n            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let found =\
    \ string.find(&substring);\n        if found.is_none() {\n            break;\n\
    \        }\n        count += 1;\n        index = found.unwrap() + 1;\n       \
    \ string = string[index..].to_string();\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp_a_03fdv.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = 0;\n    let mut found = false;\n    let mut index = 0;\n    let mut\
    \ len = substring.len();\n    let mut string = string.clone();\n    let mut substring\
    \ = substring.clone();\n    while end < string.len() {\n        if string.chars().nth(end).unwrap()\
    \ == substring.chars().nth(index).unwrap() {\n            if !found {\n      \
    \          found = true;\n                start = end;\n            }\n      \
    \      index += 1;\n            end += 1;\n            if index == len {\n   \
    \             count += 1;\n                index = 0;\n                found =\
    \ false;\n                string = string.chars().skip(start + 1).collect();\n\
    \                end = 0;\n            }\n        } else {\n            if found\
    \ {\n                found = false;\n                index = 0;\n            \
    \    end = start + 1;\n                string = string.chars().skip(start + 1).collect();\n\
    \            } else {\n                end += 1;\n            }\n        }\n \
    \   }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        let index_of_substring = index_of_substring.unwrap();\n\
    \        count += 1;\n        index += index_of_substring + substring.len();\n\
    \        string = string[index_of_substring + substring.len()..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpd7gp8up8.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start_index = 0;\n \
    \   let mut end_index = substring.len();\n    while end_index <= string.len()\
    \ {\n        if string[start_index..end_index] == substring {\n            count\
    \ += 1;\n        }\n        start_index += 1;\n        end_index += 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        if let Some(i) = string[index..].find(&substring)\
    \ {\n            count += 1;\n            index += i + substring.len();\n    \
    \    } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl78jot_2.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for i in 0..substring.len()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if string.chars().nth(index + i).unwrap() != substring.chars().nth(i).unwrap()\
    \ {\n                break;\n            }\n            if i == substring.len()\
    \ - 1 {\n                found = true;\n            }\n        }\n        if found\
    \ {\n            count += 1;\n            index += substring.len();\n        }\
    \ else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpygxclf7u.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for (i, c) in\
    \ substring.chars().enumerate() {\n            if index + i >= string.len() {\n\
    \                break;\n            }\n            if string.chars().nth(index\
    \ + i).unwrap() == c {\n                found = true;\n            } else {\n\
    \                found = false;\n                break;\n            }\n     \
    \   }\n        if found {\n            count += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpl8dgr6sl.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut substring_char = substring_chars.next();\n    let mut string_char\
    \ = string_chars.next();\n    while substring_char.is_some() && string_char.is_some()\
    \ {\n        if substring_char.unwrap() == string_char.unwrap() {\n          \
    \  substring_char = substring_chars.next();\n            string_char = string_chars.next();\n\
    \            if substring_char.is_none() {\n                count += 1;\n    \
    \            substring_char = substring_chars.next();\n                index +=\
    \ 1;\n                string_chars = string[index..].chars();\n              \
    \  string_char = string_chars.next();\n            }\n        } else {\n     \
    \       index += 1;\n            string_chars = string[index..].chars();\n   \
    \         string_char = string_chars.next();\n            substring_chars = substring.chars();\n\
    \            substring_char = substring_chars.next();\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpsz92hgfe.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        if let Some(next_index) = string[index..].find(&substring)\
    \ {\n            count += 1;\n            index += next_index + substring.len();\n\
    \        } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpwco_7w4l.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let sub_index = string[index..].find(&substring);\n\
    \        if sub_index.is_none() {\n            break;\n        }\n        count\
    \ += 1;\n        index += sub_index.unwrap() + substring.len();\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpdr5c6auw.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let substring_chars = substring.chars();\n\
    \    let mut substring_iter = substring_chars.clone();\n    let mut substring_first_char\
    \ = substring_iter.next();\n    let mut string_first_char = string_chars.next();\n\
    \    while string_first_char != None {\n        if substring_first_char == string_first_char\
    \ {\n            let mut string_iter = string_chars.clone();\n            let\
    \ mut substring_iter = substring_chars.clone();\n            let mut string_char\
    \ = string_iter.next();\n            let mut substring_char = substring_iter.next();\n\
    \            while substring_char != None && string_char == substring_char {\n\
    \                string_char = string_iter.next();\n                substring_char\
    \ = substring_iter.next();\n            }\n            if substring_char == None\
    \ {\n                count += 1;\n            }\n        }\n        string_first_char\
    \ = string_chars.next();\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpqiehimge.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let mut substring = substring;\n    while index !=\
    \ -1 {\n        index = string.find(&substring).unwrap_or(-1);\n        if index\
    \ != -1 {\n            count += 1;\n            string = string[index + substring.len()..].to_string();\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n --> /tmp/tmpilnazho3.rs:8:51\n\
    \  |\n8 |         index = string.find(&substring).unwrap_or(-1);\n  |        \
    \                                           ^^\n  |                          \
    \                         |\n  |                                             \
    \      cannot apply unary operator `-`\n  |                                  \
    \                 help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \  |\n  = note: unsigned values cannot be negated\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n --> /tmp/tmpilnazho3.rs:7:20\n  |\n7 |     while\
    \ index != -1 {\n  |                    ^^ the trait `Neg` is not implemented\
    \ for `usize`\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \ --> /tmp/tmpilnazho3.rs:9:21\n  |\n9 |         if index != -1 {\n  |       \
    \              ^^\n  |                     |\n  |                     cannot apply\
    \ unary operator `-`\n  |                     help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n  |\n  = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_option\
    \ = string.find(&substring);\n        if index_option.is_none() {\n          \
    \  break;\n        }\n        let index = index_option.unwrap();\n        count\
    \ += 1;\n        string = string[index + substring.len()..].to_string();\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpfxuj_xmt.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        count += 1;\n        index += index_of_substring.unwrap()\
    \ + 1;\n        string = string[index..].to_string();\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmppz8o2bgw.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        if let Some(i) = string[index..].find(&substring)\
    \ {\n            count += 1;\n            index += i + substring.len();\n    \
    \    } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl78jot_2.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_length = string.len();\n    let substring_length = substring.len();\n\
    \    while index < string_length {\n        let found_index = string[index..].find(&substring);\n\
    \        if found_index.is_some() {\n            count += 1;\n            index\
    \ += found_index.unwrap() + substring_length;\n        } else {\n            break;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmps3iaivyi.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for i in 0..substring.len()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if string.chars().nth(index + i).unwrap() != substring.chars().nth(i).unwrap()\
    \ {\n                break;\n            }\n            if i == substring.len()\
    \ - 1 {\n                found = true;\n            }\n        }\n        if found\
    \ {\n            count += 1;\n            index += substring.len();\n        }\
    \ else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpygxclf7u.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut found = false;\n    let mut string_chars = string.chars();\n\
    \    let mut substring_chars = substring.chars();\n    while i < string.len()\
    \ {\n        if string_chars.next().unwrap() == substring_chars.next().unwrap()\
    \ {\n            if !found {\n                found = true;\n                j\
    \ = i;\n            }\n            if substring_chars.peek().is_none() {\n   \
    \             count += 1;\n                substring_chars = substring.chars();\n\
    \                i = j;\n                found = false;\n            }\n     \
    \   } else {\n            substring_chars = substring.chars();\n            found\
    \ = false;\n        }\n        i += 1;\n    }\n    count\n}\n\nfn main() {\n \
    \   let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `peek` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpcrwekyvr.rs:15:32\n   |\n15 |             if substring_chars.peek().is_none()\
    \ {\n   |                                ^^^^ method not found in `Chars<'_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut found = false;\n    while end <= string.len()\
    \ {\n        if string[start..end] == substring {\n            count += 1;\n \
    \           start += 1;\n            end += 1;\n            found = true;\n  \
    \      } else {\n            if found {\n                start += 1;\n       \
    \         end += 1;\n            } else {\n                start += 1;\n     \
    \           end += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_iter = string.chars();\n    let mut substring_iter = substring.chars();\n\
    \    let mut substring_first_char = substring_iter.next();\n    let mut string_first_char\
    \ = string_iter.next();\n    while let Some(c) = string_first_char {\n       \
    \ if c == substring_first_char.unwrap() {\n            let mut string_iter_copy\
    \ = string_iter.clone();\n            let mut substring_iter_copy = substring_iter.clone();\n\
    \            let mut string_first_char_copy = string_iter_copy.next();\n     \
    \       let mut substring_first_char_copy = substring_iter_copy.next();\n    \
    \        while let Some(c) = substring_first_char_copy {\n                if c\
    \ != string_first_char_copy.unwrap() {\n                    break;\n         \
    \       }\n                string_first_char_copy = string_iter_copy.next();\n\
    \                substring_first_char_copy = substring_iter_copy.next();\n   \
    \         }\n            if substring_first_char_copy == None {\n            \
    \    count += 1;\n            }\n        }\n        string_first_char = string_iter.next();\n\
    \        substring_first_char = substring.chars().next();\n        index += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp93_d_e_1.rs:16:48

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let index_of_substring = string[index..].find(&substring);\n\
    \        if index_of_substring.is_none() {\n            break;\n        }\n  \
    \      let index_of_substring = index_of_substring.unwrap();\n        count +=\
    \ 1;\n        index += index_of_substring + substring.len();\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpix4d3v6p.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while let Some(i) = string.find(&substring) {\n  \
    \      count += 1;\n        index += i;\n        string = string[(index + substring.len())..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 3 is out of bounds of `x`'', /tmp/tmpeeypfwvn.rs:9:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ string_len = string.len();\n    let substring_len = substring.len();\n    while\
    \ index < string_len {\n        let found = string.find(&substring, index);\n\
    \        if found.is_none() {\n            break;\n        }\n        index =\
    \ found.unwrap() + substring_len;\n        count += 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp7hqtog5e.rs:8:28\n     |\n8    |         let found = string.find(&substring,\
    \ index);\n     |                            ^^^^ ----------  ----- supplied 2\
    \ arguments\n     |                            |\n     |                     \
    \       expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    while end <= string.len() {\n        if string[start..end]\
    \ == substring {\n            count += 1;\n        }\n        start += 1;\n  \
    \      end += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut found = false;\n    while end <= string.len()\
    \ {\n        if &string[start..end] == substring {\n            count += 1;\n\
    \            start += 1;\n            end += 1;\n            found = true;\n \
    \       } else {\n            if found {\n                start += 1;\n      \
    \          end += 1;\n            } else {\n                start += 1;\n    \
    \            end += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    while end <= string.len() {\n        if string[start..end]\
    \ == substring {\n            count += 1;\n        }\n        start += 1;\n  \
    \      end += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let substring_chars = substring.chars();\n\
    \    while let Some(c) = string_chars.next() {\n        if c == substring_chars.clone().nth(index).unwrap()\
    \ {\n            index += 1;\n            if index == substring.len() {\n    \
    \            count += 1;\n                index = 0;\n            }\n        }\
    \ else {\n            index = 0;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpzda7r7os.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        let index_of_substring = index_of_substring.unwrap();\n\
    \        count += 1;\n        string = string[index_of_substring + substring.len()..].to_string();\n\
    \        index += index_of_substring + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpwv1kb01x.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for i in 0..substring.len()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if substring.chars().nth(i).unwrap() != string.chars().nth(index\
    \ + i).unwrap() {\n                break;\n            }\n            if i ==\
    \ substring.len() - 1 {\n                found = true;\n            }\n      \
    \  }\n        if found {\n            count += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpbx4nhhax.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while let Some(i) = string.find(&substring) {\n  \
    \      count += 1;\n        index += i + 1;\n        string = string[index..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    /tmp/tmpow_x2n6y.rs:9:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut found = false;\n    while end <= string.len()\
    \ {\n        if string[start..end] == substring {\n            count += 1;\n \
    \           start += 1;\n            end += 1;\n            found = true;\n  \
    \      } else {\n            if found {\n                start += 1;\n       \
    \         end += 1;\n            } else {\n                start += 1;\n     \
    \           end += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index != -1 {\n        index = string[index..].find(&substring).unwrap_or(-1);\n\
    \        if index != -1 {\n            count += 1;\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmp4t9hr6bt.rs:5:20\n\
    \  |\n5 |     while index != -1 {\n  |                    ^^ the trait `Neg` is\
    \ not implemented for `usize`\n\nerror[E0600]: cannot apply unary operator `-`\
    \ to type `usize`\n --> /tmp/tmp4t9hr6bt.rs:6:60\n  |\n6 |         index = string[index..].find(&substring).unwrap_or(-1);\n\
    \  |                                                            ^^\n  |      \
    \                                                      |\n  |                \
    \                                            cannot apply unary operator `-`\n\
    \  |                                                            help: you may\
    \ have meant the maximum value of `usize`: `usize::MAX`\n  |\n  = note: unsigned\
    \ values cannot be negated\n\nerror[E0600]: cannot apply unary operator `-` to\
    \ type `usize`\n --> /tmp/tmp4t9hr6bt.rs:7:21\n  |\n7 |         if index != -1\
    \ {\n  |                     ^^\n  |                     |\n  |              \
    \       cannot apply unary operator `-`\n  |                     help: you may\
    \ have meant the maximum value of `usize`: `usize::MAX`\n  |\n  = note: unsigned\
    \ values cannot be negated\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0600.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        if let Some(i) = string[index..].find(&substring)\
    \ {\n            count += 1;\n            index += i + substring.len();\n    \
    \    } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl78jot_2.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_length = substring.len();\n    while\
    \ index < string.len() {\n        if string.starts_with(&substring) {\n      \
    \      count += 1;\n            string = string.chars().skip(substring_length).collect();\n\
    \        } else {\n            string = string.chars().skip(1).collect();\n  \
    \      }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpa_i8irqn.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for (i, c) in\
    \ substring.chars().enumerate() {\n            if index + i >= string.len() {\n\
    \                break;\n            }\n            if string.chars().nth(index\
    \ + i).unwrap() == c {\n                found = true;\n            } else {\n\
    \                found = false;\n                break;\n            }\n     \
    \   }\n        if found {\n            count += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpl8dgr6sl.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut substring_char = substring_chars.next();\n    for c in string_chars\
    \ {\n        if c == substring_char.unwrap() {\n            index += 1;\n    \
    \        substring_char = substring_chars.next();\n            if index == substring.len()\
    \ {\n                count += 1;\n                index = 0;\n               \
    \ substring_char = substring_chars.next();\n            }\n        } else {\n\
    \            index = 0;\n            substring_char = substring_chars.next();\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp68yfkznt.rs:9:32

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index =\
    \ string.find(&substring);\n        if index.is_none() {\n            break;\n\
    \        }\n        count += 1;\n        let index = index.unwrap();\n       \
    \ string = string[index + substring.len()..].to_string();\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpmpz1dqps.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while let Some(i) = string.find(&substring) {\n  \
    \      count += 1;\n        index += i + 1;\n        string = string[index..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    /tmp/tmpow_x2n6y.rs:9:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for i in 0..substring.len()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if substring.chars().nth(i).unwrap() != string.chars().nth(index\
    \ + i).unwrap() {\n                break;\n            }\n            if i ==\
    \ substring.len() - 1 {\n                found = true;\n            }\n      \
    \  }\n        if found {\n            count += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpbx4nhhax.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if substring.len() > string.len() {\n        return\
    \ 0;\n    }\n\n    let mut count = 0;\n    let mut index = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n\n    while\
    \ let Some(string_char) = string_chars.nth(index) {\n        if string_char ==\
    \ substring_chars.next().unwrap() {\n            let mut string_chars_clone =\
    \ string_chars.clone();\n            let mut substring_chars_clone = substring_chars.clone();\n\
    \            let mut match_count = 1;\n\n            while let Some(string_char)\
    \ = string_chars_clone.next() {\n                if let Some(substring_char) =\
    \ substring_chars_clone.next() {\n                    if string_char == substring_char\
    \ {\n                        match_count += 1;\n                    } else {\n\
    \                        break;\n                    }\n                } else\
    \ {\n                    count += 1;\n                    break;\n           \
    \     }\n            }\n\n            if match_count == substring.len() {\n  \
    \              count += 1;\n            }\n        }\n\n        index += 1;\n\
    \    }\n\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n \
    \   assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpamimz8d5.rs:13:50

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        count += 1;\n        let index_of_substring\
    \ = index_of_substring.unwrap();\n        string = string.split_off(index_of_substring\
    \ + substring.len());\n        index += index_of_substring + substring.len();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp5__tg708.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for i in 0..substring.len()\
    \ {\n            if index + i < string.len() && string.chars().nth(index + i).unwrap()\
    \ == substring.chars().nth(i).unwrap() {\n                found = true;\n    \
    \        } else {\n                found = false;\n                break;\n  \
    \          }\n        }\n        if found {\n            count += 1;\n       \
    \     index += substring.len();\n        } else {\n            index += 1;\n \
    \       }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpias2ebkb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut substring_char = substring_chars.next();\n    while let Some(c) =\
    \ string_chars.next() {\n        if c == substring_char.unwrap() {\n         \
    \   substring_char = substring_chars.next();\n            if substring_char.is_none()\
    \ {\n                count += 1;\n                substring_char = substring_chars.next();\n\
    \            }\n        } else {\n            substring_char = substring.chars().next();\n\
    \        }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpglmubvb0.rs:9:32

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        count += 1;\n        let index_of_substring\
    \ = index_of_substring.unwrap();\n        string = string.split_off(index_of_substring\
    \ + substring.len());\n        index += index_of_substring + substring.len();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp5__tg708.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut substring_chars_vec: Vec<char> = substring.chars().collect();\n \
    \   let mut substring_chars_vec_len = substring_chars_vec.len();\n    let mut\
    \ substring_chars_vec_first = substring_chars_vec[0];\n    let mut substring_chars_vec_last\
    \ = substring_chars_vec[substring_chars_vec_len - 1];\n    let mut substring_chars_vec_first_index\
    \ = 0;\n    let mut substring_chars_vec_last_index = 0;\n    let mut substring_chars_vec_first_index_found\
    \ = false;\n    let mut substring_chars_vec_last_index_found = false;\n    let\
    \ mut substring_chars_vec_first_index_found_count = 0;\n    let mut substring_chars_vec_last_index_found_count\
    \ = 0;\n    let mut substring_chars_vec_first_index_found_count_max = 0;\n   \
    \ let mut substring_chars_vec_last_index_found_count_max = 0;\n    let mut substring_chars_vec_first_index_found_count_max_index\
    \ = 0;\n    let mut substring_chars_vec_last_index_found_count_max_index = 0;\n\
    \    let mut substring_chars_vec_first_index_found_count_max_index_found = false;\n\
    \    let mut substring_chars_vec_last_index_found_count_max_index_found = false;\n\
    \    let mut substring_chars_vec_first_index_found_count_max_index_found_count\
    \ = 0;\n    let mut substring_chars_vec_last_index_found_count_max_index_found_count\
    \ = 0;\n    let mut substring_chars_vec_first_index_found_count_max_index\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1ifbp0ue.rs:25:66\n   |\n\
    25 |     let mut substring_chars_vec_first_index_found_count_max_index\n   | \
    \                                                                 ^ help: add\
    \ `;` here\n26 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp1ifbp0ue.rs:2:57\n  |\n2 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |    --------------                                  \
    \     ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_len = substring.len();\n    while let\
    \ Some(i) = string.find(&substring) {\n        index += i;\n        string = string[i\
    \ + substring_len..].to_string();\n        count += 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpau015ivg.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        count += 1;\n        index += index_of_substring.unwrap()\
    \ + 1;\n        string = string[index..].to_string();\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmppz8o2bgw.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let sub_index\
    \ = string[index..].find(&substring);\n        if sub_index.is_none() {\n    \
    \        break;\n        }\n        count += 1;\n        index += sub_index.unwrap()\
    \ + substring.len();\n        string = string[index..].to_string();\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpz4iju9mf.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut last_index = 0;\n    let mut string = string;\n    let mut substring = substring;\n\
    \    while index != -1 {\n        index = string.find(&substring);\n        if\
    \ index != -1 {\n            count += 1;\n            last_index = index;\n  \
    \          string = string[(index + substring.len())..].to_string();\n       \
    \ }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpx_gi6n4f.rs:9:17\n  |\n9 |\
    \         index = string.find(&substring);\n  |                 ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n  |\n  = note: expected type `{integer}`\n\
    \             found enum `Option<usize>`\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n --> /tmp/tmpx_gi6n4f.rs:8:20\n  |\n8 |     while index\
    \ != -1 {\n  |                    ^^ the trait `Neg` is not implemented for `usize`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpx_gi6n4f.rs:10:21\n\
    \   |\n10 |         if index != -1 {\n   |                     ^^ the trait `Neg`\
    \ is not implemented for `usize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let found =\
    \ string.find(&substring);\n        if found.is_none() {\n            break;\n\
    \        }\n        let found = found.unwrap();\n        count += 1;\n       \
    \ string = string.split_off(found + substring.len());\n        index += found\
    \ + substring.len();\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpx3hv5rtw.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        count += 1;\n        let index_of_substring\
    \ = index_of_substring.unwrap();\n        string = string.split_off(index_of_substring\
    \ + substring.len());\n        index += index_of_substring + substring.len();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp5__tg708.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut string = string;\n    while end <= string.len()\
    \ {\n        if string[start..end] == substring {\n            count += 1;\n \
    \           start += 1;\n            end += 1;\n        } else {\n           \
    \ start += 1;\n            end += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        index +=\
    \ found.unwrap() + 1;\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut last_index = 0;\n  \
    \  let mut index = 0;\n    let mut string = string;\n    while index != -1 {\n\
    \        index = string.find(&substring).unwrap_or(-1);\n        if index != -1\
    \ {\n            count += 1;\n            last_index = index;\n            string\
    \ = string[index + substring.len()..].to_string();\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n --> /tmp/tmpmrkm27bj.rs:8:51\n\
    \  |\n8 |         index = string.find(&substring).unwrap_or(-1);\n  |        \
    \                                           ^^\n  |                          \
    \                         |\n  |                                             \
    \      cannot apply unary operator `-`\n  |                                  \
    \                 help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \  |\n  = note: unsigned values cannot be negated\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n --> /tmp/tmpmrkm27bj.rs:7:20\n  |\n7 |     while\
    \ index != -1 {\n  |                    ^^ the trait `Neg` is not implemented\
    \ for `usize`\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \ --> /tmp/tmpmrkm27bj.rs:9:21\n  |\n9 |         if index != -1 {\n  |       \
    \              ^^\n  |                     |\n  |                     cannot apply\
    \ unary operator `-`\n  |                     help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n  |\n  = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_length = substring.len();\n    while\
    \ index < string.len() {\n        if string.starts_with(&substring) {\n      \
    \      count += 1;\n            string = string.chars().skip(substring_length).collect();\n\
    \        } else {\n            string = string.chars().skip(1).collect();\n  \
    \      }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpa_i8irqn.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_len = substring.len();\n    while index\
    \ < string.len() {\n        if string.starts_with(&substring) {\n            count\
    \ += 1;\n            string = string[substring_len..].to_string();\n        }\
    \ else {\n            string = string[1..].to_string();\n        }\n        index\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp87i8b_e3.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_len = substring.len();\n    while index\
    \ < string.len() {\n        if string.starts_with(&substring) {\n            count\
    \ += 1;\n            string = string[substring_len..].to_string();\n        }\
    \ else {\n            string = string[1..].to_string();\n        }\n        index\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp87i8b_e3.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = 0;\n    let mut string_chars = string.chars();\n    let mut substring_chars\
    \ = substring.chars();\n    let mut substring_char = substring_chars.next();\n\
    \    let mut string_char = string_chars.next();\n    while string_char.is_some()\
    \ {\n        if string_char == substring_char {\n            end += 1;\n     \
    \       substring_char = substring_chars.next();\n            if substring_char.is_none()\
    \ {\n                count += 1;\n                substring_chars = substring.chars();\n\
    \                substring_char = substring_chars.next();\n                start\
    \ = end;\n            }\n        } else {\n            substring_chars = substring.chars();\n\
    \            substring_char = substring_chars.next();\n            start = end;\n\
    \        }\n        string_char = string_chars.next();\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5rafu38q.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    while\
    \ let Some(index) = string[start..].find(&substring) {\n        count += 1;\n\
    \        start = start + index + substring.len();\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpslu49yul.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut substring_char = substring_chars.next();\n    let mut string_char\
    \ = string_chars.next();\n    while string_char != None {\n        if substring_char\
    \ == string_char {\n            index += 1;\n            substring_char = substring_chars.next();\n\
    \            if substring_char == None {\n                count += 1;\n      \
    \          substring_char = substring_chars.next();\n            }\n        }\
    \ else {\n            index = 0;\n            substring_char = substring_chars.next();\n\
    \        }\n        string_char = string_chars.next();\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpg1gg985n.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        if let Some(i)\
    \ = string.find(&substring) {\n            count += 1;\n            index += i\
    \ + substring.len();\n            string = string[i + substring.len()..].to_string();\n\
    \        } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpnp4ocu1x.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_len = substring.len();\n    while index\
    \ < string.len() {\n        if string.starts_with(&substring) {\n            count\
    \ += 1;\n            string = string[substring_len..].to_string();\n        }\
    \ else {\n            string = string[1..].to_string();\n        }\n        index\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp87i8b_e3.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let mut substring = substring;\n    while index <\
    \ string.len() {\n        if string.contains(&substring) {\n            count\
    \ += 1;\n            index += substring.len();\n            string = string[index..].to_string();\n\
    \        } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpvnaay39v.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        if let Some(i)\
    \ = string.find(&substring) {\n            count += 1;\n            index += i\
    \ + substring.len();\n            string = string[i + substring.len()..].to_string();\n\
    \        } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpnp4ocu1x.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = true;\n        for (i, c) in\
    \ substring.chars().enumerate() {\n            if string.chars().nth(index + i)\
    \ != Some(c) {\n                found = false;\n                break;\n     \
    \       }\n        }\n        if found {\n            count += 1;\n          \
    \  index += substring.len();\n        } else {\n            index += 1;\n    \
    \    }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1ggq8e3z.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n    while end <= string_len {\n        let slice = &string[start..end];\n\
    \        if slice == substring {\n            count += 1;\n        }\n       \
    \ start += 1;\n        end += 1;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = true;\n        for (i, c) in\
    \ substring.chars().enumerate() {\n            if string.chars().nth(index + i)\
    \ != Some(c) {\n                found = false;\n                break;\n     \
    \       }\n        }\n        if found {\n            count += 1;\n          \
    \  index += substring.len();\n        } else {\n            index += 1;\n    \
    \    }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1ggq8e3z.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut found = false;\n    while end <= string.len()\
    \ {\n        if string[start..end] == substring {\n            count += 1;\n \
    \           start += 1;\n            end += 1;\n            found = true;\n  \
    \      } else {\n            if found {\n                start += 1;\n       \
    \         end += 1;\n            } else {\n                start += 1;\n     \
    \           end += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        count += 1;\n        index += index_of_substring.unwrap()\
    \ + 1;\n        string = string[index..].to_string();\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmppz8o2bgw.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start_index = 0;\n \
    \   let mut end_index = substring.len();\n    let mut string_chars = string.chars();\n\
    \    let mut substring_chars = substring.chars();\n    let mut string_char;\n\
    \    let mut substring_char;\n    let mut string_char_index = 0;\n    let mut\
    \ substring_char_index = 0;\n    let mut string_char_iter = string_chars.by_ref();\n\
    \    let mut substring_char_iter = substring_chars.by_ref();\n    let mut string_char_iter_clone;\n\
    \    let mut substring_char_iter_clone;\n    let mut string_char_iter_clone_clone;\n\
    \    let mut substring_char_iter_clone_clone;\n    let mut string_char_iter_clone_clone_clone;\n\
    \    let mut substring_char_iter_clone_clone_clone;\n    let mut string_char_iter_clone_clone_clone_clone;\n\
    \    let mut substring_char_iter_clone_clone_clone_clone;\n    let mut string_char_iter_clone_clone_clone_clone_clone;\n\
    \    let mut substring_char_iter_clone_clone_clone_clone_clone;\n    let mut string_char_iter_clone_clone_clone_clone_clone_clone;\n\
    \    let mut substring_char_iter_clone_clone_clone_clone_clone_clone;\n    let\
    \ mut string_char_iter_clone_clone_clone_clone_clone_clone_clone;\n    let mut\
    \ substring_char_iter_clone_clone_clone_clone_clone_clone_clone;\n    let mut\
    \ string_char_iter_clone_clone_clone_clone_clone_clone_clone_clone;\n    let mut\
    \ substring_char_iter_clone_clone_clone_clone_clone_clone_clone_clone;\n    let\
    \ mut string_char_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone;\n\
    \    let mut substring_char_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone;\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv69b46dv.rs:2:57\n  |\n2 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |    --------------\
    \                                       ^^^^^ expected `isize`, found `()`\n \
    \ |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_len = substring.len();\n    while index\
    \ < string.len() {\n        if string.starts_with(&substring) {\n            count\
    \ += 1;\n            string = string[substring_len..].to_string();\n        }\
    \ else {\n            string = string[1..].to_string();\n        }\n        index\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp87i8b_e3.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        if string.starts_with(&substring)\
    \ {\n            count += 1;\n            string = string.chars().skip(substring.len()).collect();\n\
    \        } else {\n            string = string.chars().skip(1).collect();\n  \
    \      }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5qwoxfgp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n    while end <= string_len {\n        if string[start..end]\
    \ == substring {\n            count += 1;\n            start += 1;\n         \
    \   end += 1;\n        } else {\n            start += 1;\n            end += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut substring_chars_vec: Vec<char> = substring.chars().collect();\n \
    \   let mut substring_chars_vec_len = substring_chars_vec.len();\n    let mut\
    \ substring_chars_vec_index = 0;\n    let mut substring_chars_vec_index_reset\
    \ = 0;\n    let mut substring_chars_vec_index_reset_flag = false;\n    let mut\
    \ substring_chars_vec_index_reset_flag_reset = false;\n    let mut substring_chars_vec_index_reset_flag_reset_flag\
    \ = false;\n    let mut substring_chars_vec_index_reset_flag_reset_flag_reset\
    \ = false;\n    let mut substring_chars_vec_index_reset_flag_reset_flag_reset_flag\
    \ = false;\n    let mut substring_chars_vec_index_reset_flag_reset_flag_reset_flag_reset\
    \ = false;\n    let mut substring_chars_vec_index_reset_flag_reset_flag_reset_flag_reset_flag\
    \ = false;\n    let mut substring_chars_vec_index_reset_flag_reset_flag_reset_flag_reset_flag_reset\
    \ = false;\n    let mut substring_chars_vec_index_reset_flag_reset_flag_reset_flag_reset_flag_reset_flag\
    \ = false;\n    let mut substring_chars_vec_index_reset_flag_reset_flag_reset_flag_reset_flag_reset_flag_reset\
    \ = false;\n    let mut substring_chars_vec_index_reset_flag_reset_flag_reset_flag_reset_flag_reset_flag_reset_flag\
    \ = false;\n    let mut substring_chars_vec_index_reset_flag_reset_flag_reset_flag_reset_flag_reset_flag_reset_flag_reset\
    \ = false;\n    let mut substring_chars_vec\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9ucgsmgt.rs:23:32\n   |\n\
    23 |     let mut substring_chars_vec\n   |                                ^ help:\
    \ add `;` here\n24 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp9ucgsmgt.rs:2:57\n  |\n2 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |    --------------                                  \
    \     ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for (i, c) in\
    \ substring.chars().enumerate() {\n            if index + i >= string.len() {\n\
    \                break;\n            }\n            if string.chars().nth(index\
    \ + i).unwrap() == c {\n                found = true;\n            } else {\n\
    \                found = false;\n                break;\n            }\n     \
    \   }\n        if found {\n            count += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpl8dgr6sl.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    while i\
    \ < string.len() {\n        let mut j = 0;\n        while j < substring.len()\
    \ && i + j < string.len() && string.chars().nth(i + j) == substring.chars().nth(j)\
    \ {\n            j += 1;\n        }\n        if j == substring.len() {\n     \
    \       count += 1;\n            i += j;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpb0inul48.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_len = substring.len();\n    while index\
    \ < string.len() {\n        if string.starts_with(&substring) {\n            count\
    \ += 1;\n            string = string[substring_len..].to_string();\n        }\
    \ else {\n            string = string[1..].to_string();\n        }\n        index\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp87i8b_e3.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let new_index = string[index..].find(&substring);\n\
    \        if new_index.is_none() {\n            break;\n        }\n        count\
    \ += 1;\n        index += new_index.unwrap() + substring.len();\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpc255upge.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut index = 0;\n    let string_len = string.len();\n    let substring_len =\
    \ substring.len();\n    let mut string_chars = string.chars();\n    let mut substring_chars\
    \ = substring.chars();\n    let mut string_char = string_chars.next();\n    let\
    \ mut substring_char = substring_chars.next();\n    while string_char != None\
    \ {\n        if string_char == substring_char {\n            if index == 0 {\n\
    \                start = string_chars.as_str().len();\n            }\n       \
    \     index += 1;\n            substring_char = substring_chars.next();\n    \
    \        if substring_char == None {\n                count += 1;\n          \
    \      substring_chars = substring.chars();\n                substring_char =\
    \ substring_chars.next();\n                index = 0;\n            }\n       \
    \ } else {\n            if index > 0 {\n                string_chars = string[start..].chars();\n\
    \                string_char = string_chars.next();\n                substring_chars\
    \ = substring.chars();\n                substring_char = substring_chars.next();\n\
    \                index = 0;\n            }\n        }\n        string_char = string_chars.next();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3gqweclu.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut substring_chars_clone = substring.chars();\n    let mut substring_chars_clone_clone\
    \ = substring.chars();\n    let mut substring_chars_clone_clone_clone = substring.chars();\n\
    \    let mut substring_chars_clone_clone_clone_clone = substring.chars();\n  \
    \  let mut substring_chars_clone_clone_clone_clone_clone = substring.chars();\n\
    \    let mut substring_chars_clone_clone_clone_clone_clone_clone = substring.chars();\n\
    \    let mut substring_chars_clone_clone_clone_clone_clone_clone_clone = substring.chars();\n\
    \    let mut substring_chars_clone_clone_clone_clone_clone_clone_clone_clone =\
    \ substring.chars();\n    let mut substring_chars_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring.chars();\n    let mut substring_chars_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring.chars();\n    let mut substring_chars_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring.chars();\n    let mut substring_chars_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring.chars();\n    let mut substring_chars_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring.chars();\n    let mut substring_chars_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring.chars();\n    let mut substring_chars_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgkb39jro.rs:21:95\n   |\n\
    21 |     let mut substring_chars_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_\n\
    \   |                                                                        \
    \                       ^ help: add `;` here\n22 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpgkb39jro.rs:2:57\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |    --------------               \
    \                        ^^^^^ expected `isize`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        if let Some(i) = string[index..].find(&substring)\
    \ {\n            count += 1;\n            index += i + substring.len();\n    \
    \    } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl78jot_2.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start_index = 0;\n \
    \   let mut index = 0;\n    while index < string.len() {\n        let slice =\
    \ &string[start_index..index];\n        if slice == substring {\n            count\
    \ += 1;\n            start_index = index;\n        }\n        index += 1;\n  \
    \  }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmppxr_dmom.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        if let Some(i)\
    \ = string.find(&substring) {\n            count += 1;\n            string = string[i\
    \ + substring.len()..].to_string();\n        } else {\n            break;\n  \
    \      }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1ooplymz.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        let index_of_substring = index_of_substring.unwrap();\n\
    \        count += 1;\n        string = string[index_of_substring + substring.len()..].to_string();\n\
    \        index += index_of_substring + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpwv1kb01x.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while let Some(i) = string.find(&substring) {\n  \
    \      count += 1;\n        index += i + 1;\n        string = string[index..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    /tmp/tmpow_x2n6y.rs:9:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut substring_first_char = substring_chars.next();\n    let mut string_first_char\
    \ = string_chars.next();\n    while string_first_char != None {\n        if string_first_char\
    \ == substring_first_char {\n            let mut string_chars_clone = string_chars.clone();\n\
    \            let mut substring_chars_clone = substring_chars.clone();\n      \
    \      let mut string_char = string_chars_clone.next();\n            let mut substring_char\
    \ = substring_chars_clone.next();\n            while substring_char != None {\n\
    \                if string_char != substring_char {\n                    break;\n\
    \                }\n                string_char = string_chars_clone.next();\n\
    \                substring_char = substring_chars_clone.next();\n            }\n\
    \            if substring_char == None {\n                count += 1;\n      \
    \      }\n        }\n        index += 1;\n        string_first_char = string_chars.next();\n\
    \        substring_first_char = substring_chars.next();\n        if substring_first_char\
    \ == None {\n            substring_chars = substring.chars();\n            substring_first_char\
    \ = substring_chars.next();\n        }\n    }\n    count\n}\n\nfn main() {\n \
    \   let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `4`', /tmp/tmpfv8hrbnk.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        count += 1;\n        index += index_of_substring.unwrap()\
    \ + 1;\n        string = string[index..].to_string();\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmppz8o2bgw.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index != -1 {\n        index = string[index..].find(&substring).unwrap_or(-1);\n\
    \        if index != -1 {\n            count += 1;\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmp4t9hr6bt.rs:5:20\n\
    \  |\n5 |     while index != -1 {\n  |                    ^^ the trait `Neg` is\
    \ not implemented for `usize`\n\nerror[E0600]: cannot apply unary operator `-`\
    \ to type `usize`\n --> /tmp/tmp4t9hr6bt.rs:6:60\n  |\n6 |         index = string[index..].find(&substring).unwrap_or(-1);\n\
    \  |                                                            ^^\n  |      \
    \                                                      |\n  |                \
    \                                            cannot apply unary operator `-`\n\
    \  |                                                            help: you may\
    \ have meant the maximum value of `usize`: `usize::MAX`\n  |\n  = note: unsigned\
    \ values cannot be negated\n\nerror[E0600]: cannot apply unary operator `-` to\
    \ type `usize`\n --> /tmp/tmp4t9hr6bt.rs:7:21\n  |\n7 |         if index != -1\
    \ {\n  |                     ^^\n  |                     |\n  |              \
    \       cannot apply unary operator `-`\n  |                     help: you may\
    \ have meant the maximum value of `usize`: `usize::MAX`\n  |\n  = note: unsigned\
    \ values cannot be negated\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0600.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let substring_chars = substring.chars();\n\
    \    while let Some(c) = string_chars.next() {\n        if c == substring_chars.clone().nth(index).unwrap()\
    \ {\n            index += 1;\n            if index == substring.len() {\n    \
    \            count += 1;\n                index = 0;\n            }\n        }\
    \ else {\n            index = 0;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpzda7r7os.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for i in 0..substring.len()\
    \ {\n            if index + i < string.len() && string.chars().nth(index + i).unwrap()\
    \ == substring.chars().nth(i).unwrap() {\n                found = true;\n    \
    \        } else {\n                found = false;\n                break;\n  \
    \          }\n        }\n        if found {\n            count += 1;\n       \
    \     index += substring.len();\n        } else {\n            index += 1;\n \
    \       }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpias2ebkb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for i in 0..substring.len()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if substring.chars().nth(i).unwrap() != string.chars().nth(index\
    \ + i).unwrap() {\n                break;\n            }\n            if i ==\
    \ substring.len() - 1 {\n                found = true;\n            }\n      \
    \  }\n        if found {\n            count += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpbx4nhhax.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for i in 0..substring.len()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if string.chars().nth(index + i).unwrap() != substring.chars().nth(i).unwrap()\
    \ {\n                break;\n            }\n            if i == substring.len()\
    \ - 1 {\n                found = true;\n            }\n        }\n        if found\
    \ {\n            count += 1;\n            index += substring.len();\n        }\
    \ else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpygxclf7u.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while let Some(pos) = string.find(&substring) {\n\
    \        count += 1;\n        index += pos + 1;\n        string = string[index..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    /tmp/tmpc10328pu.rs:9:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        } else {\n        \
    \    let found = found.unwrap();\n            count += 1;\n            index +=\
    \ found + substring.len();\n        }\n    }\n    count\n}\n\nfn main() {\n  \
    \  let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpld2eyerr.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    while\
    \ start < string.len() {\n        let pos = string[start..].find(&substring);\n\
    \        if pos.is_none() {\n            break;\n        }\n        count += 1;\n\
    \        start += pos.unwrap() + substring.len();\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp7t4dhy4a.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    while\
    \ start < string.len() {\n        if let Some(index) = string[start..].find(&substring)\
    \ {\n            count += 1;\n            start += index + substring.len();\n\
    \        } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5amie1va.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    while i\
    \ < string.len() {\n        if string[i..].starts_with(&substring) {\n       \
    \     count += 1;\n            i += substring.len();\n        } else {\n     \
    \       i += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpyrny3rk8.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut found = false;\n    while end <= string.len()\
    \ {\n        let slice = &string[start..end];\n        if slice == substring {\n\
    \            count += 1;\n            start += 1;\n            end += 1;\n   \
    \         found = true;\n        } else {\n            if found {\n          \
    \      start += 1;\n                end += 1;\n            } else {\n        \
    \        start += 1;\n                end += 1;\n            }\n        }\n  \
    \  }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ sub_len = substring.len();\n    let string_len = string.len();\n    while start\
    \ + sub_len <= string_len {\n        if string[start..start + sub_len] == substring\
    \ {\n            count += 1;\n            start += sub_len;\n        } else {\n\
    \            start += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp_d5b0b8i.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while let Some(i) = string.find(&substring) {\n  \
    \      count += 1;\n        index += i + 1;\n        string = string[index..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    /tmp/tmpow_x2n6y.rs:9:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_len = substring.len();\n    while let\
    \ Some(pos) = string.find(&substring) {\n        index += pos;\n        string\
    \ = string[pos + substring_len..].to_string();\n        count += 1;\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpm74p2myp.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let substring_chars = substring.chars();\n\
    \    let mut substring_chars_iter = substring_chars.clone();\n    loop {\n   \
    \     match string_chars.next() {\n            Some(c) => {\n                if\
    \ c == substring_chars_iter.next().unwrap() {\n                    if substring_chars_iter.clone().count()\
    \ == 0 {\n                        count += 1;\n                        substring_chars_iter\
    \ = substring_chars.clone();\n                    }\n                } else {\n\
    \                    substring_chars_iter = substring_chars.clone();\n       \
    \         }\n            }\n            None => break,\n        }\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpzb2_wyat.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        count += 1;\n        index += index_of_substring.unwrap()\
    \ + 1;\n        string = string[index..].to_string();\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmppz8o2bgw.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut slice = &string[start..end];\n    while\
    \ slice.contains(&substring) {\n        count += 1;\n        start += 1;\n   \
    \     end += 1;\n        slice = &string[start..end];\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 1 is out of bounds of ``'', /tmp/tmp6xrgb3e4.rs:6:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut found = false;\n    while end <= string.len()\
    \ {\n        if string[start..end] == substring {\n            count += 1;\n \
    \           found = true;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    if found {\n        count\n    } else {\n        -1\n    }\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `0`', /tmp/tmpl9f804cx.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for i in 0..substring.len()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if string.chars().nth(index + i).unwrap() != substring.chars().nth(i).unwrap()\
    \ {\n                break;\n            }\n            if i == substring.len()\
    \ - 1 {\n                found = true;\n            }\n        }\n        if found\
    \ {\n            count += 1;\n            index += substring.len();\n        }\
    \ else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpygxclf7u.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        if let Some(i)\
    \ = string.find(&substring) {\n            count += 1;\n            string = string[i\
    \ + substring.len()..].to_string();\n        } else {\n            break;\n  \
    \      }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1ooplymz.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut start = 0;\n    let string_length = string.len();\n    let substring_length\
    \ = substring.len();\n    let mut string_chars = string.chars();\n    let mut\
    \ substring_chars = substring.chars();\n    let mut string_char;\n    let mut\
    \ substring_char;\n    loop {\n        string_char = string_chars.nth(index);\n\
    \        substring_char = substring_chars.nth(index);\n        if string_char\
    \ == None || substring_char == None {\n            break;\n        }\n       \
    \ if string_char != substring_char {\n            index = 0;\n            start\
    \ += 1;\n            string_chars = string.chars().skip(start);\n            substring_chars\
    \ = substring.chars();\n        } else {\n            index += 1;\n          \
    \  if index == substring_length {\n                count += 1;\n             \
    \   index = 0;\n                start += 1;\n                string_chars = string.chars().skip(start);\n\
    \                substring_chars = substring.chars();\n            }\n       \
    \ }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp80q6xpdg.rs:21:28\n   |\n\
    21 |             string_chars = string.chars().skip(start);\n   |            \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Chars`, found struct\
    \ `Skip`\n   |\n   = note: expected struct `Chars<'_>`\n              found struct\
    \ `Skip<Chars<'_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp80q6xpdg.rs:29:32\n\
    \   |\n29 |                 string_chars = string.chars().skip(start);\n   | \
    \                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Chars`,\
    \ found struct `Skip`\n   |\n   = note: expected struct `Chars<'_>`\n        \
    \      found struct `Skip<Chars<'_>>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n    while end <= string_len {\n        if string[start..end]\
    \ == substring {\n            count += 1;\n            start += 1;\n         \
    \   end += 1;\n        } else {\n            start += 1;\n            end += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let pos = string.find(&substring);\n\
    \        if pos.is_none() {\n            break;\n        }\n        count += 1;\n\
    \        index += pos.unwrap() + substring.len();\n        string = string[index..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpq9utajy2.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        index = index_of_substring.unwrap();\n   \
    \     count += 1;\n        string = string[index + substring.len()..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp8l9wjhct.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut index = 0;\n    let string_len = string.len();\n    let substring_len =\
    \ substring.len();\n    while start < string_len {\n        index = string[start..].find(&substring);\n\
    \        if index.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        start += index.unwrap() + substring_len;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9smwu6qn.rs:9:17\n  |\n9 |\
    \         index = string[start..].find(&substring);\n  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n  |\n  = note: expected type `{integer}`\n\
    \             found enum `Option<usize>`\n\nerror[E0599]: no method named `is_none`\
    \ found for type `{integer}` in the current scope\n  --> /tmp/tmp9smwu6qn.rs:10:18\n\
    \   |\n10 |         if index.is_none() {\n   |                  ^^^^^^^ method\
    \ not found in `{integer}`\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `{integer}` in the current scope\n  --> /tmp/tmp9smwu6qn.rs:14:24\n   |\n\
    14 |         start += index.unwrap() + substring_len;\n   |                  \
    \      ^^^^^^ method not found in `{integer}`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for (i, c) in\
    \ substring.chars().enumerate() {\n            if string.chars().nth(index + i)\
    \ == Some(c) {\n                found = true;\n            } else {\n        \
    \        found = false;\n                break;\n            }\n        }\n  \
    \      if found {\n            count += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpy5mlfy7g.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut found = false;\n        for i in 0..substring.len()\
    \ {\n            if index + i < string.len() && string.chars().nth(index + i).unwrap()\
    \ == substring.chars().nth(i).unwrap() {\n                found = true;\n    \
    \        } else {\n                found = false;\n                break;\n  \
    \          }\n        }\n        if found {\n            count += 1;\n       \
    \     index += substring.len();\n        } else {\n            index += 1;\n \
    \       }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpias2ebkb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    while end <= string.len() {\n        if string[start..end]\
    \ == substring {\n            count += 1;\n        }\n        start += 1;\n  \
    \      end += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut found = true;\n    while found {\n \
    \       found = false;\n        for i in start..end {\n            if string.chars().nth(i).unwrap()\
    \ == substring.chars().nth(i - start).unwrap() {\n                found = true;\n\
    \            } else {\n                found = false;\n                break;\n\
    \            }\n        }\n        if found {\n            count += 1;\n     \
    \       start += 1;\n            end += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpghhkaql1.rs:10:38

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut substring_char = substring_chars.next();\n    let mut string_char\
    \ = string_chars.next();\n    while string_char != None {\n        if string_char\
    \ == substring_char {\n            index += 1;\n            substring_char = substring_chars.next();\n\
    \            if substring_char == None {\n                count += 1;\n      \
    \          substring_char = substring_chars.next();\n                index = 0;\n\
    \            }\n        } else {\n            substring_char = substring.chars().nth(index);\n\
    \            index = 0;\n        }\n        string_char = string_chars.next();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_len = substring.len();\n    while index\
    \ < string.len() {\n        let index_of_substring = string.find(&substring);\n\
    \        if index_of_substring.is_some() {\n            count += 1;\n        \
    \    index += index_of_substring.unwrap() + substring_len;\n            string\
    \ = string[index_of_substring.unwrap() + substring_len..].to_string();\n     \
    \   } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpi3rmazxq.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while let Some(pos) = string.find(&substring) {\n\
    \        count += 1;\n        index += pos + 1;\n        string = string[index..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    /tmp/tmpc10328pu.rs:9:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        if let Some(i) = string[index..].find(&substring)\
    \ {\n            count += 1;\n            index += i + substring.len();\n    \
    \    } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl78jot_2.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ let Some(i) = string[index..].find(&substring) {\n        count += 1;\n    \
    \    index = index + i + 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let substring_chars = substring.chars();\n\
    \    while let Some(c) = string_chars.next() {\n        if c == substring_chars.clone().nth(index).unwrap()\
    \ {\n            index += 1;\n            if index == substring.len() {\n    \
    \            count += 1;\n                index = 0;\n            }\n        }\
    \ else {\n            index = 0;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpzda7r7os.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut last_index = 0;\n    while index < string.len() {\n        if string[index..].starts_with(&substring)\
    \ {\n            count += 1;\n            last_index = index;\n            index\
    \ += substring.len();\n        } else {\n            index += 1;\n        }\n\
    \    }\n    if last_index + substring.len() == string.len() {\n        count -=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpzkv8m1by.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    loop\
    \ {\n        match string[start..].find(&substring) {\n            Some(index)\
    \ => {\n                count += 1;\n                start = start + index + 1;\n\
    \            }\n            None => break,\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    let substring_len = substring.len();\n    while let\
    \ Some(i) = string.find(&substring) {\n        count += 1;\n        index += i\
    \ + substring_len;\n        string = string[index..].to_string();\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    /tmp/tmpf8r20o68.rs:10:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut substring_char = substring_chars.next();\n    let mut string_char\
    \ = string_chars.next();\n    while string_char != None {\n        if string_char\
    \ == substring_char {\n            if substring_chars.clone().count() == 0 {\n\
    \                count += 1;\n                substring_chars = substring.chars();\n\
    \                substring_char = substring_chars.next();\n            } else\
    \ {\n                substring_char = substring_chars.next();\n            }\n\
    \        } else {\n            substring_chars = substring.chars();\n        \
    \    substring_char = substring_chars.next();\n        }\n        string_char\
    \ = string_chars.next();\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp0wc1crci.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut string = string;\n    while end <= string.len()\
    \ {\n        if string[start..end] == substring {\n            count += 1;\n \
    \           start += 1;\n            end += 1;\n        } else {\n           \
    \ start += 1;\n            end += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index_of_substring\
    \ = string.find(&substring);\n        if index_of_substring.is_none() {\n    \
    \        break;\n        }\n        let index_of_substring = index_of_substring.unwrap();\n\
    \        count += 1;\n        string = string[index_of_substring + substring.len()..].to_string();\n\
    \        index += index_of_substring + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpwv1kb01x.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while index < string.len() {\n        let index =\
    \ string.find(&substring);\n        if index.is_none() {\n            break;\n\
    \        }\n        count += 1;\n        string = string.chars().skip(index.unwrap()\
    \ + substring.len()).collect();\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5ikuo3j5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    while let Some(i) = string.find(&substring) {\n  \
    \      count += 1;\n        index += i + 1;\n        string = string[index..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    /tmp/tmpow_x2n6y.rs:9:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        if let Some(i) = string[index..].find(&substring)\
    \ {\n            count += 1;\n            index += i + substring.len();\n    \
    \    } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl78jot_2.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let found = string[index..].find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index += found.unwrap() + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5djtynv_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
