language: rs
name: HumanEval_105_by_length
results:
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i == 1 {\n            result.push(\"\
    One\".to_string());\n        } else if i == 2 {\n            result.push(\"Two\"\
    .to_string());\n        } else if i == 3 {\n            result.push(\"Three\"\
    .to_string());\n        } else if i == 4 {\n            result.push(\"Four\".to_string());\n\
    \        } else if i == 5 {\n            result.push(\"Five\".to_string());\n\
    \        } else if i == 6 {\n            result.push(\"Six\".to_string());\n \
    \       } else if i == 7 {\n            result.push(\"Seven\".to_string());\n\
    \        } else if i == 8 {\n            result.push(\"Eight\".to_string());\n\
    \        } else if i == 9 {\n            result.push(\"Nine\".to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res = arr.iter().filter(|&x| x > &0 && x < &10).map(|&x| x.to_string()).collect::<Vec<String>>();\n\
    \    res.sort();\n    res.reverse();\n    res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp9as9ozie.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6gy6ffs9.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6gy6ffs9.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res: Vec<String> = vec![];\n    for i in arr {\n        if i > 0 &&\
    \ i < 10 {\n            res.push(i.to_string());\n        }\n    }\n    res.sort();\n\
    \    res.reverse();\n    for i in 0..res.len() {\n        match res[i].as_ref()\
    \ {\n            \"1\" => res[i] = \"One\".to_string(),\n            \"2\" =>\
    \ res[i] = \"Two\".to_string(),\n            \"3\" => res[i] = \"Three\".to_string(),\n\
    \            \"4\" => res[i] = \"Four\".to_string(),\n            \"5\" => res[i]\
    \ = \"Five\".to_string(),\n            \"6\" => res[i] = \"Six\".to_string(),\n\
    \            \"7\" => res[i] = \"Seven\".to_string(),\n            \"8\" => res[i]\
    \ = \"Eight\".to_string(),\n            \"9\" => res[i] = \"Nine\".to_string(),\n\
    \            _ => (),\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  match i {\n                1 => result.push(\"One\".to_string()),\n       \
    \         2 => result.push(\"Two\".to_string()),\n                3 => result.push(\"\
    Three\".to_string()),\n                4 => result.push(\"Four\".to_string()),\n\
    \                5 => result.push(\"Five\".to_string()),\n                6 =>\
    \ result.push(\"Six\".to_string()),\n                7 => result.push(\"Seven\"\
    .to_string()),\n                8 => result.push(\"Eight\".to_string()),\n   \
    \             9 => result.push(\"Nine\".to_string()),\n                _ => (),\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut res =\
    \ Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n            res.push(match\
    \ i {\n                1 => \"One\",\n                2 => \"Two\",\n        \
    \        3 => \"Three\",\n                4 => \"Four\",\n                5 =>\
    \ \"Five\",\n                6 => \"Six\",\n                7 => \"Seven\",\n\
    \                8 => \"Eight\",\n                9 => \"Nine\",\n           \
    \     _ => \"\",\n            }.to_string());\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res: Vec<String> = Vec::new();\n    for i in arr {\n        if i >\
    \ 0 && i < 10 {\n            res.push(i.to_string());\n        }\n    }\n    res.sort();\n\
    \    res.reverse();\n    for i in 0..res.len() {\n        match res[i].as_ref()\
    \ {\n            \"1\" => res[i] = \"One\".to_string(),\n            \"2\" =>\
    \ res[i] = \"Two\".to_string(),\n            \"3\" => res[i] = \"Three\".to_string(),\n\
    \            \"4\" => res[i] = \"Four\".to_string(),\n            \"5\" => res[i]\
    \ = \"Five\".to_string(),\n            \"6\" => res[i] = \"Six\".to_string(),\n\
    \            \"7\" => res[i] = \"Seven\".to_string(),\n            \"8\" => res[i]\
    \ = \"Eight\".to_string(),\n            \"9\" => res[i] = \"Nine\".to_string(),\n\
    \            _ => (),\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  result.push(match i {\n                1 => \"One\",\n                2 =>\
    \ \"Two\",\n                3 => \"Three\",\n                4 => \"Four\",\n\
    \                5 => \"Five\",\n                6 => \"Six\",\n             \
    \   7 => \"Seven\",\n                8 => \"Eight\",\n                9 => \"\
    Nine\",\n                _ => \"\",\n            }.to_string());\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().filter(|&x|\
    \ x >= &1 && x <= &9).map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i < 1 || i > 9 {\n           \
    \ continue;\n        }\n        result.push(match i {\n            1 => \"One\"\
    ,\n            2 => \"Two\",\n            3 => \"Three\",\n            4 => \"\
    Four\",\n            5 => \"Five\",\n            6 => \"Six\",\n            7\
    \ => \"Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n   \
    \         _ => \"\",\n        }.to_string());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => unreachable!(),\n\
    \    }).map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpk3d3qgo7.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| x.is_positive() && *x\
    \ < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmppn50im_g.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i < 1 || i > 9 {\n           \
    \ continue;\n        }\n        match i {\n            1 => result.push(\"One\"\
    .to_string()),\n            2 => result.push(\"Two\".to_string()),\n         \
    \   3 => result.push(\"Three\".to_string()),\n            4 => result.push(\"\
    Four\".to_string()),\n            5 => result.push(\"Five\".to_string()),\n  \
    \          6 => result.push(\"Six\".to_string()),\n            7 => result.push(\"\
    Seven\".to_string()),\n            8 => result.push(\"Eight\".to_string()),\n\
    \            9 => result.push(\"Nine\".to_string()),\n            _ => panic!(\"\
    This should never happen\"),\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut res =\
    \ Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n            res.push(match\
    \ i {\n                1 => \"One\",\n                2 => \"Two\",\n        \
    \        3 => \"Three\",\n                4 => \"Four\",\n                5 =>\
    \ \"Five\",\n                6 => \"Six\",\n                7 => \"Seven\",\n\
    \                8 => \"Eight\",\n                9 => \"Nine\",\n           \
    \     _ => \"\",\n            }.to_string());\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    let\
    \ mut res: Vec<String> = Vec::new();\n    for i in arr {\n        match i {\n\
    \            1 => res.push(\"One\".to_string()),\n            2 => res.push(\"\
    Two\".to_string()),\n            3 => res.push(\"Three\".to_string()),\n     \
    \       4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\"\
    .to_string()),\n            6 => res.push(\"Six\".to_string()),\n            7\
    \ => res.push(\"Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n\
    \            9 => res.push(\"Nine\".to_string()),\n            _ => (),\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i >= 1 && i <= 9 {\n         \
    \   result.push(match i {\n                1 => \"One\",\n                2 =>\
    \ \"Two\",\n                3 => \"Three\",\n                4 => \"Four\",\n\
    \                5 => \"Five\",\n                6 => \"Six\",\n             \
    \   7 => \"Seven\",\n                8 => \"Eight\",\n                9 => \"\
    Nine\",\n                _ => \"\",\n            }.to_string());\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().filter(|&x|\
    \ *x > 0 && *x < 10).map(|&x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp3mur5p__.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpk3d3qgo7.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().filter(|&x|\
    \ *x > 0 && *x < 10).map(|&x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().filter(|&x|\
    \ *x > 0 && *x < 10).map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmplmaqrd4m.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  match i {\n                1 => result.push(\"One\".to_string()),\n       \
    \         2 => result.push(\"Two\".to_string()),\n                3 => result.push(\"\
    Three\".to_string()),\n                4 => result.push(\"Four\".to_string()),\n\
    \                5 => result.push(\"Five\".to_string()),\n                6 =>\
    \ result.push(\"Six\".to_string()),\n                7 => result.push(\"Seven\"\
    .to_string()),\n                8 => result.push(\"Eight\".to_string()),\n   \
    \             9 => result.push(\"Nine\".to_string()),\n                _ => (),\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut res =\
    \ Vec::new();\n    for i in arr {\n        if i == 1 {\n            res.push(\"\
    One\".to_string());\n        } else if i == 2 {\n            res.push(\"Two\"\
    .to_string());\n        } else if i == 3 {\n            res.push(\"Three\".to_string());\n\
    \        } else if i == 4 {\n            res.push(\"Four\".to_string());\n   \
    \     } else if i == 5 {\n            res.push(\"Five\".to_string());\n      \
    \  } else if i == 6 {\n            res.push(\"Six\".to_string());\n        } else\
    \ if i == 7 {\n            res.push(\"Seven\".to_string());\n        } else if\
    \ i == 8 {\n            res.push(\"Eight\".to_string());\n        } else if i\
    \ == 9 {\n            res.push(\"Nine\".to_string());\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.clone();\n    result.sort();\n    result.reverse();\n\
    \    result.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  match i {\n                1 => result.push(\"One\".to_string()),\n       \
    \         2 => result.push(\"Two\".to_string()),\n                3 => result.push(\"\
    Three\".to_string()),\n                4 => result.push(\"Four\".to_string()),\n\
    \                5 => result.push(\"Five\".to_string()),\n                6 =>\
    \ result.push(\"Six\".to_string()),\n                7 => result.push(\"Seven\"\
    .to_string()),\n                8 => result.push(\"Eight\".to_string()),\n   \
    \             9 => result.push(\"Nine\".to_string()),\n                _ => panic!(\"\
    Unexpected value\"),\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    let\
    \ mut res: Vec<String> = Vec::new();\n    for i in arr {\n        match i {\n\
    \            1 => res.push(\"One\".to_string()),\n            2 => res.push(\"\
    Two\".to_string()),\n            3 => res.push(\"Three\".to_string()),\n     \
    \       4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\"\
    .to_string()),\n            6 => res.push(\"Six\".to_string()),\n            7\
    \ => res.push(\"Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n\
    \            9 => res.push(\"Nine\".to_string()),\n            _ => (),\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6gy6ffs9.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    let mut sorted_arr: Vec<isize>\
    \ = arr.clone();\n    sorted_arr.sort();\n    for i in sorted_arr {\n        if\
    \ i > 0 && i < 10 {\n            result.push(match i {\n                1 => \"\
    One\".to_string(),\n                2 => \"Two\".to_string(),\n              \
    \  3 => \"Three\".to_string(),\n                4 => \"Four\".to_string(),\n \
    \               5 => \"Five\".to_string(),\n                6 => \"Six\".to_string(),\n\
    \                7 => \"Seven\".to_string(),\n                8 => \"Eight\".to_string(),\n\
    \                9 => \"Nine\".to_string(),\n                _ => \"\".to_string(),\n\
    \            });\n        }\n    }\n    result.reverse();\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    let mut sorted_arr: Vec<isize>\
    \ = arr.clone();\n    sorted_arr.sort();\n    for i in sorted_arr {\n        if\
    \ i > 0 && i < 10 {\n            result.push(match i {\n                1 => \"\
    One\".to_string(),\n                2 => \"Two\".to_string(),\n              \
    \  3 => \"Three\".to_string(),\n                4 => \"Four\".to_string(),\n \
    \               5 => \"Five\".to_string(),\n                6 => \"Six\".to_string(),\n\
    \                7 => \"Seven\".to_string(),\n                8 => \"Eight\".to_string(),\n\
    \                9 => \"Nine\".to_string(),\n                _ => \"\".to_string(),\n\
    \            });\n        }\n    }\n    result.reverse();\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  result.push(match i {\n                1 => \"One\",\n                2 =>\
    \ \"Two\",\n                3 => \"Three\",\n                4 => \"Four\",\n\
    \                5 => \"Five\",\n                6 => \"Six\",\n             \
    \   7 => \"Seven\",\n                8 => \"Eight\",\n                9 => \"\
    Nine\",\n                _ => \"\",\n            }.to_string());\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    let mut sorted_arr: Vec<isize>\
    \ = arr.clone();\n    sorted_arr.sort();\n    for i in sorted_arr {\n        if\
    \ i >= 1 && i <= 9 {\n            result.push(match i {\n                1 =>\
    \ \"One\".to_string(),\n                2 => \"Two\".to_string(),\n          \
    \      3 => \"Three\".to_string(),\n                4 => \"Four\".to_string(),\n\
    \                5 => \"Five\".to_string(),\n                6 => \"Six\".to_string(),\n\
    \                7 => \"Seven\".to_string(),\n                8 => \"Eight\".to_string(),\n\
    \                9 => \"Nine\".to_string(),\n                _ => \"\".to_string(),\n\
    \            });\n        }\n    }\n    result.reverse();\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    let mut sorted_arr: Vec<isize>\
    \ = arr.clone();\n    sorted_arr.sort();\n    for i in sorted_arr {\n        if\
    \ i >= 1 && i <= 9 {\n            result.push(match i {\n                1 =>\
    \ \"One\".to_string(),\n                2 => \"Two\".to_string(),\n          \
    \      3 => \"Three\".to_string(),\n                4 => \"Four\".to_string(),\n\
    \                5 => \"Five\".to_string(),\n                6 => \"Six\".to_string(),\n\
    \                7 => \"Seven\".to_string(),\n                8 => \"Eight\".to_string(),\n\
    \                9 => \"Nine\".to_string(),\n                _ => \"\".to_string(),\n\
    \            });\n        }\n    }\n    result.reverse();\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().filter(|&x|\
    \ *x >= 1 && *x <= 9).map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res = arr.clone();\n    res.sort();\n    res.reverse();\n    let mut\
    \ res_str = Vec::new();\n    for i in res {\n        match i {\n            1\
    \ => res_str.push(\"One\".to_string()),\n            2 => res_str.push(\"Two\"\
    .to_string()),\n            3 => res_str.push(\"Three\".to_string()),\n      \
    \      4 => res_str.push(\"Four\".to_string()),\n            5 => res_str.push(\"\
    Five\".to_string()),\n            6 => res_str.push(\"Six\".to_string()),\n  \
    \          7 => res_str.push(\"Seven\".to_string()),\n            8 => res_str.push(\"\
    Eight\".to_string()),\n            9 => res_str.push(\"Nine\".to_string()),\n\
    \            _ => (),\n        }\n    }\n    res_str\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().filter(|&x|\
    \ *x > 0 && *x < 10).map(|&x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp3mur5p__.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = Vec::new();\n    let mut sorted = arr.clone();\n    sorted.sort();\n\
    \    for i in sorted {\n        if i > 0 && i < 10 {\n            result.push(i.to_string());\n\
    \        }\n    }\n    result.reverse();\n    for i in 0..result.len() {\n   \
    \     match result[i].as_ref() {\n            \"1\" => result[i] = \"One\".to_string(),\n\
    \            \"2\" => result[i] = \"Two\".to_string(),\n            \"3\" => result[i]\
    \ = \"Three\".to_string(),\n            \"4\" => result[i] = \"Four\".to_string(),\n\
    \            \"5\" => result[i] = \"Five\".to_string(),\n            \"6\" =>\
    \ result[i] = \"Six\".to_string(),\n            \"7\" => result[i] = \"Seven\"\
    .to_string(),\n            \"8\" => result[i] = \"Eight\".to_string(),\n     \
    \       \"9\" => result[i] = \"Nine\".to_string(),\n            _ => (),\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    for i in arr {\n        if i\
    \ > 0 && i < 10 {\n            result.push(i.to_string());\n        }\n    }\n\
    \    result.sort();\n    result.reverse();\n    for i in 0..result.len() {\n \
    \       match result[i].as_ref() {\n            \"1\" => result[i] = \"One\".to_string(),\n\
    \            \"2\" => result[i] = \"Two\".to_string(),\n            \"3\" => result[i]\
    \ = \"Three\".to_string(),\n            \"4\" => result[i] = \"Four\".to_string(),\n\
    \            \"5\" => result[i] = \"Five\".to_string(),\n            \"6\" =>\
    \ result[i] = \"Six\".to_string(),\n            \"7\" => result[i] = \"Seven\"\
    .to_string(),\n            \"8\" => result[i] = \"Eight\".to_string(),\n     \
    \       \"9\" => result[i] = \"Nine\".to_string(),\n            _ => result[i]\
    \ = \"\".to_string(),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    let mut sorted_arr: Vec<isize>\
    \ = arr.clone();\n    sorted_arr.sort();\n    for i in sorted_arr {\n        match\
    \ i {\n            1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => continue,\n        }\n    }\n    result.reverse();\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| x >= &1 && x <= &9).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\".to_string(),\n        2 => \"Two\".to_string(),\n      \
    \  3 => \"Three\".to_string(),\n        4 => \"Four\".to_string(),\n        5\
    \ => \"Five\".to_string(),\n        6 => \"Six\".to_string(),\n        7 => \"\
    Seven\".to_string(),\n        8 => \"Eight\".to_string(),\n        9 => \"Nine\"\
    .to_string(),\n        _ => \"\".to_string(),\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().filter(|&x|\
    \ *x >= 1 && *x <= 9).map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = Vec::new();\n    for i in arr {\n        if i < 1 || i > 9\
    \ {\n            continue;\n        }\n        result.push(i.to_string());\n \
    \   }\n    result.sort();\n    result.reverse();\n    result.iter().map(|x| match\
    \ x.as_ref() {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n       \
    \ \"3\" => \"Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n\
    \        \"6\" => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\"\
    ,\n        \"9\" => \"Nine\",\n        _ => \"\",\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpiogdgvca.rs:32:8\n   |\n32 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    let\
    \ mut result: Vec<String> = Vec::new();\n    for i in arr {\n        match i {\n\
    \            1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6gy6ffs9.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    for i in arr {\n        if i\
    \ > 0 && i < 10 {\n            result.push(i.to_string());\n        }\n    }\n\
    \    result.sort();\n    result.reverse();\n    for i in 0..result.len() {\n \
    \       match result[i].as_ref() {\n            \"1\" => result[i] = \"One\".to_string(),\n\
    \            \"2\" => result[i] = \"Two\".to_string(),\n            \"3\" => result[i]\
    \ = \"Three\".to_string(),\n            \"4\" => result[i] = \"Four\".to_string(),\n\
    \            \"5\" => result[i] = \"Five\".to_string(),\n            \"6\" =>\
    \ result[i] = \"Six\".to_string(),\n            \"7\" => result[i] = \"Seven\"\
    .to_string(),\n            \"8\" => result[i] = \"Eight\".to_string(),\n     \
    \       \"9\" => result[i] = \"Nine\".to_string(),\n            _ => {},\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2mtkr6hi.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut res =\
    \ Vec::new();\n    for i in arr {\n        match i {\n            1 => res.push(\"\
    One\".to_string()),\n            2 => res.push(\"Two\".to_string()),\n       \
    \     3 => res.push(\"Three\".to_string()),\n            4 => res.push(\"Four\"\
    .to_string()),\n            5 => res.push(\"Five\".to_string()),\n           \
    \ 6 => res.push(\"Six\".to_string()),\n            7 => res.push(\"Seven\".to_string()),\n\
    \            8 => res.push(\"Eight\".to_string()),\n            9 => res.push(\"\
    Nine\".to_string()),\n            _ => (),\n        }\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6gy6ffs9.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n    let mut result\
    \ = Vec::new();\n    for i in sorted_arr {\n        if i < 1 || i > 9 {\n    \
    \        continue;\n        }\n        result.push(i.to_string());\n    }\n  \
    \  result.reverse();\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmptvztdxok.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    let\
    \ mut result: Vec<String> = Vec::new();\n    for i in arr {\n        match i {\n\
    \            1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.clone();\n    result.sort();\n    result.reverse();\n\
    \    let mut result_string: Vec<String> = vec![];\n    for i in result {\n   \
    \     if i == 1 {\n            result_string.push(\"One\".to_string());\n    \
    \    } else if i == 2 {\n            result_string.push(\"Two\".to_string());\n\
    \        } else if i == 3 {\n            result_string.push(\"Three\".to_string());\n\
    \        } else if i == 4 {\n            result_string.push(\"Four\".to_string());\n\
    \        } else if i == 5 {\n            result_string.push(\"Five\".to_string());\n\
    \        } else if i == 6 {\n            result_string.push(\"Six\".to_string());\n\
    \        } else if i == 7 {\n            result_string.push(\"Seven\".to_string());\n\
    \        } else if i == 8 {\n            result_string.push(\"Eight\".to_string());\n\
    \        } else if i == 9 {\n            result_string.push(\"Nine\".to_string());\n\
    \        }\n    }\n    result_string\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    let\
    \ mut res: Vec<String> = Vec::new();\n    for i in arr {\n        if i == 1 {\n\
    \            res.push(\"One\".to_string());\n        } else if i == 2 {\n    \
    \        res.push(\"Two\".to_string());\n        } else if i == 3 {\n        \
    \    res.push(\"Three\".to_string());\n        } else if i == 4 {\n          \
    \  res.push(\"Four\".to_string());\n        } else if i == 5 {\n            res.push(\"\
    Five\".to_string());\n        } else if i == 6 {\n            res.push(\"Six\"\
    .to_string());\n        } else if i == 7 {\n            res.push(\"Seven\".to_string());\n\
    \        } else if i == 8 {\n            res.push(\"Eight\".to_string());\n  \
    \      } else if i == 9 {\n            res.push(\"Nine\".to_string());\n     \
    \   }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut res =\
    \ Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n            res.push(i.to_string());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp309p88jo.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    let mut result = Vec::new();\n   \
    \ for i in arr {\n        if i >= 1 && i <= 9 {\n            result.push(i.to_string());\n\
    \        }\n    }\n    result.reverse();\n    for i in 0..result.len() {\n   \
    \     match result[i].as_ref() {\n            \"1\" => result[i] = \"One\".to_string(),\n\
    \            \"2\" => result[i] = \"Two\".to_string(),\n            \"3\" => result[i]\
    \ = \"Three\".to_string(),\n            \"4\" => result[i] = \"Four\".to_string(),\n\
    \            \"5\" => result[i] = \"Five\".to_string(),\n            \"6\" =>\
    \ result[i] = \"Six\".to_string(),\n            \"7\" => result[i] = \"Seven\"\
    .to_string(),\n            \"8\" => result[i] = \"Eight\".to_string(),\n     \
    \       \"9\" => result[i] = \"Nine\".to_string(),\n            _ => (),\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  result.push(i.to_string());\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmphpw9mmyy.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted = arr.clone();\n    sorted.sort();\n    sorted.reverse();\n\
    \    let mut res = Vec::new();\n    for i in sorted {\n        match i {\n   \
    \         1 => res.push(\"One\".to_string()),\n            2 => res.push(\"Two\"\
    .to_string()),\n            3 => res.push(\"Three\".to_string()),\n          \
    \  4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\".to_string()),\n\
    \            6 => res.push(\"Six\".to_string()),\n            7 => res.push(\"\
    Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n   \
    \         9 => res.push(\"Nine\".to_string()),\n            _ => (),\n       \
    \ }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i >= 1 && i <= 9 {\n         \
    \   result.push(match i {\n                1 => \"One\",\n                2 =>\
    \ \"Two\",\n                3 => \"Three\",\n                4 => \"Four\",\n\
    \                5 => \"Five\",\n                6 => \"Six\",\n             \
    \   7 => \"Seven\",\n                8 => \"Eight\",\n                9 => \"\
    Nine\",\n                _ => \"\",\n            }.to_string());\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        match i {\n            1 => result.push(\"\
    One\".to_string()),\n            2 => result.push(\"Two\".to_string()),\n    \
    \        3 => result.push(\"Three\".to_string()),\n            4 => result.push(\"\
    Four\".to_string()),\n            5 => result.push(\"Five\".to_string()),\n  \
    \          6 => result.push(\"Six\".to_string()),\n            7 => result.push(\"\
    Seven\".to_string()),\n            8 => result.push(\"Eight\".to_string()),\n\
    \            9 => result.push(\"Nine\".to_string()),\n            _ => continue,\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    let mut sorted_arr: Vec<isize>\
    \ = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n    for i\
    \ in sorted_arr {\n        if i > 0 && i < 10 {\n            result.push(match\
    \ i {\n                1 => \"One\".to_string(),\n                2 => \"Two\"\
    .to_string(),\n                3 => \"Three\".to_string(),\n                4\
    \ => \"Four\".to_string(),\n                5 => \"Five\".to_string(),\n     \
    \           6 => \"Six\".to_string(),\n                7 => \"Seven\".to_string(),\n\
    \                8 => \"Eight\".to_string(),\n                9 => \"Nine\".to_string(),\n\
    \                _ => \"\".to_string(),\n            });\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6gy6ffs9.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    for i in arr {\n        if i\
    \ > 0 && i < 10 {\n            result.push(i.to_string());\n        }\n    }\n\
    \    result.sort();\n    result.reverse();\n    for i in 0..result.len() {\n \
    \       match result[i].as_ref() {\n            \"1\" => result[i] = \"One\".to_string(),\n\
    \            \"2\" => result[i] = \"Two\".to_string(),\n            \"3\" => result[i]\
    \ = \"Three\".to_string(),\n            \"4\" => result[i] = \"Four\".to_string(),\n\
    \            \"5\" => result[i] = \"Five\".to_string(),\n            \"6\" =>\
    \ result[i] = \"Six\".to_string(),\n            \"7\" => result[i] = \"Seven\"\
    .to_string(),\n            \"8\" => result[i] = \"Eight\".to_string(),\n     \
    \       \"9\" => result[i] = \"Nine\".to_string(),\n            _ => (),\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  match i {\n                1 => result.push(\"One\".to_string()),\n       \
    \         2 => result.push(\"Two\".to_string()),\n                3 => result.push(\"\
    Three\".to_string()),\n                4 => result.push(\"Four\".to_string()),\n\
    \                5 => result.push(\"Five\".to_string()),\n                6 =>\
    \ result.push(\"Six\".to_string()),\n                7 => result.push(\"Seven\"\
    .to_string()),\n                8 => result.push(\"Eight\".to_string()),\n   \
    \             9 => result.push(\"Nine\".to_string()),\n                _ => (),\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2mtkr6hi.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6gy6ffs9.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i < 1 || i > 9 {\n           \
    \ continue;\n        }\n        result.push(match i {\n            1 => \"One\"\
    ,\n            2 => \"Two\",\n            3 => \"Three\",\n            4 => \"\
    Four\",\n            5 => \"Five\",\n            6 => \"Six\",\n            7\
    \ => \"Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n   \
    \         _ => \"\",\n        }.to_string());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6gy6ffs9.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  result.push(match i {\n                1 => \"One\",\n                2 =>\
    \ \"Two\",\n                3 => \"Three\",\n                4 => \"Four\",\n\
    \                5 => \"Five\",\n                6 => \"Six\",\n             \
    \   7 => \"Seven\",\n                8 => \"Eight\",\n                9 => \"\
    Nine\",\n                _ => \"\",\n            }.to_string());\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmphu7q54o7.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.clone();\n    result.sort();\n    result.reverse();\n\
    \    result.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = vec![];\n    let mut sorted = arr.clone();\n    sorted.sort();\n\
    \    for i in sorted {\n        if i < 1 || i > 9 {\n            continue;\n \
    \       }\n        result.push(match i {\n            1 => \"One\",\n        \
    \    2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\",\n\
    \            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"Seven\"\
    ,\n            8 => \"Eight\",\n            9 => \"Nine\",\n            _ => \"\
    \",\n        }.to_string());\n    }\n    result.reverse();\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    let mut sorted_arr: Vec<isize>\
    \ = arr.clone();\n    sorted_arr.sort();\n    for i in sorted_arr {\n        if\
    \ i > 0 && i < 10 {\n            result.push(match i {\n                1 => \"\
    One\".to_string(),\n                2 => \"Two\".to_string(),\n              \
    \  3 => \"Three\".to_string(),\n                4 => \"Four\".to_string(),\n \
    \               5 => \"Five\".to_string(),\n                6 => \"Six\".to_string(),\n\
    \                7 => \"Seven\".to_string(),\n                8 => \"Eight\".to_string(),\n\
    \                9 => \"Nine\".to_string(),\n                _ => \"\".to_string(),\n\
    \            });\n        }\n    }\n    result.reverse();\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  match i {\n                1 => result.push(\"One\".to_string()),\n       \
    \         2 => result.push(\"Two\".to_string()),\n                3 => result.push(\"\
    Three\".to_string()),\n                4 => result.push(\"Four\".to_string()),\n\
    \                5 => result.push(\"Five\".to_string()),\n                6 =>\
    \ result.push(\"Six\".to_string()),\n                7 => result.push(\"Seven\"\
    .to_string()),\n                8 => result.push(\"Eight\".to_string()),\n   \
    \             9 => result.push(\"Nine\".to_string()),\n                _ => (),\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  match i {\n                1 => result.push(\"One\".to_string()),\n       \
    \         2 => result.push(\"Two\".to_string()),\n                3 => result.push(\"\
    Three\".to_string()),\n                4 => result.push(\"Four\".to_string()),\n\
    \                5 => result.push(\"Five\".to_string()),\n                6 =>\
    \ result.push(\"Six\".to_string()),\n                7 => result.push(\"Seven\"\
    .to_string()),\n                8 => result.push(\"Eight\".to_string()),\n   \
    \             9 => result.push(\"Nine\".to_string()),\n                _ => (),\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => panic!(\"\
    Should not happen\"),\n    }).map(|x| x.to_string()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| *x != \"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    let\
    \ mut result: Vec<String> = Vec::new();\n    for i in arr {\n        match i {\n\
    \            1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().filter(|&x|\
    \ x >= 1 && x <= 9).map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpthj8lrhm.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpxfq2cj0o.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().filter(|&x|\
    \ *x >= 1 && *x <= 9).map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res: Vec<String> = Vec::new();\n    let mut arr_sort: Vec<isize> =\
    \ Vec::new();\n    for i in arr {\n        if i >= 1 && i <= 9 {\n           \
    \ arr_sort.push(i);\n        }\n    }\n    arr_sort.sort();\n    arr_sort.reverse();\n\
    \    for i in arr_sort {\n        match i {\n            1 => res.push(\"One\"\
    .to_string()),\n            2 => res.push(\"Two\".to_string()),\n            3\
    \ => res.push(\"Three\".to_string()),\n            4 => res.push(\"Four\".to_string()),\n\
    \            5 => res.push(\"Five\".to_string()),\n            6 => res.push(\"\
    Six\".to_string()),\n            7 => res.push(\"Seven\".to_string()),\n     \
    \       8 => res.push(\"Eight\".to_string()),\n            9 => res.push(\"Nine\"\
    .to_string()),\n            _ => (),\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n    let mut result\
    \ = Vec::new();\n    for i in sorted_arr {\n        if i > 0 && i < 10 {\n   \
    \         result.push(i.to_string());\n        }\n    }\n    result.reverse();\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpez12y904.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749479
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res: Vec<String> = Vec::new();\n    let mut sorted_arr: Vec<isize>\
    \ = arr.clone();\n    sorted_arr.sort();\n    for i in sorted_arr {\n        if\
    \ i > 0 && i < 10 {\n            res.push(match i {\n                1 => \"One\"\
    .to_string(),\n                2 => \"Two\".to_string(),\n                3 =>\
    \ \"Three\".to_string(),\n                4 => \"Four\".to_string(),\n       \
    \         5 => \"Five\".to_string(),\n                6 => \"Six\".to_string(),\n\
    \                7 => \"Seven\".to_string(),\n                8 => \"Eight\".to_string(),\n\
    \                9 => \"Nine\".to_string(),\n                _ => \"\".to_string(),\n\
    \            });\n        }\n    }\n    res.reverse();\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| x > &0 && x < &10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmph2cda_mz.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.clone();\n    result.sort();\n    result.reverse();\n\
    \    result.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    let mut sorted_arr: Vec<isize>\
    \ = arr.clone();\n    sorted_arr.sort();\n    for i in sorted_arr {\n        if\
    \ i > 0 && i < 10 {\n            result.push(match i {\n                1 => \"\
    One\".to_string(),\n                2 => \"Two\".to_string(),\n              \
    \  3 => \"Three\".to_string(),\n                4 => \"Four\".to_string(),\n \
    \               5 => \"Five\".to_string(),\n                6 => \"Six\".to_string(),\n\
    \                7 => \"Seven\".to_string(),\n                8 => \"Eight\".to_string(),\n\
    \                9 => \"Nine\".to_string(),\n                _ => \"\".to_string(),\n\
    \            });\n        }\n    }\n    result.reverse();\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| x as usize).collect::<Vec<usize>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|&x| match x\
    \ {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n \
    \       4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n      \
    \  7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _\
    \ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().filter(|&x|\
    \ x >= 1 && x <= 9).map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmplpt1sepl.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted = arr.clone();\n    sorted.sort();\n    let mut result = Vec::new();\n\
    \    for i in sorted {\n        if i > 0 && i < 10 {\n            result.push(i.to_string());\n\
    \        }\n    }\n    result.reverse();\n    for i in 0..result.len() {\n   \
    \     match result[i].as_ref() {\n            \"1\" => result[i] = \"One\".to_string(),\n\
    \            \"2\" => result[i] = \"Two\".to_string(),\n            \"3\" => result[i]\
    \ = \"Three\".to_string(),\n            \"4\" => result[i] = \"Four\".to_string(),\n\
    \            \"5\" => result[i] = \"Five\".to_string(),\n            \"6\" =>\
    \ result[i] = \"Six\".to_string(),\n            \"7\" => result[i] = \"Seven\"\
    .to_string(),\n            \"8\" => result[i] = \"Eight\".to_string(),\n     \
    \       \"9\" => result[i] = \"Nine\".to_string(),\n            _ => (),\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp1h5x99u1.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res: Vec<String> = Vec::new();\n    let mut arr_sorted: Vec<isize>\
    \ = arr.clone();\n    arr_sorted.sort();\n    for i in arr_sorted {\n        if\
    \ i > 0 && i < 10 {\n            res.push(match i {\n                1 => \"One\"\
    .to_string(),\n                2 => \"Two\".to_string(),\n                3 =>\
    \ \"Three\".to_string(),\n                4 => \"Four\".to_string(),\n       \
    \         5 => \"Five\".to_string(),\n                6 => \"Six\".to_string(),\n\
    \                7 => \"Seven\".to_string(),\n                8 => \"Eight\".to_string(),\n\
    \                9 => \"Nine\".to_string(),\n                _ => \"\".to_string(),\n\
    \            });\n        }\n    }\n    res.reverse();\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2mtkr6hi.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().filter(|&x|\
    \ *x > 0 && *x < 10).map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6gy6ffs9.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| x as usize).collect::<Vec<usize>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|&x| match x\
    \ {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n \
    \       4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n      \
    \  7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _\
    \ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut res =\
    \ Vec::new();\n    for i in arr {\n        if i == 1 {\n            res.push(\"\
    One\".to_string());\n        } else if i == 2 {\n            res.push(\"Two\"\
    .to_string());\n        } else if i == 3 {\n            res.push(\"Three\".to_string());\n\
    \        } else if i == 4 {\n            res.push(\"Four\".to_string());\n   \
    \     } else if i == 5 {\n            res.push(\"Five\".to_string());\n      \
    \  } else if i == 6 {\n            res.push(\"Six\".to_string());\n        } else\
    \ if i == 7 {\n            res.push(\"Seven\".to_string());\n        } else if\
    \ i == 8 {\n            res.push(\"Eight\".to_string());\n        } else if i\
    \ == 9 {\n            res.push(\"Nine\".to_string());\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6gy6ffs9.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpxfq2cj0o.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6gy6ffs9.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i == 1 {\n            result.push(\"\
    One\".to_string());\n        } else if i == 2 {\n            result.push(\"Two\"\
    .to_string());\n        } else if i == 3 {\n            result.push(\"Three\"\
    .to_string());\n        } else if i == 4 {\n            result.push(\"Four\".to_string());\n\
    \        } else if i == 5 {\n            result.push(\"Five\".to_string());\n\
    \        } else if i == 6 {\n            result.push(\"Six\".to_string());\n \
    \       } else if i == 7 {\n            result.push(\"Seven\".to_string());\n\
    \        } else if i == 8 {\n            result.push(\"Eight\".to_string());\n\
    \        } else if i == 9 {\n            result.push(\"Nine\".to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    for i in arr {\n        if i\
    \ > 0 && i < 10 {\n            result.push(i.to_string());\n        }\n    }\n\
    \    result.sort();\n    result.reverse();\n    for i in 0..result.len() {\n \
    \       match result[i].as_ref() {\n            \"1\" => result[i] = \"One\".to_string(),\n\
    \            \"2\" => result[i] = \"Two\".to_string(),\n            \"3\" => result[i]\
    \ = \"Three\".to_string(),\n            \"4\" => result[i] = \"Four\".to_string(),\n\
    \            \"5\" => result[i] = \"Five\".to_string(),\n            \"6\" =>\
    \ result[i] = \"Six\".to_string(),\n            \"7\" => result[i] = \"Seven\"\
    .to_string(),\n            \"8\" => result[i] = \"Eight\".to_string(),\n     \
    \       \"9\" => result[i] = \"Nine\".to_string(),\n            _ => ()\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().filter(|x|\
    \ **x < 10 && **x > 0).map(|x| match x {\n        1 => \"One\",\n        2 =>\
    \ \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i == 1 {\n            result.push(\"\
    One\".to_string());\n        } else if i == 2 {\n            result.push(\"Two\"\
    .to_string());\n        } else if i == 3 {\n            result.push(\"Three\"\
    .to_string());\n        } else if i == 4 {\n            result.push(\"Four\".to_string());\n\
    \        } else if i == 5 {\n            result.push(\"Five\".to_string());\n\
    \        } else if i == 6 {\n            result.push(\"Six\".to_string());\n \
    \       } else if i == 7 {\n            result.push(\"Seven\".to_string());\n\
    \        } else if i == 8 {\n            result.push(\"Eight\".to_string());\n\
    \        } else if i == 9 {\n            result.push(\"Nine\".to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.clone();\n    result.sort();\n    result.reverse();\n\
    \    result.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.iter().filter(|&x| x >= &1 && x <= &9).map(|&x| x as usize).collect::<Vec<usize>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|&x| match x\
    \ {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n \
    \       4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n      \
    \  7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _\
    \ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut res: Vec<String>\
    \ = Vec::new();\n    for i in arr {\n        if i >= 1 && i <= 9 {\n         \
    \   match i {\n                1 => res.push(\"One\".to_string()),\n         \
    \       2 => res.push(\"Two\".to_string()),\n                3 => res.push(\"\
    Three\".to_string()),\n                4 => res.push(\"Four\".to_string()),\n\
    \                5 => res.push(\"Five\".to_string()),\n                6 => res.push(\"\
    Six\".to_string()),\n                7 => res.push(\"Seven\".to_string()),\n \
    \               8 => res.push(\"Eight\".to_string()),\n                9 => res.push(\"\
    Nine\".to_string()),\n                _ => (),\n            }\n        }\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    let mut sorted_arr: Vec<isize>\
    \ = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n    for i\
    \ in sorted_arr {\n        match i {\n            1 => result.push(\"One\".to_string()),\n\
    \            2 => result.push(\"Two\".to_string()),\n            3 => result.push(\"\
    Three\".to_string()),\n            4 => result.push(\"Four\".to_string()),\n \
    \           5 => result.push(\"Five\".to_string()),\n            6 => result.push(\"\
    Six\".to_string()),\n            7 => result.push(\"Seven\".to_string()),\n  \
    \          8 => result.push(\"Eight\".to_string()),\n            9 => result.push(\"\
    Nine\".to_string()),\n            _ => (),\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| x as usize).collect::<Vec<usize>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|&x| match x\
    \ {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n \
    \       4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n      \
    \  7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _\
    \ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  match i {\n                1 => result.push(\"One\".to_string()),\n       \
    \         2 => result.push(\"Two\".to_string()),\n                3 => result.push(\"\
    Three\".to_string()),\n                4 => result.push(\"Four\".to_string()),\n\
    \                5 => result.push(\"Five\".to_string()),\n                6 =>\
    \ result.push(\"Six\".to_string()),\n                7 => result.push(\"Seven\"\
    .to_string()),\n                8 => result.push(\"Eight\".to_string()),\n   \
    \             9 => result.push(\"Nine\".to_string()),\n                _ => (),\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted = arr.clone();\n    sorted.sort();\n    let mut result = Vec::new();\n\
    \    for num in sorted {\n        if num >= 1 && num <= 9 {\n            result.push(num_to_string(num));\n\
    \        }\n    }\n    result.reverse();\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num_to_string` in this scope\n  -->\
    \ /tmp/tmp9ohnl___.rs:17:25\n   |\n17 |             result.push(num_to_string(num));\n\
    \   |                         ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut res =\
    \ Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n            match\
    \ i {\n                1 => res.push(\"One\".to_string()),\n                2\
    \ => res.push(\"Two\".to_string()),\n                3 => res.push(\"Three\".to_string()),\n\
    \                4 => res.push(\"Four\".to_string()),\n                5 => res.push(\"\
    Five\".to_string()),\n                6 => res.push(\"Six\".to_string()),\n  \
    \              7 => res.push(\"Seven\".to_string()),\n                8 => res.push(\"\
    Eight\".to_string()),\n                9 => res.push(\"Nine\".to_string()),\n\
    \                _ => (),\n            }\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().filter(|x|\
    \ **x > 0 && **x < 10).map(|x| x.to_string()).collect()\n}\n\nfn main() {\n  \
    \  let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpnok0uo80.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res: Vec<String> = Vec::new();\n    let mut sorted: Vec<isize> = arr.clone();\n\
    \    sorted.sort();\n    for i in sorted {\n        if i < 1 || i > 9 {\n    \
    \        continue;\n        }\n        match i {\n            1 => res.push(\"\
    One\".to_string()),\n            2 => res.push(\"Two\".to_string()),\n       \
    \     3 => res.push(\"Three\".to_string()),\n            4 => res.push(\"Four\"\
    .to_string()),\n            5 => res.push(\"Five\".to_string()),\n           \
    \ 6 => res.push(\"Six\".to_string()),\n            7 => res.push(\"Seven\".to_string()),\n\
    \            8 => res.push(\"Eight\".to_string()),\n            9 => res.push(\"\
    Nine\".to_string()),\n            _ => continue,\n        }\n    }\n    res.reverse();\n\
    \    res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n    let mut result:\
    \ Vec<String> = Vec::new();\n    for i in sorted_arr {\n        if i >= 1 && i\
    \ <= 9 {\n            result.push(match i {\n                1 => \"One\".to_string(),\n\
    \                2 => \"Two\".to_string(),\n                3 => \"Three\".to_string(),\n\
    \                4 => \"Four\".to_string(),\n                5 => \"Five\".to_string(),\n\
    \                6 => \"Six\".to_string(),\n                7 => \"Seven\".to_string(),\n\
    \                8 => \"Eight\".to_string(),\n                9 => \"Nine\".to_string(),\n\
    \                _ => \"\".to_string(),\n            });\n        }\n    }\n \
    \   result.reverse();\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => panic!(\"\
    Unexpected number\"),\n    }).map(|x| x.to_string()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().filter(|&x|\
    \ *x >= 1 && *x <= 9).map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpb_1_0box.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  match i {\n                1 => result.push(\"One\".to_string()),\n       \
    \         2 => result.push(\"Two\".to_string()),\n                3 => result.push(\"\
    Three\".to_string()),\n                4 => result.push(\"Four\".to_string()),\n\
    \                5 => result.push(\"Five\".to_string()),\n                6 =>\
    \ result.push(\"Six\".to_string()),\n                7 => result.push(\"Seven\"\
    .to_string()),\n                8 => result.push(\"Eight\".to_string()),\n   \
    \             9 => result.push(\"Nine\".to_string()),\n                _ => (),\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n    let mut result:\
    \ Vec<String> = Vec::new();\n    for i in sorted_arr {\n        if i > 0 && i\
    \ < 10 {\n            result.push(match i {\n                1 => \"One\".to_string(),\n\
    \                2 => \"Two\".to_string(),\n                3 => \"Three\".to_string(),\n\
    \                4 => \"Four\".to_string(),\n                5 => \"Five\".to_string(),\n\
    \                6 => \"Six\".to_string(),\n                7 => \"Seven\".to_string(),\n\
    \                8 => \"Eight\".to_string(),\n                9 => \"Nine\".to_string(),\n\
    \                _ => \"\".to_string(),\n            });\n        }\n    }\n \
    \   result.reverse();\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().filter(|&x|\
    \ x > 0 && x < 10).map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpq56be3wu.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i >= 1 && i <= 9 {\n         \
    \   match i {\n                1 => result.push(\"One\".to_string()),\n      \
    \          2 => result.push(\"Two\".to_string()),\n                3 => result.push(\"\
    Three\".to_string()),\n                4 => result.push(\"Four\".to_string()),\n\
    \                5 => result.push(\"Five\".to_string()),\n                6 =>\
    \ result.push(\"Six\".to_string()),\n                7 => result.push(\"Seven\"\
    .to_string()),\n                8 => result.push(\"Eight\".to_string()),\n   \
    \             9 => result.push(\"Nine\".to_string()),\n                _ => (),\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res: Vec<String> = Vec::new();\n    let mut nums: Vec<isize> = Vec::new();\n\
    \    for i in arr {\n        if i >= 1 && i <= 9 {\n            nums.push(i);\n\
    \        }\n    }\n    nums.sort();\n    nums.reverse();\n    for i in nums {\n\
    \        match i {\n            1 => res.push(\"One\".to_string()),\n        \
    \    2 => res.push(\"Two\".to_string()),\n            3 => res.push(\"Three\"\
    .to_string()),\n            4 => res.push(\"Four\".to_string()),\n           \
    \ 5 => res.push(\"Five\".to_string()),\n            6 => res.push(\"Six\".to_string()),\n\
    \            7 => res.push(\"Seven\".to_string()),\n            8 => res.push(\"\
    Eight\".to_string()),\n            9 => res.push(\"Nine\".to_string()),\n    \
    \        _ => (),\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6gy6ffs9.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  result.push(match i {\n                1 => \"One\",\n                2 =>\
    \ \"Two\",\n                3 => \"Three\",\n                4 => \"Four\",\n\
    \                5 => \"Five\",\n                6 => \"Six\",\n             \
    \   7 => \"Seven\",\n                8 => \"Eight\",\n                9 => \"\
    Nine\",\n                _ => \"\",\n            }.to_string());\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<_> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => unreachable!(),\n\
    \    }).map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6gy6ffs9.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.iter().filter(|&x| x >= &1 && x <= &9).map(|&x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmppnd2jpde.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    let mut arr_sorted: Vec<isize>\
    \ = arr.clone();\n    arr_sorted.sort();\n    for i in arr_sorted {\n        if\
    \ i > 0 && i < 10 {\n            result.push(match i {\n                1 => \"\
    One\".to_string(),\n                2 => \"Two\".to_string(),\n              \
    \  3 => \"Three\".to_string(),\n                4 => \"Four\".to_string(),\n \
    \               5 => \"Five\".to_string(),\n                6 => \"Six\".to_string(),\n\
    \                7 => \"Seven\".to_string(),\n                8 => \"Eight\".to_string(),\n\
    \                9 => \"Nine\".to_string(),\n                _ => \"\".to_string(),\n\
    \            });\n        }\n    }\n    result.reverse();\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpxfq2cj0o.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    for i in arr {\n        if i\
    \ > 0 && i < 10 {\n            result.push(i.to_string());\n        }\n    }\n\
    \    result.sort();\n    result.reverse();\n    for i in 0..result.len() {\n \
    \       match result[i].as_ref() {\n            \"1\" => result[i] = \"One\".to_string(),\n\
    \            \"2\" => result[i] = \"Two\".to_string(),\n            \"3\" => result[i]\
    \ = \"Three\".to_string(),\n            \"4\" => result[i] = \"Four\".to_string(),\n\
    \            \"5\" => result[i] = \"Five\".to_string(),\n            \"6\" =>\
    \ result[i] = \"Six\".to_string(),\n            \"7\" => result[i] = \"Seven\"\
    .to_string(),\n            \"8\" => result[i] = \"Eight\".to_string(),\n     \
    \       \"9\" => result[i] = \"Nine\".to_string(),\n            _ => (),\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().filter(|x|\
    \ *x > 0 && *x < 10).map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6epod1ak.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i < 1 || i > 9 {\n           \
    \ continue;\n        }\n        match i {\n            1 => result.push(\"One\"\
    .to_string()),\n            2 => result.push(\"Two\".to_string()),\n         \
    \   3 => result.push(\"Three\".to_string()),\n            4 => result.push(\"\
    Four\".to_string()),\n            5 => result.push(\"Five\".to_string()),\n  \
    \          6 => result.push(\"Six\".to_string()),\n            7 => result.push(\"\
    Seven\".to_string()),\n            8 => result.push(\"Eight\".to_string()),\n\
    \            9 => result.push(\"Nine\".to_string()),\n            _ => continue,\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut v: Vec<isize> = arr.clone();\n    v.sort();\n    v.reverse();\n   \
    \ let mut res: Vec<String> = Vec::new();\n    for i in v {\n        match i {\n\
    \            1 => res.push(\"One\".to_string()),\n            2 => res.push(\"\
    Two\".to_string()),\n            3 => res.push(\"Three\".to_string()),\n     \
    \       4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\"\
    .to_string()),\n            6 => res.push(\"Six\".to_string()),\n            7\
    \ => res.push(\"Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n\
    \            9 => res.push(\"Nine\".to_string()),\n            _ => (),\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i < 1 || i > 9 {\n           \
    \ continue;\n        }\n        match i {\n            1 => result.push(\"One\"\
    .to_string()),\n            2 => result.push(\"Two\".to_string()),\n         \
    \   3 => result.push(\"Three\".to_string()),\n            4 => result.push(\"\
    Four\".to_string()),\n            5 => result.push(\"Five\".to_string()),\n  \
    \          6 => result.push(\"Six\".to_string()),\n            7 => result.push(\"\
    Seven\".to_string()),\n            8 => result.push(\"Eight\".to_string()),\n\
    \            9 => result.push(\"Nine\".to_string()),\n            _ => continue,\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  match i {\n                1 => result.push(\"One\".to_string()),\n       \
    \         2 => result.push(\"Two\".to_string()),\n                3 => result.push(\"\
    Three\".to_string()),\n                4 => result.push(\"Four\".to_string()),\n\
    \                5 => result.push(\"Five\".to_string()),\n                6 =>\
    \ result.push(\"Six\".to_string()),\n                7 => result.push(\"Seven\"\
    .to_string()),\n                8 => result.push(\"Eight\".to_string()),\n   \
    \             9 => result.push(\"Nine\".to_string()),\n                _ => (),\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => panic!(\"\
    Unexpected number\"),\n    }).collect()\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpcistvgtg.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result: Vec<String> = Vec::new();\n\
    \    for i in arr {\n        result.push(match i {\n            1 => \"One\".to_string(),\n\
    \            2 => \"Two\".to_string(),\n            3 => \"Three\".to_string(),\n\
    \            4 => \"Four\".to_string(),\n            5 => \"Five\".to_string(),\n\
    \            6 => \"Six\".to_string(),\n            7 => \"Seven\".to_string(),\n\
    \            8 => \"Eight\".to_string(),\n            9 => \"Nine\".to_string(),\n\
    \            _ => \"\".to_string(),\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp2bcpu4d2.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().filter(|&x|\
    \ *x >= 1 && *x <= 9).map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res = arr.iter().filter(|&x| x > &0 && x < &10).map(|&x| x as usize).collect::<Vec<usize>>();\n\
    \    res.sort();\n    res.reverse();\n    res.iter().map(|&x| match x {\n    \
    \    1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4\
    \ => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"\
    Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n\
    \    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn main() {\n  \
    \  let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted = arr.clone();\n    sorted.sort();\n    let mut result = Vec::new();\n\
    \    for i in sorted {\n        if i > 0 && i < 10 {\n            result.push(i.to_string());\n\
    \        }\n    }\n    result.reverse();\n    for i in 0..result.len() {\n   \
    \     match result[i].as_ref() {\n            \"1\" => result[i] = \"One\".to_string(),\n\
    \            \"2\" => result[i] = \"Two\".to_string(),\n            \"3\" => result[i]\
    \ = \"Three\".to_string(),\n            \"4\" => result[i] = \"Four\".to_string(),\n\
    \            \"5\" => result[i] = \"Five\".to_string(),\n            \"6\" =>\
    \ result[i] = \"Six\".to_string(),\n            \"7\" => result[i] = \"Seven\"\
    .to_string(),\n            \"8\" => result[i] = \"Eight\".to_string(),\n     \
    \       \"9\" => result[i] = \"Nine\".to_string(),\n            _ => (),\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().filter(|&x|\
    \ *x >= 1 && *x <= 9).map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpb_1_0box.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    let\
    \ mut result: Vec<String> = Vec::new();\n    for i in arr {\n        match i {\n\
    \            1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => continue,\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  result.push(match i {\n                1 => \"One\",\n                2 =>\
    \ \"Two\",\n                3 => \"Three\",\n                4 => \"Four\",\n\
    \                5 => \"Five\",\n                6 => \"Six\",\n             \
    \   7 => \"Seven\",\n                8 => \"Eight\",\n                9 => \"\
    Nine\",\n                _ => \"\",\n            }.to_string());\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => unreachable!(),\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpr_61ns0c.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749479
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp1h5x99u1.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        match i {\n            1 => result.push(\"\
    One\".to_string()),\n            2 => result.push(\"Two\".to_string()),\n    \
    \        3 => result.push(\"Three\".to_string()),\n            4 => result.push(\"\
    Four\".to_string()),\n            5 => result.push(\"Five\".to_string()),\n  \
    \          6 => result.push(\"Six\".to_string()),\n            7 => result.push(\"\
    Seven\".to_string()),\n            8 => result.push(\"Eight\".to_string()),\n\
    \            9 => result.push(\"Nine\".to_string()),\n            _ => continue,\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  result.push(match i {\n                1 => \"One\",\n                2 =>\
    \ \"Two\",\n                3 => \"Three\",\n                4 => \"Four\",\n\
    \                5 => \"Five\",\n                6 => \"Six\",\n             \
    \   7 => \"Seven\",\n                8 => \"Eight\",\n                9 => \"\
    Nine\",\n                _ => \"\",\n            }.to_string());\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    \",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6gy6ffs9.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    let\
    \ mut result: Vec<String> = Vec::new();\n    for i in arr {\n        match i {\n\
    \            1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10\
    \ {\n            result.push(i);\n        }\n    }\n    result.sort();\n    result.reverse();\n\
    \    result.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749479
