language: rs
name: HumanEval_11_string_xor
results:
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => '0',\n      \
    \  });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        let a_char = a.chars().nth(i).unwrap();\n       \
    \ let b_char = b.chars().nth(i).unwrap();\n        if a_char == b_char {\n   \
    \         result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        let a_char = a.chars().nth(i).unwrap();\n       \
    \ let b_char = b.chars().nth(i).unwrap();\n        if a_char == b_char {\n   \
    \         result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        let x = i.to_digit(10).unwrap()\
    \ ^ j.to_digit(10).unwrap();\n        result.push_str(&x.to_string());\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => unreachable!(),\n\
    \        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    let mut result = String::new();\n    for i in 0..a_bytes.len()\
    \ {\n        let a_char = a_bytes[i];\n        let b_char = b_bytes[i];\n    \
    \    let xor_result = a_char ^ b_char;\n        result.push(xor_result as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmpqaib7wr5.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746947
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.into_bytes();\n    let b_bytes\
    \ = b.into_bytes();\n    let mut result = Vec::new();\n    for i in 0..a_bytes.len()\
    \ {\n        result.push(a_bytes[i] ^ b_bytes[i]);\n    }\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmpqtfov17w.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (x, y) in a.chars().zip(b.chars()) {\n        result.push(match (x, y) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut a_iter = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n     \
    \   match (a_iter.next(), b_iter.next()) {\n            (Some(a_char), Some(b_char))\
    \ => {\n                result.push(if a_char == b_char { '0' } else { '1' });\n\
    \            }\n            (Some(_), None) => {\n                panic!(\"a is\
    \ longer than b\");\n            }\n            (None, Some(_)) => {\n       \
    \         panic!(\"b is longer than a\");\n            }\n            (None, None)\
    \ => {\n                break;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => ' ',\n      \
    \  });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        let a = i.to_digit(10).unwrap();\n\
    \        let b = j.to_digit(10).unwrap();\n        result.push_str(&(a ^ b).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut a_iter = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n     \
    \   match (a_iter.next(), b_iter.next()) {\n            (Some(a_char), Some(b_char))\
    \ => {\n                let xor_result = match (a_char, b_char) {\n          \
    \          ('0', '0') => '0',\n                    ('0', '1') => '1',\n      \
    \              ('1', '0') => '1',\n                    ('1', '1') => '0',\n  \
    \                  _ => panic!(\"Invalid input\"),\n                };\n     \
    \           result.push(xor_result);\n            }\n            (None, None)\
    \ => break,\n            _ => panic!(\"Invalid input\"),\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut a_iter = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n     \
    \   match (a_iter.next(), b_iter.next()) {\n            (Some(a_char), Some(b_char))\
    \ => {\n                result.push(if a_char == b_char { '0' } else { '1' });\n\
    \            }\n            (Some(_), None) => {\n                result.push('1');\n\
    \            }\n            (None, Some(_)) => {\n                result.push('1');\n\
    \            }\n            (None, None) => {\n                break;\n      \
    \      }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut a_iter = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n     \
    \   let a_char = a_iter.next();\n        let b_char = b_iter.next();\n       \
    \ if a_char == None || b_char == None {\n            break;\n        }\n     \
    \   let a_char = a_char.unwrap();\n        let b_char = b_char.unwrap();\n   \
    \     if a_char == b_char {\n            result.push('0');\n        } else {\n\
    \            result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        let a = i.to_digit(10).unwrap();\n\
    \        let b = j.to_digit(10).unwrap();\n        result.push_str(&(a ^ b).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        if a == b {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        let x = i.to_digit(10).unwrap();\n\
    \        let y = j.to_digit(10).unwrap();\n        let z = x ^ y;\n        result.push_str(&z.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (c1, c2) in a.chars().zip(b.chars()) {\n        result.push(if c1 == c2 { '0'\
    \ } else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    let mut result = String::new();\n    for i in 0..a_bytes.len()\
    \ {\n        result.push(match (a_bytes[i], b_bytes[i]) {\n            (b'0',\
    \ b'0') => '0',\n            (b'0', b'1') => '1',\n            (b'1', b'0') =>\
    \ '1',\n            (b'1', b'1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut a_iter = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n     \
    \   match (a_iter.next(), b_iter.next()) {\n            (Some(a_char), Some(b_char))\
    \ => {\n                result.push(if a_char == b_char { '0' } else { '1' });\n\
    \            }\n            (Some(_), None) => {\n                panic!(\"String\
    \ a is longer than string b\");\n            }\n            (None, Some(_)) =>\
    \ {\n                panic!(\"String b is longer than string a\");\n         \
    \   }\n            (None, None) => {\n                break;\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (x, y) in a.chars().zip(b.chars()) {\n        let x = x.to_digit(10).unwrap();\n\
    \        let y = y.to_digit(10).unwrap();\n        let z = x ^ y;\n        result.push_str(&z.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        let a_char = a.chars().nth(i).unwrap();\n       \
    \ let b_char = b.chars().nth(i).unwrap();\n        if a_char == b_char {\n   \
    \         result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Unexpected\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (c1, c2) in a.chars().zip(b.chars()) {\n        let x = match (c1, c2) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        };\n        result.push(x);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746948
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        let a_char = a.chars().nth(i).unwrap();\n       \
    \ let b_char = b.chars().nth(i).unwrap();\n        if a_char == b_char {\n   \
    \         result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        if a == b {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut a_iter = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n     \
    \   match (a_iter.next(), b_iter.next()) {\n            (Some(a_char), Some(b_char))\
    \ => {\n                if a_char == b_char {\n                    result.push('0');\n\
    \                } else {\n                    result.push('1');\n           \
    \     }\n            }\n            _ => break,\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => '0',\n      \
    \  });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        let a = i.to_digit(10).unwrap();\n\
    \        let b = j.to_digit(10).unwrap();\n        result.push_str(&(a ^ b).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        if a == b {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (c1, c2) in a.chars().zip(b.chars()) {\n        let x = c1.to_digit(10).unwrap()\
    \ ^ c2.to_digit(10).unwrap();\n        result.push_str(&x.to_string());\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746948
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (c1, c2) in a.chars().zip(b.chars()) {\n        let x = c1.to_digit(10).unwrap()\
    \ ^ c2.to_digit(10).unwrap();\n        result.push_str(&x.to_string());\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746948
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        if a == b {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        let x = i.to_digit(10).unwrap()\
    \ ^ j.to_digit(10).unwrap();\n        result.push_str(&x.to_string());\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => '0',\n      \
    \  });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ a_chars = a.chars();\n    let b_chars = b.chars();\n    for (a_char, b_char)\
    \ in a_chars.zip(b_chars) {\n        result.push(if a_char == b_char { '0' } else\
    \ { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        let x = i.to_digit(10).unwrap();\n\
    \        let y = j.to_digit(10).unwrap();\n        result.push_str(&(x ^ y).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        let x = i.to_digit(10).unwrap();\n\
    \        let y = j.to_digit(10).unwrap();\n        result.push_str(&(x ^ y).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (x, y) in a.chars().zip(b.chars()) {\n        if x == y {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (x, y) in a.chars().zip(b.chars()) {\n        result.push(if x == y { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746948
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        let x = i.to_digit(10).unwrap()\
    \ ^ j.to_digit(10).unwrap();\n        result.push_str(&x.to_string());\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => '0',\n      \
    \  });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (c1, c2) in a.chars().zip(b.chars()) {\n        result.push(if c1 == c2 { '0'\
    \ } else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        let x = i.to_digit(10).unwrap();\n\
    \        let y = j.to_digit(10).unwrap();\n        result.push_str(&(x ^ y).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for (c1,\
    \ c2) in a.chars().zip(b.chars()) {\n        res.push(match (c1, c2) {\n     \
    \       ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746948
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut a_iter = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n     \
    \   let a_char = a_iter.next();\n        let b_char = b_iter.next();\n       \
    \ if a_char == None || b_char == None {\n            break;\n        }\n     \
    \   let a_char = a_char.unwrap();\n        let b_char = b_char.unwrap();\n   \
    \     if a_char == b_char {\n            result.push('0');\n        } else {\n\
    \            result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        let x = i.to_digit(10).unwrap();\n\
    \        let y = j.to_digit(10).unwrap();\n        result.push_str(&(x ^ y).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746948
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        let a_char = a.chars().nth(i).unwrap();\n       \
    \ let b_char = b.chars().nth(i).unwrap();\n        let a_int = a_char.to_digit(10).unwrap();\n\
    \        let b_int = b_char.to_digit(10).unwrap();\n        result.push_str(&(a_int\
    \ ^ b_int).to_string());\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746948
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut a_iter = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n     \
    \   let a_char = a_iter.next();\n        let b_char = b_iter.next();\n       \
    \ if a_char == None || b_char == None {\n            break;\n        }\n     \
    \   let a_char = a_char.unwrap();\n        let b_char = b_char.unwrap();\n   \
    \     if a_char == b_char {\n            result.push('0');\n        } else {\n\
    \            result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut a_iter = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n     \
    \   match (a_iter.next(), b_iter.next()) {\n            (Some(a_char), Some(b_char))\
    \ => {\n                result.push(if a_char == b_char { '0' } else { '1' });\n\
    \            }\n            (Some(_), None) => {\n                result.push('0');\n\
    \            }\n            (None, Some(_)) => {\n                result.push('0');\n\
    \            }\n            (None, None) => {\n                break;\n      \
    \      }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746948
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        let a = a.to_digit(10).unwrap();\n\
    \        let b = b.to_digit(10).unwrap();\n        result.push_str(&(a ^ b).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746948
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut a_iter = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n     \
    \   match (a_iter.next(), b_iter.next()) {\n            (Some(a_char), Some(b_char))\
    \ => {\n                if a_char == b_char {\n                    result.push('0');\n\
    \                } else {\n                    result.push('1');\n           \
    \     }\n            }\n            _ => break,\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        let x = i.to_digit(10).unwrap();\n\
    \        let y = j.to_digit(10).unwrap();\n        result.push_str(&(x ^ y).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        let x = i.to_digit(10).unwrap();\n\
    \        let y = j.to_digit(10).unwrap();\n        result.push_str(&(x ^ y).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        let a_char = a.chars().nth(i).unwrap();\n       \
    \ let b_char = b.chars().nth(i).unwrap();\n        if a_char == b_char {\n   \
    \         result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(match (a.chars().nth(i), b.chars().nth(i))\
    \ {\n            (Some('1'), Some('1')) => '0',\n            (Some('0'), Some('0'))\
    \ => '0',\n            _ => '1',\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746948
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746947
