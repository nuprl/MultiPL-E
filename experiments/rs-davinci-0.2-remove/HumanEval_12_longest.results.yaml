language: rs
name: HumanEval_12_longest
results:
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut longest_string)\
    \ => {\n                if string.len() > longest_string.len() {\n           \
    \         *longest_string = string;\n                }\n            }\n      \
    \  }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmpub98kmj8.rs:4:49\n    |\n\
    4   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if string.len() > l.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut longest_string)\
    \ => {\n                if string.len() > longest_string.len() {\n           \
    \         *longest_string = string;\n                }\n            }\n      \
    \  }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if string.len() > l.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings.iter() {\n        if string.len()\
    \ > longest.len() {\n            longest = string.clone();\n        }\n    }\n\
    \n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        if longest.is_none()\
    \ || string.len() > longest.as_ref().unwrap().len() {\n            longest = Some(string);\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmp6_48pi6h.rs:6:56\n\
    \  |\n4 |     let mut longest = None;\n  |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    5 |     for string in strings {\n6 |         if longest.is_none() || string.len()\
    \ > longest.as_ref().unwrap().len() {\n  |                                   \
    \                     ^^^^^^ cannot infer type for type parameter `T`\n  |\n \
    \ = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if string.len() > l.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |acc, s| {\n        match acc {\n        \
    \    None => Some(s),\n            Some(acc_s) => {\n                if s.len()\
    \ > acc_s.len() {\n                    Some(s)\n                } else {\n   \
    \                 Some(acc_s)\n                }\n            }\n        }\n \
    \   })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref current)\
    \ => {\n                if string.len() > current.len() {\n                  \
    \  longest = Some(string);\n                }\n            }\n        }\n    }\n\
    \    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n\n    Some(longest.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_string = None;\n    for string in strings {\n        match\
    \ longest_string {\n            None => longest_string = Some(string),\n     \
    \       Some(ref mut longest) => {\n                if string.len() > longest.len()\
    \ {\n                    *longest = string;\n                }\n            }\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut longest_string)\
    \ => {\n                if string.len() > longest_string.len() {\n           \
    \         *longest_string = string;\n                }\n            }\n      \
    \  }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings.iter() {\n        if string.len()\
    \ > longest.len() {\n            longest = string.clone();\n        }\n    }\n\
    \n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |longest, s| {\n        match longest {\n\
    \            None => Some(s),\n            Some(l) => if s.len() > l.len() { Some(s)\
    \ } else { Some(l) }\n        }\n    })\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings.iter() {\n        if string.len()\
    \ > longest.len() {\n            longest = string.clone();\n        }\n    }\n\
    \n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        if longest.is_none()\
    \ || longest.as_ref().unwrap().len() < s.len() {\n            longest = Some(s);\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmpogu0o4f_.rs:6:41\n\
    \  |\n4 |     let mut longest = None;\n  |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    5 |     for s in strings {\n6 |         if longest.is_none() || longest.as_ref().unwrap().len()\
    \ < s.len() {\n  |                                         ^^^^^^ cannot infer\
    \ type for type parameter `T`\n  |\n  = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n\n    Some(longest.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings.iter() {\n        if string.len()\
    \ > longest.len() {\n            longest = string.clone();\n        }\n    }\n\
    \n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings.iter() {\n        if string.len()\
    \ > longest.len() {\n            longest = string.clone();\n        }\n    }\n\
    \n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings.iter() {\n        if s.len() > longest.len()\
    \ {\n            longest = s.clone();\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = strings[0].clone();\n    for string in strings.iter() {\n        if string.len()\
    \ > longest_string.len() {\n            longest_string = string.clone();\n   \
    \     }\n    }\n\n    Some(longest_string)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if string.len() > l.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut longest_string)\
    \ => {\n                if string.len() > longest_string.len() {\n           \
    \         *longest_string = string;\n                }\n            }\n      \
    \  }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut longest_string)\
    \ => {\n                if string.len() > longest_string.len() {\n           \
    \         *longest_string = string;\n                }\n            }\n      \
    \  }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if string.len() > l.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpdej2z15_.rs:10:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        if longest.is_none()\
    \ || s.len() > longest.as_ref().unwrap().len() {\n            longest = Some(s);\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmpa3wk5q6h.rs:6:51\n\
    \  |\n4 |     let mut longest = None;\n  |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    5 |     for s in strings {\n6 |         if longest.is_none() || s.len() > longest.as_ref().unwrap().len()\
    \ {\n  |                                                   ^^^^^^ cannot infer\
    \ type for type parameter `T`\n  |\n  = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => {\n            let mut longest = strings[0].clone();\n         \
    \   for s in strings.iter() {\n                if s.len() > longest.len() {\n\
    \                    longest = s.clone();\n                }\n            }\n\
    \            Some(longest)\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut longest_string)\
    \ => {\n                if string.len() > longest_string.len() {\n           \
    \         *longest_string = string;\n                }\n            }\n      \
    \  }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |longest, s| {\n        match longest {\n\
    \            None => Some(s),\n            Some(l) => {\n                if s.len()\
    \ > l.len() {\n                    Some(s)\n                } else {\n       \
    \             Some(l)\n                }\n            }\n        }\n    })\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmpub98kmj8.rs:4:49\n    |\n\
    4   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if string.len() > l.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if string.len() > l.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut longest_string)\
    \ => {\n                if string.len() > longest_string.len() {\n           \
    \         *longest_string = string;\n                }\n            }\n      \
    \  }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut max_length = 0;\n    let mut longest_string = None;\n    for string\
    \ in strings {\n        if string.len() > max_length {\n            max_length\
    \ = string.len();\n            longest_string = Some(string);\n        }\n   \
    \ }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmpub98kmj8.rs:4:49\n    |\n\
    4   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_string = None;\n    let mut longest_length = 0;\n    for\
    \ string in strings {\n        if string.len() > longest_length {\n          \
    \  longest_length = string.len();\n            longest_string = Some(string);\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if string.len() > l.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n\n    Some(longest.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |longest, s| {\n        match longest {\n\
    \            None => Some(s),\n            Some(longest) => {\n              \
    \  if s.len() > longest.len() {\n                    Some(s)\n               \
    \ } else {\n                    Some(longest)\n                }\n           \
    \ }\n        }\n    })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings.iter() {\n        if string.len()\
    \ > longest.len() {\n            longest = string.clone();\n        }\n    }\n\
    \n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n\n    Some(longest.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut longest_string)\
    \ => {\n                if string.len() > longest_string.len() {\n           \
    \         *longest_string = string;\n                }\n            }\n      \
    \  }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref mut l) => {\n  \
    \              if s.len() > l.len() {\n                    *l = s;\n         \
    \       }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n  \
    \  let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut longest_string)\
    \ => {\n                if string.len() > longest_string.len() {\n           \
    \         *longest_string = string;\n                }\n            }\n      \
    \  }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        if longest.is_none()\
    \ || string.len() > longest.as_ref().unwrap().len() {\n            longest = Some(string);\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmp6_48pi6h.rs:6:56\n\
    \  |\n4 |     let mut longest = None;\n  |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    5 |     for string in strings {\n6 |         if longest.is_none() || string.len()\
    \ > longest.as_ref().unwrap().len() {\n  |                                   \
    \                     ^^^^^^ cannot infer type for type parameter `T`\n  |\n \
    \ = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_string = None;\n    let mut longest_length = 0;\n    for\
    \ string in strings {\n        if string.len() > longest_length {\n          \
    \  longest_string = Some(string);\n            longest_length = string.len();\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `string`\n --> /tmp/tmpknszwtpk.rs:9:30\n\
    \  |\n6 |     for string in strings {\n  |         ------ move occurs because\
    \ `string` has type `String`, which does not implement the `Copy` trait\n7 | \
    \        if string.len() > longest_length {\n8 |             longest_string =\
    \ Some(string);\n  |                                   ------ value moved here\n\
    9 |             longest_length = string.len();\n  |                          \
    \    ^^^^^^ value borrowed here after move\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings.iter() {\n        if s.len() > longest.len()\
    \ {\n            longest = s.clone();\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmpub98kmj8.rs:4:49\n    |\n\
    4   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if string.len() > l.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        if longest.is_none()\
    \ || string.len() > longest.as_ref().unwrap().len() {\n            longest = Some(string);\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmp6_48pi6h.rs:6:56\n\
    \  |\n4 |     let mut longest = None;\n  |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    5 |     for string in strings {\n6 |         if longest.is_none() || string.len()\
    \ > longest.as_ref().unwrap().len() {\n  |                                   \
    \                     ^^^^^^ cannot infer type for type parameter `T`\n  |\n \
    \ = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref current)\
    \ => {\n                if string.len() > current.len() {\n                  \
    \  longest = Some(string);\n                }\n            }\n        }\n    }\n\
    \    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref current)\
    \ => {\n                if string.len() > current.len() {\n                  \
    \  longest = Some(string);\n                }\n            }\n        }\n    }\n\
    \    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut s)\
    \ => {\n                if string.len() > s.len() {\n                    *s =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmpub98kmj8.rs:4:49\n    |\n\
    4   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if string.len() > l.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings.iter() {\n        if s.len() > longest.len()\
    \ {\n            longest = s.clone();\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_len\
    \ = 0;\n    let mut max_str = String::new();\n    for s in strings {\n       \
    \ if s.len() > max_len {\n            max_len = s.len();\n            max_str\
    \ = s;\n        }\n    }\n\n    Some(max_str)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if string.len() > l.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmpub98kmj8.rs:4:49\n    |\n\
    4   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        if longest.is_none()\
    \ || string.len() > longest.as_ref().unwrap().len() {\n            longest = Some(string);\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmp6_48pi6h.rs:6:56\n\
    \  |\n4 |     let mut longest = None;\n  |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    5 |     for string in strings {\n6 |         if longest.is_none() || string.len()\
    \ > longest.as_ref().unwrap().len() {\n  |                                   \
    \                     ^^^^^^ cannot infer type for type parameter `T`\n  |\n \
    \ = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings.iter() {\n        if s.len() > longest.len()\
    \ {\n            longest = s.clone();\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings.iter() {\n        if s.len() > longest.len()\
    \ {\n            longest = s.clone();\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings.iter() {\n        if s.len() > longest.len()\
    \ {\n            longest = s.clone();\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |acc, s| {\n        match acc {\n        \
    \    None => Some(s),\n            Some(acc_s) => {\n                if s.len()\
    \ > acc_s.len() {\n                    Some(s)\n                } else {\n   \
    \                 Some(acc_s)\n                }\n            }\n        }\n \
    \   })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut longest_string)\
    \ => {\n                if string.len() > longest_string.len() {\n           \
    \         *longest_string = string;\n                }\n            }\n      \
    \  }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref current)\
    \ => {\n                if string.len() > current.len() {\n                  \
    \  longest = Some(string);\n                }\n            }\n        }\n    }\n\
    \    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref l) => if\
    \ string.len() > l.len() {\n                longest = Some(string);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if string.len() > l.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings.iter() {\n        if string.len()\
    \ > longest.len() {\n            longest = string.clone();\n        }\n    }\n\
    \n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref current)\
    \ => {\n                if string.len() > current.len() {\n                  \
    \  longest = Some(string);\n                }\n            }\n        }\n    }\n\
    \    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest_string.len()\
    \ {\n            longest_string = string;\n        }\n    }\n\n    Some(longest_string.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |longest, s| {\n        match longest {\n\
    \            None => Some(s),\n            Some(ref l) if l.len() < s.len() =>\
    \ Some(s),\n            _ => longest,\n        }\n    })\n}\n\nfn main() {\n \
    \   let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749478
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749477
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        if longest.is_none()\
    \ || string.len() > longest.as_ref().unwrap().len() {\n            longest = Some(string);\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmp6_48pi6h.rs:6:56\n\
    \  |\n4 |     let mut longest = None;\n  |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    5 |     for string in strings {\n6 |         if longest.is_none() || string.len()\
    \ > longest.as_ref().unwrap().len() {\n  |                                   \
    \                     ^^^^^^ cannot infer type for type parameter `T`\n  |\n \
    \ = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659749477
