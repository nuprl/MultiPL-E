language: rs
name: HumanEval_73_smallest_change
results:
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut left = 0;\n    let\
    \ mut right = arr.len() - 1;\n    while left < right {\n        if arr[left] !=\
    \ arr[right] {\n            count += 1;\n        }\n        left += 1;\n     \
    \   right -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut left = 0;\n    let\
    \ mut right = arr.len() - 1;\n    while left < right {\n        if arr[left] !=\
    \ arr[right] {\n            count += 1;\n        }\n        left += 1;\n     \
    \   right -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut arr = arr;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    let mut changes = 0;\n    while i < j {\n      \
    \  if arr[i] != arr[j] {\n            changes += 1;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len()\
    \ - 1;\n    let mut count = 0;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            count += 1;\n        }\n        left += 1;\n  \
    \      right -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut start = 0;\n \
    \   let mut end = arr.len() - 1;\n    while start < end {\n        if arr[start]\
    \ != arr[end] {\n            changes += 1;\n        }\n        start += 1;\n \
    \       end -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut arr = arr;\n    let mut changes = 0;\n \
    \   let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n      \
    \  if arr[i] != arr[j] {\n            changes += 1;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n\
    \    let mut changes = 0;\n    while i < j {\n        if arr[i] != arr[j] {\n\
    \            changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 101
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let n = arr.len();\n    let mut dp = vec![vec![0;\
    \ n]; n];\n    for i in 0..n {\n        dp[i][i] = 0;\n    }\n    for l in 2..=n\
    \ {\n        for i in 0..=(n - l) {\n            let j = i + l - 1;\n        \
    \    if arr[i] == arr[j] {\n                dp[i][j] = dp[i + 1][j - 1];\n   \
    \         } else {\n                dp[i][j] = 1 + std::cmp::min(dp[i + 1][j],\
    \ dp[i][j - 1]);\n            }\n        }\n    }\n    dp[0][n - 1]\n}\n\nfn main()\
    \ {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]),\
    \ 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `4`', /tmp/tmp5mw3m2mt.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len()\
    \ - 1;\n    let mut changes = 0;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut left = 0;\n    let\
    \ mut right = arr.len() - 1;\n    while left < right {\n        if arr[left] !=\
    \ arr[right] {\n            count += 1;\n        }\n        left += 1;\n     \
    \   right -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut arr = arr;\n    let mut count = 0;\n   \
    \ let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        if\
    \ arr[i] != arr[j] {\n            count += 1;\n        }\n        i += 1;\n  \
    \      j -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut left = 0;\n    let\
    \ mut right = arr.len() - 1;\n    while left < right {\n        if arr[left] !=\
    \ arr[right] {\n            count += 1;\n        }\n        left += 1;\n     \
    \   right -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut left = 0;\n    let\
    \ mut right = arr.len() - 1;\n    while left < right {\n        if arr[left] !=\
    \ arr[right] {\n            count += 1;\n        }\n        left += 1;\n     \
    \   right -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len()\
    \ - 1;\n    let mut changes = 0;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut i = 0;\n \
    \   let mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j]\
    \ {\n            min_changes += 1;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    min_changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut arr = arr;\n    let mut changes = 0;\n \
    \   let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n      \
    \  if arr[i] != arr[j] {\n            changes += 1;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut arr = arr;\n    let mut count = 0;\n   \
    \ let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        if\
    \ arr[i] != arr[j] {\n            count += 1;\n        }\n        i += 1;\n  \
    \      j -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut left = 0;\n    let\
    \ mut right = arr.len() - 1;\n    while left < right {\n        if arr[left] !=\
    \ arr[right] {\n            count += 1;\n        }\n        left += 1;\n     \
    \   right -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len()\
    \ - 1;\n    let mut changes = 0;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len()\
    \ - 1;\n    let mut count = 0;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            count += 1;\n        }\n        left += 1;\n  \
    \      right -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    for i in 0..arr.len()\
    \ / 2 {\n        let j = arr.len() - i - 1;\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n    }\n    changes\n}\n\nfn main() {\n \
    \   let candidate = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5,\
    \ 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n\
    \    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut i = 0;\n \
    \   let mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j]\
    \ {\n            min_changes += 1;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    min_changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_change = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_change += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_change\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut arr = arr;\n    let mut count = 0;\n   \
    \ let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        if\
    \ arr[i] != arr[j] {\n            count += 1;\n        }\n        i += 1;\n  \
    \      j -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n\
    \    let mut count = 0;\n    while i < j {\n        if arr[i] != arr[j] {\n  \
    \          count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len()\
    \ - 1;\n    let mut changes = 0;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut arr = arr;\n    let mut changes = 0;\n \
    \   let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n      \
    \  if arr[i] != arr[j] {\n            changes += 1;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut arr = arr;\n    let mut count = 0;\n   \
    \ let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        if\
    \ arr[i] != arr[j] {\n            count += 1;\n        }\n        i += 1;\n  \
    \      j -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut arr = arr;\n    let mut count = 0;\n   \
    \ let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        if\
    \ arr[i] != arr[j] {\n            count += 1;\n        }\n        i += 1;\n  \
    \      j -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut left = 0;\n    let\
    \ mut right = arr.len() - 1;\n    while left < right {\n        if arr[left] !=\
    \ arr[right] {\n            count += 1;\n        }\n        left += 1;\n     \
    \   right -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut left = 0;\n    let\
    \ mut right = arr.len() - 1;\n    while left < right {\n        if arr[left] !=\
    \ arr[right] {\n            count += 1;\n        }\n        left += 1;\n     \
    \   right -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut i = 0;\n \
    \   let mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j]\
    \ {\n            min_changes += 1;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    min_changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut left = 0;\n    let\
    \ mut right = arr.len() - 1;\n    while left < right {\n        if arr[left] !=\
    \ arr[right] {\n            count += 1;\n        }\n        left += 1;\n     \
    \   right -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len()\
    \ - 1;\n    let mut count = 0;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            count += 1;\n        }\n        left += 1;\n  \
    \      right -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut arr = arr;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    let mut count = 0;\n    while i < j {\n        if\
    \ arr[i] != arr[j] {\n            count += 1;\n        }\n        i += 1;\n  \
    \      j -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    for i in 0..arr.len()\
    \ / 2 {\n        if arr[i] != arr[arr.len() - i - 1] {\n            min_changes\
    \ += 1;\n        }\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len()\
    \ - 1;\n    let mut changes = 0;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut left = 0;\n    let\
    \ mut right = arr.len() - 1;\n    while left < right {\n        if arr[left] !=\
    \ arr[right] {\n            count += 1;\n        }\n        left += 1;\n     \
    \   right -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut left = 0;\n    let\
    \ mut right = arr.len() - 1;\n    while left < right {\n        if arr[left] !=\
    \ arr[right] {\n            count += 1;\n        }\n        left += 1;\n     \
    \   right -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len()\
    \ - 1;\n    let mut changes = 0;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut left = 0;\n    let\
    \ mut right = arr.len() - 1;\n    while left < right {\n        if arr[left] !=\
    \ arr[right] {\n            count += 1;\n        }\n        left += 1;\n     \
    \   right -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut i = 0;\n \
    \   let mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j]\
    \ {\n            min_changes += 1;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    min_changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len()\
    \ - 1;\n    let mut changes = 0;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut arr = arr;\n    let mut changes = 0;\n \
    \   let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n      \
    \  if arr[i] != arr[j] {\n            changes += 1;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut min_changes = 0;\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            min_changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    min_changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        if arr[left]\
    \ != arr[right] {\n            changes += 1;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    changes\n}\n\nfn main() {\n    let candidate\
    \ = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]),\
    \ 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]),\
    \ 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
- exit_code: 0
  program: "/// Given an array arr of integers, find the minimum number of elements\
    \ that\n/// need to be changed to make the array palindromic. A palindromic array\
    \ is an array that\n/// is read the same backwards and forwards. In one change,\
    \ you can change one element to any other element.\n/// For example:\nfn smallest_change(arr:\
    \ Vec<isize>) -> isize {\n    let mut changes = 0;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        if arr[i] != arr[j] {\n \
    \           changes += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    changes\n}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2,\
    \ 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3,\
    \ 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0,\
    \ 1]), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749663
