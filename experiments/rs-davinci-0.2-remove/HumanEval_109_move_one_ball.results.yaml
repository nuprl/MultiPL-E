language: rs
name: HumanEval_109_move_one_ball
results:
- exit_code: 0
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            break;\n        }\n        if arr[i] > arr[i + 1] {\n   \
    \         count += 1;\n            if count > 1 {\n                return false;\n\
    \            }\n            i += 1;\n        } else {\n            i += 1;\n \
    \       }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppzv17avy.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    while !sorted {\n        sorted = true;\n        for i\
    \ in 0..arr.len()-1 {\n            if arr[i] > arr[i+1] {\n                sorted\
    \ = false;\n                let tmp = arr[i];\n                arr[i] = arr[i+1];\n\
    \                arr[i+1] = tmp;\n            }\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0k8zlm07.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    while k < n {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n        \
    \    i += 1;\n            j += 1;\n            k += 1;\n        } else if arr[i]\
    \ < arr[j] && arr[j] > arr[k] {\n            arr.remove(j);\n            n -=\
    \ 1;\n            j -= 1;\n            k -= 1;\n        } else {\n           \
    \ return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfh6_7h65.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    while !sorted {\n        sorted = true;\n        for i\
    \ in 0..arr.len() - 1 {\n            if arr[i] > arr[i + 1] {\n              \
    \  sorted = false;\n                let tmp = arr[i];\n                arr[i]\
    \ = arr[i + 1];\n                arr[i + 1] = tmp;\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplkm5akb1.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    while !sorted {\n        sorted = true;\n        for i\
    \ in 0..arr.len() - 1 {\n            if arr[i] > arr[i + 1] {\n              \
    \  sorted = false;\n                let tmp = arr[i];\n                arr[i]\
    \ = arr[i + 1];\n                arr[i + 1] = tmp;\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplkm5akb1.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let tmp = arr[i];\n     \
    \       arr[i] = arr[i + 1];\n            arr[i + 1] = tmp;\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3g6b0fvv.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut l = arr.len();\n\
    \    while i < l {\n        if j < l && arr[i] > arr[j] {\n            if k <\
    \ l && arr[j] > arr[k] {\n                return false;\n            }\n     \
    \       let tmp = arr[i];\n            arr[i] = arr[j];\n            arr[j] =\
    \ tmp;\n            i += 1;\n            j += 1;\n            k += 1;\n      \
    \  } else {\n            i += 1;\n            j += 1;\n            k += 1;\n \
    \       }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: -1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let n = arr.len();\n    while i < n {\n        if i == n - 1 {\n\
    \            return true;\n        }\n        if arr[i] > arr[i + 1] {\n     \
    \       arr.rotate_right(1);\n            i = 0;\n        } else {\n         \
    \   i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate =\
    \ move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659748181
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = 1;\n    while j < arr.len() {\n        if arr[i] > arr[j] {\n          \
    \  return false;\n        }\n        i += 1;\n        j += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpa_gr6gi_.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let\
    \ mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n   \
    \ let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n\
    \    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut aa = 0;\n    let mut bb =\
    \ 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n    let mut\
    \ ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n    let mut ii = 0;\n   \
    \ let mut jj = 0;\n    let mut kk = 0;\n    let mut ll = 0;\n    let mut mm =\
    \ 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n    let mut\
    \ qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n    let mut tt = 0;\n   \
    \ let mut uu = 0;\n    let mut vv = 0;\n    let mut ww = 0;\n    let mut xx =\
    \ 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut aaa = 0;\n    let\
    \ mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n    let mut eee =\
    \ 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut hhh = 0;\n    let\
    \ mut iii = 0;\n    let mut jjj = 0;\n    let mut kkk = 0;\n    let mut lll =\
    \ 0;\n    let mut mmm = 0;\n    let mut nnn = 0;\n    let mut ooo = 0;\n\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvzep1kbo.rs:18:38\n   |\n\
    18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n            i =\
    \ i + 1;\n        } else {\n            i = i + 1;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp81mjo8jg.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    let mut count = 0;\n    while i < n && j < n && k < n {\n        if arr[i]\
    \ < arr[j] && arr[j] < arr[k] {\n            i += 1;\n            j += 1;\n  \
    \          k += 1;\n        } else if arr[i] > arr[j] && arr[j] > arr[k] {\n \
    \           i += 1;\n            j += 1;\n            k += 1;\n        } else\
    \ if arr[i] < arr[j] && arr[j] > arr[k] {\n            arr.swap(j, k);\n     \
    \       count += 1;\n            i += 1;\n            j += 1;\n            k +=\
    \ 1;\n        } else if arr[i] > arr[j] && arr[j] < arr[k] {\n            arr.swap(j,\
    \ k);\n            count += 1;\n            i += 1;\n            j += 1;\n   \
    \         k += 1;\n        } else if arr[i] > arr[j] && arr[j] == arr[k] {\n \
    \           arr.swap(j, k);\n            count += 1;\n            i += 1;\n  \
    \          j += 1;\n            k += 1;\n        } else if arr[i] == arr[j] &&\
    \ arr[j] < arr[k] {\n            arr.swap(j, k);\n            count += 1;\n  \
    \          i += 1;\n            j += 1;\n            k += 1;\n        } else if\
    \ arr[i] == arr[j] && arr[j] > arr[k] {\n            arr.swap(j, k);\n       \
    \     count += 1;\n            i += 1;\n            j += 1;\n            k +=\
    \ 1;\n        } else if arr[i] == arr[j] && arr[j] == arr[k] {\n            arr.swap(j,\
    \ k);\n            count += 1;\n            i += 1;\n            j += 1;\n   \
    \         k += 1;\n        }\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbhyagvbv.rs:80:3\n\
    \   |\n18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |                \
    \                           - unclosed delimiter\n...\n25 |     while i < n &&\
    \ j < n && k < n {\n   |                                   - this delimiter might\
    \ not be properly closed...\n...\n71 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n80 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbhyagvbv.rs:18:38\n   |\n18 | fn move_one_ball(arr: Vec<isize>)\
    \ -> bool {\n   |    -------------                     ^^^^ expected `bool`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: -1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    let mut count = 0;\n    while !sorted {\n        sorted\
    \ = true;\n        for i in 0..arr.len() - 1 {\n            if arr[i] > arr[i\
    \ + 1] {\n                arr.rotate_right(1);\n                count += 1;\n\
    \                sorted = false;\n                break;\n            }\n    \
    \    }\n    }\n    println!(\"{}\", count);\n    true\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Timeout
  stderr: ''
  stdout: '2

    2

    '
  timestamp: 1659748181
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ let mut flag = true;\n    let mut temp = 0;\n    let mut temp1 = 0;\n    let\
    \ mut temp2 = 0;\n    let mut temp3 = 0;\n    let mut temp4 = 0;\n    let mut\
    \ temp5 = 0;\n    let mut temp6 = 0;\n    let mut temp7 = 0;\n    let mut temp8\
    \ = 0;\n    let mut temp9 = 0;\n    let mut temp10 = 0;\n    let mut temp11 =\
    \ 0;\n    let mut temp12 = 0;\n    let mut temp13 = 0;\n    let mut temp14 = 0;\n\
    \    let mut temp15 = 0;\n    let mut temp16 = 0;\n    let mut temp17 = 0;\n \
    \   let mut temp18 = 0;\n    let mut temp19 = 0;\n    let mut temp20 = 0;\n  \
    \  let mut temp21 = 0;\n    let mut temp22 = 0;\n    let mut temp23 = 0;\n   \
    \ let mut temp24 = 0;\n    let mut temp25 = 0;\n    let mut temp26 = 0;\n    let\
    \ mut temp27 = 0;\n    let mut temp28 = 0;\n    let mut temp29 = 0;\n    let mut\
    \ temp30 = 0;\n    let mut temp31 = 0;\n    let mut temp32 = 0;\n    let mut temp33\
    \ = 0;\n    let mut temp34 = 0;\n    let mut temp35 = 0;\n    let mut temp36 =\
    \ 0;\n    let mut temp37 = 0;\n    let mut temp38 = 0;\n    let mut temp39 = 0;\n\
    \    let mut temp40 = 0;\n    let mut temp41 = 0;\n    let mut temp42 = 0;\n \
    \   let mut temp43 = 0;\n    let mut temp44 = 0;\n    let mut temp45 = 0;\n  \
    \  let mut temp46 = 0;\n    let mut temp47 = 0;\n    let mut temp48 = 0;\n   \
    \ let mut temp49 = 0;\n    let mut temp50 = 0;\n    let mut temp51\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp23hji0e7.rs:76:19\n   |\n\
    76 |     let mut temp51\n   |                   ^ help: add `;` here\n77 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp23hji0e7.rs:18:38\n\
    \   |\n18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------\
    \                     ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ let mut flag = false;\n    while i < arr.len() {\n        if arr[i] > arr[j]\
    \ {\n            if arr[j] < arr[k] {\n                arr.swap(j, k);\n     \
    \           count += 1;\n                flag = true;\n            } else {\n\
    \                arr.swap(i, j);\n                count += 1;\n              \
    \  flag = true;\n            }\n        }\n        i += 1;\n        j += 1;\n\
    \        k += 1;\n    }\n    if count > 1 {\n        return false;\n    }\n  \
    \  if flag {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 5 but the
    index is 5'', /tmp/tmpfgg97vqg.rs:27:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    while j < arr.len()\
    \ {\n        if arr[i] > arr[j] {\n            count += 1;\n            if count\
    \ > 1 {\n                return false;\n            }\n            i = j;\n  \
    \      }\n        j += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb7a2zpy_.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuz7me8uv.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    while k < n {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n        \
    \    i += 1;\n            j += 1;\n            k += 1;\n        } else if arr[i]\
    \ < arr[j] && arr[j] > arr[k] {\n            arr[j] = arr[i];\n            i +=\
    \ 1;\n            j += 1;\n            k += 1;\n        } else if arr[i] > arr[j]\
    \ && arr[j] < arr[k] {\n            arr[i] = arr[j];\n            i += 1;\n  \
    \          j += 1;\n            k += 1;\n        } else if arr[i] > arr[j] &&\
    \ arr[j] > arr[k] {\n            arr[j] = arr[k];\n            i += 1;\n     \
    \       j += 1;\n            k += 1;\n        } else {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpj38vw0go.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        if arr[i]\
    \ > arr[i + 1] {\n            arr.rotate_right(1);\n            j -= 1;\n    \
    \    } else {\n            i += 1;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe3lp3jih.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let n = arr.len();\n   \
    \ while k < n {\n        if arr[i] <= arr[j] && arr[j] <= arr[k] {\n         \
    \   i += 1;\n            j += 1;\n            k += 1;\n        } else if arr[i]\
    \ > arr[j] && arr[j] <= arr[k] {\n            arr.swap(i, k);\n            i +=\
    \ 1;\n            j += 1;\n            k += 1;\n        } else if arr[i] <= arr[j]\
    \ && arr[j] > arr[k] {\n            arr.swap(j, k);\n            j += 1;\n   \
    \         k += 1;\n        } else {\n            return false;\n        }\n  \
    \  }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3l3grym8.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppzv17avy.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    while !sorted {\n        sorted = true;\n        for i\
    \ in 0..arr.len() - 1 {\n            if arr[i] > arr[i + 1] {\n              \
    \  sorted = false;\n                let tmp = arr[i];\n                arr[i]\
    \ = arr[i + 1];\n                arr[i + 1] = tmp;\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplkm5akb1.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            break;\n        }\n        if arr[i] > arr[i + 1] {\n   \
    \         let temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = temp;\n            count += 1;\n        }\n        i += 1;\n    }\n \
    \   if count <= 1 {\n        return true;\n    }\n    return false;\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxk__czhd.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    while k < n {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n        \
    \    i += 1;\n            j += 1;\n            k += 1;\n        } else if arr[i]\
    \ < arr[j] && arr[j] > arr[k] {\n            arr.remove(j);\n            n -=\
    \ 1;\n            i += 1;\n            j += 1;\n            k += 1;\n        }\
    \ else {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            if i == 0 {\n           \
    \     i += 1;\n            } else {\n                i -= 1;\n            }\n\
    \        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp05jsvivj.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut l = arr.len();\n\
    \    while i < l {\n        if j < l && arr[i] > arr[j] {\n            if k <\
    \ l && arr[j] > arr[k] {\n                return false;\n            }\n     \
    \       arr.swap(i, j);\n            i += 1;\n            j += 1;\n          \
    \  k += 1;\n        } else {\n            i += 1;\n            j += 1;\n     \
    \       k += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            arr.rotate_right(1);\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    count <= 1\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpij8eonho.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = temp;\n            i = 0;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbtg0lsta.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    while !sorted {\n        sorted = true;\n        for i\
    \ in 1..arr.len() {\n            if arr[i] < arr[i - 1] {\n                sorted\
    \ = false;\n                let temp = arr[i];\n                arr[i] = arr[i\
    \ - 1];\n                arr[i - 1] = temp;\n            }\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnrq5xbat.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let\
    \ mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n   \
    \ let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n\
    \    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut aa = 0;\n    let mut bb =\
    \ 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n    let mut\
    \ ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n    let mut ii = 0;\n   \
    \ let mut jj = 0;\n    let mut kk = 0;\n    let mut ll = 0;\n    let mut mm =\
    \ 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n    let mut\
    \ qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n    let mut tt = 0;\n   \
    \ let mut uu = 0;\n    let mut vv = 0;\n    let mut ww = 0;\n    let mut xx =\
    \ 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut aaa = 0;\n    let\
    \ mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n    let mut eee =\
    \ 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut hhh = 0;\n    let\
    \ mut iii = 0;\n    let mut jjj = 0;\n    let mut kkk = 0;\n    let mut lll =\
    \ 0;\n    let mut mmm = 0;\n    let mut nnn = 0;\n    let mut ooo = 0;\n\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvzep1kbo.rs:18:38\n   |\n\
    18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ while k < arr.len() {\n        if arr[i] > arr[j] {\n            if arr[j] >\
    \ arr[k] {\n                return false;\n            }\n            count +=\
    \ 1;\n            let temp = arr[i];\n            arr[i] = arr[j];\n         \
    \   arr[j] = arr[k];\n            arr[k] = temp;\n        }\n        i += 1;\n\
    \        j += 1;\n        k += 1;\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            let\
    \ tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = tmp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmeuc5ue_.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ let mut flag = false;\n    let mut flag1 = false;\n    let mut flag2 = false;\n\
    \    let mut flag3 = false;\n    let mut flag4 = false;\n    let mut flag5 = false;\n\
    \    let mut flag6 = false;\n    let mut flag7 = false;\n    let mut flag8 = false;\n\
    \    let mut flag9 = false;\n    let mut flag10 = false;\n    let mut flag11 =\
    \ false;\n    let mut flag12 = false;\n    let mut flag13 = false;\n    let mut\
    \ flag14 = false;\n    let mut flag15 = false;\n    let mut flag16 = false;\n\
    \    let mut flag17 = false;\n    let mut flag18 = false;\n    let mut flag19\
    \ = false;\n    let mut flag20 = false;\n    let mut flag21 = false;\n    let\
    \ mut flag22 = false;\n    let mut flag23 = false;\n    let mut flag24 = false;\n\
    \    let mut flag25 = false;\n    let mut flag26 = false;\n    let mut flag27\
    \ = false;\n    let mut flag28 = false;\n    let mut flag29 = false;\n    let\
    \ mut flag30 = false;\n    let mut flag31 = false;\n    let mut flag32 = false;\n\
    \    let mut flag33 = false;\n    let mut flag34 = false;\n    let mut flag35\
    \ = false;\n    let mut flag36 = false;\n    let mut flag37 = false;\n    let\
    \ mut flag38 = false;\n    let mut flag39 = false;\n    let mut flag40 = false;\n\
    \    let mut flag41 = false;\n    let mut flag42 = false;\n    let mut flag43\
    \ = false;\n    let mut flag44 = false;\n    let mut flag45 = false;\n    let\
    \ mut flag46 = false;\n    let mut flag47 = false;\n    let mut flag48 = false;\n\
    \    let mut flag49 = false;\n    let mut flag50 = false;\n    let mut flag51\
    \ = false;\n    let mut flag\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9rz0eyv_.rs:76:17\n   |\n\
    76 |     let mut flag\n   |                 ^ help: add `;` here\n77 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9rz0eyv_.rs:18:38\n\
    \   |\n18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------\
    \                     ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ while k < arr.len() {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n   \
    \         i += 1;\n            j += 1;\n            k += 1;\n        } else if\
    \ arr[i] < arr[j] && arr[j] > arr[k] {\n            if count == 0 {\n        \
    \        count += 1;\n                i += 1;\n                j += 1;\n     \
    \           k += 1;\n            } else {\n                return false;\n   \
    \         }\n        } else if arr[i] > arr[j] && arr[j] < arr[k] {\n        \
    \    if count == 0 {\n                count += 1;\n                i += 1;\n \
    \               j += 1;\n                k += 1;\n            } else {\n     \
    \           return false;\n            }\n        } else if arr[i] > arr[j] &&\
    \ arr[j] > arr[k] {\n            if count == 0 {\n                count += 1;\n\
    \                i += 1;\n                j += 1;\n                k += 1;\n \
    \           } else {\n                return false;\n            }\n        }\
    \ else if arr[i] == arr[j] && arr[j] < arr[k] {\n            i += 1;\n       \
    \     j += 1;\n            k += 1;\n        } else if arr[i] == arr[j] && arr[j]\
    \ > arr[k] {\n            if count == 0 {\n                count += 1;\n     \
    \           i += 1;\n                j += 1;\n                k += 1;\n      \
    \      } else {\n                return false;\n            }\n        } else\
    \ if arr[i] < arr[j] && arr[j] == arr[k] {\n            i += 1;\n            j\
    \ += 1;\n            k += 1;\n        } else if arr[i] > arr[j] && arr[j] == arr[k]\
    \ {\n            if count == 0 {\n                count += 1;\n              \
    \  i += 1;\n                j += 1;\n                k += 1;\n            }\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1y81x3lg.rs:89:3\n\
    \   |\n18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |                \
    \                           - unclosed delimiter\n...\n24 |     while k < arr.len()\
    \ {\n   |                         - unclosed delimiter\n...\n73 |         } else\
    \ if arr[i] > arr[j] && arr[j] == arr[k] {\n   |                             \
    \                          - this delimiter might not be properly closed...\n\
    ...\n80 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    89 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1y81x3lg.rs:24:5\n\
    \   |\n18 |   fn move_one_ball(arr: Vec<isize>) -> bool {\n   |              \
    \                          ---- expected `bool` because of return type\n...\n\
    24 | /     while k < arr.len() {\n25 | |         if arr[i] < arr[j] && arr[j]\
    \ < arr[k] {\n26 | |             i += 1;\n27 | |             j += 1;\n...  |\n\
    88 | |     assert_eq!(candidate(Vec::<isize>::new()), true);\n89 | | }\n   | |__^\
    \ expected `bool`, found `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: -1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    while !sorted {\n        sorted = true;\n        for i\
    \ in 0..arr.len() - 1 {\n            if arr[i] > arr[i + 1] {\n              \
    \  arr.rotate_right(1);\n                sorted = false;\n                break;\n\
    \            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659748182
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            break;\n        }\n        if arr[i] > arr[i + 1] {\n   \
    \         count += 1;\n            if count > 1 {\n                return false;\n\
    \            }\n            let mut j = i + 1;\n            while j < arr.len()\
    \ {\n                if arr[j] < arr[i] {\n                    return false;\n\
    \                }\n                j += 1;\n            }\n        }\n      \
    \  i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxpyq5pd_.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 0
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    let mut j = 1;\n    let mut k = 2;\n   \
    \ while k < arr.len() {\n        if arr[i] > arr[j] {\n            if arr[j] >\
    \ arr[k] {\n                return false;\n            }\n            count +=\
    \ 1;\n            if count > 1 {\n                return false;\n            }\n\
    \            let temp = arr[j];\n            arr[j] = arr[k];\n            arr[k]\
    \ = temp;\n        }\n        i += 1;\n        j += 1;\n        k += 1;\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    while i < n - 2 {\n        if arr[i] <= arr[j] && arr[j] <= arr[k] {\n  \
    \          i += 1;\n            j += 1;\n            k += 1;\n        } else {\n\
    \            arr.rotate_right(1);\n            n -= 1;\n        }\n    }\n   \
    \ arr[i] <= arr[j]\n}\n\nfn main() {\n    let candidate = move_one_ball;\n   \
    \ assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu06xg2wi.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = arr.len() - 1;\n    while i > 0 {\n        if arr[i - 1] > arr[i] {\n  \
    \          break;\n        }\n        i -= 1;\n    }\n    if i == 0 {\n      \
    \  return true;\n    }\n    let mut j = i + 1;\n    while j < arr.len() {\n  \
    \      if arr[j] < arr[i - 1] {\n            return false;\n        }\n      \
    \  j += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc1e9zox1.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            arr.rotate_right(1);\n            count += 1;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    count < 2\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqhsqh4gw.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    while k < n {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n        \
    \    i += 1;\n            j += 1;\n            k += 1;\n        } else if arr[i]\
    \ < arr[j] && arr[j] > arr[k] {\n            arr.swap(j, k);\n            j +=\
    \ 1;\n            k += 1;\n        } else if arr[i] > arr[j] && arr[j] < arr[k]\
    \ {\n            arr.swap(i, j);\n            i += 1;\n            j += 1;\n \
    \           k += 1;\n        } else if arr[i] > arr[j] && arr[j] > arr[k] {\n\
    \            arr.swap(i, j);\n            arr.swap(j, k);\n            i += 1;\n\
    \            j += 1;\n            k += 1;\n        } else {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn6fj_kx3.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    while k < arr.len() {\n\
    \        if arr[i] < arr[j] && arr[j] < arr[k] {\n            i += 1;\n      \
    \      j += 1;\n            k += 1;\n        } else if arr[i] < arr[j] && arr[j]\
    \ > arr[k] {\n            arr.swap(j, k);\n            j += 1;\n            k\
    \ += 1;\n        } else if arr[i] > arr[j] && arr[j] < arr[k] {\n            arr.swap(i,\
    \ j);\n            i += 1;\n            j += 1;\n            k += 1;\n       \
    \ } else if arr[i] > arr[j] && arr[j] > arr[k] {\n            arr.swap(i, j);\n\
    \            arr.swap(j, k);\n            i += 1;\n            j += 1;\n     \
    \       k += 1;\n        } else {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp5ljegz4.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let\
    \ mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n   \
    \ let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n\
    \    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut aa = 0;\n    let mut bb =\
    \ 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n    let mut\
    \ ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n    let mut ii = 0;\n   \
    \ let mut jj = 0;\n    let mut kk = 0;\n    let mut ll = 0;\n    let mut mm =\
    \ 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n    let mut\
    \ qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n    let mut tt = 0;\n   \
    \ let mut uu = 0;\n    let mut vv = 0;\n    let mut ww = 0;\n    let mut xx =\
    \ 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut aaa = 0;\n    let\
    \ mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n    let mut eee =\
    \ 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut hhh = 0;\n    let\
    \ mut iii = 0;\n    let mut jjj = 0;\n    let mut kkk = 0;\n    let mut lll =\
    \ 0;\n    let mut mmm = 0;\n    let mut nnn = 0;\n    let mut ooo = 0;\n\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvzep1kbo.rs:18:38\n   |\n\
    18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ while k < arr.len() {\n        if arr[i] > arr[j] && arr[j] > arr[k] {\n   \
    \         return false;\n        }\n        if arr[i] > arr[j] && arr[j] < arr[k]\
    \ {\n            count += 1;\n            if count > 1 {\n                return\
    \ false;\n            }\n        }\n        i += 1;\n        j += 1;\n       \
    \ k += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let n = arr.len();\n   \
    \ while k < n {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n           \
    \ i += 1;\n            j += 1;\n            k += 1;\n        } else if arr[i]\
    \ < arr[j] && arr[j] > arr[k] {\n            j += 1;\n            k += 1;\n  \
    \      } else if arr[i] > arr[j] && arr[j] < arr[k] {\n            i += 1;\n \
    \           j += 1;\n            k += 1;\n        } else if arr[i] > arr[j] &&\
    \ arr[j] > arr[k] {\n            return false;\n        }\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnuvjty6e.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = temp;\n            i = 0;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    println!(\"{:?}\", arr);\n    true\n}\n\nfn main() {\n  \
    \  let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]),\
    \ true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2nolkdj0.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: '[1, 2, 3, 4, 5]

    [1, 2, 3, 5, 10]

    [1, 2, 3, 4]

    '
  timestamp: 1659748177
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut l = 3;\n    let\
    \ mut m = 4;\n    let mut n = 5;\n    let mut o = 6;\n    let mut p = 7;\n   \
    \ let mut q = 8;\n    let mut r = 9;\n    let mut s = 10;\n    let mut t = 11;\n\
    \    let mut u = 12;\n    let mut v = 13;\n    let mut w = 14;\n    let mut x\
    \ = 15;\n    let mut y = 16;\n    let mut z = 17;\n    let mut aa = 18;\n    let\
    \ mut bb = 19;\n    let mut cc = 20;\n    let mut dd = 21;\n    let mut ee = 22;\n\
    \    let mut ff = 23;\n    let mut gg = 24;\n    let mut hh = 25;\n    let mut\
    \ ii = 26;\n    let mut jj = 27;\n    let mut kk = 28;\n    let mut ll = 29;\n\
    \    let mut mm = 30;\n    let mut nn = 31;\n    let mut oo = 32;\n    let mut\
    \ pp = 33;\n    let mut qq = 34;\n    let mut rr = 35;\n    let mut ss = 36;\n\
    \    let mut tt = 37;\n    let mut uu = 38;\n    let mut vv = 39;\n    let mut\
    \ ww = 40;\n    let mut xx = 41;\n    let mut yy = 42;\n    let mut zz = 43;\n\
    \    let mut aaa = 44;\n    let mut bbb = 45;\n    let mut ccc = 46;\n    let\
    \ mut ddd = 47;\n    let mut eee = 48;\n    let mut fff = 49;\n    let mut ggg\
    \ = 50;\n    let mut hhh = 51;\n    let mut iii = 52;\n    let mut jjj = 53;\n\
    \    let mut kkk = 54;\n    let mut lll = 55;\n    let mut mmm = 56;\n    let\
    \ mut nnn = 57;\n    let mut ooo = 58;\n\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpolhth5hm.rs:18:38\n   |\n\
    18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    while k < n {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n        \
    \    i += 1;\n            j += 1;\n            k += 1;\n        } else if arr[i]\
    \ < arr[j] && arr[j] > arr[k] {\n            arr.swap(j, k);\n            j +=\
    \ 1;\n            k += 1;\n        } else if arr[i] > arr[j] && arr[j] < arr[k]\
    \ {\n            arr.swap(i, j);\n            i += 1;\n            j += 1;\n \
    \           k += 1;\n        } else if arr[i] > arr[j] && arr[j] > arr[k] {\n\
    \            arr.swap(i, j);\n            arr.swap(j, k);\n            i += 1;\n\
    \            j += 1;\n            k += 1;\n        } else {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn6fj_kx3.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut l = 3;\n    let\
    \ mut m = 4;\n    let mut n = 5;\n    let mut o = 6;\n    let mut p = 7;\n   \
    \ let mut q = 8;\n    let mut r = 9;\n    let mut s = 10;\n    let mut t = 11;\n\
    \    let mut u = 12;\n    let mut v = 13;\n    let mut w = 14;\n    let mut x\
    \ = 15;\n    let mut y = 16;\n    let mut z = 17;\n    let mut aa = 18;\n    let\
    \ mut bb = 19;\n    let mut cc = 20;\n    let mut dd = 21;\n    let mut ee = 22;\n\
    \    let mut ff = 23;\n    let mut gg = 24;\n    let mut hh = 25;\n    let mut\
    \ ii = 26;\n    let mut jj = 27;\n    let mut kk = 28;\n    let mut ll = 29;\n\
    \    let mut mm = 30;\n    let mut nn = 31;\n    let mut oo = 32;\n    let mut\
    \ pp = 33;\n    let mut qq = 34;\n    let mut rr = 35;\n    let mut ss = 36;\n\
    \    let mut tt = 37;\n    let mut uu = 38;\n    let mut vv = 39;\n    let mut\
    \ ww = 40;\n    let mut xx = 41;\n    let mut yy = 42;\n    let mut zz = 43;\n\
    \    let mut aaa = 44;\n    let mut bbb = 45;\n    let mut ccc = 46;\n    let\
    \ mut ddd = 47;\n    let mut eee = 48;\n    let mut fff = 49;\n    let mut ggg\
    \ = 50;\n    let mut hhh = 51;\n    let mut iii = 52;\n    let mut jjj = 53;\n\
    \    let mut kkk = 54;\n    let mut lll = 55;\n    let mut mmm = 56;\n    let\
    \ mut nnn = 57;\n    let mut ooo = 58;\n\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpolhth5hm.rs:18:38\n   |\n\
    18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = arr.len() - 1;\n    while i < j {\n        if arr[i] > arr[j] {\n      \
    \      let tmp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = tmp;\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i\
    \ + 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp71augmbh.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = arr.len() - 1;\n    while i > 0 {\n        if arr[i] < arr[i - 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i - 1];\n            arr[i\
    \ - 1] = temp;\n            i = arr.len() - 1;\n        } else {\n           \
    \ i -= 1;\n        }\n    }\n    for i in 0..arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpq8xeg8yg.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut temp = 0;\n    let\
    \ mut count = 0;\n    let mut flag = false;\n    let mut flag1 = false;\n    let\
    \ mut flag2 = false;\n    let mut flag3 = false;\n    let mut flag4 = false;\n\
    \    let mut flag5 = false;\n    let mut flag6 = false;\n    let mut flag7 = false;\n\
    \    let mut flag8 = false;\n    let mut flag9 = false;\n    let mut flag10 =\
    \ false;\n    let mut flag11 = false;\n    let mut flag12 = false;\n    let mut\
    \ flag13 = false;\n    let mut flag14 = false;\n    let mut flag15 = false;\n\
    \    let mut flag16 = false;\n    let mut flag17 = false;\n    let mut flag18\
    \ = false;\n    let mut flag19 = false;\n    let mut flag20 = false;\n    let\
    \ mut flag21 = false;\n    let mut flag22 = false;\n    let mut flag23 = false;\n\
    \    let mut flag24 = false;\n    let mut flag25 = false;\n    let mut flag26\
    \ = false;\n    let mut flag27 = false;\n    let mut flag28 = false;\n    let\
    \ mut flag29 = false;\n    let mut flag30 = false;\n    let mut flag31 = false;\n\
    \    let mut flag32 = false;\n    let mut flag33 = false;\n    let mut flag34\
    \ = false;\n    let mut flag35 = false;\n    let mut flag36 = false;\n    let\
    \ mut flag37 = false;\n    let mut flag38 = false;\n    let mut flag39 = false;\n\
    \    let mut flag40 = false;\n    let mut flag41 = false;\n    let mut flag42\
    \ = false;\n    let mut flag43 = false;\n    let mut flag44 = false;\n    let\
    \ mut flag45 = false;\n    let mut flag46 = false;\n    let mut flag47 = false;\n\
    \    let mut flag48 = false;\n    let mut flag49 = false;\n    let mut flag50\
    \ = false;\n    let mut flag51\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphqzq_sfx.rs:76:19\n   |\n\
    76 |     let mut flag51\n   |                   ^ help: add `;` here\n77 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphqzq_sfx.rs:18:38\n\
    \   |\n18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------\
    \                     ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    while k < arr.len() {\n\
    \        if arr[i] < arr[j] && arr[j] < arr[k] {\n            i += 1;\n      \
    \      j += 1;\n            k += 1;\n        } else if arr[i] > arr[j] && arr[j]\
    \ > arr[k] {\n            i += 1;\n            j += 1;\n            k += 1;\n\
    \        } else if arr[i] < arr[j] && arr[j] > arr[k] {\n            arr.swap(j,\
    \ k);\n            i += 1;\n            j += 1;\n            k += 1;\n       \
    \ } else if arr[i] > arr[j] && arr[j] < arr[k] {\n            arr.swap(j, k);\n\
    \            i += 1;\n            j += 1;\n            k += 1;\n        } else\
    \ if arr[i] > arr[j] && arr[j] == arr[k] {\n            arr.swap(j, k);\n    \
    \        i += 1;\n            j += 1;\n            k += 1;\n        } else if\
    \ arr[i] == arr[j] && arr[j] < arr[k] {\n            arr.swap(j, k);\n       \
    \     i += 1;\n            j += 1;\n            k += 1;\n        } else if arr[i]\
    \ == arr[j] && arr[j] > arr[k] {\n            arr.swap(j, k);\n            i +=\
    \ 1;\n            j += 1;\n            k += 1;\n        } else if arr[i] > arr[j]\
    \ && arr[j] > arr[k] {\n            arr.swap(j, k);\n            i += 1;\n   \
    \         j += 1;\n            k += 1;\n        } else if arr[i] < arr[j] && arr[j]\
    \ < arr[k] {\n            i += 1;\n            j += 1;\n            k += 1;\n\
    \        } else if arr[i] < arr[j] && arr[j]\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbrhdz9uk.rs:76:3\n\
    \   |\n18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |                \
    \                           - unclosed delimiter\n...\n23 |     while k < arr.len()\
    \ {\n   |                         - this delimiter might not be properly closed...\n\
    ...\n67 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    76 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpbrhdz9uk.rs:67:1\n\
    \   |\n66 |         } else if arr[i] < arr[j] && arr[j]\n   |                --\
    \ this `if` expression has a condition, but no block\n67 | }\n   | ^ expected\
    \ `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbrhdz9uk.rs:18:38\n   |\n\
    18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = temp;\n            i = 0;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbtg0lsta.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    while !sorted {\n        sorted = true;\n        for i\
    \ in 0..arr.len()-1 {\n            if arr[i] > arr[i+1] {\n                sorted\
    \ = false;\n                let tmp = arr[i];\n                arr[i] = arr[i+1];\n\
    \                arr[i+1] = tmp;\n            }\n        }\n    }\n    sorted\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkouqwnaf.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = arr.len() - 1;\n    while i > 0 {\n        if arr[i] < arr[i - 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i - 1];\n            arr[i\
    \ - 1] = temp;\n            i = arr.len() - 1;\n        } else {\n           \
    \ i -= 1;\n        }\n    }\n    for i in 0..arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpq8xeg8yg.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = temp;\n            i = 0;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbtg0lsta.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 0
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    while k < arr.len() {\n\
    \        if arr[i] > arr[j] && arr[j] > arr[k] {\n            return false;\n\
    \        }\n        i += 1;\n        j += 1;\n        k += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            let\
    \ tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = tmp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmeuc5ue_.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut n = arr.len();\n    while i < n && j\
    \ < n {\n        if arr[i] <= arr[j] {\n            i += 1;\n            j +=\
    \ 1;\n        } else {\n            let temp = arr[j];\n            for k in (1..j+1).rev()\
    \ {\n                arr[k] = arr[k-1];\n            }\n            arr[0] = temp;\n\
    \            i += 1;\n            j += 1;\n        }\n    }\n    for i in 0..n-1\
    \ {\n        if arr[i] > arr[i+1] {\n            return false;\n        }\n  \
    \  }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjnm72mz1.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: -1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    let mut i = 0;\n    while !sorted {\n        sorted = true;\n\
    \        for j in 0..arr.len() - 1 {\n            if arr[j] > arr[j + 1] {\n \
    \               sorted = false;\n                break;\n            }\n     \
    \   }\n        if sorted {\n            break;\n        }\n        let tmp = arr[arr.len()\
    \ - 1];\n        for j in (1..arr.len()).rev() {\n            arr[j] = arr[j -\
    \ 1];\n        }\n        arr[0] = tmp;\n        i += 1;\n    }\n    i % 2 ==\
    \ 0\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659748182
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: -1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          arr.rotate_right(1);\n            i = 0;\n        } else {\n      \
    \      i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659748182
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 0
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    while k < arr.len() {\n\
    \        if arr[i] > arr[j] && arr[j] > arr[k] {\n            return false;\n\
    \        }\n        i += 1;\n        j += 1;\n        k += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    arr.sort();\n\
    \    let mut count = 0;\n    for i in 0..arr.len() {\n        if arr[i] != i as\
    \ isize {\n            count += 1;\n        }\n    }\n    count <= 1\n}\n\nfn\
    \ main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4qf7c20s.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ let mut flag = false;\n    let mut flag1 = false;\n    let mut flag2 = false;\n\
    \    let mut flag3 = false;\n    let mut flag4 = false;\n    let mut flag5 = false;\n\
    \    let mut flag6 = false;\n    let mut flag7 = false;\n    let mut flag8 = false;\n\
    \    let mut flag9 = false;\n    let mut flag10 = false;\n    let mut flag11 =\
    \ false;\n    let mut flag12 = false;\n    let mut flag13 = false;\n    let mut\
    \ flag14 = false;\n    let mut flag15 = false;\n    let mut flag16 = false;\n\
    \    let mut flag17 = false;\n    let mut flag18 = false;\n    let mut flag19\
    \ = false;\n    let mut flag20 = false;\n    let mut flag21 = false;\n    let\
    \ mut flag22 = false;\n    let mut flag23 = false;\n    let mut flag24 = false;\n\
    \    let mut flag25 = false;\n    let mut flag26 = false;\n    let mut flag27\
    \ = false;\n    let mut flag28 = false;\n    let mut flag29 = false;\n    let\
    \ mut flag30 = false;\n    let mut flag31 = false;\n    let mut flag32 = false;\n\
    \    let mut flag33 = false;\n    let mut flag34 = false;\n    let mut flag35\
    \ = false;\n    let mut flag36 = false;\n    let mut flag37 = false;\n    let\
    \ mut flag38 = false;\n    let mut flag39 = false;\n    let mut flag40 = false;\n\
    \    let mut flag41 = false;\n    let mut flag42 = false;\n    let mut flag43\
    \ = false;\n    let mut flag44 = false;\n    let mut flag45 = false;\n    let\
    \ mut flag46 = false;\n    let mut flag47 = false;\n    let mut flag48 = false;\n\
    \    let mut flag49 = false;\n    let mut flag50 = false;\n    let mut flag51\
    \ = false;\n    let mut flag\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9rz0eyv_.rs:76:17\n   |\n\
    76 |     let mut flag\n   |                 ^ help: add `;` here\n77 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9rz0eyv_.rs:18:38\n\
    \   |\n18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------\
    \                     ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = arr.len() - 1;\n    while i > 0 {\n        if arr[i] < arr[i - 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i - 1];\n            arr[i\
    \ - 1] = temp;\n            i -= 1;\n        } else {\n            break;\n  \
    \      }\n    }\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if\
    \ arr[i] > arr[i + 1] {\n            return false;\n        }\n        i += 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi6d0xma0.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut l = 3;\n    let\
    \ mut m = 4;\n    let mut n = 5;\n    let mut o = 6;\n    let mut p = 7;\n   \
    \ let mut q = 8;\n    let mut r = 9;\n    let mut s = 10;\n    let mut t = 11;\n\
    \    let mut u = 12;\n    let mut v = 13;\n    let mut w = 14;\n    let mut x\
    \ = 15;\n    let mut y = 16;\n    let mut z = 17;\n    let mut aa = 18;\n    let\
    \ mut bb = 19;\n    let mut cc = 20;\n    let mut dd = 21;\n    let mut ee = 22;\n\
    \    let mut ff = 23;\n    let mut gg = 24;\n    let mut hh = 25;\n    let mut\
    \ ii = 26;\n    let mut jj = 27;\n    let mut kk = 28;\n    let mut ll = 29;\n\
    \    let mut mm = 30;\n    let mut nn = 31;\n    let mut oo = 32;\n    let mut\
    \ pp = 33;\n    let mut qq = 34;\n    let mut rr = 35;\n    let mut ss = 36;\n\
    \    let mut tt = 37;\n    let mut uu = 38;\n    let mut vv = 39;\n    let mut\
    \ ww = 40;\n    let mut xx = 41;\n    let mut yy = 42;\n    let mut zz = 43;\n\
    \    let mut aaa = 44;\n    let mut bbb = 45;\n    let mut ccc = 46;\n    let\
    \ mut ddd = 47;\n    let mut eee = 48;\n    let mut fff = 49;\n    let mut ggg\
    \ = 50;\n    let mut hhh = 51;\n    let mut iii = 52;\n    let mut jjj = 53;\n\
    \    let mut kkk = 54;\n    let mut lll = 55;\n    let mut mmm = 56;\n    let\
    \ mut nnn = 57;\n    let mut ooo = 58;\n\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpolhth5hm.rs:18:38\n   |\n\
    18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuz7me8uv.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ let len = arr.len();\n    while i < len {\n        if arr[i] > arr[j] {\n  \
    \          if arr[j] > arr[k] {\n                return false;\n            }\
    \ else {\n                let temp = arr[j];\n                arr[j] = arr[k];\n\
    \                arr[k] = temp;\n                count += 1;\n            }\n\
    \        }\n        i += 1;\n        j += 1;\n        k += 1;\n    }\n    if count\
    \ == 1 {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n \
    \   let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 5 but the
    index is 5'', /tmp/tmp5k3erro8.rs:27:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = arr.len() - 1;\n    while i > 0 {\n        if arr[i] < arr[i - 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i - 1];\n            arr[i\
    \ - 1] = tmp;\n            i = arr.len() - 1;\n        } else {\n            i\
    \ -= 1;\n        }\n    }\n    arr.windows(2).all(|w| w[0] <= w[1])\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp38e4wr2u.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut l = 3;\n    let\
    \ n = arr.len();\n    while i < n {\n        if j < n && arr[i] > arr[j] {\n \
    \           return false;\n        }\n        if k < n && arr[j] > arr[k] {\n\
    \            return false;\n        }\n        if l < n && arr[k] > arr[l] {\n\
    \            return false;\n        }\n        i += 4;\n        j += 4;\n    \
    \    k += 4;\n        l += 4;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmbz8zima.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    let mut count = 0;\n    while !sorted {\n        sorted\
    \ = true;\n        for i in 0..arr.len() - 1 {\n            if arr[i] > arr[i\
    \ + 1] {\n                sorted = false;\n                count += 1;\n     \
    \           let temp = arr[i];\n                arr[i] = arr[i + 1];\n       \
    \         arr[i + 1] = temp;\n            }\n        }\n    }\n    count <= 1\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp59gb_dam.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n   \
    \ let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n\
    \    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n\
    \    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n\
    \    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut aa =\
    \ 0;\n    let mut bb = 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut\
    \ ee = 0;\n    let mut ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n   \
    \ let mut ii = 0;\n    let mut jj = 0;\n    let mut kk = 0;\n    let mut ll =\
    \ 0;\n    let mut mm = 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut\
    \ pp = 0;\n    let mut qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n   \
    \ let mut tt = 0;\n    let mut uu = 0;\n    let mut vv = 0;\n    let mut ww =\
    \ 0;\n    let mut xx = 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut\
    \ aaa = 0;\n    let mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n\
    \    let mut eee = 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut\
    \ hhh = 0;\n    let mut iii = 0;\n    let mut jjj = 0;\n    let mut kkk = 0;\n\
    \    let mut lll = 0;\n    let mut mmm = 0;\n    let mut nnn = 0;\n   \n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpibt7lfxf.rs:18:38\n   |\n\
    18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     break;\n        }\n        if arr[i] > arr[i + 1] {\n            let tmp\
    \ = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = tmp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph9ykxw77.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuz7me8uv.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            break;\n        }\n        if arr[i] > arr[i + 1] {\n   \
    \         count += 1;\n            if count > 1 {\n                return false;\n\
    \            }\n            let temp = arr[i];\n            arr[i] = arr[i + 1];\n\
    \            arr[i + 1] = temp;\n            i += 1;\n        } else {\n     \
    \       i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgrbzv8w7.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = temp;\n            i = 0;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i +\
    \ 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp10t55et.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    while k < n {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n        \
    \    return true;\n        }\n        i += 1;\n        j += 1;\n        k += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdsi8wupv.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     break;\n        }\n        if arr[i] > arr[i + 1] {\n            let tmp\
    \ = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = tmp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph9ykxw77.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ let mut flag = true;\n    let mut flag1 = true;\n    let mut flag2 = true;\n\
    \    let mut flag3 = true;\n    let mut flag4 = true;\n    let mut flag5 = true;\n\
    \    let mut flag6 = true;\n    let mut flag7 = true;\n    let mut flag8 = true;\n\
    \    let mut flag9 = true;\n    let mut flag10 = true;\n    let mut flag11 = true;\n\
    \    let mut flag12 = true;\n    let mut flag13 = true;\n    let mut flag14 =\
    \ true;\n    let mut flag15 = true;\n    let mut flag16 = true;\n    let mut flag17\
    \ = true;\n    let mut flag18 = true;\n    let mut flag19 = true;\n    let mut\
    \ flag20 = true;\n    let mut flag21 = true;\n    let mut flag22 = true;\n   \
    \ let mut flag23 = true;\n    let mut flag24 = true;\n    let mut flag25 = true;\n\
    \    let mut flag26 = true;\n    let mut flag27 = true;\n    let mut flag28 =\
    \ true;\n    let mut flag29 = true;\n    let mut flag30 = true;\n    let mut flag31\
    \ = true;\n    let mut flag32 = true;\n    let mut flag33 = true;\n    let mut\
    \ flag34 = true;\n    let mut flag35 = true;\n    let mut flag36 = true;\n   \
    \ let mut flag37 = true;\n    let mut flag38 = true;\n    let mut flag39 = true;\n\
    \    let mut flag40 = true;\n    let mut flag41 = true;\n    let mut flag42 =\
    \ true;\n    let mut flag43 = true;\n    let mut flag44 = true;\n    let mut flag45\
    \ = true;\n    let mut flag46 = true;\n    let mut flag47 = true;\n    let mut\
    \ flag48 = true;\n    let mut flag49 = true;\n    let mut flag50 = true;\n   \
    \ let mut flag51 = true;\n    let mut flag\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpagzua92b.rs:76:17\n   |\n\
    76 |     let mut flag\n   |                 ^ help: add `;` here\n77 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpagzua92b.rs:18:38\n\
    \   |\n18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------\
    \                     ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n   \
    \ let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n\
    \    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n\
    \    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n\
    \    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut aa =\
    \ 0;\n    let mut bb = 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut\
    \ ee = 0;\n    let mut ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n   \
    \ let mut ii = 0;\n    let mut jj = 0;\n    let mut kk = 0;\n    let mut ll =\
    \ 0;\n    let mut mm = 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut\
    \ pp = 0;\n    let mut qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n   \
    \ let mut tt = 0;\n    let mut uu = 0;\n    let mut vv = 0;\n    let mut ww =\
    \ 0;\n    let mut xx = 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut\
    \ aaa = 0;\n    let mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n\
    \    let mut eee = 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut\
    \ hhh = 0;\n    let mut iii = 0;\n    let mut jjj = 0;\n    let mut kkk = 0;\n\
    \    let mut lll = 0;\n    let mut mmm = 0;\n    let mut nnn = 0;\n   \n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpibt7lfxf.rs:18:38\n   |\n\
    18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 0
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    let mut count = 0;\n    while k < n {\n        if arr[i] > arr[j] && arr[j]\
    \ > arr[k] {\n            return false;\n        }\n        if arr[i] > arr[j]\
    \ && arr[j] < arr[k] {\n            arr[j] = arr[i];\n            count += 1;\n\
    \        }\n        i += 1;\n        j += 1;\n        k += 1;\n    }\n    if count\
    \ <= 1 {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n \
    \   let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ let mut flag = false;\n    while i < arr.len() - 2 {\n        if arr[i] > arr[j]\
    \ {\n            if arr[j] > arr[k] {\n                flag = true;\n        \
    \        break;\n            } else {\n                count += 1;\n         \
    \       if count > 1 {\n                    flag = false;\n                  \
    \  break;\n                }\n            }\n        }\n        i += 1;\n    \
    \    j += 1;\n        k += 1;\n    }\n    flag\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1hcfw7ob.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    while !sorted {\n        sorted = true;\n        for i\
    \ in 0..arr.len() - 1 {\n            if arr[i] > arr[i + 1] {\n              \
    \  sorted = false;\n                let tmp = arr[i];\n                arr[i]\
    \ = arr[i + 1];\n                arr[i + 1] = tmp;\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplkm5akb1.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    while k < n {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n        \
    \    i += 1;\n            j += 1;\n            k += 1;\n        } else if arr[i]\
    \ < arr[j] && arr[j] > arr[k] {\n            arr.rotate_right(1);\n          \
    \  n -= 1;\n        } else {\n            return false;\n        }\n    }\n  \
    \  true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu33gclql.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    while k < n {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n        \
    \    i += 1;\n            j += 1;\n            k += 1;\n        } else if arr[i]\
    \ < arr[j] && arr[j] > arr[k] {\n            arr.swap(j, k);\n            j +=\
    \ 1;\n            k += 1;\n        } else if arr[i] > arr[j] && arr[j] < arr[k]\
    \ {\n            arr.swap(i, j);\n            i += 1;\n            j += 1;\n \
    \           k += 1;\n        } else if arr[i] > arr[j] && arr[j] > arr[k] {\n\
    \            arr.swap(i, j);\n            arr.swap(j, k);\n            i += 1;\n\
    \            j += 1;\n            k += 1;\n        } else {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn6fj_kx3.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let mut j = i + 1;\n    \
    \        while j < arr.len() - 1 && arr[j] > arr[j + 1] {\n                j +=\
    \ 1;\n            }\n            i = j;\n        }\n        i += 1;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcptptz_u.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    while !sorted {\n        sorted = true;\n        for i\
    \ in 0..arr.len() - 1 {\n            if arr[i] > arr[i + 1] {\n              \
    \  sorted = false;\n                let temp = arr[i];\n                arr[i]\
    \ = arr[i + 1];\n                arr[i + 1] = temp;\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe90m5ykq.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            break;\n        }\n        if arr[i] > arr[i + 1] {\n   \
    \         count += 1;\n            if count > 1 {\n                return false;\n\
    \            }\n            let temp = arr[i];\n            arr[i] = arr[i + 1];\n\
    \            arr[i + 1] = temp;\n            i += 1;\n        } else {\n     \
    \       i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgrbzv8w7.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: -1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          arr.rotate_right(1);\n            i = 0;\n        } else {\n      \
    \      i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659748182
- exit_code: -1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    while !sorted {\n        sorted = true;\n        for i\
    \ in 1..arr.len() {\n            if arr[i] < arr[i - 1] {\n                arr.rotate_right(1);\n\
    \                sorted = false;\n                break;\n            }\n    \
    \    }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659748182
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = 1;\n    while j < arr.len() {\n        if arr[i] > arr[j] {\n          \
    \  return false;\n        }\n        i += 1;\n        j += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpa_gr6gi_.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ let mut last_index = arr.len() - 1;\n    while i < last_index {\n        if\
    \ arr[i] < arr[j] {\n            i += 1;\n            j += 1;\n            k +=\
    \ 1;\n        } else {\n            if arr[j] < arr[k] {\n                arr.swap(j,\
    \ k);\n                count += 1;\n                i += 1;\n                j\
    \ += 1;\n                k += 1;\n            } else {\n                return\
    \ false;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 5 but the
    index is 5'', /tmp/tmpx97c0yih.rs:31:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    while j < arr.len()\
    \ {\n        if arr[i] > arr[j] {\n            count += 1;\n            if count\
    \ > 1 {\n                return false;\n            }\n            i = j;\n  \
    \      }\n        j += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb7a2zpy_.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    while k < n {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n        \
    \    i += 1;\n            j += 1;\n            k += 1;\n        } else if arr[i]\
    \ < arr[j] && arr[j] > arr[k] {\n            arr.remove(j);\n            n -=\
    \ 1;\n            i += 1;\n            j += 1;\n            k += 1;\n        }\
    \ else {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ last = arr.len() - 1;\n    while last > 0 {\n        if arr[last] < arr[last\
    \ - 1] {\n            return false;\n        }\n        last -= 1;\n    }\n  \
    \  true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2gdouuzr.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ last = arr.len() - 1;\n    let mut i = last;\n    while i > 0 {\n        if\
    \ arr[i] < arr[i - 1] {\n            let tmp = arr[i];\n            arr[i] = arr[i\
    \ - 1];\n            arr[i - 1] = tmp;\n            i = last;\n        } else\
    \ {\n            i -= 1;\n        }\n    }\n    for i in 0..last {\n        if\
    \ arr[i] > arr[i + 1] {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpokbnc4su.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ n = arr.len();\n    if n == 0 {\n        return true;\n    }\n    while n >\
    \ 1 {\n        if arr[n - 1] < arr[n - 2] {\n            let temp = arr[n - 1];\n\
    \            arr[n - 1] = arr[0];\n            arr[0] = temp;\n        } else\
    \ {\n            break;\n        }\n        n -= 1;\n    }\n    for i in 1..n\
    \ {\n        if arr[i] < arr[i - 1] {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpotzmtxfw.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    while k < n {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n        \
    \    i += 1;\n            j += 1;\n            k += 1;\n        } else if arr[i]\
    \ < arr[j] && arr[j] > arr[k] {\n            arr.swap(j, k);\n            j +=\
    \ 1;\n            k += 1;\n        } else if arr[i] > arr[j] && arr[j] < arr[k]\
    \ {\n            arr.swap(i, j);\n            i += 1;\n            j += 1;\n \
    \           k += 1;\n        } else if arr[i] > arr[j] && arr[j] > arr[k] {\n\
    \            arr.swap(i, j);\n            arr.swap(j, k);\n            i += 1;\n\
    \            j += 1;\n            k += 1;\n        } else {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn6fj_kx3.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    let mut count = 0;\n    while k < n {\n        if arr[i] < arr[j] && arr[j]\
    \ < arr[k] {\n            i += 1;\n            j += 1;\n            k += 1;\n\
    \        } else if arr[i] < arr[j] && arr[j] > arr[k] {\n            arr.swap(j,\
    \ k);\n            count += 1;\n            i += 1;\n            j += 1;\n   \
    \         k += 1;\n        } else if arr[i] > arr[j] && arr[j] < arr[k] {\n  \
    \          arr.swap(i, j);\n            count += 1;\n            i += 1;\n   \
    \         j += 1;\n            k += 1;\n        } else if arr[i] > arr[j] && arr[j]\
    \ > arr[k] {\n            arr.swap(i, k);\n            count += 1;\n         \
    \   i += 1;\n            j += 1;\n            k += 1;\n        } else {\n    \
    \        i += 1;\n            j += 1;\n            k += 1;\n        }\n    }\n\
    \    if count <= 2 {\n        true\n    } else {\n        false\n    }\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv6goo0hc.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = temp;\n            i = 0;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i +\
    \ 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp10t55et.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    while !sorted {\n        sorted = true;\n        for i\
    \ in 0..arr.len()-1 {\n            if arr[i] > arr[i+1] {\n                sorted\
    \ = false;\n                let tmp = arr[i];\n                arr[i] = arr[i+1];\n\
    \                arr[i+1] = tmp;\n            }\n        }\n    }\n    for i in\
    \ 0..arr.len()-1 {\n        if arr[i] > arr[i+1] {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp99vhyikc.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          arr.remove(i);\n            arr.insert(0, arr[arr.len() - 1]);\n  \
    \          arr.pop();\n            i = 0;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpym9o2in3.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuz7me8uv.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuz7me8uv.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = arr.len() - 1;\n    while i > 0 {\n        if arr[i] < arr[i - 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i - 1];\n            arr[i\
    \ - 1] = temp;\n            i = arr.len() - 1;\n        } else {\n           \
    \ i -= 1;\n        }\n    }\n    for i in 0..arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpq8xeg8yg.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ let mut flag = true;\n    while i < arr.len() - 2 {\n        if arr[i] > arr[j]\
    \ && arr[j] > arr[k] {\n            flag = false;\n            break;\n      \
    \  }\n        if arr[i] > arr[j] && arr[j] < arr[k] {\n            count += 1;\n\
    \            if count > 1 {\n                flag = false;\n                break;\n\
    \            }\n        }\n        i += 1;\n        j += 1;\n        k += 1;\n\
    \    }\n    flag\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpgco9roiw.rs:25:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748178
- exit_code: 0
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = 1;\n    let mut count = 0;\n    while j < arr.len() {\n        if arr[i]\
    \ > arr[j] {\n            count += 1;\n            if count > 1 {\n          \
    \      return false;\n            }\n            i = j;\n            j += 1;\n\
    \        } else {\n            i = j;\n            j += 1;\n        }\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ let mut flag = false;\n    while i < arr.len() {\n        if arr[i] > arr[j]\
    \ {\n            count += 1;\n            if count > 1 {\n                flag\
    \ = true;\n                break;\n            }\n        }\n        i += 1;\n\
    \        j += 1;\n        k += 1;\n    }\n    if flag {\n        return false;\n\
    \    }\n    return true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 5 but the
    index is 5'', /tmp/tmp4tz9vimq.rs:26:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ n = arr.len();\n    let mut i = n - 1;\n    while i > 0 {\n        if arr[i\
    \ - 1] <= arr[i] {\n            i -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    if i == 0 {\n        return true;\n    }\n    let mut j\
    \ = n - 1;\n    while j > i {\n        if arr[j] < arr[i - 1] {\n            break;\n\
    \        }\n        j -= 1;\n    }\n    let mut temp = arr[j];\n    for k in (i..j).rev()\
    \ {\n        arr[k + 1] = arr[k];\n    }\n    arr[i] = temp;\n    for k in 0..(n\
    \ - 1) {\n        if arr[k] > arr[k + 1] {\n            return false;\n      \
    \  }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi2mfot6o.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = temp;\n            i = 0;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i +\
    \ 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp10t55et.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: -1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          arr.rotate_right(1);\n            i = 0;\n        } else {\n      \
    \      i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659748182
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            if i == 0 {\n           \
    \     i += 1;\n            } else {\n                i -= 1;\n            }\n\
    \        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp05jsvivj.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ let mut flag = false;\n    while i < arr.len() {\n        if arr[i] > arr[j]\
    \ {\n            if arr[j] > arr[k] {\n                arr.insert(0, arr.remove(arr.len()\
    \ - 1));\n                count += 1;\n                flag = true;\n        \
    \    } else {\n                if flag {\n                    arr.insert(0, arr.remove(arr.len()\
    \ - 1));\n                    count += 1;\n                }\n               \
    \ i += 1;\n                j += 1;\n                k += 1;\n                flag\
    \ = false;\n            }\n        } else {\n            i += 1;\n           \
    \ j += 1;\n            k += 1;\n            flag = false;\n        }\n    }\n\
    \    if count == 0 {\n        return true;\n    }\n    if count == 1 {\n     \
    \   return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0499]: cannot borrow `arr` as mutable more than once at a time\n\
    \  --> /tmp/tmpg7yxclr9.rs:28:31\n   |\n28 |                 arr.insert(0, arr.remove(arr.len()\
    \ - 1));\n   |                 --- ------    ^^^ second mutable borrow occurs\
    \ here\n   |                 |   |\n   |                 |   first borrow later\
    \ used by call\n   |                 first mutable borrow occurs here\n\nerror[E0499]:\
    \ cannot borrow `arr` as mutable more than once at a time\n  --> /tmp/tmpg7yxclr9.rs:33:35\n\
    \   |\n33 |                     arr.insert(0, arr.remove(arr.len() - 1));\n  \
    \ |                     --- ------    ^^^ second mutable borrow occurs here\n\
    \   |                     |   |\n   |                     |   first borrow later\
    \ used by call\n   |                     first mutable borrow occurs here\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0499`.\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            arr.remove(i);\n\
    \            arr.insert(0, arr[arr.len() - 1]);\n            arr.remove(arr.len()\
    \ - 1);\n            i = 0;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8dxykrkk.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    let mut count = 0;\n    while k < n {\n        if arr[i] < arr[j] && arr[j]\
    \ < arr[k] {\n            i += 1;\n            j += 1;\n            k += 1;\n\
    \        } else if arr[i] > arr[j] && arr[j] > arr[k] {\n            i += 1;\n\
    \            j += 1;\n            k += 1;\n        } else if arr[i] < arr[j] &&\
    \ arr[j] > arr[k] {\n            arr.swap(j, k);\n            count += 1;\n  \
    \          i += 1;\n            j += 1;\n            k += 1;\n        } else if\
    \ arr[i] > arr[j] && arr[j] < arr[k] {\n            arr.swap(j, k);\n        \
    \    count += 1;\n            i += 1;\n            j += 1;\n            k += 1;\n\
    \        } else if arr[i] > arr[j] && arr[j] == arr[k] {\n            arr.swap(j,\
    \ k);\n            count += 1;\n            i += 1;\n            j += 1;\n   \
    \         k += 1;\n        } else if arr[i] == arr[j] && arr[j] < arr[k] {\n \
    \           arr.swap(j, k);\n            count += 1;\n            i += 1;\n  \
    \          j += 1;\n            k += 1;\n        } else if arr[i] == arr[j] &&\
    \ arr[j] > arr[k] {\n            arr.swap(j, k);\n            count += 1;\n  \
    \          i += 1;\n            j += 1;\n            k += 1;\n        } else if\
    \ arr[i] == arr[j] && arr[j] == arr[k] {\n            arr.swap(j, k);\n      \
    \      count += 1;\n            i += 1;\n            j += 1;\n            k +=\
    \ 1;\n        } else {\n            return false;\n\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpsdsww43s.rs:82:3\n\
    \   |\n18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |                \
    \                           - unclosed delimiter\n...\n25 |     while k < n {\n\
    \   |                 - unclosed delimiter\n...\n70 |         } else {\n   | \
    \               - this delimiter might not be properly closed...\n...\n73 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n82 | }\n\
    \   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdsww43s.rs:25:5\n\
    \   |\n18 |   fn move_one_ball(arr: Vec<isize>) -> bool {\n   |              \
    \                          ---- expected `bool` because of return type\n...\n\
    25 | /     while k < n {\n26 | |         if arr[i] < arr[j] && arr[j] < arr[k]\
    \ {\n27 | |             i += 1;\n28 | |             j += 1;\n...  |\n81 | |  \
    \   assert_eq!(candidate(Vec::<isize>::new()), true);\n82 | | }\n   | |__^ expected\
    \ `bool`, found `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 0
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    let mut count = 0;\n    while !sorted {\n        sorted\
    \ = true;\n        for i in 1..arr.len() {\n            if arr[i] < arr[i - 1]\
    \ {\n                sorted = false;\n                count += 1;\n          \
    \      let tmp = arr[i];\n                arr[i] = arr[i - 1];\n             \
    \   arr[i - 1] = tmp;\n            }\n        }\n    }\n    count % 2 == 0\n}\n\
    \nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let n\
    \ = arr.len();\n    let mut i = n - 1;\n    while i > 0 {\n        if arr[i] <\
    \ arr[i - 1] {\n            break;\n        }\n        i -= 1;\n    }\n    if\
    \ i == 0 {\n        return true;\n    }\n    let mut j = i - 1;\n    while j >\
    \ 0 {\n        if arr[j] > arr[j - 1] {\n            break;\n        }\n     \
    \   j -= 1;\n    }\n    if j == 0 {\n        return false;\n    }\n    arr.rotate_right(j);\n\
    \    let mut i = n - 1;\n    while i > 0 {\n        if arr[i] < arr[i - 1] {\n\
    \            break;\n        }\n        i -= 1;\n    }\n    if i == 0 {\n    \
    \    return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpm5xqjpwi.rs:21:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut n = arr.len();\n    while j < n {\n\
    \        if arr[i] > arr[j] {\n            return false;\n        }\n        i\
    \ += 1;\n        j += 1;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwqq2668m.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    let mut count = 0;\n    while k < n {\n        if arr[i] < arr[j] && arr[j]\
    \ < arr[k] {\n            i += 1;\n            j += 1;\n            k += 1;\n\
    \        } else if arr[i] < arr[j] && arr[j] > arr[k] {\n            let temp\
    \ = arr[k];\n            arr[k] = arr[j];\n            arr[j] = arr[i];\n    \
    \        arr[i] = temp;\n            count += 1;\n            i += 1;\n      \
    \      j += 1;\n            k += 1;\n        } else if arr[i] > arr[j] && arr[j]\
    \ < arr[k] {\n            let temp = arr[k];\n            arr[k] = arr[j];\n \
    \           arr[j] = arr[i];\n            arr[i] = temp;\n            count +=\
    \ 1;\n            i += 1;\n            j += 1;\n            k += 1;\n        }\
    \ else if arr[i] > arr[j] && arr[j] > arr[k] {\n            let temp = arr[k];\n\
    \            arr[k] = arr[j];\n            arr[j] = arr[i];\n            arr[i]\
    \ = temp;\n            count += 1;\n            i += 1;\n            j += 1;\n\
    \            k += 1;\n        } else {\n            return false;\n        }\n\
    \    }\n    if count == 0 {\n        return true;\n    } else {\n        return\
    \ false;\n    }\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0d0j9ynq.rs:70:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ while k < arr.len() {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n   \
    \         i += 1;\n            j += 1;\n            k += 1;\n        } else if\
    \ arr[i] < arr[j] && arr[j] > arr[k] {\n            if arr[i] < arr[k] {\n   \
    \             i += 1;\n                j += 1;\n                k += 1;\n    \
    \        } else {\n                count += 1;\n                i += 1;\n    \
    \            j += 1;\n                k += 1;\n            }\n        } else if\
    \ arr[i] > arr[j] && arr[j] < arr[k] {\n            if arr[i] < arr[k] {\n   \
    \             i += 1;\n                j += 1;\n                k += 1;\n    \
    \        } else {\n                count += 1;\n                i += 1;\n    \
    \            j += 1;\n                k += 1;\n            }\n        } else if\
    \ arr[i] > arr[j] && arr[j] > arr[k] {\n            count += 1;\n            i\
    \ += 1;\n            j += 1;\n            k += 1;\n        }\n    }\n    if count\
    \ > 1 {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n  \
    \  let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]),\
    \ true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp647qqds0.rs:66:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    while !sorted {\n        sorted = true;\n        for i\
    \ in 0..arr.len() - 1 {\n            if arr[i] > arr[i + 1] {\n              \
    \  sorted = false;\n                let tmp = arr[i];\n                arr[i]\
    \ = arr[i + 1];\n                arr[i + 1] = tmp;\n            }\n        }\n\
    \    }\n    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzv85k39w.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        if arr[i]\
    \ > arr[i + 1] {\n            arr.swap(i, i + 1);\n            i += 1;\n     \
    \   } else if arr[j] < arr[j - 1] {\n            arr.swap(j, j - 1);\n       \
    \     j -= 1;\n        } else {\n            i += 1;\n            j -= 1;\n  \
    \      }\n    }\n    arr.windows(2).all(|w| w[0] <= w[1])\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0ifim_l1.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    while i < n - 2 {\n        if arr[i] > arr[j] && arr[j] > arr[k] {\n    \
    \        return false;\n        }\n        i += 1;\n        j += 1;\n        k\
    \ += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpk2ry8j02.rs:24:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    while !sorted {\n        sorted = true;\n        for i\
    \ in 0..arr.len() - 1 {\n            if arr[i] > arr[i + 1] {\n              \
    \  sorted = false;\n                let tmp = arr[i];\n                arr[i]\
    \ = arr[i + 1];\n                arr[i + 1] = tmp;\n            }\n        }\n\
    \    }\n    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzv85k39w.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj_eps0ei.rs:22:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748177
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    while k < n {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n        \
    \    i += 1;\n            j += 1;\n            k += 1;\n        } else if arr[i]\
    \ > arr[j] && arr[j] > arr[k] {\n            i += 1;\n            j += 1;\n  \
    \          k += 1;\n        } else if arr[i] < arr[j] && arr[j] > arr[k] {\n \
    \           arr.rotate_right(1);\n            i += 1;\n            j += 1;\n \
    \           k += 1;\n        } else if arr[i] > arr[j] && arr[j] < arr[k] {\n\
    \            arr.rotate_right(1);\n            i += 1;\n            j += 1;\n\
    \            k += 1;\n        } else if arr[i] == arr[j] && arr[j] < arr[k] {\n\
    \            arr.rotate_right(1);\n            i += 1;\n            j += 1;\n\
    \            k += 1;\n        } else if arr[i] == arr[j] && arr[j] > arr[k] {\n\
    \            arr.rotate_right(1);\n            i += 1;\n            j += 1;\n\
    \            k += 1;\n        } else if arr[i] < arr[j] && arr[j] == arr[k] {\n\
    \            arr.rotate_right(1);\n            i += 1;\n            j += 1;\n\
    \            k += 1;\n        } else if arr[i] > arr[j] && arr[j] == arr[k] {\n\
    \            arr.rotate_right(1);\n            i += 1;\n            j += 1;\n\
    \            k += 1;\n        } else if arr[i] == arr[j] && arr[j] == arr[k] {\n\
    \            arr.rotate_right(1);\n            i += 1;\n            j += 1;\n\
    \            k += 1;\n\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpusxatgjz.rs:78:3\n\
    \   |\n18 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |                \
    \                           - unclosed delimiter\n...\n24 |     while k < n {\n\
    \   |                 - unclosed delimiter\n...\n63 |         } else if arr[i]\
    \ == arr[j] && arr[j] == arr[k] {\n   |                                      \
    \                  - this delimiter might not be properly closed...\n...\n69 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n78 |\
    \ }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpusxatgjz.rs:24:5\n\
    \   |\n18 |   fn move_one_ball(arr: Vec<isize>) -> bool {\n   |              \
    \                          ---- expected `bool` because of return type\n...\n\
    24 | /     while k < n {\n25 | |         if arr[i] < arr[j] && arr[j] < arr[k]\
    \ {\n26 | |             i += 1;\n27 | |             j += 1;\n...  |\n77 | |  \
    \   assert_eq!(candidate(Vec::<isize>::new()), true);\n78 | | }\n   | |__^ expected\
    \ `bool`, found `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = temp;\n            i = 0;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    arr == arr.iter().sorted().collect::<Vec<_>>()\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpu0ow5m8d.rs:31:23\n   |\n31 |     arr ==\
    \ arr.iter().sorted().collect::<Vec<_>>()\n   |                       ^^^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    while !sorted {\n        sorted = true;\n        for i\
    \ in 0..arr.len() - 1 {\n            if arr[i] > arr[i + 1] {\n              \
    \  sorted = false;\n                let tmp = arr[i];\n                arr[i]\
    \ = arr[i + 1];\n                arr[i + 1] = tmp;\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplkm5akb1.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ max = arr[0];\n    for i in 1..arr.len() {\n        if arr[i] < max {\n    \
    \        return false;\n        }\n        max = arr[i];\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyt0_mms8.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut n = arr.len();\n\
    \    while k < n {\n        if arr[i] <= arr[j] && arr[j] <= arr[k] {\n      \
    \      i += 1;\n            j += 1;\n            k += 1;\n        } else if arr[i]\
    \ <= arr[j] && arr[j] > arr[k] {\n            j = k;\n            k += 1;\n  \
    \      } else {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb7zor7u1.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: -1
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          arr.rotate_right(1);\n            i = 0;\n        } else {\n      \
    \      i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659748182
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = temp;\n            i = 0;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbtg0lsta.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748177
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuz7me8uv.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    while i\
    \ < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            let tmp = arr[i];\n\
    \            arr[i] = arr[i + 1];\n            arr[i + 1] = tmp;\n           \
    \ i = 0;\n        } else {\n            i += 1;\n        }\n    }\n    for i in\
    \ 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp70l76dv1.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut l = 3;\n    while\
    \ i < arr.len() {\n        if j < arr.len() && arr[i] > arr[j] {\n           \
    \ if k < arr.len() && arr[j] > arr[k] {\n                if l < arr.len() && arr[k]\
    \ > arr[l] {\n                    return false;\n                }\n         \
    \       arr.swap(j, k);\n                arr.swap(i, k);\n                i +=\
    \ 1;\n                j += 1;\n                k += 1;\n                l += 1;\n\
    \            } else {\n                arr.swap(i, j);\n                i += 1;\n\
    \                j += 1;\n                k += 1;\n                l += 1;\n \
    \           }\n        } else {\n            i += 1;\n            j += 1;\n  \
    \          k += 1;\n            l += 1;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv74k6s8y.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuz7me8uv.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ while k < arr.len() {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n   \
    \         count += 1;\n            i += 1;\n            j += 1;\n            k\
    \ += 1;\n        } else if arr[i] > arr[j] && arr[j] > arr[k] {\n            count\
    \ += 1;\n            i += 1;\n            j += 1;\n            k += 1;\n     \
    \   } else {\n            i += 1;\n            j += 1;\n            k += 1;\n\
    \        }\n    }\n    if count == arr.len() - 2 {\n        return true;\n   \
    \ }\n    return false;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp685g9meq.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748178
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 101
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo3p5at12.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748176
- exit_code: 0
  program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// Explanation: By performin\
    \ 2 right shift operations, non-decreasing order can\n/// be achieved for the\
    \ given array.\n/// Explanation:It is not possible to get non-decreasing order\
    \ for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut sorted = arr.clone();\n\
    \    sorted.sort();\n    let mut arr = arr;\n    let mut count = 0;\n    while\
    \ arr != sorted {\n        let last = arr.pop().unwrap();\n        arr.insert(0,\
    \ last);\n        count += 1;\n        if count > arr.len() {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748178
