name: HumanEval_120_maximum
language: rs
prompt: "/// Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n///\
  \ Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array will be\
  \ in the range of [1, 1000].\n/// 2. The elements in the array will be in the range\
  \ of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize)\
  \ -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
  \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
  \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n \
  \   assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
  \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
  \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0,\
  \ 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);\n\
  \    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
  \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
  \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
  }\n"
completions: ["    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut heap = BinaryHeap::new();\n    for i in 0..k\
    \ {\n        heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as\
    \ isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    heap.into_sorted_vec()",
  "    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n        heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > heap.peek().unwrap() {\n            heap.pop();\n            heap.push(arr[i\
    \ as usize]);\n        }\n    }\n    heap.into_sorted_vec()", "    let mut arr\
    \ = arr;\n    let mut k = k as usize;\n    let mut result = Vec::new();\n    for\
    \ i in 0..k {\n        let mut max_index = i;\n        for j in i+1..arr.len()\
    \ {\n            if arr[j] > arr[max_index] {\n                max_index = j;\n\
    \            }\n        }\n        result.push(arr[max_index]);\n        arr.swap(i,\
    \ max_index);\n    }\n    result", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n   \
    \     heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize {\n\
    \        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    while !heap.is_empty()\
    \ {\n        result.push(heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut res = Vec::with_capacity(k as usize);\n    let mut\
    \ arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        res.push(*max);\n        arr.remove_item(max);\n    }\n    res", "  \
    \  let mut arr = arr;\n    let mut k = k as usize;\n    let mut res = Vec::new();\n\
    \    for i in 0..k {\n        let mut max = i;\n        for j in i+1..arr.len()\
    \ {\n            if arr[j] > arr[max] {\n                max = j;\n          \
    \  }\n        }\n        res.push(arr[max]);\n        arr.swap(i, max);\n    }\n\
    \    res", "    let mut result = vec![];\n    let mut max_heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        max_heap.push(arr[i as usize]);\n    }\n    for\
    \ i in k..arr.len() as isize {\n        if arr[i as usize] > max_heap.peek().unwrap()\
    \ {\n            max_heap.pop();\n            max_heap.push(arr[i as usize]);\n\
    \        }\n    }\n    while !max_heap.is_empty() {\n        result.push(max_heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut res = vec![];\n    let\
    \ mut arr = arr;\n    arr.sort();\n    for i in 0..k {\n        res.push(arr[arr.len()\
    \ - 1 - i as usize]);\n    }\n    res", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    for _ in 0..k {\n        let mut max\
    \ = arr[0];\n        let mut max_index = 0;\n        for (i, &x) in arr.iter().enumerate()\
    \ {\n            if x > max {\n                max = x;\n                max_index\
    \ = i;\n            }\n        }\n        result.push(max);\n        arr.remove(max_index);\n\
    \    }\n    result", "    let mut res = vec![];\n    let mut arr = arr;\n    arr.sort();\n\
    \    for i in 0..k {\n        res.push(arr[arr.len() - 1 - i as usize]);\n   \
    \ }\n    res", "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut\
    \ result = Vec::new();\n    for _ in 0..k {\n        let mut max = std::isize::MIN;\n\
    \        let mut max_idx = 0;\n        for (i, &v) in arr.iter().enumerate() {\n\
    \            if v > max {\n                max = v;\n                max_idx =\
    \ i;\n            }\n        }\n        result.push(max);\n        arr.remove(max_idx);\n\
    \        k -= 1;\n    }\n    result", "    let mut res = vec![];\n    let mut\
    \ arr = arr;\n    arr.sort();\n    for i in 0..k {\n        res.push(arr[arr.len()\
    \ - 1 - i as usize]);\n    }\n    res", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n   \
    \     heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize {\n\
    \        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    while let Some(x)\
    \ = heap.pop() {\n        result.push(x);\n    }\n    result.reverse();\n    result",
  "    let mut result = arr[0..k as usize].to_vec();\n    result.sort();\n    for\
    \ i in k..arr.len() as isize {\n        let mut j = 0;\n        while j < k &&\
    \ result[j as usize] < arr[i as usize] {\n            j += 1;\n        }\n   \
    \     if j < k {\n            result.insert(j as usize, arr[i as usize]);\n  \
    \          result.pop();\n        }\n    }\n    result", "    let mut res = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        res.push(*max);\n        arr.remove(arr.iter().position(|&x| x == *max).unwrap());\n\
    \    }\n    res", "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut max_heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        max_heap.push(arr[i as usize]);\n    }\n    for\
    \ i in k..arr.len() as isize {\n        if arr[i as usize] > max_heap.peek().unwrap()\
    \ {\n            max_heap.pop();\n            max_heap.push(arr[i as usize]);\n\
    \        }\n    }\n    max_heap.into_sorted_vec()", "    let mut arr = arr;\n\
    \    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()", "   \
    \ let mut res = vec![];\n    let mut arr = arr;\n    arr.sort();\n    for i in\
    \ 0..k {\n        res.push(arr[arr.len() - 1 - i as usize]);\n    }\n    res",
  "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut res = Vec::with_capacity(k as usize);\n \
    \   let mut arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        res.push(*max);\n        arr.remove_item(max);\n    }\n    res", "  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    let mut res = Vec::with_capacity(k as usize);\n    let mut arr = arr;\n   \
    \ let mut i = 0;\n    while i < k {\n        let mut max = 0;\n        for j in\
    \ 1..arr.len() {\n            if arr[j] > arr[max] {\n                max = j;\n\
    \            }\n        }\n        res.push(arr[max]);\n        arr.remove(max);\n\
    \        i += 1;\n    }\n    res", "    let mut heap = BinaryHeap::new();\n  \
    \  for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len()\
    \ as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n          \
    \  heap.pop();\n            heap.push(arr[i as usize]);\n        }\n    }\n  \
    \  let mut res = vec![];\n    while let Some(x) = heap.pop() {\n        res.push(x);\n\
    \    }\n    res.reverse();\n    res", "    let mut arr = arr;\n    let mut k =\
    \ k as usize;\n    let mut res = Vec::new();\n    for i in 0..k {\n        let\
    \ mut max = i;\n        for j in i+1..arr.len() {\n            if arr[j] > arr[max]\
    \ {\n                max = j;\n            }\n        }\n        res.push(arr[max]);\n\
    \        arr.swap(i, max);\n    }\n    res", "    let mut arr = arr;\n    let\
    \ mut k = k as usize;\n    let mut result = Vec::new();\n    let mut i = 0;\n\
    \    while i < arr.len() {\n        let mut j = i + 1;\n        while j < arr.len()\
    \ {\n            if arr[i] < arr[j] {\n                arr.swap(i, j);\n     \
    \       }\n            j += 1;\n        }\n        if k > 0 {\n            result.push(arr[i]);\n\
    \            k -= 1;\n        }\n        i += 1;\n    }\n    result", "    let\
    \ mut heap = BinaryHeap::new();\n    for i in 0..k {\n        heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > heap.peek().unwrap() {\n            heap.pop();\n            heap.push(arr[i\
    \ as usize]);\n        }\n    }\n    heap.into_sorted_vec()", "    let mut result\
    \ = vec![];\n    let mut arr = arr;\n    arr.sort();\n    for i in 0..k {\n  \
    \      result.push(arr[arr.len() - 1 - i as usize]);\n    }\n    result", "  \
    \  let mut arr = arr;\n    let mut result = Vec::new();\n    for _ in 0..k {\n\
    \        let max = arr.iter().max().unwrap();\n        result.push(*max);\n  \
    \      arr.remove_item(max);\n    }\n    result", "    let mut max_heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        max_heap.push(arr[i as usize]);\n    }\n    for\
    \ i in k..arr.len() as isize {\n        if arr[i as usize] > max_heap.peek().unwrap()\
    \ {\n            max_heap.pop();\n            max_heap.push(arr[i as usize]);\n\
    \        }\n    }\n    let mut result = Vec::new();\n    while !max_heap.is_empty()\
    \ {\n        result.push(max_heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n  \
    \      heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize\
    \ {\n        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    heap.into_sorted_vec()",
  "    let mut result = Vec::with_capacity(k as usize);\n    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut result = arr[0..k as\
    \ usize].to_vec();\n    result.sort();\n    for i in k..arr.len() as isize {\n\
    \        let mut j = 0;\n        while j < k && result[j as usize] < arr[i as\
    \ usize] {\n            j += 1;\n        }\n        if j < k {\n            result.insert(j\
    \ as usize, arr[i as usize]);\n            result.pop();\n        }\n    }\n \
    \   result", "    let mut arr = arr;\n    let mut res = Vec::new();\n    for _\
    \ in 0..k {\n        let max = arr.iter().max().unwrap();\n        res.push(*max);\n\
    \        arr.remove_item(max);\n    }\n    res", "    let mut arr = arr;\n   \
    \ let mut res = Vec::new();\n    let mut i = 0;\n    while i < k {\n        let\
    \ mut max = 0;\n        for j in 1..arr.len() {\n            if arr[j] > arr[max]\
    \ {\n                max = j;\n            }\n        }\n        res.push(arr[max]);\n\
    \        arr.remove(max);\n        i += 1;\n    }\n    res", "    let mut arr\
    \ = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k as usize).collect()",
  "    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n        heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > heap.peek().unwrap() {\n            heap.pop();\n            heap.push(arr[i\
    \ as usize]);\n        }\n    }\n    heap.into_sorted_vec()", "    let mut result\
    \ = Vec::with_capacity(k as usize);\n    let mut arr = arr;\n    arr.sort();\n\
    \    for i in 0..k {\n        result.push(arr[arr.len() - 1 - i as usize]);\n\
    \    }\n    result", "    let mut result = Vec::with_capacity(k as usize);\n \
    \   let mut heap = BinaryHeap::new();\n    for i in 0..arr.len() {\n        heap.push(arr[i]);\n\
    \        if heap.len() > k as usize {\n            heap.pop();\n        }\n  \
    \  }\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        result.push(*max);\n        arr.remove_item(max);\n    }\n    result",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut res = Vec::new();\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n \
    \       while j < arr.len() {\n            if arr[i] < arr[j] {\n            \
    \    arr.swap(i, j);\n            }\n            j += 1;\n        }\n        if\
    \ k == 0 {\n            break;\n        }\n        res.push(arr[i]);\n       \
    \ i += 1;\n        k -= 1;\n    }\n    res", "    let mut result = arr[0..k as\
    \ usize].to_vec();\n    result.sort();\n    for i in k..arr.len() as isize {\n\
    \        if arr[i as usize] > result[0] {\n            result.remove(0);\n   \
    \         result.push(arr[i as usize]);\n            result.sort();\n        }\n\
    \    }\n    result", "    let mut result = Vec::with_capacity(k as usize);\n \
    \   let mut heap = BinaryHeap::new();\n    for &num in arr.iter() {\n        heap.push(num);\n\
    \        if heap.len() > k as usize {\n            heap.pop();\n        }\n  \
    \  }\n    while let Some(num) = heap.pop() {\n        result.push(num);\n    }\n\
    \    result.reverse();\n    result", "    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    heap.into_sorted_vec()", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n   \
    \     heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize {\n\
    \        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    while !heap.is_empty()\
    \ {\n        result.push(heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut res = Vec::with_capacity(k as usize);\n    let mut\
    \ arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        res.push(*max);\n        arr.remove_item(max);\n    }\n    res", "  \
    \  let mut result = vec![];\n    let mut max_heap = BinaryHeap::new();\n    for\
    \ i in 0..k {\n        max_heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len()\
    \ as isize {\n        if arr[i as usize] > max_heap.peek().unwrap() {\n      \
    \      max_heap.pop();\n            max_heap.push(arr[i as usize]);\n        }\n\
    \    }\n    while !max_heap.is_empty() {\n        result.push(max_heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        result.push(*max);\n        arr.remove_item(max);\n    }\n    result",
  "    let mut res = Vec::with_capacity(k as usize);\n    for i in 0..k {\n      \
    \  let mut max = std::isize::MIN;\n        let mut max_idx = 0;\n        for j\
    \ in 0..arr.len() {\n            if arr[j] > max {\n                max = arr[j];\n\
    \                max_idx = j;\n            }\n        }\n        res.push(max);\n\
    \        arr[max_idx] = std::isize::MIN;\n    }\n    res", "    let mut result\
    \ = Vec::with_capacity(k as usize);\n    let mut heap = BinaryHeap::new();\n \
    \   for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut arr = arr;\n    let mut\
    \ result = Vec::new();\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        result.push(*max);\n        arr.remove_item(max);\n    }\n    result",
  "    let mut res = arr.clone();\n    res.sort();\n    res.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut result = Vec::with_capacity(k as usize);\n\
    \    let mut arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        result.push(*max);\n        arr.remove_item(max);\n    }\n    result",
  "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    let mut result = Vec::with_capacity(k as usize);\n    let mut arr = arr;\n\
    \    let mut k = k;\n    while k > 0 {\n        let mut max = std::isize::MIN;\n\
    \        let mut max_index = 0;\n        for (i, &v) in arr.iter().enumerate()\
    \ {\n            if v > max {\n                max = v;\n                max_index\
    \ = i;\n            }\n        }\n        result.push(max);\n        arr.remove(max_index);\n\
    \        k -= 1;\n    }\n    result", "    let mut result = arr[0..k as usize].to_vec();\n\
    \    result.sort();\n    for i in k..arr.len() as isize {\n        let mut j =\
    \ 0;\n        while j < k && result[j as usize] < arr[i as usize] {\n        \
    \    j += 1;\n        }\n        if j < k {\n            result.insert(j as usize,\
    \ arr[i as usize]);\n            result.pop();\n        }\n    }\n    result",
  "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut result = Vec::with_capacity(k as usize);\n\
    \    let mut arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        result.push(*max);\n        arr.remove_item(max);\n    }\n    result",
  "    let mut result = vec![];\n    let mut heap = BinaryHeap::new();\n    for i\
    \ in 0..arr.len() {\n        heap.push(arr[i]);\n        if heap.len() > k as\
    \ usize {\n            heap.pop();\n        }\n    }\n    while !heap.is_empty()\
    \ {\n        result.push(heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut result = arr[0..k as usize].to_vec();\n    result.sort();\n\
    \    for i in k..arr.len() as isize {\n        let mut j = 0;\n        while j\
    \ < k && result[j as usize] < arr[i as usize] {\n            j += 1;\n       \
    \ }\n        if j < k {\n            result.insert(j as usize, arr[i as usize]);\n\
    \            result.pop();\n        }\n    }\n    result", "    let mut result\
    \ = Vec::with_capacity(k as usize);\n    let mut arr = arr;\n    for _ in 0..k\
    \ {\n        let mut max = isize::min_value();\n        let mut index = 0;\n \
    \       for (i, &v) in arr.iter().enumerate() {\n            if v > max {\n  \
    \              max = v;\n                index = i;\n            }\n        }\n\
    \        result.push(max);\n        arr.remove(index);\n    }\n    result", " \
    \   let mut arr = arr;\n    let mut result = Vec::new();\n    let mut i = 0;\n\
    \    while i < k {\n        let mut max = arr[0];\n        let mut max_index =\
    \ 0;\n        for (j, &x) in arr.iter().enumerate() {\n            if x > max\
    \ {\n                max = x;\n                max_index = j;\n            }\n\
    \        }\n        result.push(max);\n        arr.remove(max_index);\n      \
    \  i += 1;\n    }\n    result", "    let mut res = Vec::with_capacity(k as usize);\n\
    \    let mut arr = arr;\n    for _ in 0..k {\n        let mut max = -1001;\n \
    \       let mut max_idx = 0;\n        for (i, &n) in arr.iter().enumerate() {\n\
    \            if n > max {\n                max = n;\n                max_idx =\
    \ i;\n            }\n        }\n        res.push(max);\n        arr.remove(max_idx);\n\
    \    }\n    res", "    let mut result = Vec::with_capacity(k as usize);\n    let\
    \ mut heap = BinaryHeap::new();\n    for i in 0..k {\n        heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > heap.peek().unwrap() {\n            heap.pop();\n            heap.push(arr[i\
    \ as usize]);\n        }\n    }\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    let mut res = vec![];\n    while !heap.is_empty() {\n        res.push(heap.pop().unwrap());\n\
    \    }\n    res.reverse();\n    res", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.into_iter().rev().take(k as usize).collect()", "    let mut res = Vec::with_capacity(k\
    \ as usize);\n    for i in 0..k {\n        let mut max = std::isize::MIN;\n  \
    \      let mut max_idx = 0;\n        for j in i..arr.len() {\n            if arr[j]\
    \ > max {\n                max = arr[j];\n                max_idx = j;\n     \
    \       }\n        }\n        res.push(max);\n        arr.swap(max_idx, i as usize);\n\
    \    }\n    res", "    let mut result = Vec::with_capacity(k as usize);\n    let\
    \ mut arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        result.push(*max);\n        arr.remove_item(max);\n    }\n    result",
  "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::new();\n\
    \    if arr.len() < k {\n        return result;\n    }\n    arr.sort();\n    for\
    \ i in arr.len() - k..arr.len() {\n        result.push(arr[i]);\n    }\n    result",
  "    let mut max_k = arr[0..k as usize].to_vec();\n    max_k.sort();\n    for i\
    \ in k as usize..arr.len() {\n        let mut j = 0;\n        while j < k as usize\
    \ && arr[i] > max_k[j] {\n            j += 1;\n        }\n        if j < k as\
    \ usize {\n            max_k.insert(j, arr[i]);\n            max_k.pop();\n  \
    \      }\n    }\n    max_k", "    let mut res = Vec::with_capacity(k as usize);\n\
    \    let mut arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        res.push(*max);\n        arr.remove_item(max);\n    }\n    res", "  \
    \  let mut res = Vec::with_capacity(k as usize);\n    let mut arr = arr;\n   \
    \ let mut k = k;\n    while k > 0 {\n        let mut max = isize::min_value();\n\
    \        let mut max_idx = 0;\n        for (i, &v) in arr.iter().enumerate() {\n\
    \            if v > max {\n                max = v;\n                max_idx =\
    \ i;\n            }\n        }\n        res.push(max);\n        arr.remove(max_idx);\n\
    \        k -= 1;\n    }\n    res", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n   \
    \     heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize {\n\
    \        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    while let Some(x)\
    \ = heap.pop() {\n        result.push(x);\n    }\n    result.reverse();\n    result",
  "    let mut arr = arr;\n    let mut res = Vec::new();\n    for _ in 0..k {\n  \
    \      let max = arr.iter().max().unwrap();\n        res.push(*max);\n       \
    \ arr.remove_item(max);\n    }\n    res", "    let mut res = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        res.push(*max);\n        arr.remove_item(max);\n    }\n    res", "  \
    \  let mut result = vec![];\n    let mut arr = arr;\n    arr.sort();\n    for\
    \ i in 0..k {\n        result.push(arr[arr.len() - 1 - i as usize]);\n    }\n\
    \    result", "    let mut arr = arr;\n    let mut res = Vec::new();\n    let\
    \ mut i = 0;\n    while i < k {\n        let mut max = i;\n        for j in i\
    \ + 1..arr.len() {\n            if arr[j] > arr[max] {\n                max =\
    \ j;\n            }\n        }\n        res.push(arr[max]);\n        arr.swap(i,\
    \ max);\n        i += 1;\n    }\n    res", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().take(k as usize).collect()", "    let\
    \ mut result = Vec::with_capacity(k as usize);\n    let mut max_heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        max_heap.push(arr[i as usize]);\n    }\n    for\
    \ i in k..arr.len() as isize {\n        if arr[i as usize] > max_heap.peek().unwrap()\
    \ {\n            max_heap.pop();\n            max_heap.push(arr[i as usize]);\n\
    \        }\n    }\n    while !max_heap.is_empty() {\n        result.push(max_heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    arr.sort();\n    for i in 0..k {\n \
    \       result.push(arr[arr.len() - 1 - i as usize]);\n    }\n    result", " \
    \   let mut arr = arr;\n    let mut res = Vec::new();\n    let mut i = 0;\n  \
    \  while i < k {\n        let mut max = i;\n        for j in i+1..arr.len() {\n\
    \            if arr[j] > arr[max] {\n                max = j;\n            }\n\
    \        }\n        res.push(arr[max]);\n        arr.swap(i, max);\n        i\
    \ += 1;\n    }\n    res", "    let mut max_k = vec![];\n    let mut max_k_set\
    \ = std::collections::HashSet::new();\n    for i in 0..k {\n        let mut max\
    \ = std::isize::MIN;\n        let mut max_index = 0;\n        for j in 0..arr.len()\
    \ {\n            if arr[j] > max && !max_k_set.contains(&j) {\n              \
    \  max = arr[j];\n                max_index = j;\n            }\n        }\n \
    \       max_k.push(max);\n        max_k_set.insert(max_index);\n    }\n    max_k",
  "    let mut result = Vec::with_capacity(k as usize);\n    let mut max_heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        max_heap.push(arr[i as usize]);\n    }\n    for\
    \ i in k..arr.len() as isize {\n        if arr[i as usize] > max_heap.peek().unwrap()\
    \ {\n            max_heap.pop();\n            max_heap.push(arr[i as usize]);\n\
    \        }\n    }\n    while !max_heap.is_empty() {\n        result.push(max_heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n   \
    \     heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize {\n\
    \        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    while !heap.is_empty()\
    \ {\n        result.push(heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n  \
    \      heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize\
    \ {\n        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    let mut result\
    \ = Vec::new();\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    heap.into_sorted_vec()", "    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    let mut res = Vec::new();\n    while !heap.is_empty() {\n        res.push(heap.pop().unwrap());\n\
    \    }\n    res.reverse();\n    res", "    let mut result = vec![];\n    let mut\
    \ heap = BinaryHeap::new();\n    for i in 0..k {\n        heap.push(arr[i as usize]);\n\
    \    }\n    for i in k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap()\
    \ {\n            heap.pop();\n            heap.push(arr[i as usize]);\n      \
    \  }\n    }\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.iter().rev().take(k as usize).cloned().collect()", "    let mut res =\
    \ Vec::with_capacity(k as usize);\n    let mut heap = BinaryHeap::new();\n   \
    \ for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len()\
    \ as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n          \
    \  heap.pop();\n            heap.push(arr[i as usize]);\n        }\n    }\n  \
    \  while !heap.is_empty() {\n        res.push(heap.pop().unwrap());\n    }\n \
    \   res.reverse();\n    res", "    let mut result = Vec::with_capacity(k as usize);\n\
    \    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n        heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > heap.peek().unwrap() {\n            heap.pop();\n            heap.push(arr[i\
    \ as usize]);\n        }\n    }\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut arr = arr;\n    let mut\
    \ result = Vec::new();\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        result.push(*max);\n        arr.remove_item(max);\n    }\n    result",
  "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let mut max_heap = BinaryHeap::new();\n    for i in 0..k {\n        max_heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > max_heap.peek().unwrap() {\n            max_heap.pop();\n         \
    \   max_heap.push(arr[i as usize]);\n        }\n    }\n    let mut result = vec![];\n\
    \    while !max_heap.is_empty() {\n        result.push(max_heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut res = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        res.push(*max);\n        arr.remove_item(max);\n    }\n    res", "  \
    \  let mut arr = arr;\n    let mut res = Vec::new();\n    for _ in 0..k {\n  \
    \      let max = arr.iter().max().unwrap();\n        res.push(*max);\n       \
    \ arr.remove_item(max);\n    }\n    res", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.iter().rev().take(k as usize).cloned().collect()", "    let mut arr =\
    \ arr;\n    let mut result = Vec::new();\n    let mut i = 0;\n    while i < k\
    \ {\n        let max = arr.iter().max().unwrap();\n        result.push(*max);\n\
    \        arr.remove_item(max);\n        i += 1;\n    }\n    result", "    let\
    \ mut result = Vec::with_capacity(k as usize);\n    let mut heap = BinaryHeap::new();\n\
    \    for &x in arr.iter() {\n        heap.push(x);\n        if heap.len() > k\
    \ as usize {\n            heap.pop();\n        }\n    }\n    while let Some(x)\
    \ = heap.pop() {\n        result.push(x);\n    }\n    result.reverse();\n    result",
  "    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n        heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > heap.peek().unwrap() {\n            heap.pop();\n            heap.push(arr[i\
    \ as usize]);\n        }\n    }\n    let mut res = vec![];\n    while !heap.is_empty()\
    \ {\n        res.push(heap.pop().unwrap());\n    }\n    res.reverse();\n    res",
  "    let mut arr = arr;\n    let mut res = Vec::new();\n    let mut i = 0;\n   \
    \ while i < k {\n        let mut max = i;\n        for j in i+1..arr.len() {\n\
    \            if arr[j] > arr[max] {\n                max = j;\n            }\n\
    \        }\n        res.push(arr[max]);\n        arr.swap(i, max);\n        i\
    \ += 1;\n    }\n    res", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut result = Vec::with_capacity(k as usize);\n\
    \    let mut arr = arr;\n    let mut k = k;\n    while k > 0 {\n        let mut\
    \ max = std::isize::MIN;\n        let mut max_index = 0;\n        for (i, &v)\
    \ in arr.iter().enumerate() {\n            if v > max {\n                max =\
    \ v;\n                max_index = i;\n            }\n        }\n        result.push(max);\n\
    \        arr.remove(max_index);\n        k -= 1;\n    }\n    result", "    let\
    \ mut heap = BinaryHeap::new();\n    for i in 0..k {\n        heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > heap.peek().unwrap() {\n            heap.pop();\n            heap.push(arr[i\
    \ as usize]);\n        }\n    }\n    let mut result = vec![];\n    while !heap.is_empty()\
    \ {\n        result.push(heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n  \
    \      heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize\
    \ {\n        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    let mut res =\
    \ Vec::new();\n    while !heap.is_empty() {\n        res.push(heap.pop().unwrap());\n\
    \    }\n    res.reverse();\n    res", "    let mut res = Vec::with_capacity(k\
    \ as usize);\n    for i in 0..k {\n        let mut max = std::isize::MIN;\n  \
    \      let mut max_idx = 0;\n        for j in 0..arr.len() {\n            if arr[j]\
    \ > max {\n                max = arr[j];\n                max_idx = j;\n     \
    \       }\n        }\n        res.push(max);\n        arr[max_idx] = std::isize::MIN;\n\
    \    }\n    res", "    let mut result = Vec::with_capacity(k as usize);\n    let\
    \ mut arr = arr;\n    arr.sort();\n    for i in (0..k).rev() {\n        result.push(arr[i\
    \ as usize]);\n    }\n    result", "    let mut heap = BinaryHeap::new();\n  \
    \  for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len()\
    \ as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n          \
    \  heap.pop();\n            heap.push(arr[i as usize]);\n        }\n    }\n  \
    \  heap.into_sorted_vec()", "    let mut arr = arr;\n    let mut res = Vec::new();\n\
    \    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n        res.push(*max);\n\
    \        arr.remove_item(max);\n    }\n    res", "    let mut result = arr.clone();\n\
    \    result.sort();\n    result.reverse();\n    result.truncate(k as usize);\n\
    \    result", "    let mut res = arr[0..k as usize].to_vec();\n    res.sort();\n\
    \    for i in k as usize..arr.len() {\n        let mut j = 0;\n        while j\
    \ < k as usize && res[j] < arr[i] {\n            j += 1;\n        }\n        if\
    \ j < k as usize {\n            res.insert(j, arr[i]);\n            res.pop();\n\
    \        }\n    }\n    res", "    let mut arr = arr;\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    while i < k {\n        let mut max = i;\n        for\
    \ j in i+1..arr.len() {\n            if arr[j] > arr[max] {\n                max\
    \ = j;\n            }\n        }\n        result.push(arr[max]);\n        arr.swap(i,\
    \ max);\n        i += 1;\n    }\n    result", "    let mut res = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        res.push(*max);\n        arr.remove_item(max);\n    }\n    res", "  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let mut arr = arr;\n    let mut res = Vec::new();\n    let mut i = 0;\n   \
    \ while i < k {\n        let mut max = i;\n        for j in i + 1..arr.len() {\n\
    \            if arr[j] > arr[max] {\n                max = j;\n            }\n\
    \        }\n        res.push(arr[max]);\n        arr.swap(i, max);\n        i\
    \ += 1;\n    }\n    res", "    let mut res = Vec::with_capacity(k as usize);\n\
    \    let mut arr = arr;\n    let mut k = k;\n    while k > 0 {\n        let mut\
    \ max = isize::min_value();\n        let mut max_idx = 0;\n        for (i, &x)\
    \ in arr.iter().enumerate() {\n            if x > max {\n                max =\
    \ x;\n                max_idx = i;\n            }\n        }\n        res.push(max);\n\
    \        arr.remove(max_idx);\n        k -= 1;\n    }\n    res", "    let mut\
    \ result = Vec::with_capacity(k as usize);\n    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n   \
    \     heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize {\n\
    \        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    while !heap.is_empty()\
    \ {\n        result.push(heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).map(|&x| x).collect()", "    let mut heap = BinaryHeap::new();\n \
    \   for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    heap.into_sorted_vec()", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut max_heap = BinaryHeap::new();\n    for i in 0..k {\n\
    \        max_heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as\
    \ isize {\n        if arr[i as usize] > max_heap.peek().unwrap() {\n         \
    \   max_heap.pop();\n            max_heap.push(arr[i as usize]);\n        }\n\
    \    }\n    while !max_heap.is_empty() {\n        result.push(max_heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.into_iter().rev().take(k as usize).collect()", "    let mut result =\
    \ Vec::with_capacity(k as usize);\n    let mut arr = arr;\n    for _ in 0..k {\n\
    \        let max = arr.iter().max().unwrap();\n        result.push(*max);\n  \
    \      arr.remove_item(max);\n    }\n    result", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n   \
    \     heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize {\n\
    \        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    while !heap.is_empty()\
    \ {\n        result.push(heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.into_iter().take(k as usize).collect()", "    let mut res = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        res.push(*max);\n        arr.remove_item(max);\n    }\n    res", "  \
    \  let mut result = Vec::with_capacity(k as usize);\n    let mut max_heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        max_heap.push(arr[i as usize]);\n    }\n    for\
    \ i in k..arr.len() as isize {\n        if arr[i as usize] > max_heap.peek().unwrap()\
    \ {\n            max_heap.pop();\n            max_heap.push(arr[i as usize]);\n\
    \        }\n    }\n    for _ in 0..k {\n        result.push(max_heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    heap.into_sorted_vec()", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        result.push(*max);\n        arr.remove_item(max);\n    }\n    result",
  "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    let mut arr = arr;\n    let mut res = Vec::new();\n    let mut i = 0;\n   \
    \ while i < k {\n        let mut max = std::isize::MIN;\n        let mut max_idx\
    \ = 0;\n        for j in 0..arr.len() {\n            if arr[j] > max {\n     \
    \           max = arr[j];\n                max_idx = j;\n            }\n     \
    \   }\n        res.push(max);\n        arr.remove(max_idx);\n        i += 1;\n\
    \    }\n    res", "    let mut arr = arr;\n    let mut k = k as usize;\n    let\
    \ mut res = Vec::new();\n    for i in 0..k {\n        let mut max = i;\n     \
    \   for j in i+1..arr.len() {\n            if arr[j] > arr[max] {\n          \
    \      max = j;\n            }\n        }\n        res.push(arr[max]);\n     \
    \   arr.swap(i, max);\n    }\n    res", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.into_iter().rev().take(k as usize).collect()", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    let mut result = Vec::new();\n    for i in 0..k\
    \ {\n        let mut max_index = i;\n        for j in i+1..arr.len() {\n     \
    \       if arr[j] > arr[max_index] {\n                max_index = j;\n       \
    \     }\n        }\n        result.push(arr[max_index]);\n        arr.swap(i,\
    \ max_index);\n    }\n    result", "    let mut result = vec![];\n    let mut\
    \ max_heap = BinaryHeap::new();\n    for i in 0..k {\n        max_heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > max_heap.peek().unwrap() {\n            max_heap.pop();\n         \
    \   max_heap.push(arr[i as usize]);\n        }\n    }\n    while !max_heap.is_empty()\
    \ {\n        result.push(max_heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut result = Vec::with_capacity(k as usize);\n    let mut\
    \ arr = arr;\n    arr.sort();\n    for i in 0..k {\n        result.push(arr[(arr.len()\
    \ - 1 - i as usize) as usize]);\n    }\n    result", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    arr.sort();\n    for i in 0..k {\n \
    \       result.push(arr[arr.len() - 1 - i as usize]);\n    }\n    result", " \
    \   let mut arr = arr;\n    let mut res = Vec::new();\n    let mut i = 0;\n  \
    \  while i < k {\n        let mut max = i;\n        for j in i + 1..arr.len()\
    \ {\n            if arr[j] > arr[max] {\n                max = j;\n          \
    \  }\n        }\n        res.push(arr[max]);\n        arr.swap(i, max);\n    \
    \    i += 1;\n    }\n    res", "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut result = Vec::with_capacity(k as\
    \ usize);\n    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n      \
    \  heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize {\n\
    \        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    while !heap.is_empty()\
    \ {\n        result.push(heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n  \
    \      heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize\
    \ {\n        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    let mut result\
    \ = Vec::new();\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    for i in 0..k {\n        let mut max = std::isize::MIN;\n  \
    \      let mut max_index = 0;\n        for j in 0..arr.len() {\n            if\
    \ arr[j] > max {\n                max = arr[j];\n                max_index = j;\n\
    \            }\n        }\n        result.push(max);\n        arr[max_index] =\
    \ std::isize::MIN;\n    }\n    result", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut max_heap = BinaryHeap::new();\n    for &num in arr.iter()\
    \ {\n        max_heap.push(num);\n        if max_heap.len() > k as usize {\n \
    \           max_heap.pop();\n        }\n    }\n    while let Some(num) = max_heap.pop()\
    \ {\n        result.push(num);\n    }\n    result.reverse();\n    result", " \
    \   let mut result = Vec::with_capacity(k as usize);\n    for i in 0..k {\n  \
    \      let mut max = std::isize::MIN;\n        let mut max_index = 0;\n      \
    \  for j in 0..arr.len() {\n            if arr[j] > max {\n                max\
    \ = arr[j];\n                max_index = j;\n            }\n        }\n      \
    \  result.push(max);\n        arr[max_index] = std::isize::MIN;\n    }\n    result",
  "    let mut result = Vec::with_capacity(k as usize);\n    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    heap.into_sorted_vec()", "    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    let mut res = Vec::new();\n    while !heap.is_empty() {\n        res.push(heap.pop().unwrap());\n\
    \    }\n    res.reverse();\n    res", "    let mut res = Vec::with_capacity(k\
    \ as usize);\n    for i in 0..k {\n        let mut max = std::isize::MIN;\n  \
    \      let mut max_idx = 0;\n        for j in 0..arr.len() {\n            if arr[j]\
    \ > max {\n                max = arr[j];\n                max_idx = j;\n     \
    \       }\n        }\n        res.push(max);\n        arr[max_idx] = std::isize::MIN;\n\
    \    }\n    res", "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut result = Vec::with_capacity(k as\
    \ usize);\n    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n      \
    \  heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize {\n\
    \        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    while !heap.is_empty()\
    \ {\n        result.push(heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut result = Vec::with_capacity(k as\
    \ usize);\n    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n      \
    \  heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize {\n\
    \        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    while !heap.is_empty()\
    \ {\n        result.push(heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut res = vec![];\n    let mut arr = arr;\n    arr.sort();\n\
    \    for i in 0..k {\n        res.push(arr[arr.len() - 1 - i as usize]);\n   \
    \ }\n    res", "    let mut res = arr.clone();\n    res.sort();\n    res.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut result = Vec::with_capacity(k as usize);\n\
    \    let mut arr = arr;\n    arr.sort();\n    for i in 0..k {\n        result.push(arr[arr.len()\
    \ - 1 - i as usize]);\n    }\n    result", "    let mut res = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    let mut k = k;\n    while k > 0 {\n\
    \        let mut max = std::isize::MIN;\n        let mut max_idx = 0;\n      \
    \  for i in 0..arr.len() {\n            if arr[i] > max {\n                max\
    \ = arr[i];\n                max_idx = i;\n            }\n        }\n        res.push(max);\n\
    \        arr.remove(max_idx);\n        k -= 1;\n    }\n    res", "    let mut\
    \ result = Vec::with_capacity(k as usize);\n    for i in 0..k {\n        let mut\
    \ max = i;\n        for j in (i + 1)..arr.len() {\n            if arr[j] > arr[max]\
    \ {\n                max = j;\n            }\n        }\n        result.push(arr[max]);\n\
    \        arr.swap(i, max);\n    }\n    result", "    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    let mut res = vec![];\n    while let Some(x) = heap.pop() {\n    \
    \    res.push(x);\n    }\n    res.reverse();\n    res", "    let mut arr = arr;\n\
    \    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()", "   \
    \ let mut res = Vec::with_capacity(k as usize);\n    let mut arr = arr;\n    for\
    \ _ in 0..k {\n        let max = arr.iter().max().unwrap();\n        res.push(*max);\n\
    \        arr.remove_item(max);\n    }\n    res", "    let mut res = Vec::with_capacity(k\
    \ as usize);\n    for i in 0..k {\n        let mut max = std::isize::MIN;\n  \
    \      let mut max_idx = 0;\n        for j in 0..arr.len() {\n            if arr[j]\
    \ > max {\n                max = arr[j];\n                max_idx = j;\n     \
    \       }\n        }\n        res.push(max);\n        arr[max_idx] = std::isize::MIN;\n\
    \    }\n    res", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut result = Vec::with_capacity(k as usize);\n\
    \    let mut arr = arr;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        result.push(*max);\n        arr.remove_item(max);\n    }\n    result",
  "    let mut result = vec![];\n    let mut max_heap = BinaryHeap::new();\n    for\
    \ i in 0..k {\n        max_heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len()\
    \ as isize {\n        if arr[i as usize] > max_heap.peek().unwrap() {\n      \
    \      max_heap.pop();\n            max_heap.push(arr[i as usize]);\n        }\n\
    \    }\n    while !max_heap.is_empty() {\n        result.push(max_heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.iter().rev().take(k as usize).cloned().collect()", "    let mut result\
    \ = Vec::with_capacity(k as usize);\n    let mut arr = arr;\n    for _ in 0..k\
    \ {\n        let mut max = std::isize::MIN;\n        let mut max_index = 0;\n\
    \        for (i, &x) in arr.iter().enumerate() {\n            if x > max {\n \
    \               max = x;\n                max_index = i;\n            }\n    \
    \    }\n        result.push(max);\n        arr.remove(max_index);\n    }\n   \
    \ result", "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut result\
    \ = Vec::new();\n    let mut i = 0;\n    while i < arr.len() {\n        let mut\
    \ j = i + 1;\n        while j < arr.len() {\n            if arr[i] < arr[j] {\n\
    \                arr.swap(i, j);\n            }\n            j += 1;\n       \
    \ }\n        if k > 0 {\n            result.push(arr[i]);\n            k -= 1;\n\
    \        }\n        i += 1;\n    }\n    result", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut max_heap = BinaryHeap::new();\n    for i in 0..k {\n\
    \        max_heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as\
    \ isize {\n        if arr[i as usize] > max_heap.peek().unwrap() {\n         \
    \   max_heap.pop();\n            max_heap.push(arr[i as usize]);\n        }\n\
    \    }\n    while !max_heap.is_empty() {\n        result.push(max_heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut res = vec![];\n    let\
    \ mut arr = arr;\n    arr.sort();\n    for i in 0..k {\n        res.push(arr[arr.len()\
    \ - 1 - i as usize]);\n    }\n    res", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    arr.sort();\n    for i in 0..k {\n \
    \       result.push(arr[arr.len() - 1 - i as usize]);\n    }\n    result", " \
    \   let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut res = Vec::new();\n\
    \    for i in 0..k {\n        let mut max = i;\n        for j in i+1..arr.len()\
    \ {\n            if arr[j] > arr[max] {\n                max = j;\n          \
    \  }\n        }\n        res.push(arr[max]);\n        arr.swap(i, max);\n    }\n\
    \    res", "    let mut arr = arr;\n    let mut res = Vec::new();\n    for _ in\
    \ 0..k {\n        let max = arr.iter().max().unwrap();\n        res.push(*max);\n\
    \        arr.remove_item(max);\n    }\n    res", "    let mut arr = arr;\n   \
    \ let mut k = k as usize;\n    let mut res = Vec::new();\n    for i in 0..k {\n\
    \        let mut max = i;\n        for j in i+1..arr.len() {\n            if arr[j]\
    \ > arr[max] {\n                max = j;\n            }\n        }\n        res.push(arr[max]);\n\
    \        arr.swap(i, max);\n    }\n    res", "    let mut res = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    arr.sort();\n    for i in 0..k {\n \
    \       res.push(arr[arr.len() - 1 - i as usize]);\n    }\n    res", "    let\
    \ mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    let mut arr = arr;\n    let mut result = Vec::new();\n    let mut i = 0;\n\
    \    while i < k {\n        let mut max = i;\n        for j in i + 1..arr.len()\
    \ {\n            if arr[j] > arr[max] {\n                max = j;\n          \
    \  }\n        }\n        result.push(arr[max]);\n        arr.swap(i, max);\n \
    \       i += 1;\n    }\n    result", "    let mut arr = arr;\n    let mut k =\
    \ k as usize;\n    let mut res = Vec::new();\n    for i in 0..k {\n        let\
    \ mut max = i;\n        for j in i+1..arr.len() {\n            if arr[j] > arr[max]\
    \ {\n                max = j;\n            }\n        }\n        res.push(arr[max]);\n\
    \        arr.swap(i, max);\n    }\n    res", "    let mut arr = arr;\n    let\
    \ mut res = Vec::new();\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        res.push(*max);\n        arr.remove_item(max);\n    }\n    res", "  \
    \  let mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n \
    \       while j < arr.len() {\n            if arr[i] < arr[j] {\n            \
    \    arr.swap(i, j);\n            }\n            j += 1;\n        }\n        if\
    \ k > 0 {\n            result.push(arr[i]);\n            k -= 1;\n        }\n\
    \        i += 1;\n    }\n    result", "    let mut res = Vec::with_capacity(k\
    \ as usize);\n    for i in 0..k {\n        let mut j = i as usize;\n        while\
    \ j > 0 && arr[j] > arr[j - 1] {\n            res.swap(j, j - 1);\n          \
    \  j -= 1;\n        }\n        res.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > res[0] {\n           \
    \ res.remove(0);\n            let mut j = res.len() - 1;\n            while j\
    \ > 0 && arr[i as usize] > res[j - 1] {\n                res.swap(j, j - 1);\n\
    \                j -= 1;\n            }\n            res.push(arr[i as usize]);\n\
    \        }\n    }\n    res", "    let mut result = Vec::with_capacity(k as usize);\n\
    \    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n        heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > heap.peek().unwrap() {\n            heap.pop();\n            heap.push(arr[i\
    \ as usize]);\n        }\n    }\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut heap = BinaryHeap::new();\n    for i in 0..arr.len()\
    \ {\n        heap.push(arr[i]);\n        if heap.len() > k as usize {\n      \
    \      heap.pop();\n        }\n    }\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut res = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    arr.sort();\n    for i in (0..k).rev()\
    \ {\n        res.push(arr[i as usize]);\n    }\n    res", "    let mut result\
    \ = Vec::with_capacity(k as usize);\n    let mut heap = BinaryHeap::new();\n \
    \   for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    heap.into_sorted_vec()", "    let mut res = vec![];\n    let mut max_heap\
    \ = BinaryHeap::new();\n    for i in 0..k {\n        max_heap.push(arr[i as usize]);\n\
    \    }\n    for i in k..arr.len() as isize {\n        if arr[i as usize] > max_heap.peek().unwrap()\
    \ {\n            max_heap.pop();\n            max_heap.push(arr[i as usize]);\n\
    \        }\n    }\n    while !max_heap.is_empty() {\n        res.push(max_heap.pop().unwrap());\n\
    \    }\n    res.reverse();\n    res", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    let mut k = k;\n    while k > 0 {\n\
    \        let mut max = isize::min_value();\n        let mut max_index = 0;\n \
    \       for (i, &x) in arr.iter().enumerate() {\n            if x > max {\n  \
    \              max = x;\n                max_index = i;\n            }\n     \
    \   }\n        result.push(max);\n        arr.remove(max_index);\n        k -=\
    \ 1;\n    }\n    result", "    let mut res = Vec::with_capacity(k as usize);\n\
    \    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n        heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > heap.peek().unwrap() {\n            heap.pop();\n            heap.push(arr[i\
    \ as usize]);\n        }\n    }\n    while let Some(x) = heap.pop() {\n      \
    \  res.push(x);\n    }\n    res.reverse();\n    res", "    let mut arr = arr;\n\
    \    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()", " \
    \   let mut res = Vec::with_capacity(k as usize);\n    for i in 0..k {\n     \
    \   let mut max = std::isize::MIN;\n        let mut max_idx = 0;\n        for\
    \ j in 0..arr.len() {\n            if arr[j] > max {\n                max = arr[j];\n\
    \                max_idx = j;\n            }\n        }\n        res.push(max);\n\
    \        arr[max_idx] = std::isize::MIN;\n    }\n    res", "    let mut result\
    \ = vec![];\n    let mut max_heap = BinaryHeap::new();\n    for i in 0..k {\n\
    \        max_heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as\
    \ isize {\n        if arr[i as usize] > max_heap.peek().unwrap() {\n         \
    \   max_heap.pop();\n            max_heap.push(arr[i as usize]);\n        }\n\
    \    }\n    while !max_heap.is_empty() {\n        result.push(max_heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n   \
    \     heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize {\n\
    \        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    while let Some(x)\
    \ = heap.pop() {\n        result.push(x);\n    }\n    result.reverse();\n    result",
  "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut result = Vec::with_capacity(k as usize);\n\
    \    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n        heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > heap.peek().unwrap() {\n            heap.pop();\n            heap.push(arr[i\
    \ as usize]);\n        }\n    }\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result"]
stop_tokens:
- "\n}"
