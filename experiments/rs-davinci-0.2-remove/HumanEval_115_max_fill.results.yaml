language: rs
name: HumanEval_115_max_fill
results:
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  let mut fill = 0;\n    for row in grid {\n        for &col in row.iter() {\n\
    \            fill += col;\n            if fill > capacity {\n                max_fill\
    \ += 1;\n                fill = 0;\n            }\n        }\n        max_fill\
    \ += 1;\n        fill = 0;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpds4mo_p_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut sum = 0;\n        for &well in row.iter() {\n\
    \            sum += well;\n            if sum == capacity {\n                count\
    \ += 1;\n                sum = 0;\n            }\n        }\n        if sum >\
    \ 0 {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let rows = grid.len();\n    let cols = grid[0].len();\n\
    \    for i in 0..rows {\n        for j in 0..cols {\n            if grid[i][j]\
    \ == 1 {\n                count += 1;\n                let mut curr_row = i;\n\
    \                while curr_row < rows && grid[curr_row][j] == 1 {\n         \
    \           grid[curr_row][j] = 0;\n                    curr_row += 1;\n     \
    \           }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpje1adxih.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for row in grid {\n        let mut max\
    \ = 0;\n        for &x in row.iter() {\n            max = max.max(x);\n      \
    \  }\n        row_max.push(max);\n    }\n    for &max in row_max.iter() {\n  \
    \      result += max / capacity;\n        if max % capacity != 0 {\n         \
    \   result += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpau92zoxh.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n      \
    \  for well in row {\n            if well == 1 {\n                fill += 1;\n\
    \            } else {\n                if fill > max_fill {\n                \
    \    max_fill = fill;\n                }\n                fill = 0;\n        \
    \    }\n        }\n        if fill > max_fill {\n            max_fill = fill;\n\
    \        }\n        result += max_fill / capacity;\n        if max_fill % capacity\
    \ != 0 {\n            result += 1;\n        }\n        max_fill = 0;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747067
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut row = 0;\n    let mut col = 0;\n    let mut max_row = 0;\n    let mut max_col\
    \ = 0;\n    let mut max_val = 0;\n    let mut max_val_row = 0;\n    let mut max_val_col\
    \ = 0;\n    let mut max_row_val = 0;\n    let mut max_col_val = 0;\n    let mut\
    \ max_row_val_row = 0;\n    let mut max_col_val_col = 0;\n    let mut max_row_val_col\
    \ = 0;\n    let mut max_col_val_row = 0;\n    let mut max_row_val_row_col = 0;\n\
    \    let mut max_col_val_row_col = 0;\n    let mut max_row_val_row_col_val = 0;\n\
    \    let mut max_col_val_row_col_val = 0;\n    let mut max_row_val_row_col_val_row\
    \ = 0;\n    let mut max_col_val_row_col_val_row = 0;\n    let mut max_row_val_row_col_val_row_col\
    \ = 0;\n    let mut max_col_val_row_col_val_row_col = 0;\n    let mut max_row_val_row_col_val_row_col_val\
    \ = 0;\n    let mut max_col_val_row_col_val_row_col_val = 0;\n    let mut max_row_val_row_col_val_row_col_val_row\
    \ = 0;\n    let mut max_col_val_row_col_val_row_col_val_row = 0;\n    let mut\
    \ max_row_val_row_col_val_row_col_val_row_col = 0;\n    let mut max_col_val_row_col_val_row_col_val_row_col\
    \ = 0;\n    let mut max_row_val_row_col_val_row_col_val_row_col_val = 0;\n   \
    \ let mut max_col_val_row_col_val_\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6mvq9o8a.rs:46:37\n   |\n\
    46 |     let mut max_col_val_row_col_val_\n   |                              \
    \       ^ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6mvq9o8a.rs:16:56\n   |\n16 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    --------             \
    \                               ^^^^^ expected `isize`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max_row = 0;\n    let mut max_col = 0;\n    for row in grid.iter() {\n \
    \       let mut row_count = 0;\n        for col in row.iter() {\n            if\
    \ *col == 1 {\n                row_count += 1;\n            }\n        }\n   \
    \     if row_count > max_row {\n            max_row = row_count;\n        }\n\
    \    }\n    for col in 0..grid[0].len() {\n        let mut col_count = 0;\n  \
    \      for row in grid.iter() {\n            if row[col] == 1 {\n            \
    \    col_count += 1;\n            }\n        }\n        if col_count > max_col\
    \ {\n            max_col = col_count;\n        }\n    }\n    if max_row > capacity\
    \ {\n        count += max_row / capacity;\n        if max_row % capacity != 0\
    \ {\n            count += 1;\n        }\n    } else {\n        count += 1;\n \
    \   }\n    if max_col > capacity {\n        count += max_col / capacity;\n   \
    \     if max_col % capacity != 0 {\n            count += 1;\n        }\n    }\
    \ else {\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmpbikr0s2_.rs:64:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut sum = 0;\n        for &cell in row.iter() {\n\
    \            sum += cell;\n            if sum == capacity {\n                count\
    \ += 1;\n                sum = 0;\n            }\n        }\n        if sum >\
    \ 0 {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747067
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut max_fill = 0;\n    for row in grid {\n        for &well in &row {\n    \
    \        max_fill += well;\n        }\n    }\n    while max_fill > 0 {\n     \
    \   let mut fill = 0;\n        for row in grid.iter() {\n            let mut row_fill\
    \ = 0;\n            for &well in row {\n                if well > 0 {\n      \
    \              row_fill += 1;\n                }\n            }\n            fill\
    \ += row_fill;\n            if fill > capacity {\n                break;\n   \
    \         }\n        }\n        if fill > capacity {\n            result += 1;\n\
    \            for row in grid.iter_mut() {\n                for well in row.iter_mut()\
    \ {\n                    if *well > 0 {\n                        *well -= 1;\n\
    \                    }\n                }\n            }\n        } else {\n \
    \           max_fill = 0;\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `grid`\n    --> /tmp/tmpzx4_grkn.rs:26:20\n\
    \     |\n16   | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \     |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19   |     for row in grid {\n\
    \     |                ----\n     |                |\n     |                `grid`\
    \ moved due to this implicit call to `.into_iter()`\n     |                help:\
    \ consider borrowing to avoid moving into the for loop: `&grid`\n...\n26   | \
    \        for row in grid.iter() {\n     |                    ^^^^^^^^^^^ value\
    \ borrowed here after move\n     |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `grid`\n     = note: borrow occurs due to deref\
    \ coercion to `[Vec<isize>]`\nnote: deref defined here\n\nerror[E0596]: cannot\
    \ borrow `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmpzx4_grkn.rs:40:24\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n40 |             for row in grid.iter_mut() {\n   |                     \
    \   ^^^^ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0382, E0596.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    for row in grid.iter_mut() {\n        let mut row_sum\
    \ = 0;\n        for cell in row.iter_mut() {\n            row_sum += *cell;\n\
    \            *cell = 0;\n        }\n        count += row_sum / capacity;\n   \
    \     if row_sum % capacity != 0 {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747067
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid {\n        let mut height = 0;\n  \
    \      for &cell in row.iter() {\n            if cell == 1 {\n               \
    \ height += 1;\n            }\n        }\n        max_height = max(max_height,\
    \ height);\n    }\n    for height in 0..max_height {\n        let mut fill = 0;\n\
    \        for row in grid {\n            for &cell in row.iter() {\n          \
    \      if cell == 1 {\n                    fill += 1;\n                }\n   \
    \             if fill == capacity {\n                    result += 1;\n      \
    \              fill = 0;\n                }\n            }\n        }\n      \
    \  if fill > 0 {\n            result += 1;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpiduykdgt.rs:26:22\n\
    \   |\n26 |         max_height = max(max_height, height);\n   |              \
    \        ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     fill = capacity;\n            }\n        }\n        max_fill = max(max_fill,\
    \ fill);\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp3eap0233.rs:26:20\n\
    \   |\n26 |         max_fill = max(max_fill, fill);\n   |                    ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell == 1 {\n                *cell = capacity;\n        \
    \        count += 1;\n            }\n        }\n    }\n    let mut result = 0;\n\
    \    let mut row = 0;\n    while row < grid.len() {\n        let mut col = 0;\n\
    \        while col < grid[row].len() {\n            if grid[row][col] > 0 {\n\
    \                result += 1;\n                let mut i = row;\n            \
    \    while i < grid.len() && grid[i][col] > 0 {\n                    grid[i][col]\
    \ -= 1;\n                    i += 1;\n                }\n            }\n     \
    \       col += 1;\n        }\n        row += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpxycjvuar.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut res = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for row in grid {\n        let mut max\
    \ = 0;\n        for &col in row.iter() {\n            max = max.max(col);\n  \
    \      }\n        row_max.push(max);\n    }\n    for &max in row_max.iter() {\n\
    \        res += max / capacity;\n        if max % capacity != 0 {\n          \
    \  res += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpnb_y6mmv.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        let mut height = 0;\n        for cell in row.iter_mut() {\n     \
    \       if *cell == 1 {\n                height += 1;\n            } else {\n\
    \                height = 0;\n            }\n            *cell = height;\n   \
    \     }\n        max_height = max(max_height, height);\n    }\n    for height\
    \ in 1..=max_height {\n        for row in grid.iter_mut() {\n            let mut\
    \ filled = false;\n            for cell in row.iter_mut() {\n                if\
    \ *cell >= height {\n                    *cell -= 1;\n                    filled\
    \ = true;\n                }\n            }\n            if filled {\n       \
    \         count += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp8m4wbh56.rs:30:22\n\
    \   |\n30 |         max_height = max(max_height, height);\n   |              \
    \        ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut wells = grid.iter().map(|row| row.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    while wells.iter().any(|&w| w > 0) {\n        let mut filled = 0;\n     \
    \   for w in wells.iter_mut() {\n            if *w > capacity {\n            \
    \    *w -= capacity;\n                filled += capacity;\n            } else\
    \ {\n                filled += *w;\n                *w = 0;\n            }\n \
    \       }\n        count += 1;\n        for w in wells.iter_mut() {\n        \
    \    if *w > 0 {\n                let fill = std::cmp::min(*w, filled);\n    \
    \            *w -= fill;\n                filled -= fill;\n            }\n   \
    \     }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpszh8no5z.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut row = 0;\n    let mut col = 0;\n    let mut max_row = 0;\n    let mut max_col\
    \ = 0;\n    let mut max_val = 0;\n    let mut max_val_row = 0;\n    let mut max_val_col\
    \ = 0;\n    let mut max_val_row_col = 0;\n    let mut max_val_col_row = 0;\n \
    \   let mut max_val_row_col_row = 0;\n    let mut max_val_col_row_col = 0;\n \
    \   let mut max_val_row_col_row_col = 0;\n    let mut max_val_col_row_col_row\
    \ = 0;\n    let mut max_val_row_col_row_col_row = 0;\n    let mut max_val_col_row_col_row_col\
    \ = 0;\n    let mut max_val_row_col_row_col_row_col = 0;\n    let mut max_val_col_row_col_row_col_row\
    \ = 0;\n    let mut max_val_row_col_row_col_row_col_row = 0;\n    let mut max_val_col_row_col_row_col_row_col\
    \ = 0;\n    let mut max_val_row_col_row_col_row_col_row_col = 0;\n    let mut\
    \ max_val_col_row_col_row_col_row_col_row = 0;\n    let mut max_val_row_col_row_col_row_col_row_col_row\
    \ = 0;\n    let mut max_val_col_row_col_row_col_row_col_row_col = 0;\n    let\
    \ mut max_val_row_col_row_col_row_col_row_col_row_col = 0;\n    let mut max_val_col_row_col_row_col_row_col_row_col_row\
    \ = 0;\n    let mut max_val_row_col_row_col_row_col_row_col_row_col_row = 0;\n\
    \    let mut max_\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpre8rasdp.rs:44:17\n   |\n\
    44 |     let mut max_\n   |                 ^ help: add `;` here\n45 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpre8rasdp.rs:16:56\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |    --------                                            ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     fill = capacity;\n            }\n        }\n        max_fill = max_fill.max(fill);\n\
    \    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp9kiu54bj.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max_fill = 0;\n    for row in grid {\n        for cell in row {\n      \
    \      if cell == 1 {\n                max_fill += 1;\n            }\n       \
    \ }\n    }\n    while max_fill > 0 {\n        for row in grid {\n            for\
    \ cell in row {\n                if cell == 1 {\n                    max_fill\
    \ -= 1;\n                    count += 1;\n                }\n            }\n \
    \       }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmp7wnomnt2.rs:16:36\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `grid`\n   --> /tmp/tmp7wnomnt2.rs:27:20\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n27  |         for row in grid {\n    |                    ^^^^ `grid` moved\
    \ due to this implicit call to `.into_iter()`, in previous iteration of loop\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `grid`\nhelp: consider borrowing to avoid moving into the for loop\n    |\n\
    27  |         for row in &grid {\n    |                    ~~~~~\nhelp: consider\
    \ borrowing to avoid moving into the for loop\n    |\n19  |     for row in &grid\
    \ {\n    |                ~~~~~\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut i = 0;\n    while i < grid.len() {\n       \
    \ let mut j = 0;\n        while j < grid[i].len() {\n            if grid[i][j]\
    \ == 1 {\n                let mut k = i;\n                while k < grid.len()\
    \ && grid[k][j] == 1 {\n                    grid[k][j] = 0;\n                \
    \    k += 1;\n                }\n                count += 1;\n            }\n\
    \            j += 1;\n        }\n        i += 1;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmp1e5wmuui.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut i = 0;\n    while i < grid.len() {\n       \
    \ let mut j = 0;\n        while j < grid[i].len() {\n            if grid[i][j]\
    \ == 1 {\n                grid[i][j] = 0;\n                count += 1;\n     \
    \           let mut k = i + 1;\n                while k < grid.len() && capacity\
    \ > 0 {\n                    if grid[k][j] == 1 {\n                        grid[k][j]\
    \ = 0;\n                        capacity -= 1;\n                    }\n      \
    \              k += 1;\n                }\n            }\n            j += 1;\n\
    \        }\n        i += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `capacity`\n  --> /tmp/tmpymkljz42.rs:30:25\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    -------- help: consider making this binding\
    \ mutable: `mut capacity`\n...\n30 |                         capacity -= 1;\n\
    \   |                         ^^^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_row = 0;\n    for row in grid.iter_mut()\
    \ {\n        let mut sum = 0;\n        for col in row.iter_mut() {\n         \
    \   sum += *col;\n        }\n        max_row = max(max_row, sum);\n    }\n   \
    \ for _ in 0..max_row {\n        for row in grid.iter_mut() {\n            let\
    \ mut sum = 0;\n            for col in row.iter_mut() {\n                sum +=\
    \ *col;\n            }\n            if sum > capacity {\n                *row\
    \ = row.iter().map(|x| x - 1).collect();\n                count += 1;\n      \
    \      }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpxw504aim.rs:25:19\n\
    \   |\n25 |         max_row = max(max_row, sum);\n   |                   ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut water = 0;\n    for row in grid {\n        for &well in &row {\n       \
    \     water += well;\n            if water == capacity {\n                result\
    \ += 1;\n                water = 0;\n            } else if water > capacity {\n\
    \                result += 1;\n                water = well;\n            }\n\
    \        }\n        if water > 0 {\n            result += 1;\n            water\
    \ = 0;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for well in row {\n \
    \           fill += well;\n            if fill > capacity {\n                max_fill\
    \ += 1;\n                fill = well;\n            }\n        }\n        max_fill\
    \ += 1;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpoil66_hw.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut row = 0;\n    let mut col = 0;\n    let mut row_max = 0;\n    let mut col_max\
    \ = 0;\n    let mut row_sum = 0;\n    let mut col_sum = 0;\n    let mut row_max_index\
    \ = 0;\n    let mut col_max_index = 0;\n    let mut row_sum_index = 0;\n    let\
    \ mut col_sum_index = 0;\n    let mut row_max_count = 0;\n    let mut col_max_count\
    \ = 0;\n    let mut row_sum_count = 0;\n    let mut col_sum_count = 0;\n    let\
    \ mut row_max_count_index = 0;\n    let mut col_max_count_index = 0;\n    let\
    \ mut row_sum_count_index = 0;\n    let mut col_sum_count_index = 0;\n    let\
    \ mut row_max_count_index_max = 0;\n    let mut col_max_count_index_max = 0;\n\
    \    let mut row_sum_count_index_max = 0;\n    let mut col_sum_count_index_max\
    \ = 0;\n    let mut row_max_count_index_max_count = 0;\n    let mut col_max_count_index_max_count\
    \ = 0;\n    let mut row_sum_count_index_max_count = 0;\n    let mut col_sum_count_index_max_count\
    \ = 0;\n    let mut row_max_count_index_max_count_index = 0;\n    let mut col_max_count_index_max_count_index\
    \ = 0;\n    let mut row_sum_count_index_max_count_index = 0;\n    let mut col_sum_count_index_max_count_index\
    \ = 0;\n    let mut row_max_count_index_max_count_index_max = 0;\n    let mut\
    \ col_max_count_index_max_count_index_max = 0;\n    let mut row_sum_count_index_max_count_index_max\
    \ = 0;\n    let mut col_sum_count_index_max_\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp198_r6aa.rs:51:37\n   |\n\
    51 |     let mut col_sum_count_index_max_\n   |                              \
    \       ^ help: add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp198_r6aa.rs:16:56\n   |\n16 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    --------             \
    \                               ^^^^^ expected `isize`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut wells = grid.clone();\n    let mut i = 0;\n    while i < wells.len() {\n\
    \        let mut j = 0;\n        while j < wells[i].len() {\n            if wells[i][j]\
    \ == 1 {\n                let mut k = i;\n                while k < wells.len()\
    \ && wells[k][j] == 1 {\n                    wells[k][j] = 0;\n              \
    \      k += 1;\n                }\n                count += 1;\n            }\n\
    \            j += 1;\n        }\n        i += 1;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmp6522a5zy.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     fill = capacity;\n            }\n        }\n        max_fill = max(max_fill,\
    \ fill);\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp3eap0233.rs:26:20\n\
    \   |\n26 |         max_fill = max(max_fill, fill);\n   |                    ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut grid = grid;\n    let mut row = 0;\n    let mut col = 0;\n    let mut row_max\
    \ = 0;\n    let mut col_max = 0;\n    let mut row_max_index = 0;\n    let mut\
    \ col_max_index = 0;\n    let mut row_max_count = 0;\n    let mut col_max_count\
    \ = 0;\n    let mut row_max_count_index = 0;\n    let mut col_max_count_index\
    \ = 0;\n    let mut row_max_count_index_max = 0;\n    let mut col_max_count_index_max\
    \ = 0;\n    let mut row_max_count_max = 0;\n    let mut col_max_count_max = 0;\n\
    \    let mut row_max_count_index_max_count = 0;\n    let mut col_max_count_index_max_count\
    \ = 0;\n    let mut row_max_count_index_max_count_max = 0;\n    let mut col_max_count_index_max_count_max\
    \ = 0;\n    let mut row_max_count_index_max_count_max_count = 0;\n    let mut\
    \ col_max_count_index_max_count_max_count = 0;\n    let mut row_max_count_index_max_count_max_count_max\
    \ = 0;\n    let mut col_max_count_index_max_count_max_count_max = 0;\n    let\
    \ mut row_max_count_index_max_count_max_count_max_count = 0;\n    let mut col_max_count_index_max_count_max_count_max_count\
    \ = 0;\n    let mut row_max_count_index_max_count_max_count_max_count_max = 0;\n\
    \    let mut col_max_count_index_max_count_max_count_max_count_max = 0;\n    let\
    \ mut row_max_count_index_max_count_max_count_max_count_max_count = 0;\n    let\
    \ mut col_max_count_index_max_count_max_\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb0kw6b7w.rs:46:47\n   |\n\
    46 |     let mut col_max_count_index_max_count_max_\n   |                    \
    \                           ^ help: add `;` here\n47 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpb0kw6b7w.rs:16:56\n   |\n16 |\
    \ fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    --------\
    \                                            ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut current = 0;\n    for row in grid {\n        for col in row {\n        \
    \    if col == 1 {\n                current += 1;\n            }\n        }\n\
    \        result += current / capacity;\n        current = current % capacity;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmprkq5pc4p.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max_fill = 0;\n    for row in grid {\n        for &well in row.iter() {\n\
    \            if well == 1 {\n                max_fill += 1;\n            }\n \
    \       }\n    }\n    let mut fill = 0;\n    for row in grid {\n        for &well\
    \ in row.iter() {\n            if well == 1 {\n                fill += 1;\n  \
    \          }\n            if fill == max_fill {\n                count += 1;\n\
    \                fill = 0;\n            }\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpcfq1h4xg.rs:16:36\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `grid`\n   --> /tmp/tmpcfq1h4xg.rs:27:16\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for row in grid {\n\
    \    |                ----\n    |                |\n    |                `grid`\
    \ moved due to this implicit call to `.into_iter()`\n    |                help:\
    \ consider borrowing to avoid moving into the for loop: `&grid`\n...\n27  |  \
    \   for row in grid {\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `grid`\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = well;\n            }\n        }\n\
    \        max_fill += fill / capacity;\n    }\n    max_fill\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmp3y0_gzlr.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut filled = 0;\n        for &cell in row.iter()\
    \ {\n            filled += cell;\n            if filled == capacity {\n      \
    \          count += 1;\n                filled = 0;\n            }\n        }\n\
    \        if filled > 0 {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     fill = capacity;\n            }\n        }\n        max_fill = std::cmp::max(max_fill,\
    \ fill);\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp2nsyxmbk.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for row in grid {\n        let mut row_max_val\
    \ = 0;\n        for (i, &val) in row.iter().enumerate() {\n            row_max_val\
    \ = std::cmp::max(row_max_val, val);\n            row_max[i] = std::cmp::max(row_max[i],\
    \ val);\n        }\n        result += row_max_val;\n    }\n    for &val in row_max.iter()\
    \ {\n        result += val;\n    }\n    result - capacity * grid.len() as isize\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmpi4a2z16p.rs:30:25\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for row in grid {\n\
    \    |                ----\n    |                |\n    |                `grid`\
    \ moved due to this implicit call to `.into_iter()`\n    |                help:\
    \ consider borrowing to avoid moving into the for loop: `&grid`\n...\n30  |  \
    \   result - capacity * grid.len() as isize\n    |                         ^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `grid`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for (i, row) in grid.iter().enumerate()\
    \ {\n        let mut max = 0;\n        for &c in row {\n            max = max.max(c);\n\
    \        }\n        row_max[i] = max;\n    }\n    let mut col_max = vec![0; grid[0].len()];\n\
    \    for j in 0..grid[0].len() {\n        let mut max = 0;\n        for i in 0..grid.len()\
    \ {\n            max = max.max(grid[i][j]);\n        }\n        col_max[j] = max;\n\
    \    }\n    for i in 0..grid.len() {\n        for j in 0..grid[0].len() {\n  \
    \          let max = row_max[i].min(col_max[j]);\n            if grid[i][j] <\
    \ max {\n                count += max - grid[i][j];\n            }\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp0mhowxd9.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        let mut row_max = 0;\n        for cell in row.iter_mut() {\n    \
    \        if *cell == 1 {\n                row_max += 1;\n            }\n     \
    \   }\n        if row_max > max_height {\n            max_height = row_max;\n\
    \        }\n    }\n    for _ in 0..max_height {\n        for row in grid.iter_mut()\
    \ {\n            for cell in row.iter_mut() {\n                if *cell == 1 {\n\
    \                    *cell = 0;\n                    count += 1;\n           \
    \     }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmp1asz852g.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_row = 0;\n    let mut max_col = 0;\n   \
    \ let mut max_val = 0;\n    let mut max_row_idx = 0;\n    let mut max_col_idx\
    \ = 0;\n    let mut max_val_idx = 0;\n    let mut max_val_idx_row = 0;\n    let\
    \ mut max_val_idx_col = 0;\n    let mut max_val_idx_row_idx = 0;\n    let mut\
    \ max_val_idx_col_idx = 0;\n    let mut max_val_idx_row_idx_col = 0;\n    let\
    \ mut max_val_idx_row_idx_col_idx = 0;\n    let mut max_val_idx_row_idx_col_idx_val\
    \ = 0;\n    let mut max_val_idx_row_idx_col_idx_val_row = 0;\n    let mut max_val_idx_row_idx_col_idx_val_row_idx\
    \ = 0;\n    let mut max_val_idx_row_idx_col_idx_val_row_idx_col = 0;\n    let\
    \ mut max_val_idx_row_idx_col_idx_val_row_idx_col_idx = 0;\n    let mut max_val_idx_row_idx_col_idx_val_row_idx_col_idx_val\
    \ = 0;\n    let mut max_val_idx_row_idx_col_idx_val_row_idx_col_idx_val_row =\
    \ 0;\n    let mut max_val_idx_row_idx_col_idx_val_row_idx_col_idx_val_row_idx\
    \ = 0;\n    let mut max_val_idx_row_idx_col_idx_val_row_idx_col_idx_val_row_idx_col\
    \ = 0;\n    let mut max_val\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp94yfbppp.rs:40:20\n   |\n\
    40 |     let mut max_val\n   |                    ^ help: add `;` here\n41 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp94yfbppp.rs:16:56\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |    --------                                            ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut grid = grid;\n    let mut full = vec![false; grid.len()];\n    let mut empty\
    \ = vec![false; grid.len()];\n    let mut i = 0;\n    while i < grid.len() {\n\
    \        if full[i] {\n            i += 1;\n            continue;\n        }\n\
    \        let mut j = 0;\n        while j < grid[i].len() {\n            if grid[i][j]\
    \ == 1 {\n                grid[i][j] = 0;\n                if j == grid[i].len()\
    \ - 1 {\n                    full[i] = true;\n                }\n            \
    \    if capacity == 1 {\n                    count += 1;\n                }\n\
    \            } else {\n                if capacity > 1 {\n                   \
    \ count += 1;\n                }\n                if j == grid[i].len() - 1 {\n\
    \                    empty[i] = true;\n                }\n            }\n    \
    \        j += 1;\n        }\n        i += 1;\n    }\n    let mut i = 0;\n    while\
    \ i < grid.len() {\n        if empty[i] {\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = 0;\n        while j < grid[i].len() {\n      \
    \      if grid[i][j] == 1 {\n                grid[i][j] = 0;\n               \
    \ if j == grid[i].len() - 1 {\n                    empty[i] = true;\n        \
    \        }\n                if capacity == 1 {\n                    count += 1;\n\
    \                }\n            } else {\n                if capacity > 1 {\n\
    \                    count += 1;\n                }\n                if j == grid[i].len()\
    \ - 1 {\n                    full[i] = true;\n                }\n            }\n\
    \            j += 1;\n        }\n        i += 1;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `19`,\n right: `5`', /tmp/tmpouhmstlz.rs:83:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut sum = 0;\n        for cell in row {\n       \
    \     sum += cell;\n            if sum == capacity {\n                count +=\
    \ 1;\n                sum = 0;\n            }\n        }\n        if sum > 0 {\n\
    \            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max_row = 0;\n    let mut max_col = 0;\n    let mut max_val = 0;\n    for\
    \ (row, cols) in grid.iter().enumerate() {\n        for (col, val) in cols.iter().enumerate()\
    \ {\n            if *val > max_val {\n                max_val = *val;\n      \
    \          max_row = row;\n                max_col = col;\n            }\n   \
    \     }\n    }\n    let mut grid = grid;\n    while max_val > 0 {\n        let\
    \ mut bucket = capacity;\n        for row in 0..grid.len() {\n            for\
    \ col in 0..grid[row].len() {\n                if grid[row][col] > 0 {\n     \
    \               if bucket > grid[row][col] {\n                        bucket -=\
    \ grid[row][col];\n                        grid[row][col] = 0;\n             \
    \       } else {\n                        grid[row][col] -= bucket;\n        \
    \                bucket = 0;\n                    }\n                }\n     \
    \       }\n        }\n        count += 1;\n        max_val = 0;\n        for (row,\
    \ cols) in grid.iter().enumerate() {\n            for (col, val) in cols.iter().enumerate()\
    \ {\n                if *val > max_val {\n                    max_val = *val;\n\
    \                    max_row = row;\n                    max_col = col;\n    \
    \            }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmpwxeeu9h9.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            if well == 1 {\n                fill += 1;\n            } else\
    \ {\n                max_fill = max_fill.max(fill);\n                fill = 0;\n\
    \            }\n        }\n        max_fill = max_fill.max(fill);\n    }\n   \
    \ (max_fill as f64 / capacity as f64).ceil() as isize\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmptjcad04o.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = 0;\n            }\n        }\n  \
    \      if fill > 0 {\n            max_fill += 1;\n        }\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp57z_cf0g.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for well in row {\n \
    \           if well == 1 {\n                fill += 1;\n            }\n      \
    \  }\n        max_fill = std::cmp::max(max_fill, fill);\n    }\n    max_fill /\
    \ capacity + if max_fill % capacity == 0 { 0 } else { 1 }\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpx33nvkck.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for row in grid {\n        let max =\
    \ row.iter().max().unwrap();\n        row_max.push(*max);\n    }\n    let max\
    \ = row_max.iter().max().unwrap();\n    while max > 0 {\n        for row in grid\
    \ {\n            for col in row {\n                if col > 0 {\n            \
    \        count += 1;\n                }\n            }\n        }\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvubi8gs7.rs:24:17\n   |\n\
    24 |     while max > 0 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        max_height = max_height.max(row.iter().sum());\n    }\n    for height\
    \ in 1..=max_height {\n        for row in grid.iter_mut() {\n            for cell\
    \ in row.iter_mut() {\n                if *cell >= height {\n                \
    \    *cell -= capacity;\n                    count += 1;\n                }\n\
    \            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpot83hqcv.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut max_level = 0;\n    for row in grid {\n        let mut level = 0;\n    \
    \    for &cell in &row {\n            if cell == 1 {\n                level +=\
    \ 1;\n            }\n        }\n        max_level = max(max_level, level);\n \
    \   }\n    for level in 1..=max_level {\n        let mut count = 0;\n        for\
    \ row in grid {\n            let mut level_count = 0;\n            for &cell in\
    \ &row {\n                if cell == 1 {\n                    level_count += 1;\n\
    \                }\n            }\n            if level_count >= level {\n   \
    \             count += 1;\n            }\n        }\n        result += count /\
    \ capacity;\n        if count % capacity != 0 {\n            result += 1;\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpbbvdi48h.rs:26:21\n\
    \   |\n26 |         max_level = max(max_level, level);\n   |                 \
    \    ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        for cell in row.iter_mut() {\n            if *cell == 1 {\n     \
    \           max_height += 1;\n            }\n        }\n    }\n    for i in 0..max_height\
    \ {\n        let mut filled = 0;\n        for row in grid.iter_mut() {\n     \
    \       for cell in row.iter_mut() {\n                if *cell == 1 {\n      \
    \              *cell = 0;\n                    filled += 1;\n                }\n\
    \            }\n        }\n        if filled > 0 {\n            count += 1;\n\
    \        }\n        if filled > capacity {\n            for row in grid.iter_mut()\
    \ {\n                for cell in row.iter_mut() {\n                    if *cell\
    \ == 0 {\n                        *cell = 1;\n                    }\n        \
    \        }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmp90wap9yi.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill_count = 0;\n\
    \    let mut grid = grid;\n    let mut row_max = vec![0; grid.len()];\n    for\
    \ row in grid.iter_mut() {\n        let mut max = 0;\n        for cell in row.iter_mut()\
    \ {\n            if *cell == 1 {\n                *cell = capacity;\n        \
    \        max += capacity;\n            }\n        }\n        row_max.push(max);\n\
    \    }\n    let mut col_max = vec![0; grid[0].len()];\n    for col in 0..grid[0].len()\
    \ {\n        let mut max = 0;\n        for row in 0..grid.len() {\n          \
    \  if grid[row][col] == 1 {\n                grid[row][col] = capacity;\n    \
    \            max += capacity;\n            }\n        }\n        col_max.push(max);\n\
    \    }\n    let mut row_index = 0;\n    let mut col_index = 0;\n    while row_index\
    \ < grid.len() && col_index < grid[0].len() {\n        let row_max = row_max[row_index];\n\
    \        let col_max = col_max[col_index];\n        if row_max > col_max {\n \
    \           for col in 0..grid[0].len() {\n                if grid[row_index][col]\
    \ == capacity {\n                    grid[row_index][col] = 0;\n             \
    \       col_max[col] -= capacity;\n                }\n            }\n        \
    \    row_index += 1;\n        } else {\n            for row in 0..grid.len() {\n\
    \                if grid[row][col_index] == capacity {\n                    grid[row][col_index]\
    \ = 0;\n                    row_max[row] -= capacity;\n                }\n   \
    \         }\n            col_index += 1;\n        }\n        fill_count += 1;\n\
    \    }\n    fill_count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmpq09_bt5u.rs:50:21\n\
    \   |\n50 |                     col_max[col] -= capacity;\n   |              \
    \       ^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `isize`\n\
    \  --> /tmp/tmpq09_bt5u.rs:58:21\n   |\n58 |                     row_max[row]\
    \ -= capacity;\n   |                     ^^^^^^^^^^^^\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0608`.\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for row in grid {\n        let mut max\
    \ = 0;\n        for &cell in row.iter() {\n            max = std::cmp::max(max,\
    \ cell);\n        }\n        row_max.push(max);\n    }\n    let mut row_max =\
    \ row_max.into_iter().rev();\n    let mut row_max = row_max.peekable();\n    while\
    \ let Some(max) = row_max.next() {\n        if max == 0 {\n            continue;\n\
    \        }\n        let mut fill = capacity;\n        while fill > 0 {\n     \
    \       if let Some(next) = row_max.peek() {\n                if *next == 0 {\n\
    \                    break;\n                }\n            }\n            fill\
    \ -= max;\n            result += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmpjsttzxsv.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     fill = capacity;\n            }\n        }\n        max_fill = max(max_fill,\
    \ fill);\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp3eap0233.rs:26:20\n\
    \   |\n26 |         max_fill = max(max_fill, fill);\n   |                    ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for i in 0..grid.len() {\n        for\
    \ j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n                row_max[i]\
    \ = j as isize;\n            }\n        }\n    }\n    let mut col_max = vec![0;\
    \ grid[0].len()];\n    for j in 0..grid[0].len() {\n        for i in 0..grid.len()\
    \ {\n            if grid[i][j] == 1 {\n                col_max[j] = i as isize;\n\
    \            }\n        }\n    }\n    for i in 0..grid.len() {\n        for j\
    \ in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n                let\
    \ mut fill = capacity;\n                let mut row_max_fill = row_max[i];\n \
    \               let mut col_max_fill = col_max[j];\n                while fill\
    \ > 0 {\n                    if row_max_fill > col_max_fill {\n              \
    \          row_max_fill -= 1;\n                    } else {\n                \
    \        col_max_fill -= 1;\n                    }\n                    fill -=\
    \ 1;\n                }\n                if row_max_fill < 0 {\n             \
    \       row_max_fill = 0;\n                }\n                if col_max_fill\
    \ < 0 {\n                    col_max_fill = 0;\n                }\n          \
    \      count += (row_max_fill + col_max_fill) as isize;\n            }\n     \
    \   }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n   \
    \ assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `21`,\n right: `6`', /tmp/tmpbisagp31.rs:63:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        max_height = max_height.max(row.iter().sum());\n    }\n    for height\
    \ in 0..max_height {\n        for row in grid.iter_mut() {\n            for cell\
    \ in row.iter_mut() {\n                if *cell > 0 {\n                    *cell\
    \ -= 1;\n                    count += 1;\n                }\n            }\n \
    \       }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmp91a3lfjj.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = well;\n            }\n        }\n\
    \        max_fill += 1;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpzzsvzvb1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        let mut height = 0;\n        for cell in row.iter_mut() {\n     \
    \       if *cell == 1 {\n                height += 1;\n            } else {\n\
    \                height = 0;\n            }\n            *cell = height;\n   \
    \     }\n        max_height = max_height.max(height);\n    }\n    for row in grid.iter()\
    \ {\n        let mut height = 0;\n        for cell in row.iter() {\n         \
    \   height = height.max(*cell);\n            if height == max_height {\n     \
    \           break;\n            }\n        }\n        count += capacity - height;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `6`', /tmp/tmp_3wuc5pu.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid {\n        let mut height = 0;\n  \
    \      for &cell in row.iter() {\n            if cell == 1 {\n               \
    \ height += 1;\n            }\n        }\n        max_height = max(max_height,\
    \ height);\n    }\n    for height in 0..max_height {\n        let mut fill = 0;\n\
    \        for row in grid {\n            for &cell in row.iter() {\n          \
    \      if cell == 1 {\n                    fill += 1;\n                }\n   \
    \             if fill == capacity {\n                    result += 1;\n      \
    \              fill = 0;\n                }\n            }\n        }\n      \
    \  if fill > 0 {\n            result += 1;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpiduykdgt.rs:26:22\n\
    \   |\n26 |         max_height = max(max_height, height);\n   |              \
    \        ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = well;\n            }\n        }\n\
    \        max_fill += 1;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpzzsvzvb1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_row = 0;\n    let mut max_col = 0;\n   \
    \ for row in grid.iter() {\n        let mut sum = 0;\n        for col in row.iter()\
    \ {\n            sum += col;\n        }\n        if sum > max_row {\n        \
    \    max_row = sum;\n        }\n    }\n    for col in 0..grid[0].len() {\n   \
    \     let mut sum = 0;\n        for row in 0..grid.len() {\n            sum +=\
    \ grid[row][col];\n        }\n        if sum > max_col {\n            max_col\
    \ = sum;\n        }\n    }\n    let mut max = max_row;\n    if max_col > max_row\
    \ {\n        max = max_col;\n    }\n    let mut row_count = 0;\n    let mut col_count\
    \ = 0;\n    while max > 0 {\n        for row in 0..grid.len() {\n            for\
    \ col in 0..grid[0].len() {\n                if grid[row][col] > 0 {\n       \
    \             grid[row][col] -= 1;\n                    row_count += 1;\n    \
    \            }\n            }\n        }\n        for col in 0..grid[0].len()\
    \ {\n            for row in 0..grid.len() {\n                if grid[row][col]\
    \ > 0 {\n                    grid[row][col] -= 1;\n                    col_count\
    \ += 1;\n                }\n            }\n        }\n        max -= 1;\n    }\n\
    \    count = row_count + col_count;\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpuid7cddg.rs:71:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for well in row {\n \
    \           fill += well;\n            if fill > capacity {\n                max_fill\
    \ += 1;\n                fill = 0;\n            }\n        }\n        if fill\
    \ > 0 {\n            max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmplcncmt3k.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut current = 0;\n    for row in grid {\n        for &cell in row.iter() {\n\
    \            current += cell;\n            if current == capacity {\n        \
    \        result += 1;\n                current = 0;\n            } else if current\
    \ > capacity {\n                result += 1;\n                current = cell;\n\
    \            }\n        }\n        if current > 0 {\n            result += 1;\n\
    \            current = 0;\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747068
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid {\n        let mut height = 0;\n  \
    \      for cell in row {\n            if cell == 1 {\n                height +=\
    \ 1;\n            }\n        }\n        if height > max_height {\n           \
    \ max_height = height;\n        }\n    }\n    for height in 0..max_height {\n\
    \        let mut row_count = 0;\n        for row in grid {\n            let mut\
    \ cell_count = 0;\n            for cell in row {\n                if cell == 1\
    \ {\n                    cell_count += 1;\n                }\n            }\n\
    \            if cell_count > height {\n                row_count += 1;\n     \
    \       }\n        }\n        count += row_count / capacity;\n        if row_count\
    \ % capacity != 0 {\n            count += 1;\n        }\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `grid`\n   --> /tmp/tmpnecgua8x.rs:32:20\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n32  |         for row in grid {\n    |                    ^^^^ `grid` moved\
    \ due to this implicit call to `.into_iter()`, in previous iteration of loop\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `grid`\nhelp: consider borrowing to avoid moving into the for loop\n    |\n\
    32  |         for row in &grid {\n    |                    ~~~~~\nhelp: consider\
    \ borrowing to avoid moving into the for loop\n    |\n19  |     for row in &grid\
    \ {\n    |                ~~~~~\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut i = 0;\n    while i < grid.len() {\n       \
    \ let mut j = 0;\n        while j < grid[i].len() {\n            if grid[i][j]\
    \ == 1 {\n                let mut k = i;\n                while k < grid.len()\
    \ && grid[k][j] == 1 {\n                    grid[k][j] = 0;\n                \
    \    k += 1;\n                }\n                count += 1;\n            }\n\
    \            j += 1;\n        }\n        i += 1;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmp1e5wmuui.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            if grid[i][j] == 1 {\n                count += 1;\n         \
    \       let mut k = i;\n                while k < grid.len() && grid[k][j] ==\
    \ 1 {\n                    grid[k][j] = 0;\n                    k += 1;\n    \
    \            }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmptqlt6_n3.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut row = 0;\n    let mut col = 0;\n    let mut row_max = 0;\n    let mut col_max\
    \ = 0;\n    let mut row_sum = 0;\n    let mut col_sum = 0;\n    let mut row_max_index\
    \ = 0;\n    let mut col_max_index = 0;\n    let mut row_max_sum = 0;\n    let\
    \ mut col_max_sum = 0;\n    let mut row_max_index_sum = 0;\n    let mut col_max_index_sum\
    \ = 0;\n    let mut row_max_index_sum_max = 0;\n    let mut col_max_index_sum_max\
    \ = 0;\n    let mut row_max_index_sum_max_index = 0;\n    let mut col_max_index_sum_max_index\
    \ = 0;\n    let mut row_max_index_sum_max_index_sum = 0;\n    let mut col_max_index_sum_max_index_sum\
    \ = 0;\n    let mut row_max_index_sum_max_index_sum_max = 0;\n    let mut col_max_index_sum_max_index_sum_max\
    \ = 0;\n    let mut row_max_index_sum_max_index_sum_max_index = 0;\n    let mut\
    \ col_max_index_sum_max_index_sum_max_index = 0;\n    let mut row_max_index_sum_max_index_sum_max_index_sum\
    \ = 0;\n    let mut col_max_index_sum_max_index_sum_max_index_sum = 0;\n    let\
    \ mut row_max_index_sum_max_index_sum_max_index_sum_max = 0;\n    let mut col_max_index_sum_max_index_sum_max_index_sum_max\
    \ = 0;\n    let mut row_max_index_sum_max_index_sum_max_index_sum_max_index =\
    \ 0;\n    let mut col_max_index_sum_max_index_sum_max_index_sum_max_index = 0;\n\
    \    let mut\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp4vjfv6mw.rs:47:1\n\
    \   |\n47 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut row_max = 0;\n    for row in grid {\n        let mut row_fill = 0;\n   \
    \     for cell in row {\n            if cell == 1 {\n                row_fill\
    \ += 1;\n            }\n        }\n        if row_fill > row_max {\n         \
    \   row_max = row_fill;\n        }\n    }\n    let mut col_max = 0;\n    for col\
    \ in 0..grid[0].len() {\n        let mut col_fill = 0;\n        for row in grid\
    \ {\n            if row[col] == 1 {\n                col_fill += 1;\n        \
    \    }\n        }\n        if col_fill > col_max {\n            col_max = col_fill;\n\
    \        }\n    }\n    let mut row_fill = 0;\n    let mut col_fill = 0;\n    for\
    \ row in grid {\n        for cell in row {\n            if cell == 1 {\n     \
    \           row_fill += 1;\n                col_fill += 1;\n            }\n  \
    \      }\n        if row_fill > capacity {\n            count += row_fill / capacity;\n\
    \            row_fill = row_fill % capacity;\n        }\n        if col_fill >\
    \ capacity {\n            count += col_fill / capacity;\n            col_fill\
    \ = col_fill % capacity;\n        }\n    }\n    if row_fill > 0 {\n        count\
    \ += 1;\n    }\n    if col_fill > 0 {\n        count += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmpjfn4tpu8.rs:31:19\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for row in grid {\n\
    \    |                ----\n    |                |\n    |                `grid`\
    \ moved due to this implicit call to `.into_iter()`\n    |                help:\
    \ consider borrowing to avoid moving into the for loop: `&grid`\n...\n31  |  \
    \   for col in 0..grid[0].len() {\n    |                   ^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `grid`\n\nerror[E0382]: use of moved value: `grid`\n  -->\
    \ /tmp/tmpjfn4tpu8.rs:33:20\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n   |             ---- move occurs because `grid` has type\
    \ `Vec<Vec<isize>>`, which does not implement the `Copy` trait\n...\n19 |    \
    \ for row in grid {\n   |                ---- `grid` moved due to this implicit\
    \ call to `.into_iter()`\n...\n33 |         for row in grid {\n   |          \
    \          ^^^^ `grid` moved due to this implicit call to `.into_iter()`, in previous\
    \ iteration of loop\n   |\nhelp: consider borrowing to avoid moving into the for\
    \ loop\n   |\n33 |         for row in &grid {\n   |                    ~~~~~\n\
    help: consider borrowing to avoid moving into the for loop\n   |\n19 |     for\
    \ row in &grid {\n   |                ~~~~~\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid {\n        let mut row_height = 0;\n\
    \        for cell in row {\n            if cell == 1 {\n                row_height\
    \ += 1;\n            }\n        }\n        max_height = max(max_height, row_height);\n\
    \    }\n    for _ in 0..max_height {\n        for row in grid {\n            for\
    \ cell in row {\n                if cell == 1 {\n                    count +=\
    \ 1;\n                }\n            }\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpgt6wxitf.rs:26:22\n\
    \   |\n26 |         max_height = max(max_height, row_height);\n   |          \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    for\
    \ row in grid {\n        let mut row_fill = 0;\n        for well in row {\n  \
    \          if well == 1 {\n                row_fill += 1;\n            }\n   \
    \     }\n        fill += (row_fill + capacity - 1) / capacity;\n    }\n    fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill_count = 0;\n\
    \    let mut wells = grid;\n    let mut bucket = capacity;\n    let mut i = 0;\n\
    \    while i < wells.len() {\n        let mut j = 0;\n        while j < wells[i].len()\
    \ {\n            if wells[i][j] == 1 {\n                if bucket > 0 {\n    \
    \                bucket -= 1;\n                    wells[i][j] = 0;\n        \
    \        } else {\n                    fill_count += 1;\n                    bucket\
    \ = capacity;\n                    j -= 1;\n                }\n            }\n\
    \            j += 1;\n        }\n        i += 1;\n    }\n    fill_count\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpoeg2t9mp.rs:31:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747069
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut row_max = vec![0; grid.len()];\n    for row\
    \ in grid.iter_mut() {\n        let mut max = 0;\n        for cell in row.iter_mut()\
    \ {\n            if *cell == 1 {\n                max += 1;\n            }\n \
    \           *cell = max;\n        }\n    }\n    for (i, row) in grid.iter().enumerate()\
    \ {\n        let mut max = 0;\n        for cell in row.iter() {\n            if\
    \ *cell > max {\n                max = *cell;\n            }\n        }\n    \
    \    row_max[i] = max;\n    }\n    for row in grid.iter_mut() {\n        for cell\
    \ in row.iter_mut() {\n            if *cell > 0 {\n                *cell = 1;\n\
    \            }\n        }\n    }\n    for row in row_max.iter() {\n        count\
    \ += row / capacity;\n        if row % capacity > 0 {\n            count += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max = 0;\n    for row in grid.iter_mut() {\n\
    \        for cell in row.iter_mut() {\n            if *cell == 1 {\n         \
    \       *cell = capacity;\n            }\n        }\n    }\n    let mut done =\
    \ false;\n    while !done {\n        done = true;\n        for row in grid.iter_mut()\
    \ {\n            for cell in row.iter_mut() {\n                if *cell > 0 {\n\
    \                    done = false;\n                    *cell -= 1;\n        \
    \        }\n            }\n        }\n        count += 1;\n    }\n    count -\
    \ 1\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpjw69jdx9.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut filled = vec![0; grid.len()];\n    for row in grid {\n        for (i, &cell)\
    \ in row.iter().enumerate() {\n            if cell == 1 {\n                if\
    \ filled[i] < capacity {\n                    filled[i] += 1;\n              \
    \  } else {\n                    result += 1;\n                }\n           \
    \ }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmp2hc9p8jv.rs:22:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max = 0;\n    for row in grid.iter_mut() {\n\
    \        let mut row_max = 0;\n        for cell in row.iter_mut() {\n        \
    \    if *cell == 1 {\n                row_max += 1;\n            }\n        }\n\
    \        if row_max > max {\n            max = row_max;\n        }\n    }\n  \
    \  let mut row_max = 0;\n    for row in grid.iter_mut() {\n        for cell in\
    \ row.iter_mut() {\n            if *cell == 1 {\n                row_max += 1;\n\
    \            }\n        }\n        if row_max == max {\n            count += 1;\n\
    \            row_max = 0;\n        }\n    }\n    count\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmp0ohlftd3.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut wells = grid.iter().map(|row| row.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    let mut bucket = capacity;\n    for well in wells.iter_mut() {\n        if\
    \ *well > 0 {\n            if bucket >= *well {\n                bucket -= *well;\n\
    \                *well = 0;\n            } else {\n                *well -= bucket;\n\
    \                bucket = capacity;\n                count += 1;\n           \
    \ }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmpp5an_v7j.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max = 0;\n    for row in grid.iter_mut() {\n\
    \        let mut sum = 0;\n        for cell in row.iter_mut() {\n            sum\
    \ += *cell;\n            *cell = 0;\n        }\n        max = max.max(sum);\n\
    \    }\n    while max > 0 {\n        count += 1;\n        for row in grid.iter_mut()\
    \ {\n            let mut sum = 0;\n            for cell in row.iter_mut() {\n\
    \                sum += *cell;\n                if sum < capacity {\n        \
    \            *cell = 1;\n                } else {\n                    *cell =\
    \ 0;\n                }\n            }\n        }\n        max = 0;\n        for\
    \ row in grid.iter() {\n            let mut sum = 0;\n            for cell in\
    \ row.iter() {\n                sum += *cell;\n            }\n            max\
    \ = max.max(sum);\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmp3yr25xa_.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     fill = capacity;\n            }\n        }\n        max_fill = std::cmp::max(max_fill,\
    \ fill);\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp2nsyxmbk.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max_row = vec![0; grid[0].len()];\n    for row in grid {\n        for (i,\
    \ &cell) in row.iter().enumerate() {\n            if cell == 1 {\n           \
    \     max_row[i] += 1;\n            }\n        }\n    }\n    for &max in max_row.iter()\
    \ {\n        count += (max + capacity - 1) / capacity;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpc6al77rr.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut row = 0;\n    let mut col = 0;\n    let mut max_row = 0;\n    let mut max_col\
    \ = 0;\n    let mut max_val = 0;\n    let mut curr_val = 0;\n    let mut curr_row\
    \ = 0;\n    let mut curr_col = 0;\n    let mut curr_max_val = 0;\n    let mut\
    \ curr_max_row = 0;\n    let mut curr_max_col = 0;\n    let mut curr_max_row_val\
    \ = 0;\n    let mut curr_max_col_val = 0;\n    let mut curr_max_row_col = 0;\n\
    \    let mut curr_max_col_row = 0;\n    let mut curr_max_row_col_val = 0;\n  \
    \  let mut curr_max_col_row_val = 0;\n    let mut curr_max_row_col_val_row = 0;\n\
    \    let mut curr_max_col_row_val_col = 0;\n    let mut curr_max_row_col_val_row_col\
    \ = 0;\n    let mut curr_max_col_row_val_col_row = 0;\n    let mut curr_max_row_col_val_row_col_val\
    \ = 0;\n    let mut curr_max_col_row_val_col_row_val = 0;\n    let mut curr_max_row_col_val_row_col_val_row\
    \ = 0;\n    let mut curr_max_col_row_val_col_row_val_col = 0;\n    let mut curr_max_row_col_val_row_col_val_row_col\
    \ = 0;\n    let mut curr_max_col_row_val_col_row_val_col_row = 0;\n    let mut\
    \ curr_max_row_col_val_row_col_val_row_col_val = 0;\n    let mut curr_max_col_row_val_col_row_val_col_row_val\
    \ = 0;\n    let mut\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpp7vn71m6.rs:48:1\n\
    \   |\n48 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = well;\n            }\n        }\n\
    \        max_fill += 1;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpzzsvzvb1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut row = 0;\n    let mut col = 0;\n    let mut sum = 0;\n    let mut max_sum\
    \ = 0;\n    let mut max_row = 0;\n    let mut max_col = 0;\n    let mut max_count\
    \ = 0;\n    let mut max_count_row = 0;\n    let mut max_count_col = 0;\n    let\
    \ mut max_count_sum = 0;\n    let mut max_count_max_sum = 0;\n    let mut max_count_max_row\
    \ = 0;\n    let mut max_count_max_col = 0;\n    let mut max_count_max_count =\
    \ 0;\n    let mut max_count_max_count_row = 0;\n    let mut max_count_max_count_col\
    \ = 0;\n    let mut max_count_max_count_sum = 0;\n    let mut max_count_max_count_max_sum\
    \ = 0;\n    let mut max_count_max_count_max_row = 0;\n    let mut max_count_max_count_max_col\
    \ = 0;\n    let mut max_count_max_count_max_count = 0;\n    let mut max_count_max_count_max_count_row\
    \ = 0;\n    let mut max_count_max_count_max_count_col = 0;\n    let mut max_count_max_count_max_count_sum\
    \ = 0;\n    let mut max_count_max_count_max_count_max_sum = 0;\n    let mut max_count_max_count_max_count_max_row\
    \ = 0;\n    let mut max_count_max_count_max_count_max_col = 0;\n    let mut max_count_max_count_max_count_max_count\
    \ = 0;\n    let mut max_count_max_count_max_count_max_count_row = 0;\n    let\
    \ mut max_count_max_count_max_count_max_count_col = 0;\n    let mut max_count_max_count_max_count_max_count_sum\
    \ = 0;\n    let mut max_count_\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl842bdxs.rs:49:23\n   |\n\
    49 |     let mut max_count_\n   |                       ^ help: add `;` here\n\
    50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl842bdxs.rs:16:56\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |    --------                                            ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            if well == 1 {\n                fill += 1;\n            } else\
    \ {\n                fill = 0;\n            }\n            if fill > max_fill\
    \ {\n                max_fill = fill;\n            }\n        }\n    }\n    (max_fill\
    \ + capacity - 1) / capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp29ch2_f9.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut wells = grid.clone();\n    let mut row_max = vec![0; wells.len()];\n   \
    \ for i in 0..wells.len() {\n        for j in 0..wells[i].len() {\n          \
    \  if wells[i][j] == 1 {\n                row_max[i] = j;\n            }\n   \
    \     }\n    }\n    let mut max_col = 0;\n    for i in 0..wells.len() {\n    \
    \    if row_max[i] > max_col {\n            max_col = row_max[i];\n        }\n\
    \    }\n    for i in 0..max_col + 1 {\n        let mut col_max = 0;\n        for\
    \ j in 0..wells.len() {\n            if wells[j][i] == 1 {\n                col_max\
    \ = j;\n            }\n        }\n        for j in 0..col_max + 1 {\n        \
    \    if wells[j][i] == 1 {\n                wells[j][i] = 0;\n               \
    \ count += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpn6h_py3u.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = well;\n            }\n        }\n\
    \        max_fill += 1;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpzzsvzvb1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for well in row {\n \
    \           if well == 1 {\n                fill += 1;\n            }\n      \
    \  }\n        max_fill = std::cmp::max(max_fill, fill);\n    }\n    max_fill /\
    \ capacity + if max_fill % capacity == 0 { 0 } else { 1 }\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpx33nvkck.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for well in row {\n \
    \           fill += well;\n            if fill > capacity {\n                max_fill\
    \ += 1;\n                fill = 0;\n            }\n        }\n        if fill\
    \ > 0 {\n            max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmplcncmt3k.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max = 0;\n    for row in grid.iter_mut() {\n\
    \        let mut sum = 0;\n        for cell in row.iter_mut() {\n            sum\
    \ += *cell;\n            *cell = 0;\n        }\n        if sum > max {\n     \
    \       max = sum;\n        }\n    }\n    while max > 0 {\n        for row in\
    \ grid.iter_mut() {\n            for cell in row.iter_mut() {\n              \
    \  if *cell < capacity {\n                    *cell += 1;\n                }\n\
    \            }\n        }\n        count += 1;\n        max -= capacity;\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp6__ssyqb.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max_fill = 0;\n    for row in grid {\n        for cell in row {\n      \
    \      if cell == 1 {\n                max_fill += 1;\n            }\n       \
    \ }\n    }\n    let mut fill = 0;\n    while fill < max_fill {\n        for row\
    \ in grid {\n            for cell in row {\n                if cell == 1 {\n \
    \                   fill += 1;\n                    if fill == max_fill {\n  \
    \                      return count;\n                    }\n                }\n\
    \            }\n            count += 1;\n        }\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpbdddu8y3.rs:16:36\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `grid`\n   --> /tmp/tmpbdddu8y3.rs:28:20\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n28  |         for row in grid {\n    |                    ^^^^ `grid` moved\
    \ due to this implicit call to `.into_iter()`, in previous iteration of loop\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `grid`\nhelp: consider borrowing to avoid moving into the for loop\n    |\n\
    28  |         for row in &grid {\n    |                    ~~~~~\nhelp: consider\
    \ borrowing to avoid moving into the for loop\n    |\n19  |     for row in &grid\
    \ {\n    |                ~~~~~\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut res = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for row in grid {\n        let mut max\
    \ = 0;\n        for &col in row.iter() {\n            max = max.max(col);\n  \
    \      }\n        row_max.push(max);\n    }\n    for &max in row_max.iter() {\n\
    \        res += max / capacity;\n        if max % capacity != 0 {\n          \
    \  res += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpnb_y6mmv.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        let mut row_max = 0;\n        for cell in row.iter_mut() {\n    \
    \        if *cell == 1 {\n                row_max += 1;\n            }\n     \
    \   }\n        if row_max > max_height {\n            max_height = row_max;\n\
    \        }\n    }\n    for _ in 0..max_height {\n        let mut row_max = 0;\n\
    \        for row in grid.iter_mut() {\n            let mut row_max_here = 0;\n\
    \            for cell in row.iter_mut() {\n                if *cell == 1 {\n \
    \                   row_max_here += 1;\n                }\n            }\n   \
    \         if row_max_here > row_max {\n                row_max = row_max_here;\n\
    \            }\n        }\n        if row_max > capacity {\n            count\
    \ += row_max / capacity;\n            if row_max % capacity != 0 {\n         \
    \       count += 1;\n            }\n        } else {\n            count += 1;\n\
    \        }\n        for row in grid.iter_mut() {\n            for cell in row.iter_mut()\
    \ {\n                if *cell == 1 {\n                    *cell = 0;\n       \
    \         }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n  \
    \  let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmpus9pvdge.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max_row = 0;\n    for row in grid {\n        let mut sum = 0;\n        for\
    \ &cell in row.iter() {\n            sum += cell;\n        }\n        max_row\
    \ = max(max_row, sum);\n    }\n    for _ in 0..max_row {\n        for row in grid\
    \ {\n            for &cell in row.iter() {\n                if cell > 0 {\n  \
    \                  count += 1;\n                    break;\n                }\n\
    \            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpt42mud1x.rs:24:19\n\
    \   |\n24 |         max_row = max(max_row, sum);\n   |                   ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut row_max = 0;\n    for row in grid {\n        let mut row_sum = 0;\n    \
    \    for &cell in row.iter() {\n            row_sum += cell;\n        }\n    \
    \    row_max = std::cmp::max(row_max, row_sum);\n        result += row_sum;\n\
    \    }\n    result - row_max * capacity\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmpkvmtbwjj.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut total = 0;\n    let\
    \ mut fill = 0;\n    for row in grid {\n        for cell in row {\n          \
    \  if cell == 1 {\n                fill += 1;\n            } else {\n        \
    \        if fill > 0 {\n                    let bucket_fill = std::cmp::min(fill,\
    \ capacity);\n                    total += 1;\n                    fill -= bucket_fill;\n\
    \                }\n            }\n        }\n        if fill > 0 {\n        \
    \    total += 1;\n            fill = 0;\n        }\n    }\n    total\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmps62mwu1f.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for row in grid {\n        let mut max\
    \ = 0;\n        for &col in row.iter() {\n            max = max.max(col);\n  \
    \      }\n        row_max.push(max);\n    }\n    for &max in row_max.iter() {\n\
    \        result += max / capacity;\n        if max % capacity != 0 {\n       \
    \     result += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpldlg965w.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    for\
    \ row in grid {\n        let mut water = 0;\n        for well in row {\n     \
    \       water += well;\n            if water > capacity {\n                fill\
    \ += 1;\n                water = capacity;\n            }\n        }\n    }\n\
    \    fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpjvlgaers.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    let\
    \ mut row_max = 0;\n    for row in grid {\n        for cell in row {\n       \
    \     if cell > row_max {\n                row_max = cell;\n            }\n  \
    \      }\n        fill += row_max / capacity;\n        if row_max % capacity !=\
    \ 0 {\n            fill += 1;\n        }\n        row_max = 0;\n    }\n    fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmp0u_ueh7_.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_row = 0;\n    let mut max_col = 0;\n   \
    \ for row in grid.iter() {\n        let mut row_sum = 0;\n        for col in row.iter()\
    \ {\n            row_sum += col;\n        }\n        if row_sum > max_row {\n\
    \            max_row = row_sum;\n        }\n    }\n    for col in 0..grid[0].len()\
    \ {\n        let mut col_sum = 0;\n        for row in grid.iter() {\n        \
    \    col_sum += row[col];\n        }\n        if col_sum > max_col {\n       \
    \     max_col = col_sum;\n        }\n    }\n    let mut max_fill = max_row;\n\
    \    if max_col > max_row {\n        max_fill = max_col;\n    }\n    if max_fill\
    \ > capacity {\n        max_fill = capacity;\n    }\n    for row in grid.iter_mut()\
    \ {\n        for col in row.iter_mut() {\n            if *col > 0 {\n        \
    \        *col -= max_fill;\n                count += 1;\n            }\n     \
    \   }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n   \
    \ assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpds0t43b9.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    let\
    \ mut max_fill = 0;\n    for row in grid {\n        for &well in row.iter() {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ max_fill += 1;\n                fill = 0;\n            }\n        }\n      \
    \  max_fill += 1;\n        fill = 0;\n    }\n    max_fill\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpdc31n_ep.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = well;\n            }\n        }\n\
    \        max_fill += 1;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpzzsvzvb1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        let mut row_max = 0;\n        for cell in row.iter_mut() {\n    \
    \        if *cell == 1 {\n                row_max += 1;\n            }\n     \
    \   }\n        if row_max > max_height {\n            max_height = row_max;\n\
    \        }\n    }\n    for _ in 0..max_height {\n        for row in grid.iter_mut()\
    \ {\n            for cell in row.iter_mut() {\n                if *cell == 1 {\n\
    \                    *cell = 0;\n                    count += 1;\n           \
    \     }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmp1asz852g.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for row in grid {\n        let mut max\
    \ = 0;\n        for &val in row.iter() {\n            max = max.max(val);\n  \
    \      }\n        row_max.push(max);\n    }\n    for &max in row_max.iter() {\n\
    \        count += max / capacity;\n        if max % capacity != 0 {\n        \
    \    count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpvs6_1xm1.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = well;\n            }\n        }\n\
    \        max_fill += 1;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpzzsvzvb1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        for cell in row.iter_mut() {\n            if *cell == 1 {\n     \
    \           *cell = capacity;\n                max_height = max_height.max(capacity);\n\
    \            }\n        }\n    }\n    for row in grid.iter_mut() {\n        for\
    \ cell in row.iter_mut() {\n            if *cell > 0 {\n                *cell\
    \ -= 1;\n                count += 1;\n            }\n        }\n    }\n    count\
    \ + max_height\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmp_4cywtdo.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut water = 0;\n    let mut row = 0;\n    let mut col = 0;\n    let rows = grid.len();\n\
    \    let cols = grid[0].len();\n    while row < rows {\n        while col < cols\
    \ {\n            water += grid[row][col];\n            if water == capacity {\n\
    \                result += 1;\n                water = 0;\n            } else\
    \ if water > capacity {\n                result += 1;\n                water =\
    \ 1;\n            }\n            col += 1;\n        }\n        col = 0;\n    \
    \    row += 1;\n    }\n    if water > 0 {\n        result += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmp3xalq6sj.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut filled = 0;\n        for cell in row {\n    \
    \        filled += cell;\n            if filled == capacity {\n              \
    \  count += 1;\n                filled = 0;\n            }\n        }\n      \
    \  if filled > 0 {\n            count += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for row in grid {\n        let mut max\
    \ = 0;\n        for &col in row.iter() {\n            max = max.max(col);\n  \
    \      }\n        row_max.push(max);\n    }\n    for &max in row_max.iter() {\n\
    \        let mut fill = max;\n        while fill > 0 {\n            count += 1;\n\
    \            fill -= capacity;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmptawb9n2a.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    let\
    \ mut max_fill = 0;\n    for row in grid {\n        for &well in row.iter() {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ max_fill += 1;\n                fill = 0;\n            }\n        }\n      \
    \  max_fill += 1;\n        fill = 0;\n    }\n    max_fill\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpdc31n_ep.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut res = 0;\n    for\
    \ row in grid {\n        let mut well = 0;\n        for &cell in &row {\n    \
    \        if cell == 1 {\n                well += 1;\n            }\n        }\n\
    \        res += well / capacity;\n        if well % capacity != 0 {\n        \
    \    res += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max = 0;\n    for\
    \ row in grid {\n        let mut sum = 0;\n        for &cell in row.iter() {\n\
    \            sum += cell;\n            if sum > capacity {\n                max\
    \ += 1;\n                sum = cell;\n            }\n        }\n    }\n    max\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmp4hvvc15w.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        let mut height = 0;\n        for cell in row.iter_mut() {\n     \
    \       if *cell == 1 {\n                height += 1;\n            } else {\n\
    \                height = 0;\n            }\n            *cell = height;\n   \
    \     }\n        max_height = max(max_height, height);\n    }\n    for height\
    \ in 1..=max_height {\n        let mut row_count = 0;\n        for row in grid.iter()\
    \ {\n            let mut row_height = 0;\n            for cell in row.iter() {\n\
    \                if *cell >= height {\n                    row_height += 1;\n\
    \                } else {\n                    row_height = 0;\n             \
    \   }\n                if row_height == capacity {\n                    row_count\
    \ += 1;\n                    row_height = 0;\n                }\n            }\n\
    \        }\n        count += row_count;\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpsn08fdp_.rs:30:22\n\
    \   |\n30 |         max_height = max(max_height, height);\n   |              \
    \        ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  let mut fill = 0;\n    for row in grid {\n        for col in row {\n      \
    \      if col == 1 {\n                fill += 1;\n            }\n        }\n \
    \       max_fill = max(max_fill, fill);\n        fill = 0;\n    }\n    max_fill\
    \ / capacity + if max_fill % capacity == 0 { 0 } else { 1 }\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpy7f44z3p.rs:25:20\n\
    \   |\n25 |         max_fill = max(max_fill, fill);\n   |                    ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  let mut max_fill_count = 0;\n    for row in grid {\n        let mut fill =\
    \ 0;\n        for &cell in row.iter() {\n            fill += cell;\n         \
    \   if fill > capacity {\n                max_fill_count += 1;\n             \
    \   fill = capacity;\n            }\n        }\n        max_fill = max_fill.max(fill);\n\
    \    }\n    max_fill_count + max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpnteixgv0.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid {\n        for col in row {\n            if\
    \ col == 1 {\n                max += 1;\n            }\n        }\n    }\n   \
    \ let mut filled = 0;\n    while filled < max {\n        filled = 0;\n       \
    \ for row in grid {\n            let mut row_filled = 0;\n            for col\
    \ in row {\n                if col == 1 {\n                    row_filled += 1;\n\
    \                }\n            }\n            if row_filled > capacity {\n  \
    \              filled += capacity;\n            } else {\n                filled\
    \ += row_filled;\n            }\n        }\n        count += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `grid`\n   --> /tmp/tmpjhypcacc.rs:29:20\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n29  |         for row in grid {\n    |                    ^^^^ `grid` moved\
    \ due to this implicit call to `.into_iter()`, in previous iteration of loop\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `grid`\nhelp: consider borrowing to avoid moving into the for loop\n    |\n\
    29  |         for row in &grid {\n    |                    ~~~~~\nhelp: consider\
    \ borrowing to avoid moving into the for loop\n    |\n19  |     for row in &grid\
    \ {\n    |                ~~~~~\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for row in grid {\n        let mut max\
    \ = 0;\n        for &col in row.iter() {\n            max = max.max(col);\n  \
    \      }\n        row_max.push(max);\n    }\n    for &max in row_max.iter() {\n\
    \        count += max / capacity;\n        if max % capacity != 0 {\n        \
    \    count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpjoud7btk.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut wells = grid.iter().map(|row|\
    \ row.iter().sum::<isize>()).collect::<Vec<isize>>();\n    let mut count = 0;\n\
    \    while wells.iter().any(|&w| w > 0) {\n        for i in 0..wells.len() {\n\
    \            if wells[i] > 0 {\n                wells[i] -= capacity;\n      \
    \          count += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747069
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut fill = 0;\n        for &well in row.iter() {\n\
    \            fill += well;\n            if fill == capacity {\n              \
    \  count += 1;\n                fill = 0;\n            }\n        }\n        if\
    \ fill > 0 {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747069
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid {\n        for &height in &row {\n\
    \            if height > max_height {\n                max_height = height;\n\
    \            }\n        }\n    }\n    for height in 0..max_height {\n        let\
    \ mut fill = 0;\n        for row in &grid {\n            for &well in row {\n\
    \                if well > height {\n                    fill += 1;\n        \
    \        }\n            }\n        }\n        result += (fill + capacity - 1)\
    \ / capacity;\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmpmseug_k1.rs:28:20\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for row in grid {\n\
    \    |                ----\n    |                |\n    |                `grid`\
    \ moved due to this implicit call to `.into_iter()`\n    |                help:\
    \ consider borrowing to avoid moving into the for loop: `&grid`\n...\n28  |  \
    \       for row in &grid {\n    |                    ^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `grid`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut row = 0;\n    while row < grid.len() {\n   \
    \     let mut col = 0;\n        while col < grid[row].len() {\n            if\
    \ grid[row][col] == 1 {\n                let mut col_next = col + 1;\n       \
    \         while col_next < grid[row].len() && grid[row][col_next] == 1 {\n   \
    \                 col_next += 1;\n                }\n                let mut row_next\
    \ = row + 1;\n                while row_next < grid.len() && grid[row_next][col]\
    \ == 1 {\n                    row_next += 1;\n                }\n            \
    \    let mut row_cur = row;\n                while row_cur < row_next {\n    \
    \                let mut col_cur = col;\n                    while col_cur < col_next\
    \ {\n                        grid[row_cur][col_cur] = 0;\n                   \
    \     col_cur += 1;\n                    }\n                    row_cur += 1;\n\
    \                }\n                count += 1;\n                col = col_next;\n\
    \            } else {\n                col += 1;\n            }\n        }\n \
    \       row += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpmmk1tqjy.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut wells = grid.clone();\n    let mut row_max = vec![0; wells.len()];\n   \
    \ for i in 0..wells.len() {\n        row_max[i] = wells[i].iter().max().unwrap();\n\
    \    }\n    let mut col_max = vec![0; wells[0].len()];\n    for j in 0..wells[0].len()\
    \ {\n        col_max[j] = wells.iter().map(|row| row[j]).max().unwrap();\n   \
    \ }\n    let mut row_max_idx = vec![0; wells.len()];\n    for i in 0..wells.len()\
    \ {\n        row_max_idx[i] = wells[i].iter().position(|&x| x == row_max[i]).unwrap();\n\
    \    }\n    let mut col_max_idx = vec![0; wells[0].len()];\n    for j in 0..wells[0].len()\
    \ {\n        col_max_idx[j] = wells.iter().position(|row| row[j] == col_max[j]).unwrap();\n\
    \    }\n    let mut row_max_idx_set = HashSet::new();\n    let mut col_max_idx_set\
    \ = HashSet::new();\n    for i in 0..wells.len() {\n        row_max_idx_set.insert(row_max_idx[i]);\n\
    \    }\n    for j in 0..wells[0].len() {\n        col_max_idx_set.insert(col_max_idx[j]);\n\
    \    }\n    let mut row_max_idx_set_iter = row_max_idx_set.iter();\n    let mut\
    \ col_max_idx_set_iter = col_max_idx_set.iter();\n    let mut row_max_idx_set_iter_next\
    \ = row_max_idx_set_iter.next();\n    let mut col_max_idx_set_iter_next = col_max_idx_set_iter.next();\n\
    \n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp0tcn2fuv.rs:35:31\n   |\n35 |     let mut row_max_idx_set = HashSet::new();\n\
    \   |                               ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp0tcn2fuv.rs:36:31\n   |\n36 |     let mut col_max_idx_set = HashSet::new();\n\
    \   |                               ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0tcn2fuv.rs:21:22\n   |\n\
    21 |         row_max[i] = wells[i].iter().max().unwrap();\n   |              \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n21 |         row_max[i] = *wells[i].iter().max().unwrap();\n\
    \   |                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0tcn2fuv.rs:16:56\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |    --------                                            ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut wells = grid.iter().map(|row|\
    \ row.iter().sum::<isize>()).collect::<Vec<isize>>();\n    let mut count = 0;\n\
    \    while wells.iter().any(|&w| w > 0) {\n        for w in wells.iter_mut() {\n\
    \            if *w > capacity {\n                *w -= capacity;\n           \
    \ } else {\n                *w = 0;\n            }\n        }\n        count +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmptg5v4ept.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for i in 0..grid.len() {\n        for\
    \ j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n                row_max[i]\
    \ = j as isize;\n            }\n        }\n    }\n    let mut col_max = vec![0;\
    \ grid[0].len()];\n    for j in 0..grid[0].len() {\n        for i in 0..grid.len()\
    \ {\n            if grid[i][j] == 1 {\n                col_max[j] = i as isize;\n\
    \            }\n        }\n    }\n    for i in 0..grid.len() {\n        for j\
    \ in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n                let\
    \ mut fill = capacity;\n                let mut row_fill = capacity;\n       \
    \         let mut col_fill = capacity;\n                if row_max[i] > j as isize\
    \ {\n                    row_fill = capacity - (row_max[i] - j as isize);\n  \
    \              }\n                if col_max[j] > i as isize {\n             \
    \       col_fill = capacity - (col_max[j] - i as isize);\n                }\n\
    \                fill = std::cmp::min(row_fill, col_fill);\n                result\
    \ += fill;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `6`', /tmp/tmpwslbyv6e.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  let mut fill = 0;\n    for row in grid {\n        for well in row {\n     \
    \       fill += well;\n            if fill > capacity {\n                max_fill\
    \ += 1;\n                fill = 0;\n            }\n        }\n        max_fill\
    \ += 1;\n        fill = 0;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmp7z7o5hct.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for row in grid {\n        let mut max\
    \ = 0;\n        for &cell in row.iter() {\n            max = max.max(cell);\n\
    \        }\n        row_max.push(max);\n    }\n    for &max in row_max.iter()\
    \ {\n        fill += max / capacity;\n        if max % capacity != 0 {\n     \
    \       fill += 1;\n        }\n    }\n    fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpoar__fgg.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    for\
    \ row in grid {\n        let mut fill = 0;\n        for &well in row.iter() {\n\
    \            fill += well;\n            if fill == capacity {\n              \
    \  result += 1;\n                fill = 0;\n            }\n        }\n       \
    \ if fill > 0 {\n            result += 1;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747069
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    for\
    \ row in grid {\n        let mut fill = 0;\n        for &cell in row.iter() {\n\
    \            fill += cell;\n            if fill == capacity {\n              \
    \  result += 1;\n                fill = 0;\n            }\n        }\n       \
    \ if fill > 0 {\n            result += 1;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  let mut fill = 0;\n    for row in grid {\n        for cell in row {\n     \
    \       fill += cell;\n            if fill > capacity {\n                max_fill\
    \ += 1;\n                fill = cell;\n            }\n        }\n        max_fill\
    \ += 1;\n        fill = 0;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmp1c1dyirj.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     fill = capacity;\n            }\n        }\n        max_fill = max(max_fill,\
    \ fill);\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp3eap0233.rs:26:20\n\
    \   |\n26 |         max_fill = max(max_fill, fill);\n   |                    ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut row_max = 0;\n    for row in grid {\n        for col in row {\n        \
    \    if col > row_max {\n                row_max = col;\n            }\n     \
    \   }\n        result += row_max / capacity;\n        if row_max % capacity !=\
    \ 0 {\n            result += 1;\n        }\n        row_max = 0;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpu4qs9mj1.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    let\
    \ mut max_fill = 0;\n    for row in grid {\n        for cell in row {\n      \
    \      if cell == 1 {\n                fill += 1;\n            }\n        }\n\
    \        max_fill = std::cmp::max(max_fill, fill);\n        fill = 0;\n    }\n\
    \    max_fill / capacity + if max_fill % capacity == 0 { 0 } else { 1 }\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpkrp3mc2d.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut max = 0;\n    for row in grid {\n        for &cell in row.iter() {\n   \
    \         if cell == 1 {\n                max += 1;\n            }\n        }\n\
    \    }\n    let mut fill = 0;\n    for row in grid {\n        for &cell in row.iter()\
    \ {\n            if cell == 1 {\n                fill += 1;\n            }\n \
    \       }\n        if fill == max {\n            break;\n        }\n        result\
    \ += 1;\n        fill = 0;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpt9sl9xwn.rs:16:36\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `grid`\n   --> /tmp/tmpt9sl9xwn.rs:27:16\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for row in grid {\n\
    \    |                ----\n    |                |\n    |                `grid`\
    \ moved due to this implicit call to `.into_iter()`\n    |                help:\
    \ consider borrowing to avoid moving into the for loop: `&grid`\n...\n27  |  \
    \   for row in grid {\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `grid`\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = well;\n            }\n        }\n\
    \        max_fill += 1;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpzzsvzvb1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    for row in grid.iter_mut() {\n        let mut sum =\
    \ 0;\n        for col in row.iter_mut() {\n            sum += *col;\n        \
    \    *col = 0;\n        }\n        count += sum / capacity;\n        if sum %\
    \ capacity != 0 {\n            count += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    let mut col_max = vec![0; grid[0].len()];\n\
    \    for (i, row) in grid.iter().enumerate() {\n        for (j, &cell) in row.iter().enumerate()\
    \ {\n            row_max[i] = row_max[i].max(cell);\n            col_max[j] =\
    \ col_max[j].max(cell);\n        }\n    }\n    for (i, row) in grid.iter().enumerate()\
    \ {\n        for (j, &cell) in row.iter().enumerate() {\n            let max_fill\
    \ = row_max[i].min(col_max[j]);\n            result += max_fill - cell;\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp8olo0zyt.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for cell in row {\n \
    \           if cell == 1 {\n                fill += 1;\n            }\n      \
    \  }\n        max_fill = max(max_fill, fill);\n    }\n    max_fill / capacity\
    \ + if max_fill % capacity == 0 { 0 } else { 1 }\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp1v_0qqep.rs:25:20\n\
    \   |\n25 |         max_fill = max(max_fill, fill);\n   |                    ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for row in grid {\n        let mut row_max\
    \ = 0;\n        for &col in row.iter() {\n            row_max = std::cmp::max(row_max,\
    \ col);\n        }\n        result += row_max;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmp8i5xeqr7.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &col in row.iter()\
    \ {\n            fill += col;\n            if fill > capacity {\n            \
    \    max_fill += 1;\n                fill = col;\n            }\n        }\n \
    \       max_fill += 1;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmph3jalu4n.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid {\n        for cell in row {\n           \
    \ if cell == 1 {\n                max += 1;\n            }\n        }\n    }\n\
    \    while max > 0 {\n        let mut current = 0;\n        for row in grid {\n\
    \            for cell in row {\n                if cell == 1 {\n             \
    \       current += 1;\n                }\n            }\n            if current\
    \ > capacity {\n                current = capacity;\n            }\n         \
    \   max -= current;\n            count += 1;\n        }\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `grid`\n   --> /tmp/tmpp6vkqg3d.rs:28:20\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n28  |         for row in grid {\n    |                    ^^^^ `grid` moved\
    \ due to this implicit call to `.into_iter()`, in previous iteration of loop\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `grid`\nhelp: consider borrowing to avoid moving into the for loop\n    |\n\
    28  |         for row in &grid {\n    |                    ~~~~~\nhelp: consider\
    \ borrowing to avoid moving into the for loop\n    |\n19  |     for row in &grid\
    \ {\n    |                ~~~~~\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut wells = grid.iter().map(|row| {\n        let mut sum = 0;\n        for &c\
    \ in row {\n            sum += c;\n        }\n        sum\n    }).collect::<Vec<isize>>();\n\
    \    while wells.iter().any(|&w| w > 0) {\n        count += 1;\n        for w\
    \ in wells.iter_mut() {\n            if *w > capacity {\n                *w -=\
    \ capacity;\n            } else {\n                *w = 0;\n            }\n  \
    \      }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpdjug8nvd.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut wells = grid.iter().map(|row| row.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    while wells.iter().any(|&w| w > 0) {\n        let mut i = 0;\n        while\
    \ i < wells.len() {\n            if wells[i] > 0 {\n                wells[i] -=\
    \ capacity;\n                count += 1;\n            }\n            i += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747070
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut row = 0;\n    let mut col = 0;\n    let mut\
    \ col_max = 0;\n    let mut row_max = 0;\n    let mut col_min = 0;\n    let mut\
    \ row_min = 0;\n    let mut row_sum = 0;\n    let mut col_sum = 0;\n    let mut\
    \ row_max_index = 0;\n    let mut col_max_index = 0;\n    let mut row_min_index\
    \ = 0;\n    let mut col_min_index = 0;\n    let mut row_sum_index = 0;\n    let\
    \ mut col_sum_index = 0;\n    let mut row_max_index_temp = 0;\n    let mut col_max_index_temp\
    \ = 0;\n    let mut row_min_index_temp = 0;\n    let mut col_min_index_temp =\
    \ 0;\n    let mut row_sum_index_temp = 0;\n    let mut col_sum_index_temp = 0;\n\
    \    let mut row_max_temp = 0;\n    let mut col_max_temp = 0;\n    let mut row_min_temp\
    \ = 0;\n    let mut col_min_temp = 0;\n    let mut row_sum_temp = 0;\n    let\
    \ mut col_sum_temp = 0;\n    let mut row_max_temp_temp = 0;\n    let mut col_max_temp_temp\
    \ = 0;\n    let mut row_min_temp_temp = 0;\n    let mut col_min_temp_temp = 0;\n\
    \    let mut row_sum_temp_temp = 0;\n    let mut col_sum_temp_temp = 0;\n    let\
    \ mut row_max_temp_temp_temp = 0;\n    let mut col_max_temp_temp_temp = 0;\n \
    \   let mut row_min_temp_temp_temp = 0;\n    let mut col_min_temp_temp_temp =\
    \ 0;\n    let mut row_sum_temp_temp_temp = 0;\n    let mut col_sum_temp_temp_temp\
    \ = 0;\n    let mut row_max_temp_temp_\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf69f4qsb.rs:57:31\n   |\n\
    57 |     let mut row_max_temp_temp_\n   |                               ^ help:\
    \ add `;` here\n58 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf69f4qsb.rs:16:56\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |    --------                              \
    \              ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut wells = grid.iter().map(|row| row.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    let mut filled = wells.iter().map(|_| 0).collect::<Vec<isize>>();\n    let\
    \ mut bucket = capacity;\n    loop {\n        let mut i = 0;\n        while i\
    \ < wells.len() {\n            if wells[i] > 0 {\n                if bucket >\
    \ 0 {\n                    let amount = bucket.min(wells[i]);\n              \
    \      bucket -= amount;\n                    wells[i] -= amount;\n          \
    \          filled[i] += amount;\n                } else {\n                  \
    \  bucket = capacity;\n                    result += 1;\n                }\n \
    \           }\n            i += 1;\n        }\n        if wells.iter().sum::<isize>()\
    \ == 0 {\n            break;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpa3x95any.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    let\
    \ mut max_fill = 0;\n    for row in grid {\n        for &well in row.iter() {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ max_fill += 1;\n                fill = 0;\n            }\n        }\n      \
    \  max_fill += 1;\n        fill = 0;\n    }\n    max_fill\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpdc31n_ep.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    let\
    \ mut row_max = 0;\n    for row in grid {\n        let mut row_fill = 0;\n   \
    \     for &well in row.iter() {\n            if well == 1 {\n                row_fill\
    \ += 1;\n            }\n        }\n        if row_fill > row_max {\n         \
    \   row_max = row_fill;\n        }\n        fill += row_fill;\n    }\n    fill\
    \ - row_max * capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmpf6brm8kd.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    for row in grid.iter_mut() {\n        let mut water\
    \ = 0;\n        for cell in row.iter_mut() {\n            if *cell == 1 {\n  \
    \              *cell = 0;\n                water += 1;\n            }\n      \
    \      if water > 0 {\n                *cell = 1;\n                water -= 1;\n\
    \            }\n        }\n        count += water / capacity;\n        if water\
    \ % capacity > 0 {\n            count += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpbmuybx69.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut row = 0;\n    while row < grid.len() {\n   \
    \     let mut col = 0;\n        while col < grid[row].len() {\n            if\
    \ grid[row][col] == 1 {\n                count += 1;\n                let mut\
    \ row_ = row;\n                while row_ < grid.len() && grid[row_][col] == 1\
    \ {\n                    grid[row_][col] = 0;\n                    row_ += 1;\n\
    \                }\n            }\n            col += 1;\n        }\n        row\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmp03nyk4rl.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_fill = 0;\n    let mut max_fill_index =\
    \ 0;\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n    \
    \        if grid[i][j] == 1 {\n                max_fill += 1;\n            }\n\
    \        }\n        if max_fill > max_fill_index {\n            max_fill_index\
    \ = max_fill;\n        }\n        max_fill = 0;\n    }\n    for i in 0..grid.len()\
    \ {\n        for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n \
    \               grid[i][j] = 0;\n                count += 1;\n            }\n\
    \        }\n        if count == max_fill_index {\n            break;\n       \
    \ }\n        count = 0;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp060roe3c.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut water = 0;\n    for row in grid {\n        for &well in &row {\n       \
    \     water += well;\n            if water == capacity {\n                result\
    \ += 1;\n                water = 0;\n            } else if water > capacity {\n\
    \                result += 1;\n                water = well;\n            }\n\
    \        }\n        if water > 0 {\n            result += 1;\n            water\
    \ = 0;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747067
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    let\
    \ mut row = 0;\n    let mut col = 0;\n    let mut max_row = 0;\n    let mut max_col\
    \ = 0;\n    let mut max_fill = 0;\n    let mut max_fill_row = 0;\n    let mut\
    \ max_fill_col = 0;\n    let mut max_fill_count = 0;\n    let mut max_fill_count_row\
    \ = 0;\n    let mut max_fill_count_col = 0;\n    let mut max_fill_count_fill =\
    \ 0;\n    let mut max_fill_count_fill_row = 0;\n    let mut max_fill_count_fill_col\
    \ = 0;\n    let mut max_fill_count_fill_count = 0;\n    let mut max_fill_count_fill_count_row\
    \ = 0;\n    let mut max_fill_count_fill_count_col = 0;\n    let mut max_fill_count_fill_count_fill\
    \ = 0;\n    let mut max_fill_count_fill_count_fill_row = 0;\n    let mut max_fill_count_fill_count_fill_col\
    \ = 0;\n    let mut max_fill_count_fill_count_fill_count = 0;\n    let mut max_fill_count_fill_count_fill_count_row\
    \ = 0;\n    let mut max_fill_count_fill_count_fill_count_col = 0;\n    let mut\
    \ max_fill_count_fill_count_fill_count_fill = 0;\n    let mut max_fill_count_fill_count_fill_count_fill_row\
    \ = 0;\n    let mut max_fill_count_fill_count_fill_count_fill_col = 0;\n    let\
    \ mut max_fill_count_fill_count_fill_count_fill_count = 0;\n    let mut max_fill_count_fill_count_fill_count_fill_count_row\
    \ = 0;\n    let mut max_fill_count_fill_count_fill_count_fill_count_col = 0;\n\
    \    let mut max_fill_count_fill_count_fill_count_fill_count_fill = 0;\n   \n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpftzhym4l.rs:16:56\n   |\n\
    16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    --------\
    \                                            ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     fill = capacity;\n            }\n        }\n        max_fill = max(max_fill,\
    \ fill);\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp3eap0233.rs:26:20\n\
    \   |\n26 |         max_fill = max(max_fill, fill);\n   |                    ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for i in 0..grid.len() {\n        let\
    \ mut max = 0;\n        for j in 0..grid[i].len() {\n            if grid[i][j]\
    \ == 1 {\n                max = max.max(j);\n            }\n        }\n      \
    \  row_max[i] = max;\n    }\n    let mut col_max = vec![0; grid[0].len()];\n \
    \   for j in 0..grid[0].len() {\n        let mut max = 0;\n        for i in 0..grid.len()\
    \ {\n            if grid[i][j] == 1 {\n                max = max.max(i);\n   \
    \         }\n        }\n        col_max[j] = max;\n    }\n    let mut row_fill\
    \ = vec![0; grid.len()];\n    let mut col_fill = vec![0; grid[0].len()];\n   \
    \ let mut row_fill_max = vec![0; grid.len()];\n    let mut col_fill_max = vec![0;\
    \ grid[0].len()];\n    let mut row_fill_min = vec![0; grid.len()];\n    let mut\
    \ col_fill_min = vec![0; grid[0].len()];\n    let mut row_fill_max_index = vec![0;\
    \ grid.len()];\n    let mut col_fill_max_index = vec![0; grid[0].len()];\n   \
    \ let mut row_fill_min_index = vec![0; grid.len()];\n    let mut col_fill_min_index\
    \ = vec![0; grid[0].len()];\n    loop {\n        let mut row_max_index = 0;\n\
    \        let mut col_max_index = 0;\n        let mut row_max_value = 0;\n    \
    \    let mut col_max_value = 0;\n        for i in 0..grid.len() {\n          \
    \  if row_max[i] > row_max_value {\n                row_max_value = row_max[i];\n\
    \                row_max_\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmphc4exfb_.rs:66:3\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n48 |     loop {\n   |          - unclosed delimiter\n...\n53 |         for\
    \ i in 0..grid.len() {\n   |                                - unclosed delimiter\n\
    54 |             if row_max[i] > row_max_value {\n   |                       \
    \                    - this delimiter might not be properly closed...\n...\n57\
    \ | }\n   | - ...as it matches this but it has different indentation\n...\n66\
    \ | }\n   |   ^\n\nerror[E0425]: cannot find value `row_max_` in this scope\n\
    \  --> /tmp/tmphc4exfb_.rs:56:17\n   |\n56 |                 row_max_\n   |  \
    \               ^^^^^^^^ help: a local variable with a similar name exists: `row_max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: -1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut wells = grid.clone();\n    let mut bucket = capacity;\n    while bucket\
    \ > 0 {\n        let mut row = 0;\n        while row < wells.len() {\n       \
    \     let mut col = 0;\n            while col < wells[row].len() {\n         \
    \       if wells[row][col] == 1 {\n                    wells[row][col] = 0;\n\
    \                    bucket -= 1;\n                }\n                col += 1;\n\
    \            }\n            row += 1;\n        }\n        count += 1;\n      \
    \  bucket = capacity;\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659747075
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for well in row {\n \
    \           fill += well;\n            if fill > capacity {\n                max_fill\
    \ += 1;\n                fill = 0;\n            }\n        }\n        if fill\
    \ > 0 {\n            max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmplcncmt3k.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    for row in grid.iter_mut() {\n        let mut sum =\
    \ 0;\n        for cell in row.iter_mut() {\n            sum += *cell;\n      \
    \      *cell = 0;\n        }\n        count += sum / capacity;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmpmzg7zje7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut max_depth = 0;\n    for row in grid {\n        let mut depth = 0;\n    \
    \    for &well in row.iter() {\n            depth += well;\n        }\n      \
    \  max_depth = max(max_depth, depth);\n        result += depth / capacity;\n \
    \       if depth % capacity != 0 {\n            result += 1;\n        }\n    }\n\
    \    result * max_depth\n}\n\nfn main() {\n    let candidate = max_fill;\n   \
    \ assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmphbifenpu.rs:24:21\n\
    \   |\n24 |         max_depth = max(max_depth, depth);\n   |                 \
    \    ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut wells = grid.clone();\n    let mut bucket = capacity;\n    for row in wells.iter_mut()\
    \ {\n        for well in row.iter_mut() {\n            if *well == 1 {\n     \
    \           if bucket == 0 {\n                    bucket = capacity;\n       \
    \             count += 1;\n                }\n                bucket -= 1;\n \
    \               *well = 0;\n            }\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpu8ba7eod.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max_row = 0;\n    let mut max_col = 0;\n    let mut max_val = 0;\n    for\
    \ row in grid.iter() {\n        for (col, &val) in row.iter().enumerate() {\n\
    \            if val > max_val {\n                max_val = val;\n            \
    \    max_row = row.len();\n                max_col = col;\n            }\n   \
    \     }\n    }\n    let mut grid = grid;\n    while max_val > 0 {\n        let\
    \ mut row = 0;\n        let mut col = max_col;\n        while row < max_row {\n\
    \            if grid[row][col] > 0 {\n                grid[row][col] -= 1;\n \
    \               count += 1;\n            }\n            row += 1;\n        }\n\
    \        max_val -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmpqi6s4ywq.rs:35:16

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for i in 0..grid.len() {\n        for\
    \ j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n                row_max[i]\
    \ = j as isize;\n            }\n        }\n    }\n    row_max.sort();\n    let\
    \ mut last_max = 0;\n    for i in 0..row_max.len() {\n        if row_max[i] >\
    \ last_max {\n            result += (row_max[i] - last_max) / capacity;\n    \
    \        if (row_max[i] - last_max) % capacity != 0 {\n                result\
    \ += 1;\n            }\n            last_max = row_max[i];\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmp378pdvtb.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     fill = capacity;\n            }\n        }\n        max_fill = max(max_fill,\
    \ fill);\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp3eap0233.rs:26:20\n\
    \   |\n26 |         max_fill = max(max_fill, fill);\n   |                    ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = well;\n            }\n        }\n\
    \        max_fill += 1;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpzzsvzvb1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747068
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut res = 0;\n    for\
    \ row in grid {\n        let mut curr = 0;\n        for &cell in &row {\n    \
    \        if cell == 1 {\n                curr += 1;\n            } else {\n  \
    \              if curr > 0 {\n                    res += 1;\n                \
    \    curr = 0;\n                }\n            }\n        }\n        if curr >\
    \ 0 {\n            res += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n  \
    \  let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmp722jftuo.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid {\n        for &cell in &row {\n  \
    \          max_height = max_height.max(cell);\n        }\n    }\n    for height\
    \ in 0..=max_height {\n        for row in &grid {\n            for &cell in row\
    \ {\n                if cell >= height {\n                    result += 1;\n \
    \               }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpl6rim6qr.rs:16:36\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmpl6rim6qr.rs:25:20\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for row in grid {\n\
    \    |                ----\n    |                |\n    |                `grid`\
    \ moved due to this implicit call to `.into_iter()`\n    |                help:\
    \ consider borrowing to avoid moving into the for loop: `&grid`\n...\n25  |  \
    \       for row in &grid {\n    |                    ^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `grid`\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    for\
    \ row in grid {\n        let mut sum = 0;\n        for &cell in &row {\n     \
    \       sum += cell;\n            if sum == capacity {\n                result\
    \ += 1;\n                sum = 0;\n            }\n        }\n        if sum >\
    \ 0 {\n            result += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747070
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut wells = grid.clone();\n    let mut row_max = vec![0; wells.len()];\n   \
    \ for (i, row) in wells.iter().enumerate() {\n        row_max[i] = *row.iter().max().unwrap();\n\
    \    }\n    let mut col_max = vec![0; wells[0].len()];\n    for j in 0..wells[0].len()\
    \ {\n        col_max[j] = wells.iter().map(|row| row[j]).max().unwrap();\n   \
    \ }\n    let mut row_max_idx = vec![0; wells.len()];\n    for (i, row) in wells.iter().enumerate()\
    \ {\n        row_max_idx[i] = row.iter().position(|&x| x == row_max[i]).unwrap();\n\
    \    }\n    let mut col_max_idx = vec![0; wells[0].len()];\n    for j in 0..wells[0].len()\
    \ {\n        col_max_idx[j] = wells.iter().position(|row| row[j] == col_max[j]).unwrap();\n\
    \    }\n    let mut row_max_idx_set = HashSet::new();\n    for i in 0..wells.len()\
    \ {\n        row_max_idx_set.insert(row_max_idx[i]);\n    }\n    let mut col_max_idx_set\
    \ = HashSet::new();\n    for j in 0..wells[0].len() {\n        col_max_idx_set.insert(col_max_idx[j]);\n\
    \    }\n    let mut row_max_idx_set_iter = row_max_idx_set.iter();\n    let mut\
    \ col_max_idx_set_iter = col_max_idx_set.iter();\n    let mut row_max_idx_set_iter_next\
    \ = row_max_idx_set_iter.next();\n    let mut col_max_idx_set_iter_next = col_max_idx_\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpznyhdegn.rs:46:53\n   |\n\
    46 |     let mut col_max_idx_set_iter_next = col_max_idx_\n   |              \
    \                                       ^ help: add `;` here\n47 | }\n   | - unexpected\
    \ token\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmpznyhdegn.rs:35:31\n   |\n35 |     let mut row_max_idx_set = HashSet::new();\n\
    \   |                               ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpznyhdegn.rs:39:31\n   |\n39 |     let mut col_max_idx_set = HashSet::new();\n\
    \   |                               ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0425]: cannot find value `col_max_idx_` in this scope\n  --> /tmp/tmpznyhdegn.rs:46:41\n\
    \   |\n46 |     let mut col_max_idx_set_iter_next = col_max_idx_\n   |       \
    \                                  ^^^^^^^^^^^^ help: a local variable with a\
    \ similar name exists: `col_max_idx`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpznyhdegn.rs:16:56\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n   |    --------                                        \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut water = 0;\n    for row in grid {\n        for cell in row {\n         \
    \   water += cell;\n            if water == capacity {\n                count\
    \ += 1;\n                water = 0;\n            } else if water > capacity {\n\
    \                count += 1;\n                water = cell;\n            }\n \
    \       }\n        if water > 0 {\n            count += 1;\n            water\
    \ = 0;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747070
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill_count = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill == capacity {\n          \
    \      fill_count += 1;\n                fill = 0;\n            }\n        }\n\
    \        if fill > 0 {\n            fill_count += 1;\n        }\n    }\n    fill_count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747070
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max_fill = 0;\n    for row in grid {\n        for cell in row {\n      \
    \      if cell == 1 {\n                max_fill += 1;\n            }\n       \
    \ }\n    }\n    let mut fill = 0;\n    for row in grid {\n        for cell in\
    \ row {\n            if cell == 1 {\n                fill += 1;\n            }\n\
    \        }\n        if fill == max_fill {\n            break;\n        }\n   \
    \     count += 1;\n        fill = 0;\n    }\n    count\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpdioa30p2.rs:16:36\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `grid`\n   --> /tmp/tmpdioa30p2.rs:27:16\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for row in grid {\n\
    \    |                ----\n    |                |\n    |                `grid`\
    \ moved due to this implicit call to `.into_iter()`\n    |                help:\
    \ consider borrowing to avoid moving into the for loop: `&grid`\n...\n27  |  \
    \   for row in grid {\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `grid`\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_height = 0;\n    for row in &grid {\n  \
    \      max_height = max_height.max(row.iter().sum());\n    }\n    for _ in 0..max_height\
    \ {\n        let mut row_count = 0;\n        for row in &mut grid {\n        \
    \    let mut row_max = 0;\n            for cell in row {\n                if *cell\
    \ > 0 {\n                    row_max += 1;\n                    *cell -= 1;\n\
    \                }\n            }\n            row_count += row_max;\n       \
    \ }\n        count += row_count / capacity;\n        if row_count % capacity >\
    \ 0 {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmpwvxjru5y.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut water = 0;\n        for &well in row.iter() {\n\
    \            water += well;\n            if water == capacity {\n            \
    \    count += 1;\n                water = 0;\n            } else if water > capacity\
    \ {\n                count += 1;\n                water = well;\n            }\n\
    \        }\n        if water > 0 {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut grid = grid;\n    let mut row = 0;\n    let mut col = 0;\n    while row\
    \ < grid.len() {\n        while col < grid[row].len() {\n            if grid[row][col]\
    \ == 1 {\n                count += 1;\n                let mut row_ = row;\n \
    \               while row_ < grid.len() && grid[row_][col] == 1 {\n          \
    \          grid[row_][col] = 0;\n                    row_ += 1;\n            \
    \    }\n            }\n            col += 1;\n        }\n        row += 1;\n \
    \       col = 0;\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpnreg2ziz.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut sum = 0;\n        for &well in row.iter() {\n\
    \            sum += well;\n            if sum == capacity {\n                count\
    \ += 1;\n                sum = 0;\n            }\n        }\n        if sum >\
    \ 0 {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &cell in row.iter()\
    \ {\n            fill += cell;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = capacity;\n            }\n      \
    \  }\n        max_fill += fill;\n    }\n    max_fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpc91ir5h5.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut grid = grid;\n    let mut row = 0;\n    let mut col = 0;\n    let mut row_len\
    \ = grid.len();\n    let mut col_len = grid[0].len();\n    while row < row_len\
    \ {\n        if grid[row][col] == 1 {\n            count += 1;\n            let\
    \ mut i = 0;\n            while i < row_len {\n                grid[i][col] =\
    \ 0;\n                i += 1;\n            }\n            col += 1;\n        \
    \    col_len -= 1;\n        } else {\n            row += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 4 but the
    index is 4'', /tmp/tmpjnrlqr3t.rs:24:12

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut wells = grid.iter().map(|row| row.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    while wells.iter().any(|&w| w > 0) {\n        let mut bucket = capacity;\n\
    \        for well in wells.iter_mut() {\n            if bucket > 0 {\n       \
    \         let fill = std::cmp::min(bucket, *well);\n                bucket -=\
    \ fill;\n                *well -= fill;\n            }\n        }\n        count\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmptdxd13b1.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  let mut fill = 0;\n    for row in grid {\n        for &well in row.iter() {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ max_fill += 1;\n                fill = well;\n            }\n        }\n   \
    \     max_fill += 1;\n        fill = 0;\n    }\n    max_fill\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpuask_636.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747071
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut sum = 0;\n        for &cell in row.iter() {\n\
    \            sum += cell;\n            if sum == capacity {\n                count\
    \ += 1;\n                sum = 0;\n            }\n        }\n        if sum >\
    \ 0 {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747067
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut grid = grid;\n    let mut row = 0;\n    let mut col = 0;\n    let mut row_max\
    \ = 0;\n    let mut col_max = 0;\n    let mut row_min = 0;\n    let mut col_min\
    \ = 0;\n    let mut row_sum = 0;\n    let mut col_sum = 0;\n    let mut row_max_idx\
    \ = 0;\n    let mut col_max_idx = 0;\n    let mut row_min_idx = 0;\n    let mut\
    \ col_min_idx = 0;\n    let mut row_max_idx_prev = 0;\n    let mut col_max_idx_prev\
    \ = 0;\n    let mut row_min_idx_prev = 0;\n    let mut col_min_idx_prev = 0;\n\
    \    let mut row_max_prev = 0;\n    let mut col_max_prev = 0;\n    let mut row_min_prev\
    \ = 0;\n    let mut col_min_prev = 0;\n    let mut row_sum_prev = 0;\n    let\
    \ mut col_sum_prev = 0;\n    let mut row_max_idx_prev_prev = 0;\n    let mut col_max_idx_prev_prev\
    \ = 0;\n    let mut row_min_idx_prev_prev = 0;\n    let mut col_min_idx_prev_prev\
    \ = 0;\n    let mut row_max_prev_prev = 0;\n    let mut col_max_prev_prev = 0;\n\
    \    let mut row_min_prev_prev = 0;\n    let mut col_min_prev_prev = 0;\n    let\
    \ mut row_sum_prev_prev = 0;\n    let mut col_sum_prev_prev = 0;\n    let mut\
    \ row_max_idx_prev_prev_prev = 0;\n    let mut col_max_idx_prev_prev_prev = 0;\n\
    \    let mut row_min_idx_prev_prev_prev = 0;\n    let mut col_min_idx_prev_prev_prev\
    \ = 0;\n    let mut row_max_\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpej30_d8j.rs:55:21\n   |\n\
    55 |     let mut row_max_\n   |                     ^ help: add `;` here\n56 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpej30_d8j.rs:16:56\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |    --------                                            ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    for row in grid.iter_mut() {\n        let mut filled\
    \ = 0;\n        for cell in row.iter_mut() {\n            if *cell == 1 {\n  \
    \              *cell = 0;\n                filled += 1;\n            }\n     \
    \       if filled == capacity {\n                break;\n            }\n     \
    \   }\n        if filled > 0 {\n            count += 1;\n        }\n    }\n  \
    \  count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpd5pnl_xg.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747071
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    while !grid.iter().all(|row| row.iter().all(|&x| x ==\
    \ 0)) {\n        for row in &mut grid {\n            for cell in row {\n     \
    \           if *cell > 0 {\n                    *cell -= capacity;\n         \
    \           if *cell < 0 {\n                        *cell = 0;\n             \
    \       }\n                }\n            }\n        }\n        count += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpvqxht7rf.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    let mut max_i = 0;\n    let mut max_j =\
    \ 0;\n    let mut max_value = 0;\n    let mut max_value_i = 0;\n    let mut max_value_j\
    \ = 0;\n    let mut max_value_count = 0;\n    let mut max_value_count_i = 0;\n\
    \    let mut max_value_count_j = 0;\n    let mut max_value_count_value = 0;\n\
    \    let mut max_value_count_value_i = 0;\n    let mut max_value_count_value_j\
    \ = 0;\n    let mut max_value_count_value_count = 0;\n    let mut max_value_count_value_count_i\
    \ = 0;\n    let mut max_value_count_value_count_j = 0;\n    let mut max_value_count_value_count_value\
    \ = 0;\n    let mut max_value_count_value_count_value_i = 0;\n    let mut max_value_count_value_count_value_j\
    \ = 0;\n    let mut max_value_count_value_count_value_count = 0;\n    let mut\
    \ max_value_count_value_count_value_count_i = 0;\n    let mut max_value_count_value_count_value_count_j\
    \ = 0;\n    let mut max_value_count_value_count_value_count_value = 0;\n    let\
    \ mut max_value_count_value_count_value_count_value_i = 0;\n    let mut max_value_count_value_count_value_count_value_j\
    \ = 0;\n    let mut max_value_count_value_count_value_count_value_count = 0;\n\
    \    let mut max_value_count_value_count_value_count_value_count_i = 0;\n    let\
    \ mut max_value_count_value_count_value_count_value_count_j = 0;\n    let mut\
    \ max_value_count_value_count_value_count_value_count_value = 0;\n   \n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgdf3jz1h.rs:16:56\n   |\n\
    16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    --------\
    \                                            ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill_count = 0;\n\
    \    let mut row_max = vec![0; grid.len()];\n    for row in grid {\n        let\
    \ mut row_fill = 0;\n        for (i, &x) in row.iter().enumerate() {\n       \
    \     if x == 1 {\n                row_fill += 1;\n            } else {\n    \
    \            row_max[i] = row_max[i].max(row_fill);\n                row_fill\
    \ = 0;\n            }\n        }\n        row_max[row.len() - 1] = row_max[row.len()\
    \ - 1].max(row_fill);\n    }\n    for &x in row_max.iter() {\n        fill_count\
    \ += (x + capacity - 1) / capacity;\n    }\n    fill_count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmpatwyqg92.rs:25:30

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747071
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    let\
    \ mut wells = grid.clone();\n    let mut bucket = capacity;\n    let mut i = 0;\n\
    \    while i < wells.len() {\n        let mut j = 0;\n        while j < wells[i].len()\
    \ {\n            if wells[i][j] == 1 {\n                if bucket == 0 {\n   \
    \                 bucket = capacity;\n                    fill += 1;\n       \
    \         }\n                bucket -= 1;\n                wells[i][j] = 0;\n\
    \            }\n            j += 1;\n        }\n        i += 1;\n    }\n    fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpkx5f6pdq.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747071
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut row = 0;\n    let mut col = 0;\n    let mut max_row = 0;\n    let mut max_col\
    \ = 0;\n    let mut max_fill = 0;\n    let mut max_fill_row = 0;\n    let mut\
    \ max_fill_col = 0;\n    let mut max_fill_count = 0;\n    let mut max_fill_count_row\
    \ = 0;\n    let mut max_fill_count_col = 0;\n    let mut max_fill_count_row_count\
    \ = 0;\n    let mut max_fill_count_col_count = 0;\n    let mut max_fill_count_row_count_row\
    \ = 0;\n    let mut max_fill_count_col_count_col = 0;\n    let mut max_fill_count_row_count_row_count\
    \ = 0;\n    let mut max_fill_count_col_count_col_count = 0;\n    let mut max_fill_count_row_count_row_count_row\
    \ = 0;\n    let mut max_fill_count_col_count_col_count_col = 0;\n    let mut max_fill_count_row_count_row_count_row_count\
    \ = 0;\n    let mut max_fill_count_col_count_col_count_col_count = 0;\n    let\
    \ mut max_fill_count_row_count_row_count_row_count_row = 0;\n    let mut max_fill_count_col_count_col_count_col_count_col\
    \ = 0;\n    let mut max_fill_count_row_count_row_count_row_count_row_count = 0;\n\
    \    let mut max_fill_count_col_count_col_count_col_count_col_count = 0;\n   \
    \ let mut max_fill_count_row_count_row_count_row_count_row_count_row = 0;\n  \
    \  let mut max_fill_count_col_count_col_count_col_count_col_count_col = 0;\n \
    \   let mut max_fill_count_row_count_row_count_row_count_row_count_\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoxwf1o7i.rs:44:68\n   |\n\
    44 |     let mut max_fill_count_row_count_row_count_row_count_row_count_\n   |\
    \                                                                    ^ help: add\
    \ `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoxwf1o7i.rs:16:56\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |    --------                              \
    \              ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut water = 0;\n    for row in grid {\n        for &well in &row {\n       \
    \     water += well;\n            if water == capacity {\n                result\
    \ += 1;\n                water = 0;\n            } else if water > capacity {\n\
    \                result += 1;\n                water = well;\n            }\n\
    \        }\n        if water > 0 {\n            result += 1;\n            water\
    \ = 0;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747067
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut sum = 0;\n        for &well in row.iter() {\n\
    \            sum += well;\n            if sum == capacity {\n                count\
    \ += 1;\n                sum = 0;\n            }\n        }\n        if sum >\
    \ 0 {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747067
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut sum = 0;\n        for &cell in row.iter() {\n\
    \            sum += cell;\n            if sum == capacity {\n                count\
    \ += 1;\n                sum = 0;\n            }\n        }\n        if sum >\
    \ 0 {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        max_height = max_height.max(row.iter().sum());\n    }\n    for height\
    \ in 0..max_height {\n        for row in grid.iter_mut() {\n            let mut\
    \ filled = 0;\n            for cell in row.iter_mut() {\n                if *cell\
    \ > 0 {\n                    *cell -= 1;\n                    filled += 1;\n \
    \               }\n            }\n            if filled > 0 {\n              \
    \  count += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpbyfajqa8.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747071
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    let mut col_max = vec![0; grid[0].len()];\n\
    \    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n         \
    \   row_max[i] = row_max[i].max(grid[i][j]);\n            col_max[j] = col_max[j].max(grid[i][j]);\n\
    \        }\n    }\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            let max_fill = row_max[i].min(col_max[j]);\n            count\
    \ += max_fill - grid[i][j];\n        }\n    }\n    count\n}\n\nfn main() {\n \
    \   let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpri75r7j9.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747071
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  let mut fill = 0;\n    for row in grid {\n        for well in row {\n     \
    \       fill += well;\n            if fill > capacity {\n                max_fill\
    \ += 1;\n                fill = well;\n            }\n        }\n        max_fill\
    \ += 1;\n        fill = 0;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpolhwhjcz.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747071
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let mut max_height = 0;\n    for row in grid.iter_mut()\
    \ {\n        let mut height = 0;\n        for cell in row.iter_mut() {\n     \
    \       if *cell == 1 {\n                height += 1;\n            } else {\n\
    \                height = 0;\n            }\n            *cell = height;\n   \
    \     }\n        max_height = max(max_height, height);\n    }\n    for height\
    \ in 1..=max_height {\n        for row in grid.iter_mut() {\n            for cell\
    \ in row.iter_mut() {\n                if *cell >= height {\n                \
    \    *cell -= height;\n                    count += 1;\n                }\n  \
    \          }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpleuhh0ny.rs:30:22\n\
    \   |\n30 |         max_height = max(max_height, height);\n   |              \
    \        ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid {\n        let mut height = 0;\n  \
    \      for &cell in row.iter() {\n            if cell == 1 {\n               \
    \ height += 1;\n            }\n        }\n        if height > max_height {\n \
    \           max_height = height;\n        }\n    }\n    for _ in 0..max_height\
    \ {\n        for row in grid {\n            for &cell in row.iter() {\n      \
    \          if cell == 1 {\n                    count += 1;\n                }\n\
    \            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpm7itfb7j.rs:16:36\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `grid`\n   --> /tmp/tmpm7itfb7j.rs:31:20\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n31  |         for row in grid {\n    |                    ^^^^ `grid` moved\
    \ due to this implicit call to `.into_iter()`, in previous iteration of loop\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `grid`\nhelp: consider borrowing to avoid moving into the for loop\n    |\n\
    31  |         for row in &grid {\n    |                    ~~~~~\nhelp: consider\
    \ borrowing to avoid moving into the for loop\n    |\n19  |     for row in &grid\
    \ {\n    |                ~~~~~\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &cell in row.iter()\
    \ {\n            fill += cell;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = cell;\n            }\n        }\n\
    \        max_fill += 1;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpdm3fdw93.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747071
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     fill = capacity;\n            }\n        }\n        max_fill = max(max_fill,\
    \ fill);\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp3eap0233.rs:26:20\n\
    \   |\n26 |         max_fill = max(max_fill, fill);\n   |                    ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747067
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &cell in row.iter()\
    \ {\n            fill += cell;\n            if fill > capacity {\n           \
    \     fill = capacity;\n            }\n        }\n        max_fill = max(max_fill,\
    \ fill);\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmps01u3qpx.rs:26:20\n\
    \   |\n26 |         max_fill = max(max_fill, fill);\n   |                    ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747070
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &cell in row.iter()\
    \ {\n            fill += cell;\n            if fill > capacity {\n           \
    \     max_fill += 1;\n                fill = cell;\n            }\n        }\n\
    \        max_fill += 1;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpdm3fdw93.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747071
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut row_max = vec![0; grid.len()];\n    for row in grid {\n        for (i, &v)\
    \ in row.iter().enumerate() {\n            row_max[i] = std::cmp::max(row_max[i],\
    \ v);\n        }\n    }\n    for row in grid {\n        for (i, &v) in row.iter().enumerate()\
    \ {\n            let diff = row_max[i] - v;\n            if diff > 0 {\n     \
    \           result += diff;\n            }\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpf1z6yj1p.rs:16:36\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `grid`\n   --> /tmp/tmpf1z6yj1p.rs:24:16\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for row in grid {\n\
    \    |                ----\n    |                |\n    |                `grid`\
    \ moved due to this implicit call to `.into_iter()`\n    |                help:\
    \ consider borrowing to avoid moving into the for loop: `&grid`\n...\n24  |  \
    \   for row in grid {\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `grid`\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747071
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut wells = grid.iter().map(|row| row.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    while wells.iter().any(|&x| x > 0) {\n        for well in wells.iter_mut()\
    \ {\n            if *well > 0 {\n                *well -= capacity;\n        \
    \    }\n        }\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n \
    \   let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpsc81v3ea.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747071
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    let\
    \ mut max_fill = 0;\n    for row in grid {\n        for &well in row.iter() {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ max_fill += 1;\n                fill = 0;\n            }\n        }\n      \
    \  max_fill += 1;\n        fill = 0;\n    }\n    max_fill\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpdc31n_ep.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747069
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut sum = 0;\n        for &cell in row.iter() {\n\
    \            sum += cell;\n            if sum == capacity {\n                count\
    \ += 1;\n                sum = 0;\n            }\n        }\n        if sum >\
    \ 0 {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747067
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            if well == 1 {\n                fill += 1;\n            } else\
    \ {\n                if fill > max_fill {\n                    max_fill = fill;\n\
    \                }\n                fill = 0;\n            }\n        }\n    \
    \    if fill > max_fill {\n            max_fill = fill;\n        }\n    }\n  \
    \  if max_fill == 0 {\n        return 0;\n    }\n    if max_fill <= capacity {\n\
    \        return 1;\n    }\n    max_fill / capacity + if max_fill % capacity ==\
    \ 0 { 0 } else { 1 }\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpgydi67qy.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747071
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut grid = grid;\n    let mut row = 0;\n    let mut col = 0;\n    while row\
    \ < grid.len() {\n        while col < grid[row].len() {\n            if grid[row][col]\
    \ == 1 {\n                count += 1;\n                grid[row][col] = 0;\n \
    \               let mut bucket = capacity;\n                while bucket > 0 &&\
    \ col < grid[row].len() {\n                    if grid[row][col] == 1 {\n    \
    \                    grid[row][col] = 0;\n                        bucket -= 1;\n\
    \                    }\n                    col += 1;\n                }\n   \
    \         }\n            col += 1;\n        }\n        row += 1;\n        col\
    \ = 0;\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n  \
    \  assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp21c8yvde.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747071
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max_row = 0;\n    let mut max_col = 0;\n    for row in grid.iter() {\n \
    \       let mut row_sum = 0;\n        for col in row.iter() {\n            row_sum\
    \ += col;\n        }\n        if row_sum > max_row {\n            max_row = row_sum;\n\
    \        }\n    }\n    for col in 0..grid[0].len() {\n        let mut col_sum\
    \ = 0;\n        for row in grid.iter() {\n            col_sum += row[col];\n \
    \       }\n        if col_sum > max_col {\n            max_col = col_sum;\n  \
    \      }\n    }\n    count += max_row / capacity;\n    count += max_col / capacity;\n\
    \    if max_row % capacity != 0 {\n        count += 1;\n    }\n    if max_col\
    \ % capacity != 0 {\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmpslfgb9tx.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747071
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    let\
    \ mut row_max = 0;\n    for row in grid {\n        for &cell in row.iter() {\n\
    \            row_max = std::cmp::max(row_max, cell);\n        }\n        fill\
    \ += row_max;\n        row_max = 0;\n    }\n    fill / capacity\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpo9ie8edb.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747071
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid {\n        let mut height = 0;\n  \
    \      for &cell in row.iter() {\n            if cell == 1 {\n               \
    \ height += 1;\n            }\n        }\n        if height > max_height {\n \
    \           max_height = height;\n        }\n    }\n    for h in 0..max_height\
    \ {\n        for row in grid.iter() {\n            for &cell in row.iter() {\n\
    \                if cell == 1 {\n                    count += 1;\n           \
    \     }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `h`\n  --> /tmp/tmp6ogbte1n.rs:30:9\n   |\n30\
    \ |     for h in 0..max_height {\n   |         ^ help: if this is intentional,\
    \ prefix it with an underscore: `_h`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: unused variable: `capacity`\n  --> /tmp/tmp6ogbte1n.rs:16:36\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n\nerror[E0382]: borrow of moved value:\
    \ `grid`\n    --> /tmp/tmp6ogbte1n.rs:31:20\n     |\n16   | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n     |             ---- move occurs\
    \ because `grid` has type `Vec<Vec<isize>>`, which does not implement the `Copy`\
    \ trait\n...\n19   |     for row in grid {\n     |                ----\n     |\
    \                |\n     |                `grid` moved due to this implicit call\
    \ to `.into_iter()`\n     |                help: consider borrowing to avoid moving\
    \ into the for loop: `&grid`\n...\n31   |         for row in grid.iter() {\n \
    \    |                    ^^^^^^^^^^^ value borrowed here after move\n     |\n\
    note: this function takes ownership of the receiver `self`, which moves `grid`\n\
    \     = note: borrow occurs due to deref coercion to `[Vec<isize>]`\nnote: deref\
    \ defined here\n\nerror: aborting due to previous error; 2 warnings emitted\n\n\
    For more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747071
