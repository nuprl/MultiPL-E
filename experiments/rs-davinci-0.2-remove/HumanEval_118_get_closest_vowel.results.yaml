language: rs
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut last_consonant = word.len();\n \
    \   for (i, c) in word.chars().enumerate() {\n        if is_vowel(c) {\n     \
    \       if i - last_consonant < closest_distance {\n                closest_distance\
    \ = i - last_consonant;\n                closest_vowel = c.to_string();\n    \
    \        }\n        } else {\n            last_consonant = i;\n        }\n   \
    \ }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp_6vxdt88.rs:12:12\n\
    \   |\n12 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel = 0;\n    let mut last_consonant\
    \ = 0;\n    let mut last_char = ' ';\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            last_vowel = i;\n        }\
    \ else {\n            if last_vowel > last_consonant {\n                result\
    \ = word[last_vowel..i].to_string();\n            }\n            last_consonant\
    \ = i;\n        }\n        last_char = c;\n    }\n    if last_vowel > last_consonant\
    \ {\n        result = word[last_vowel..].to_string();\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpil0d7m5t.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_index = word.len();\n    let mut last_consonant_index = word.len();\n\
    \    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let consonants = vec!['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    for (i, c) in word.chars().enumerate() {\n       \
    \ if vowels.contains(&c) {\n            if i > last_consonant_index {\n      \
    \          if i - last_consonant_index < closest_vowel_index - last_consonant_index\
    \ {\n                    closest_vowel_index = i;\n                    closest_vowel\
    \ = c.to_string();\n                }\n            }\n        } else if consonants.contains(&c)\
    \ {\n            last_consonant_index = i;\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp5gcghx1c.rs:16:47

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_vowel_index = word.len();\n\
    \    for (i, c) in word.chars().enumerate().rev() {\n        if vowels.contains(&c)\
    \ {\n            closest_vowel_index = i;\n            closest_vowel = c.to_string();\n\
    \        } else if closest_vowel_index != word.len() {\n            break;\n \
    \       }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmpvwogijtn.rs:11:44\n   |\n11 |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n   |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmpvwogijtn.rs:11:19\n    |\n11  |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_char = ' ';\n    for\
    \ (i, c) in word.chars().enumerate() {\n        if c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u' {\n            last_vowel = i;\n        } else {\n\
    \            last_consonant = i;\n        }\n        if last_vowel > last_consonant\
    \ && last_consonant > 0 && last_vowel > 0 {\n            result = word[last_vowel..last_vowel\
    \ + 1].to_string();\n        }\n        last_char = c;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp8mxb8h6a.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel_index\
    \ = 0;\n    let mut last_consonant_index = 0;\n    let mut last_vowel_char = '\
    \ ';\n    let mut last_consonant_char = ' ';\n    let mut last_char = ' ';\n \
    \   let mut vowel_found = false;\n    let mut consonant_found = false;\n    let\
    \ mut vowel_index = 0;\n    let mut consonant_index = 0;\n    let mut vowel_char\
    \ = ' ';\n    let mut consonant_char = ' ';\n    let mut char = ' ';\n    let\
    \ mut i = 0;\n    for c in word.chars() {\n        char = c;\n        if is_vowel(char)\
    \ {\n            vowel_found = true;\n            vowel_index = i;\n         \
    \   vowel_char = char;\n        } else {\n            consonant_found = true;\n\
    \            consonant_index = i;\n            consonant_char = char;\n      \
    \  }\n        if vowel_found && consonant_found {\n            if last_vowel_index\
    \ == 0 {\n                last_vowel_index = vowel_index;\n                last_vowel_char\
    \ = vowel_char;\n                last_consonant_index = consonant_index;\n   \
    \             last_consonant_char = consonant_char;\n                last_char\
    \ = char;\n            } else {\n                if last_vowel_index < consonant_index\
    \ {\n                    last_vowel_index = vowel_index;\n                   \
    \ last_vowel_char = vowel_char;\n                    last_consonant_index = consonant_index;\n\
    \                    last_consonant_char = consonant_char;\n                 \
    \   last_char = char;\n                }\n            }\n            vowel_found\
    \ = false;\n            consonant_found = false;\n        }\n        i += 1;\n\
    \    }\n    if last_vowel_index > 0 {\n        result.push(last_vowel_char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpob5x8wz1.rs:24:12\n\
    \   |\n24 |         if is_vowel(char) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_consonant_index = 0;\n\
    \    let mut last_vowel_index = 0;\n    let mut index = 0;\n    for c in word.chars()\
    \ {\n        if is_vowel(c) {\n            last_vowel = index;\n            last_vowel_index\
    \ = index;\n        } else {\n            last_consonant = index;\n          \
    \  last_consonant_index = index;\n        }\n        index += 1;\n    }\n    if\
    \ last_vowel_index > last_consonant_index {\n        result.push(word.chars().nth(last_vowel_index).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpxaa1c4_h.rs:15:12\n\
    \   |\n15 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev_char\
    \ = ' ';\n    let mut vowel_found = false;\n    let mut vowel_found_index = 0;\n\
    \    let mut vowel_found_char = ' ';\n    for (i, c) in word.chars().rev().enumerate()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \           if prev_char != ' ' && !vowel_found {\n                vowel_found\
    \ = true;\n                vowel_found_index = i;\n                vowel_found_char\
    \ = c;\n            }\n        } else {\n            if vowel_found {\n      \
    \          if i == vowel_found_index + 1 {\n                    result.push(vowel_found_char);\n\
    \                    break;\n                } else {\n                    vowel_found\
    \ = false;\n                }\n            }\n        }\n        prev_char = c;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpifk4ia6b.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel_index\
    \ = 0;\n    let mut last_consonant_index = 0;\n    let mut last_vowel_found =\
    \ false;\n    let mut last_consonant_found = false;\n    let mut last_char_is_vowel\
    \ = false;\n    let mut last_char_is_consonant = false;\n    let mut last_char_is_vowel_or_consonant\
    \ = false;\n    let mut last_char_is_vowel_and_consonant = false;\n    let mut\
    \ last_char_is_vowel_and_consonant_and_found = false;\n    let mut last_char_is_vowel_and_consonant_and_found_and_not_first\
    \ = false;\n    let mut last_char_is_vowel_and_consonant_and_found_and_not_first_and_not_last\
    \ = false;\n    let mut last_char_is_vowel_and_consonant_and_found_and_not_first_and_not_last_and_not_last_vowel\
    \ = false;\n    let mut last_char_is_vowel_and_consonant_and_found_and_not_first_and_not_last_and_not_last_vowel_and_not_last_consonant\
    \ = false;\n    let mut last_char_is_vowel_and_consonant_and_found_and_not_first_and_not_last_and_not_last_vowel_and_not_last_consonant_and_not_last_vowel_found\
    \ = false;\n    let mut last_char_is_vowel_and_consonant_and_found_and_not_first_and_not_last_and_not_last_vowel_and_not_last_consonant_and_not_last_vowel_found_and_not_last_consonant_found\
    \ = false;\n    let mut last_char_is_vowel_and_\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp9mrsnhr.rs:24:36\n   |\n\
    24 |     let mut last_char_is_vowel_and_\n   |                               \
    \     ^ help: add `;` here\n25 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpp9mrsnhr.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String)\
    \ -> String {\n  |    -----------------                  ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut last_consonant = word.len();\n \
    \   let mut last_vowel = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \           if i > last_consonant && i - last_consonant < closest_distance {\n\
    \                closest_distance = i - last_consonant;\n                closest_vowel\
    \ = c.to_string();\n            }\n            last_vowel = i;\n        } else\
    \ {\n            if i < last_vowel && last_vowel - i < closest_distance {\n  \
    \              closest_distance = last_vowel - i;\n                closest_vowel\
    \ = word[last_vowel..i].chars().next().unwrap().to_string();\n            }\n\
    \            last_consonant = i;\n        }\n    }\n    closest_vowel\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpcz3wcauv.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = String::new();\n    let mut last_consonant = String::new();\n    let mut last_char\
    \ = String::new();\n    let mut last_char_is_vowel = false;\n    let mut last_char_is_consonant\
    \ = false;\n    let mut last_char_is_vowel_or_consonant = false;\n    let mut\
    \ last_char_is_vowel_and_consonant = false;\n    let mut last_char_is_vowel_or_consonant_and_consonant\
    \ = false;\n    let mut last_char_is_vowel_and_consonant_and_consonant = false;\n\
    \    let mut last_char_is_vowel_or_consonant_and_vowel = false;\n    let mut last_char_is_vowel_and_consonant_and_vowel\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_and_vowel_and_consonant\
    \ = false;\n    let mut last_char_is_vowel_and_consonant_and_vowel_and_consonant\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_and_vowel_and_vowel =\
    \ false;\n    let mut last_char_is_vowel_and_consonant_and_vowel_and_vowel = false;\n\
    \    let mut last_char_is_vowel_or_consonant_and_vowel_and_vowel_and_consonant\
    \ = false;\n    let mut last_char_is_vowel_and_consonant_and_vowel_and_vowel_and_consonant\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_and_vowel_and_vowel_and_vowel\
    \ = false;\n    let mut last_char_is_vowel_and_conson\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdiw1u6r0.rs:27:42\n   |\n\
    27 |     let mut last_char_is_vowel_and_conson\n   |                         \
    \                 ^ help: add `;` here\n28 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpdiw1u6r0.rs:7:39\n  |\n7 | fn get_closest_vowel(word:\
    \ String) -> String {\n  |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut last_vowel = None;\n    let mut last_consonant\
    \ = None;\n    let mut result = String::new();\n    for c in word.chars() {\n\
    \        if is_vowel(c) {\n            last_vowel = Some(c);\n        } else {\n\
    \            if last_vowel.is_some() {\n                result.push(last_vowel.unwrap());\n\
    \                break;\n            }\n            last_consonant = Some(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpi73c83bk.rs:12:12\n\
    \   |\n12 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev_vowel\
    \ = false;\n    let mut prev_consonant = false;\n    for c in word.chars().rev()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \           if prev_consonant {\n                result.push(c);\n           \
    \     break;\n            }\n            prev_vowel = true;\n        } else {\n\
    \            if prev_vowel {\n                result.push(c);\n              \
    \  break;\n            }\n            prev_consonant = true;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpaelfk2on.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut consonants = vec!['b', 'c', 'd',\
    \ 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x',\
    \ 'y', 'z'];\n    let mut word_chars: Vec<char> = word.chars().collect();\n  \
    \  let mut word_len = word_chars.len();\n    let mut i = word_len - 1;\n    let\
    \ mut j = word_len - 1;\n    let mut k = word_len - 1;\n    let mut l = word_len\
    \ - 1;\n    let mut m = word_len - 1;\n    let mut n = word_len - 1;\n    let\
    \ mut o = word_len - 1;\n    let mut p = word_len - 1;\n    let mut q = word_len\
    \ - 1;\n    let mut r = word_len - 1;\n    let mut s = word_len - 1;\n    let\
    \ mut t = word_len - 1;\n    let mut u = word_len - 1;\n    let mut v = word_len\
    \ - 1;\n    let mut w = word_len - 1;\n    let mut x = word_len - 1;\n    let\
    \ mut y = word_len - 1;\n    let mut z = word_len - 1;\n    let mut a = word_len\
    \ - 1;\n    let mut e = word_len - 1;\n    let mut i = word_len - 1;\n    let\
    \ mut o = word_len - 1;\n    let mut u = word_len - 1;\n    let mut b = word_len\
    \ - 1;\n    let mut c = word_len - 1;\n    let mut d = word_len - 1;\n    let\
    \ mut f = word_len - 1;\n    let mut g = word_len - 1;\n    let mut h = word_len\
    \ - 1;\n    let mut j = word_len - 1;\n    let mut k = word_\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpat3vh7ia.rs:43:22\n   |\n\
    43 |     let mut k = word_\n   |                      ^ help: add `;` here\n44\
    \ | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `word_` in this\
    \ scope\n  --> /tmp/tmpat3vh7ia.rs:43:17\n   |\n43 |     let mut k = word_\n \
    \  |                 ^^^^^ help: a local variable with a similar name exists:\
    \ `word`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpat3vh7ia.rs:7:39\n  |\n\
    7 | fn get_closest_vowel(word: String) -> String {\n  |    ----------------- \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = String::new();\n    let mut last_consonant = String::new();\n    let mut last_char\
    \ = String::new();\n    let mut last_char_is_vowel = false;\n    let mut last_char_is_consonant\
    \ = false;\n    let mut last_char_is_vowel_or_consonant = false;\n    let mut\
    \ last_char_is_vowel_or_consonant_or_empty = false;\n    let mut last_char_is_empty\
    \ = false;\n    let mut last_char_is_vowel_or_empty = false;\n    let mut last_char_is_consonant_or_empty\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_end = false;\n\
    \    let mut last_char_is_vowel_or_consonant_or_end = false;\n    let mut last_char_is_vowel_or_end\
    \ = false;\n    let mut last_char_is_consonant_or_end = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_start\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_start = false;\n  \
    \  let mut last_char_is_vowel_or_start = false;\n    let mut last_char_is_consonant_or_start\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_start_or_end\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_start_or_end = false;\n\
    \    let mut last_char_is_vowel_or_start_or_end = false;\n    let mut last_char_is_consonant_or_start_or_end\
    \ = false;\n    let mut last_char_is_start = false;\n    let mut last_char_is_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8h_q65y8.rs:32:26\n   |\n\
    32 |     let mut last_char_is_\n   |                          ^ help: add `;`\
    \ here\n33 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp8h_q65y8.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String) -> String\
    \ {\n  |    -----------------                  ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = String::new();\n    let mut last_consonant = String::new();\n    let mut last_char\
    \ = String::new();\n    let mut last_vowel_index = 0;\n    let mut last_consonant_index\
    \ = 0;\n    let mut last_char_index = 0;\n    let mut index = 0;\n    let mut\
    \ found = false;\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    for c in word.chars() {\n        let s = c.to_string();\n\
    \        if vowels.contains(&s.as_str()) {\n            last_vowel = s;\n    \
    \        last_vowel_index = index;\n        }\n        if consonants.contains(&s.as_str())\
    \ {\n            last_consonant = s;\n            last_consonant_index = index;\n\
    \        }\n        if last_vowel_index > last_consonant_index {\n           \
    \ if last_vowel_index < index {\n                result = last_vowel;\n      \
    \          found = true;\n            }\n        }\n        last_char = s;\n \
    \       last_char_index = index;\n        index += 1;\n    }\n    if !found {\n\
    \        if last_vowel_index > last_consonant_index {\n            result = last_vowel;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "warning: variable `last_consonant` is assigned to, but never used\n  -->\
    \ /tmp/tmp1kocehks.rs:10:13\n   |\n10 |     let mut last_consonant = String::new();\n\
    \   |             ^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_last_consonant` instead\n\nwarning:\
    \ variable `last_char` is assigned to, but never used\n  --> /tmp/tmp1kocehks.rs:11:13\n\
    \   |\n11 |     let mut last_char = String::new();\n   |             ^^^^^^^^^\n\
    \   |\n   = note: consider using `_last_char` instead\n\nwarning: variable `last_char_index`\
    \ is assigned to, but never used\n  --> /tmp/tmp1kocehks.rs:14:13\n   |\n14 |\
    \     let mut last_char_index = 0;\n   |             ^^^^^^^^^^^^^^^\n   |\n \
    \  = note: consider using `_last_char_index` instead\n\nwarning: value assigned\
    \ to `last_consonant` is never read\n  --> /tmp/tmp1kocehks.rs:26:13\n   |\n26\
    \ |             last_consonant = s;\n   |             ^^^^^^^^^^^^^^\n   |\n \
    \  = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `last_char` is\
    \ never read\n  --> /tmp/tmp1kocehks.rs:35:9\n   |\n35 |         last_char = s;\n\
    \   |         ^^^^^^^^^\n   |\n   = help: maybe it is overwritten before being\
    \ read?\n\nwarning: value assigned to `last_char_index` is never read\n  --> /tmp/tmp1kocehks.rs:36:9\n\
    \   |\n36 |         last_char_index = index;\n   |         ^^^^^^^^^^^^^^^\n \
    \  |\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp1kocehks.rs:17:9\n   |\n17 |    \
    \ let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n   |         ----^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmp1kocehks.rs:18:9\n\
    \   |\n18 |     let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"\
    h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"];\n   |         ----^^^^^^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n\nerror[E0382]: borrow of "
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut consonant_found = false;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if consonant_found && vowels.contains(&c) {\n            if i < closest_distance\
    \ {\n                closest_distance = i;\n                closest_vowel = c.to_string();\n\
    \            }\n        }\n        if !vowels.contains(&c) {\n            consonant_found\
    \ = true;\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp96389s3j.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ word = word.chars().collect::<Vec<char>>();\n    let mut result = String::new();\n\
    \    let mut index = 0;\n    let mut found = false;\n    for i in (0..word.len()).rev()\
    \ {\n        if vowels.contains(&word[i]) {\n            if i == word.len() -\
    \ 1 {\n                continue;\n            }\n            if !vowels.contains(&word[i\
    \ + 1]) {\n                index = i;\n                found = true;\n       \
    \         break;\n            }\n        }\n    }\n    if found {\n        result.push(word[index]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpqtnp9h4c.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_distance = word.len();\n    let mut last_consonant_index = 0;\n\
    \    let mut vowel_index = 0;\n    let mut vowel_found = false;\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            vowel_index = i;\n        \
    \    vowel_found = true;\n        } else {\n            if vowel_found && vowel_index\
    \ > last_consonant_index {\n                if vowel_index - last_consonant_index\
    \ < closest_vowel_distance {\n                    closest_vowel_distance = vowel_index\
    \ - last_consonant_index;\n                    closest_vowel = c.to_string();\n\
    \                }\n            }\n            last_consonant_index = i;\n   \
    \     }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"g\"`,\n right: `\"u\"`', /tmp/tmpxr3r0rhf.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_distance = word.len();\n\
    \    let mut last_consonant = 0;\n    for (i, c) in word.chars().enumerate() {\n\
    \        if vowels.contains(&c) {\n            if i - last_consonant < closest_distance\
    \ {\n                closest_distance = i - last_consonant;\n                closest_vowel\
    \ = c.to_string();\n            }\n        } else {\n            last_consonant\
    \ = i;\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpa53yltjd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut word = word.chars().collect::<Vec<char>>();\n\
    \    let mut i = word.len() - 1;\n    let mut vowel = String::new();\n    let\
    \ mut consonant = String::new();\n    while i > 0 {\n        if word[i].is_vowel()\
    \ {\n            vowel = word[i].to_string();\n            break;\n        }\n\
    \        i -= 1;\n    }\n    if vowel.is_empty() {\n        return vowel;\n  \
    \  }\n    i -= 1;\n    while i > 0 {\n        if word[i].is_consonant() {\n  \
    \          consonant = word[i].to_string();\n            break;\n        }\n \
    \       i -= 1;\n    }\n    if consonant.is_empty() {\n        return consonant;\n\
    \    }\n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp2to_t9sq.rs:13:20\n   |\n13 |         if word[i].is_vowel()\
    \ {\n   |                    ^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `is_consonant` found for type `char` in the current scope\n\
    \  --> /tmp/tmp2to_t9sq.rs:24:20\n   |\n24 |         if word[i].is_consonant()\
    \ {\n   |                    ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut consonants = Vec::new();\n    let mut index = 0;\n\
    \    for c in word.chars() {\n        if c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u' {\n            vowels.push(index);\n        } else {\n  \
    \          consonants.push(index);\n        }\n        index += 1;\n    }\n  \
    \  for i in 0..consonants.len() {\n        if i == 0 {\n            if vowels.len()\
    \ > 0 && vowels[0] < consonants[i] {\n                result = vowels[0].to_string();\n\
    \            }\n        } else {\n            if vowels.len() > 0 && vowels[0]\
    \ > consonants[i-1] && vowels[0] < consonants[i] {\n                result = vowels[0].to_string();\n\
    \            }\n        }\n    }\n    if vowels.len() > 0 && vowels[0] > consonants[consonants.len()-1]\
    \ {\n        result = vowels[0].to_string();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1\"`,\n right: `\"u\"`', /tmp/tmpk1y3eqq1.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ vowel_index = 0;\n    let mut vowel_found = false;\n    let mut last_consonant_index\
    \ = 0;\n    let mut last_consonant_found = false;\n    let mut current_index =\
    \ 0;\n    for c in word.chars() {\n        if is_vowel(c) {\n            if last_consonant_found\
    \ {\n                vowel_found = true;\n                vowel_index = current_index;\n\
    \                break;\n            }\n        } else {\n            last_consonant_found\
    \ = true;\n            last_consonant_index = current_index;\n        }\n    \
    \    current_index += 1;\n    }\n    if vowel_found {\n        closest_vowel.push(word.chars().nth(vowel_index).unwrap());\n\
    \    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpehojkzjr.rs:15:12\n\
    \   |\n15 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_index = 0;\n    let mut vowel_distance\
    \ = word.len();\n    let mut last_consonant_index = 0;\n    let mut last_consonant_distance\
    \ = word.len();\n    let mut result = String::new();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if is_vowel(c) {\n            if i - last_consonant_index < vowel_distance\
    \ {\n                vowel_distance = i - last_consonant_index;\n            \
    \    vowel_index = i;\n            }\n        } else {\n            if i - vowel_index\
    \ < last_consonant_distance {\n                last_consonant_distance = i - vowel_index;\n\
    \                last_consonant_index = i;\n            }\n        }\n    }\n\
    \    if vowel_distance < last_consonant_distance {\n        result.push(word.chars().nth(vowel_index).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp98ywxzrf.rs:14:12\n\
    \   |\n14 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_distance = word.len();\n\
    \    let mut last_consonant = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            if i - last_consonant < closest_distance\
    \ {\n                closest_distance = i - last_consonant;\n                closest_vowel\
    \ = c.to_string();\n            }\n        } else {\n            last_consonant\
    \ = i;\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp9x6zvd66.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut index = word.len();\n    let mut vowel_index\
    \ = 0;\n    let mut vowel_found = false;\n    let mut vowel_distance = 0;\n  \
    \  let mut last_consonant_index = 0;\n    let mut last_consonant_found = false;\n\
    \    let mut last_consonant_distance = 0;\n    let vowels = ['a', 'e', 'i', 'o',\
    \ 'u'];\n    let consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm',\
    \ 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    for c in word.chars().rev()\
    \ {\n        index -= 1;\n        if !vowel_found {\n            if vowels.contains(&c)\
    \ {\n                vowel_found = true;\n                vowel_index = index;\n\
    \                vowel_distance = word.len() - index;\n            }\n       \
    \ }\n        if !last_consonant_found {\n            if consonants.contains(&c)\
    \ {\n                last_consonant_found = true;\n                last_consonant_index\
    \ = index;\n                last_consonant_distance = word.len() - index;\n  \
    \          }\n        }\n        if vowel_found && last_consonant_found {\n  \
    \          break;\n        }\n    }\n    if vowel_found && last_consonant_found\
    \ && vowel_index > last_consonant_index {\n        return word[vowel_index..vowel_index+1].to_string();\n\
    \    }\n    return \"\".to_string();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpz0vp3g06.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_index = word.len();\n    let mut last_consonant_index = word.len();\n\
    \    let mut vowel_found = false;\n    for (i, c) in word.chars().enumerate().rev()\
    \ {\n        if is_vowel(c) {\n            if i < last_consonant_index {\n   \
    \             closest_vowel = c.to_string();\n                closest_vowel_index\
    \ = i;\n                vowel_found = true;\n            }\n        } else {\n\
    \            last_consonant_index = i;\n        }\n    }\n    if vowel_found {\n\
    \        closest_vowel\n    } else {\n        String::new()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpc4jes5we.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not\
    \ satisfied\n  --> /tmp/tmpc4jes5we.rs:12:44\n   |\n12 |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n   |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmpc4jes5we.rs:12:19\n    |\n12  |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev_char\
    \ = ' ';\n    let mut prev_vowel = ' ';\n    for c in word.chars().rev() {\n \
    \       if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n      \
    \      if prev_char != ' ' && prev_char != 'a' && prev_char != 'e' && prev_char\
    \ != 'i' && prev_char != 'o' && prev_char != 'u' {\n                result.push(c);\n\
    \                break;\n            }\n            prev_vowel = c;\n        }\n\
    \        prev_char = c;\n    }\n    if result.is_empty() {\n        result.push(prev_vowel);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpmd897glv.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev_vowel\
    \ = false;\n    let mut prev_consonant = false;\n    for c in word.chars().rev()\
    \ {\n        if is_vowel(c) {\n            if prev_consonant {\n             \
    \   result.push(c);\n                break;\n            }\n            prev_vowel\
    \ = true;\n        } else {\n            if prev_vowel {\n                result.push(c);\n\
    \                break;\n            }\n            prev_consonant = true;\n \
    \       }\n    }\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpxmpx2fj3.rs:12:12\n\
    \   |\n12 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 0
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut word = word.chars().rev().collect::<Vec<char>>();\n\
    \    let mut result = String::new();\n    let mut found = false;\n    for i in\
    \ 0..word.len() {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u' {\n            if i > 0 && i < word.len()\
    \ - 1 {\n                if word[i - 1] != 'a' && word[i - 1] != 'e' && word[i\
    \ - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i + 1] != 'a'\
    \ && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i\
    \ + 1] != 'u' {\n                    result.push(word[i]);\n                 \
    \   found = true;\n                    break;\n                }\n           \
    \ }\n        }\n    }\n    if found {\n        result\n    } else {\n        String::new()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut chars = word.chars().rev().peekable();\n  \
    \  let mut result = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o',\
    \ 'u'];\n    let mut found_vowel = false;\n    while let Some(c) = chars.next()\
    \ {\n        if vowels.contains(&c) {\n            result.push(c);\n         \
    \   found_vowel = true;\n        } else if found_vowel {\n            break;\n\
    \        }\n    }\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ea\"`,\n right: `\"\"`', /tmp/tmpv286z4pj.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ last_vowel = String::new();\n    let mut last_consonant = String::new();\n \
    \   let mut last_char = String::new();\n    let mut last_char_is_vowel = false;\n\
    \    let mut last_char_is_consonant = false;\n    let mut last_char_is_vowel_or_consonant\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_other = false;\n  \
    \  let mut last_char_is_other = false;\n    let mut last_char_is_vowel_or_other\
    \ = false;\n    let mut last_char_is_consonant_or_other = false;\n    let mut\
    \ last_char_is_vowel_or_consonant_or_other = false;\n    let mut last_char_is_vowel_or_consonant_or_other_or_other\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_other_or_other_or_other\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_other_or_other_or_other_or_other\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_other_or_other_or_other_or_other_or_other\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_other_or_other_or_other_or_other_or_other_or_other\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_other_or_other_or_other_or_other_or_other_or_other_or_other\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_other_or_other_or_other_or_other_or_other_or_other_or_other_or_other\
    \ = false;\n    let mut\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpcqoyqokd.rs:28:1\n\
    \   |\n28 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_index = word.len();\n    let mut last_consonant_index = word.len();\n\
    \    let mut vowel_found = false;\n    for (i, c) in word.chars().enumerate().rev()\
    \ {\n        if is_vowel(c) {\n            if i < last_consonant_index {\n   \
    \             vowel_found = true;\n                if i < closest_vowel_index\
    \ {\n                    closest_vowel_index = i;\n                    closest_vowel\
    \ = c.to_string();\n                }\n            }\n        } else {\n     \
    \       last_consonant_index = i;\n        }\n    }\n    if vowel_found {\n  \
    \      closest_vowel\n    } else {\n        String::new()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp_2pf14tb.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not\
    \ satisfied\n  --> /tmp/tmp_2pf14tb.rs:12:44\n   |\n12 |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n   |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmp_2pf14tb.rs:12:19\n    |\n12  |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel_index = 0;\n    let mut\
    \ last_consonant_index = 0;\n    for (i, c) in word.chars().enumerate() {\n  \
    \      if vowels.contains(&c) {\n            last_vowel_index = i;\n        }\
    \ else {\n            last_consonant_index = i;\n        }\n        if last_vowel_index\
    \ > last_consonant_index {\n            result = word[last_vowel_index..].to_string();\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ogurt\"`,\n right: `\"u\"`', /tmp/tmpb6fpsp12.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev_char\
    \ = ' ';\n    let mut prev_vowel = ' ';\n    for c in word.chars().rev() {\n \
    \       if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n      \
    \      if prev_char != ' ' && prev_char != 'a' && prev_char != 'e' && prev_char\
    \ != 'i' && prev_char != 'o' && prev_char != 'u' {\n                result = c.to_string();\n\
    \                break;\n            }\n            prev_vowel = c;\n        }\n\
    \        prev_char = c;\n    }\n    if result.is_empty() {\n        result = prev_vowel.to_string();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpi4z377ev.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowel_index\
    \ = 0;\n    let mut consonant_index = 0;\n    let mut vowel_count = 0;\n    let\
    \ mut consonant_count = 0;\n    let mut vowel_distance = 0;\n    let mut consonant_distance\
    \ = 0;\n    let mut distance = 0;\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_consonant = String::new();\n    let mut closest_distance\
    \ = 0;\n    let mut closest_vowel_index = 0;\n    let mut closest_consonant_index\
    \ = 0;\n    let mut closest_vowel_count = 0;\n    let mut closest_consonant_count\
    \ = 0;\n    let mut closest_vowel_distance = 0;\n    let mut closest_consonant_distance\
    \ = 0;\n    let mut word_chars: Vec<char> = word.chars().collect();\n    let mut\
    \ word_length = word_chars.len();\n    let mut word_index = 0;\n    let mut word_char\
    \ = ' ';\n    let mut word_char_string = String::new();\n    let mut word_char_string_lower\
    \ = String::new();\n    let mut word_char_string_upper = String::new();\n    let\
    \ mut vowel_char = ' ';\n    let mut vowel_char_string = String::new();\n    let\
    \ mut vowel_char_string_lower = String::new();\n    let mut vowel_char_string_upper\
    \ = String::new();\n    let mut consonant_char = ' ';\n    let mut consonant_char_string\
    \ = String::new();\n    let mut consonant_char_string_lower = String::new();\n\
    \    let mut consonant_char_string_upper = String::new();\n    let mut vowel_char_index\
    \ = 0;\n    let mut consonant_char_index = 0;\n    let mut vowel_char_count =\
    \ 0;\n    let mut consonant_char_count = 0;\n    let mut vowel_char_distance =\
    \ 0;\n    let mut\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpwc7tnntx.rs:48:1\n\
    \   |\n48 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ last_consonant = String::new();\n    let mut last_vowel = String::new();\n \
    \   let mut last_char = String::new();\n    let mut last_vowel_index = 0;\n  \
    \  let mut last_consonant_index = 0;\n    let mut last_char_index = 0;\n    let\
    \ mut vowel_index = 0;\n    let mut consonant_index = 0;\n    let mut char_index\
    \ = 0;\n    let mut vowel_found = false;\n    let mut consonant_found = false;\n\
    \    let mut char_found = false;\n    let mut vowel_distance = 0;\n    let mut\
    \ consonant_distance = 0;\n    let mut char_distance = 0;\n    let mut vowel_distance_min\
    \ = 0;\n    let mut consonant_distance_min = 0;\n    let mut char_distance_min\
    \ = 0;\n    let mut vowel_distance_min_index = 0;\n    let mut consonant_distance_min_index\
    \ = 0;\n    let mut char_distance_min_index = 0;\n    let mut vowel_distance_min_found\
    \ = false;\n    let mut consonant_distance_min_found = false;\n    let mut char_distance_min_found\
    \ = false;\n    let mut vowel_distance_min_index_found = false;\n    let mut consonant_distance_min_index_found\
    \ = false;\n    let mut char_distance_min_index_found = false;\n    let mut vowel_distance_min_index_found_first\
    \ = false;\n    let mut consonant_distance_min_index_found_first = false;\n  \
    \  let mut char_distance_min_index_found_first = false;\n    let mut vowel_distance_min_index_found_second\
    \ = false;\n    let mut consonant_distance_min_index_found_second = false;\n \
    \   let mut char_distance_min_index_found_second = false;\n    let mut vowel_distance_min_index_found_third\
    \ = false;\n    let mut consonant_distance_min_index_found_third = false;\n  \
    \  let mut char_\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n \
    \   assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n  \
    \  assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7opv9lhn.rs:44:18\n   |\n\
    44 |     let mut char_\n   |                  ^ help: add `;` here\n45 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7opv9lhn.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut word = word.chars().rev().collect::<Vec<char>>();\n\
    \    let mut result = String::new();\n    let mut i = 0;\n    while i < word.len()\
    \ {\n        if word[i].is_vowel() {\n            result.push(word[i]);\n    \
    \        break;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpmsh0xf35.rs:12:20\n   |\n12 |         if word[i].is_vowel()\
    \ {\n   |                    ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_index = 0;\n    let mut last_consonant_index\
    \ = 0;\n    let mut last_vowel_index = 0;\n    let mut last_vowel_distance = 0;\n\
    \    let mut last_consonant_distance = 0;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    for c in word.chars() {\n        if c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u' {\n            vowel_index = i;\n  \
    \          if last_consonant_index != 0 {\n                last_vowel_distance\
    \ = vowel_index - last_consonant_index;\n                if last_vowel_index ==\
    \ 0 {\n                    last_vowel_index = vowel_index;\n                }\
    \ else {\n                    if last_vowel_distance < last_consonant_distance\
    \ {\n                        last_vowel_index = vowel_index;\n               \
    \     }\n                }\n            }\n        } else {\n            if vowel_index\
    \ != 0 {\n                last_consonant_index = i;\n                last_consonant_distance\
    \ = last_consonant_index - vowel_index;\n            }\n        }\n        i +=\
    \ 1;\n    }\n    if last_vowel_index != 0 {\n        result.push(word.chars().nth(last_vowel_index).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp_tq5zta9.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut result = String::new();\n\
    \    let mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n  \
    \  for (i, c) in word.chars().enumerate() {\n        if vowels.contains(c) {\n\
    \            last_vowel_index = i;\n        } else {\n            last_consonant_index\
    \ = i;\n        }\n        if last_vowel_index > last_consonant_index {\n    \
    \        result = word[last_vowel_index..].to_string();\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"urt\"`,\n right: `\"u\"`', /tmp/tmpncqp4m7z.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_index = word.len();\n    let mut last_consonant_index = word.len();\n\
    \    for (i, c) in word.chars().enumerate() {\n        if is_vowel(c) {\n    \
    \        if i > last_consonant_index {\n                if i - last_consonant_index\
    \ < closest_vowel_index - last_consonant_index {\n                    closest_vowel\
    \ = c.to_string();\n                    closest_vowel_index = i;\n           \
    \     }\n            }\n        } else {\n            last_consonant_index = i;\n\
    \        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp20_ovknc.rs:12:12\n\
    \   |\n12 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_vowel_index = 0;\n \
    \   let mut last_consonant_index = 0;\n    let mut vowel_found = false;\n    let\
    \ mut consonant_found = false;\n    let mut index = 0;\n    for c in word.chars()\
    \ {\n        if is_vowel(c) {\n            last_vowel = c as u8;\n           \
    \ last_vowel_index = index;\n            vowel_found = true;\n        } else {\n\
    \            last_consonant = c as u8;\n            last_consonant_index = index;\n\
    \            consonant_found = true;\n        }\n        if vowel_found && consonant_found\
    \ {\n            if last_vowel_index > last_consonant_index {\n              \
    \  result.push(last_vowel as char);\n                break;\n            }\n \
    \       }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpvi9ei4e6.rs:17:12\n\
    \   |\n17 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel_pos\
    \ = 0;\n    let mut last_consonant_pos = 0;\n    let mut last_char_is_vowel =\
    \ false;\n    let mut last_char_is_consonant = false;\n    let mut last_char_is_vowel_pos\
    \ = 0;\n    let mut last_char_is_consonant_pos = 0;\n    let mut last_char_is_vowel_pos_result\
    \ = 0;\n    let mut last_char_is_consonant_pos_result = 0;\n    let mut last_char_is_vowel_result\
    \ = false;\n    let mut last_char_is_consonant_result = false;\n    let mut last_char_is_vowel_result_pos\
    \ = 0;\n    let mut last_char_is_consonant_result_pos = 0;\n    let mut last_char_is_vowel_result_pos_result\
    \ = 0;\n    let mut last_char_is_consonant_result_pos_result = 0;\n    let mut\
    \ last_char_is_vowel_result_result = false;\n    let mut last_char_is_consonant_result_result\
    \ = false;\n    let mut last_char_is_vowel_result_result_pos = 0;\n    let mut\
    \ last_char_is_consonant_result_result_pos = 0;\n    let mut last_char_is_vowel_result_result_pos_result\
    \ = 0;\n    let mut last_char_is_consonant_result_result_pos_result = 0;\n   \
    \ let mut last_char_is_vowel_result_result_result = false;\n    let mut last_char_is_consonant_result_result_result\
    \ = false;\n    let mut last_char_is_vowel_result_result_result_pos = 0;\n   \
    \ let mut last_char_is_consonant_result_result_result_pos = 0;\n    let mut last_char_is_vowel_result_result_result_pos_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu0gi4gcs.rs:33:57\n   |\n\
    33 |     let mut last_char_is_vowel_result_result_result_pos_\n   |          \
    \                                               ^ help: add `;` here\n34 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpu0gi4gcs.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut last_consonant = word.len();\n \
    \   let mut last_vowel = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if \"aeiou\".contains(c) {\n            last_vowel = i;\n       \
    \     if last_consonant < i {\n                let distance = i - last_consonant;\n\
    \                if distance < closest_distance {\n                    closest_distance\
    \ = distance;\n                    closest_vowel = c.to_string();\n          \
    \      }\n            }\n        } else {\n            last_consonant = i;\n \
    \       }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmppnbf5ch6.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel = String::new();\n    let\
    \ mut last_consonant = String::new();\n    let mut last_char = String::new();\n\
    \    for c in word.chars() {\n        if vowels.contains(&c) {\n            last_vowel\
    \ = c.to_string();\n        } else {\n            last_consonant = c.to_string();\n\
    \        }\n        if last_vowel != \"\" && last_consonant != \"\" {\n      \
    \      result = last_vowel.clone();\n            break;\n        }\n        last_char\
    \ = c.to_string();\n    }\n    if result == \"\" {\n        result = last_char;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp_mukg03_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowel_pos\
    \ = 0;\n    let mut prev_consonant_pos = 0;\n    let mut next_consonant_pos =\
    \ 0;\n    let mut vowel_found = false;\n    let mut prev_consonant_found = false;\n\
    \    let mut next_consonant_found = false;\n    let mut vowel_distance = 0;\n\
    \    let mut prev_consonant_distance = 0;\n    let mut next_consonant_distance\
    \ = 0;\n    let mut min_distance = 0;\n    let mut min_distance_vowel = 0;\n \
    \   let mut min_distance_prev_consonant = 0;\n    let mut min_distance_next_consonant\
    \ = 0;\n    let mut min_distance_found = false;\n    let mut vowel_list = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut consonant_list = vec!['b', 'c', 'd', 'f',\
    \ 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y',\
    \ 'z'];\n    let mut word_chars = word.chars().collect::<Vec<char>>();\n    let\
    \ mut word_len = word_chars.len();\n    for i in 0..word_len {\n        if vowel_list.contains(&word_chars[i])\
    \ {\n            vowel_found = true;\n            vowel_pos = i;\n           \
    \ if prev_consonant_found {\n                prev_consonant_distance = vowel_pos\
    \ - prev_consonant_pos;\n            }\n            if next_consonant_found {\n\
    \                next_consonant_distance = next_consonant_pos - vowel_pos;\n \
    \           }\n            if prev_consonant_found && next_consonant_found {\n\
    \                if prev_consonant_distance < next_consonant_distance {\n    \
    \                vowel_distance = prev_consonant_distance;\n                }\
    \ else {\n                    vowel_distance = next\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp3wia8bh9.rs:59:3\n\
    \   |\n7  | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n27 |     for i in\
    \ 0..word_len {\n   |                          - unclosed delimiter\n28 |    \
    \     if vowel_list.contains(&word_chars[i]) {\n   |                         \
    \                       - unclosed delimiter\n...\n37 |             if prev_consonant_found\
    \ && next_consonant_found {\n   |                                            \
    \                 - unclosed delimiter\n...\n40 |                 } else {\n \
    \  |                        - this delimiter might not be properly closed...\n\
    41 |                     vowel_distance = next\n42 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n59 | }\n   |   ^\n\nerror[E0425]:\
    \ cannot find value `next` in this scope\n  --> /tmp/tmp3wia8bh9.rs:41:38\n  \
    \ |\n41 |                     vowel_distance = next\n   |                    \
    \                  ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3wia8bh9.rs:27:5\n   |\n7  |   fn get_closest_vowel(word: String)\
    \ -> String {\n   |                                         ------ expected `String`\
    \ because of return type\n...\n27 | /     for i in 0..word_len {\n28 | |     \
    \    if vowel_list.contains(&word_chars[i]) {\n29 | |             vowel_found\
    \ = true;\n30 | |             vowel_pos = i;\n...  |\n58 | |     assert_eq!(candidate(String::from(\"\
    Above\")), String::from(\"o\"));\n59 | | }\n   | |__^ expected struct `String`,\
    \ found `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = String::new();\n    let mut last_consonant = String::new();\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut is_consonant = false;\n    for\
    \ c in word.chars() {\n        if vowels.contains(&c) {\n            last_vowel\
    \ = c.to_string();\n            if is_consonant {\n                result = last_vowel.clone();\n\
    \                break;\n            }\n        } else {\n            last_consonant\
    \ = c.to_string();\n            is_consonant = true;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpzyghjkxb.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut found = false;\n    let mut prev_char\
    \ = ' ';\n    for c in word.chars().rev() {\n        if vowels.contains(&c) {\n\
    \            if !found {\n                result.push(c);\n                found\
    \ = true;\n            }\n        } else {\n            if found && prev_char\
    \ != ' ' {\n                break;\n            }\n        }\n        prev_char\
    \ = c;\n    }\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpbtd439ln.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel_index = 0;\n    let mut\
    \ last_consonant_index = 0;\n    for (i, c) in word.chars().enumerate() {\n  \
    \      if vowels.contains(&c) {\n            last_vowel_index = i;\n        }\
    \ else {\n            last_consonant_index = i;\n        }\n        if last_vowel_index\
    \ > last_consonant_index {\n            result = c.to_string();\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpobdbuac2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel = 0;\n    let mut last_consonant\
    \ = 0;\n    for (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c)\
    \ {\n            last_vowel = i;\n        } else {\n            last_consonant\
    \ = i;\n        }\n        if last_vowel > last_consonant {\n            result\
    \ = c.to_string();\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp90thep8r.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_distance = word.len();\n\
    \    let mut last_consonant = 0;\n    for (i, c) in word.chars().enumerate() {\n\
    \        if vowels.contains(&c) {\n            if i - last_consonant < closest_distance\
    \ {\n                closest_distance = i - last_consonant;\n                closest_vowel\
    \ = c.to_string();\n            }\n        } else {\n            last_consonant\
    \ = i;\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpa53yltjd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ last_consonant = String::new();\n    let mut last_vowel = String::new();\n \
    \   let mut last_char = String::new();\n    let mut last_vowel_index = 0;\n  \
    \  let mut last_consonant_index = 0;\n    let mut vowel_index = 0;\n    let mut\
    \ consonant_index = 0;\n    let mut vowel_found = false;\n    let mut consonant_found\
    \ = false;\n    let mut vowel_found_first = false;\n    let mut consonant_found_first\
    \ = false;\n    let mut vowel_found_second = false;\n    let mut consonant_found_second\
    \ = false;\n    let mut vowel_found_third = false;\n    let mut consonant_found_third\
    \ = false;\n    let mut vowel_found_fourth = false;\n    let mut consonant_found_fourth\
    \ = false;\n    let mut vowel_found_fifth = false;\n    let mut consonant_found_fifth\
    \ = false;\n    let mut vowel_found_sixth = false;\n    let mut consonant_found_sixth\
    \ = false;\n    let mut vowel_found_seventh = false;\n    let mut consonant_found_seventh\
    \ = false;\n    let mut vowel_found_eighth = false;\n    let mut consonant_found_eighth\
    \ = false;\n    let mut vowel_found_ninth = false;\n    let mut consonant_found_ninth\
    \ = false;\n    let mut vowel_found_tenth = false;\n    let mut consonant_found_tenth\
    \ = false;\n    let mut vowel_found_eleventh = false;\n    let mut consonant_found_eleventh\
    \ = false;\n    let mut vowel_found_twelfth = false;\n    let mut consonant_found_twelfth\
    \ = false;\n    let mut vowel_found_thirteenth = false;\n    let mut consonant_found_thirteenth\
    \ = false;\n    let mut vowel_found_fourteenth = false;\n    let mut consonant_found_fourteenth\
    \ = false;\n    let mut vowel_found_fifteenth = false;\n    let mut conson\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphbijmvps.rs:47:19\n   |\n\
    47 |     let mut conson\n   |                   ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmphbijmvps.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel_index = 0;\n    let mut\
    \ last_consonant_index = 0;\n    for (i, c) in word.chars().enumerate() {\n  \
    \      if vowels.contains(&c) {\n            last_vowel_index = i;\n        }\
    \ else {\n            last_consonant_index = i;\n        }\n        if last_vowel_index\
    \ > last_consonant_index {\n            result = word[last_vowel_index..].to_string();\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ogurt\"`,\n right: `\"u\"`', /tmp/tmpb6fpsp12.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut index\
    \ = word.len() - 1;\n    let mut vowel_index = 0;\n    let mut vowel_distance\
    \ = 0;\n    let mut consonant_count = 0;\n    let mut vowel_count = 0;\n    let\
    \ mut vowel_flag = false;\n    let mut consonant_flag = false;\n    let mut vowel_found\
    \ = false;\n    let mut consonant_found = false;\n    let mut vowel_index_found\
    \ = false;\n    let mut consonant_index_found = false;\n    let mut vowel_index_found_flag\
    \ = false;\n    let mut consonant_index_found_flag = false;\n    let mut vowel_index_found_flag_2\
    \ = false;\n    let mut consonant_index_found_flag_2 = false;\n    let mut vowel_index_found_flag_3\
    \ = false;\n    let mut consonant_index_found_flag_3 = false;\n    let mut vowel_index_found_flag_4\
    \ = false;\n    let mut consonant_index_found_flag_4 = false;\n    let mut vowel_index_found_flag_5\
    \ = false;\n    let mut consonant_index_found_flag_5 = false;\n    let mut vowel_index_found_flag_6\
    \ = false;\n    let mut consonant_index_found_flag_6 = false;\n    let mut vowel_index_found_flag_7\
    \ = false;\n    let mut consonant_index_found_flag_7 = false;\n    let mut vowel_index_found_flag_8\
    \ = false;\n    let mut consonant_index_found_flag_8 = false;\n    let mut vowel_index_found_flag_9\
    \ = false;\n    let mut consonant_index_found_flag_9 = false;\n    let mut vowel_index_found_flag_10\
    \ = false;\n    let mut consonant_index_found_flag_10 = false;\n    let mut vowel_index_found_flag_11\
    \ = false;\n    let mut consonant_index_found_flag_11 = false;\n    let mut vowel_index_found_flag_12\
    \ = false;\n    let mut consonant\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxdq_ggzu.rs:43:22\n   |\n\
    43 |     let mut consonant\n   |                      ^ help: add `;` here\n44\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxdq_ggzu.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel_index\
    \ = 0;\n    let mut last_consonant_index = 0;\n    let mut last_char_is_vowel\
    \ = false;\n    let mut last_char_is_consonant = false;\n    let mut last_char_is_vowel_index\
    \ = 0;\n    let mut last_char_is_consonant_index = 0;\n    let mut last_char_is_vowel_index_temp\
    \ = 0;\n    let mut last_char_is_consonant_index_temp = 0;\n    let mut last_char_is_vowel_index_temp_temp\
    \ = 0;\n    let mut last_char_is_consonant_index_temp_temp = 0;\n    let mut last_char_is_vowel_index_temp_temp_temp\
    \ = 0;\n    let mut last_char_is_consonant_index_temp_temp_temp = 0;\n    let\
    \ mut last_char_is_vowel_index_temp_temp_temp_temp = 0;\n    let mut last_char_is_consonant_index_temp_temp_temp_temp\
    \ = 0;\n    let mut last_char_is_vowel_index_temp_temp_temp_temp_temp = 0;\n \
    \   let mut last_char_is_consonant_index_temp_temp_temp_temp_temp = 0;\n    let\
    \ mut last_char_is_vowel_index_temp_temp_temp_temp_temp_temp = 0;\n    let mut\
    \ last_char_is_consonant_index_temp_temp_temp_temp_temp_temp = 0;\n    let mut\
    \ last_char_is_vowel_index_temp_temp_temp_temp_temp_temp_temp = 0;\n    let mut\
    \ last_char_is_consonant_index_temp_temp_temp_temp_temp_temp_temp = 0;\n    let\
    \ mut last_char_is_vowel_index_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n\
    \    let mut last_char_\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdcghy090.rs:30:23\n   |\n\
    30 |     let mut last_char_\n   |                       ^ help: add `;` here\n\
    31 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdcghy090.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut index = word.len() - 1;\n    let mut\
    \ prev_is_vowel = false;\n    while index >= 0 {\n        let c = word.chars().nth(index).unwrap();\n\
    \        if vowels.contains(&c) {\n            if prev_is_vowel {\n          \
    \      break;\n            } else {\n                result.push(c);\n       \
    \         prev_is_vowel = true;\n            }\n        } else {\n           \
    \ prev_is_vowel = false;\n        }\n        index -= 1;\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp4sjckmbz.rs:24:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_distance = word.len();\n    let mut last_consonant_index = word.len();\n\
    \    for (i, c) in word.chars().enumerate() {\n        if c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' {\n            if i > last_consonant_index\
    \ {\n                if i - last_consonant_index < closest_vowel_distance {\n\
    \                    closest_vowel = c.to_string();\n                    closest_vowel_distance\
    \ = i - last_consonant_index;\n                }\n            }\n        } else\
    \ {\n            last_consonant_index = i;\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpzdxye5ag.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_char = ' ';\n    for\
    \ (i, c) in word.chars().enumerate() {\n        if c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u' {\n            last_vowel = i;\n        } else {\n\
    \            last_consonant = i;\n        }\n        if last_vowel > last_consonant\
    \ && last_char != c {\n            result = c.to_string();\n        }\n      \
    \  last_char = c;\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp5fbz2j_s.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut index\
    \ = word.len() - 1;\n    let mut found_consonant = false;\n    let mut found_vowel\
    \ = false;\n    while index >= 0 {\n        let c = word.chars().nth(index).unwrap();\n\
    \        if !found_consonant && !is_vowel(c) {\n            found_consonant =\
    \ true;\n        } else if found_consonant && is_vowel(c) {\n            result.push(c);\n\
    \            found_vowel = true;\n            break;\n        }\n        index\
    \ -= 1;\n    }\n    if !found_vowel {\n        result = String::new();\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp2ff0dpfc.rs:14:33\n\
    \   |\n14 |         if !found_consonant && !is_vowel(c) {\n   |              \
    \                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_vowel` in this scope\n  --> /tmp/tmp2ff0dpfc.rs:16:38\n   |\n16\
    \ |         } else if found_consonant && is_vowel(c) {\n   |                 \
    \                     ^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut last_consonant = word.len();\n \
    \   let mut last_vowel = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if is_vowel(c) {\n            if i > last_consonant {\n         \
    \       if i - last_consonant < closest_distance {\n                    closest_distance\
    \ = i - last_consonant;\n                    closest_vowel = c.to_string();\n\
    \                }\n            }\n            last_vowel = i;\n        } else\
    \ {\n            if i > last_vowel {\n                if i - last_vowel < closest_distance\
    \ {\n                    closest_distance = i - last_vowel;\n                \
    \    closest_vowel = c.to_string();\n                }\n            }\n      \
    \      last_consonant = i;\n        }\n    }\n    closest_vowel\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp5yss7pfy.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ last_consonant = String::new();\n    let mut last_vowel = String::new();\n \
    \   let mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n   \
    \ let mut vowel_index = 0;\n    let mut consonant_index = 0;\n    let mut vowel_found\
    \ = false;\n    let mut consonant_found = false;\n    let mut vowel_distance =\
    \ 0;\n    let mut consonant_distance = 0;\n    let mut distance = 0;\n    let\
    \ mut closest_distance = 0;\n    let mut closest_vowel_index = 0;\n    let mut\
    \ closest_consonant_index = 0;\n    let mut vowel_count = 0;\n    let mut consonant_count\
    \ = 0;\n    let mut vowel_consonant_distance = 0;\n    let mut closest_vowel_consonant_distance\
    \ = 0;\n    let mut vowel_consonant_distance_found = false;\n    let mut closest_vowel_consonant_distance_found\
    \ = false;\n    let mut vowel_consonant_distance_index = 0;\n    let mut closest_vowel_consonant_distance_index\
    \ = 0;\n    let mut vowel_consonant_distance_count = 0;\n    let mut closest_vowel_consonant_distance_count\
    \ = 0;\n    let mut vowel_consonant_distance_index_found = false;\n    let mut\
    \ closest_vowel_consonant_distance_index_found = false;\n    let mut vowel_consonant_distance_index_count\
    \ = 0;\n    let mut closest_vowel_consonant_distance_index_count = 0;\n    let\
    \ mut vowel_consonant_distance_index_found_count = 0;\n    let mut closest_vowel_consonant_distance_index_found_count\
    \ = 0;\n    let mut vowel_consonant_distance_index_found_count_found = false;\n\
    \    let mut closest_vowel_consonant_distance_index_found_count_found = false;\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmplvqyfb18.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_index = word.len();\n    let mut last_consonant_index = word.len();\n\
    \    for (i, c) in word.chars().enumerate() {\n        if c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' {\n            if i > last_consonant_index\
    \ {\n                if i - last_consonant_index < closest_vowel_index {\n   \
    \                 closest_vowel = c.to_string();\n                    closest_vowel_index\
    \ = i - last_consonant_index;\n                }\n            }\n        } else\
    \ {\n            last_consonant_index = i;\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpm5iag33w.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = String::new();\n    let mut last_consonant = String::new();\n    let mut last_vowel_index\
    \ = 0;\n    let mut last_consonant_index = 0;\n    let mut index = 0;\n    for\
    \ c in word.chars() {\n        if is_vowel(c) {\n            last_vowel = c.to_string();\n\
    \            last_vowel_index = index;\n        } else {\n            last_consonant\
    \ = c.to_string();\n            last_consonant_index = index;\n        }\n   \
    \     index += 1;\n    }\n    if last_vowel_index > last_consonant_index {\n \
    \       result = last_vowel;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpujgbme05.rs:15:12\n\
    \   |\n15 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_char = ' ';\n    for\
    \ (i, c) in word.chars().enumerate() {\n        if is_vowel(c) {\n           \
    \ last_vowel = i;\n        } else {\n            last_consonant = i;\n       \
    \ }\n        if last_vowel < last_consonant {\n            result = word[last_vowel..last_consonant].to_string();\n\
    \        }\n        last_char = c;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpn527u48n.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_vowel_index = 0;\n \
    \   let mut last_consonant_index = 0;\n    let mut index = 0;\n    for c in word.chars()\
    \ {\n        if is_vowel(c) {\n            last_vowel = c as u8;\n           \
    \ last_vowel_index = index;\n        } else {\n            last_consonant = c\
    \ as u8;\n            last_consonant_index = index;\n        }\n        index\
    \ += 1;\n    }\n    if last_vowel_index > last_consonant_index {\n        result.push(last_vowel\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp559276v9.rs:15:12\n\
    \   |\n15 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ last_consonant = String::new();\n    let mut last_vowel = String::new();\n \
    \   let mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n   \
    \ let mut vowel_index = 0;\n    let mut consonant_index = 0;\n    let mut vowel_found\
    \ = false;\n    let mut consonant_found = false;\n    let mut vowel_distance =\
    \ 0;\n    let mut consonant_distance = 0;\n    let mut distance = 0;\n    let\
    \ mut vowel_distance_index = 0;\n    let mut consonant_distance_index = 0;\n \
    \   let mut distance_index = 0;\n    let mut vowel_distance_found = false;\n \
    \   let mut consonant_distance_found = false;\n    let mut distance_found = false;\n\
    \    let mut vowel_distance_index_found = false;\n    let mut consonant_distance_index_found\
    \ = false;\n    let mut distance_index_found = false;\n    let mut vowel_distance_index_found_first\
    \ = false;\n    let mut consonant_distance_index_found_first = false;\n    let\
    \ mut distance_index_found_first = false;\n    let mut vowel_distance_index_found_second\
    \ = false;\n    let mut consonant_distance_index_found_second = false;\n    let\
    \ mut distance_index_found_second = false;\n    let mut vowel_distance_index_found_third\
    \ = false;\n    let mut consonant_distance_index_found_third = false;\n    let\
    \ mut distance_index_found_third = false;\n    let mut vowel_distance_index_found_fourth\
    \ = false;\n    let mut consonant_distance_index_found_fourth = false;\n    let\
    \ mut distance_index_found_fourth = false;\n    let mut vowel_distance_index_found_fifth\
    \ = false;\n    let mut consonant_distance_index_found_fifth = false;\n    let\
    \ mut distance_index_found_fifth = false;\n    let mut vowel_distance_index_found_sixth\
    \ = false;\n    let mut consonant_distance\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpecm8hl8o.rs:45:31\n   |\n\
    45 |     let mut consonant_distance\n   |                               ^ help:\
    \ add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpecm8hl8o.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String) ->\
    \ String {\n  |    -----------------                  ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut prev_is_consonant = false;\n   \
    \ for (i, c) in word.chars().enumerate() {\n        if is_vowel(c) {\n       \
    \     if prev_is_consonant {\n                if i < closest_distance {\n    \
    \                closest_distance = i;\n                    closest_vowel = c.to_string();\n\
    \                }\n            }\n            prev_is_consonant = false;\n  \
    \      } else {\n            prev_is_consonant = true;\n        }\n    }\n   \
    \ closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp33kacfux.rs:12:12\n\
    \   |\n12 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_index = word.len();\n    for (i, c) in word.chars().enumerate().rev()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \           if i < closest_vowel_index {\n                closest_vowel_index\
    \ = i;\n                closest_vowel = c.to_string();\n            }\n      \
    \  }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmpxthlquuo.rs:10:44\n   |\n10 |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n   |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmpxthlquuo.rs:10:19\n    |\n10  |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel_index = 0;\n    let mut\
    \ last_consonant_index = 0;\n    for (index, letter) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&letter) {\n            last_vowel_index = index;\n\
    \        } else {\n            last_consonant_index = index;\n        }\n    \
    \    if last_vowel_index > last_consonant_index {\n            result = word[last_vowel_index..last_vowel_index\
    \ + 1].to_string();\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpe1mohsfa.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut last_consonant = 0;\n    for (i,\
    \ c) in word.chars().enumerate() {\n        if c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' {\n            if i - last_consonant < closest_distance\
    \ {\n                closest_distance = i - last_consonant;\n                closest_vowel\
    \ = c.to_string();\n            }\n        } else {\n            last_consonant\
    \ = i;\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpxi5o7_nd.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_pos = 0;\n    let mut vowel_dist = word.len();\n\
    \    let mut prev_consonant = false;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if is_vowel(c) {\n            if prev_consonant && i < vowel_dist\
    \ {\n                vowel_pos = i;\n                vowel_dist = i;\n       \
    \     }\n            prev_consonant = false;\n        } else {\n            prev_consonant\
    \ = true;\n        }\n    }\n    if vowel_dist == word.len() {\n        return\
    \ String::new();\n    }\n    word.chars().nth(vowel_pos).unwrap().to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmplhmnbc3k.rs:12:12\n\
    \   |\n12 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = String::new();\n    let mut last_consonant = String::new();\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    for c in word.chars() {\n        if vowels.contains(&c)\
    \ {\n            last_vowel = c.to_string();\n        } else {\n            last_consonant\
    \ = c.to_string();\n        }\n        if last_vowel != \"\" && last_consonant\
    \ != \"\" {\n            result = last_vowel.clone();\n            break;\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp3tcia7jq.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_consonant\
    \ = false;\n    let mut last_vowel = false;\n    let mut last_vowel_index = 0;\n\
    \    let mut last_consonant_index = 0;\n    let mut index = 0;\n    for c in word.chars()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \           if last_consonant {\n                if result.is_empty() {\n    \
    \                result.push(c);\n                    last_vowel_index = index;\n\
    \                } else {\n                    if index - last_consonant_index\
    \ < last_vowel_index - last_consonant_index {\n                        result.clear();\n\
    \                        result.push(c);\n                        last_vowel_index\
    \ = index;\n                    }\n                }\n            }\n        \
    \    last_vowel = true;\n        } else {\n            if last_vowel {\n     \
    \           last_consonant_index = index;\n            }\n            last_consonant\
    \ = true;\n        }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpj_fm_7_m.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_vowel_distance = word.len();\n\
    \    let mut last_consonant_index = 0;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            if i - last_consonant_index\
    \ < closest_vowel_distance {\n                closest_vowel = c.to_string();\n\
    \                closest_vowel_distance = i - last_consonant_index;\n        \
    \    }\n        } else {\n            last_consonant_index = i;\n        }\n \
    \   }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpuh3ta2_w.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = String::new();\n    let mut last_consonant = String::new();\n    let mut last_char\
    \ = String::new();\n    let mut last_last_char = String::new();\n    let mut last_last_last_char\
    \ = String::new();\n    let mut last_last_last_last_char = String::new();\n  \
    \  let mut last_last_last_last_last_char = String::new();\n    let mut last_last_last_last_last_last_char\
    \ = String::new();\n    let mut last_last_last_last_last_last_last_char = String::new();\n\
    \    let mut last_last_last_last_last_last_last_last_char = String::new();\n \
    \   let mut last_last_last_last_last_last_last_last_last_char = String::new();\n\
    \    let mut last_last_last_last_last_last_last_last_last_last_char = String::new();\n\
    \    let mut last_last_last_last_last_last_last_last_last_last_last_char = String::new();\n\
    \    let mut last_last_last_last_last_last_last_last_last_last_last_last_char\
    \ = String::new();\n    let mut last_last_last_last_last_last_last_last_last_last_last_last_last_char\
    \ = String::new();\n    let mut last_last_last_last_last_last_last_last_last_last_last_last_last_last_char\
    \ = String::new();\n    let mut last_last_last_last_last_last_last_last_last_last_last_last_last_last_last_char\
    \ = String::new();\n    let mut last_last_last_last_last_last_last_last_last_last_last_last_last_last_last_last_char\
    \ = String::new();\n    let mut last_last_last_last_last_last_last_last_last_last_last_last_last_last_last_last_last_char\
    \ = String::\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1eyv22sm.rs:28:1\n\
    \   |\n28 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut last_consonant = word.len();\n \
    \   let mut first_vowel = word.len();\n    let mut vowels = String::from(\"aeiou\"\
    );\n    let mut consonants = String::from(\"bcdfghjklmnpqrstvwxyz\");\n    for\
    \ (i, c) in word.chars().enumerate() {\n        if vowels.contains(c) {\n    \
    \        if i < first_vowel {\n                first_vowel = i;\n            }\n\
    \            if i - last_consonant < closest_distance {\n                closest_distance\
    \ = i - last_consonant;\n                closest_vowel = c.to_string();\n    \
    \        }\n        } else if consonants.contains(c) {\n            last_consonant\
    \ = i;\n        }\n    }\n    if closest_distance == word.len() || closest_distance\
    \ == first_vowel {\n        String::new()\n    } else {\n        closest_vowel\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpecmw17nm.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_vowel_index = 0;\n \
    \   let mut closest_vowel_distance = 0;\n    let mut last_consonant_index = 0;\n\
    \    let mut vowel_found = false;\n    for (index, character) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&character) {\n            if vowel_found {\n\
    \                if index - last_consonant_index < closest_vowel_distance {\n\
    \                    closest_vowel_distance = index - last_consonant_index;\n\
    \                    closest_vowel_index = index;\n                }\n       \
    \     } else {\n                vowel_found = true;\n                closest_vowel_distance\
    \ = index - last_consonant_index;\n                closest_vowel_index = index;\n\
    \            }\n        } else {\n            last_consonant_index = index;\n\
    \        }\n    }\n    if vowel_found {\n        closest_vowel.push(word.chars().nth(closest_vowel_index).unwrap());\n\
    \    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp75zi8sdv.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_vowel_index = 0;\n \
    \   let mut last_consonant_index = 0;\n    let mut i = 0;\n    for c in word.chars()\
    \ {\n        if is_vowel(c) {\n            last_vowel = i;\n            last_vowel_index\
    \ = i;\n        } else {\n            last_consonant = i;\n            last_consonant_index\
    \ = i;\n        }\n        i += 1;\n    }\n    if last_vowel_index > last_consonant_index\
    \ {\n        for c in word.chars() {\n            if is_vowel(c) {\n         \
    \       result.push(c);\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmposnxhksp.rs:15:12\n\
    \   |\n15 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmposnxhksp.rs:26:16\n   |\n26 |             if is_vowel(c) {\n   |   \
    \             ^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = String::new();\n    let mut last_consonant = String::new();\n    let mut last_char\
    \ = String::new();\n    let mut last_char_is_vowel = false;\n    let mut last_char_is_consonant\
    \ = false;\n    let mut last_char_is_vowel_or_consonant = false;\n    let mut\
    \ last_char_is_vowel_or_consonant_or_empty = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_punctuation\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_punctuation_or_space\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_punctuation_or_space_or_digit\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_punctuation_or_space_or_digit_or_letter\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_punctuation_or_space_or_digit_or_letter_or_symbol\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_punctuation_or_space_or_digit_or_letter_or_symbol_or_whitespace\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_punctuation_or_space_or_digit_or_letter_or_symbol_or_whitespace_or_control\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_punctuation_or_space_or_digit_or_letter_or_symbol_or_whitespace_or_control_or_formfeed\
    \ = false;\n    let\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpxg1azg5j.rs:25:1\n  \
    \ |\n25 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_consonant\
    \ = 0;\n    let mut last_vowel = 0;\n    let mut last_vowel_index = 0;\n    let\
    \ mut last_consonant_index = 0;\n    let mut index = 0;\n    for c in word.chars()\
    \ {\n        match c {\n            'a' | 'e' | 'i' | 'o' | 'u' => {\n       \
    \         if last_consonant_index != 0 {\n                    if last_vowel_index\
    \ == 0 {\n                        last_vowel_index = index;\n                \
    \        last_vowel = index - last_consonant_index;\n                    } else\
    \ {\n                        if index - last_consonant_index < last_vowel {\n\
    \                            last_vowel_index = index;\n                     \
    \       last_vowel = index - last_consonant_index;\n                        }\n\
    \                    }\n                }\n            }\n            _ => {\n\
    \                if last_vowel_index != 0 {\n                    if last_consonant_index\
    \ == 0 {\n                        last_consonant_index = index;\n            \
    \            last_consonant = index - last_vowel_index;\n                    }\
    \ else {\n                        if index - last_vowel_index < last_consonant\
    \ {\n                            last_consonant_index = index;\n             \
    \               last_consonant = index - last_vowel_index;\n                 \
    \       }\n                    }\n                }\n            }\n        }\n\
    \        index += 1;\n    }\n    if last_vowel_index != 0 {\n        result =\
    \ word[last_vowel_index..last_vowel_index + 1].to_string();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpyfj1zla8.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel_index\
    \ = 0;\n    let mut last_consonant_index = 0;\n    let mut last_vowel_char = '\
    \ ';\n    let mut last_consonant_char = ' ';\n    let mut last_char = ' ';\n \
    \   let mut is_last_char_vowel = false;\n    let mut is_last_char_consonant =\
    \ false;\n    let mut is_last_char_vowel_found = false;\n    let mut is_last_char_consonant_found\
    \ = false;\n    let mut is_last_char_consonant_found_first = false;\n    let mut\
    \ is_last_char_consonant_found_second = false;\n    let mut is_last_char_vowel_found_first\
    \ = false;\n    let mut is_last_char_vowel_found_second = false;\n    let mut\
    \ is_last_char_vowel_found_third = false;\n    let mut is_last_char_vowel_found_fourth\
    \ = false;\n    let mut is_last_char_vowel_found_fifth = false;\n    let mut is_last_char_vowel_found_sixth\
    \ = false;\n    let mut is_last_char_vowel_found_seventh = false;\n    let mut\
    \ is_last_char_vowel_found_eighth = false;\n    let mut is_last_char_vowel_found_ninth\
    \ = false;\n    let mut is_last_char_vowel_found_tenth = false;\n    let mut is_last_char_vowel_found_eleventh\
    \ = false;\n    let mut is_last_char_vowel_found_twelfth = false;\n    let mut\
    \ is_last_char_vowel_found_thirteenth = false;\n    let mut is_last_char_vowel_found_fourteenth\
    \ = false;\n    let mut is_last_char_vowel_found_fifteenth = false;\n    let mut\
    \ is_last_char_vowel_\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpiq682zxx.rs:35:32\n   |\n\
    35 |     let mut is_last_char_vowel_\n   |                                ^ help:\
    \ add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpiq682zxx.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String) ->\
    \ String {\n  |    -----------------                  ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut index\
    \ = word.len() - 1;\n    let mut is_consonant = false;\n    let mut is_vowel =\
    \ false;\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    while index >=\
    \ 0 {\n        if vowels.contains(&word.chars().nth(index).unwrap()) {\n     \
    \       if is_consonant {\n                result.push(word.chars().nth(index).unwrap());\n\
    \                break;\n            }\n            is_vowel = true;\n       \
    \ } else {\n            if is_vowel {\n                is_consonant = true;\n\
    \            }\n        }\n        index -= 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpeh6y06mx.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut closest_vowel\
    \ = String::new();\n    let mut closest_distance = word.len();\n    for (i, c)\
    \ in word.chars().enumerate() {\n        if vowels.contains(c) {\n           \
    \ let mut distance = word.len() - i;\n            if i > 0 {\n               \
    \ distance -= 1;\n            }\n            if distance < closest_distance {\n\
    \                closest_distance = distance;\n                closest_vowel =\
    \ c.to_string();\n            }\n        }\n    }\n    closest_vowel\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpwudx6hhu.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = String::new();\n    let mut last_consonant = String::new();\n    let mut found\
    \ = false;\n    for c in word.chars() {\n        if is_vowel(c) {\n          \
    \  last_vowel = c.to_string();\n        } else {\n            last_consonant =\
    \ c.to_string();\n            if !last_vowel.is_empty() {\n                found\
    \ = true;\n                break;\n            }\n        }\n    }\n    if found\
    \ {\n        result = last_vowel;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpky_j5644.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = String::new();\n    let mut last_consonant = String::new();\n    let mut last_char\
    \ = String::new();\n    let mut last_char_is_vowel = false;\n    let mut last_char_is_consonant\
    \ = false;\n    let mut last_char_is_vowel_or_consonant = false;\n    let mut\
    \ last_char_is_vowel_or_consonant_or_empty = false;\n    let mut last_char_is_consonant_or_empty\
    \ = false;\n    let mut last_char_is_vowel_or_empty = false;\n    let mut last_char_is_empty\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_start = false;\n\
    \    let mut last_char_is_consonant_or_empty_or_start = false;\n    let mut last_char_is_vowel_or_empty_or_start\
    \ = false;\n    let mut last_char_is_empty_or_start = false;\n    let mut last_char_is_start\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_start_or_end\
    \ = false;\n    let mut last_char_is_consonant_or_empty_or_start_or_end = false;\n\
    \    let mut last_char_is_vowel_or_empty_or_start_or_end = false;\n    let mut\
    \ last_char_is_empty_or_start_or_end = false;\n    let mut last_char_is_start_or_end\
    \ = false;\n    let mut last_char_is_end = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_start_or_end_or_end\
    \ = false;\n    let mut last_char_is_consonant_or_empty_or_start_or_end_or_end\
    \ = false;\n    let mut\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpdxht1qy9.rs:33:1\n\
    \   |\n33 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_char = ' ';\n    for\
    \ c in word.chars() {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u' {\n            last_vowel = last_consonant;\n        } else {\n\
    \            last_consonant += 1;\n        }\n        if last_consonant > last_vowel\
    \ && last_char != ' ' {\n            result = c.to_string();\n        }\n    \
    \    last_char = c;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"t\"`,\n right: `\"u\"`', /tmp/tmpaxuwnag8.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_index = word.len();\n\
    \    for (i, c) in word.chars().enumerate().rev() {\n        if vowels.contains(&c)\
    \ {\n            if closest_index - i > 1 {\n                closest_index = i;\n\
    \                closest_vowel = c.to_string();\n            }\n        }\n  \
    \  }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmpzz15pdz7.rs:11:44\n   |\n11 |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n   |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmpzz15pdz7.rs:11:19\n    |\n11  |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev_char\
    \ = ' ';\n    let mut prev_vowel = ' ';\n    for c in word.chars().rev() {\n \
    \       if is_vowel(c) {\n            if prev_char != ' ' && !is_vowel(prev_char)\
    \ {\n                result = prev_vowel.to_string();\n                break;\n\
    \            }\n            prev_vowel = c;\n        }\n        prev_char = c;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp79yx7h3x.rs:12:12\n\
    \   |\n12 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmp79yx7h3x.rs:13:37\n   |\n13 |             if prev_char != ' ' && !is_vowel(prev_char)\
    \ {\n   |                                     ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel_index\
    \ = 0;\n    let mut last_consonant_index = 0;\n    let mut last_vowel_char = '\
    \ ';\n    let mut last_consonant_char = ' ';\n    let mut is_vowel = false;\n\
    \    let mut is_consonant = false;\n    let mut is_first_vowel = false;\n    let\
    \ mut is_first_consonant = false;\n    let mut is_last_vowel = false;\n    let\
    \ mut is_last_consonant = false;\n    let mut is_first_char = true;\n    let mut\
    \ is_last_char = false;\n    let mut is_first_vowel_found = false;\n    let mut\
    \ is_first_consonant_found = false;\n    let mut is_last_vowel_found = false;\n\
    \    let mut is_last_consonant_found = false;\n    let mut is_first_vowel_consonant_found\
    \ = false;\n    let mut is_last_vowel_consonant_found = false;\n    let mut is_first_consonant_vowel_found\
    \ = false;\n    let mut is_last_consonant_vowel_found = false;\n    let mut is_first_vowel_consonant_vowel_found\
    \ = false;\n    let mut is_last_vowel_consonant_vowel_found = false;\n    let\
    \ mut is_first_consonant_vowel_consonant_found = false;\n    let mut is_last_consonant_vowel_consonant_found\
    \ = false;\n    let mut is_first_vowel_consonant_vowel_consonant_found = false;\n\
    \    let mut is_last_vowel_consonant_vowel_consonant_found = false;\n    let mut\
    \ is_first_consonant_vowel_consonant_vowel_found = false;\n    let mut is_last_consonant_vowel_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9oiwmq7h.rs:36:37\n   |\n\
    36 |     let mut is_last_consonant_vowel_\n   |                              \
    \       ^ help: add `;` here\n37 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp9oiwmq7h.rs:7:39\n  |\n7 | fn get_closest_vowel(word:\
    \ String) -> String {\n  |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel_index\
    \ = 0;\n    let mut last_consonant_index = 0;\n    let mut last_vowel_found =\
    \ false;\n    let mut last_consonant_found = false;\n    let mut last_vowel_char\
    \ = ' ';\n    let mut last_consonant_char = ' ';\n    let mut last_char = ' ';\n\
    \    let mut last_char_is_vowel = false;\n    let mut last_char_is_consonant =\
    \ false;\n    let mut last_char_is_vowel_or_consonant = false;\n    let mut last_char_is_vowel_or_consonant_or_space\
    \ = false;\n    let mut last_char_is_space = false;\n    let mut last_char_is_space_or_vowel\
    \ = false;\n    let mut last_char_is_space_or_consonant = false;\n    let mut\
    \ last_char_is_space_or_vowel_or_consonant = false;\n    let mut last_char_is_space_or_vowel_or_consonant_or_space\
    \ = false;\n    let mut last_char_is_space_or_vowel_or_consonant_or_space_or_vowel\
    \ = false;\n    let mut last_char_is_space_or_vowel_or_consonant_or_space_or_consonant\
    \ = false;\n    let mut last_char_is_space_or_vowel_or_consonant_or_space_or_vowel_or_consonant\
    \ = false;\n    let mut last_char_is_space_or_vowel_or_consonant_or_space_or_vowel_or_consonant_or_space\
    \ = false;\n    let mut last_char_is_space_or_vowel_or_consonant_or_space_or_vowel_or_consonant_or_space_or_vowel\
    \ = false;\n    let\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfzuuvvbu.rs:31:1\n  \
    \ |\n31 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut index = word.len();\n    let mut vowel_index\
    \ = 0;\n    let mut vowel_found = false;\n    let mut last_vowel_index = 0;\n\
    \    let mut last_vowel_found = false;\n    let vowels = vec!['a', 'e', 'i', 'o',\
    \ 'u'];\n    let mut last_char = ' ';\n    let mut last_vowel = ' ';\n    for\
    \ (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c) {\n   \
    \         last_vowel = c;\n            last_vowel_index = i;\n            last_vowel_found\
    \ = true;\n        } else {\n            if last_vowel_found && !vowel_found {\n\
    \                vowel_index = last_vowel_index;\n                vowel_found\
    \ = true;\n            }\n            last_vowel_found = false;\n        }\n \
    \       if !vowels.contains(&c) && !vowels.contains(&last_char) {\n          \
    \  index = i;\n            break;\n        }\n        last_char = c;\n    }\n\
    \    if vowel_found {\n        return word[vowel_index..index].to_string();\n\
    \    }\n    return \"\".to_string();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpwqk2o458.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel = 0;\n    let mut last_consonant\
    \ = 0;\n    let mut last_char = ' ';\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            last_vowel = i;\n        }\
    \ else {\n            if last_char != ' ' && vowels.contains(&last_char) {\n \
    \               last_consonant = i;\n            }\n        }\n        last_char\
    \ = c;\n    }\n    if last_consonant > last_vowel {\n        result = word[last_vowel..last_consonant].to_string();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpxd5m_1v2.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut word = word.chars().collect::<Vec<char>>();\n\
    \    word.reverse();\n    let mut result = String::new();\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut found_vowel = false;\n    for (i, c) in word.iter().enumerate()\
    \ {\n        if vowels.contains(c) {\n            found_vowel = true;\n      \
    \      result.push(*c);\n        } else if found_vowel {\n            break;\n\
    \        }\n    }\n    result.chars().rev().collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ea\"`,\n right: `\"\"`', /tmp/tmpljrypcvj.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut index\
    \ = word.len() - 1;\n    let mut found_consonant = false;\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    while index >= 0 {\n        if vowels.contains(&word.chars().nth(index).unwrap())\
    \ {\n            if found_consonant {\n                result.push(word.chars().nth(index).unwrap());\n\
    \                break;\n            }\n        } else {\n            found_consonant\
    \ = true;\n        }\n        index -= 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpqbmzh7_q.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel_index = 0;\n    let mut\
    \ last_consonant_index = 0;\n    for (i, c) in word.chars().enumerate() {\n  \
    \      if vowels.contains(&c) {\n            last_vowel_index = i;\n        }\
    \ else {\n            last_consonant_index = i;\n        }\n        if last_vowel_index\
    \ > last_consonant_index {\n            result = word[last_vowel_index..=last_vowel_index].to_string();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpj_bdh4l3.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowel_index\
    \ = 0;\n    let mut consonant_index = 0;\n    let mut vowel_found = false;\n \
    \   let mut consonant_found = false;\n    let mut vowel_distance = 0;\n    let\
    \ mut consonant_distance = 0;\n    let mut distance = 0;\n    let mut min_distance\
    \ = 0;\n    let mut min_index = 0;\n    let mut min_distance_found = false;\n\
    \    let mut vowel_index_found = false;\n    let mut consonant_index_found = false;\n\
    \    let mut vowel_index_distance = 0;\n    let mut consonant_index_distance =\
    \ 0;\n    let mut vowel_index_min_distance = 0;\n    let mut consonant_index_min_distance\
    \ = 0;\n    let mut vowel_index_min_index = 0;\n    let mut consonant_index_min_index\
    \ = 0;\n    let mut vowel_index_min_distance_found = false;\n    let mut consonant_index_min_distance_found\
    \ = false;\n    let mut vowel_index_distance_found = false;\n    let mut consonant_index_distance_found\
    \ = false;\n    let mut vowel_index_min_distance_found = false;\n    let mut consonant_index_min_distance_found\
    \ = false;\n    let mut vowel_index_min_index_found = false;\n    let mut consonant_index_min_index_found\
    \ = false;\n    let mut vowel_index_min_distance_found = false;\n    let mut consonant_index_min_distance_found\
    \ = false;\n    let mut vowel_index_min_index_found = false;\n    let mut consonant_index_min_index_found\
    \ = false;\n    let mut vowel_index_min_distance_found = false;\n    let mut consonant_index_min_distance_found\
    \ = false;\n    let mut vowel_index_min_index_found = false;\n    let mut consonant_index_min_index_found\
    \ = false;\n    let mut vowel_index_min\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb6jnj4nm.rs:45:28\n   |\n\
    45 |     let mut vowel_index_min\n   |                            ^ help: add\
    \ `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpb6jnj4nm.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String) ->\
    \ String {\n  |    -----------------                  ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_vowel_index = 0;\n \
    \   let mut last_consonant_index = 0;\n    let mut last_char = ' ';\n    let mut\
    \ index = 0;\n    for c in word.chars() {\n        if is_vowel(c) {\n        \
    \    last_vowel = c;\n            last_vowel_index = index;\n        } else {\n\
    \            last_consonant = c;\n            last_consonant_index = index;\n\
    \        }\n        if last_vowel != 0 && last_consonant != 0 && last_char !=\
    \ ' ' {\n            if last_vowel_index > last_consonant_index {\n          \
    \      result.push(last_vowel);\n                break;\n            }\n     \
    \   }\n        last_char = c;\n        index += 1;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpptoon6da.rs:16:12\n\
    \   |\n16 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpptoon6da.rs:17:26\n \
    \  |\n17 |             last_vowel = c;\n   |                          ^ expected\
    \ integer, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpptoon6da.rs:20:30\n\
    \   |\n20 |             last_consonant = c;\n   |                            \
    \  ^ expected integer, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpptoon6da.rs:25:29\n\
    \   |\n25 |                 result.push(last_vowel);\n   |                   \
    \          ^^^^^^^^^^ expected `char`, found integer\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel_index\
    \ = 0;\n    let mut last_consonant_index = 0;\n    let mut last_vowel_found =\
    \ false;\n    let mut last_consonant_found = false;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if is_vowel(c) {\n            last_vowel_index = i;\n           \
    \ last_vowel_found = true;\n        } else {\n            last_consonant_index\
    \ = i;\n            last_consonant_found = true;\n        }\n        if last_vowel_found\
    \ && last_consonant_found {\n            if last_vowel_index > last_consonant_index\
    \ {\n                result = word[last_vowel_index..last_vowel_index + 1].to_string();\n\
    \                break;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpsk2kejog.rs:14:12\n\
    \   |\n14 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut consonants = vec!['b', 'c', 'd',\
    \ 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x',\
    \ 'y', 'z'];\n    let mut word_vec: Vec<char> = word.chars().collect();\n    let\
    \ mut vowel_index = 0;\n    let mut consonant_index = 0;\n    let mut vowel_count\
    \ = 0;\n    let mut consonant_count = 0;\n    let mut vowel_index_vec = Vec::new();\n\
    \    let mut consonant_index_vec = Vec::new();\n    for i in (0..word_vec.len()).rev()\
    \ {\n        for j in 0..vowels.len() {\n            if word_vec[i] == vowels[j]\
    \ {\n                vowel_index = i;\n                vowel_count += 1;\n   \
    \             vowel_index_vec.push(vowel_index);\n            }\n        }\n \
    \       for k in 0..consonants.len() {\n            if word_vec[i] == consonants[k]\
    \ {\n                consonant_index = i;\n                consonant_count +=\
    \ 1;\n                consonant_index_vec.push(consonant_index);\n           \
    \ }\n        }\n    }\n    if vowel_count == 0 || consonant_count == 0 {\n   \
    \     return result;\n    }\n    let mut vowel_index_vec_len = vowel_index_vec.len();\n\
    \    let mut consonant_index_vec_len = consonant_index_vec.len();\n    for i in\
    \ 0..vowel_index_vec_len {\n        for j in 0..consonant_index_vec_len {\n  \
    \          if vowel_index_vec[i] > consonant_index_vec[j] {\n                result\
    \ = word_vec[vowel_index_vec[i]].to_string();\n                return result;\n\
    \            }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n   \
    \ assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"\
    most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n  \
    \  assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp0kgeewjq.rs:62:3\n\
    \   |\n7  | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n39 |     for i in\
    \ 0..vowel_index_vec_len {\n   |                                     - unclosed\
    \ delimiter\n40 |         for j in 0..consonant_index_vec_len {\n   |        \
    \                                     - this delimiter might not be properly closed...\n\
    ...\n45 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    62 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0kgeewjq.rs:39:5\n\
    \   |\n7  |   fn get_closest_vowel(word: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n39 | /     for i in 0..vowel_index_vec_len {\n40 | |         for j in 0..consonant_index_vec_len\
    \ {\n41 | |             if vowel_index_vec[i] > consonant_index_vec[j] {\n42 |\
    \ |                 result = word_vec[vowel_index_vec[i]].to_string();\n...  |\n\
    61 | |     assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    62 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel_index = 0;\n    let mut\
    \ last_consonant_index = 0;\n    for (i, c) in word.chars().enumerate() {\n  \
    \      if vowels.contains(&c) {\n            last_vowel_index = i;\n        }\
    \ else {\n            last_consonant_index = i;\n        }\n        if last_vowel_index\
    \ > last_consonant_index {\n            result = word[last_vowel_index..].to_string();\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ogurt\"`,\n right: `\"u\"`', /tmp/tmpb6fpsp12.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_distance = word.len();\n    let mut last_consonant_index = word.len();\n\
    \    for (i, c) in word.chars().enumerate() {\n        if c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' {\n            if i - last_consonant_index\
    \ < closest_vowel_distance {\n                closest_vowel = c.to_string();\n\
    \                closest_vowel_distance = i - last_consonant_index;\n        \
    \    }\n        } else {\n            last_consonant_index = i;\n        }\n \
    \   }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp8hu6_yl4.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_distance = word.len();\n\
    \    let mut last_consonant = 0;\n    for (i, c) in word.chars().enumerate() {\n\
    \        if vowels.contains(&c) {\n            if i - last_consonant < closest_distance\
    \ {\n                closest_distance = i - last_consonant;\n                closest_vowel\
    \ = c.to_string();\n            }\n        } else {\n            last_consonant\
    \ = i;\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpa53yltjd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut last_consonant = 0;\n    let mut\
    \ last_vowel = 0;\n    let mut last_char = ' ';\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \           if last_char != ' ' && last_char != 'a' && last_char != 'e' && last_char\
    \ != 'i' && last_char != 'o' && last_char != 'u' {\n                let distance\
    \ = i - last_consonant;\n                if distance < closest_distance {\n  \
    \                  closest_distance = distance;\n                    closest_vowel\
    \ = c.to_string();\n                }\n            }\n            last_vowel =\
    \ i;\n        } else {\n            if last_char != ' ' && last_char != 'a' &&\
    \ last_char != 'e' && last_char != 'i' && last_char != 'o' && last_char != 'u'\
    \ {\n                last_consonant = i;\n            }\n        }\n        last_char\
    \ = c;\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpc7if1ld8.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec!['a', 'e', 'i', 'o', 'u'];\n \
    \   let mut result = String::new();\n    let mut last_vowel_index = 0;\n    let\
    \ mut last_consonant_index = 0;\n    let mut last_vowel_char = ' ';\n    let mut\
    \ last_consonant_char = ' ';\n    let mut last_index = 0;\n    let mut last_char\
    \ = ' ';\n    let mut index = 0;\n    let mut char = ' ';\n    let mut is_vowel\
    \ = false;\n    let mut is_consonant = false;\n    let mut is_first_char = true;\n\
    \    let mut is_first_vowel = true;\n    let mut is_first_consonant = true;\n\
    \    let mut is_last_char = false;\n    let mut is_last_vowel = false;\n    let\
    \ mut is_last_consonant = false;\n    let mut is_last_vowel_found = false;\n \
    \   let mut is_last_consonant_found = false;\n    let mut is_last_char_found =\
    \ false;\n    let mut is_last_vowel_before_consonant = false;\n    let mut is_last_consonant_before_vowel\
    \ = false;\n    let mut is_last_char_before_vowel = false;\n    let mut is_last_char_before_consonant\
    \ = false;\n    let mut is_last_char_before_vowel_found = false;\n    let mut\
    \ is_last_char_before_consonant_found = false;\n    let mut is_last_vowel_before_consonant_found\
    \ = false;\n    let mut is_last_consonant_before_vowel_found = false;\n    let\
    \ mut is_last_vowel_before_consonant_found_first = false;\n    let mut is_last_consonant_before_vowel_found_first\
    \ = false;\n    let mut is_last_char_before_vowel_found_first = false;\n\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmw07rntz.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ last_vowel = String::new();\n    let mut last_consonant = String::new();\n \
    \   let mut last_char = String::new();\n    let mut closest_distance = 0;\n  \
    \  let mut current_distance = 0;\n    let mut is_vowel = false;\n    let mut is_consonant\
    \ = false;\n    let mut is_first_char = true;\n    let mut is_last_char = false;\n\
    \    let mut is_first_vowel = true;\n    let mut is_first_consonant = true;\n\
    \    let mut is_first_distance = true;\n    let mut is_closest_vowel = false;\n\
    \    let mut is_last_vowel = false;\n    let mut is_last_consonant = false;\n\
    \    let mut is_last_distance = false;\n    let mut is_current_distance = false;\n\
    \    let mut is_closest_distance = false;\n    let mut is_first_char_vowel = false;\n\
    \    let mut is_first_char_consonant = false;\n    let mut is_last_char_vowel\
    \ = false;\n    let mut is_last_char_consonant = false;\n    let mut is_last_char_consonant_vowel\
    \ = false;\n    let mut is_last_char_vowel_consonant = false;\n    let mut is_last_char_consonant_consonant\
    \ = false;\n    let mut is_last_char_vowel_vowel = false;\n    let mut is_last_char_consonant_vowel_consonant\
    \ = false;\n    let mut is_last_char_vowel_consonant_vowel = false;\n    let mut\
    \ is_last_char_consonant_vowel_vowel = false;\n    let mut is_last_char_vowel_vowel_consonant\
    \ = false;\n    let mut is_last_char_consonant_consonant_vowel = false;\n    let\
    \ mut\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpfc4jk3nn.rs:41:1\n\
    \   |\n41 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut last_consonant = word.len();\n \
    \   let mut last_vowel = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if is_vowel(c) {\n            last_vowel = i;\n            if last_consonant\
    \ < i {\n                let distance = i - last_consonant;\n                if\
    \ distance < closest_distance {\n                    closest_distance = distance;\n\
    \                    closest_vowel = c.to_string();\n                }\n     \
    \       }\n        } else {\n            last_consonant = i;\n        }\n    }\n\
    \    if last_vowel < last_consonant {\n        closest_vowel\n    } else {\n \
    \       String::new()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp8sl_1ex9.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut result = String::new();\n\
    \    let mut last_consonant = 0;\n    let mut last_vowel = 0;\n    for (i, c)\
    \ in word.chars().enumerate() {\n        if vowels.contains(c) {\n           \
    \ last_vowel = i;\n        } else {\n            last_consonant = i;\n       \
    \ }\n        if last_consonant > last_vowel {\n            result = word[last_vowel..last_consonant].to_string();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ur\"`,\n right: `\"u\"`', /tmp/tmpkbegyqr8.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_char = ' ';\n    for\
    \ (i, c) in word.chars().enumerate() {\n        if is_vowel(c) {\n           \
    \ last_vowel = i;\n        } else {\n            last_consonant = i;\n       \
    \ }\n        if last_vowel > last_consonant && last_consonant != 0 {\n       \
    \     result = word[last_vowel..=last_vowel].to_string();\n        }\n       \
    \ last_char = c;\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp1ydvrkjp.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut result = String::new();\n\
    \    let mut last_consonant = 0;\n    let mut last_vowel = 0;\n    for (i, c)\
    \ in word.chars().enumerate() {\n        if vowels.contains(c) {\n           \
    \ last_vowel = i;\n        } else {\n            last_consonant = i;\n       \
    \ }\n        if last_consonant > last_vowel {\n            result = word[last_vowel..last_consonant].to_string();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ur\"`,\n right: `\"u\"`', /tmp/tmpkbegyqr8.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_index = 0;\n    let mut index = 0;\n    let mut last_consonant_index\
    \ = 0;\n    let mut last_vowel_index = 0;\n    let mut found_vowel = false;\n\
    \    let mut found_consonant = false;\n    let mut found_vowel_after_consonant\
    \ = false;\n    let mut found_consonant_after_vowel = false;\n    let mut found_vowel_before_consonant\
    \ = false;\n    let mut found_consonant_before_vowel = false;\n    let mut found_vowel_after_consonant_before_consonant\
    \ = false;\n    let mut found_consonant_after_vowel_before_vowel = false;\n  \
    \  let mut found_vowel_after_consonant_before_vowel = false;\n    let mut found_consonant_after_vowel_before_consonant\
    \ = false;\n    let mut found_vowel_after_consonant_before_consonant_before_vowel\
    \ = false;\n    let mut found_consonant_after_vowel_before_consonant_before_consonant\
    \ = false;\n    let mut found_vowel_after_consonant_before_consonant_before_consonant\
    \ = false;\n    let mut found_consonant_after_vowel_before_consonant_before_vowel\
    \ = false;\n    let mut found_vowel_after_consonant_before_vowel_before_consonant\
    \ = false;\n    let mut found_consonant_after_vowel_before_vowel_before_vowel\
    \ = false;\n    let mut found_vowel_after_consonant_before_vowel_before_vowel\
    \ = false;\n    let mut found_consonant_after_vowel_before_vowel_before_consonant\
    \ = false;\n    let mut found_vowel_after_consonant_\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfd5qfaql.rs:31:41\n   |\n\
    31 |     let mut found_vowel_after_consonant_\n   |                          \
    \               ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpfd5qfaql.rs:7:39\n  |\n7 | fn get_closest_vowel(word:\
    \ String) -> String {\n  |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_vowel_index = word.len();\n\
    \    let mut last_consonant_index = 0;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            if i > last_consonant_index\
    \ && i - last_consonant_index < closest_vowel_index {\n                closest_vowel_index\
    \ = i - last_consonant_index;\n                closest_vowel = c.to_string();\n\
    \            }\n        } else {\n            last_consonant_index = i;\n    \
    \    }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpnyq2ac5n.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut last_consonant = word.len();\n \
    \   let mut first_vowel = word.len();\n    let mut i = word.len() - 1;\n    while\
    \ i >= 0 {\n        if word.chars().nth(i).unwrap().is_vowel() {\n           \
    \ first_vowel = i;\n            if last_consonant - first_vowel < closest_distance\
    \ {\n                closest_distance = last_consonant - first_vowel;\n      \
    \          closest_vowel = word.chars().nth(i).unwrap().to_string();\n       \
    \     }\n        } else {\n            last_consonant = i;\n        }\n      \
    \  i -= 1;\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpsl2kl3hd.rs:14:41\n   |\n14 |         if word.chars().nth(i).unwrap().is_vowel()\
    \ {\n   |                                         ^^^^^^^^ method not found in\
    \ `char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel = 0;\n    let mut last_consonant\
    \ = 0;\n    let mut last_char = ' ';\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            last_vowel = i;\n        }\
    \ else {\n            if last_vowel != 0 && last_consonant != 0 {\n          \
    \      if last_vowel > last_consonant {\n                    result.push(last_char);\n\
    \                    break;\n                }\n            }\n            last_consonant\
    \ = i;\n            last_char = c;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"g\"`,\n right: `\"u\"`', /tmp/tmpbe82m_ng.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_index = 0;\n    let mut closest_consonant_index = 0;\n    let\
    \ mut vowel_found = false;\n    let mut consonant_found = false;\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    let consonants = ['b', 'c', 'd', 'f', 'g',\
    \ 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let word_chars: Vec<char> = word.chars().collect();\n    for (i, c) in word_chars.iter().enumerate().rev()\
    \ {\n        if vowels.contains(c) {\n            vowel_found = true;\n      \
    \      closest_vowel_index = i;\n        }\n        if consonants.contains(c)\
    \ && vowel_found {\n            consonant_found = true;\n            closest_consonant_index\
    \ = i;\n            break;\n        }\n    }\n    if vowel_found && consonant_found\
    \ {\n        for i in closest_consonant_index..closest_vowel_index + 1 {\n   \
    \         closest_vowel.push(word_chars[i]);\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"gu\"`,\n right: `\"u\"`', /tmp/tmpmipsj05k.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_index = 0;\n    let\
    \ mut is_vowel = false;\n    let mut is_consonant = false;\n    let mut is_first\
    \ = true;\n    let mut is_last = false;\n    let mut is_found = false;\n    let\
    \ mut is_last_vowel = false;\n    let mut is_last_consonant = false;\n    let\
    \ mut is_last_found = false;\n    let mut is_first_vowel = false;\n    let mut\
    \ is_first_consonant = false;\n    let mut is_first_found = false;\n    let mut\
    \ is_first_last = false;\n    let mut is_last_first = false;\n    let mut is_first_last_found\
    \ = false;\n    let mut is_last_first_found = false;\n    let mut is_first_last_vowel\
    \ = false;\n    let mut is_last_first_vowel = false;\n    let mut is_first_last_consonant\
    \ = false;\n    let mut is_last_first_consonant = false;\n    let mut is_first_last_consonant_found\
    \ = false;\n    let mut is_last_first_consonant_found = false;\n    let mut is_first_last_vowel_found\
    \ = false;\n    let mut is_last_first_vowel_found = false;\n    let mut is_first_last_consonant_vowel\
    \ = false;\n    let mut is_last_first_consonant_vowel = false;\n    let mut is_first_last_consonant_vowel_found\
    \ = false;\n    let mut is_last_first_consonant_vowel_found = false;\n    let\
    \ mut is_first_last_consonant_vowel_consonant = false;\n    let mut is_last_first_consonant_vowel_consonant\
    \ = false;\n    let mut is_first_last_consonant_\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzu490kns.rs:41:37\n   |\n\
    41 |     let mut is_first_last_consonant_\n   |                              \
    \       ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpzu490kns.rs:7:39\n  |\n7 | fn get_closest_vowel(word:\
    \ String) -> String {\n  |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel_index = word.len();\n  \
    \  for (i, c) in word.chars().enumerate().rev() {\n        if vowels.contains(&c)\
    \ {\n            last_vowel_index = i;\n            break;\n        }\n    }\n\
    \    for (i, c) in word.chars().enumerate().rev() {\n        if !vowels.contains(&c)\
    \ && last_vowel_index < i {\n            result.push(word.chars().nth(i - 1).unwrap());\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmprxrppefs.rs:11:44\n   |\n11 |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n   |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmprxrppefs.rs:11:19\n    |\n11  |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator`\
    \ is not satisfied\n  --> /tmp/tmprxrppefs.rs:17:44\n   |\n17 |     for (i, c)\
    \ in word.chars().enumerate().rev() {\n   |                                  \
    \          ^^^ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n\
    \   |\n   = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator`\
    \ is not satisfied\n   --> /tmp/tmprxrppefs.rs:17:19\n    |\n17  |     for (i,\
    \ c) in word.chars().enumerate().rev() {\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n    |\n  \
    \  = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\n    = note: required because of the requirements\
    \ on the impl of `Iterator` for `Rev<Enumerate<Chars<'_>>>`\n    = note: required\
    \ because of the requirements on th"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel_index = 0;\n    let mut\
    \ last_consonant_index = 0;\n    let mut last_vowel_char = ' ';\n    let mut last_consonant_char\
    \ = ' ';\n    let mut last_char = ' ';\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            last_vowel_index = i;\n   \
    \         last_vowel_char = c;\n        } else {\n            last_consonant_index\
    \ = i;\n            last_consonant_char = c;\n        }\n        if last_vowel_index\
    \ > last_consonant_index {\n            result.push(last_vowel_char);\n      \
    \      break;\n        }\n        last_char = c;\n    }\n    if last_vowel_index\
    \ == 0 && last_consonant_index == 0 {\n        result.push(last_char);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpplcwo28b.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ last_consonant = String::new();\n    let mut last_vowel = String::new();\n \
    \   let mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n   \
    \ let mut vowel_index = 0;\n    let mut consonant_index = 0;\n    let mut vowel_count\
    \ = 0;\n    let mut consonant_count = 0;\n    let mut vowel_distance = 0;\n  \
    \  let mut consonant_distance = 0;\n    let mut vowel_distance_index = 0;\n  \
    \  let mut consonant_distance_index = 0;\n    let mut vowel_distance_count = 0;\n\
    \    let mut consonant_distance_count = 0;\n    let mut vowel_distance_index_count\
    \ = 0;\n    let mut consonant_distance_index_count = 0;\n    let mut vowel_distance_index_count_index\
    \ = 0;\n    let mut consonant_distance_index_count_index = 0;\n    let mut vowel_distance_index_count_index_index\
    \ = 0;\n    let mut consonant_distance_index_count_index_index = 0;\n    let mut\
    \ vowel_distance_index_count_index_index_index = 0;\n    let mut consonant_distance_index_count_index_index_index\
    \ = 0;\n    let mut vowel_distance_index_count_index_index_index_index = 0;\n\
    \    let mut consonant_distance_index_count_index_index_index_index = 0;\n   \
    \ let mut vowel_distance_index_count_index_index_index_index_index = 0;\n    let\
    \ mut consonant_distance_index_count_index_index_index_index_index = 0;\n    let\
    \ mut vowel_distance_index_count_index_index_index_index_index_index = 0;\n  \
    \  let mut consonant_distance_index_count_index_index_index_index_index_index\
    \ = 0;\n    let mut vowel_distance_index_count_index_index_index_index_index_index_index\
    \ = 0;\n    let mut consonant_distance_index_count_index\n}\n\nfn main() {\n \
    \   let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0egqseia.rs:38:49\n   |\n\
    38 |     let mut consonant_distance_index_count_index\n   |                  \
    \                               ^ help: add `;` here\n39 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp0egqseia.rs:7:39\n  |\n\
    7 | fn get_closest_vowel(word: String) -> String {\n  |    ----------------- \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ last_consonant = String::new();\n    let mut last_vowel = String::new();\n \
    \   let mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n   \
    \ let mut index = 0;\n    for c in word.chars() {\n        if c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u' {\n            last_vowel = c.to_string();\n\
    \            last_vowel_index = index;\n        } else {\n            last_consonant\
    \ = c.to_string();\n            last_consonant_index = index;\n        }\n   \
    \     index += 1;\n    }\n    if last_vowel_index > last_consonant_index {\n \
    \       closest_vowel = last_vowel;\n    }\n    closest_vowel\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpqx7l21hu.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_distance = word.len();\n\
    \    let mut last_consonant = 0;\n    for (i, c) in word.chars().enumerate() {\n\
    \        if vowels.contains(&c) {\n            if i - last_consonant < closest_distance\
    \ {\n                closest_distance = i - last_consonant;\n                closest_vowel\
    \ = c.to_string();\n            }\n        } else {\n            last_consonant\
    \ = i;\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpa53yltjd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut last_vowel_index = None;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            last_vowel_index = Some(i);\n\
    \        } else if let Some(last_vowel_index) = last_vowel_index {\n         \
    \   if i - last_vowel_index < closest_distance {\n                closest_distance\
    \ = i - last_vowel_index;\n                closest_vowel = word[last_vowel_index..i].to_string();\n\
    \            }\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp1_qcyt_b.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut index\
    \ = word.len() - 1;\n    let mut last_vowel_index = 0;\n    let mut last_consonant_index\
    \ = 0;\n    let mut found_vowel = false;\n    let mut found_consonant = false;\n\
    \    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let consonants = vec!['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    while index >= 0 {\n        if vowels.contains(&word.chars().nth(index).unwrap())\
    \ {\n            last_vowel_index = index;\n            found_vowel = true;\n\
    \        }\n        if consonants.contains(&word.chars().nth(index).unwrap())\
    \ {\n            last_consonant_index = index;\n            found_consonant =\
    \ true;\n        }\n        if found_vowel && found_consonant {\n            if\
    \ last_vowel_index > last_consonant_index {\n                result.push(word.chars().nth(last_vowel_index).unwrap());\n\
    \            }\n            break;\n        }\n        index -= 1;\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpm_c_9dmc.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut last_vowel = None;\n    let mut last_consonant\
    \ = None;\n    let mut last_vowel_index = None;\n    let mut last_consonant_index\
    \ = None;\n    let mut result = String::new();\n    let mut index = 0;\n    for\
    \ c in word.chars() {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u' {\n            last_vowel = Some(c);\n            last_vowel_index\
    \ = Some(index);\n        } else {\n            last_consonant = Some(c);\n  \
    \          last_consonant_index = Some(index);\n        }\n        index += 1;\n\
    \    }\n    if last_vowel.is_some() && last_consonant.is_some() {\n        if\
    \ last_vowel_index.unwrap() > last_consonant_index.unwrap() {\n            result.push(last_vowel.unwrap());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpr8f7njsw.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_char = ' ';\n    for\
    \ (i, c) in word.chars().enumerate() {\n        if c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u' {\n            last_vowel = i;\n        } else {\n\
    \            last_consonant = i;\n        }\n        if last_vowel > last_consonant\
    \ && last_char != c {\n            result = word[last_vowel..].to_string();\n\
    \        }\n        last_char = c;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"urt\"`,\n right: `\"u\"`', /tmp/tmpxhack8eu.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut index = word.len();\n    let mut vowel_index\
    \ = 0;\n    let mut vowel_found = false;\n    let mut vowel_count = 0;\n    let\
    \ mut last_vowel_index = 0;\n    let mut last_vowel_count = 0;\n    let mut last_vowel_found\
    \ = false;\n    let mut last_vowel = String::new();\n    let mut vowel = String::new();\n\
    \    let mut last_consonant = String::new();\n    let mut consonant = String::new();\n\
    \    let mut last_consonant_index = 0;\n    let mut last_consonant_count = 0;\n\
    \    let mut last_consonant_found = false;\n    let mut consonant_index = 0;\n\
    \    let mut consonant_count = 0;\n    let mut consonant_found = false;\n    let\
    \ mut vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut consonants = vec!['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let mut word_chars: Vec<char> = word.chars().collect();\n\
    \    for i in (0..word.len()).rev() {\n        if vowels.contains(&word_chars[i])\
    \ {\n            vowel_count += 1;\n            vowel_index = i;\n           \
    \ vowel_found = true;\n            vowel = word_chars[i].to_string();\n      \
    \  }\n        if consonants.contains(&word_chars[i]) {\n            consonant_count\
    \ += 1;\n            consonant_index = i;\n            consonant_found = true;\n\
    \            consonant = word_chars[i].to_string();\n        }\n        if vowel_found\
    \ && consonant_found {\n            if last_vowel_count == 0 {\n             \
    \   last_vowel_count = vowel_count;\n                last_vowel_index =\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpslxu1w8p.rs:62:3\n\
    \   |\n7  | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n28 |     for i in\
    \ (0..word.len()).rev() {\n   |                                    - unclosed\
    \ delimiter\n...\n41 |         if vowel_found && consonant_found {\n   |     \
    \                                      - unclosed delimiter\n42 |            \
    \ if last_vowel_count == 0 {\n   |                                      - this\
    \ delimiter might not be properly closed...\n...\n45 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n62 | }\n   |   ^\n\nerror: expected\
    \ expression, found `}`\n  --> /tmp/tmpslxu1w8p.rs:45:1\n   |\n45 | }\n   | ^\
    \ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpslxu1w8p.rs:28:5\n\
    \   |\n7  |   fn get_closest_vowel(word: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n28 | /     for i in (0..word.len()).rev() {\n29 | |         if vowels.contains(&word_chars[i])\
    \ {\n30 | |             vowel_count += 1;\n31 | |             vowel_index = i;\n\
    ...  |\n61 | |     assert_eq!(candidate(String::from(\"Above\")), String::from(\"\
    o\"));\n62 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_distance = word.len();\n    let mut last_consonant_index = word.len();\n\
    \    for (i, c) in word.chars().enumerate() {\n        if is_vowel(c) {\n    \
    \        if i > last_consonant_index {\n                if i - last_consonant_index\
    \ < closest_vowel_distance {\n                    closest_vowel = c.to_string();\n\
    \                    closest_vowel_distance = i - last_consonant_index;\n    \
    \            }\n            }\n        } else {\n            last_consonant_index\
    \ = i;\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpx2l2svxt.rs:12:12\n\
    \   |\n12 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut index\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_vowel = 0;\n    let\
    \ mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n    let mut\
    \ found_vowel = false;\n    let mut found_consonant = false;\n    let mut found_vowel_after_consonant\
    \ = false;\n    let mut found_consonant_after_vowel = false;\n    let mut found_consonant_before_vowel\
    \ = false;\n    let mut found_vowel_before_consonant = false;\n    let mut found_vowel_after_consonant_index\
    \ = 0;\n    let mut found_consonant_after_vowel_index = 0;\n    let mut found_consonant_before_vowel_index\
    \ = 0;\n    let mut found_vowel_before_consonant_index = 0;\n    let mut found_vowel_before_consonant_after_vowel\
    \ = false;\n    let mut found_vowel_before_consonant_after_vowel_index = 0;\n\
    \    let mut found_consonant_after_vowel_before_consonant = false;\n    let mut\
    \ found_consonant_after_vowel_before_consonant_index = 0;\n    let mut found_vowel_before_consonant_after_vowel_before_consonant\
    \ = false;\n    let mut found_vowel_before_consonant_after_vowel_before_consonant_index\
    \ = 0;\n    let mut found_vowel_before_consonant_after_vowel_before_consonant_after_vowel\
    \ = false;\n    let mut found_vowel_before_consonant_after_vowel_before_consonant_after_vowel_index\
    \ = 0;\n    let mut found_consonant_after_vowel_before_consonant_after_vowel =\
    \ false;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkc2qv9b7.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel_index\
    \ = 0;\n    let mut last_consonant_index = 0;\n    let mut last_vowel_found =\
    \ false;\n    let mut last_consonant_found = false;\n    let mut last_vowel_char\
    \ = ' ';\n    let mut last_consonant_char = ' ';\n    let mut last_char = ' ';\n\
    \    let mut last_char_is_vowel = false;\n    let mut last_char_is_consonant =\
    \ false;\n    let mut last_char_is_vowel_or_consonant = false;\n    let mut last_char_is_vowel_or_consonant_or_space\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_space_or_punctuation\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_space_or_punctuation_or_digit\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_space_or_punctuation_or_digit_or_symbol\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_space_or_punctuation_or_digit_or_symbol_or_control\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_space_or_punctuation_or_digit_or_symbol_or_control_or_whitespace\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_space_or_punctuation_or_digit_or_symbol_or_control_or_whitespace_or_newline\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_space_or_punctuation_or_digit_or_symbol_or_control_or_whitespace_or_newline_or_tab\
    \ = false;\n    let mut\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp_uwhhh_1.rs:28:1\n\
    \   |\n28 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_distance = word.len();\n\
    \    let mut last_consonant = 0;\n    for (i, c) in word.chars().enumerate() {\n\
    \        if vowels.contains(&c) {\n            if i - last_consonant < closest_distance\
    \ {\n                closest_distance = i - last_consonant;\n                closest_vowel\
    \ = c.to_string();\n            }\n        } else {\n            last_consonant\
    \ = i;\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpa53yltjd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev_char\
    \ = ' ';\n    let mut prev_vowel = ' ';\n    for c in word.chars().rev() {\n \
    \       if is_vowel(c) {\n            if !is_vowel(prev_char) {\n            \
    \    result = c.to_string();\n                break;\n            }\n        \
    \    prev_vowel = c;\n        }\n        prev_char = c;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpc3fuvx13.rs:12:12\n\
    \   |\n12 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmpc3fuvx13.rs:13:17\n   |\n13 |             if !is_vowel(prev_char) {\n\
    \   |                 ^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_distance = word.len();\n    let mut last_consonant_index = 0;\n\
    \    let mut last_consonant_found = false;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if is_vowel(c) {\n            if last_consonant_found {\n       \
    \         let distance = i - last_consonant_index;\n                if distance\
    \ < closest_vowel_distance {\n                    closest_vowel_distance = distance;\n\
    \                    closest_vowel = c.to_string();\n                }\n     \
    \       }\n        } else {\n            last_consonant_index = i;\n         \
    \   last_consonant_found = true;\n        }\n    }\n    closest_vowel\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpjro7xi8z.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut index\
    \ = 0;\n    let mut last_vowel_index = 0;\n    let mut last_consonant_index =\
    \ 0;\n    let mut found_vowel = false;\n    let mut found_consonant = false;\n\
    \    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut word_chars = word.chars();\n\
    \    while let Some(c) = word_chars.next() {\n        if vowels.contains(&c) {\n\
    \            last_vowel_index = index;\n            found_vowel = true;\n    \
    \    } else {\n            if found_vowel {\n                last_consonant_index\
    \ = index;\n                found_consonant = true;\n            }\n        }\n\
    \        index += 1;\n    }\n    if found_vowel && found_consonant {\n       \
    \ result.push(word.chars().nth(last_vowel_index).unwrap());\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp34qho1dj.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut index = word.len() - 1;\n    let mut\
    \ is_consonant = false;\n    while index >= 0 {\n        let c = word.chars().nth(index).unwrap();\n\
    \        if vowels.contains(&c) {\n            if is_consonant {\n           \
    \     result.push(c);\n                break;\n            }\n        } else {\n\
    \            is_consonant = true;\n        }\n        index -= 1;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpbu3er73z.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec!['a', 'e', 'i', 'o', 'u'];\n \
    \   let mut result = String::new();\n    let mut prev_char = ' ';\n    let mut\
    \ next_char = ' ';\n    for (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c)\
    \ {\n            if i == 0 {\n                continue;\n            }\n     \
    \       if i == word.len() - 1 {\n                continue;\n            }\n \
    \           prev_char = word.chars().nth(i - 1).unwrap();\n            next_char\
    \ = word.chars().nth(i + 1).unwrap();\n            if !vowels.contains(&prev_char)\
    \ && !vowels.contains(&next_char) {\n                result = c.to_string();\n\
    \                break;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpr3kjgm8q.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut found_consonant\
    \ = false;\n    let mut found_vowel = false;\n    let mut found_consonant_again\
    \ = false;\n    let mut found_vowel_again = false;\n    let mut vowel_index =\
    \ 0;\n    let mut consonant_index = 0;\n    let mut consonant_index_again = 0;\n\
    \    let mut vowel_index_again = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n\
    \    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n\
    \    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n\
    \    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\
    \    let mut a = 0;\n    let mut b = 0;\n    let mut c = 0;\n    let mut d = 0;\n\
    \    let mut e = 0;\n    let mut f = 0;\n    let mut g = 0;\n    let mut h = 0;\n\
    \    let mut ii = 0;\n    let mut jj = 0;\n    let mut kk = 0;\n    let mut ll\
    \ = 0;\n    let mut mm = 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let\
    \ mut pp = 0;\n    let mut qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n\
    \    let mut tt = 0;\n    let mut uu = 0;\n    let mut vv = 0;\n    let mut ww\
    \ = 0;\n    let mut xx = 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let\
    \ mut aa = 0;\n    let mut bb = 0;\n    let mut cc = 0;\n    let mut dd = 0;\n\
    \    let mut ee\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpn725p8zn.rs:65:15\n   |\n\
    65 |     let mut ee\n   |               ^ help: add `;` here\n66 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpn725p8zn.rs:7:39\n  |\n\
    7 | fn get_closest_vowel(word: String) -> String {\n  |    ----------------- \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_vowel_index = word.len();\n\
    \    let mut last_consonant_index = word.len();\n    for (i, c) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&c) {\n            if i < last_consonant_index\
    \ && last_consonant_index - i < closest_vowel_index {\n                closest_vowel_index\
    \ = last_consonant_index - i;\n                closest_vowel = c.to_string();\n\
    \            }\n        } else {\n            last_consonant_index = i;\n    \
    \    }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmprqhkojg1.rs:12:44\n   |\n12 |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n   |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmprqhkojg1.rs:12:19\n    |\n12  |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_distance = word.len();\n\
    \    let mut prev_is_consonant = false;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            if prev_is_consonant {\n  \
    \              if i < closest_distance {\n                    closest_distance\
    \ = i;\n                    closest_vowel = c.to_string();\n                }\n\
    \            }\n            prev_is_consonant = false;\n        } else {\n   \
    \         prev_is_consonant = true;\n        }\n    }\n    closest_vowel\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpluucvpsn.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_consonant\
    \ = false;\n    let mut last_vowel = false;\n    let mut last_vowel_index = 0;\n\
    \    let mut last_consonant_index = 0;\n    let mut index = 0;\n    for c in word.chars()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \           if last_consonant {\n                last_vowel = true;\n        \
    \        last_vowel_index = index;\n            }\n        } else {\n        \
    \    if last_vowel {\n                last_consonant = true;\n               \
    \ last_consonant_index = index;\n            }\n        }\n        index += 1;\n\
    \    }\n    if last_consonant && last_vowel {\n        result = word[last_vowel_index..last_consonant_index].to_string();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpf00fuiqs.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel_index\
    \ = 0;\n    let mut last_consonant_index = 0;\n    let mut last_vowel_char = '\
    \ ';\n    let mut last_consonant_char = ' ';\n    let mut found_vowel = false;\n\
    \    let mut found_consonant = false;\n    let mut found_vowel_between_consonants\
    \ = false;\n    let mut found_consonant_between_vowels = false;\n    let mut found_vowel_between_consonants_index\
    \ = 0;\n    let mut found_consonant_between_vowels_index = 0;\n    let mut found_vowel_between_consonants_char\
    \ = ' ';\n    let mut found_consonant_between_vowels_char = ' ';\n    let mut\
    \ found_vowel_between_consonants_distance = 0;\n    let mut found_consonant_between_vowels_distance\
    \ = 0;\n    let mut distance = 0;\n    let mut distance_between_vowels = 0;\n\
    \    let mut distance_between_consonants = 0;\n    let mut distance_between_vowels_and_consonants\
    \ = 0;\n    let mut distance_between_consonants_and_vowels = 0;\n    let mut distance_between_vowels_and_consonants_index\
    \ = 0;\n    let mut distance_between_consonants_and_vowels_index = 0;\n    let\
    \ mut distance_between_vowels_and_consonants_char = ' ';\n    let mut distance_between_consonants_and_vowels_char\
    \ = ' ';\n    let mut distance_between_vowels_and_consonants_distance = 0;\n \
    \   let mut distance_between_consonants_and_vowels_distance = 0;\n    let mut\
    \ distance_between_vowels_and_consonants_distance_index = 0;\n    let mut distance_between_consonants_and_vowels_distance_index\
    \ = 0;\n    let mut\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpkppf7axp.rs:37:1\n\
    \   |\n37 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut result = String::new();\n\
    \    let mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n  \
    \  let mut last_consonant_found = false;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(c) {\n            last_vowel_index = i;\n    \
    \    } else {\n            if last_consonant_found {\n                if last_vowel_index\
    \ > last_consonant_index {\n                    result = word[last_vowel_index..last_vowel_index\
    \ + 1].to_string();\n                    break;\n                }\n         \
    \   }\n            last_consonant_index = i;\n            last_consonant_found\
    \ = true;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpi7wu_7ej.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel_index = 0;\n    let mut\
    \ last_consonant_index = 0;\n    for (i, c) in word.chars().enumerate() {\n  \
    \      if vowels.contains(&c) {\n            last_vowel_index = i;\n        }\
    \ else {\n            last_consonant_index = i;\n        }\n        if last_vowel_index\
    \ > last_consonant_index {\n            result = word[last_vowel_index..last_vowel_index\
    \ + 1].to_string();\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp0033w0z_.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_vowel_index = word.len();\n\
    \    let mut last_consonant_index = 0;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            if i - last_consonant_index\
    \ > 1 && i - last_consonant_index < closest_vowel_index {\n                closest_vowel\
    \ = c.to_string();\n                closest_vowel_index = i;\n            }\n\
    \        } else {\n            last_consonant_index = i;\n        }\n    }\n \
    \   closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpurz1hqdq.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut last_consonant = word.len();\n \
    \   for (i, c) in word.chars().enumerate() {\n        if \"aeiou\".contains(c)\
    \ {\n            if i - last_consonant < closest_distance {\n                closest_distance\
    \ = i - last_consonant;\n                closest_vowel = c.to_string();\n    \
    \        }\n        } else {\n            last_consonant = i;\n        }\n   \
    \ }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpu2qumfga.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel_index\
    \ = 0;\n    let mut last_consonant_index = 0;\n    let mut last_char_is_vowel\
    \ = false;\n    let mut last_char_is_consonant = false;\n    let mut last_char_index\
    \ = 0;\n    let mut last_char = ' ';\n    let mut i = 0;\n    for c in word.chars()\
    \ {\n        if is_vowel(c) {\n            last_vowel_index = i;\n           \
    \ last_char_is_vowel = true;\n            last_char_is_consonant = false;\n  \
    \      } else {\n            last_consonant_index = i;\n            last_char_is_vowel\
    \ = false;\n            last_char_is_consonant = true;\n        }\n        if\
    \ last_char_is_vowel && last_char_is_consonant {\n            result = word[last_vowel_index..=last_vowel_index].to_string();\n\
    \            break;\n        }\n        last_char = c;\n        last_char_index\
    \ = i;\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp1gkp369d.rs:17:12\n\
    \   |\n17 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev_is_consonant\
    \ = false;\n    let mut next_is_consonant = false;\n    let mut vowel_index =\
    \ 0;\n    let mut vowel_index_found = false;\n    let mut vowel_index_found_prev\
    \ = false;\n    let mut vowel_index_found_next = false;\n    let mut vowel_index_found_prev_index\
    \ = 0;\n    let mut vowel_index_found_next_index = 0;\n    let mut vowel_index_found_prev_index_found\
    \ = false;\n    let mut vowel_index_found_next_index_found = false;\n    let mut\
    \ vowel_index_found_prev_index_found_prev = false;\n    let mut vowel_index_found_next_index_found_next\
    \ = false;\n    let mut vowel_index_found_prev_index_found_prev_index = 0;\n \
    \   let mut vowel_index_found_next_index_found_next_index = 0;\n    let mut vowel_index_found_prev_index_found_prev_index_found\
    \ = false;\n    let mut vowel_index_found_next_index_found_next_index_found =\
    \ false;\n    let mut vowel_index_found_prev_index_found_prev_index_found_prev\
    \ = false;\n    let mut vowel_index_found_next_index_found_next_index_found_next\
    \ = false;\n    let mut vowel_index_found_prev_index_found_prev_index_found_prev_index\
    \ = 0;\n    let mut vowel_index_found_next_index_found_next_index_found_next_index\
    \ = 0;\n    let mut vowel_index_found_prev_index_found_prev_index_found_prev_index_found\
    \ = false;\n    let mut vowel_index_found_next_index_found_next_index_found_next_index_found\
    \ = false;\n    let mut vowel_index_found_prev_index_found_prev_index_found_prev_index_found_prev\
    \ = false;\n    let mut vowel_index_found_next_index_found_next_index_found_next_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt21vcl1x.rs:32:70\n   |\n\
    32 |     let mut vowel_index_found_next_index_found_next_index_found_next_\n \
    \  |                                                                      ^ help:\
    \ add `;` here\n33 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpt21vcl1x.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String) ->\
    \ String {\n  |    -----------------                  ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = Vec::new();\n    let mut consonants\
    \ = Vec::new();\n    for c in word.chars() {\n        if c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' {\n            vowels.push(c);\n       \
    \ } else {\n            consonants.push(c);\n        }\n    }\n    if vowels.len()\
    \ == 0 || consonants.len() == 0 {\n        return String::from(\"\");\n    }\n\
    \    let mut closest_vowel = vowels[0];\n    let mut closest_distance = word.len();\n\
    \    for i in 0..vowels.len() {\n        let vowel = vowels[i];\n        let mut\
    \ distance = word.len();\n        for j in 0..consonants.len() {\n           \
    \ let consonant = consonants[j];\n            let mut found = false;\n       \
    \     for k in 0..word.len() {\n                if word.chars().nth(k).unwrap()\
    \ == vowel {\n                    for l in k..word.len() {\n                 \
    \       if word.chars().nth(l).unwrap() == consonant {\n                     \
    \       found = true;\n                            distance = l - k;\n       \
    \                     break;\n                        }\n                    }\n\
    \                    if found {\n                        break;\n            \
    \        }\n                }\n            }\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_vowel\
    \ = vowel;\n            }\n        }\n    }\n    closest_vowel.to_string()\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmptwas5vkh.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut word = word.chars().rev().collect::<Vec<char>>();\n\
    \    let mut result = String::new();\n    let mut found = false;\n    for i in\
    \ 0..word.len() {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u' {\n            if i == 0 {\n           \
    \     break;\n            }\n            if word[i - 1] != 'a' && word[i - 1]\
    \ != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' {\n\
    \                result.push(word[i]);\n                found = true;\n      \
    \          break;\n            }\n        }\n    }\n    if found {\n        result\n\
    \    } else {\n        String::new()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp49rnof9v.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = String::new();\n    let mut last_consonant = String::new();\n    let mut last_char\
    \ = String::new();\n    let mut last_char_is_vowel = false;\n    let mut last_char_is_consonant\
    \ = false;\n    let mut last_char_is_vowel_or_consonant = false;\n    let mut\
    \ last_char_is_vowel_and_consonant = false;\n    let mut last_char_is_vowel_or_consonant_and_consonant\
    \ = false;\n    let mut last_char_is_vowel_and_consonant_and_consonant = false;\n\
    \    let mut last_char_is_vowel_or_consonant_and_vowel = false;\n    let mut last_char_is_vowel_and_consonant_and_vowel\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_and_vowel_and_consonant\
    \ = false;\n    let mut last_char_is_vowel_and_consonant_and_vowel_and_consonant\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_and_vowel_and_vowel =\
    \ false;\n    let mut last_char_is_vowel_and_consonant_and_vowel_and_vowel = false;\n\
    \    let mut last_char_is_vowel_or_consonant_and_vowel_and_vowel_and_consonant\
    \ = false;\n    let mut last_char_is_vowel_and_consonant_and_vowel_and_vowel_and_consonant\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_and_vowel_and_vowel_and_vowel\
    \ = false;\n    let mut last_char_is_vowel_and_conson\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdiw1u6r0.rs:27:42\n   |\n\
    27 |     let mut last_char_is_vowel_and_conson\n   |                         \
    \                 ^ help: add `;` here\n28 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpdiw1u6r0.rs:7:39\n  |\n7 | fn get_closest_vowel(word:\
    \ String) -> String {\n  |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = String::new();\n    let mut last_consonant = String::new();\n    let mut last_char\
    \ = String::new();\n    let mut last_char_is_vowel = false;\n    let mut last_char_is_consonant\
    \ = false;\n    let mut last_char_is_vowel_or_consonant = false;\n    let mut\
    \ last_char_is_vowel_or_consonant_or_empty = false;\n    let mut last_char_is_consonant_or_empty\
    \ = false;\n    let mut last_char_is_vowel_or_empty = false;\n    let mut last_char_is_empty\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_start = false;\n\
    \    let mut last_char_is_consonant_or_empty_or_start = false;\n    let mut last_char_is_vowel_or_empty_or_start\
    \ = false;\n    let mut last_char_is_empty_or_start = false;\n    let mut last_char_is_start\
    \ = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_start_or_end\
    \ = false;\n    let mut last_char_is_consonant_or_empty_or_start_or_end = false;\n\
    \    let mut last_char_is_vowel_or_empty_or_start_or_end = false;\n    let mut\
    \ last_char_is_empty_or_start_or_end = false;\n    let mut last_char_is_start_or_end\
    \ = false;\n    let mut last_char_is_end = false;\n    let mut last_char_is_vowel_or_consonant_or_empty_or_start_or_end_or_end\
    \ = false;\n    let mut last_char_is_consonant_or_empty_or_start_or_end_or_end\
    \ = false;\n    let mut\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpdxht1qy9.rs:33:1\n\
    \   |\n33 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_distance = word.len();\n\
    \    let mut last_consonant = 0;\n    for (i, c) in word.chars().enumerate() {\n\
    \        if vowels.contains(&c) {\n            if i - last_consonant < closest_distance\
    \ {\n                closest_distance = i - last_consonant;\n                closest_vowel\
    \ = c.to_string();\n            }\n        } else {\n            last_consonant\
    \ = i;\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpa53yltjd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut chars = word.chars().collect::<Vec<char>>();\n\
    \    let mut i = chars.len() - 1;\n    while i > 0 {\n        if vowels.contains(&chars[i])\
    \ {\n            if !vowels.contains(&chars[i - 1]) {\n                result.push(chars[i]);\n\
    \                break;\n            }\n        }\n        i -= 1;\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmp43onjs_y.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = String::new();\n    let mut last_consonant = String::new();\n    for c in\
    \ word.chars() {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u' {\n            last_vowel = c.to_string();\n        } else {\n      \
    \      last_consonant = c.to_string();\n        }\n        if !last_vowel.is_empty()\
    \ && !last_consonant.is_empty() {\n            result = last_vowel.clone();\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmprdmewfu8.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut word = word.chars().rev().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    while i < word.len() {\n        if is_vowel(word[i])\
    \ {\n            if i + 1 < word.len() && is_vowel(word[i + 1]) {\n          \
    \      i += 1;\n            } else {\n                break;\n            }\n\
    \        }\n        i += 1;\n    }\n    if i == word.len() {\n        return String::new();\n\
    \    }\n    word[i].to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp85f3ij1h.rs:11:12\n\
    \   |\n11 |         if is_vowel(word[i]) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmp85f3ij1h.rs:12:38\n   |\n12 |             if i + 1 < word.len()\
    \ && is_vowel(word[i + 1]) {\n   |                                      ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut last_consonant = word.len();\n    for (i, c) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&c) {\n            if i < last_consonant && last_consonant\
    \ - i < closest_distance {\n                closest_distance = last_consonant\
    \ - i;\n                closest_vowel = c.to_string();\n            }\n      \
    \  } else {\n            last_consonant = i;\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmpmqp0izil.rs:12:44\n   |\n12 |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n   |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmpmqp0izil.rs:12:19\n    |\n12  |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_index = word.len();\n    let mut last_consonant_index = word.len();\n\
    \    let mut found_vowel = false;\n    for (index, character) in word.chars().enumerate()\
    \ {\n        if is_vowel(character) {\n            found_vowel = true;\n     \
    \       if index - last_consonant_index < closest_vowel_index - last_consonant_index\
    \ {\n                closest_vowel_index = index;\n            }\n        } else\
    \ {\n            last_consonant_index = index;\n        }\n    }\n    if found_vowel\
    \ {\n        closest_vowel.push(word.chars().nth(closest_vowel_index).unwrap());\n\
    \    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpw2sk9dly.rs:13:12\n\
    \   |\n13 |         if is_vowel(character) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev_char\
    \ = ' ';\n    let mut prev_vowel = ' ';\n    let mut vowel_found = false;\n  \
    \  for c in word.chars().rev() {\n        if is_vowel(c) {\n            prev_vowel\
    \ = c;\n            if vowel_found {\n                result.push(prev_vowel);\n\
    \                break;\n            }\n        } else {\n            if is_vowel(prev_char)\
    \ {\n                vowel_found = true;\n            }\n        }\n        prev_char\
    \ = c;\n    }\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpjzjpjdv2.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmpjzjpjdv2.rs:20:16\n   |\n20 |             if is_vowel(prev_char) {\n\
    \   |                ^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_vowel_index = 0;\n \
    \   let mut last_consonant_index = 0;\n    let mut is_vowel = false;\n    let\
    \ mut is_consonant = false;\n    let mut is_first_letter = true;\n    let mut\
    \ is_last_letter = false;\n    let mut is_first_vowel = false;\n    let mut is_first_consonant\
    \ = false;\n    let mut is_last_vowel = false;\n    let mut is_last_consonant\
    \ = false;\n    let mut is_first_vowel_found = false;\n    let mut is_first_consonant_found\
    \ = false;\n    let mut is_last_vowel_found = false;\n    let mut is_last_consonant_found\
    \ = false;\n    let mut is_first_vowel_found_index = 0;\n    let mut is_first_consonant_found_index\
    \ = 0;\n    let mut is_last_vowel_found_index = 0;\n    let mut is_last_consonant_found_index\
    \ = 0;\n    let mut is_first_vowel_found_index_temp = 0;\n    let mut is_first_consonant_found_index_temp\
    \ = 0;\n    let mut is_last_vowel_found_index_temp = 0;\n    let mut is_last_consonant_found_index_temp\
    \ = 0;\n    let mut is_first_vowel_found_temp = false;\n    let mut is_first_consonant_found_temp\
    \ = false;\n    let mut is_last_vowel_found_temp = false;\n    let mut is_last_consonant_found_temp\
    \ = false;\n    let mut is_first_vowel_found_index_temp_temp = 0;\n    let mut\
    \ is_first_consonant_found_index_temp_temp = 0;\n    let mut is_last_vowel_found_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptk6seyq7.rs:39:33\n   |\n\
    39 |     let mut is_last_vowel_found_\n   |                                 ^\
    \ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmptk6seyq7.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String)\
    \ -> String {\n  |    -----------------                  ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ result = String::new();\n    let mut last_vowel = 0;\n    let mut last_consonant\
    \ = 0;\n    let mut index = 0;\n    for c in word.chars() {\n        if vowels.contains(&c)\
    \ {\n            last_vowel = index;\n        } else {\n            last_consonant\
    \ = index;\n        }\n        index += 1;\n    }\n    if last_vowel == 0 || last_consonant\
    \ == 0 {\n        return result;\n    }\n    let mut index = 0;\n    for c in\
    \ word.chars() {\n        if vowels.contains(&c) {\n            if index > last_consonant\
    \ {\n                result.push(c);\n                break;\n            }\n\
    \        }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp93hnjkeb.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel_index = 0;\n    let mut\
    \ last_consonant_index = 0;\n    for (i, c) in word.chars().enumerate() {\n  \
    \      if vowels.contains(&c) {\n            last_vowel_index = i;\n        }\
    \ else {\n            last_consonant_index = i;\n        }\n        if last_vowel_index\
    \ > last_consonant_index {\n            result = word[last_vowel_index..].to_string();\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ogurt\"`,\n right: `\"u\"`', /tmp/tmpb6fpsp12.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = String::new();\n    let mut last_consonant = String::new();\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    for c in word.chars() {\n        if vowels.contains(&c)\
    \ {\n            last_vowel = c.to_string();\n        } else {\n            last_consonant\
    \ = c.to_string();\n        }\n        if last_vowel != \"\" && last_consonant\
    \ != \"\" {\n            result = last_vowel.clone();\n            break;\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp3tcia7jq.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut vowel_found = false;\n  \
    \  let mut consonant_found = false;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \           last_vowel = i;\n            vowel_found = true;\n        } else {\n\
    \            last_consonant = i;\n            consonant_found = true;\n      \
    \  }\n        if vowel_found && consonant_found {\n            result = word[last_vowel..last_consonant].to_string();\n\
    \            vowel_found = false;\n            consonant_found = false;\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''begin <= end (1 <= 0) when slicing `yogurt`'',
    /tmp/tmp5i_21m4w.rs:22:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev_is_vowel\
    \ = false;\n    let mut prev_is_consonant = false;\n    let mut prev_char = '\
    \ ';\n    for c in word.chars() {\n        if is_vowel(c) {\n            if prev_is_consonant\
    \ {\n                result.push(c);\n                break;\n            }\n\
    \            prev_is_vowel = true;\n        } else {\n            if prev_is_vowel\
    \ {\n                prev_is_consonant = true;\n            }\n        }\n   \
    \     prev_char = c;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpqfk5woyg.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_char = ' ';\n    for\
    \ (i, c) in word.chars().enumerate() {\n        if c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u' {\n            last_vowel = i;\n        } else {\n\
    \            last_consonant = i;\n        }\n        if last_vowel > last_consonant\
    \ && last_char != c {\n            result = c.to_string();\n        }\n      \
    \  last_char = c;\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp5fbz2j_s.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![];\n    let mut consonants =\
    \ vec![];\n    let mut result = String::new();\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let\
    \ mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n   \
    \ let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n\
    \    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n\
    \    let mut z = 0;\n    let mut a = 0;\n    let mut b = 0;\n    let mut c = 0;\n\
    \    let mut d = 0;\n    let mut e = 0;\n    let mut f = 0;\n    let mut g = 0;\n\
    \    let mut h = 0;\n    let mut ii = 0;\n    let mut jj = 0;\n    let mut kk\
    \ = 0;\n    let mut ll = 0;\n    let mut mm = 0;\n    let mut nn = 0;\n    let\
    \ mut oo = 0;\n    let mut pp = 0;\n    let mut qq = 0;\n    let mut rr = 0;\n\
    \    let mut ss = 0;\n    let mut tt = 0;\n    let mut uu = 0;\n    let mut vv\
    \ = 0;\n    let mut ww = 0;\n    let mut xx = 0;\n    let mut yy = 0;\n    let\
    \ mut zz = 0;\n    let mut aa = 0;\n    let mut bb = 0;\n    let mut cc = 0;\n\
    \    let mut dd = 0;\n    let mut ee = 0;\n    let mut ff = 0;\n    let mut gg\
    \ = 0;\n    let mut hh = 0;\n    let mut iii = 0;\n    let mut jjj = 0;\n    let\
    \ mut kkk = 0;\n    let mut lll = 0;\n    let mut mmm = 0;\n    let\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpnhqmtll4.rs:69:1\n  \
    \ |\n69 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_index = word.len();\n    let mut last_consonant_index = word.len();\n\
    \    let mut first_vowel_index = word.len();\n    let mut current_vowel_index\
    \ = word.len();\n    let mut current_vowel = String::new();\n    let vowels =\
    \ vec!['a', 'e', 'i', 'o', 'u'];\n    for (i, c) in word.chars().enumerate() {\n\
    \        if vowels.contains(&c) {\n            if first_vowel_index == word.len()\
    \ {\n                first_vowel_index = i;\n            }\n            current_vowel_index\
    \ = i;\n            current_vowel = c.to_string();\n        } else {\n       \
    \     if current_vowel_index < last_consonant_index {\n                last_consonant_index\
    \ = i;\n                if last_consonant_index - current_vowel_index < closest_vowel_index\
    \ {\n                    closest_vowel_index = last_consonant_index - current_vowel_index;\n\
    \                    closest_vowel = current_vowel;\n                }\n     \
    \       }\n        }\n    }\n    if closest_vowel_index == word.len() {\n    \
    \    return String::new();\n    }\n    if closest_vowel_index == first_vowel_index\
    \ {\n        return String::new();\n    }\n    closest_vowel\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `current_vowel`\n  --> /tmp/tmpyu4vrl09.rs:27:37\n\
    \   |\n13 |     let mut current_vowel = String::new();\n   |         -----------------\
    \ move occurs because `current_vowel` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n21 |             current_vowel = c.to_string();\n   |\
    \             ------------- this reinitialization might get skipped\n...\n27 |\
    \                     closest_vowel = current_vowel;\n   |                   \
    \                  ^^^^^^^^^^^^^ value moved here, in previous iteration of loop\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_consonant\
    \ = false;\n    let mut last_vowel = false;\n    let mut last_vowel_pos = 0;\n\
    \    let mut last_consonant_pos = 0;\n    let mut pos = 0;\n    for c in word.chars()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \           if last_consonant {\n                if last_vowel {\n           \
    \         if pos - last_consonant_pos < last_vowel_pos - last_consonant_pos {\n\
    \                        result = c.to_string();\n                    }\n    \
    \            } else {\n                    result = c.to_string();\n         \
    \       }\n                last_vowel = true;\n                last_vowel_pos\
    \ = pos;\n            }\n        } else {\n            if last_vowel {\n     \
    \           last_consonant = true;\n                last_consonant_pos = pos;\n\
    \            }\n        }\n        pos += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpytx6mtpk.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel = 0;\n    let mut last_consonant\
    \ = 0;\n    for (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c)\
    \ {\n            last_vowel = i;\n        } else {\n            last_consonant\
    \ = i;\n        }\n        if last_vowel > last_consonant {\n            result\
    \ = c.to_string();\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp90thep8r.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_index = word.len();\n    let mut last_consonant_index = word.len();\n\
    \    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut consonants = vec!['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    consonants.append(&mut vowels);\n    for (i, c) in\
    \ word.chars().enumerate().rev() {\n        if consonants.contains(&c) {\n   \
    \         if last_consonant_index - i > 1 && closest_vowel_index - i > 1 {\n \
    \               return closest_vowel;\n            }\n            last_consonant_index\
    \ = i;\n        } else {\n            if last_consonant_index - i < closest_vowel_index\
    \ - i {\n                closest_vowel = c.to_string();\n                closest_vowel_index\
    \ = i;\n            }\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmpgm8vosvd.rs:14:44\n   |\n14 |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n   |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmpgm8vosvd.rs:14:19\n    |\n14  |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel_pos\
    \ = 0;\n    let mut last_consonant_pos = 0;\n    let mut last_char_is_vowel =\
    \ false;\n    let mut last_char_is_consonant = false;\n    let mut last_char_pos\
    \ = 0;\n    let mut last_char = ' ';\n    let mut found_vowel = false;\n    let\
    \ mut found_consonant = false;\n    let mut found_vowel_pos = 0;\n    let mut\
    \ found_consonant_pos = 0;\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut i = 0;\n    for c in word.chars() {\n        if vowels.contains(&c)\
    \ {\n            if last_char_is_consonant {\n                found_vowel = true;\n\
    \                found_vowel_pos = i;\n            }\n            last_char_is_vowel\
    \ = true;\n            last_char_is_consonant = false;\n            last_vowel_pos\
    \ = i;\n        } else {\n            if last_char_is_vowel {\n              \
    \  found_consonant = true;\n                found_consonant_pos = i;\n       \
    \     }\n            last_char_is_vowel = false;\n            last_char_is_consonant\
    \ = true;\n            last_consonant_pos = i;\n        }\n        last_char =\
    \ c;\n        last_char_pos = i;\n        i += 1;\n    }\n    if found_vowel &&\
    \ found_consonant {\n        if found_vowel_pos > found_consonant_pos {\n    \
    \        result.push(word.chars().nth(found_vowel_pos).unwrap());\n        } else\
    \ {\n            result.push(word.chars().nth(found_consonant_pos).unwrap());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"r\"`,\n right: `\"u\"`', /tmp/tmp0710vmwf.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut closest_vowel\
    \ = String::new();\n    let mut closest_distance = word.len();\n    for (i, c)\
    \ in word.chars().enumerate() {\n        if vowels.contains(c) {\n           \
    \ if i > 0 && i < word.len() - 1 {\n                let distance = word.len()\
    \ - i;\n                if distance < closest_distance {\n                   \
    \ closest_distance = distance;\n                    closest_vowel = c.to_string();\n\
    \                }\n            }\n        }\n    }\n    closest_vowel\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpmpmzhsvq.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut index = word.len() - 1;\n    let mut\
    \ prev_vowel = false;\n    let mut prev_consonant = false;\n    while index >=\
    \ 0 {\n        let c = word.chars().nth(index).unwrap();\n        if vowels.contains(&c)\
    \ {\n            if prev_consonant {\n                result.push(c);\n      \
    \          break;\n            }\n            prev_vowel = true;\n        } else\
    \ {\n            if prev_vowel {\n                result.push(c);\n          \
    \      break;\n            }\n            prev_consonant = true;\n        }\n\
    \        index -= 1;\n    }\n    result.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpd90z1ez8.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut word = word.chars().collect::<Vec<char>>();\n\
    \    word.reverse();\n    let mut result = String::new();\n    let mut prev_is_consonant\
    \ = false;\n    for c in word {\n        if c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u' {\n            if prev_is_consonant {\n               \
    \ result.push(c);\n                break;\n            }\n        } else {\n \
    \           prev_is_consonant = true;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpnue9zywz.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev_char\
    \ = ' ';\n    let mut prev_vowel = ' ';\n    for c in word.chars().rev() {\n \
    \       if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n      \
    \      if prev_char != ' ' && prev_char != 'a' && prev_char != 'e' && prev_char\
    \ != 'i' && prev_char != 'o' && prev_char != 'u' {\n                result.push(c);\n\
    \                break;\n            }\n            prev_vowel = c;\n        }\n\
    \        prev_char = c;\n    }\n    if result.is_empty() {\n        result.push(prev_vowel);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpmd897glv.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut last_vowel = None;\n    let mut last_consonant\
    \ = None;\n    for c in word.chars().rev() {\n        if c.is_vowel() {\n    \
    \        last_vowel = Some(c);\n        } else if last_vowel.is_some() {\n   \
    \         last_consonant = Some(c);\n            break;\n        }\n    }\n  \
    \  if last_vowel.is_some() && last_consonant.is_some() {\n        last_vowel.unwrap().to_string()\n\
    \    } else {\n        \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpvxjkf2zb.rs:11:14\n   |\n11 |         if c.is_vowel() {\n\
    \   |              ^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ last_vowel = String::new();\n    let mut last_consonant = String::new();\n \
    \   let mut last_vowel_pos = 0;\n    let mut last_consonant_pos = 0;\n    let\
    \ mut i = 0;\n    for c in word.chars() {\n        if is_vowel(c) {\n        \
    \    last_vowel = c.to_string();\n            last_vowel_pos = i;\n        } else\
    \ {\n            last_consonant = c.to_string();\n            last_consonant_pos\
    \ = i;\n        }\n        i += 1;\n    }\n    if last_vowel_pos > last_consonant_pos\
    \ {\n        closest_vowel = last_vowel;\n    }\n    closest_vowel\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpiqkfqb0v.rs:15:12\n\
    \   |\n15 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ word = word.chars().collect::<Vec<char>>();\n    let mut index = word.len()\
    \ - 1;\n    let mut result = String::new();\n    while index > 0 {\n        if\
    \ vowels.contains(&word[index]) {\n            if !vowels.contains(&word[index\
    \ - 1]) {\n                result.push(word[index]);\n                break;\n\
    \            }\n        }\n        index -= 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmperb1ljnk.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_consonant\
    \ = String::new();\n    let mut last_vowel = String::new();\n    let mut last_vowel_index\
    \ = 0;\n    let mut last_consonant_index = 0;\n    let mut last_index = 0;\n \
    \   let mut index = 0;\n    let mut is_vowel = false;\n    let mut is_consonant\
    \ = false;\n    let mut is_first_vowel = false;\n    let mut is_first_consonant\
    \ = false;\n    let mut is_last_vowel = false;\n    let mut is_last_consonant\
    \ = false;\n    let mut is_last_vowel_first = false;\n    let mut is_last_consonant_first\
    \ = false;\n    let mut is_last_vowel_last = false;\n    let mut is_last_consonant_last\
    \ = false;\n    let mut is_first_vowel_first = false;\n    let mut is_first_consonant_first\
    \ = false;\n    let mut is_first_vowel_last = false;\n    let mut is_first_consonant_last\
    \ = false;\n    let mut is_first_vowel_first_last = false;\n    let mut is_first_consonant_first_last\
    \ = false;\n    let mut is_last_vowel_first_last = false;\n    let mut is_last_consonant_first_last\
    \ = false;\n    let mut is_first_vowel_first_last_first = false;\n    let mut\
    \ is_first_consonant_first_last_first = false;\n    let mut is_last_vowel_first_last_first\
    \ = false;\n    let mut is_last_consonant_first_last_first = false;\n    let mut\
    \ is_first_vowel_first_last_last = false;\n    let mut is_first_consonant_first_last_last\
    \ = false;\n    let mut is_last_vowel_first_last_last = false;\n    let mut is_last_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp75_rvgrz.rs:40:21\n   |\n\
    40 |     let mut is_last_\n   |                     ^ help: add `;` here\n41 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp75_rvgrz.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_vowel_index = word.len();\n\
    \    for (i, c) in word.chars().enumerate().rev() {\n        if vowels.contains(&c)\
    \ {\n            if i < closest_vowel_index {\n                closest_vowel_index\
    \ = i;\n                closest_vowel = c.to_string();\n            }\n      \
    \  } else {\n            if !closest_vowel.is_empty() {\n                break;\n\
    \            }\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmpv9ux9egr.rs:11:44\n   |\n11 |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n   |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmpv9ux9egr.rs:11:19\n    |\n11  |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut last_consonant = word.len();\n \
    \   let mut last_vowel = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if is_vowel(c) {\n            last_vowel = i;\n            let distance\
    \ = last_consonant - last_vowel;\n            if distance < closest_distance &&\
    \ distance > 1 {\n                closest_distance = distance;\n             \
    \   closest_vowel = c.to_string();\n            }\n        } else {\n        \
    \    last_consonant = i;\n        }\n    }\n    closest_vowel\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpuk65mnve.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowel_index\
    \ = 0;\n    let mut vowel_distance = 0;\n    let mut prev_is_consonant = false;\n\
    \    let mut prev_is_vowel = false;\n    let mut prev_vowel_index = 0;\n    let\
    \ mut prev_vowel_distance = 0;\n    let mut prev_consonant_index = 0;\n    let\
    \ mut prev_consonant_distance = 0;\n    let mut prev_char = ' ';\n    let mut\
    \ prev_prev_char = ' ';\n    let mut prev_prev_is_consonant = false;\n    let\
    \ mut prev_prev_is_vowel = false;\n    let mut prev_prev_vowel_index = 0;\n  \
    \  let mut prev_prev_vowel_distance = 0;\n    let mut prev_prev_consonant_index\
    \ = 0;\n    let mut prev_prev_consonant_distance = 0;\n    for (index, c) in word.chars().enumerate()\
    \ {\n        let is_vowel = match c {\n            'a' | 'e' | 'i' | 'o' | 'u'\
    \ => true,\n            _ => false,\n        };\n        let is_consonant = !is_vowel;\n\
    \        if is_vowel {\n            if prev_is_consonant {\n                vowel_index\
    \ = index;\n                vowel_distance = index - prev_consonant_index;\n \
    \           }\n            if prev_prev_is_consonant {\n                prev_vowel_index\
    \ = index;\n                prev_vowel_distance = index - prev_prev_consonant_index;\n\
    \            }\n        }\n        if is_consonant {\n            if prev_is_vowel\
    \ {\n                consonant_index = index;\n                consonant_distance\
    \ = index - prev_vowel_index;\n            }\n            if prev_prev_is_vowel\
    \ {\n                prev_consonant_index = index;\n                prev_consonant_distance\
    \ = index - prev_prev_vowel_index;\n           \n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpa2zuhomw.rs:67:3\n\
    \   |\n7  | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n25 |     for (index,\
    \ c) in word.chars().enumerate() {\n   |                                     \
    \           - unclosed delimiter\n...\n41 |         if is_consonant {\n   |  \
    \                       - unclosed delimiter\n...\n46 |             if prev_prev_is_vowel\
    \ {\n   |                                   - this delimiter might not be properly\
    \ closed...\n...\n50 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n67 | }\n   |   ^\n\nerror[E0425]: cannot find value `consonant_index` in\
    \ this scope\n  --> /tmp/tmpa2zuhomw.rs:43:17\n   |\n43 |                 consonant_index\
    \ = index;\n   |                 ^^^^^^^^^^^^^^^ help: a local variable with a\
    \ similar name exists: `prev_consonant_index`\n\nerror[E0425]: cannot find value\
    \ `consonant_distance` in this scope\n  --> /tmp/tmpa2zuhomw.rs:44:17\n   |\n\
    44 |                 consonant_distance = index - prev_vowel_index;\n   |    \
    \             ^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `prev_consonant_distance`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa2zuhomw.rs:25:5\n\
    \   |\n7  |   fn get_closest_vowel(word: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n25 | /     for (index, c) in word.chars().enumerate() {\n26 | |         let\
    \ is_vowel = match c {\n27 | |             'a' | 'e' | 'i' | 'o' | 'u' => true,\n\
    28 | |             _ => false,\n...  |\n66 | |     assert_eq!(candidate(String::from(\"\
    Above\")), String::from(\"o\"));\n67 | | }\n   | |__^ expected struct `String`,\
    \ found `()`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowel_pos\
    \ = word.len();\n    let mut consonant_pos = word.len();\n    let mut i = word.len()\
    \ - 1;\n    while i >= 0 {\n        let c = word.chars().nth(i).unwrap();\n  \
    \      if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n       \
    \     vowel_pos = i;\n            if consonant_pos != word.len() {\n         \
    \       break;\n            }\n        } else {\n            consonant_pos = i;\n\
    \            if vowel_pos != word.len() {\n                break;\n          \
    \  }\n        }\n        i -= 1;\n    }\n    if vowel_pos != word.len() && consonant_pos\
    \ != word.len() {\n        result.push(word.chars().nth(vowel_pos).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpatq2pxvm.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_consonant\
    \ = 0;\n    let mut last_vowel = 0;\n    let mut last_vowel_index = 0;\n    let\
    \ mut last_consonant_index = 0;\n    let mut index = 0;\n    for c in word.chars()\
    \ {\n        if is_vowel(c) {\n            last_vowel = index;\n            last_vowel_index\
    \ = index;\n        } else {\n            last_consonant = index;\n          \
    \  last_consonant_index = index;\n        }\n        index += 1;\n    }\n    if\
    \ last_vowel_index > last_consonant_index {\n        result = word.chars().nth(last_vowel_index).unwrap().to_string();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpo5_szmcu.rs:15:12\n\
    \   |\n15 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev_vowel\
    \ = false;\n    let mut prev_consonant = false;\n    for c in word.chars().rev()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \           if prev_consonant {\n                result.push(c);\n           \
    \     break;\n            }\n            prev_vowel = true;\n        } else {\n\
    \            if prev_vowel {\n                result.push(c);\n              \
    \  break;\n            }\n            prev_consonant = true;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpaelfk2on.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748610
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_consonant\
    \ = String::new();\n    let mut last_vowel = String::new();\n    let mut last_vowel_index\
    \ = 0;\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            last_vowel = c.to_string();\n\
    \            last_vowel_index = i;\n        } else {\n            last_consonant\
    \ = c.to_string();\n        }\n        if last_consonant != \"\" && last_vowel\
    \ != \"\" {\n            result = last_vowel;\n            break;\n        }\n\
    \    }\n    if last_vowel_index == word.len() - 1 {\n        result = String::new();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp5m3lgdep.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut last_consonant = word.len();\n \
    \   let mut last_vowel = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if is_vowel(c) {\n            last_vowel = i;\n            if last_consonant\
    \ != word.len() {\n                let distance = last_vowel - last_consonant;\n\
    \                if distance < closest_distance {\n                    closest_distance\
    \ = distance;\n                    closest_vowel = c.to_string();\n          \
    \      }\n            }\n        } else {\n            last_consonant = i;\n \
    \       }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpb89grgj3.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel_index\
    \ = 0;\n    let mut last_consonant_index = 0;\n    let mut last_vowel_char = '\
    \ ';\n    let mut last_consonant_char = ' ';\n    let mut found_vowel = false;\n\
    \    let mut found_consonant = false;\n    let mut found_vowel_between_consonants\
    \ = false;\n    let mut found_consonant_between_vowels = false;\n    let mut found_vowel_between_consonants_index\
    \ = 0;\n    let mut found_consonant_between_vowels_index = 0;\n    let mut found_vowel_between_consonants_char\
    \ = ' ';\n    let mut found_consonant_between_vowels_char = ' ';\n    let mut\
    \ found_vowel_between_consonants_distance = 0;\n    let mut found_consonant_between_vowels_distance\
    \ = 0;\n    let mut distance = 0;\n    let mut distance_between_vowels = 0;\n\
    \    let mut distance_between_consonants = 0;\n    let mut distance_between_vowels_and_consonants\
    \ = 0;\n    let mut distance_between_consonants_and_vowels = 0;\n    let mut distance_between_vowels_and_consonants_index\
    \ = 0;\n    let mut distance_between_consonants_and_vowels_index = 0;\n    let\
    \ mut distance_between_vowels_and_consonants_char = ' ';\n    let mut distance_between_consonants_and_vowels_char\
    \ = ' ';\n    let mut distance_between_vowels_and_consonants_distance = 0;\n \
    \   let mut distance_between_consonants_and_vowels_distance = 0;\n    let mut\
    \ distance_between_vowels_and_consonants_distance_index = 0;\n    let mut distance_between_consonants_and_vowels_distance_index\
    \ = 0;\n    let mut\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpkppf7axp.rs:37:1\n\
    \   |\n37 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_vowel_pos\
    \ = 0;\n    let mut last_consonant_pos = 0;\n    let mut last_char_is_vowel =\
    \ false;\n    let mut last_char_is_consonant = false;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if is_vowel(c) {\n            last_vowel_pos = i;\n            last_char_is_vowel\
    \ = true;\n            last_char_is_consonant = false;\n        } else {\n   \
    \         last_consonant_pos = i;\n            last_char_is_vowel = false;\n \
    \           last_char_is_consonant = true;\n        }\n        if last_char_is_vowel\
    \ && last_char_is_consonant {\n            result = word[last_vowel_pos..last_vowel_pos+1].to_string();\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpcdzoymg9.rs:14:12\n\
    \   |\n14 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut result = String::new();\n\
    \    let mut last_vowel_pos = 0;\n    let mut last_consonant_pos = 0;\n    let\
    \ mut last_vowel_char = ' ';\n    let mut last_consonant_char = ' ';\n    let\
    \ mut last_char = ' ';\n    let mut last_char_pos = 0;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(c) {\n            last_vowel_pos = i;\n      \
    \      last_vowel_char = c;\n        } else {\n            last_consonant_pos\
    \ = i;\n            last_consonant_char = c;\n        }\n        if last_vowel_pos\
    \ > last_consonant_pos {\n            if last_vowel_pos - last_consonant_pos <\
    \ last_char_pos - last_consonant_pos {\n                last_char = last_vowel_char;\n\
    \                last_char_pos = last_vowel_pos;\n            }\n        }\n \
    \   }\n    if last_char_pos > last_consonant_pos {\n        result.push(last_char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpv13h95u4.rs:25:54

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ last_consonant = String::new();\n    let mut last_vowel = String::new();\n \
    \   let mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n   \
    \ let mut index = 0;\n    for c in word.chars() {\n        if c.is_alphabetic()\
    \ {\n            if c.is_vowel() {\n                last_vowel = c.to_string();\n\
    \                last_vowel_index = index;\n            } else {\n           \
    \     last_consonant = c.to_string();\n                last_consonant_index =\
    \ index;\n            }\n        }\n        index += 1;\n    }\n    if last_vowel_index\
    \ > last_consonant_index {\n        closest_vowel = last_vowel;\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpfmd3e7e2.rs:16:18\n   |\n16 |             if c.is_vowel()\
    \ {\n   |                  ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut last_consonant = word.len();\n \
    \   let mut last_vowel = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if is_vowel(c) {\n            last_vowel = i;\n            if last_consonant\
    \ < last_vowel {\n                let distance = last_vowel - last_consonant;\n\
    \                if distance < closest_distance {\n                    closest_distance\
    \ = distance;\n                    closest_vowel = c.to_string();\n          \
    \      }\n            }\n        } else {\n            last_consonant = i;\n \
    \       }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpp46ebw2l.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut chars = word.chars().collect::<Vec<char>>();\n\
    \    let mut last_vowel = 0;\n    let mut last_consonant = 0;\n    let mut index\
    \ = 0;\n    for c in chars.iter() {\n        if vowels.contains(c) {\n       \
    \     last_vowel = index;\n        } else {\n            last_consonant = index;\n\
    \        }\n        index += 1;\n    }\n    if last_vowel > last_consonant {\n\
    \        result.push(chars[last_vowel]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpszi4c0wg.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut last_vowel_pos\
    \ = 0;\n    let mut last_consonant_pos = 0;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if is_vowel(c) {\n            last_vowel_pos = i;\n        } else\
    \ {\n            last_consonant_pos = i;\n        }\n        if last_vowel_pos\
    \ > last_consonant_pos {\n            res = word[last_vowel_pos..=last_vowel_pos].to_string();\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpjgqfcx6h.rs:12:12\n\
    \   |\n12 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_vowel_index = word.len();\n    let mut last_consonant_index = word.len();\n\
    \    for (i, c) in word.chars().enumerate() {\n        if c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' {\n            if i > last_consonant_index\
    \ && i - last_consonant_index < closest_vowel_index {\n                closest_vowel\
    \ = c.to_string();\n                closest_vowel_index = i - last_consonant_index;\n\
    \            }\n        } else {\n            last_consonant_index = i;\n    \
    \    }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmps3ticm3o.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut last_consonant = 0;\n    for (i,\
    \ c) in word.chars().enumerate() {\n        if c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' {\n            if i - last_consonant < closest_distance\
    \ {\n                closest_distance = i - last_consonant;\n                closest_vowel\
    \ = c.to_string();\n            }\n        } else {\n            last_consonant\
    \ = i;\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpxi5o7_nd.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748611
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut last_vowel = 0;\n    let mut last_consonant\
    \ = 0;\n    let mut last_char = ' ';\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            last_vowel = i;\n        }\
    \ else {\n            last_consonant = i;\n            if last_vowel < last_consonant\
    \ {\n                result = word[last_vowel..last_consonant].to_string();\n\
    \            }\n        }\n        last_char = c;\n    }\n    if last_vowel <\
    \ last_consonant {\n        result = word[last_vowel..last_consonant].to_string();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ur\"`,\n right: `\"u\"`', /tmp/tmp86hj3nul.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut last_consonant\
    \ = 0;\n    let mut last_vowel = 0;\n    let mut last_vowel_pos = 0;\n    let\
    \ mut last_consonant_pos = 0;\n    let mut vowel_pos = 0;\n    let mut consonant_pos\
    \ = 0;\n    let mut vowel_found = false;\n    let mut consonant_found = false;\n\
    \    let mut vowel_count = 0;\n    let mut consonant_count = 0;\n    let mut vowel_pos_count\
    \ = 0;\n    let mut consonant_pos_count = 0;\n    let mut vowel_pos_arr = [0;\
    \ 10];\n    let mut consonant_pos_arr = [0; 10];\n    let mut vowel_arr = [0;\
    \ 10];\n    let mut consonant_arr = [0; 10];\n    let mut vowel_pos_arr_count\
    \ = 0;\n    let mut consonant_pos_arr_count = 0;\n    let mut vowel_arr_count\
    \ = 0;\n    let mut consonant_arr_count = 0;\n    let mut vowel_pos_arr_index\
    \ = 0;\n    let mut consonant_pos_arr_index = 0;\n    let mut vowel_arr_index\
    \ = 0;\n    let mut consonant_arr_index = 0;\n    let mut vowel_pos_arr_index_count\
    \ = 0;\n    let mut consonant_pos_arr_index_count = 0;\n    let mut vowel_arr_index_count\
    \ = 0;\n    let mut consonant_arr_index_count = 0;\n    let mut vowel_pos_arr_index_count_arr\
    \ = [0; 10];\n    let mut consonant_pos_arr_index_count_arr = [0; 10];\n    let\
    \ mut vowel_arr_index_count_arr = [0; 10];\n    let mut consonant_arr_index_count_arr\
    \ = [0; 10];\n    let mut vowel_pos_arr_index_count_arr_count = 0;\n    let mut\
    \ consonant_pos_arr_index_count_arr_count = 0;\n    let mut vowel_arr_index_count\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1sbr1ws5.rs:43:34\n   |\n\
    43 |     let mut vowel_arr_index_count\n   |                                 \
    \ ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp1sbr1ws5.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String)\
    \ -> String {\n  |    -----------------                  ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = String::new();\n    let mut closest_distance = word.len();\n\
    \    let mut last_consonant = None;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            if let Some(last_consonant)\
    \ = last_consonant {\n                if i - last_consonant < closest_distance\
    \ {\n                    closest_distance = i - last_consonant;\n            \
    \        closest_vowel = c.to_string();\n                }\n            }\n  \
    \      } else {\n            last_consonant = Some(i);\n        }\n    }\n   \
    \ closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpitm6z23_.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748613
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut last_vowel_index = 0;\n    let mut\
    \ last_consonant_index = 0;\n    for (i, c) in word.chars().enumerate() {\n  \
    \      if vowels.contains(&c) {\n            last_vowel_index = i;\n        }\
    \ else {\n            last_consonant_index = i;\n        }\n        if last_vowel_index\
    \ < last_consonant_index {\n            result = word[last_vowel_index..last_consonant_index].to_string();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ur\"`,\n right: `\"u\"`', /tmp/tmpgpxknaqm.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut res = String::new();\n\
    \    let mut last_consonant = 0;\n    let mut last_vowel = 0;\n    for (i, c)\
    \ in word.chars().enumerate() {\n        if vowels.contains(c) {\n           \
    \ last_vowel = i;\n        } else {\n            last_consonant = i;\n       \
    \ }\n        if last_consonant > last_vowel {\n            res = word[last_vowel..last_consonant].to_string();\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ur\"`,\n right: `\"u\"`', /tmp/tmpsu4tn5rx.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748612
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ closest_distance = word.len();\n    let mut last_consonant = 0;\n    let mut\
    \ last_vowel = 0;\n    for (i, c) in word.chars().enumerate() {\n        if is_vowel(c)\
    \ {\n            last_vowel = i;\n            if last_vowel - last_consonant <\
    \ closest_distance {\n                closest_distance = last_vowel - last_consonant;\n\
    \                closest_vowel = c.to_string();\n            }\n        } else\
    \ {\n            last_consonant = i;\n        }\n    }\n    closest_vowel\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpyqvbn6wy.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748612
