language: rs
name: HumanEval_112_reverse_delete
results:
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let c: HashSet<char>\
    \ = c.chars().collect();\n    s.retain(|c| !c.is_ascii_whitespace());\n    s.retain(|c|\
    \ !c.is_ascii_punctuation());\n    s.retain(|c| !c.is_ascii_control());\n    s.retain(|c|\
    \ !c.is_ascii_digit());\n    s.retain(|c| !c.is_ascii_lowercase());\n    s.retain(|c|\
    \ !c.is_ascii_uppercase());\n    s.retain(|c| !c.is_ascii_alphabetic());\n   \
    \ s.retain(|c| !c.is_ascii_alphanumeric());\n    s.retain(|c| !c.is_ascii_graphic());\n\
    \    s.retain(|c| !c.is_ascii_whitespace());\n    s.retain(|c| !c.is_ascii_lowercase());\n\
    \    s.retain(|c| !c.is_ascii_uppercase());\n    s.retain(|c| !c.is_ascii_alphabetic());\n\
    \    s.retain(|c| !c.is_ascii_alphanumeric());\n    s.retain(|c| !c.is_ascii_graphic());\n\
    \    s.retain(|c| !c.is_ascii_whitespace());\n    s.retain(|c| !c.is_ascii_lowercase());\n\
    \    s.retain(|c| !c.is_ascii_uppercase());\n    s.retain(|c| !c.is_ascii_alphabetic());\n\
    \    s.retain(|c| !c.is_ascii_alphanumeric());\n    s.retain(|c| !c.is_ascii_graphic());\n\
    \    s.retain(|c| !c.is_as\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp2m75vq0v.rs:31:13\n\
    \   |\n7  | fn reverse_delete(s: String, c: String) -> (String, bool) {\n   |\
    \                                                           - closing delimiter\
    \ possibly meant for this\n...\n31 |     s.retain(|c| !c.is_as\n   |         \
    \    ^ unclosed delimiter\n32 | }\n   | ^ mismatched closing delimiter\n\nerror[E0412]:\
    \ cannot find type `HashSet` in this scope\n --> /tmp/tmp2m75vq0v.rs:9:12\n  |\n\
    9 |     let c: HashSet<char> = c.chars().collect();\n  |            ^^^^^^^ not\
    \ found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use\
    \ std::collections::HashSet;\n  |\n\nerror[E0610]: `char` is a primitive type\
    \ and therefore doesn't have fields\n  --> /tmp/tmp2m75vq0v.rs:31:21\n   |\n31\
    \ |     s.retain(|c| !c.is_as\n   |                     ^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2m75vq0v.rs:31:5\n   |\n7  |   fn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n   |                               \
    \               -------------- expected `(String, bool)` because of return type\n\
    ...\n31 | /     s.retain(|c| !c.is_as\n32 | | }\n   | |_^ expected tuple, found\
    \ `()`\n   |\n   = note:  expected tuple `(String, bool)`\n           found unit\
    \ type `()`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0412, E0610.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyo8hogmx.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjoy00mri.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let c: Vec<char>\
    \ = c.chars().collect();\n    for i in c {\n        s = s.replace(i, \"\");\n\
    \    }\n    let mut s1 = s.clone();\n    s1.make_ascii_lowercase();\n    let mut\
    \ s2 = s1.clone();\n    s2.chars().rev().collect::<String>();\n    (s, s1 == s2)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"bcd\", true)`,\n right: `(\"bcd\", false)`', /tmp/tmpsf30cami.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyo8hogmx.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s_chars: Vec<char> = s.chars().collect();\n\
    \    let c_chars: Vec<char> = c.chars().collect();\n    s_chars.retain(|x| !c_chars.contains(x));\n\
    \    let s_chars_rev: Vec<char> = s_chars.iter().rev().cloned().collect();\n \
    \   (s_chars.iter().collect(), s_chars == s_chars_rev)\n}\n\nfn main() {\n   \
    \ let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    c.push_str(&c.chars().rev().collect::<String>());\n    let mut i = 0;\n\
    \    while i < s.len() {\n        if c.contains(s.chars().nth(i).unwrap()) {\n\
    \            s.remove(i);\n        } else {\n            i += 1;\n        }\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpq0jzdsov.rs:19:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n19 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjoy00mri.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjoy00mri.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = s;\n    for ch\
    \ in c.chars() {\n        result = result.replace(ch, \"\");\n    }\n    let mut\
    \ result_chars: Vec<char> = result.chars().collect();\n    result_chars.reverse();\n\
    \    let result_reversed: String = result_chars.into_iter().collect();\n    (result,\
    \ result == result_reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp2rn66qmp.rs:15:14\n\
    \   |\n8  |     let mut result = s;\n   |         ---------- move occurs because\
    \ `result` has type `String`, which does not implement the `Copy` trait\n...\n\
    15 |     (result, result == result_reversed)\n   |      ------  ^^^^^^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    let mut result = String::new();\n    let mut check = true;\n    for\
    \ i in s.chars() {\n        if !c.contains(i) {\n            result.push(i);\n\
    \        }\n    }\n    for i in 0..result.len() / 2 {\n        if result.chars().nth(i)\
    \ != result.chars().nth(result.len() - i - 1) {\n            check = false;\n\
    \        }\n    }\n    (result, check)\n}\n\nfn main() {\n    let candidate =\
    \ reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjoy00mri.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpls1xqejb.rs:8:50\n\
    \  |\n8 |     let mut s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                  ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    (s.iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmph4y5kg7t.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0277]: can't\
    \ compare `char` with `&char`\n  --> /tmp/tmph4y5kg7t.rs:11:28\n   |\n11 |   \
    \  (s.iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n   |       \
    \                     ^^ no implementation for `char == &char`\n   |\n   = help:\
    \ the trait `PartialEq<&char>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&char>>` for `Vec<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0412.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjoy00mri.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmppbpkbwlw.rs:8:9\n\
    \  |\n8 |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \  |         ----^\n  |         |\n  |         help: remove this `mut`\n  |\n\
    \  = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need\
    \ to be mutable\n --> /tmp/tmppbpkbwlw.rs:9:9\n  |\n9 |     let mut s_rev = s.clone();\n\
    \  |         ----^^^^^\n  |         |\n  |         help: remove this `mut`\n\n\
    error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmppbpkbwlw.rs:11:9\n   |\n\
    8  |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n11 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    let mut s = s.chars().collect::<Vec<char>>();\n    let mut c = c.chars().collect::<Vec<char>>();\n\
    \    s.retain(|&x| !c.contains(&x));\n    for i in s {\n        result.push(i);\n\
    \    }\n    (result, result == result.chars().rev().collect::<String>())\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp7_wnw9uf.rs:10:9\n\
    \   |\n10 |     let mut c = c.chars().collect::<Vec<char>>();\n   |         ----^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp7_wnw9uf.rs:15:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n15 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    (s.iter().collect(), s.iter().eq(s.iter().rev()))\n}\n\nfn main() {\n   \
    \ let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    s.retain(|x| !c.contains(x));\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpws6bpvqc.rs:9:9\n\
    \  |\n9 |     let mut c = c;\n  |         ----^\n  |         |\n  |         help:\
    \ remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]:\
    \ borrow of moved value: `s`\n  --> /tmp/tmpws6bpvqc.rs:11:9\n   |\n8  |     let\
    \ mut s = s;\n   |         ----- move occurs because `s` has type `String`, which\
    \ does not implement the `Copy` trait\n...\n11 |     (s, s == s.chars().rev().collect::<String>())\n\
    \   |      -  ^ value borrowed here after move\n   |      |\n   |      value moved\
    \ here\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjoy00mri.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let mut r = s.clone();\n    r.chars().rev().collect::<String>();\n\
    \    (s, s == r)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpevd8tq_1.rs:8:50\n\
    \  |\n8 |     let mut s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                  ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    c.push_str(&s);\n    s.retain(|x| !c.contains(x));\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpxnrk4a0r.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpwuhdaex3.rs:8:9\n\
    \  |\n8 |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \  |         ----^\n  |         |\n  |         help: remove this `mut`\n  |\n\
    \  = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need\
    \ to be mutable\n --> /tmp/tmpwuhdaex3.rs:9:9\n  |\n9 |     let mut s_rev = s.clone();\n\
    \  |         ----^^^^^\n  |         |\n  |         help: remove this `mut`\n\n\
    error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpwuhdaex3.rs:11:9\n   |\n\
    8  |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n11 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    let mut rev = s.clone();\n    rev.chars().rev();\n\
    \    (s, s == rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n  \
    \  assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpkiit1yaq.rs:8:9\n\
    \  |\n8 |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \  |         ----^\n  |         |\n  |         help: remove this `mut`\n  |\n\
    \  = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need\
    \ to be mutable\n --> /tmp/tmpkiit1yaq.rs:9:9\n  |\n9 |     let mut rev = s.clone();\n\
    \  |         ----^^^\n  |         |\n  |         help: remove this `mut`\n\nerror[E0382]:\
    \ borrow of moved value: `s`\n  --> /tmp/tmpkiit1yaq.rs:11:9\n   |\n8  |     let\
    \ mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n   |   \
    \      ----- move occurs because `s` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n11 |     (s, s == rev)\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    let mut s = s.chars().collect::<Vec<char>>();\n    let c = c.chars().collect::<Vec<char>>();\n\
    \    for i in 0..s.len() {\n        if !c.contains(&s[i]) {\n            result.push(s[i]);\n\
    \        }\n    }\n    let mut result_rev = result.chars().rev().collect::<String>();\n\
    \    (result, result == result_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmphfhzb8oz.rs:9:9\n\
    \  |\n9 |     let mut s = s.chars().collect::<Vec<char>>();\n  |         ----^\n\
    \  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmphfhzb8oz.rs:16:9\n\
    \   |\n16 |     let mut result_rev = result.chars().rev().collect::<String>();\n\
    \   |         ----^^^^^^^^^^\n   |         |\n   |         help: remove this `mut`\n\
    \nerror[E0382]: borrow of moved value: `result`\n  --> /tmp/tmphfhzb8oz.rs:17:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n17 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<Vec<_>>();\n    s.retain(|x| !c.contains(x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpjiortu_c.rs:12:9\n\
    \   |\n11 |     let s = s.iter().collect::<String>();\n   |         - move occurs\
    \ because `s` has type `String`, which does not implement the `Copy` trait\n12\
    \ |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    (s.iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmph4y5kg7t.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0277]: can't\
    \ compare `char` with `&char`\n  --> /tmp/tmph4y5kg7t.rs:11:28\n   |\n11 |   \
    \  (s.iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n   |       \
    \                     ^^ no implementation for `char == &char`\n   |\n   = help:\
    \ the trait `PartialEq<&char>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&char>>` for `Vec<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0412.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    for i in c.chars() {\n        s = s.replace(i, \"\");\n    }\n    let\
    \ mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>() == s\n}\n\
    \nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp099quad7.rs:14:5\n   |\n\
    7  | fn reverse_delete(s: String, c: String) -> (String, bool) {\n   |       \
    \                                     -------------- expected `(String, bool)`\
    \ because of return type\n...\n14 |     s_rev.chars().rev().collect::<String>()\
    \ == s\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple,\
    \ found `bool`\n   |\n   = note: expected tuple `(String, bool)`\n           \
    \    found type `bool`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmppbpkbwlw.rs:8:9\n\
    \  |\n8 |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \  |         ----^\n  |         |\n  |         help: remove this `mut`\n  |\n\
    \  = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need\
    \ to be mutable\n --> /tmp/tmppbpkbwlw.rs:9:9\n  |\n9 |     let mut s_rev = s.clone();\n\
    \  |         ----^^^^^\n  |         |\n  |         help: remove this `mut`\n\n\
    error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmppbpkbwlw.rs:11:9\n   |\n\
    8  |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n11 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjoy00mri.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    let s: Vec<char> = s.chars().collect();\n\
    \    let is_palindrome = s.iter().zip(s.iter().rev()).all(|(x, y)| x == y);\n\
    \    (s.into_iter().collect(), is_palindrome)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars()\
    \ {\n        s = s.replace(ch, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.iter().collect(), false);\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    (s.iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpwszju5ky.rs:14:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    c.push_str(&c.chars().rev().collect::<String>());\n    s.retain(|x|\
    \ !c.contains(x));\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn\
    \ main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp0li4o1vt.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    let mut chars = s.chars();\n    while let Some(c) = chars.next() {\n    \
    \    if !c.is_whitespace() && !c.is_alphanumeric() {\n            continue;\n\
    \        }\n        if !c.is_ascii_lowercase() {\n            result.push(c.to_ascii_lowercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    let mut\
    \ chars = c.chars();\n    while let Some(c) = chars.next() {\n        if !c.is_whitespace()\
    \ && !c.is_alphanumeric() {\n            continue;\n        }\n        if !c.is_ascii_lowercase()\
    \ {\n            result.retain(|x| x != c.to_ascii_lowercase());\n        } else\
    \ {\n            result.retain(|x| x != c);\n        }\n    }\n    (result, result\
    \ == result.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp8e7uadf4.rs:31:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n31 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s1 = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s2 = s1.clone();\n    s2.make_ascii_lowercase();\n\
    \    s2.chars().rev().collect::<String>() == s2\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmphxeagm0t.rs:8:51\n\
    \  |\n8 |     let mut s1 = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                   ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphxeagm0t.rs:11:5\n\
    \   |\n7  | fn reverse_delete(s: String, c: String) -> (String, bool) {\n   |\
    \                                            -------------- expected `(String,\
    \ bool)` because of return type\n...\n11 |     s2.chars().rev().collect::<String>()\
    \ == s2\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found\
    \ `bool`\n   |\n   = note: expected tuple `(String, bool)`\n               found\
    \ type `bool`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars()\
    \ {\n        s = s.replace(ch, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.iter().collect(), false);\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    (s.iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpwszju5ky.rs:14:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    let mut s = s.chars().collect::<Vec<char>>();\n    let c = c.chars().collect::<Vec<char>>();\n\
    \    for i in 0..s.len() {\n        if !c.contains(&s[i]) {\n            result.push(s[i]);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpynz0g131.rs:9:9\n\
    \  |\n9 |     let mut s = s.chars().collect::<Vec<char>>();\n  |         ----^\n\
    \  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpynz0g131.rs:16:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n16 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmppbpkbwlw.rs:8:9\n\
    \  |\n8 |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \  |         ----^\n  |         |\n  |         help: remove this `mut`\n  |\n\
    \  = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need\
    \ to be mutable\n --> /tmp/tmppbpkbwlw.rs:9:9\n  |\n9 |     let mut s_rev = s.clone();\n\
    \  |         ----^^^^^\n  |         |\n  |         help: remove this `mut`\n\n\
    error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmppbpkbwlw.rs:11:9\n   |\n\
    8  |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n11 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyo8hogmx.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let mut i = 0;\n    while i\
    \ < s.len() {\n        if c.contains(&s[i]) {\n            s.remove(i);\n    \
    \    } else {\n            i += 1;\n        }\n    }\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp09koxo0o.rs:19:9\n\
    \   |\n18 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    19 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    let mut result = String::new();\n    let mut is_palindrome = true;\n\
    \    for i in s.chars() {\n        if !c.contains(i) {\n            result.push(i);\n\
    \        }\n    }\n    for i in 0..result.len() / 2 {\n        if result.chars().nth(i)\
    \ != result.chars().nth(result.len() - i - 1) {\n            is_palindrome = false;\n\
    \            break;\n        }\n    }\n    (result, is_palindrome)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let is_palindrome = s.iter().eq(s.iter().rev());\n    (s.iter().collect(),\
    \ is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    let mut result = String::new();\n    let mut is_palindrome = true;\n\
    \    for i in 0..s.len() {\n        if !c.contains(s.chars().nth(i).unwrap())\
    \ {\n            result.push(s.chars().nth(i).unwrap());\n        }\n    }\n \
    \   for i in 0..result.len() {\n        if result.chars().nth(i).unwrap() != result.chars().rev().nth(i).unwrap()\
    \ {\n            is_palindrome = false;\n        }\n    }\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjoy00mri.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    (s.iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmph4y5kg7t.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0277]: can't\
    \ compare `char` with `&char`\n  --> /tmp/tmph4y5kg7t.rs:11:28\n   |\n11 |   \
    \  (s.iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n   |       \
    \                     ^^ no implementation for `char == &char`\n   |\n   = help:\
    \ the trait `PartialEq<&char>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&char>>` for `Vec<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0412.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    (s.iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmph4y5kg7t.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0277]: can't\
    \ compare `char` with `&char`\n  --> /tmp/tmph4y5kg7t.rs:11:28\n   |\n11 |   \
    \  (s.iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n   |       \
    \                     ^^ no implementation for `char == &char`\n   |\n   = help:\
    \ the trait `PartialEq<&char>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&char>>` for `Vec<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0412.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    let mut is_palindrome = true;\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars_c.sort();\n\
    \    chars_c.dedup();\n    for i in 0..chars.len() {\n        if !chars_c.contains(&chars[i])\
    \ {\n            result.push(chars[i]);\n        }\n    }\n    for i in 0..result.len()\
    \ / 2 {\n        if result.chars().nth(i) != result.chars().nth(result.len() -\
    \ i - 1) {\n            is_palindrome = false;\n            break;\n        }\n\
    \    }\n    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmppbpkbwlw.rs:8:9\n\
    \  |\n8 |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \  |         ----^\n  |         |\n  |         help: remove this `mut`\n  |\n\
    \  = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need\
    \ to be mutable\n --> /tmp/tmppbpkbwlw.rs:9:9\n  |\n9 |     let mut s_rev = s.clone();\n\
    \  |         ----^^^^^\n  |         |\n  |         help: remove this `mut`\n\n\
    error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmppbpkbwlw.rs:11:9\n   |\n\
    8  |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n11 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpls1xqejb.rs:8:50\n\
    \  |\n8 |     let mut s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                  ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpf41t0f36.rs:18:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n18 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpf41t0f36.rs:18:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n18 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let mut i = 0;\n    while i\
    \ < s.len() {\n        if c.contains(&s[i]) {\n            s.remove(i);\n    \
    \    } else {\n            i += 1;\n        }\n    }\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp09koxo0o.rs:19:9\n\
    \   |\n18 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    19 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    let mut result = String::new();\n    let mut result_bool = true;\n \
    \   for i in 0..s.len() {\n        if c.contains(s.chars().nth(i).unwrap()) {\n\
    \            s.remove(i);\n        }\n    }\n    for i in 0..s.len() {\n     \
    \   if s.chars().nth(i).unwrap() != s.chars().rev().nth(i).unwrap() {\n      \
    \      result_bool = false;\n        }\n    }\n    result = s;\n    (result, result_bool)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp4xcpafm0.rs:13:40

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    let mut chars = s.chars();\n    while let Some(c) = chars.next() {\n    \
    \    if !c.is_alphanumeric() {\n            continue;\n        }\n        if c.is_uppercase()\
    \ {\n            result.push(c.to_lowercase().next().unwrap());\n        } else\
    \ {\n            result.push(c);\n        }\n    }\n    let mut chars = c.chars();\n\
    \    while let Some(c) = chars.next() {\n        if !c.is_alphanumeric() {\n \
    \           continue;\n        }\n        if c.is_uppercase() {\n            result\
    \ = result.replace(c.to_lowercase().next().unwrap(), \"\");\n        } else {\n\
    \            result = result.replace(c, \"\");\n        }\n    }\n    let mut\
    \ chars = result.chars();\n    let mut result_reversed = String::new();\n    while\
    \ let Some(c) = chars.next_back() {\n        result_reversed.push(c);\n    }\n\
    \    (result, result == result_reversed)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp98z7qk_g.rs:36:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n36 |     (result, result == result_reversed)\n   |      ------ \
    \ ^^^^^^ value borrowed here after move\n   |      |\n   |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyo8hogmx.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.make_ascii_lowercase();\n\
    \    s_rev.chars().rev().collect::<String>() == s_rev\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpur385pb7.rs:8:50\n\
    \  |\n8 |     let mut s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                  ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpur385pb7.rs:11:5\n\
    \   |\n7  | fn reverse_delete(s: String, c: String) -> (String, bool) {\n   |\
    \                                            -------------- expected `(String,\
    \ bool)` because of return type\n...\n11 |     s_rev.chars().rev().collect::<String>()\
    \ == s_rev\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ tuple, found `bool`\n   |\n   = note: expected tuple `(String, bool)`\n    \
    \           found type `bool`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyo8hogmx.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    let mut result = String::new();\n    let mut is_palindrome = true;\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if c.contains(s.get(i..i + 1).unwrap()) {\n            s.remove(i);\n      \
    \      continue;\n        }\n        if c.contains(s.get(j..j + 1).unwrap()) {\n\
    \            s.remove(j);\n            continue;\n        }\n        if s.get(i..i\
    \ + 1).unwrap() != s.get(j..j + 1).unwrap() {\n            is_palindrome = false;\n\
    \        }\n        i += 1;\n        j -= 1;\n    }\n    (s, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpupk9y7iu.rs:19:39

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpls1xqejb.rs:8:50\n\
    \  |\n8 |     let mut s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                  ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    let mut s = s.chars().collect::<Vec<char>>();\n    let c = c.chars().collect::<Vec<char>>();\n\
    \    for i in 0..s.len() {\n        if !c.contains(&s[i]) {\n            result.push(s[i]);\n\
    \        }\n    }\n    let mut result_rev = result.chars().rev().collect::<String>();\n\
    \    (result, result == result_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmphfhzb8oz.rs:9:9\n\
    \  |\n9 |     let mut s = s.chars().collect::<Vec<char>>();\n  |         ----^\n\
    \  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmphfhzb8oz.rs:16:9\n\
    \   |\n16 |     let mut result_rev = result.chars().rev().collect::<String>();\n\
    \   |         ----^^^^^^^^^^\n   |         |\n   |         help: remove this `mut`\n\
    \nerror[E0382]: borrow of moved value: `result`\n  --> /tmp/tmphfhzb8oz.rs:17:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n17 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    let mut result = String::new();\n    let mut is_palindrome = true;\n\
    \    for i in 0..s.len() {\n        if !c.contains(s.chars().nth(i).unwrap())\
    \ {\n            result.push(s.chars().nth(i).unwrap());\n        }\n    }\n \
    \   for i in 0..result.len() {\n        if result.chars().nth(i).unwrap() != result.chars().rev().nth(i).unwrap()\
    \ {\n            is_palindrome = false;\n        }\n    }\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    let mut result = String::new();\n    let mut check = true;\n    for\
    \ i in 0..s.len() {\n        if !c.contains(s.chars().nth(i).unwrap()) {\n   \
    \         result.push(s.chars().nth(i).unwrap());\n        }\n    }\n    for i\
    \ in 0..result.len() {\n        if result.chars().nth(i).unwrap() != result.chars().rev().nth(i).unwrap()\
    \ {\n            check = false;\n        }\n    }\n    (result, check)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747251
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpls1xqejb.rs:8:50\n\
    \  |\n8 |     let mut s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                  ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    let mut result = String::new();\n    let mut is_palindrome = true;\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < s.len() {\n        if c.contains(s.chars().nth(i).unwrap())\
    \ {\n            s.remove(i);\n        } else {\n            i += 1;\n       \
    \ }\n    }\n    while j < s.len() / 2 {\n        if s.chars().nth(j).unwrap()\
    \ != s.chars().nth(s.len() - j - 1).unwrap() {\n            is_palindrome = false;\n\
    \            break;\n        }\n        j += 1;\n    }\n    result = s;\n    (result,\
    \ is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747251
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    c.push_str(&c.chars().rev().collect::<String>());\n    s.retain(|x|\
    \ !c.contains(x));\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn\
    \ main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp0li4o1vt.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let mut i = 0;\n    while i\
    \ < s.len() {\n        if c.contains(&s[i]) {\n            s.remove(i);\n    \
    \    } else {\n            i += 1;\n        }\n    }\n    let s = s.iter().collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmppzqm3rf_.rs:19:9\n\
    \   |\n18 |     let s = s.iter().collect::<String>();\n   |         - move occurs\
    \ because `s` has type `String`, which does not implement the `Copy` trait\n19\
    \ |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    for i in c.chars() {\n        s = s.replace(i, \"\");\n    }\n    let\
    \ mut s = s.chars().collect::<Vec<char>>();\n    let mut s_rev = s.clone();\n\
    \    s_rev.reverse();\n    (s.into_iter().collect(), s == s_rev)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmp2_lg8b_2.rs:9:9\n\
    \  |\n9 |     let mut c = c;\n  |         ----^\n  |         |\n  |         help:\
    \ remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmp2_lg8b_2.rs:13:9\n   |\n\
    13 |     let mut s = s.chars().collect::<Vec<char>>();\n   |         ----^\n \
    \  |         |\n   |         help: remove this `mut`\n\nerror[E0382]: borrow of\
    \ moved value: `s`\n   --> /tmp/tmp2_lg8b_2.rs:16:31\n    |\n13  |     let mut\
    \ s = s.chars().collect::<Vec<char>>();\n    |         ----- move occurs because\
    \ `s` has type `Vec<char>`, which does not implement the `Copy` trait\n...\n16\
    \  |     (s.into_iter().collect(), s == s_rev)\n    |        -----------     \
    \       ^ value borrowed here after move\n    |        |\n    |        `s` moved\
    \ due to this method call\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `s`\n\nerror: aborting due to previous error; 2 warnings\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let c: HashSet<char>\
    \ = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n    (s, s.chars().eq(s.chars().rev()))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp8gb5g4kr.rs:9:12\n\
    \  |\n9 |     let c: HashSet<char> = c.chars().collect();\n  |            ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmppbpkbwlw.rs:8:9\n\
    \  |\n8 |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \  |         ----^\n  |         |\n  |         help: remove this `mut`\n  |\n\
    \  = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need\
    \ to be mutable\n --> /tmp/tmppbpkbwlw.rs:9:9\n  |\n9 |     let mut s_rev = s.clone();\n\
    \  |         ----^^^^^\n  |         |\n  |         help: remove this `mut`\n\n\
    error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmppbpkbwlw.rs:11:9\n   |\n\
    8  |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n11 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpf41t0f36.rs:18:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n18 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    let mut result = String::new();\n    let mut is_palindrome = true;\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < s.len() {\n        if c.contains(s.chars().nth(i).unwrap())\
    \ {\n            s.remove(i);\n        } else {\n            i += 1;\n       \
    \ }\n    }\n    while j < s.len() {\n        result.push(s.chars().nth(j).unwrap());\n\
    \        j += 1;\n    }\n    let mut k = 0;\n    while k < result.len() {\n  \
    \      if result.chars().nth(k).unwrap() != result.chars().rev().nth(k).unwrap()\
    \ {\n            is_palindrome = false;\n            break;\n        }\n     \
    \   k += 1;\n    }\n    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747251
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmppbpkbwlw.rs:8:9\n\
    \  |\n8 |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \  |         ----^\n  |         |\n  |         help: remove this `mut`\n  |\n\
    \  = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need\
    \ to be mutable\n --> /tmp/tmppbpkbwlw.rs:9:9\n  |\n9 |     let mut s_rev = s.clone();\n\
    \  |         ----^^^^^\n  |         |\n  |         help: remove this `mut`\n\n\
    error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmppbpkbwlw.rs:11:9\n   |\n\
    8  |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n11 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    let is_palindrome = s.chars().eq(s.chars().rev());\n\
    \    (s, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747251
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    for i in c.chars() {\n        s = s.replace(i, \"\");\n    }\n    (s,\
    \ s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpqsm4e09z.rs:9:9\n\
    \  |\n9 |     let mut c = c;\n  |         ----^\n  |         |\n  |         help:\
    \ remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]:\
    \ borrow of moved value: `s`\n  --> /tmp/tmpqsm4e09z.rs:13:9\n   |\n8  |     let\
    \ mut s = s;\n   |         ----- move occurs because `s` has type `String`, which\
    \ does not implement the `Copy` trait\n...\n13 |     (s, s == s.chars().rev().collect::<String>())\n\
    \   |      -  ^ value borrowed here after move\n   |      |\n   |      value moved\
    \ here\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let mut c = c.chars().collect::<Vec<_>>();\n    s.retain(|x| !c.contains(x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmplqx60x9i.rs:9:9\n\
    \  |\n9 |     let mut c = c.chars().collect::<Vec<_>>();\n  |         ----^\n\
    \  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmplqx60x9i.rs:12:9\n\
    \   |\n11 |     let s = s.iter().collect::<String>();\n   |         - move occurs\
    \ because `s` has type `String`, which does not implement the `Copy` trait\n12\
    \ |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    (s.iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmph4y5kg7t.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0277]: can't\
    \ compare `char` with `&char`\n  --> /tmp/tmph4y5kg7t.rs:11:28\n   |\n11 |   \
    \  (s.iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n   |       \
    \                     ^^ no implementation for `char == &char`\n   |\n   = help:\
    \ the trait `PartialEq<&char>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&char>>` for `Vec<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0412.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    let mut result = String::new();\n    let mut is_palindrome = true;\n\
    \    for i in 0..s.len() {\n        if !c.contains(s.chars().nth(i).unwrap())\
    \ {\n            result.push(s.chars().nth(i).unwrap());\n        }\n    }\n \
    \   for i in 0..result.len() {\n        if result.chars().nth(i).unwrap() != result.chars().rev().nth(i).unwrap()\
    \ {\n            is_palindrome = false;\n        }\n    }\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars()\
    \ {\n        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmps7bg8fij.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpls1xqejb.rs:8:50\n\
    \  |\n8 |     let mut s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                  ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for i in c.chars()\
    \ {\n        s = s.replace(i, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyvyldhir.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|x| !c.contains(x));\n\
    \    (s.iter().collect(), s.iter().eq(s.iter().rev()))\n}\n\nfn main() {\n   \
    \ let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp2368vz_h.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpf41t0f36.rs:18:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n18 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpf41t0f36.rs:18:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n18 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars()\
    \ {\n        s = s.replace(ch, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.iter().collect(), false);\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    (s.iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpwszju5ky.rs:14:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyo8hogmx.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmppbpkbwlw.rs:8:9\n\
    \  |\n8 |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \  |         ----^\n  |         |\n  |         help: remove this `mut`\n  |\n\
    \  = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need\
    \ to be mutable\n --> /tmp/tmppbpkbwlw.rs:9:9\n  |\n9 |     let mut s_rev = s.clone();\n\
    \  |         ----^^^^^\n  |         |\n  |         help: remove this `mut`\n\n\
    error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmppbpkbwlw.rs:11:9\n   |\n\
    8  |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n11 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjoy00mri.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjoy00mri.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let mut i = 0;\n    while i\
    \ < s.len() {\n        if c.contains(&s[i]) {\n            s.remove(i);\n    \
    \    } else {\n            i += 1;\n        }\n    }\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp09koxo0o.rs:19:9\n\
    \   |\n18 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    19 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    let mut s = s.chars().collect::<Vec<char>>();\n    let c = c.chars().collect::<Vec<char>>();\n\
    \    for i in 0..s.len() {\n        if !c.contains(&s[i]) {\n            result.push(s[i]);\n\
    \        }\n    }\n    let mut result_rev = result.chars().rev().collect::<String>();\n\
    \    (result, result == result_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmphfhzb8oz.rs:9:9\n\
    \  |\n9 |     let mut s = s.chars().collect::<Vec<char>>();\n  |         ----^\n\
    \  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmphfhzb8oz.rs:16:9\n\
    \   |\n16 |     let mut result_rev = result.chars().rev().collect::<String>();\n\
    \   |         ----^^^^^^^^^^\n   |         |\n   |         help: remove this `mut`\n\
    \nerror[E0382]: borrow of moved value: `result`\n  --> /tmp/tmphfhzb8oz.rs:17:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n17 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars()\
    \ {\n        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmps7bg8fij.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    (s.iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmph4y5kg7t.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0277]: can't\
    \ compare `char` with `&char`\n  --> /tmp/tmph4y5kg7t.rs:11:28\n   |\n11 |   \
    \  (s.iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n   |       \
    \                     ^^ no implementation for `char == &char`\n   |\n   = help:\
    \ the trait `PartialEq<&char>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&char>>` for `Vec<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0412.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpls1xqejb.rs:8:50\n\
    \  |\n8 |     let mut s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                  ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpls1xqejb.rs:8:50\n\
    \  |\n8 |     let mut s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                  ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars()\
    \ {\n        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmps7bg8fij.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmppbpkbwlw.rs:8:9\n\
    \  |\n8 |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \  |         ----^\n  |         |\n  |         help: remove this `mut`\n  |\n\
    \  = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need\
    \ to be mutable\n --> /tmp/tmppbpkbwlw.rs:9:9\n  |\n9 |     let mut s_rev = s.clone();\n\
    \  |         ----^^^^^\n  |         |\n  |         help: remove this `mut`\n\n\
    error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmppbpkbwlw.rs:11:9\n   |\n\
    8  |     let mut s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n11 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    (s.iter().collect(), s.iter().eq(s.iter().rev()))\n}\n\nfn main() {\n   \
    \ let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjoy00mri.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpls1xqejb.rs:8:50\n\
    \  |\n8 |     let mut s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                  ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp6z0oady7.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    let mut result = String::new();\n    let mut result_bool = true;\n \
    \   let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n\
    \    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n\
    \    let mut q = 0;\n    let mut r = 0;\n    let mut s_len = s.len();\n    let\
    \ mut c_len = c.len();\n    let mut s_chars: Vec<char> = s.chars().collect();\n\
    \    let mut c_chars: Vec<char> = c.chars().collect();\n    while i < s_len {\n\
    \        j = 0;\n        while j < c_len {\n            if s_chars[i] == c_chars[j]\
    \ {\n                s_chars.remove(i);\n                s_len -= 1;\n       \
    \         i -= 1;\n                break;\n            }\n            j += 1;\n\
    \        }\n        i += 1;\n    }\n    while k < s_len {\n        l = s_len -\
    \ 1;\n        while l > k {\n            if s_chars[k] == s_chars[l] {\n     \
    \           s_chars.remove(l);\n                s_chars.remove(k);\n         \
    \       s_len -= 2;\n                k -= 1;\n                break;\n       \
    \     }\n            l -= 1;\n        }\n        k += 1;\n    }\n    while m <\
    \ s_len {\n        result.push(s_chars[m]);\n        m += 1;\n    }\n    while\
    \ n < s_len {\n        o = s_len - 1;\n        while o > n {\n            if result.chars().nth(n)\
    \ != result.chars().nth(o) {\n                result_bool = false;\n         \
    \       break;\n            }\n            o -= 1;\n        }\n        n += 1;\n\
    \    }\n    (result, result_bool)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpa994kjzb.rs:32:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747251
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    (s.iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmph4y5kg7t.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0277]: can't\
    \ compare `char` with `&char`\n  --> /tmp/tmph4y5kg7t.rs:11:28\n   |\n11 |   \
    \  (s.iter().collect(), s == s.iter().rev().collect::<Vec<_>>())\n   |       \
    \                     ^^ no implementation for `char == &char`\n   |\n   = help:\
    \ the trait `PartialEq<&char>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&char>>` for `Vec<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0412.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.chars().filter(|x| x != &c).collect();\n    }\n    let is_palindrome\
    \ = s.chars().eq(s.chars().rev());\n    (s, is_palindrome)\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747251
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyo8hogmx.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpls1xqejb.rs:8:50\n\
    \  |\n8 |     let mut s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                  ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjoy00mri.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars()\
    \ {\n        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmps7bg8fij.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyo8hogmx.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars()\
    \ {\n        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmps7bg8fij.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoej65zkf.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    let mut s_chars = s.chars();\n    let mut c_chars = c.chars();\n    let mut\
    \ s_iter = s_chars.by_ref();\n    let mut c_iter = c_chars.by_ref();\n    let\
    \ mut s_char = s_iter.next();\n    let mut c_char = c_iter.next();\n    while\
    \ s_char != None {\n        if c_char == None {\n            result.push(s_char.unwrap());\n\
    \            s_char = s_iter.next();\n        } else if s_char.unwrap() == c_char.unwrap()\
    \ {\n            s_char = s_iter.next();\n            c_char = c_iter.next();\n\
    \        } else {\n            result.push(s_char.unwrap());\n            s_char\
    \ = s_iter.next();\n        }\n    }\n    let mut result_chars = result.chars();\n\
    \    let mut result_iter = result_chars.by_ref();\n    let mut result_char = result_iter.next();\n\
    \    let mut result_rev = String::new();\n    while result_char != None {\n  \
    \      result_rev.push(result_char.unwrap());\n        result_char = result_iter.next();\n\
    \    }\n    let mut result_rev_chars = result_rev.chars();\n    let mut result_rev_iter\
    \ = result_rev_chars.by_ref();\n    let mut result_rev_char = result_rev_iter.next();\n\
    \    let mut result_rev_rev = String::new();\n    while result_rev_char != None\
    \ {\n        result_rev_rev.push(result_rev_char.unwrap());\n        result_rev_char\
    \ = result_rev_iter.next();\n    }\n    (result_rev, result_rev == result)\n}\n\
    \nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpej2w6vt7.rs:11:9\n\
    \   |\n11 |     let mut s_iter = s_chars.by_ref();\n   |         ----^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpej2w6vt7.rs:12:9\n\
    \   |\n12 |     let mut c_iter = c_chars.by_ref();\n   |         ----^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpej2w6vt7.rs:28:9\n   |\n28 |     let mut\
    \ result_iter = result_chars.by_ref();\n   |         ----^^^^^^^^^^^\n   |   \
    \      |\n   |         help: remove this `mut`\n\nwarning: variable does not need\
    \ to be mutable\n  --> /tmp/tmpej2w6vt7.rs:36:9\n   |\n36 |     let mut result_rev_iter\
    \ = result_rev_chars.by_ref();\n   |         ----^^^^^^^^^^^^^^^\n   |       \
    \  |\n   |         help: remove this `mut`\n\nerror[E0382]: borrow of moved value:\
    \ `result_rev`\n  --> /tmp/tmpej2w6vt7.rs:43:18\n   |\n30 |     let mut result_rev\
    \ = String::new();\n   |         -------------- move occurs because `result_rev`\
    \ has type `String`, which does not implement the `Copy` trait\n...\n43 |    \
    \ (result_rev, result_rev == result)\n   |      ----------  ^^^^^^^^^^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error; 4 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<HashSet<_>>();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpr_0gayk1.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjoy00mri.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars()\
    \ {\n        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmps7bg8fij.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars()\
    \ {\n        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmps7bg8fij.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjoy00mri.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpls1xqejb.rs:8:50\n\
    \  |\n8 |     let mut s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                  ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyeqw0aef.rs:12:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n12 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747250
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    let mut r = s.clone();\n    r.chars().rev().collect::<String>()\
    \ == s && (s.len() > 0)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ujl68fm.rs:10:5\n   |\n\
    7  | fn reverse_delete(s: String, c: String) -> (String, bool) {\n   |       \
    \                                     -------------- expected `(String, bool)`\
    \ because of return type\n...\n10 |     r.chars().rev().collect::<String>() ==\
    \ s && (s.len() > 0)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found `bool`\n   |\n   = note: expected tuple `(String, bool)`\n\
    \               found type `bool`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747251
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    let mut result = String::new();\n    let mut is_palindrome = true;\n\
    \    for i in 0..s.len() {\n        let mut is_delete = false;\n        for j\
    \ in 0..c.len() {\n            if s.chars().nth(i).unwrap() == c.chars().nth(j).unwrap()\
    \ {\n                is_delete = true;\n                break;\n            }\n\
    \        }\n        if !is_delete {\n            result.push(s.chars().nth(i).unwrap());\n\
    \        }\n    }\n    for i in 0..result.len() {\n        if result.chars().nth(i).unwrap()\
    \ != result.chars().nth(result.len() - i - 1).unwrap() {\n            is_palindrome\
    \ = false;\n            break;\n        }\n    }\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747251
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    (s.iter().collect(), s.iter().eq(s.iter().rev()))\n}\n\nfn main() {\n   \
    \ let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747250
