language: rs
name: HumanEval_135_can_arrange
results:
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    let mut max_index = -1;\n    for i in (0..arr.len()).rev()\
    \ {\n        if arr[i] >= max {\n            max = arr[i];\n            max_index\
    \ = i as isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp93kz39ew.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n \
    \           max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = -1;\n    for (i, &x)\
    \ in arr.iter().enumerate() {\n        if x > max_value {\n            max_value\
    \ = x;\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp1luce1y0.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    let mut max_idx = -1;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x > max {\n            max = x;\n            max_idx = i as isize;\n\
    \        }\n    }\n    max_idx\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpqs26e4nq.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() - 1 {\n        if arr[i]\
    \ >= arr[i + 1] {\n            max = i as isize;\n        }\n    }\n    max\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpr3d92xtc.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    for i in 0..arr.len() {\n\
    \        if arr[i] == max {\n            return i as isize;\n        }\n    }\n\
    \    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp5e62krmc.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    let mut max_index = -1;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x > max {\n            max = x;\n            max_index = i as\
    \ isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp9fwql1nw.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ arr[i - 1] {\n            max = i as isize;\n        }\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyxgl6j90.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            max_index = 0;\n        } else if arr[i] > arr[i - 1] {\n \
    \           max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpbiv_czd1.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ arr[i - 1] {\n            max = i as isize;\n        }\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyxgl6j90.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = -1;\n    for (i, &value)\
    \ in arr.iter().enumerate() {\n        if value > max_value {\n            max_value\
    \ = value;\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp438b4kv7.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] < max_value {\n            max_index = i as\
    \ isize;\n            max_value = arr[i];\n        }\n    }\n    max_index\n}\n\
    \nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `3`', /tmp/tmpz80zireq.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut count = vec![0;\
    \ max as usize + 1];\n    for i in 0..arr.len() {\n        count[arr[i] as usize]\
    \ += 1;\n    }\n    let mut sum = 0;\n    for i in 0..count.len() {\n        sum\
    \ += count[i];\n        count[i] = sum - count[i];\n    }\n    let mut ans = vec![0;\
    \ arr.len()];\n    for i in 0..arr.len() {\n        ans[count[arr[i] as usize]\
    \ as usize] = arr[i];\n        count[arr[i] as usize] += 1;\n    }\n    for i\
    \ in 1..ans.len() {\n        if ans[i] < ans[i - 1] {\n            return i as\
    \ isize - 1;\n        }\n    }\n    -1\n}\n\nfn main() {\n    let candidate =\
    \ can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `3`', /tmp/tmp25utbmez.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_idx = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ < arr[i - 1] {\n            max_idx = i as isize;\n        }\n    }\n    max_idx\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmprh33mw5p.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = arr[0];\n    for (i,\
    \ &x) in arr.iter().enumerate() {\n        if x > max_value {\n            max_value\
    \ = x;\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp86def64i.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut max_index = -1;\n\
    \    for i in 0..arr.len() {\n        if arr[i] == max {\n            max_index\
    \ = i as isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpr_q9bu0n.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] > max_value {\n            max_index = i as\
    \ isize;\n            max_value = arr[i];\n        }\n    }\n    max_index\n}\n\
    \nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpfcq7fw_3.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ max {\n            return i as isize - 1;\n        }\n        max = arr[i];\n\
    \    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpo82d_izy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() - 1 {\n        if arr[i]\
    \ >= arr[i + 1] {\n            max = i as isize;\n        }\n    }\n    max\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpr3d92xtc.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] < max_value {\n            max_index = i as\
    \ isize;\n            max_value = arr[i];\n        }\n    }\n    max_index\n}\n\
    \nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `3`', /tmp/tmpz80zireq.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    max\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpsylecl4h.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    max\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpsylecl4h.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] < max_value {\n            max_index = i as\
    \ isize;\n            max_value = arr[i];\n        }\n    }\n    max_index\n}\n\
    \nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `3`', /tmp/tmpz80zireq.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    for i in 0..arr.len() {\n        if arr[i] >= arr[i - 1] {\n        \
    \    return i as isize - 1;\n        }\n    }\n    -1\n}\n\nfn main() {\n    let\
    \ candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdscn5y1l.rs:8:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] < arr[i\
    \ - 1] {\n            max = i as isize - 1;\n        }\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpgiq8mqh1.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_idx = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_idx = i as isize;\n        }\n    }\n    max_idx\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpq1fd_tjj.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut max_index = -1;\n\
    \    for i in 0..arr.len() {\n        if arr[i] == max {\n            max_index\
    \ = i as isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpr_q9bu0n.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut largest_index = -1;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if i == 0 {\n            continue;\n        }\n        if x <= arr[i\
    \ - 1] {\n            largest_index = i as isize;\n        }\n    }\n    largest_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    let mut max_idx = -1;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x > max {\n            max = x;\n            max_idx = i as isize;\n\
    \        }\n    }\n    max_idx\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpqs26e4nq.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] > max_value {\n            max_index = i as\
    \ isize;\n            max_value = arr[i];\n        }\n    }\n    max_index\n}\n\
    \nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpfcq7fw_3.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ max {\n            return i as isize - 1;\n        }\n        max = arr[i];\n\
    \    }\n    (arr.len() - 1) as isize\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpvejy8cku.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_idx = -1;\n    let mut max_val = -1;\n    for (i, &val) in\
    \ arr.iter().enumerate() {\n        if val > max_val {\n            max_idx =\
    \ i as isize;\n            max_val = val;\n        }\n    }\n    max_idx\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpnq9_92pn.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ max {\n            return i as isize - 1;\n        }\n        max = arr[i];\n\
    \    }\n    (arr.len() - 1) as isize\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpvejy8cku.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in (0..arr.len()).rev() {\n        if arr[i]\
    \ >= max {\n            max = i as isize;\n        }\n    }\n    max\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpcwlhkywq.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n \
    \           max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] < arr[i\
    \ - 1] {\n            max = i as isize - 1;\n        }\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpgiq8mqh1.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_val = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] > max_val {\n            max_index = i as\
    \ isize;\n            max_val = arr[i];\n        }\n    }\n    max_index\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpadiaprpt.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    max\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpsylecl4h.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_idx = -1;\n    for i in 0..arr.len() {\n        if i == 0\
    \ {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n   \
    \         max_idx = i as isize;\n        }\n    }\n    max_idx\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    let mut i = arr.len() - 1;\n    while i > 0 {\n\
    \        if arr[i] <= arr[i - 1] {\n            max = i as isize;\n        }\n\
    \        i -= 1;\n    }\n    max\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpvh4398ie.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] > max_value {\n            max_value = arr[i];\n\
    \            max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp6_k8yhrt.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut max_index = -1;\n\
    \    for i in 0..arr.len() {\n        if arr[i] == max {\n            max_index\
    \ = i as isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpr_q9bu0n.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut arr2 = arr.clone();\n\
    \    arr2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    while i < arr.len()\
    \ && j < arr2.len() {\n        if arr[i] == arr2[j] {\n            i += 1;\n \
    \           j += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    if j == arr2.len() {\n        return -1;\n    }\n    j as isize\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp6cn1x8xi.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    if max == -1 {\n       \
    \ return -1;\n    }\n    let mut count = vec![0; max as usize + 1];\n    for i\
    \ in 0..arr.len() {\n        count[arr[i] as usize] += 1;\n    }\n    let mut\
    \ sum = 0;\n    for i in 0..count.len() {\n        sum += count[i];\n        count[i]\
    \ = sum - count[i];\n    }\n    let mut output = vec![0; arr.len()];\n    for\
    \ i in 0..arr.len() {\n        output[count[arr[i] as usize] as usize] = arr[i];\n\
    \        count[arr[i] as usize] += 1;\n    }\n    let mut max = -1;\n    for i\
    \ in 0..output.len() {\n        if output[i] > max {\n            max = output[i];\n\
    \        }\n    }\n    max\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpnn1_y6ll.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    max\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpsylecl4h.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    max\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpsylecl4h.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut count = vec![0;\
    \ max as usize + 1];\n    for i in 0..arr.len() {\n        count[arr[i] as usize]\
    \ += 1;\n    }\n    let mut sum = 0;\n    for i in 0..count.len() {\n        sum\
    \ += count[i];\n        count[i] = sum - count[i];\n    }\n    let mut temp =\
    \ vec![0; arr.len()];\n    for i in 0..arr.len() {\n        temp[count[arr[i]\
    \ as usize] as usize] = arr[i];\n        count[arr[i] as usize] += 1;\n    }\n\
    \    for i in 0..arr.len() {\n        arr[i] = temp[i];\n    }\n    let mut max_index\
    \ = -1;\n    for i in 1..arr.len() {\n        if arr[i] < arr[i - 1] {\n     \
    \       max_index = i as isize - 1;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpo8sfmsb6.rs:28:9\n   |\n6  | fn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n   |                --- help: consider changing this to be mutable:\
    \ `mut arr`\n...\n28 |         arr[i] = temp[i];\n   |         ^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut map = vec![0; max\
    \ as usize + 1];\n    for i in 0..arr.len() {\n        map[arr[i] as usize] +=\
    \ 1;\n    }\n    let mut sum = 0;\n    for i in 0..map.len() {\n        sum +=\
    \ map[i];\n        map[i] = sum;\n    }\n    let mut max = -1;\n    for i in 0..arr.len()\
    \ {\n        let index = map[arr[i] as usize] - 1;\n        if index > max {\n\
    \            max = index;\n        }\n    }\n    max\n}\n\nfn main() {\n    let\
    \ candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp4jobkt62.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    let mut max_index = -1;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x > max {\n            max = x;\n            max_index = i as\
    \ isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp9fwql1nw.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in (0..arr.len()).rev() {\n        if arr[i]\
    \ < max {\n            return i as isize;\n        }\n        max = arr[i];\n\
    \    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `-1`', /tmp/tmp8jt2esah.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ max {\n            return i as isize - 1;\n        }\n        max = arr[i];\n\
    \    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpo82d_izy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] >=\
    \ arr[i - 1] {\n            max = i as isize;\n        }\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpykdh1y6r.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in (0..arr.len()).rev() {\n        if arr[i]\
    \ >= max {\n            max = i as isize;\n        }\n    }\n    max\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpcwlhkywq.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = -1;\n    for (i, &x)\
    \ in arr.iter().enumerate() {\n        if x > max_value {\n            max_value\
    \ = x;\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp1luce1y0.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for (i, &x) in arr.iter().enumerate() {\n\
    \        if i == 0 {\n            continue;\n        }\n        if x <= arr[i\
    \ - 1] {\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n \
    \           max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut count = vec![0;\
    \ max as usize + 1];\n    for i in 0..arr.len() {\n        count[arr[i] as usize]\
    \ += 1;\n    }\n    let mut sum = 0;\n    for i in 0..count.len() {\n        sum\
    \ += count[i];\n        count[i] = sum - count[i];\n    }\n    for i in 0..arr.len()\
    \ {\n        if count[arr[i] as usize] != i as isize {\n            return i as\
    \ isize;\n        }\n    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpwwa9uuos.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] > max_value {\n            max_index = i as\
    \ isize;\n            max_value = arr[i];\n        }\n    }\n    max_index\n}\n\
    \nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpfcq7fw_3.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in (0..arr.len()).rev() {\n        if arr[i]\
    \ < max {\n            return i as isize;\n        }\n        max = arr[i];\n\
    \    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `-1`', /tmp/tmp8jt2esah.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = std::isize::MIN;\n \
    \   for (i, &x) in arr.iter().enumerate() {\n        if x > max_value {\n    \
    \        max_value = x;\n            max_index = i as isize;\n        }\n    }\n\
    \    max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp607i6jak.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = -1;\n    for (i, &x)\
    \ in arr.iter().enumerate() {\n        if x > max_value {\n            max_value\
    \ = x;\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp1luce1y0.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] < max_value {\n            max_index = i as\
    \ isize;\n            max_value = arr[i];\n        }\n    }\n    max_index\n}\n\
    \nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `3`', /tmp/tmpz80zireq.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ max {\n            return i as isize - 1;\n        }\n        max = arr[i];\n\
    \    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpo82d_izy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n \
    \           max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut max_index = -1;\n\
    \    for i in 0..arr.len() {\n        if arr[i] == max {\n            max_index\
    \ = i as isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpr_q9bu0n.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvjmcplpc.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] > max_value {\n            max_value = arr[i];\n\
    \            max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp6_k8yhrt.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for (i, &x) in arr.iter().enumerate() {\n    \
    \    if i == 0 {\n            continue;\n        }\n        if x <= arr[i - 1]\
    \ {\n            max = i as isize - 1;\n        }\n    }\n    max\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpc8u5b2ah.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut max_index = -1;\n\
    \    for i in 0..arr.len() {\n        if arr[i] == max {\n            max_index\
    \ = i as isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpr_q9bu0n.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] < arr[i\
    \ - 1] {\n            max = i as isize - 1;\n        }\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpgiq8mqh1.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    let mut max_index = -1;\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v > max {\n            max = v;\n            max_index = i as\
    \ isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpdmjajz1d.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut arr = arr;\n    arr.sort();\n    let mut max_index = -1;\n  \
    \  for i in 0..arr.len() {\n        if arr[i] <= arr[i - 1] {\n            max_index\
    \ = i as isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdinac0ux.rs:11:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for (i, &x) in arr.iter().enumerate() {\n    \
    \    if i == 0 {\n            continue;\n        }\n        if x <= arr[i - 1]\
    \ {\n            max = i as isize - 1;\n        }\n    }\n    max\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpc8u5b2ah.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n \
    \           max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut result = -1;\n \
    \   for i in 0..arr.len() {\n        if arr[i] == max {\n            result =\
    \ i as isize;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp_aebeop0.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in (0..arr.len() - 1).rev() {\n        if\
    \ arr[i] >= arr[i + 1] {\n            max = i as isize;\n        } else {\n  \
    \          break;\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `3`', /tmp/tmp6ufan9qz.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut count = vec![0;\
    \ max as usize + 1];\n    for i in 0..arr.len() {\n        count[arr[i] as usize]\
    \ += 1;\n    }\n    let mut sum = 0;\n    for i in 0..count.len() {\n        sum\
    \ += count[i];\n        count[i] = sum - count[i];\n    }\n    let mut ans = vec![0;\
    \ arr.len()];\n    for i in 0..arr.len() {\n        ans[count[arr[i] as usize]\
    \ as usize] = arr[i];\n        count[arr[i] as usize] += 1;\n    }\n    for i\
    \ in 0..ans.len() {\n        if ans[i] != arr[i] {\n            return i as isize\
    \ - 1;\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpwhsibwif.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ max {\n            return i as isize - 1;\n        }\n        max = arr[i];\n\
    \    }\n    (arr.len() - 1) as isize\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpvejy8cku.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut max_index = -1;\n\
    \    for i in 0..arr.len() {\n        if arr[i] == max {\n            max_index\
    \ = i as isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpr_q9bu0n.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n \
    \           max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    max\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpsylecl4h.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut max_index = -1;\n\
    \    for i in 0..arr.len() {\n        if arr[i] == max {\n            max_index\
    \ = i as isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpr_q9bu0n.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvjmcplpc.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvjmcplpc.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut result = -1;\n    for i in 0..arr.len() {\n        if i == 0\
    \ {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n   \
    \         result = i as isize;\n            break;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl0zb6rwv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if i == 0 {\n\
    \            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n       \
    \     max = i as isize;\n        }\n    }\n    max\n}\n\nfn main() {\n    let\
    \ candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut count = vec![0;\
    \ max as usize + 1];\n    for i in 0..arr.len() {\n        count[arr[i] as usize]\
    \ += 1;\n    }\n    let mut sum = 0;\n    for i in 0..count.len() {\n        sum\
    \ += count[i];\n        count[i] = sum - count[i];\n    }\n    for i in 0..arr.len()\
    \ {\n        if arr[i] > 0 {\n            let pos = count[arr[i] as usize];\n\
    \            if arr[pos as usize] == arr[i] {\n                return pos;\n \
    \           }\n        }\n    }\n    -1\n}\n\nfn main() {\n    let candidate =\
    \ can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp1ctwdd36.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n \
    \           max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    let mut max_index = -1;\n    for i in (0..arr.len()).rev()\
    \ {\n        if arr[i] >= max {\n            max = arr[i];\n            max_index\
    \ = i as isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp93kz39ew.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ >= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpl0w7umb2.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n \
    \           max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvjmcplpc.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_val = -1;\n    for (i, &val)\
    \ in arr.iter().enumerate() {\n        if val > max_val {\n            max_val\
    \ = val;\n            max_index = i as isize;\n        }\n    }\n    for (i, &val)\
    \ in arr.iter().enumerate() {\n        if val == max_val {\n            if i ==\
    \ 0 {\n                return -1;\n            }\n            if arr[i - 1] <\
    \ val {\n                return i as isize - 1;\n            }\n        }\n  \
    \  }\n    max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `-1`', /tmp/tmpnesr3dzs.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    max\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpsylecl4h.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = 0;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut count = vec![0;\
    \ max as usize + 1];\n    for i in 0..arr.len() {\n        count[arr[i] as usize]\
    \ += 1;\n    }\n    let mut max_count = 0;\n    for i in 0..count.len() {\n  \
    \      if count[i] > max_count {\n            max_count = count[i];\n        }\n\
    \    }\n    if max_count > arr.len() / 2 {\n        return -1;\n    }\n    let\
    \ mut result = vec![0; arr.len()];\n    let mut index = 0;\n    for i in 0..count.len()\
    \ {\n        for j in 0..count[i] {\n            result[index] = i as isize;\n\
    \            index += 1;\n        }\n    }\n    let mut max_index = 0;\n    for\
    \ i in 1..result.len() {\n        if result[i] < result[i - 1] {\n           \
    \ max_index = i - 1;\n        }\n    }\n    max_index as isize\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpzwlya771.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in (0..arr.len() - 1).rev() {\n        if\
    \ arr[i] >= arr[i + 1] {\n            max = i as isize;\n        } else {\n  \
    \          break;\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `3`', /tmp/tmp6ufan9qz.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] > max_value {\n            max_value = arr[i];\n\
    \            max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp6_k8yhrt.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ arr[i - 1] {\n            max = i as isize;\n        }\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyxgl6j90.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if i == 0 {\n\
    \            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n       \
    \     max = i as isize;\n        }\n    }\n    max\n}\n\nfn main() {\n    let\
    \ candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    for i in 0..arr.len() {\n\
    \        if arr[i] == max {\n            return i as isize;\n        }\n    }\n\
    \    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp5e62krmc.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ < arr[i - 1] {\n            max_index = i as isize - 1;\n        }\n    }\n\
    \    max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpu7g24sh6.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n \
    \           max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    for i in 0..arr.len() {\n\
    \        if arr[i] == max {\n            return i as isize;\n        }\n    }\n\
    \    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp5e62krmc.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut result = -1;\n \
    \   for i in 0..arr.len() {\n        if arr[i] == max {\n            result =\
    \ i as isize;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp_aebeop0.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvjmcplpc.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ arr[i - 1] {\n            max = i as isize;\n        }\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyxgl6j90.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ arr[i - 1] {\n            max = i as isize;\n        }\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyxgl6j90.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut count = vec![0;\
    \ max as usize + 1];\n    for i in 0..arr.len() {\n        count[arr[i] as usize]\
    \ += 1;\n    }\n    let mut max_count = 0;\n    for i in 0..count.len() {\n  \
    \      if count[i] > max_count {\n            max_count = count[i];\n        }\n\
    \    }\n    max_count as isize\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpp7lvgiip.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    max\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpsylecl4h.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut arr = arr;\n    arr.sort();\n    let mut i = 0;\n    while i\
    \ < arr.len() - 1 {\n        if arr[i] >= arr[i + 1] {\n            return i as\
    \ isize;\n        }\n        i += 1;\n    }\n    -1\n}\n\nfn main() {\n    let\
    \ candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `3`', /tmp/tmp9_kpoaqb.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = -1;\n    for (i, &v)\
    \ in arr.iter().enumerate() {\n        if v > max_value {\n            max_value\
    \ = v;\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpmibite8t.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ max {\n            return i as isize - 1;\n        }\n        max = arr[i];\n\
    \    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpo82d_izy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_idx = -1;\n    for (i, &x) in arr.iter().enumerate() {\n\
    \        if i == 0 {\n            continue;\n        }\n        if x <= arr[i\
    \ - 1] {\n            max_idx = i as isize;\n        }\n    }\n    max_idx\n}\n\
    \nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    max\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpsylecl4h.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ arr[i - 1] {\n            max = i as isize;\n        }\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyxgl6j90.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvjmcplpc.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    let mut max_index = -1;\n    let mut min = std::isize::MAX;\n\
    \    let mut min_index = -1;\n    for (i, v) in arr.iter().enumerate() {\n   \
    \     if *v > max {\n            max = *v;\n            max_index = i as isize;\n\
    \        }\n        if *v < min {\n            min = *v;\n            min_index\
    \ = i as isize;\n        }\n    }\n    if max_index > min_index {\n        max_index\n\
    \    } else {\n        min_index\n    }\n}\n\nfn main() {\n    let candidate =\
    \ can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp792ou9za.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    let mut max_index = -1;\n    for i in (0..arr.len()).rev()\
    \ {\n        if arr[i] >= max {\n            max = arr[i];\n            max_index\
    \ = i as isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp93kz39ew.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvjmcplpc.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for (i, &x) in arr.iter().enumerate() {\n\
    \        if i == 0 {\n            continue;\n        }\n        if x <= arr[i\
    \ - 1] {\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvjmcplpc.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for (i, &x) in arr.iter().enumerate() {\n\
    \        if i > 0 && x <= arr[i - 1] {\n            max_index = i as isize;\n\
    \        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = -1;\n    for (i, &x)\
    \ in arr.iter().enumerate() {\n        if x > max_value {\n            max_value\
    \ = x;\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp1luce1y0.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut count = vec![0;\
    \ max as usize + 1];\n    for i in 0..arr.len() {\n        count[arr[i] as usize]\
    \ += 1;\n    }\n    let mut sum = 0;\n    for i in 0..count.len() {\n        sum\
    \ += count[i];\n        count[i] = sum - count[i];\n    }\n    let mut output\
    \ = vec![0; arr.len()];\n    for i in 0..arr.len() {\n        output[count[arr[i]\
    \ as usize] as usize] = arr[i];\n        count[arr[i] as usize] += 1;\n    }\n\
    \    for i in 0..arr.len() {\n        arr[i] = output[i];\n    }\n    let mut\
    \ max_index = -1;\n    for i in 1..arr.len() {\n        if arr[i] < arr[i - 1]\
    \ {\n            max_index = i as isize - 1;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpi2ayalau.rs:28:9\n   |\n6  | fn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n   |                --- help: consider changing this to be mutable:\
    \ `mut arr`\n...\n28 |         arr[i] = output[i];\n   |         ^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut largest_index = -1;\n    for i in 0..arr.len() {\n        if\
    \ arr[i] > arr[i - 1] {\n            largest_index = i as isize;\n        }\n\
    \    }\n    largest_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpfmol08sq.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ arr[i - 1] {\n            max = i as isize;\n        }\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyxgl6j90.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    max\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpsylecl4h.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    max\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpsylecl4h.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    let mut max_index = -1;\n    for i in (0..arr.len()).rev()\
    \ {\n        if arr[i] >= max {\n            max = arr[i];\n            max_index\
    \ = i as isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp93kz39ew.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvjmcplpc.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut arr_max = arr.clone();\n\
    \    arr_max.sort();\n    let mut arr_max_rev = arr_max.clone();\n    arr_max_rev.reverse();\n\
    \    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i] ==\
    \ arr_max[i] {\n            max_index = i as isize;\n        }\n    }\n    if\
    \ max_index == -1 {\n        for i in 0..arr.len() {\n            if arr[i] ==\
    \ arr_max_rev[i] {\n                max_index = i as isize;\n            }\n \
    \       }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpyawmmmx2.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvjmcplpc.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut count = vec![0;\
    \ max as usize + 1];\n    for i in 0..arr.len() {\n        count[arr[i] as usize]\
    \ += 1;\n    }\n    let mut max_count = 0;\n    for i in 0..count.len() {\n  \
    \      if count[i] > max_count {\n            max_count = count[i];\n        }\n\
    \    }\n    let mut result = 0;\n    for i in 0..count.len() {\n        if count[i]\
    \ == max_count {\n            result = i;\n        }\n    }\n    result as isize\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmppunagb9e.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() - 1 {\n        if arr[i]\
    \ >= arr[i + 1] {\n            max = i as isize;\n        }\n    }\n    max\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpr3d92xtc.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvjmcplpc.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n \
    \           max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ max {\n            return i as isize - 1;\n        }\n        max = arr[i];\n\
    \    }\n    (arr.len() - 1) as isize\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpvejy8cku.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut count = vec![0;\
    \ max as usize + 1];\n    for i in 0..arr.len() {\n        count[arr[i] as usize]\
    \ += 1;\n    }\n    let mut sum = 0;\n    for i in 0..count.len() {\n        sum\
    \ += count[i];\n        count[i] = sum - count[i];\n    }\n    let mut output\
    \ = vec![0; arr.len()];\n    for i in 0..arr.len() {\n        output[count[arr[i]\
    \ as usize] as usize] = arr[i];\n        count[arr[i] as usize] += 1;\n    }\n\
    \    let mut max_index = -1;\n    for i in 1..arr.len() {\n        if output[i]\
    \ < output[i - 1] {\n            max_index = i as isize - 1;\n        }\n    }\n\
    \    max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `3`', /tmp/tmpdvrin8yw.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n \
    \           continue;\n        }\n        max_index = i as isize;\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp27os95ub.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = 0;\n    for i in (0..arr.len()).rev()\
    \ {\n        if arr[i] >= max_value {\n            max_value = arr[i];\n     \
    \       max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpl7xxewll.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_idx = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ >= arr[i - 1] {\n            max_idx = i as isize;\n        }\n    }\n    max_idx\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpojla7l2g.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n \
    \           continue;\n        }\n        max_index = i as isize;\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp27os95ub.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ max {\n            return i as isize - 1;\n        }\n        max = arr[i];\n\
    \    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpo82d_izy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = -1;\n    for (i, &x)\
    \ in arr.iter().enumerate() {\n        if x > max_value {\n            max_value\
    \ = x;\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp1luce1y0.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut result = -1;\n    for i in 0..arr.len() {\n        if i == 0\
    \ {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n   \
    \         result = i as isize;\n            break;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl0zb6rwv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvjmcplpc.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n \
    \           max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = -1;\n    for (i, &x)\
    \ in arr.iter().enumerate() {\n        if x > max_value {\n            max_value\
    \ = x;\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp1luce1y0.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = -1;\n    for (i, &x)\
    \ in arr.iter().enumerate() {\n        if x > max_value {\n            max_value\
    \ = x;\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp1luce1y0.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] > max_value {\n            max_value = arr[i];\n\
    \            max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp6_k8yhrt.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ max {\n            return i as isize - 1;\n        }\n        max = arr[i];\n\
    \    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpo82d_izy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ max {\n            return i as isize - 1;\n        }\n        max = arr[i];\n\
    \    }\n    (arr.len() - 1) as isize\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpvejy8cku.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = -1;\n    for (i, &x)\
    \ in arr.iter().enumerate() {\n        if x > max_value {\n            max_value\
    \ = x;\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp1luce1y0.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = std::isize::MIN;\n \
    \   for (index, value) in arr.iter().enumerate() {\n        if value > &max_value\
    \ {\n            max_index = index as isize;\n            max_value = *value;\n\
    \        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp7ieizonl.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut count = vec![0;\
    \ max as usize + 1];\n    for i in 0..arr.len() {\n        count[arr[i] as usize]\
    \ += 1;\n    }\n    let mut sum = 0;\n    for i in 0..count.len() {\n        sum\
    \ += count[i];\n        count[i] = sum - count[i];\n    }\n    for i in 0..arr.len()\
    \ {\n        if count[arr[i] as usize] != i as isize {\n            return i as\
    \ isize;\n        }\n    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpwwa9uuos.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut count = vec![0;\
    \ max as usize + 1];\n    for i in 0..arr.len() {\n        count[arr[i] as usize]\
    \ += 1;\n    }\n    let mut i = 0;\n    for j in 0..max as usize + 1 {\n     \
    \   while count[j] > 0 {\n            if j < arr[i] as usize {\n             \
    \   return i as isize - 1;\n            }\n            count[j] -= 1;\n      \
    \      i += 1;\n        }\n    }\n    return i as isize - 1;\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpwqx_zwcq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ arr[i - 1] {\n            max = i as isize;\n        }\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyxgl6j90.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut count = vec![0;\
    \ max as usize + 1];\n    for i in 0..arr.len() {\n        count[arr[i] as usize]\
    \ += 1;\n    }\n    let mut sum = 0;\n    for i in 0..count.len() {\n        sum\
    \ += count[i];\n        count[i] = sum - count[i];\n    }\n    let mut ans = vec![0;\
    \ arr.len()];\n    for i in 0..arr.len() {\n        ans[count[arr[i] as usize]\
    \ as usize] = arr[i];\n        count[arr[i] as usize] += 1;\n    }\n    let mut\
    \ max = -1;\n    for i in 0..ans.len() {\n        if ans[i] > max {\n        \
    \    max = ans[i];\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpvf8id_xb.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ arr[i - 1] {\n            max = i as isize;\n        }\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyxgl6j90.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n    max_index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvjmcplpc.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() - 1 {\n        if\
    \ arr[i] >= arr[i + 1] {\n            max_index = i as isize;\n        }\n   \
    \ }\n    max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp7qob1kv9.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut max_index = -1;\n\
    \    for i in 0..arr.len() {\n        if arr[i] == max {\n            max_index\
    \ = i as isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpr_q9bu0n.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_idx = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_idx = i as isize;\n        }\n    }\n    max_idx\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpq1fd_tjj.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ max {\n            return i as isize - 1;\n        }\n        max = arr[i];\n\
    \    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpo82d_izy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n \
    \           max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = 0;\n    for i in 0..arr.len() {\n        if arr[i] > arr[i\
    \ - 1] {\n            max = i as isize;\n        }\n    }\n    max\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp8pw56bfg.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    let mut i = arr.len() - 1;\n    while i > 0 {\n\
    \        if arr[i] < arr[i - 1] {\n            max = i as isize;\n        }\n\
    \        i -= 1;\n    }\n    max\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl5xcou0y.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] > max_value {\n            max_index = i as\
    \ isize;\n            max_value = arr[i];\n        }\n    }\n    max_index\n}\n\
    \nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpfcq7fw_3.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    if max == -1 {\n       \
    \ return -1;\n    }\n    let mut count = vec![0; max as usize + 1];\n    for i\
    \ in 0..arr.len() {\n        count[arr[i] as usize] += 1;\n    }\n    let mut\
    \ sum = 0;\n    for i in 0..count.len() {\n        sum += count[i];\n        count[i]\
    \ = sum - count[i];\n    }\n    let mut output = vec![0; arr.len()];\n    for\
    \ i in 0..arr.len() {\n        output[count[arr[i] as usize] as usize] = arr[i];\n\
    \        count[arr[i] as usize] += 1;\n    }\n    for i in 0..arr.len() {\n  \
    \      if output[i] < output[i + 1] {\n            return i as isize;\n      \
    \  }\n    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmps9nn3sfa.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if i == 0 {\n\
    \            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n       \
    \     max = i as isize;\n        }\n    }\n    max\n}\n\nfn main() {\n    let\
    \ candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut largest_index = -1;\n    for i in 0..arr.len() {\n        if\
    \ arr[i] > arr[i - 1] {\n            largest_index = i as isize;\n        }\n\
    \    }\n    largest_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpfmol08sq.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = 0;\n    let mut max_index = -1;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x > max {\n            max = x;\n            max_index = i as\
    \ isize;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpyc6hiir2.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ max {\n            return i as isize - 1;\n        }\n        max = arr[i];\n\
    \    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpo82d_izy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ < arr[i - 1] {\n            max_index = i as isize - 1;\n        }\n    }\n\
    \    max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpu7g24sh6.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    let mut max_value = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] > max_value {\n            max_index = i as\
    \ isize;\n            max_value = arr[i];\n        }\n    }\n    max_index\n}\n\
    \nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpfcq7fw_3.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 0
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        if arr[i] <= arr[i - 1] {\n \
    \           max_index = i as isize;\n        }\n    }\n    max_index\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659746884
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in (0..arr.len()).rev() {\n        if arr[i]\
    \ >= max {\n            max = i as isize;\n        }\n    }\n    max\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpcwlhkywq.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] <=\
    \ max {\n            return i as isize - 1;\n        }\n        max = arr[i];\n\
    \    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpo82d_izy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746885
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut count = vec![0;\
    \ max as usize + 1];\n    for i in 0..arr.len() {\n        count[arr[i] as usize]\
    \ += 1;\n    }\n    let mut sum = 0;\n    for i in 0..count.len() {\n        sum\
    \ += count[i];\n        count[i] = sum - count[i];\n    }\n    let mut output\
    \ = vec![0; arr.len()];\n    for i in 0..arr.len() {\n        output[count[arr[i]\
    \ as usize] as usize] = arr[i];\n        count[arr[i] as usize] += 1;\n    }\n\
    \    for i in 0..arr.len() {\n        arr[i] = output[i];\n    }\n    let mut\
    \ ans = -1;\n    for i in (0..arr.len() - 1).rev() {\n        if arr[i] <= arr[i\
    \ + 1] {\n            ans = i as isize;\n        }\n    }\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp311jxga1.rs:28:9\n   |\n6  | fn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n   |                --- help: consider changing this to be mutable:\
    \ `mut arr`\n...\n28 |         arr[i] = output[i];\n   |         ^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    let mut count = vec![0;\
    \ max as usize + 1];\n    for i in 0..arr.len() {\n        count[arr[i] as usize]\
    \ += 1;\n    }\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n   \
    \     if count[arr[i] as usize] > 0 {\n            count[arr[i] as usize] -= 1;\n\
    \            if arr[i] <= max_index {\n                return max_index;\n   \
    \         }\n            max_index = arr[i];\n        }\n    }\n    -1\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpckpb3_35.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746886
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_idx = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > arr[i - 1] {\n            max_idx = i as isize;\n        }\n    }\n    max_idx\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpq1fd_tjj.rs:9:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given array will not contain\n\
    /// duplicate values.\n/// Examples:\nfn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ <= arr[i - 1] {\n            max_index = i as isize;\n        }\n    }\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp091hwlmg.rs:9:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659746885
