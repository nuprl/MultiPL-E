completions:
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $r = reverse $s;\n    my %h = map { $_ => 1 } split //, $c;\n    for my\
  \ $i (0 .. length($s) - 1) {\n        if ($h{substr($s, $i, 1)}) {\n           \
  \ substr($s, $i, 1) = '';\n            substr($r, $i, 1) = '';\n        }\n    }\n\
  \    return ($s, $s eq $r);\n}"
- "    my $r = reverse($s);\n    my $res = $s;\n    for my $char (split //, $c) {\n\
  \        $res =~ s/$char//g;\n    }\n    return ($res, $res eq $r);\n}"
- "    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t, $t eq reverse $t);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my $r = join('', reverse(split(//, $s)));\n    my $t = join('', grep { index($c,\
  \ $_) == -1 } split(//, $s));\n    my $u = join('', grep { index($c, $_) == -1 }\
  \ split(//, $r));\n    return ($t, $t eq $u);\n}"
- "    my $result = $s;\n    for my $char (split //, $c) {\n        $result =~ s/$char//g;\n\
  \    }\n    return ($result, $result eq reverse $result);\n}"
- "    my @s = split //, $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my @r;\n\
  \    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless $c{$s[$i]};\n    }\n\
  \    my $r = join '', @r;\n    return ($r, $r eq reverse $r);\n}"
- "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome = $result\
  \ eq reverse $result;\n    return ($result, $is_palindrome);\n}"
- "    my $r = reverse $s;\n    my $result = $s;\n    for my $char (split //, $c)\
  \ {\n        $result =~ s/$char//g;\n    }\n    my $is_palindrome = $result eq $r;\n\
  \    return ($result, $is_palindrome);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { not $c{$_}\
  \ } split //, $s;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1\
  \ } @c;\n    my @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless\
  \ $c{$s[$i]};\n    }\n    my $r = join '', @r;\n    my $p = $r eq reverse $r;\n\
  \    return ($r, $p);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/$c//g;\n    return ($t, $t\
  \ eq $r);\n}"
- "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1\
  \ } @c;\n    my @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless\
  \ $c{$s[$i]};\n    }\n    my $r = join '', @r;\n    my $p = $r eq reverse $r;\n\
  \    return ($r, $p);\n}"
- "    my @c = split //, $c;\n    my %c = map { $_ => 1 } @c;\n    my @s = split //,\
  \ $s;\n    my @r = grep { !$c{$_} } @s;\n    my $r = join '', @r;\n    my $p = $r\
  \ eq reverse $r;\n    return ($r, $p);\n}"
- "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return ($r,\
  \ $r eq reverse $r);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $s2 = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($s2, $s2 eq reverse $s2);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}"
- "    my $result = '';\n    my %c = map { $_ => 1 } split //, $c;\n    for my $char\
  \ (split //, $s) {\n        $result .= $char unless $c{$char};\n    }\n    return\
  \ ($result, $result eq reverse $result);\n}"
- "    my $s_copy = $s;\n    my $c_copy = $c;\n    my $s_length = length($s);\n  \
  \  my $c_length = length($c);\n    my $i = 0;\n    my $j = 0;\n    my $k = 0;\n\
  \    my $l = 0;\n    my $m = 0;\n    my $n = 0;\n    my $o = 0;\n    my $p = 0;\n\
  \    my $q = 0;\n    my $r = 0;\n    my $s_new = \"\";\n    my $c_new = \"\";\n\
  \    my $s_new_length = 0;\n    my $c_new_length = 0;\n    my $s_new_reverse = \"\
  \";\n    my $s_new_reverse_length = 0;\n    my $s_new_reverse_copy = \"\";\n   \
  \ my $s_new_reverse_copy_length = 0;\n    my $s_new_reverse_copy_new = \"\";\n \
  \   my $s_new_reverse_copy_new_length = 0;\n    my $s_new_reverse_copy_new_reverse\
  \ = \"\";\n    my $s_new_reverse_copy_new_reverse_length = 0;\n    my $s_new_reverse_copy_new_reverse_copy\
  \ = \"\";\n    my $s_new_reverse_copy_new_reverse_copy_length = 0;\n    my $s_new_reverse_copy_new_reverse_copy_new\
  \ = \"\";\n    my $s_new_reverse_copy_new_reverse_copy_new_length = 0;\n    my $s_new_reverse_copy_new_reverse_copy_new_reverse\
  \ = \"\";\n    my $s_new_reverse_copy_new_reverse_copy_new_reverse_length = 0;\n\
  \    my $s_new_reverse_copy_new_reverse_copy_new_reverse_copy = \"\";\n    my $s_new_reverse_copy_new_reverse_copy_new_reverse_copy_length\
  \ = 0;\n    my $s_new_reverse_copy_new_reverse_copy_new_reverse_"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { not $c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    my $p = $t\
  \ eq $r ? 1 : 0;\n    return ($t, $p);\n}"
- "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return ($r,\
  \ $r eq reverse $r);\n}"
- "    my $result = $s;\n    $result =~ s/[$c]//g;\n    return ($result, $result eq\
  \ reverse $result);\n}"
- "    my $r = join '', grep { index($c, $_) == -1 } split '', $s;\n    return ($r,\
  \ $r eq reverse $r);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}"
- "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1\
  \ } @c;\n    my @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless\
  \ $c{$s[$i]};\n    }\n    my $r = join '', @r;\n    my $p = $r eq reverse $r;\n\
  \    return ($r, $p);\n}"
- "    my $result = $s;\n    for my $char (split //, $c) {\n        $result =~ s/$char//g;\n\
  \    }\n    return ($result, $result eq reverse $result);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    my $r_t = reverse\
  \ $t;\n    return ($t, $r_t eq $t);\n}"
- "    my $r = reverse($s);\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    my $p = $t\
  \ eq $r ? 1 : 0;\n    return ($t, $p);\n}"
- "    my $t = $s;\n    $t =~ s/[$c]//g;\n    my $r = reverse $t;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $r = reverse $s;\n    my $d = $s;\n    $d =~ s/[$c]//g;\n    my $p = $d\
  \ eq $r;\n    return ($d, $p);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = join '', grep { index($c, $_) < 0 } split //, $s;\n    return ($r,\
  \ $r eq reverse $r);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my $result = $s;\n    for my $char (split //, $c) {\n        $result =~ s/$char//g;\n\
  \    }\n    my $is_palindrome = $result eq reverse $result;\n    return ($result,\
  \ $is_palindrome);\n}"
- "    my $result = '';\n    my $is_palindrome = 0;\n    my %c_hash = map { $_ =>\
  \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        $result .= $char\
  \ unless $c_hash{$char};\n    }\n    $is_palindrome = 1 if $result eq reverse $result;\n\
  \    return ($result, $is_palindrome);\n}"
- "    my $result = '';\n    my $check = 1;\n    my %c = map { $_ => 1 } split //,\
  \ $c;\n    for my $char (split //, $s) {\n        if (!$c{$char}) {\n          \
  \  $result .= $char;\n        }\n    }\n    my $len = length $result;\n    for my\
  \ $i (0..$len/2-1) {\n        if (substr($result, $i, 1) ne substr($result, $len-$i-1,\
  \ 1)) {\n            $check = 0;\n            last;\n        }\n    }\n    return\
  \ ($result, $check);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = reverse $s;\n    my $t = join '', grep { index($c, $_) == -1 } split\
  \ //, $s;\n    return ($t, $t eq $r);\n}"
- "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $t =\
  \ join '', grep { !$c{$_} } split //, $s;\n    return ($t, $t eq $r);\n}"
- "    my $result = $s;\n    for my $char (split //, $c) {\n        $result =~ s/$char//g;\n\
  \    }\n    return ($result, $result eq reverse $result);\n}"
- "    my $r = reverse $s;\n    my $p = $s eq $r;\n    $s =~ s/[$c]//g;\n    return\
  \ ($s, $p);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $i =\
  \ 0;\n    my $j = 0;\n    my $l = length $s;\n    while ($i < $l) {\n        if\
  \ ($c{substr($s, $i, 1)}) {\n            $i++;\n            $j++;\n        }\n \
  \       elsif ($c{substr($r, $j, 1)}) {\n            $j++;\n        }\n        else\
  \ {\n            if (substr($s, $i, 1) ne substr($r, $j, 1)) {\n               \
  \ return (substr($s, $i), 0);\n            }\n            $i++;\n            $j++;\n\
  \        }\n    }\n    return (substr($s, $i), 1);\n}"
- "    my $r = reverse $s;\n    my $p = $s eq $r;\n    my %c = map { $_ => 1 } split\
  \ //, $c;\n    $s =~ s/[$c]//g;\n    return ($s, $p);\n}"
- "    my $s_copy = $s;\n    $s_copy =~ s/[$c]//g;\n    my $s_reverse = reverse $s_copy;\n\
  \    return ($s_copy, $s_copy eq $s_reverse);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome = $result\
  \ eq reverse $result;\n    return ($result, $is_palindrome);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}"
- "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome = $result\
  \ eq reverse $result;\n    return ($result, $is_palindrome);\n}"
- "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1\
  \ } @c;\n    my @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless\
  \ $c{$s[$i]};\n    }\n    my $r = join '', @r;\n    return ($r, $r eq reverse $r);\n\
  }"
- "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return ($r,\
  \ $r eq reverse $r);\n}"
- "    my $result = $s;\n    my %c = map { $_ => 1 } split //, $c;\n    $result =~\
  \ s/[$c]//g;\n    my $is_palindrome = $result eq reverse $result;\n    return ($result,\
  \ $is_palindrome);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my %c = map {$_ => 1} split('', $c);\n    my $r = join('', grep {!$c{$_}} split('',\
  \ $s));\n    return ($r, $r eq reverse($r));\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}"
- "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome = $result\
  \ eq reverse $result;\n    return ($result, $is_palindrome);\n}"
- "    my $r = '';\n    my %c = map {$_ => 1} split //, $c;\n    for my $i (0..length($s)-1)\
  \ {\n        my $ch = substr($s, $i, 1);\n        $r .= $ch unless $c{$ch};\n  \
  \  }\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my $result = $s;\n    for my $char (split //, $c) {\n        $result =~ s/$char//g;\n\
  \    }\n    return ($result, $result eq reverse $result);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}"
- "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome = $result\
  \ eq reverse $result;\n    return ($result, $is_palindrome);\n}"
- "    my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash = map { $_ =>\
  \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!exists $c_hash{$char})\
  \ {\n            $result .= $char;\n        }\n    }\n    my $reverse_result = reverse\
  \ $result;\n    if ($result ne $reverse_result) {\n        $is_palindrome = 0;\n\
  \    }\n    return ($result, $is_palindrome);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { not $c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my @s =\
  \ split //, $s;\n    my @r = split //, $r;\n    my @t;\n    for my $i (0 .. $#s)\
  \ {\n        if (not exists $c{$s[$i]}) {\n            push @t, $s[$i];\n      \
  \  }\n        if (not exists $c{$r[$i]}) {\n            push @t, $r[$i];\n     \
  \   }\n    }\n    my $t = join '', @t;\n    return ($t, $t eq reverse $t);\n}"
- "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome = $result\
  \ eq reverse $result;\n    return ($result, $is_palindrome);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/$c//g;\n    return ($t, $t\
  \ eq $r);\n}"
- "    my $r = reverse $s;\n    my $p = $s eq $r;\n    $s =~ s/[$c]//g;\n    return\
  \ ($s, $p);\n}"
- "    my %c = map {$_ => 1} split //, $c;\n    my $r = join '', grep {!$c{$_}} split\
  \ //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = join '', grep { index($c, $_) < 0 } split //, $s;\n    return ($r,\
  \ $r eq reverse $r);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}"
- "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome = $result\
  \ eq reverse $result;\n    return ($result, $is_palindrome);\n}"
- "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $i =\
  \ 0;\n    my $j = 0;\n    while ($i < length $s && $j < length $r) {\n        if\
  \ ($c{substr $s, $i, 1}) {\n            $i++;\n        }\n        elsif ($c{substr\
  \ $r, $j, 1}) {\n            $j++;\n        }\n        else {\n            if (substr($s,\
  \ $i, 1) ne substr($r, $j, 1)) {\n                return (substr($s, $i + 1, length\
  \ $s - $i - 1), 0);\n            }\n            $i++;\n            $j++;\n     \
  \   }\n    }\n    return (substr($s, $i + 1, length $s - $i - 1), 1);\n}"
- "    my $r = reverse $s;\n    my $c_hash = { map { $_ => 1 } split //, $c };\n \
  \   my $s_hash = { map { $_ => 1 } split //, $s };\n    my $r_hash = { map { $_\
  \ => 1 } split //, $r };\n    my $result = '';\n    for my $key (keys %$s_hash)\
  \ {\n        if (!exists $c_hash->{$key}) {\n            $result .= $key;\n    \
  \    }\n    }\n    my $r_result = reverse $result;\n    return ($result, $result\
  \ eq $r_result);\n}"
- "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $i =\
  \ 0;\n    while ($i < length $s) {\n        if ($c{substr $s, $i, 1}) {\n      \
  \      substr $s, $i, 1, '';\n            substr $r, $i, 1, '';\n        } else\
  \ {\n            $i++;\n        }\n    }\n    return ($s, $s eq $r);\n}"
- "    my $result = $s;\n    for my $char (split //, $c) {\n        $result =~ s/$char//g;\n\
  \    }\n    my $is_palindrome = $result eq reverse $result;\n    return ($result,\
  \ $is_palindrome);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/$c//g;\n    my $p = $t eq\
  \ $r ? 1 : 0;\n    return ($t, $p);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome = $result\
  \ eq reverse $result;\n    return ($result, $is_palindrome);\n}"
- "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $i =\
  \ 0;\n    my $j = 0;\n    while ($i < length $s && $j < length $r) {\n        if\
  \ ($c{substr $s, $i, 1}) {\n            $i++;\n        } elsif ($c{substr $r, $j,\
  \ 1}) {\n            $j++;\n        } else {\n            return ($s, 0) if substr($s,\
  \ $i, 1) ne substr($r, $j, 1);\n            $i++;\n            $j++;\n        }\n\
  \    }\n    return (substr($s, $i, length $s - $i), 1);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my $r = join '', grep { index($c, $_) < 0 } split //, $s;\n    return ($r,\
  \ $r eq reverse $r);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}"
- "    my $res = '';\n    my $is_palindrome = 1;\n    my %c_hash = map {$_ => 1} split\
  \ //, $c;\n    for my $char (split //, $s) {\n        if (!$c_hash{$char}) {\n \
  \           $res .= $char;\n        }\n    }\n    my $len = length $res;\n    for\
  \ (my $i = 0; $i < $len / 2; $i++) {\n        if (substr($res, $i, 1) ne substr($res,\
  \ $len - $i - 1, 1)) {\n            $is_palindrome = 0;\n            last;\n   \
  \     }\n    }\n    return ($res, $is_palindrome);\n}"
- "    my $res = $s;\n    for my $c1 (split //, $c) {\n        $res =~ s/$c1//g;\n\
  \    }\n    return ($res, $res eq reverse $res);\n}"
- "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome = $result\
  \ eq reverse $result;\n    return ($result, $is_palindrome);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $new_s = $s;\n    for my $char (split //, $c) {\n        $new_s =~ s/$char//g;\n\
  \    }\n    my $is_palindrome = $new_s eq reverse $new_s;\n    return ($new_s, $is_palindrome);\n\
  }"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash = map { $_ =>\
  \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!exists $c_hash{$char})\
  \ {\n            $result .= $char;\n        }\n    }\n    my $reversed_result =\
  \ reverse $result;\n    if ($result ne $reversed_result) {\n        $is_palindrome\
  \ = 0;\n    }\n    return ($result, $is_palindrome);\n}"
- "    my $result = '';\n    my %c = map { $_ => 1 } split //, $c;\n    for my $char\
  \ (split //, $s) {\n        $result .= $char unless $c{$char};\n    }\n    return\
  \ ($result, $result eq reverse $result);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash = map { $_ =>\
  \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!exists $c_hash{$char})\
  \ {\n            $result .= $char;\n        }\n    }\n    my $result_reverse = reverse\
  \ $result;\n    if ($result ne $result_reverse) {\n        $is_palindrome = 0;\n\
  \    }\n    return ($result, $is_palindrome);\n}"
- "    my $r = reverse $s;\n    my $p = $s eq $r;\n    $s =~ s/[$c]//g;\n    return\
  \ ($s, $p);\n}"
- "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my @s =\
  \ split //, $s;\n    my @r = split //, $r;\n    my @t;\n    for my $i (0 .. $#s)\
  \ {\n        if (exists $c{$s[$i]} && exists $c{$r[$i]}) {\n            $s[$i] =\
  \ $r[$i] = '';\n        }\n        elsif (exists $c{$s[$i]}) {\n            $s[$i]\
  \ = '';\n        }\n        elsif (exists $c{$r[$i]}) {\n            $r[$i] = '';\n\
  \        }\n    }\n    my $t = join '', @s;\n    my $u = join '', @r;\n    return\
  \ ($t, $t eq $u);\n}"
- "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $i =\
  \ 0;\n    my $j = 0;\n    while ($i < length $s and $j < length $r) {\n        if\
  \ ($c{substr $s, $i, 1}) {\n            $i++;\n        } elsif ($c{substr $r, $j,\
  \ 1}) {\n            $j++;\n        } else {\n            if (substr($s, $i, 1)\
  \ ne substr($r, $j, 1)) {\n                return (substr($s, $i), 0);\n       \
  \     }\n            $i++;\n            $j++;\n        }\n    }\n    return (substr($s,\
  \ $i), 1);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1\
  \ } @c;\n    my @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless\
  \ $c{$s[$i]};\n    }\n    my $r = join '', @r;\n    return ($r, $r eq reverse $r);\n\
  }"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1\
  \ } @c;\n    my @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless\
  \ $c{$s[$i]};\n    }\n    my $r = join '', @r;\n    my $p = $r eq reverse $r;\n\
  \    return ($r, $p);\n}"
- "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return ($r,\
  \ $r eq reverse $r);\n}"
- "    my $r = reverse $s;\n    my $t = join '', grep { index($c, $_) == -1 } split\
  \ //, $s;\n    return ($t, $t eq $r);\n}"
- "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return ($r,\
  \ $r eq reverse $r);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = reverse $s;\n    my $p = $s eq $r;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n\
  \    return ($t, $p);\n}"
- "    my $result = \"\";\n    my $is_palindrome = 1;\n    my %hash = map { $_ =>\
  \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!$hash{$char})\
  \ {\n            $result .= $char;\n        }\n    }\n    my $rev = reverse $result;\n\
  \    if ($result ne $rev) {\n        $is_palindrome = 0;\n    }\n    return ($result,\
  \ $is_palindrome);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return ($r,\
  \ $r eq reverse $r);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}"
- "    my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash = map { $_ =>\
  \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!$c_hash{$char})\
  \ {\n            $result .= $char;\n        }\n    }\n    my $len = length $result;\n\
  \    for (my $i = 0; $i < $len / 2; $i++) {\n        if (substr($result, $i, 1)\
  \ ne substr($result, $len - $i - 1, 1)) {\n            $is_palindrome = 0;\n   \
  \         last;\n        }\n    }\n    return ($result, $is_palindrome);\n}"
- "    my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash = map { $_ =>\
  \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!exists $c_hash{$char})\
  \ {\n            $result .= $char;\n        }\n    }\n    my $reverse_result = reverse\
  \ $result;\n    if ($result ne $reverse_result) {\n        $is_palindrome = 0;\n\
  \    }\n    return ($result, $is_palindrome);\n}"
- "    my %hash = map { $_ => 1 } split //, $c;\n    my $res = join '', grep { not\
  \ exists $hash{$_} } split //, $s;\n    return ($res, $res eq reverse $res);\n}"
- "    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t, $t eq reverse $t);\n}"
- "    my $t = $s;\n    $t =~ s/[$c]//g;\n    my $r = reverse $t;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $result = '';\n    my $check = 0;\n    my $i = 0;\n    my $j = 0;\n    my\
  \ $len = length($s);\n    my $len_c = length($c);\n    my $s_arr = split('', $s);\n\
  \    my $c_arr = split('', $c);\n    while ($i < $len) {\n        $j = 0;\n    \
  \    while ($j < $len_c) {\n            if ($s_arr[$i] eq $c_arr[$j]) {\n      \
  \          $check = 1;\n                last;\n            }\n            $j++;\n\
  \        }\n        if ($check == 0) {\n            $result .= $s_arr[$i];\n   \
  \     }\n        $check = 0;\n        $i++;\n    }\n    return ($result, $result\
  \ eq reverse($result));\n}"
- "    my $result = '';\n    my $is_palindrome = 0;\n    my %c_hash = map { $_ =>\
  \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        $result .= $char\
  \ unless $c_hash{$char};\n    }\n    $is_palindrome = 1 if $result eq reverse $result;\n\
  \    return ($result, $is_palindrome);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    my $p = $t\
  \ eq $r ? 1 : 0;\n    return ($t, $p);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1\
  \ } @c;\n    my @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless\
  \ $c{$s[$i]};\n    }\n    my $r = join '', @r;\n    return ($r, $r eq reverse $r);\n\
  }"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my %c_hash = map { $_ => 1 } split //, $c;\n    my $s_new = join '', grep {\
  \ !$c_hash{$_} } split //, $s;\n    my $s_new_reverse = reverse $s_new;\n    return\
  \ ($s_new, $s_new eq $s_new_reverse);\n}"
- "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $s2\
  \ = join '', grep { !$c{$_} } split //, $s;\n    my $r2 = join '', grep { !$c{$_}\
  \ } split //, $r;\n    return ($s2, $s2 eq $r2);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome = $result\
  \ eq reverse $result;\n    return ($result, $is_palindrome);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my $result = $s;\n    for my $char (split //, $c) {\n        $result =~ s/$char//g;\n\
  \    }\n    return ($result, $result eq reverse $result);\n}"
- "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $i =\
  \ 0;\n    while ($i < length $s) {\n        if ($c{substr $s, $i, 1}) {\n      \
  \      substr $s, $i, 1, '';\n            substr $r, $i, 1, '';\n        } else\
  \ {\n            $i++;\n        }\n    }\n    return ($s, $s eq $r);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/$c//g;\n    my $p = $t eq\
  \ $r ? 1 : 0;\n    return ($t, $p);\n}"
- "    my $s_copy = $s;\n    my $c_copy = $c;\n    my %c_hash;\n    my $s_length =\
  \ length($s);\n    my $c_length = length($c);\n    for (my $i = 0; $i < $c_length;\
  \ $i++) {\n        $c_hash{substr($c_copy, $i, 1)} = 1;\n    }\n    for (my $i =\
  \ 0; $i < $s_length; $i++) {\n        if (exists $c_hash{substr($s_copy, $i, 1)})\
  \ {\n            $s =~ s/substr($s_copy, $i, 1)//;\n        }\n    }\n    my $s_reverse\
  \ = reverse($s);\n    if ($s eq $s_reverse) {\n        return ($s, 1);\n    } else\
  \ {\n        return ($s, 0);\n    }\n}"
- "    my @s = split //, $s;\n    my %c = map {$_ => 1} split //, $c;\n    my @r;\n\
  \    for my $i (0..$#s) {\n        push @r, $s[$i] unless $c{$s[$i]};\n    }\n \
  \   my $r = join '', @r;\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $result = '';\n    my $is_palindrome = 0;\n    my %c_hash = map { $_ =>\
  \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!exists $c_hash{$char})\
  \ {\n            $result .= $char;\n        }\n    }\n    $is_palindrome = 1 if\
  \ $result eq reverse $result;\n    return ($result, $is_palindrome);\n}"
- "    my $res = $s;\n    $res =~ s/[$c]//g;\n    return ($res, $res eq reverse $res);\n\
  }"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $i =\
  \ 0;\n    my $j = 0;\n    while ($i < length $s and $j < length $r) {\n        if\
  \ ($c{substr $s, $i, 1}) {\n            $i++;\n        } elsif ($c{substr $r, $j,\
  \ 1}) {\n            $j++;\n        } else {\n            return ($s, 0) if substr($s,\
  \ $i, 1) ne substr($r, $j, 1);\n            $i++;\n            $j++;\n        }\n\
  \    }\n    return ($s, 1);\n}"
- "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $i =\
  \ 0;\n    my $j = 0;\n    while ($i < length $s && $j < length $r) {\n        if\
  \ ($c{substr $s, $i, 1}) {\n            $i++;\n        } elsif ($c{substr $r, $j,\
  \ 1}) {\n            $j++;\n        } else {\n            if (substr($s, $i, 1)\
  \ ne substr($r, $j, 1)) {\n                return (substr($s, $i), 0);\n       \
  \     }\n            $i++;\n            $j++;\n        }\n    }\n    return (substr($s,\
  \ $i), 1);\n}"
- "    my $r = reverse $s;\n    my %h;\n    @h{split //, $c} = ();\n    my $t = join\
  \ '', grep { !exists $h{$_} } split //, $s;\n    return ($t, $t eq $r);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $result = $s;\n    for my $char (split //, $c) {\n        $result =~ s/$char//g;\n\
  \    }\n    return ($result, $result eq reverse $result);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1\
  \ } @c;\n    my @res = grep { !$c{$_} } @s;\n    my $res = join '', @res;\n    return\
  \ ($res, $res eq reverse $res);\n}"
- "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1\
  \ } @c;\n    my @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless\
  \ $c{$s[$i]};\n    }\n    my $r = join '', @r;\n    my $p = $r eq reverse $r;\n\
  \    return ($r, $p);\n}"
- "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $i =\
  \ 0;\n    my $j = 0;\n    while ($i < length $s and $j < length $r) {\n        if\
  \ ($c{substr $s, $i, 1}) {\n            $i++;\n        } elsif ($c{substr $r, $j,\
  \ 1}) {\n            $j++;\n        } else {\n            if (substr($s, $i, 1)\
  \ ne substr($r, $j, 1)) {\n                return (substr($s, $i), 0);\n       \
  \     }\n            $i++;\n            $j++;\n        }\n    }\n    return (substr($s,\
  \ $i), 1);\n}"
- "    my $r = join '', reverse split //, $s;\n    my $t = join '', grep { index($c,\
  \ $_) == -1 } split //, $s;\n    return ($t, $t eq $r);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash = map { $_ =>\
  \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!$c_hash{$char})\
  \ {\n            $result .= $char;\n        }\n    }\n    my $reverse_result = reverse\
  \ $result;\n    if ($result ne $reverse_result) {\n        $is_palindrome = 0;\n\
  \    }\n    return ($result, $is_palindrome);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { not $c{$_}\
  \ } split //, $s;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $new_s = $s;\n    for my $char (split //, $c) {\n        $new_s =~ s/$char//g;\n\
  \    }\n    return ($new_s, $new_s eq reverse $new_s);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $t =\
  \ join '', grep { !$c{$_} } split //, $s;\n    my $u = join '', grep { !$c{$_} }\
  \ split //, $r;\n    return ($t, $t eq $u);\n}"
- "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return ($r,\
  \ $r eq reverse $r);\n}"
- "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return ($r,\
  \ $r eq reverse $r);\n}"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my $res = '';\n    my $is_palindrome = 1;\n    my %c_hash = map { $_ => 1 }\
  \ split //, $c;\n    for my $char (split //, $s) {\n        if (!$c_hash{$char})\
  \ {\n            $res .= $char;\n        }\n    }\n    my $rev_res = reverse $res;\n\
  \    $is_palindrome = 0 if $res ne $rev_res;\n    return ($res, $is_palindrome);\n\
  }"
- "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
  \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}"
- "    my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash = map { $_ =>\
  \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!exists $c_hash{$char})\
  \ {\n            $result .= $char;\n        }\n    }\n    my $reverse_result = reverse\
  \ $result;\n    if ($result ne $reverse_result) {\n        $is_palindrome = 0;\n\
  \    }\n    return ($result, $is_palindrome);\n}"
- "    my $r = reverse($s);\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    my $r_t =\
  \ reverse($t);\n    return ($t, $t eq $r_t);\n}"
- "    my @s = split //, $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my @r;\n\
  \    while (@s) {\n        my $ch = pop @s;\n        push @r, $ch unless $c{$ch};\n\
  \    }\n    my $r = join '', @r;\n    return ($r, $r eq reverse $r);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash = map { $_ =>\
  \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!$c_hash{$char})\
  \ {\n            $result .= $char;\n        }\n    }\n    my $result_reverse = reverse\
  \ $result;\n    if ($result ne $result_reverse) {\n        $is_palindrome = 0;\n\
  \    }\n    return ($result, $is_palindrome);\n}"
- "    my $r = reverse($s);\n    my $t = $s;\n    foreach my $i (split //, $c) {\n\
  \        $t =~ s/$i//g;\n    }\n    return ($t, $t eq $r);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
  \ ($r, $p);\n}"
- "    my %c = map {$_ => 1} split //, $c;\n    my $r = join '', grep {!$c{$_}} split\
  \ //, $s;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    $r = reverse $r;\n    return ($r, $r\
  \ eq $s);\n}"
- "    my $r = reverse $s;\n    my %h = map { $_ => 1 } split //, $c;\n    my $i =\
  \ 0;\n    while ($i < length $s) {\n        if ($h{substr $s, $i, 1}) {\n      \
  \      substr $s, $i, 1, '';\n            substr $r, $i, 1, '';\n        } else\
  \ {\n            $i++;\n        }\n    }\n    return ($s, $s eq $r);\n}"
- "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
  \ $t eq $r);\n}"
- "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $t = $r;\n    $t =~ tr/[A-Z]/[a-z]/;\n\
  \    $t =~ s/[^a-z]//g;\n    return ($r, $t eq reverse $t);\n}"
- "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return ($r,\
  \ $r eq reverse $r);\n}"
language: pl
name: HumanEval_112_reverse_delete
prompt: "# Task\n# We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n# then check if the result string is\
  \ palindrome.\n# A string is called palindrome if it reads the same backward as\
  \ forward.\n# You should return a tuple containing the result string and True/False\
  \ for the check.\n# Example\n# For s = \"abcde\", c = \"ae\", the result should\
  \ be ('bcd',False)\n# For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n\
  # For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\nsub reverse_delete\
  \ {\n    my($s, $c) = @_;\n"
stop_tokens:
- '

  sub'
- '

  #'
- '


  '
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&reverse_delete;\n\
  \        if(eq_deeply($candidate->(\"abcde\", \"ae\"),[\"bcd\", \"\"])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdef\", \"b\"),[\"acdef\", \"\"])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"ab\"),[\"cdedc\"\
  , 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  dwik\", \"w\"),[\"dik\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"a\", \"a\"),[\"\", 1])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdedcba\", \"\"),[\"abcdedcba\", 1])) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"v\"),[\"\
  abcdedcba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"vabba\", \"v\"),[\"abba\", 1])) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  mamma\", \"mia\"),[\"\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
