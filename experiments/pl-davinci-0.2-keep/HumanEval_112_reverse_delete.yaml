name: HumanEval_112_reverse_delete
language: pl
prompt: "# Task\n# We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n# then check if the result string is\
  \ palindrome.\n# A string is called palindrome if it reads the same backward as\
  \ forward.\n# You should return a tuple containing the result string and True/False\
  \ for the check.\n# Example\n# For s = \"abcde\", c = \"ae\", the result should\
  \ be ('bcd',False)\n# For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n\
  # For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\nsub reverse_delete\
  \ {\n    my($s, $c) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&reverse_delete;\n\
  \        if(eq_deeply($candidate->(\"abcde\", \"ae\"),[\"bcd\", \"\"])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdef\", \"b\"),[\"acdef\", \"\"])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"ab\"),[\"cdedc\"\
  , 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  dwik\", \"w\"),[\"dik\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"a\", \"a\"),[\"\", 1])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdedcba\", \"\"),[\"abcdedcba\", 1])) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"v\"),[\"\
  abcdedcba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"vabba\", \"v\"),[\"abba\", 1])) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  mamma\", \"mia\"),[\"\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t, $t eq reverse\
    \ $t);\n}", "    my $t = $s;\n    $t =~ s/[$c]//g;\n    my $r = reverse $t;\n\
    \    return ($t, $t eq $r);\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 1;\n    my %c_hash = map {$_ => 1} split('', $c);\n    my @s_arr = split('',\
    \ $s);\n    while (my $char = pop @s_arr) {\n        if (!exists $c_hash{$char})\
    \ {\n            $result .= $char;\n        }\n    }\n    my @result_arr = split('',\
    \ $result);\n    while (my $char = pop @result_arr) {\n        if ($char ne shift\
    \ @result_arr) {\n            $is_palindrome = 0;\n            last;\n       \
    \ }\n    }\n    return ($result, $is_palindrome);\n}", "    my $r = reverse $s;\n\
    \    my $t = $s;\n    $t =~ s/[$c]//g;\n    my $p = $t eq $r ? 1 : 0;\n    return\
    \ ($t, $p);\n}", "    my $regex = join '|', split '', $c;\n    $s =~ s/$regex//g;\n\
    \    return ($s, $s eq reverse $s);\n}", "    my $r = reverse $s;\n    my $t =\
    \ $s;\n    $t =~ s/[$c]//g;\n    return ($t, $t eq $r);\n}", "    my $r = reverse\
    \ $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t, $t eq $r);\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my $r = reverse $s;\n    my $r_c = reverse $c;\n    my $r_s = $s;\n    $r_s\
    \ =~ s/$c//g;\n    $r_s =~ s/$r_c//g;\n    my $r_r_s = reverse $r_s;\n    return\
    \ ($r_s, $r_s eq $r_r_s);\n}", "    my $r = reverse $s;\n    my %c = map { $_\
    \ => 1 } split //, $c;\n    my $i = 0;\n    my $j = 0;\n    while ($i < length\
    \ $s and $j < length $r) {\n        if ($c{substr $s, $i, 1}) {\n            $i++;\n\
    \        } elsif ($c{substr $r, $j, 1}) {\n            $j++;\n        } else {\n\
    \            if (substr($s, $i, 1) ne substr($r, $j, 1)) {\n                return\
    \ (substr($s, $i), 0);\n            }\n            $i++;\n            $j++;\n\
    \        }\n    }\n    return (substr($s, $i), 1);\n}", "    my $r = $s;\n   \
    \ $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "    my $r = join\
    \ '', grep { index($c, $_) == -1 } split //, $s;\n    return ($r, $r eq reverse\
    \ $r);\n}", "    my $r = reverse($s);\n    my $t = $s;\n    $t =~ s/[$c]//g;\n\
    \    my $r_t = reverse($t);\n    return ($t, $t eq $r_t);\n}", "    my %h = map\
    \ { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$h{$_} } split //, $s;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my %c = map { $_ => 1 } split //,\
    \ $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    my $p = $r eq\
    \ reverse $r;\n    return ($r, $p);\n}", "    my $result = $s;\n    $result =~\
    \ s/[$c]//g;\n    my $is_palindrome = $result eq reverse $result;\n    return\
    \ ($result, $is_palindrome);\n}", "    my %c = map { $_ => 1 } split //, $c;\n\
    \    my $r = join '', grep { !$c{$_} } split //, $s;\n    return ($r, $r eq reverse\
    \ $r);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $new_s = '';\n\
    \    for my $char (split //, $s) {\n        $new_s .= $char unless $c{$char};\n\
    \    }\n    my $is_palindrome = $new_s eq reverse $new_s;\n    return ($new_s,\
    \ $is_palindrome);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my $r = join '', grep { index($c, $_) == -1 } split\
    \ //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my $r = reverse $s;\n\
    \    my %c = map { $_ => 1 } split //, $c;\n    my $t = join '', grep { !$c{$_}\
    \ } split //, $s;\n    my $u = join '', grep { !$c{$_} } split //, $r;\n    return\
    \ ($t, $t eq $u);\n}", "    my $r = reverse $s;\n    my %c = map {$_ => 1} split\
    \ //, $c;\n    my $t = '';\n    for my $i (0 .. length($s) - 1) {\n        $t\
    \ .= substr($s, $i, 1) unless $c{substr($s, $i, 1)};\n    }\n    return ($t, $t\
    \ eq $r);\n}", "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c\
    \ = map { $_ => 1 } @c;\n    my @res = grep { !$c{$_} } @s;\n    my $res = join\
    \ '', @res;\n    my $palindrome = $res eq reverse $res;\n    return ($res, $palindrome);\n\
    }", "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return\
    \ ($t, $t eq $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my @s = split //, $s;\n    my @c = split //, $c;\n\
    \    my %c = map { $_ => 1 } @c;\n    my @r;\n    for my $i (0 .. $#s) {\n   \
    \     push @r, $s[$i] unless $c{$s[$i]};\n    }\n    my $r = join '', @r;\n  \
    \  my $p = $r eq reverse $r;\n    return ($r, $p);\n}", "    my %c = map { $_\
    \ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = reverse $s;\n    my $t =\
    \ $s;\n    $t =~ s/[$c]//g;\n    return ($t, $t eq $r);\n}", "    my $r = join\
    \ '', reverse split //, $s;\n    my $t = join '', grep { index($c, $_) == -1 }\
    \ split //, $s;\n    return ($t, $t eq $r);\n}", "    my $r = join '', grep {\
    \ index($c, $_) == -1 } split //, $s;\n    return ($r, $r eq reverse $r);\n}",
  "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1\
    \ } @c;\n    my @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless\
    \ $c{$s[$i]};\n    }\n    my $r = join '', @r;\n    my $p = $r eq reverse $r;\n\
    \    return ($r, $p);\n}", "    my $r = reverse $s;\n    my $t = $s;\n    $t =~\
    \ s/[$c]//g;\n    my $p = $t eq $r ? 1 : 0;\n    return ($t, $p);\n}", "    my\
    \ $result = '';\n    my %c_hash = map { $_ => 1 } split //, $c;\n    for my $char\
    \ (split //, $s) {\n        $result .= $char unless $c_hash{$char};\n    }\n \
    \   return ($result, $result eq reverse $result);\n}", "    my $result = $s;\n\
    \    $result =~ s/[$c]//g;\n    return ($result, $result eq reverse $result);\n\
    }", "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return\
    \ ($r, $r eq reverse $r);\n}", "    my $result = '';\n    my $is_palindrome =\
    \ 1;\n    my %c_hash = map { $_ => 1 } split //, $c;\n    for my $char (split\
    \ //, $s) {\n        if (!exists $c_hash{$char}) {\n            $result .= $char;\n\
    \        }\n    }\n    for my $i (0 .. length($result) / 2) {\n        if (substr($result,\
    \ $i, 1) ne substr($result, -1 - $i, 1)) {\n            $is_palindrome = 0;\n\
    \            last;\n        }\n    }\n    return ($result, $is_palindrome);\n}",
  "    my $new_s = $s;\n    for my $char (split //, $c) {\n        $new_s =~ s/$char//g;\n\
    \    }\n    return ($new_s, $new_s eq reverse $new_s);\n}", "    my $r = $s;\n\
    \    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "    my $result\
    \ = '';\n    my %c_hash = map { $_ => 1 } split //, $c;\n    for my $char (split\
    \ //, $s) {\n        $result .= $char unless $c_hash{$char};\n    }\n    return\
    \ ($result, $result eq reverse $result);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my %c = map { $_ => 1 } split //,\
    \ $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    my $p = $r eq\
    \ reverse $r;\n    return ($r, $p);\n}", "    my $r = reverse $s;\n    my %c =\
    \ map { $_ => 1 } split //, $c;\n    my @s = split //, $s;\n    my @r = split\
    \ //, $r;\n    my @t;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @s && $j\
    \ < @r) {\n        if ($c{$s[$i]} || $c{$r[$j]}) {\n            $c{$s[$i]} ? $i++\
    \ : $i;\n            $c{$r[$j]} ? $j++ : $j;\n        } else {\n            push\
    \ @t, $s[$i];\n            $i++;\n            $j++;\n        }\n    }\n    my\
    \ $t = join '', @t;\n    return ($t, $t eq reverse $t);\n}", "    my $r = reverse\
    \ $s;\n    my $p = $s eq $r;\n    my %c = map { $_ => 1 } split //, $c;\n    $s\
    \ =~ s/[$c]//g;\n    return ($s, $p);\n}", "    my %hash = map { $_ => 1 } split\
    \ //, $c;\n    my $new_s = join '', grep { !$hash{$_} } split //, $s;\n    return\
    \ ($new_s, $new_s eq reverse $new_s);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my %c = map { $_ => 1 } split //,\
    \ $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    return ($r, $r\
    \ eq reverse $r);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r =\
    \ join '', grep { !$c{$_} } split //, $s;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome =\
    \ $result eq reverse $result;\n    return ($result, $is_palindrome);\n}", "  \
    \  my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my %c = map {$_ => 1} split //, $c;\n    my $r = join '', grep {!$c{$_}} split\
    \ //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my %c = map { $_ => 1\
    \ } split //, $c;\n    my $s2 = join '', grep { !$c{$_} } split //, $s;\n    return\
    \ ($s2, $s2 eq reverse $s2);\n}", "    my $r = reverse $s;\n    my $i = 0;\n \
    \   my $j = 0;\n    my $n = length $s;\n    my $m = length $c;\n    while ($i\
    \ < $n && $j < $m) {\n        if (substr($s, $i, 1) eq substr($c, $j, 1)) {\n\
    \            substr($s, $i, 1) = '';\n            substr($r, $i, 1) = '';\n  \
    \          $i--;\n            $n--;\n        }\n        $i++;\n        $j++;\n\
    \    }\n    return ($s, $s eq $r);\n}", "    my $result = $s;\n    for my $char\
    \ (split //, $c) {\n        $result =~ s/$char//g;\n    }\n    my $is_palindrome\
    \ = $result eq reverse $result;\n    return ($result, $is_palindrome);\n}", " \
    \   my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash = map { $_ =>\
    \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!exists $c_hash{$char})\
    \ {\n            $result .= $char;\n        }\n    }\n    my $reverse_result =\
    \ reverse $result;\n    if ($result ne $reverse_result) {\n        $is_palindrome\
    \ = 0;\n    }\n    return ($result, $is_palindrome);\n}", "    my $result = '';\n\
    \    my $is_palindrome = 1;\n    my %c_hash = map { $_ => 1 } split //, $c;\n\
    \    for my $char (split //, $s) {\n        if (!exists $c_hash{$char}) {\n  \
    \          $result .= $char;\n        }\n    }\n    my $len = length $result;\n\
    \    for (my $i = 0; $i < $len / 2; $i++) {\n        if (substr($result, $i, 1)\
    \ ne substr($result, $len - $i - 1, 1)) {\n            $is_palindrome = 0;\n \
    \           last;\n        }\n    }\n    return ($result, $is_palindrome);\n}",
  "    my $r = reverse $s;\n    my %c = map {$_ => 1} split //, $c;\n    my $i = 0;\n\
    \    my $j = 0;\n    while ($i < length $s && $j < length $r) {\n        if ($c{substr\
    \ $s, $i, 1}) {\n            $i++;\n        } elsif ($c{substr $r, $j, 1}) {\n\
    \            $j++;\n        } else {\n            if (substr($s, $i, 1) ne substr($r,\
    \ $j, 1)) {\n                return (substr($s, $i + 1, length $s - $i - 1), 0);\n\
    \            }\n            $i++;\n            $j++;\n        }\n    }\n    return\
    \ (substr($s, $i + 1, length $s - $i - 1), 1);\n}", "    my $r = reverse $s;\n\
    \    my $t = $s;\n    $t =~ s/[$c]//g;\n    my $p = $t eq $r ? 'True' : 'False';\n\
    \    return ($t, $p);\n}", "    my $r = reverse $s;\n    my $t = $s;\n    $t =~\
    \ s/[$c]//g;\n    my $p = $t eq $r ? 1 : 0;\n    return ($t, $p);\n}", "    my\
    \ $r = join '', reverse split //, $s;\n    my $t = join '', grep { index($c, $_)\
    \ < 0 } split //, $s;\n    return ($t, $t eq $r);\n}", "    my %c = map { $_ =>\
    \ 1 } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n   \
    \ return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    my $p = $r eq reverse $r;\n    return ($r, $p);\n}", "    my $t = $s;\n \
    \   $t =~ s/[$c]//g;\n    return ($t, $t eq reverse $t);\n}", "    my $r = reverse\
    \ $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $i = 0;\n    my $j =\
    \ 0;\n    while ($i < length $s && $j < length $r) {\n        if ($c{substr $s,\
    \ $i, 1}) {\n            $i++;\n        } elsif ($c{substr $r, $j, 1}) {\n   \
    \         $j++;\n        } else {\n            if (substr($s, $i, 1) ne substr($r,\
    \ $j, 1)) {\n                return (substr($s, $i), 0);\n            }\n    \
    \        $i++;\n            $j++;\n        }\n    }\n    return (substr($s, $i),\
    \ 1);\n}", "    my $result = $s;\n    for my $c_char (split //, $c) {\n      \
    \  $result =~ s/$c_char//g;\n    }\n    my $is_palindrome = $result eq reverse\
    \ $result;\n    return ($result, $is_palindrome);\n}", "    my $r = reverse $s;\n\
    \    my $l = length $s;\n    my $i = 0;\n    my $j = 0;\n    my $k = 0;\n    my\
    \ $p = 0;\n    my $q = 0;\n    my $t = 0;\n    my $u = 0;\n    my $v = 0;\n  \
    \  my $w = 0;\n    my $x = 0;\n    my $y = 0;\n    my $z = 0;\n    my $a = 0;\n\
    \    my $b = 0;\n    my $d = 0;\n    my $e = 0;\n    my $f = 0;\n    my $g = 0;\n\
    \    my $h = 0;\n    my $m = 0;\n    my $n = 0;\n    my $o = 0;\n    my $aa =\
    \ 0;\n    my $bb = 0;\n    my $cc = 0;\n    my $dd = 0;\n    my $ee = 0;\n   \
    \ my $ff = 0;\n    my $gg = 0;\n    my $hh = 0;\n    my $ii = 0;\n    my $jj =\
    \ 0;\n    my $kk = 0;\n    my $ll = 0;\n    my $mm = 0;\n    my $nn = 0;\n   \
    \ my $oo = 0;\n    my $pp = 0;\n    my $qq = 0;\n    my $rr = 0;\n    my $ss =\
    \ 0;\n    my $tt = 0;\n    my $uu = 0;\n    my $vv = 0;\n    my $ww = 0;\n   \
    \ my $xx = 0;\n    my $yy = 0;\n    my $zz = 0;\n    my $aaa = 0;\n    my $bbb\
    \ = 0;\n    my $ccc = 0;\n    my $ddd = 0;\n    my $eee = 0;\n    my $fff = 0;\n\
    \    my $ggg = 0;\n    my $hhh = 0;\n    my $iii = 0;\n    my $jjj = 0;\n    my\
    \ $kkk = 0;\n    my $lll = 0;\n    my $", "    my $res = '';\n    my $check =\
    \ 1;\n    my %c = map { $_ => 1 } split //, $c;\n    for my $i (0 .. length($s)\
    \ - 1) {\n        my $char = substr($s, $i, 1);\n        if (!exists $c{$char})\
    \ {\n            $res .= $char;\n        }\n    }\n    for my $i (0 .. length($res)\
    \ - 1) {\n        my $char1 = substr($res, $i, 1);\n        my $char2 = substr($res,\
    \ -$i - 1, 1);\n        if ($char1 ne $char2) {\n            $check = 0;\n   \
    \         last;\n        }\n    }\n    return ($res, $check);\n}", "    my $result\
    \ = $s;\n    for my $char (split //, $c) {\n        $result =~ s/$char//g;\n \
    \   }\n    my $is_palindrome = $result eq reverse $result;\n    return ($result,\
    \ $is_palindrome);\n}", "    my %hash = map { $_ => 1 } split //, $c;\n    my\
    \ $result = join '', grep { !$hash{$_} } split //, $s;\n    return ($result, $result\
    \ eq reverse $result);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my\
    \ $s_rev = reverse $s;\n    my $s_rev_c = join '', grep { !$c{$_} } split //,\
    \ $s_rev;\n    my $s_c = join '', grep { !$c{$_} } split //, $s;\n    return ($s_c,\
    \ $s_rev_c eq $s_c);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r\
    \ = join '', grep { !$c{$_} } split //, $s;\n    my $p = $r eq reverse $r;\n \
    \   return ($r, $p);\n}", "    my $r = '';\n    my $p = 1;\n    my %c = map {\
    \ $_ => 1 } split //, $c;\n    for my $i (0 .. length($s) - 1) {\n        my $ch\
    \ = substr($s, $i, 1);\n        if (!exists $c{$ch}) {\n            $r .= $ch;\n\
    \        }\n    }\n    for my $i (0 .. length($r) - 1) {\n        my $ch1 = substr($r,\
    \ $i, 1);\n        my $ch2 = substr($r, -$i - 1, 1);\n        if ($ch1 ne $ch2)\
    \ {\n            $p = 0;\n            last;\n        }\n    }\n    return ($r,\
    \ $p);\n}", "    my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash\
    \ = map { $_ => 1 } split //, $c;\n    for my $char (split //, $s) {\n       \
    \ if (!exists $c_hash{$char}) {\n            $result .= $char;\n        }\n  \
    \  }\n    my $result_reverse = reverse $result;\n    if ($result ne $result_reverse)\
    \ {\n        $is_palindrome = 0;\n    }\n    return ($result, $is_palindrome);\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n  \
    \  return ($r, $p);\n}", "    my $res = $s;\n    $res =~ s/[$c]//g;\n    my $rev\
    \ = reverse $res;\n    return ($res, $res eq $rev);\n}", "    my $r = reverse\
    \ $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $i = 0;\n    my $j =\
    \ 0;\n    while ($i < length $s and $j < length $r) {\n        if ($c{substr $s,\
    \ $i, 1}) {\n            $i++;\n        }\n        elsif ($c{substr $r, $j, 1})\
    \ {\n            $j++;\n        }\n        else {\n            if (substr($s,\
    \ $i, 1) ne substr($r, $j, 1)) {\n                return (substr($s, $i + 1),\
    \ 0);\n            }\n            $i++;\n            $j++;\n        }\n    }\n\
    \    return (substr($s, $i + 1), 1);\n}", "    my $r = reverse $s;\n    my $t\
    \ = $s;\n    $t =~ s/[$c]//g;\n    return ($t, $t eq $r);\n}", "    my $r = reverse\
    \ $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t, $t eq $r);\n}",
  "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1\
    \ } @c;\n    my @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless\
    \ $c{$s[$i]};\n    }\n    my $r = join '', @r;\n    return ($r, $r eq reverse\
    \ $r);\n}", "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n\
    \    return ($t, $t eq $r);\n}", "    my $r = reverse $s;\n    my $t = $s;\n \
    \   $t =~ s/[$c]//g;\n    my $p = $t eq $r ? 1 : 0;\n    return ($t, $p);\n}",
  "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
    \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my $result = '';\n\
    \    my $is_palindrome = 0;\n    my %c_hash = map { $_ => 1 } split //, $c;\n\
    \    for my $char (split //, $s) {\n        $result .= $char unless $c_hash{$char};\n\
    \    }\n    $is_palindrome = 1 if $result eq reverse $result;\n    return ($result,\
    \ $is_palindrome);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my $r = reverse $s;\n    my $t = $s;\n    $t =~\
    \ s/[$c]//g;\n    return ($t, $t eq $r);\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 1;\n    my %c_hash = map { $_ => 1 } split //, $c;\n    for my $char (split\
    \ //, $s) {\n        if (!exists $c_hash{$char}) {\n            $result .= $char;\n\
    \        }\n    }\n    my $reverse_result = reverse $result;\n    if ($result\
    \ ne $reverse_result) {\n        $is_palindrome = 0;\n    }\n    return ($result,\
    \ $is_palindrome);\n}", "    my $r = reverse $s;\n    my $r_is_palindrome = $r\
    \ eq $s;\n    my $r_is_palindrome_after_delete = $r_is_palindrome;\n    for my\
    \ $c_char (split //, $c) {\n        $s =~ s/$c_char//g;\n        $r =~ s/$c_char//g;\n\
    \        $r_is_palindrome_after_delete = $r eq $s;\n    }\n    return ($s, $r_is_palindrome_after_delete);\n\
    }", "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
    \ } split //, $s;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}", " \
    \   my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
    \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my %c = map {\
    \ $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 0;\n    my %hash = map { $_ => 1 } split //, $c;\n    for my $char (split\
    \ //, $s) {\n        $result .= $char unless $hash{$char};\n    }\n    $is_palindrome\
    \ = 1 if $result eq reverse $result;\n    return ($result, $is_palindrome);\n}",
  "    my $res = '';\n    my $is_palindrome = 1;\n    my %c_hash = map { $_ => 1 }\
    \ split('', $c);\n    for my $char (split('', $s)) {\n        if (!exists $c_hash{$char})\
    \ {\n            $res .= $char;\n        }\n    }\n    my $res_reverse = reverse\
    \ $res;\n    if ($res ne $res_reverse) {\n        $is_palindrome = 0;\n    }\n\
    \    return ($res, $is_palindrome);\n}", "    my $r = join('', reverse split('',\
    \ $s));\n    my $t = join('', reverse split('', $c));\n    my $p = join('', reverse\
    \ split('', $r));\n    my $q = join('', reverse split('', $t));\n    my $a = $s;\n\
    \    my $b = $c;\n    my $i = 0;\n    my $j = 0;\n    my $k = 0;\n    my $l =\
    \ 0;\n    my $m = 0;\n    my $n = 0;\n    my $o = 0;\n    my $p = 0;\n    my $q\
    \ = 0;\n    my $r = 0;\n    my $s = 0;\n    my $t = 0;\n    my $u = 0;\n    my\
    \ $v = 0;\n    my $w = 0;\n    my $x = 0;\n    my $y = 0;\n    my $z = 0;\n  \
    \  my $aa = 0;\n    my $bb = 0;\n    my $cc = 0;\n    my $dd = 0;\n    my $ee\
    \ = 0;\n    my $ff = 0;\n    my $gg = 0;\n    my $hh = 0;\n    my $ii = 0;\n \
    \   my $jj = 0;\n    my $kk = 0;\n    my $ll = 0;\n    my $mm = 0;\n    my $nn\
    \ = 0;\n    my $oo = 0;\n    my $pp = 0;\n    my $qq = 0;\n    my $rr = 0;\n \
    \   my $ss = 0;\n    my $tt = 0;\n    my $uu = 0;\n    my $vv = 0;\n    my $ww\
    \ = 0;\n    my $xx = 0;\n    my $yy = 0;\n    my $zz = 0;\n    my $aaa = 0;\n\
    \    my $bbb = 0;\n    my $ccc = 0;\n    my $ddd = 0;\n    my $eee = 0;\n    my\
    \ $fff = 0;\n    my $ggg = 0;\n    my $hhh = 0;\n    my $iii = 0;\n", "    my\
    \ @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1 } @c;\n\
    \    my @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless $c{$s[$i]};\n\
    \    }\n    my $r = join '', @r;\n    my $p = $r eq reverse $r;\n    return ($r,\
    \ $p);\n}", "    my $r = join '', grep { index($c, $_) < 0 } split //, $s;\n \
    \   return ($r, $r eq reverse $r);\n}", "    my %c = map { $_ => 1 } split //,\
    \ $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    return ($r, $r\
    \ eq reverse $r);\n}", "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my\
    \ $is_palindrome = $result eq reverse $result;\n    return ($result, $is_palindrome);\n\
    }", "    my $r = reverse $s;\n    my $t = join '', grep { index($c, $_) < 0 }\
    \ split //, $s;\n    return ($t, $t eq $r);\n}", "    my %c = map { $_ => 1 }\
    \ split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    return\
    \ ($r, $r eq reverse $r);\n}", "    my %c = map { $_ => 1 } split //, $c;\n  \
    \  my $r = join '', grep { !$c{$_} } split //, $s;\n    return ($r, $r eq reverse\
    \ $r);\n}", "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = reverse $s;\n    my %c =\
    \ map { $_ => 1 } split //, $c;\n    my $i = 0;\n    my $j = 0;\n    while ($i\
    \ < length $s && $j < length $r) {\n        if ($c{substr $s, $i, 1}) {\n    \
    \        $i++;\n        } elsif ($c{substr $r, $j, 1}) {\n            $j++;\n\
    \        } else {\n            if (substr($s, $i, 1) ne substr($r, $j, 1)) {\n\
    \                return (substr($s, $i), 0);\n            }\n            $i++;\n\
    \            $j++;\n        }\n    }\n    return (substr($s, $i), 1);\n}", " \
    \   my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
    \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my %c = map {\
    \ $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my %c = map {$_ => 1} split //,\
    \ $c;\n    my $r = join '', grep {!$c{$_}} split //, $s;\n    return ($r, $r eq\
    \ reverse $r);\n}", "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split\
    \ //, $c;\n    my $i = 0;\n    while ($i < length $s) {\n        if ($c{substr\
    \ $s, $i, 1}) {\n            substr $s, $i, 1, '';\n            substr $r, $i,\
    \ 1, '';\n        } else {\n            $i++;\n        }\n    }\n    return ($s,\
    \ $s eq $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse\
    \ $r;\n    return ($r, $p);\n}", "    my $r = join '', grep { index($c, $_) ==\
    \ -1 } split //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my $t = $s;\n\
    \    $t =~ s/[$c]//g;\n    return ($t, $t eq reverse $t);\n}", "    my %c = map\
    \ { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my %c = map { $_ => 1 } split //,\
    \ $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    return ($r, $r\
    \ eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r\
    \ eq reverse $r;\n    return ($r, $p);\n}", "    my %c = map { $_ => 1 } split\
    \ //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my $r = '';\n    my %c = map { $_ => 1 } split\
    \ //, $c;\n    for my $ch (split //, $s) {\n        $r .= $ch unless $c{$ch};\n\
    \    }\n    return ($r, $r eq reverse $r);\n}", "    my $result = $s;\n    $result\
    \ =~ s/[$c]//g;\n    my $is_palindrome = $result eq reverse $result;\n    return\
    \ ($result, $is_palindrome);\n}", "    my $r = join '', reverse split //, $s;\n\
    \    my $p = $s eq $r;\n    my $d = $s;\n    $d =~ s/[$c]//g;\n    return ($d,\
    \ $p);\n}", "    my %c = map {$_ => 1} split //, $c;\n    my $r = join '', grep\
    \ {!$c{$_}} split //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my $r\
    \ = reverse $s;\n    my $t = join '', grep { index($c, $_) == -1 } split //, $s;\n\
    \    return ($t, $t eq $r);\n}", "    my $r = join '', reverse split //, $s;\n\
    \    my $t = join '', grep { index($c, $_) == -1 } split //, $s;\n    return ($t,\
    \ $t eq $r);\n}", "    my $res = '';\n    my %h = map { $_ => 1 } split //, $c;\n\
    \    for my $ch (split //, $s) {\n        $res .= $ch unless $h{$ch};\n    }\n\
    \    my $rev = reverse $res;\n    return ($res, $res eq $rev);\n}", "    my $r\
    \ = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t, $t eq\
    \ $r);\n}", "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n\
    \    my $i = 0;\n    my $j = 0;\n    while ($i < length $s && $j < length $r)\
    \ {\n        if ($c{substr $s, $i, 1}) {\n            $i++;\n        } elsif ($c{substr\
    \ $r, $j, 1}) {\n            $j++;\n        } else {\n            if (substr($s,\
    \ $i, 1) ne substr($r, $j, 1)) {\n                return (substr($s, $i), 0);\n\
    \            }\n            $i++;\n            $j++;\n        }\n    }\n    return\
    \ (substr($s, $i), 1);\n}", "    my $t = $s;\n    $t =~ s/[$c]//g;\n    my $r\
    \ = reverse $t;\n    return ($t, $t eq $r);\n}", "    my $res = '';\n    my %c\
    \ = map { $_ => 1 } split //, $c;\n    for my $char (split //, $s) {\n       \
    \ $res .= $char unless $c{$char};\n    }\n    my $rev = reverse $res;\n    return\
    \ ($res, $res eq $rev);\n}", "    my $r = reverse $s;\n    my %h = map { $_ =>\
    \ 1 } split //, $c;\n    my $i = 0;\n    while ($i < length $s) {\n        if\
    \ ($h{substr $s, $i, 1}) {\n            substr $s, $i, 1, '';\n            substr\
    \ $r, $i, 1, '';\n        } else {\n            $i++;\n        }\n    }\n    return\
    \ ($s, $s eq $r);\n}", "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split\
    \ //, $c;\n    my $i = 0;\n    while ($i < length $s) {\n        if ($c{substr\
    \ $s, $i, 1}) {\n            substr $s, $i, 1, '';\n            substr $r, $i,\
    \ 1, '';\n        } else {\n            $i++;\n        }\n    }\n    return ($s,\
    \ $s eq $r);\n}", "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/$c//g;\n\
    \    my $p = $t eq $r ? 1 : 0;\n    return ($t, $p);\n}", "    my $r = reverse\
    \ $s;\n    my $t = $s;\n    $t =~ s/$c//g;\n    return ($t, $t eq $r);\n}", " \
    \   my $result = $s;\n    for my $char (split //, $c) {\n        $result =~ s/$char//g;\n\
    \    }\n    return ($result, $result eq reverse $result);\n}", "    my $result\
    \ = $s;\n    $result =~ s/[$c]//g;\n    return ($result, $result eq reverse $result);\n\
    }", "    my $s1 = $s;\n    $s1 =~ s/[$c]//g;\n    my $s2 = reverse $s1;\n    return\
    \ ($s1, $s1 eq $s2);\n}", "    my %c = map {$_ => 1} split //, $c;\n    my $r\
    \ = join '', grep {!$c{$_}} split //, $s;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $result = $s;\n    for my $i (0 .. length($c) - 1) {\n        my $char\
    \ = substr($c, $i, 1);\n        $result =~ s/$char//g;\n    }\n    my $is_palindrome\
    \ = $result eq reverse($result);\n    return ($result, $is_palindrome);\n}", " \
    \   my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
    \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my %hash = map\
    \ { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$hash{$_} } split //,\
    \ $s;\n    return ($r, $r eq reverse $r);\n}", "    my %c = map { $_ => 1 } split\
    \ //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my $result = $s;\n    for my $char (split //, $c)\
    \ {\n        $result =~ s/$char//g;\n    }\n    return ($result, $result eq reverse\
    \ $result);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join\
    \ '', grep { !$c{$_} } split //, $s;\n    return ($r, $r eq reverse $r);\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my %c = map {$_ => 1} split //, $c;\n    my $r = join '', grep {!$c{$_}} split\
    \ //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~\
    \ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}", "    my\
    \ $r = join '', reverse split //, $s;\n    my $p = $s eq $r;\n    $s =~ s/[$c]//g;\n\
    \    return ($s, $p);\n}", "    my $result = $s;\n    $result =~ s/[$c]//g;\n\
    \    my $is_palindrome = $result eq reverse $result;\n    return ($result, $is_palindrome);\n\
    }", "    my $s_new = $s;\n    for my $char (split //, $c) {\n        $s_new =~\
    \ s/$char//g;\n    }\n    my $s_new_reverse = reverse $s_new;\n    return ($s_new,\
    \ $s_new eq $s_new_reverse);\n}", "    my $s_copy = $s;\n    my $c_copy = $c;\n\
    \    my $result = '';\n    my $is_palindrome = 0;\n    my $s_length = length($s);\n\
    \    my $c_length = length($c);\n    my $i = 0;\n    my $j = 0;\n    my $k = 0;\n\
    \    my $l = 0;\n    my $m = 0;\n    my $n = 0;\n    my $o = 0;\n    my $p = 0;\n\
    \    my $q = 0;\n    my $r = 0;\n    my $s_index = 0;\n    my $c_index = 0;\n\
    \    my $s_char = '';\n    my $c_char = '';\n    my $s_char_code = 0;\n    my\
    \ $c_char_code = 0;\n    my $s_char_code_index = 0;\n    my $c_char_code_index\
    \ = 0;\n    my $s_char_code_index_copy = 0;\n    my $c_char_code_index_copy =\
    \ 0;\n    my $s_char_code_index_copy_copy = 0;\n    my $c_char_code_index_copy_copy\
    \ = 0;\n    my $s_char_code_index_copy_copy_copy = 0;\n    my $c_char_code_index_copy_copy_copy\
    \ = 0;\n    my $s_char_code_index_copy_copy_copy_copy = 0;\n    my $c_char_code_index_copy_copy_copy_copy\
    \ = 0;\n    my $s_char_code_index_copy_copy_copy_copy_copy = 0;\n    my $c_char_code_index_copy_copy_copy_copy_copy\
    \ = 0;\n    my $s_char_code_index_copy_copy_copy_copy_copy_copy = 0;\n    my $c_char_code_index_copy_copy_copy_copy_copy_copy\
    \ = 0;\n    my $s_char_code_index_copy_copy_copy_copy_copy_", "    my %c = map\
    \ { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $result = $s;\n    for my $char\
    \ (split //, $c) {\n        $result =~ s/$char//g;\n    }\n    return ($result,\
    \ $result eq reverse $result);\n}", "    my $r = join '', grep { index($c, $_)\
    \ == -1 } split //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my %c =\
    \ map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //,\
    \ $s;\n    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $res = $s;\n    for my $char\
    \ (split //, $c) {\n        $res =~ s/$char//g;\n    }\n    return ($res, $res\
    \ eq reverse $res);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r\
    \ = join '', grep { !$c{$_} } split //, $s;\n    return ($r, $r eq reverse $r);\n\
    }", "    my %hash = map { $_ => 1 } split //, $c;\n    my $result = join '', grep\
    \ { !$hash{$_} } split //, $s;\n    return ($result, $result eq reverse $result);\n\
    }", "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return\
    \ ($t, $t eq $r);\n}", "    my $result = '';\n    my $is_palindrome = 1;\n   \
    \ my %c_hash = map { $_ => 1 } split //, $c;\n    for my $char (split //, $s)\
    \ {\n        if (!$c_hash{$char}) {\n            $result .= $char;\n        }\n\
    \    }\n    my $reverse_result = reverse $result;\n    if ($result ne $reverse_result)\
    \ {\n        $is_palindrome = 0;\n    }\n    return ($result, $is_palindrome);\n\
    }", "    my $r = reverse $s;\n    my %c = map {$_ => 1} split //, $c;\n    my\
    \ @s = split //, $s;\n    my @r = split //, $r;\n    my @res;\n    for my $i (0..$#s)\
    \ {\n        if (!$c{$s[$i]}) {\n            push @res, $s[$i];\n        }\n \
    \       if (!$c{$r[$i]}) {\n            push @res, $r[$i];\n        }\n    }\n\
    \    my $res = join '', @res;\n    return ($res, $res eq reverse $res);\n}", " \
    \   my $res = $s;\n    $res =~ s/[$c]//g;\n    return ($res, $res eq reverse $res);\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n  \
    \  return ($r, $p);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r\
    \ = join '', grep { not $c{$_} } split //, $s;\n    return ($r, $r eq reverse\
    \ $r);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep\
    \ { !$c{$_} } split //, $s;\n    $r = reverse $r;\n    return ($r, $r eq $s);\n\
    }", "    my $r = '';\n    my %c = map { $_ => 1 } split //, $c;\n    for my $i\
    \ (0 .. length($s) - 1) {\n        my $ch = substr($s, $i, 1);\n        $r .=\
    \ $ch unless $c{$ch};\n    }\n    return ($r, $r eq reverse $r);\n}", "    my\
    \ $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "  \
    \  my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
    \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my @s = split\
    \ //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1 } @c;\n    my\
    \ @r;\n    for my $i (@s) {\n        push @r, $i unless $c{$i};\n    }\n    my\
    \ $r = join '', @r;\n    return ($r, $r eq reverse $r);\n}", "    $s =~ s/[$c]//g;\n\
    \    my $r = reverse $s;\n    return ($s, $s eq $r);\n}", "    my $r = reverse\
    \ $s;\n    my $p = $s eq $r;\n    $s =~ s/[$c]//g;\n    return ($s, $p);\n}",
  "    my $r = reverse $s;\n    my $t = join '', grep { index($c, $_) == -1 } split\
    \ //, $s;\n    return ($t, $t eq $r);\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 1;\n    my %c_hash = map { $_ => 1 } split //, $c;\n    for my $char (split\
    \ //, $s) {\n        if (!exists $c_hash{$char}) {\n            $result .= $char;\n\
    \        }\n    }\n    my $result_reverse = reverse $result;\n    if ($result\
    \ ne $result_reverse) {\n        $is_palindrome = 0;\n    }\n    return ($result,\
    \ $is_palindrome);\n}", "    my $res = $s;\n    for my $char (split //, $c) {\n\
    \        $res =~ s/$char//g;\n    }\n    return ($res, $res eq reverse $res);\n\
    }", "    my $result = '';\n    my %c = map { $_ => 1 } split //, $c;\n    for\
    \ my $char (split //, $s) {\n        $result .= $char unless $c{$char};\n    }\n\
    \    return ($result, $result eq reverse $result);\n}", "    my %c = map { $_\
    \ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n\
    \    my $p = $r eq reverse $r;\n    return ($r, $p);\n}", "    my $r = join '',\
    \ grep { index($c, $_) == -1 } split //, $s;\n    return ($r, $r eq reverse $r);\n\
    }", "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
    \ } split //, $s;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}", " \
    \   my %c = map { $_ => 1 } split //, $c;\n    my $s1 = join '', grep { !$c{$_}\
    \ } split //, $s;\n    my $s2 = join '', reverse split //, $s1;\n    return ($s1,\
    \ $s1 eq $s2);\n}", "    my $s_copy = $s;\n    my $c_copy = $c;\n    my $s_length\
    \ = length($s);\n    my $c_length = length($c);\n    my $s_index = 0;\n    my\
    \ $c_index = 0;\n    my $s_char = \"\";\n    my $c_char = \"\";\n    my $s_char_index\
    \ = 0;\n    my $c_char_index = 0;\n    my $s_char_index_copy = 0;\n    my $c_char_index_copy\
    \ = 0;\n    my $s_char_index_copy_2 = 0;\n    my $c_char_index_copy_2 = 0;\n \
    \   my $s_char_index_copy_3 = 0;\n    my $c_char_index_copy_3 = 0;\n    my $s_char_index_copy_4\
    \ = 0;\n    my $c_char_index_copy_4 = 0;\n    my $s_char_index_copy_5 = 0;\n \
    \   my $c_char_index_copy_5 = 0;\n    my $s_char_index_copy_6 = 0;\n    my $c_char_index_copy_6\
    \ = 0;\n    my $s_char_index_copy_7 = 0;\n    my $c_char_index_copy_7 = 0;\n \
    \   my $s_char_index_copy_8 = 0;\n    my $c_char_index_copy_8 = 0;\n    my $s_char_index_copy_9\
    \ = 0;\n    my $c_char_index_copy_9 = 0;\n    my $s_char_index_copy_10 = 0;\n\
    \    my $c_char_index_copy_10 = 0;\n    my $s_char_index_copy_11 = 0;\n    my\
    \ $c_char_index_copy_11 = 0;\n    my $s_char_index_copy_12 = 0;\n    my $c_char_index_copy_12\
    \ = 0;\n    my $s_char_index_copy_13 = 0;\n    my $c_", "    my %c = map { $_\
    \ => 1 } split '', $c;\n    my $r = join '', grep { not $c{$_} } split '', $s;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = reverse $s;\n    my $t =\
    \ $s;\n    $t =~ s/[$c]//g;\n    return ($t, $t eq $r);\n}", "    my $r = reverse\
    \ $s;\n    my $t = join '', sort split //, $c;\n    my $p = join '', sort split\
    \ //, $s;\n    my $q = join '', sort split //, $r;\n    my $u = join '', sort\
    \ split //, $c;\n    my $v = join '', sort split //, $r;\n    my $w = join '',\
    \ sort split //, $c;\n    my $x = join '', sort split //, $s;\n    my $y = join\
    \ '', sort split //, $r;\n    my $z = join '', sort split //, $c;\n    my $a =\
    \ join '', sort split //, $s;\n    my $b = join '', sort split //, $r;\n    my\
    \ $d = join '', sort split //, $c;\n    my $e = join '', sort split //, $s;\n\
    \    my $f = join '', sort split //, $r;\n    my $g = join '', sort split //,\
    \ $c;\n    my $h = join '', sort split //, $s;\n    my $i = join '', sort split\
    \ //, $r;\n    my $j = join '', sort split //, $c;\n    my $k = join '', sort\
    \ split //, $s;\n    my $l = join '', sort split //, $r;\n    my $m = join '',\
    \ sort split //, $c;\n    my $n = join '', sort split //, $s;\n    my $o = join\
    \ '', sort split //, $r;\n    my $p = join '', sort split //, $c;\n    my $q =\
    \ join '', sort split //, $s;\n    my $r = join '', sort split //, $r;\n    my\
    \ $t = join '', sort split //, $c;\n    my $u = join '', sort split //, $s;\n\
    \    my $v = join '', sort split //, $r;\n    my $w = join '', sort split //,\
    \ $c;\n    my $x = join '', sort split //, $s;\n    my $y =", "    my @s = split\
    \ //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1 } @c;\n    my\
    \ @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless $c{$s[$i]};\n\
    \    }\n    my $r = join '', @r;\n    my $p = $r eq reverse $r;\n    return ($r,\
    \ $p);\n}", "    my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash\
    \ = map { $_ => 1 } split //, $c;\n    for my $char (split //, $s) {\n       \
    \ if (!$c_hash{$char}) {\n            $result .= $char;\n        }\n    }\n  \
    \  my $result_reverse = reverse $result;\n    if ($result ne $result_reverse)\
    \ {\n        $is_palindrome = 0;\n    }\n    return ($result, $is_palindrome);\n\
    }", "    my $r = join '', reverse split //, $s;\n    my $t = join '', grep { index($c,\
    \ $_) < 0 } split //, $s;\n    return ($t, $t eq $r);\n}", "    my $r = join '',\
    \ grep { index($c, $_) == -1 } split //, $s;\n    return ($r, $r eq reverse $r);\n\
    }", "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
    \ } split //, $s;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}", " \
    \   my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ =>\
    \ 1 } @c;\n    my @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless\
    \ $c{$s[$i]};\n    }\n    my $r = join '', @r;\n    my $p = $r eq reverse $r;\n\
    \    return ($r, $p);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return\
    \ ($r, $r eq reverse $r);\n}", "    my $r = reverse $s;\n    my $p = $s eq $r;\n\
    \    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t, $p);\n}", "    my %c =\
    \ map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //,\
    \ $s;\n    return ($r, $r eq reverse $r);\n}", "    my $r = reverse $s;\n    my\
    \ $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t, $t eq $r);\n}", "    my $r =\
    \ reverse $s;\n    my %c = map {$_ => 1} split //, $c;\n    my $i = 0;\n    my\
    \ $j = 0;\n    while ($i < length $s and $j < length $r) {\n        if ($c{substr\
    \ $s, $i, 1}) {\n            $i++;\n        } elsif ($c{substr $r, $j, 1}) {\n\
    \            $j++;\n        } else {\n            if (substr($s, $i, 1) ne substr($r,\
    \ $j, 1)) {\n                return (substr($s, $i + 1, length $s - $i - $j -\
    \ 1), 0);\n            }\n            $i++;\n            $j++;\n        }\n  \
    \  }\n    return (substr($s, $i, length $s - $i - $j), 1);\n}", "    my $r = $s;\n\
    \    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}",
  "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1\
    \ } @c;\n    my $i = 0;\n    my $j = $#s;\n    while ($i < $j) {\n        if ($c{$s[$i]})\
    \ {\n            $i++;\n        } elsif ($c{$s[$j]}) {\n            $j--;\n  \
    \      } else {\n            ($s[$i], $s[$j]) = ($s[$j], $s[$i]);\n          \
    \  $i++;\n            $j--;\n        }\n    }\n    my $result = join '', @s[$i\
    \ .. $j];\n    return ($result, $result eq reverse $result);\n}", "    my $r =\
    \ $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "    my $new_s\
    \ = $s;\n    for my $char (split //, $c) {\n        $new_s =~ s/$char//g;\n  \
    \  }\n    return ($new_s, $new_s eq reverse $new_s);\n}", "    my $r = $s;\n \
    \   $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}",
  "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r\
    \ = join '', grep { !$c{$_} } split //, $s;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $result = $s;\n    for my $char (split //, $c) {\n        $result\
    \ =~ s/$char//g;\n    }\n    return ($result, $result eq reverse $result);\n}",
  "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return ($r,\
    \ $r eq reverse $r);\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
