name: HumanEval_90_next_smallest
language: py
prompt: "from typing import List, Optional\n\ndef next_smallest(lst: List[int]) ->\
  \ Optional[int]:\n    \"\"\"\n    You are given a list of integers.\n    Write a\
  \ function next_smallest() that returns the 2nd smallest element of the list.\n\
  \    Return None if there is no such element.\n    >>> next_smallest([1, 2, 3, 4,\
  \ 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n\
  \    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert\
  \ candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert\
  \ candidate([1, 1]) == None\n    assert candidate([1, 1, 1, 1, 0]) == 1\n    assert\
  \ candidate([1, 1]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n\
  def test_check():\n    check(next_smallest)\n\ntest_check()\n"
completions: ["    if not lst:\n        return None\n    if len(lst) == 1:\n     \
    \   return None\n    return sorted(set(lst))[1]\n", "    pass\n", "    # Time\
    \ complexity: O(n)\n    # Space complexity: O(1)\n    if len(lst) < 2:\n     \
    \   return None\n    min1 = min(lst[0], lst[1])\n    min2 = max(lst[0], lst[1])\n\
    \    for i in range(2, len(lst)):\n        if lst[i] < min1:\n            min2\
    \ = min1\n            min1 = lst[i]\n        elif lst[i] < min2:\n           \
    \ min2 = lst[i]\n    return min2 if min1 != min2 else None\n", "    smallest,\
    \ second_smallest = None, None\n    for n in lst:\n        if smallest is None\
    \ or n < smallest:\n            second_smallest = smallest\n            smallest\
    \ = n\n        elif second_smallest is None or n < second_smallest:\n        \
    \    second_smallest = n\n    return second_smallest", "    if len(lst) < 2:\n\
    \        return None\n    smallest = lst[0]\n    second_smallest = float('inf')\n\
    \    for n in lst:\n        if n < smallest:\n            second_smallest = smallest\n\
    \            smallest = n\n        elif n < second_smallest and n != smallest:\n\
    \            second_smallest = n\n    if second_smallest == float('inf'):\n  \
    \      return None\n    return second_smallest\n", "    if len(lst) < 2:\n   \
    \     return None\n    smallest = min(lst)\n    lst.remove(smallest)\n    return\
    \ min(lst)\n", '    pass', "    if len(lst) < 2:\n        return None\n    _min\
    \ = min(lst)\n    while min(lst) == _min:\n        lst.remove(_min)\n    return\
    \ min(lst)\n", "    # list is empty\n    if len(lst) == 0:\n        return None\n\
    \    # find the first minimum\n    first_min = min(lst)\n    # remove that minimum\
    \ and find the next minimum\n    second_min = min([x for x in lst if x != first_min])\n\
    \    # return the second minimum if it exists, otherwise return None\n    return\
    \ second_min if second_min != first_min else None\n", "    if len(lst) <= 1:\n\
    \        return None\n    if len(lst) == 2:\n        return None if lst[0] ==\
    \ lst[1] else lst[1]\n    min_lst = min(lst)\n    while True:\n        i = lst.index(min_lst)\n\
    \        if i == len(lst) - 1:\n            return None\n        if lst[i + 1]\
    \ > min_lst:\n            return lst[i + 1]\n        else:\n            lst.pop(i)\n\
    \            min_lst = min(lst)\n", "    def swap(x, y):\n        tmp = lst[x]\n\
    \        lst[x] = lst[y]\n        lst[y] = tmp\n\n    # sort with bubble sort\n\
    \    if len(lst) <= 1:\n        return None\n    for i in range(len(lst)):\n \
    \       for j in range(len(lst) - 1):\n            if lst[j] > lst[j + 1]:\n \
    \               swap(j, j + 1)\n    print(lst)\n    if lst[0] == lst[1]:\n   \
    \     return None\n    return lst[1]\n\n\n", "    if len(lst) < 2:\n        return\
    \ None\n    elif len(lst) == 2:\n        if lst[0] != lst[1]:\n            return\
    \ lst[1]\n        else:\n            return None\n    else:\n        min_ = min(lst)\n\
    \        min_idx = lst.index(min_)\n        # remove min from list\n        lst.pop(min_idx)\n\
    \        return min(lst)\n        \n", "    if len(lst) < 2:\n        return None\n\
    \    smallest = min(lst)\n    second_smallest = None\n    for i in lst:\n    \
    \    if i > smallest:\n            if second_smallest == None or i < second_smallest:\n\
    \                second_smallest = i\n    return second_smallest\n", "    # Write\
    \ your code here.\n    n = len(lst)\n    if n < 2:\n        return None\n    if\
    \ n == 2:\n        if lst[0] != lst[1]:\n            return lst[1]\n        else:\n\
    \            return None\n    f = [lst[0]]\n    for i in range(1, n):\n      \
    \  if lst[i] > f[0]:\n            f = [lst[i]]\n        elif lst[i] < f[0]:\n\
    \            f = [lst[i], f[0]]\n    if len(f) == 1:\n        return None\n  \
    \  else:\n        return f[1]\n", "    # Your code here\n    if len(lst) < 2:\n\
    \        return None\n    if len(lst) == 2:\n        if lst[0] != lst[1]:\n  \
    \          return lst[1]\n        else:\n            return None\n    if lst[0]\
    \ > lst[1]:\n        min_num = lst[1]\n        min_num_index = 1\n    else:\n\
    \        min_num = lst[0]\n        min_num_index = 0\n    second_min_num = min_num\n\
    \    second_min_num_index = min_num_index\n    for i in range(2, len(lst)):\n\
    \        if lst[i] < min_num:\n            second_min_num = min_num\n        \
    \    second_min_num_index = min_num_index\n            min_num = lst[i]\n    \
    \        min_num_index = i\n        elif lst[i] < second_min_num:\n          \
    \  second_min_num = lst[i]\n            second_min_num_index = i\n    if second_min_num_index\
    \ != min_num_index:\n        return second_min_num\n    else:\n        return\
    \ None\n", "    len_lst = len(lst)\n    if len_lst <= 1:\n        return None\n\
    \    min1 = min(lst)\n    min2 = min(lst[lst.index(min1) + 1:])\n    if min1 ==\
    \ min2:\n        return None\n    return min2\n", "    if not lst:\n        return\
    \ None\n    else:\n        max_min_index = 0\n        index = 0\n        for x\
    \ in lst:\n            if x < lst[max_min_index]:\n                max_min_index\
    \ = index\n            index += 1\n        if max_min_index == 0:\n          \
    \  lst.pop(max_min_index)\n        else:\n            lst.pop(max_min_index)\n\
    \            lst.pop(0)\n        if not lst:\n            return None\n      \
    \  else:\n            return min(lst)\n\n", "    if len(lst) <= 1:\n        return\
    \ None\n    else:\n        min_ = min(lst)\n        lst = [item for item in lst\
    \ if item != min_]\n        if len(lst) > 0:\n            return min(lst)\n  \
    \      else:\n            return None\n", '    return None if len(lst) < 2 else
    sorted(lst)[1]', "    if not lst:\n        return None\n    min1 = min(lst)\n\
    \    if lst.count(min1) > 1:\n        return None\n    min2 = min(lst)\n    for\
    \ n in lst:\n        if n < min2 and n != min1:\n            min2 = n\n    return\
    \ min2\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
