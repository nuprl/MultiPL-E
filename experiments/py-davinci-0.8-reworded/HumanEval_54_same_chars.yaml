name: HumanEval_54_same_chars
language: py
prompt: "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words\
  \ have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n\
  \    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc',\
  \ 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>>\
  \ same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz',\
  \ 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc')\
  \ == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc',\
  \ 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert\
  \ candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc')\
  \ == False\n    assert candidate('aabb', 'aaccc') == False\n\ndef test_check():\n\
  \    check(same_chars)\n\ntest_check()\n"
completions: ["    chars_dict0 = {}\n    chars_dict1 = {}\n    for ch in s0:\n   \
    \     chars_dict0[ch] = chars_dict0.get(ch, 0) + 1\n    for ch in s1:\n      \
    \  chars_dict1[ch] = chars_dict1.get(ch, 0) + 1\n    return chars_dict0 == chars_dict1\n\
    \n", "    if len(s0) == len(s1):\n        return True if sorted(s0) == sorted(s1)\
    \ else False\n    else:\n        return False\n\n", "    if len(s0) != len(s1):\n\
    \        return False\n    for c in s0:\n        if c not in s1:\n           \
    \ return False\n    return True\n", "    return Counter(s0) == Counter(s1)\n\n",
  "    return sorted(s0) == sorted(s1)\n\n", "    return True\n\n", "    c0 = sorted(s0)\n\
    \    c1 = sorted(s1)\n    return c0 == c1\n\n", "    str0 = ''.join(sorted(s0))\n\
    \    str1 = ''.join(sorted(s1))\n    return str0 == str1\n\n", "    l0 = sorted(s0)\n\
    \    l1 = sorted(s1)\n    return l0 == l1\n\n", "    return Counter(s0) == Counter(s1)\n\
    \n", "    return sorted(s0) == sorted(s1)\n\n", "    return sorted(s0) == sorted(s1)\n\
    \n", "    if len(s0) != len(s1):\n        return False\n    d0 = Counter(s0)\n\
    \    d1 = Counter(s1)\n    for c in d0:\n        if d0[c] != d1[c]:\n        \
    \    return False\n    return True\n\n", "    return Counter(s0) == Counter(s1)\n\
    \n", "    return set(s0) == set(s1)\n\n", "    return sorted(s0) == sorted(s1)\n",
  "    words = list(map(str.lower, [s0, s1]))\n    if any([len(w) != len(set(w)) for\
    \ w in words]):\n        return False\n    return Counter(words[0]) == Counter(words[1])\n\
    \n", "    return sorted(s0) == sorted(s1)\n\n", "    alphabet = [0] * 26\n   \
    \ for c in s0:\n        alphabet[ord(c) - ord('a')] += 1\n    for c in s1:\n \
    \       alphabet[ord(c) - ord('a')] -= 1\n    return all(s == 0 for s in alphabet)\n\
    \n", "    return collections.Counter(s0) == collections.Counter(s1)\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
