name: HumanEval_83_starts_one_ends
language: py
prompt: "def starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer\
  \ n, return the count of the numbers of n-digit\n    positive integers that start\
  \ or end with 1.\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(2)\
  \ == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert\
  \ candidate(5) == 18000\n\ndef test_check():\n    check(starts_one_ends)\n\ntest_check()\n"
completions: ["    # TODO: Implement\n    raise NotImplementedError\n\n\n@catch_zero",
  "    assert n > 0\n\n    # This counts the number of integers having the same number\
    \ of digits and\n    # starting with 1.\n    #\n    # Instead of counting the\
    \ numbers and subtracting them, we can subtract the\n    # number of numbers not\
    \ starting with 1 from the total number of n-digit\n    # numbers.\n    #\n  \
    \  # The number of n-digit numbers not starting with 1 is the number of n-digit\n\
    \    # numbers where the first digit is in {2, 3, ..., 9}.\n    #\n    # Since\
    \ the first digit is in the range {1, 2, ..., 9}, we can compute the\n    # number\
    \ of n-digit numbers not starting with 1 as (9 ** (n - 1) - 1).\n    return 10\
    \ ** (n - 1) - (9 ** (n - 1) - 1)\n\n", "    count = 0\n    while n > 0:\n   \
    \     if n % 10 == 1:\n            count += 1\n        n //= 10\n    return count\n\
    \n", "    if n == 1:\n        return 1\n    return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2)\n\n", "    return 1 + count_length(n - 1)\n\n", "    ...\n\n@dataclass",
  "    if n < 1:\n        return 0\n    elif n == 1:\n        return 1\n    elif n\
    \ > 1:\n        return 10 ** (n - 1) + 9 * (n - 1) * 10 ** (n - 2)\n\n", "   \
    \ count = 0\n    if n == 1:\n        return 1\n    for num in range(1, 10):\n\
    \        for d in range(1, n):\n            count += pow(9, d)\n        count\
    \ += 1\n    return count\n\n", "    return n*9*10**(n-1)\n\n", "    return int(str(1)\
    \ + str(0) * (n - 1)) + int(str(0) * (n - 1) + str(1))\n\n", "    counts = []\n\
    \    while n > 0:\n        counts.append(1 * 10 ** (n - 1))\n        n -= 1\n\
    \    return sum(counts)\n\n", "    return g(n, 1)\n\n", "    if n == 1:\n    \
    \    return 2\n    else:\n        return 2 * starts_one_ends(n - 1) - 9 + 10 **\
    \ (n - 1)\n\n", "    if n <= 0:\n        return 0\n    if n == 1:\n        return\
    \ 1\n    if n == 2:\n        return 2\n    a, b = 1, 2\n    for i in range(n -\
    \ 2):\n        a, b = b, a + b\n    return a + b\n", "    return (n - 1) * 10\
    \ ** (n - 2)\n\n", "    return 10 ** (n - 1) + 9 * (n - 1) * 10 ** (n - 2)\n\n",
  "    # From the first digit, there are 9 ways to decide it (1 to 9).\n    # From\
    \ the second digit, there are 9 ways to decide it (0 to 9).\n    # ...\n    #\
    \ From the second last digit, there are 9 ways to decide it (0 to 9).\n    # From\
    \ the last digit, there are 2 ways to decide it (0 or 1).\n    return 9 * (10\
    \ ** (n - 1)) + 2\n\n", "    count = 0\n    for i in range(1, n + 1):\n      \
    \  count += 9 * 10 ** (i - 1)\n    return count\n\n", "    count = 0\n    for\
    \ i in range(1, n + 1):\n        count += 10 ** (i - 1)\n    return count\n\n",
  "    if n == 1:\n        return 1\n    return (n - 1) * 9 + starts_one_ends(n -\
    \ 1)\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
