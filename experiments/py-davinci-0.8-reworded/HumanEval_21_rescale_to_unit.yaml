name: HumanEval_21_rescale_to_unit
language: py
prompt: "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n\
  \    \"\"\" Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n    such that the smallest number will become 0 and the largest\
  \ will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25,\
  \ 0.5, 0.75, 1.0]\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n \
  \   assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0,\
  \ 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0,\
  \ 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0,\
  \ 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n\ndef test_check():\n    check(rescale_to_unit)\n\
  \ntest_check()\n"
completions: ["    _min, _max = min(numbers), max(numbers)\n    if _min == _max:\n\
    \        return [0.5] * len(numbers)\n    return [(val - _min) / (_max - _min)\
    \ for val in numbers]\n", "    largest = max(numbers)\n    smallest = min(numbers)\n\
    \    factor = 1 / (largest - smallest)\n    return [(x - smallest) * factor for\
    \ x in numbers]\n\n", "    smallest = min(numbers)\n    largest = max(numbers)\n\
    \    range_of_values = largest - smallest\n    numbers_minus_smallest = [number\
    \ - smallest for number in numbers]\n    return [number / range_of_values for\
    \ number in numbers_minus_smallest]\n", "    min_value = min(numbers)\n    max_value\
    \ = max(numbers)\n    return [ (n - min_value) / (max_value - min_value) for n\
    \ in numbers ]\n", "    if (len(numbers) <= 1):\n        raise ValueError('At\
    \ least two elements required')\n    max_num = max(numbers)\n    min_num = min(numbers)\n\
    \    range_num = max_num - min_num\n    return [ (num - min_num) / range_num for\
    \ num in numbers ]\n", "    maximum = max(numbers)\n    minimum = min(numbers)\n\
    \    f = lambda n: (n - minimum) / (maximum - minimum)\n    return list(map(f,\
    \ numbers))\n", "    min_number = min(numbers)\n    max_number = max(numbers)\n\
    \    return [(number - min_number) / (max_number - min_number) for number in numbers]\n",
  "    # find the min and max numbers in the list\n    # apply a linear transformation\n\
    \    # return the resulting list\n    numbers = [float(n) for n in numbers]\n\
    \    minimum = min(numbers)\n    maximum = max(numbers)\n    new_numbers = []\n\
    \    for number in numbers:\n        new_numbers.append((number - minimum) / (maximum\
    \ - minimum))\n    return new_numbers\n", "    return [(n - min(numbers)) / (max(numbers)\
    \ - min(numbers)) for n in numbers]\n", "    smallest = min(numbers)\n    largest\
    \ = max(numbers)\n    new_numbers = []\n    for number in numbers:\n        new_numbers.append((number\
    \ - smallest) / (largest - smallest))\n    return new_numbers\n", "    min_num\
    \ = min(numbers)\n    max_num = max(numbers)\n    rescaled = []\n    for number\
    \ in numbers:\n        rescaled.append((number - min_num) / (max_num - min_num))\n\
    \    return rescaled", "    min = min(numbers)\n    max = max(numbers)\n    if\
    \ min == max:\n        return [0.5] * len(numbers)\n    else:\n        return\
    \ [(x - min) / (max - min) for x in numbers]\n", "    min_num = min(numbers)\n\
    \    max_num = max(numbers)\n    if min_num == max_num:\n        return [1] *\
    \ len(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n",
  "    assert numbers and len(numbers) > 1\n\n    # compute the bounds of the input\
    \ and the scaling factor\n    min_n = min(numbers)\n    max_n = max(numbers)\n\
    \    factor = 1 / (max_n - min_n)\n\n    # apply the transformation\n    return\
    \ [(n - min_n) * factor for n in numbers]\n", "    largest = max(numbers)\n  \
    \  smallest = min(numbers)\n    if largest == smallest:\n        raise ValueError('largest\
    \ and smallest must be different')\n    return [(x - smallest) / (largest - smallest)\
    \ for x in numbers]\n", "    minimum = min(numbers)\n    maximum = max(numbers)\n\
    \    min_max_diff = maximum - minimum\n    if min_max_diff == 0:\n        return\
    \ [0] * len(numbers)\n\n    return [\n        (n - minimum) / min_max_diff\n \
    \       for n in numbers\n    ]\n", "    largest = max(numbers)\n    smallest\
    \ = min(numbers)\n    return [ (x - smallest) / (largest - smallest) for x in\
    \ numbers ]\n\nimport math", "    smallest = min(numbers)\n    largest = max(numbers)\n\
    \    if smallest == largest:\n        return [1.0 / len(numbers) for _ in numbers]\n\
    \    else:\n        return [(n - smallest) / (largest - smallest) for n in numbers]\n",
  "    minimum = min(numbers)\n    maximum = max(numbers)\n    mean = sum(numbers)\
    \ / len(numbers)\n    return [(number - minimum) / (maximum - minimum) for number\
    \ in numbers]\n\n", "    assert len(numbers) >= 2\n    min_val = min(numbers)\n\
    \    max_val = max(numbers)\n    rescaled = []\n    for number in numbers:\n \
    \       rescaled.append((number - min_val) / (max_val - min_val))\n    return\
    \ rescaled\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
