name: HumanEval_153_Strongest_Extension
language: py
prompt: "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions:\
  \ List[str]) -> str:\n    \"\"\"You will be given the name of a class (a string)\
  \ and a list of extensions.\n    The extensions are to be used to load additional\
  \ classes to the class. The\n    strength of the extension is as follows: Let CAP\
  \ be the number of the uppercase\n    letters in the extension's name, and let SM\
  \ be the number of lowercase letters \n    in the extension's name, the strength\
  \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
  \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
  \    If there are two or more extensions with the same strength, you should\n  \
  \  choose the one that comes first in the list.\n    For example, if you are given\
  \ \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese',\
  \ 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes'\
  \ is the strongest extension \n    (its strength is -1).\n    Example:\n    >>>\
  \ Strongest_Extension('my_class', ['AA', 'Be', 'CC'])\n    'my_class.AA'\n    \"\
  \"\"\n"
tests: "def check(candidate):\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe'])\
  \ == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe',\
  \ '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t',\
  \ 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n\
  \    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert\
  \ candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert\
  \ candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n\
  \    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\
  \    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp',\
  \ ['671235', 'Bb']) == 'Sp.671235'\n\ndef test_check():\n    check(Strongest_Extension)\n\
  \ntest_check()\n"
completions: ["    strengths = {ext: len(ext) - sum(ord(c) > 90 for c in ext) for\
    \ ext in extensions}\n    return f'{class_name}.{max(strengths, key=strengths.get)}'\n",
  "    my_dict = {}\n    for i in extensions:\n        i_upper = 0\n        i_lower\
    \ = 0\n        for j in i:\n            if j.isupper():\n                i_upper\
    \ += 1\n            else:\n                i_lower += 1\n        if (i_upper -\
    \ i_lower) not in my_dict:\n            my_dict[i_upper - i_lower] = i\n     \
    \   else:\n            my_dict[i_upper - i_lower] = min(my_dict[i_upper - i_lower],\
    \ i)\n    return f'{class_name}.{my_dict[max(my_dict)]}'\n\n", "    # Possible\
    \ extensions are the value of each element in the list.\n    possible_extensions\
    \ = []\n    # Strength of each possible extension is the difference between the\
    \ number of\n    # upper case letters and the number of lower case letters.\n\
    \    strength_of_extensions = []\n    for extension in extensions:\n        #\
    \ Append the possible extension\n        possible_extensions.append(extension)\n\
    \        # Iterate through each character in each of the extension.\n        for\
    \ character in extension:\n            # If the character is uppercase then increment\
    \ the counter for uppercase letters.\n            if character.isupper():\n  \
    \              upper_case_letters = extension.count(character)\n            #\
    \ If the character is lowercase then increment the counter for lowercase letters.\n\
    \            elif character.islower():\n                lower_case_letters = extension.count(character)\n\
    \        # Append the strength of the extension to the list.\n        strength_of_extensions.append(upper_case_letters\
    \ - lower_case_letters)\n    # Max strength of the possible extensions.\n    max_strength\
    \ = max(strength_of_extensions)\n    # Index of the max strength of the possible\
    \ extensions.\n    max_strength_index = strength_of_extensions.index(max_strength)\n\
    \    # Strongest extension is the max strength index from the possible extensions.\n\
    \    strongest_extension = possible_extensions[max_strength_index]\n    # Return\
    \ the concatenation of the class name and the strongest extension.\n    return\
    \ class_name + '.' + strongest_extension\n", "    strength = []\n    for extension\
    \ in extensions:\n        CAP = 0\n        SM = 0\n        for letter in extension:\n\
    \            if letter.isupper():\n                CAP += 1\n            else:\n\
    \                SM += 1\n        strength.append(CAP - SM)\n    return class_name\
    \ + '.' + extensions[strength.index(max(strength))]\n", "    best_strength, best_extension\
    \ = -1, ''\n    for extension in extensions:\n        n_uppercase = sum(1 for\
    \ c in extension if c.isupper())\n        n_lowercase = sum(1 for c in extension\
    \ if c.islower())\n        if n_uppercase - n_lowercase > best_strength:\n   \
    \         best_strength = n_uppercase - n_lowercase\n            best_extension\
    \ = extension\n    return class_name + '.' + best_extension", "    strongest_extension\
    \ = None\n    strongest_strength = -100\n    for extension in extensions:\n  \
    \      CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1\
    \ for char in extension if char.islower())\n        strength = CAP - SM\n    \
    \    if strength > strongest_strength:\n            strongest_strength = strength\n\
    \            strongest_extension = extension\n    return class_name + '.' + strongest_extension\n",
  "    strong_ext = extensions[0]\n    strong_score = 0\n\n    for ext in extensions:\n\
    \        score = 0\n        for letter in ext:\n            if letter.isupper():\n\
    \                score += 1\n            else:\n                score -= 1\n \
    \       if abs(score) > abs(strong_score):\n            strong_score = score\n\
    \            strong_ext = ext\n    return f'{class_name}.{strong_ext}'\n\n", " \
    \   strengths = []\n    for extension in extensions:\n        strengths.append((extension,\
    \ extension.count(string.ascii_uppercase) - extension.count(string.ascii_lowercase)))\n\
    \    strongest = max(strengths, key=lambda x: x[1])\n    return class_name + '.'\
    \ + strongest[0]\n", "    if len(extensions) == 0:\n        return class_name\n\
    \n    # Build a list of tuples, each tuple containing the strength\n    # of the\
    \ respective extension, and the extension's name.\n    all_extensions = []\n \
    \   for extension in extensions:\n        all_extensions.append((extension.count(string.ascii_uppercase)\
    \ -\n                               extension.count(string.ascii_lowercase), extension))\n\
    \n    # Get the extension with the highest strength.\n    strongest_extension\
    \ = sorted(all_extensions, key=lambda x:x[0], reverse=True)[0][1]\n\n    return\
    \ class_name + '.' + strongest_extension", "    fractions = []\n    for extension\
    \ in extensions:\n        fractions.append(Fraction(extension.count(string.ascii_uppercase),\
    \ extension.count(string.ascii_lowercase)))\n    return class_name + '.' + extensions[fractions.index(max(fractions))]\n",
  "    ratio_list = []\n    for name in extensions:\n        ratio_list.append((sum(1\
    \ for char in name if char.isupper()), sum(1 for char in name if char.islower())))\n\
    \    max_ratio = -float('inf')\n    for name in extensions:\n        i = extensions.index(name)\n\
    \        if ratio_list[i][0] - ratio_list[i][1] > max_ratio:\n            max_ratio\
    \ = ratio_list[i][0] - ratio_list[i][1]\n            strongest_extension = name\n\
    \    return class_name + '.' + strongest_extension\n", "    strength = 0\n   \
    \ strong_name = ''\n    for ext in extensions:\n        cap_num = 0\n        sm_num\
    \ = 0\n        for char in ext:\n            if char.isupper():\n            \
    \    cap_num += 1\n            else:\n                sm_num += 1\n        if\
    \ cap_num - sm_num > strength:\n            strength = cap_num - sm_num\n    \
    \        strong_name = ext\n        elif cap_num - sm_num == strength:\n     \
    \       if ext < strong_name:\n                strong_name = ext\n    return f'{class_name}.{strong_name}'\n",
  "    strongest_extension = 0\n    index = -1\n    for i in range(len(extensions)):\n\
    \        count_lower = 0\n        count_upper = 0\n        for ch in extensions[i]:\n\
    \            if ch.islower():\n                count_lower += 1\n            else:\n\
    \                count_upper += 1\n        if count_upper - count_lower > strongest_extension:\n\
    \            strongest_extension = count_upper - count_lower\n            index\
    \ = i\n    if index == -1:\n        return class_name\n    return class_name +\
    \ '.' + extensions[index]\n", "    best_strength = 0\n    strongest_extension\
    \ = ''\n    for extension in extensions:\n        CAP = sum(letter.isupper() for\
    \ letter in extension)\n        SM = sum(letter.islower() for letter in extension)\n\
    \        strength = CAP - SM\n        if strength > best_strength:\n         \
    \   best_strength = strength\n            strongest_extension = extension\n  \
    \  return '{}.{}'.format(class_name, strongest_extension)\n", "    return '.'.join([class_name,\
    \ sorted(extensions, key=lambda x: (x.upper().count('A-Z') - x.lower().count('a-z'),\
    \ x))[-1]])\n", "    lst = []\n    for i in extensions:\n        num = 0\n   \
    \     sm = 0\n        for j in i:\n            if j.isupper():\n             \
    \   num += 1\n            else:\n                sm += 1\n        lst.append(num\
    \ - sm)\n    my_dict = dict(zip(extensions, lst))\n    my_dict = sorted(my_dict.items(),\
    \ key=lambda x: (-x[1], x[0]))\n    if my_dict[0][1] == my_dict[1][1]:\n     \
    \   return f'{class_name}.{my_dict[0][0]}'\n    else:\n        return f'{class_name}.{my_dict[0][0]}'\n\
    \n", "    to_return = \"\"\n    strength = 0\n    for ext in extensions:\n   \
    \     cap = sum(1 for c in ext if c.isupper())\n        sm = sum(1 for c in ext\
    \ if c.islower())\n        if strength < cap - sm:\n            strength = cap\
    \ - sm\n            to_return = ext\n        elif strength == cap - sm:\n    \
    \        if ext < to_return:\n                to_return = ext\n    return f\"\
    {class_name}.{to_return}\"\n", "    max_strength = float('-inf')\n    max_strength_name\
    \ = ''\n    for name in extensions:\n        CAP = sum(1 for c in name if c.isupper())\n\
    \        SM = sum(1 for c in name if c.islower())\n        if max_strength < CAP\
    \ - SM:\n            max_strength = CAP - SM\n            max_strength_name =\
    \ name\n    return class_name + '.' + max_strength_name", "    strength = []\n\
    \    for i in extensions:\n        strength.append(sum(1 for x in i if x.isupper())\
    \ - sum(1 for x in i if x.islower()))\n    return f'{class_name}.{extensions[strength.index(max(strength))]}'\n",
  "    strong_extension = ''\n    best_strength = -inf\n    # finding the strongest\
    \ extension\n    for ext in extensions:\n        strength = sum(map(str.isupper,\
    \ ext)) - sum(map(str.islower, ext))\n        if strength > best_strength:\n \
    \           best_strength = strength\n            strong_extension = ext\n   \
    \ return class_name + '.' + strong_extension\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
