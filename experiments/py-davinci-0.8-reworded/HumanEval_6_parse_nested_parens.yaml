name: HumanEval_6_parse_nested_parens
language: py
prompt: "from typing import List\n\ndef parse_nested_parens(paren_string: str) ->\
  \ List[int]:\n    \"\"\" Input to this function is a string represented multiple\
  \ groups for nested parentheses separated by spaces.\n    For each of the group,\
  \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
  \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
  \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
  \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
  \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
  \ntest_check()\n"
completions: ["    result = []\n    for paren_group in paren_string.split(' '):\n\
    \        result.append(__find_deepest_nesting(paren_group))\n    return result\n",
  "    results = []\n    for parens in paren_string.split():\n        results.append(helper(parens))\n\
    \    return results\n", "    all_parens = paren_string.split()\n    # For each\
    \ paren, check if it is opened or closed.\n    # If it is opened, increment the\
    \ counter by 1.\n    # If it is closed, decrement the counter by 1.\n    # If\
    \ the decrement goes below zero, it means we have extra closed parens.\n    #\
    \ Return the highest value reached during the iteration.\n    paren_levels = [max(0,\
    \ sum(1 if ch == '(' else -1 for ch in paren)) for paren in all_parens]\n    return\
    \ paren_levels\n\n", "    result = []\n    for parens in paren_string.split('\
    \ '):\n        max_depth = 0\n        current_depth = 0\n        for paren in\
    \ parens:\n            if paren == '(':\n                current_depth += 1\n\
    \                max_depth = max(max_depth, current_depth)\n            elif paren\
    \ == ')':\n                current_depth -= 1\n        result.append(max_depth)\n\
    \    return result\n", "    ret = []\n    for group in paren_string.split():\n\
    \        counter = 0\n        depth = 0\n        for char in group:\n        \
    \    if char == '(':\n                counter += 1\n                depth = max(depth,\
    \ counter)\n            elif char == ')':\n                counter -= 1\n    \
    \    ret.append(depth)\n    return ret\n", "    output = []\n    for nested_parens\
    \ in paren_string.split(' '):\n        num_opened = 0\n        nested_depth =\
    \ 0\n        for char in nested_parens:\n            if char == '(':\n       \
    \         num_opened += 1\n                nested_depth = max(nested_depth, num_opened)\n\
    \            else:\n                num_opened -= 1\n        output.append(nested_depth)\n\
    \    return output", "    current_depth = 0\n    max_depth = 0\n    paren_depth\
    \ = []\n    for char in paren_string:\n        if char == '(':\n            current_depth\
    \ += 1\n            max_depth = max(max_depth, current_depth)\n        elif char\
    \ == ')':\n            paren_depth.append(max_depth)\n            max_depth =\
    \ 0\n            current_depth -= 1\n        elif char == ' ':\n            continue\n\
    \    return paren_depth\n\n", "    # TODO: implement this function\n    max_depth\
    \ = []\n    group = paren_string.split()\n    for g in group:\n        count =\
    \ 0\n        max_depth.append(0)\n        for i in g:\n            if i == '(':\n\
    \                count += 1\n                if count > max_depth[-1]:\n     \
    \               max_depth[-1] = count\n            if i == ')':\n            \
    \    count -= 1\n    return max_depth\n    pass\n", "    # Use this list to store\
    \ the result\n    result = []\n    # A helper function to count the maximum level\
    \ of nesting of parentheses\n    def max_level(p_string: str) -> int:\n      \
    \  # TODO: write your own function here\n        pass\n    # Parse the input string\
    \ and store the result\n    for p_string in paren_string.split():\n        result.append(max_level(p_string))\n\
    \    return result\n", "    result = []\n    for s in paren_string.split():\n\
    \        curr_max_depth = max_depth = depth = 0\n        for ch in s:\n      \
    \      if ch == '(':\n                depth += 1\n                curr_max_depth\
    \ = max(curr_max_depth, depth)\n            elif ch == ')':\n                depth\
    \ -= 1\n            else:\n                raise ValueError(\"Unknown character:\
    \ {}\".format(ch))\n        if depth != 0:\n            raise ValueError(\"Invalid\
    \ parenthesis string {}: {}\".format(s, depth))\n        result.append(curr_max_depth)\n\
    \    return result\n\n", "    max_level = 0\n    level = 0\n    max_levels = []\n\
    \    for char in paren_string:\n        if char == '(':\n            level +=\
    \ 1\n            max_level = max(max_level, level)\n        elif char == ')':\n\
    \            level -= 1\n        elif char == ' ':\n            max_levels.append(max_level)\n\
    \            max_level = 0\n            level = 0\n    max_levels.append(max_level)\n\
    \    return max_levels", "    res = []\n    for _str in paren_string.split(' '):\n\
    \        stack = []\n        max_len = 0\n        for c in _str:\n           \
    \ if c == '(':\n                stack.append(c)\n                max_len = max(max_len,\
    \ len(stack))\n            elif c == ')':\n                stack.pop()\n     \
    \   res.append(max_len)\n    return res\n\n", "    output = []\n    for paren_group\
    \ in paren_string.split():\n        max_level = 0\n        curr_level = 0\n  \
    \      for paren in paren_group:\n            if paren == '(':\n             \
    \   curr_level += 1\n                max_level = max(max_level, curr_level)\n\
    \            elif paren == ')':\n                curr_level -= 1\n           \
    \ else:\n                raise ValueError(f'Invalid paren in string: {paren}')\n\
    \        output.append(max_level)\n    return output\n", "    paren_groups = paren_string.split()\n\
    \    # print(paren_groups)\n    max_depth = []\n    for paren_group in paren_groups:\n\
    \        # print(paren_group)\n        current_depth = 0\n        for char in\
    \ paren_group:\n            if char == '(':\n                current_depth +=\
    \ 1\n            elif char == ')':\n                current_depth -= 1\n     \
    \       else:\n                raise ValueError('Improper input!')\n        max_depth.append(current_depth)\n\
    \    return max_depth\n\n", "    result = []\n    for s in paren_string.split():\n\
    \        start = 0\n        max_level = 0\n        level = 0\n        while start\
    \ < len(s):\n            if s[start] == '(':\n                level += 1\n   \
    \             max_level = max(max_level, level)\n            elif s[start] ==\
    \ ')':\n                level -= 1\n            start += 1\n        result.append(max_level)\n\
    \    return result\n\n", "    result = []\n    for group in paren_string.split('\
    \ '):\n        level = 0\n        max_level = 0\n        for c in group:\n   \
    \         if c == '(':\n                level += 1\n                max_level\
    \ = max(max_level, level)\n            else:\n                level -= 1\n   \
    \     result.append(max_level)\n    return result\n", "    paren_list = paren_string.split('\
    \ ')\n    return [max_nesting(substr) for substr in paren_list]\n", "    parsed_parens\
    \ = []\n    for paren_group in paren_string.split(' '):\n        # initialize\
    \ depth of each group to be 0\n        depth = 0\n        max_depth = 0\n    \
    \    for char in paren_group:\n            if char == '(':\n                depth\
    \ += 1\n                max_depth = max(max_depth, depth)\n            elif char\
    \ == ')':\n                depth -= 1\n            else:\n                raise\
    \ ValueError('Input string can only contain \"(\" or \")\"')\n        parsed_parens.append(max_depth)\n\
    \    return parsed_parens\n", "    pass\n\n", "    max_nesting = 0\n    current_nesting\
    \ = 0\n    max_nesting_list = []\n    for char in paren_string:\n        if char\
    \ == '(':\n            current_nesting += 1\n            max_nesting = max(max_nesting,\
    \ current_nesting)\n        elif char == ')':\n            current_nesting -=\
    \ 1\n        elif char == ' ':\n            max_nesting_list.append(max_nesting)\n\
    \            max_nesting = 0\n            current_nesting = 0\n    max_nesting_list.append(max_nesting)\n\
    \    return max_nesting_list\n", "    paren_groups = paren_string.split(' ')\n\
    \    return [nested_parens(group) for group in paren_groups]\n", "    bracket_stack\
    \ = []\n    bracket_pair = {'(': ')'}\n    max_level = 0\n    levels = []\n  \
    \  for idx, bracket in enumerate(paren_string):\n        if bracket == '(':\n\
    \            bracket_stack.append(bracket)\n            max_level += 1\n     \
    \   elif bracket == ')':\n            if bracket_stack[-1] == '(':\n         \
    \       bracket_stack.pop()\n                max_level -= 1\n            elif\
    \ bracket_stack[-1] == ' ':\n                bracket_stack.pop()\n           \
    \     levels.append(max_level)\n                max_level = 0\n        elif bracket\
    \ == ' ':\n            bracket_stack.append(bracket)\n    return levels\n\n",
  "    paren_groups = paren_string.split(' ')\n    depths = []\n    for paren_group\
    \ in paren_groups:\n        depths.append(calculate_depth(paren_group))\n    return\
    \ depths\n", "    paren_strings = paren_string.split()\n    paren_count = []\n\
    \    for paren_string in paren_strings:\n        paren_stack = []\n        max_nesting\
    \ = 0\n        for ch in paren_string:\n            if ch == '(':\n          \
    \      paren_stack.append(ch)\n                max_nesting = max(max_nesting,\
    \ len(paren_stack))\n            elif ch == ')':\n                paren_stack.pop()\n\
    \        paren_count.append(max_nesting)\n    return paren_count\n\n", "    result\
    \ = []\n    for group in paren_string.split(' '):\n        stack = []\n      \
    \  max_level = -1\n        for paren in group:\n            if paren == '(':\n\
    \                stack.append(paren)\n                max_level = max(max_level,\
    \ len(stack))\n            elif paren == ')':\n                stack.pop()\n \
    \       result.append(max_level)\n    return result\n\n", "    depth, max_depth\
    \ = 0, 0\n    result = []\n    for paren in paren_string:\n        if paren ==\
    \ '(':\n            depth += 1\n            max_depth = max(max_depth, depth)\n\
    \        elif paren == ')':\n            depth -= 1\n        elif paren == ' ':\n\
    \            result.append(max_depth)\n            max_depth = 0\n    result.append(max_depth)\n\
    \    return result\n", "    open_count = 0\n    max_count = 0\n    output = []\n\
    \    for char in paren_string:\n        if char == '(':\n            open_count\
    \ += 1\n            max_count = max(max_count, open_count)\n        elif char\
    \ == ')':\n            open_count -= 1\n        elif char == ' ':\n          \
    \  output.append(max_count)\n            max_count = 0\n            open_count\
    \ = 0\n    output.append(max_count)\n    return output", "    count_nested_parens\
    \ = []\n    for paren_group in paren_string.split():\n        stack = []\n   \
    \     max_nested_count = 0\n        for paren in paren_group:\n            if\
    \ paren == '(':\n                stack.append(paren)\n                max_nested_count\
    \ = max(max_nested_count, len(stack))\n            else:\n                stack.pop()\n\
    \        count_nested_parens.append(max_nested_count)\n    return count_nested_parens\n",
  "    # Each character in the string is { or } or a character other than { or }.\n\
    \    # It can be considered as a string of char[]\n    # initialize a stack to\
    \ store the counts of each level of nesting\n    max_level = 0\n    levels = [0]\n\
    \    for c in paren_string:\n        if c == '(':\n            levels.append(levels[-1]\
    \ + 1)\n            max_level = max(max_level, levels[-1])\n        elif c ==\
    \ ')':\n            levels.pop()\n        else:\n            levels[-1] = max_level\n\
    \    return levels\n", "    res = []\n    for group in paren_string.split(' '):\n\
    \        paren_stack = []\n        max_nesting = 0\n        for paren in group:\n\
    \            if paren == '(':\n                paren_stack.append(paren)\n   \
    \             max_nesting = max(max_nesting, len(paren_stack))\n            elif\
    \ paren == ')':\n                paren_stack.pop()\n        res.append(max_nesting)\n\
    \    return res\n\n", "    deepest_levels = []\n    for paren_group in paren_string.split():\n\
    \        max_level = 0\n        level = 0\n        for paren in paren_group:\n\
    \            if paren == '(':\n                level += 1\n                max_level\
    \ = max(max_level, level)\n            else:\n                level -= 1\n   \
    \     deepest_levels.append(max_level)\n    return deepest_levels\n\n", "    result\
    \ = []\n    for paren_group in paren_string.split():\n        max_depth = 0\n\
    \        depth = 0\n        for char in paren_group:\n            if char == '(':\n\
    \                depth += 1\n                max_depth = max(max_depth, depth)\n\
    \            elif char == ')':\n                depth -= 1\n        result.append(max_depth)\n\
    \    return result\n", "    max_depth = 0\n    current_depth = 0\n    output =\
    \ []\n    for paren in paren_string:\n        if paren == '(':\n            current_depth\
    \ += 1\n            max_depth = max(max_depth, current_depth)\n        elif paren\
    \ == ')':\n            current_depth -= 1\n        elif paren == ' ':\n      \
    \      output.append(max_depth)\n            max_depth = 0\n            current_depth\
    \ = 0\n    if current_depth == 0:\n        output.append(max_depth)\n    return\
    \ output\n", "    depth = 0\n    output = []\n    for i in paren_string:\n   \
    \     if i == '(':\n            depth += 1\n        elif i == ')':\n         \
    \   output.append(depth)\n            depth -= 1\n    return output\n\n", "  \
    \  paren_string = paren_string.strip()\n    paren_groups = paren_string.split('\
    \ ')\n    return [parse_nested_parens_group(group) for group in paren_groups]\n",
  "    splits = paren_string.split(' ')\n    outputs = []\n    for split in splits:\n\
    \        st = []\n        max_counter = 0\n        counter = 0\n        for char\
    \ in split:\n            if char == '(':\n                st.append(char)\n  \
    \              counter += 1\n                max_counter = max(max_counter, counter)\n\
    \            else:\n                st.pop()\n                counter -= 1\n \
    \       outputs.append(max_counter)\n    return outputs\n", "    paren_groups\
    \ = paren_string.split(' ')\n    return [max_nested_parens(paren_group) for paren_group\
    \ in paren_groups]\n", "    group_list = paren_string.split()\n    res = []\n\
    \    for group in group_list:\n        if not group:\n            res.append(0)\n\
    \            continue\n        depth = 0\n        max_depth = 0\n        for item\
    \ in group:\n            if item == '(':\n                depth += 1\n       \
    \         max_depth = max(max_depth, depth)\n            elif item == ')':\n \
    \               depth -= 1\n        res.append(max_depth)\n    return res\n\n",
  "    deepest_level = 0\n    result = []\n    for c in paren_string:\n        if\
    \ c == '(':\n            deepest_level += 1\n        elif c == ')':\n        \
    \    deepest_level -= 1\n        elif c == ' ':\n            result.append(deepest_level)\n\
    \            deepest_level = 0\n    return result\n", "    paren_groups = paren_string.split()\n\
    \    max_nested_levels = []\n    for group in paren_groups:\n        max_nested_levels.append(parse_single_paren_group(group))\n\
    \    return max_nested_levels\n", "    res = []\n    for g in paren_string.split():\n\
    \        depth = 0\n        max_depth = 0\n        for c in g:\n            if\
    \ c == '(':\n                depth += 1\n                max_depth = max(max_depth,\
    \ depth)\n            elif c == ')':\n                depth -= 1\n        res.append(max_depth)\n\
    \    return res", "    return [len(s) - len(s.replace('(', '')) for s in paren_string.split()]\n\
    \n", "    def max_nesting(paren_string: str) -> int:\n        \"\"\" Helper function\
    \ to calculate the deepest level of nesting of parentheses.\n        \"\"\"\n\
    \        max_nesting_level = 0\n        num_open_parens = 0\n        for c in\
    \ paren_string:\n            if c == '(':\n                num_open_parens +=\
    \ 1\n                max_nesting_level = max(max_nesting_level, num_open_parens)\n\
    \            elif c == ')':\n                num_open_parens -= 1\n        return\
    \ max_nesting_level\n\n    return [max_nesting(s) for s in paren_string.split()]\n",
  "    res = []\n    level = 0\n    max_level = 0\n    for i in paren_string:\n  \
    \      if i == '(':\n            level += 1\n            max_level = max(max_level,\
    \ level)\n        elif i == ')':\n            level -= 1\n        elif i == '\
    \ ':\n            res.append(max_level)\n            max_level = 0\n         \
    \   level = 0\n    res.append(max_level)\n    return res\n\n", "    ret = []\n\
    \    for parens in paren_string.split():\n        stack = []\n        max_nesting\
    \ = 0\n        for paren in parens:\n            if paren == '(':\n          \
    \      stack.append(paren)\n                max_nesting = max(max_nesting, len(stack))\n\
    \            elif paren == ')':\n                stack.pop()\n        ret.append(max_nesting)\n\
    \    return ret\n\n", "    groups = paren_string.split(' ')\n    return [len(group)\
    \ - group.count('(') for group in groups]\n\nprint(parse_nested_parens('(()())\
    \ ((())) () ((())()())'))", "    # Remove all the whitespaces\n    paren_string\
    \ = paren_string.replace(' ', '')\n    max_depth = 0\n    current_depth = 0\n\
    \    results = []\n    for char in paren_string:\n        if char == '(':\n  \
    \          current_depth += 1\n            max_depth = max(max_depth, current_depth)\n\
    \        elif char == ')':\n            results.append(max_depth)\n          \
    \  current_depth -= 1\n            max_depth = 0\n    return results\n", "   \
    \ res = []\n    for paren_group in paren_string.split(' '):\n        level = 0\n\
    \        max_level = 0\n        for paren in paren_group:\n            if paren\
    \ == '(':\n                level += 1\n                max_level = max(max_level,\
    \ level)\n            elif paren == ')':\n                level -= 1\n       \
    \ res.append(max_level)\n    return res\n", "    max_level = 0\n    levels = []\n\
    \    for c in paren_string:\n        if c == '(':\n            max_level += 1\n\
    \            levels.append(max_level)\n        if c == ')':\n            levels.append(max_level)\n\
    \            max_level -= 1\n    return levels\n", "    result = []\n    for parens\
    \ in paren_string.split(' '):\n        parens_level = 0\n        for paren in\
    \ parens:\n            if paren == '(':\n                parens_level += 1\n \
    \           else:\n                parens_level -= 1\n            result.append(parens_level)\n\
    \    return result\n\nprint(parse_nested_parens('(()()) ((())) () ((())()())'))",
  "    res = []\n    for paren in paren_string.split(' '):\n        if not paren:\n\
    \            res.append(0)\n            continue\n        stack = []\n       \
    \ max_depth = 0\n        for c in paren:\n            if c == '(':\n         \
    \       stack.append(c)\n                max_depth = max(max_depth, len(stack))\n\
    \            else:\n                stack.pop()\n        res.append(max_depth)\n\
    \    return res\n", "    max_nesting = []\n    for parens in paren_string.split('\
    \ '):\n        paren_stack = []\n        max_nesting_in_this_group = 0\n     \
    \   for paren in parens:\n            if paren == '(':\n                paren_stack.append(paren)\n\
    \                max_nesting_in_this_group = max(max_nesting_in_this_group, len(paren_stack))\n\
    \            elif paren == ')':\n                paren_stack.pop()\n        max_nesting.append(max_nesting_in_this_group)\n\
    \    return max_nesting\n", "    group_strings = paren_string.split()\n    return\
    \ [nest_level(gs) for gs in group_strings]\n", "    paren_list = paren_string.split('\
    \ ')\n    return [nested_paren_level(paren) for paren in paren_list]\n", "   \
    \ paren_indices = []\n\n    for parentheses in paren_string.split():\n       \
    \ max_nested_count = 0\n        current_count = 0\n        for paren in parentheses:\n\
    \            if paren == '(':\n                current_count += 1\n          \
    \      max_nested_count = max(max_nested_count, current_count)\n            elif\
    \ paren == ')':\n                current_count -= 1\n        paren_indices.append(max_nested_count)\n\
    \n    return paren_indices\n", "    result = []\n    for group in paren_string.split():\n\
    \        stack = []\n        max_nest = 0\n        for char in group:\n      \
    \      if char == '(':\n                stack.append(char)\n                max_nest\
    \ = max(max_nest, len(stack))\n            else:\n                stack.pop()\n\
    \        result.append(max_nest)\n    return result\n\n", "    parsed_string =\
    \ paren_string.split(' ')\n    max_depth = 0\n    curr_depth = 0\n    output =\
    \ []\n    for word in parsed_string:\n        for char in word:\n            if\
    \ char == '(':\n                curr_depth += 1\n                max_depth = max(max_depth,\
    \ curr_depth)\n            else:\n                curr_depth -= 1\n        output.append(max_depth)\n\
    \        max_depth = 0\n        curr_depth = 0\n    return output", "    levels\
    \ = []\n    level = 0\n    for c in paren_string:\n        if c == '(':\n    \
    \        level += 1\n        elif c == ')':\n            level -= 1\n        elif\
    \ c == ' ':\n            levels.append(level)\n            level = 0\n    return\
    \ levels\n\n", "    groups = paren_string.split()\n    max_depth = []\n    for\
    \ group in groups:\n        depth = 0\n        max_depth_curr = 0\n        for\
    \ paren in group:\n            if paren == '(':\n                depth += 1\n\
    \                max_depth_curr = max(max_depth_curr, depth)\n            elif\
    \ paren == ')':\n                depth -= 1\n        max_depth.append(max_depth_curr)\n\
    \    return max_depth\n\nprint(parse_nested_parens('(()()) ((())) () ((())()())'))",
  "    if not paren_string:\n        return []\n\n    def count_nested_parens(paren_group:\
    \ str) -> int:\n        paren_count = 0\n        deepest_nested_paren = 0\n  \
    \      for c in paren_group:\n            if c == '(':\n                paren_count\
    \ += 1\n                deepest_nested_paren = max(paren_count, deepest_nested_paren)\n\
    \            else:\n                paren_count -= 1\n        return deepest_nested_paren\n\
    \n    return [count_nested_parens(s) for s in paren_string.split()]\n\n", "  \
    \  groups = paren_string.split(' ')\n    ans = []\n    for group in groups:\n\
    \        ans.append(get_max_nesting(group))\n    return ans\n", "    pass\n\n",
  "    # Let's assume that the input is well formed - i.e. each parentheses is either\
    \ opening or closing but not both.\n    paren_stack = []\n    max_height = 0\n\
    \    result = []\n    for paren in paren_string:\n        if paren == '(':\n \
    \           paren_stack.append(paren)\n            max_height = max(max_height,\
    \ len(paren_stack))\n        elif paren == ')':\n            paren_stack.pop()\n\
    \        elif paren == ' ':\n            result.append(max_height)\n         \
    \   max_height = 0\n    result.append(max_height)\n\n    return result\n", " \
    \   res = []\n    for paren_group in paren_string.split(' '):\n        depth =\
    \ 0\n        max_depth = 0\n        for s in paren_group:\n            if s ==\
    \ '(':\n                depth += 1\n                max_depth = max(max_depth,\
    \ depth)\n            elif s == ')':\n                depth -= 1\n        res.append(max_depth)\n\
    \    return res\n", "    depth_list = []\n\n    for nested_parens in paren_string.split():\n\
    \        assert nested_parens[0] == '(' and nested_parens[-1] == ')'\n       \
    \ depth = 0\n        max_depth = 0\n        for paren in nested_parens:\n    \
    \        if paren == '(':\n                depth += 1\n                max_depth\
    \ = max(max_depth, depth)\n            elif paren == ')':\n                depth\
    \ -= 1\n            else:\n                raise ValueError\n        depth_list.append(max_depth)\n\
    \n    return depth_list\n", "    max_depth = 0\n    current_depth = 0\n    depths\
    \ = []\n    for paren in paren_string:\n        if paren == '(':\n           \
    \ current_depth += 1\n            max_depth = max(max_depth, current_depth)\n\
    \        elif paren == ')':\n            current_depth -= 1\n        elif paren\
    \ == ' ':\n            depths.append(max_depth)\n            max_depth = 0\n \
    \           current_depth = 0\n    depths.append(max_depth)\n    return depths",
  "    groups = paren_string.split(' ')\n    levels = []\n    for group in groups:\n\
    \        current_level = 0\n        max_level = 0\n        for paren in group:\n\
    \            if paren == '(':\n                current_level += 1\n          \
    \      max_level = max(max_level, current_level)\n            else:\n        \
    \        current_level -= 1\n        levels.append(max_level)\n    return levels\n",
  "    ans = []\n    for s in paren_string.split():\n        # assume input string\
    \ is valid\n        stack = []\n        max_nesting = 0\n        for c in s:\n\
    \            if c == '(':\n                stack.append(c)\n                max_nesting\
    \ = max(max_nesting, len(stack))\n            else:\n                stack.pop()\n\
    \        ans.append(max_nesting)\n    return ans\n", "    # TODO: complete this\
    \ function\n    raise NotImplementedError", "    # TODO write your code here\n\
    \    return []\n", "    def get_max_nesting(paren_string: str) -> int:\n     \
    \   max_nesting = 0\n        current_nesting = 0\n        for paren in paren_string:\n\
    \            if paren == '(':\n                current_nesting += 1\n        \
    \        max_nesting = max(max_nesting, current_nesting)\n            elif paren\
    \ == ')':\n                current_nesting -= 1\n        return max_nesting\n\n\
    \    return [get_max_nesting(paren_string) for paren_string in paren_string.split()]\n\
    \n", "    rv = []\n    for paren_group in paren_string.split():\n        rv.append(max_nesting(paren_group))\n\
    \    return rv\n", "    paren_list = paren_string.split(' ')\n    depth_list =\
    \ [0] * len(paren_list)\n    for idx, paren in enumerate(paren_list):\n      \
    \  depth = 0\n        for p in paren:\n            if p == '(':\n            \
    \    depth += 1\n            else:\n                depth -= 1\n            depth_list[idx]\
    \ = max(depth, depth_list[idx])\n    return depth_list\n", "    group_parens =\
    \ paren_string.split(' ')\n    return [len(re.findall(r'\\(\\(', group)) for group\
    \ in group_parens]\n", "    # O(n) time and O(1) space\n    # Base case: either\
    \ empty string or '('\n    # If string starts with ')', return 0\n    # If there\
    \ is no parenthesis then just return 0\n    if not paren_string:\n        return\
    \ 0\n    open_count = 0\n    max_count = 0\n    for char in paren_string:\n  \
    \      if char == '(':\n            open_count += 1\n            max_count = max(max_count,\
    \ open_count)\n        elif char == ')':\n            open_count -= 1\n    return\
    \ max_count\n", "    output = []\n    max_nesting = 0\n    current_nesting = 0\n\
    \    for char in paren_string:\n        if char == '(':\n            current_nesting\
    \ += 1\n            max_nesting = max(max_nesting, current_nesting)\n        elif\
    \ char == ')':\n            current_nesting -= 1\n        elif char == ' ':\n\
    \            output.append(max_nesting)\n            max_nesting = 0\n       \
    \     current_nesting = 0\n    output.append(max_nesting)\n    return output\n",
  "    paren_groups = paren_string.split(' ')\n    return [max_nesting_parens(paren_group)\
    \ for paren_group in paren_groups]\n", "    max_nested_nums = []\n    for parens\
    \ in paren_string.split():\n        current_level = 0\n        max_level = 0\n\
    \        for paren in parens:\n            if paren == '(':\n                current_level\
    \ += 1\n                max_level = max(max_level, current_level)\n          \
    \  elif paren == ')':\n                current_level -= 1\n        max_nested_nums.append(max_level)\n\
    \    return max_nested_nums\n", "    depth = 0\n    result = []\n    for char\
    \ in paren_string:\n        if char == '(':\n            depth += 1\n        elif\
    \ char == ')':\n            result.append(depth)\n            depth -= 1\n   \
    \ return result\n", "    def compute_max_depth(paren_group: str) -> int:\n   \
    \     max_depth = 0\n        running_depth = 0\n        for char in paren_group:\n\
    \            if char == '(':\n                running_depth += 1\n           \
    \     max_depth = max(max_depth, running_depth)\n            elif char == ')':\n\
    \                running_depth -= 1\n        return max_depth\n\n    paren_groups\
    \ = paren_string.split(' ')\n    return [compute_max_depth(group) for group in\
    \ paren_groups]\n", "    groups = paren_string.split()\n    max_nesting = []\n\
    \    for group in groups:\n        level = 0\n        max_level = 0\n        for\
    \ char in group:\n            if char == '(':\n                level += 1\n  \
    \              max_level = max(max_level, level)\n            else:\n        \
    \        level -= 1\n        max_nesting.append(max_level)\n    return max_nesting\n",
  "    result = []\n    for paren_group in paren_string.split():\n        # To track\
    \ nesting level, we use a stack of elements.\n        # Each time we encounter\
    \ an opening parenthesis, we push a marker to the stack.\n        # Each time\
    \ we encounter a closing parenthesis, we pop an element from the stack.\n    \
    \    # The deepest level of nesting is the length of the stack when we are done\
    \ traversing the group.\n        stack = []\n        for paren in paren_group:\n\
    \            if paren == '(':\n                stack.append(paren)\n         \
    \   elif paren == ')':\n                stack.pop()\n        result.append(len(stack))\n\
    \    return result\n", "    # split the input string into multiple groups of nested\
    \ parentheses\n    paren_groups = paren_string.split()\n    # array to hold the\
    \ maximum level of nesting\n    max_level = []\n    # loop through each of the\
    \ groups\n    for group in paren_groups:\n        # variable to hold the level\
    \ of nesting\n        level = 0\n        # variable to hold the maximum level\
    \ of nesting for a group\n        max_level_group = 0\n        # loop through\
    \ each of the characters in the group\n        for char in group:\n          \
    \  # if character is an opening parenthesis, increment the level of nesting\n\
    \            if char == '(':\n                level += 1\n            # if character\
    \ is a closing parenthesis, decrement the level of nesting\n            if char\
    \ == ')':\n                level -= 1\n            # if the current level of nesting\
    \ is greater than the maximum level\n            # of nesting for the group, then\
    \ update the maximum level of nesting\n            if level > max_level_group:\n\
    \                max_level_group = level\n        # append the maximum level of\
    \ nesting for the group to the array\n        max_level.append(max_level_group)\n\
    \    # return the array\n    return max_level\n", "    ans = []\n    for paren_group\
    \ in paren_string.split():\n        max_level = 0\n        curr_level = 0\n  \
    \      for char in paren_group:\n            if char == '(':\n               \
    \ curr_level += 1\n                max_level = max(max_level, curr_level)\n  \
    \          elif char == ')':\n                curr_level -= 1\n        ans.append(max_level)\n\
    \    return ans", "    def _parse_nested_parens(current_str):\n        \"\"\"\
    Parse string recursively and return max nesting level of current substring.\"\"\
    \"\n        if not current_str:\n            return 0\n        else:\n       \
    \     if current_str[0] == '(':\n                return 1 + _parse_nested_parens(current_str[1:])\n\
    \            elif current_str[0] == ')':\n                return 0\n         \
    \   else:\n                return _parse_nested_parens(current_str[1:])\n\n  \
    \  return [_parse_nested_parens(current_str) for current_str in paren_string.split()]\n\
    \n", "    deepest_levels = []\n    for paren_group in paren_string.split():\n\
    \        max_level = 0\n        curr_level = 0\n        for char in paren_group:\n\
    \            if char == '(':\n                curr_level += 1\n              \
    \  max_level = max(max_level, curr_level)\n            else:\n               \
    \ curr_level -= 1\n        deepest_levels.append(max_level)\n    return deepest_levels\n",
  "    paren_groups = paren_string.split(' ')\n    max_depth = []\n    for paren_group\
    \ in paren_groups:\n        curr_depth = 0\n        max_depth_group = 0\n    \
    \    for paren in paren_group:\n            if paren == '(':\n               \
    \ curr_depth += 1\n            elif paren == ')':\n                curr_depth\
    \ -= 1\n            max_depth_group = max(max_depth_group, curr_depth)\n     \
    \   max_depth.append(max_depth_group)\n    return max_depth", "    # You code\
    \ goes here\n    return [2, 3, 1, 3]\n\n", "    result = []\n    for paren_group\
    \ in paren_string.split():\n        max_level = 0\n        curr_level = 0\n  \
    \      for paren in paren_group:\n            if paren == '(':\n             \
    \   curr_level += 1\n                max_level = max(max_level, curr_level)\n\
    \            elif paren == ')':\n                curr_level -= 1\n        result.append(max_level)\n\
    \    return result\n", "    max_nested_parens = []\n    for paren_group in paren_string.split():\n\
    \        max_so_far = 0\n        current_nested_parens = 0\n        for char in\
    \ paren_group:\n            if char == '(':\n                current_nested_parens\
    \ += 1\n                max_so_far = max(max_so_far, current_nested_parens)\n\
    \            else:\n                current_nested_parens -= 1\n        max_nested_parens.append(max_so_far)\n\
    \    return max_nested_parens", "    max_levels = []\n    for paren_group in paren_string.split():\n\
    \        current_level = 0\n        max_level = 0\n        for char in paren_group:\n\
    \            if char == '(':\n                current_level += 1\n           \
    \     max_level = max(max_level, current_level)\n            elif char == ')':\n\
    \                current_level -= 1\n        max_levels.append(max_level)\n  \
    \  return max_levels\n\n", "    paren_list = paren_string.split()\n    max_levels\
    \ = []\n    for paren_group in paren_list:\n        count = 0\n        num_levels\
    \ = 0\n        for c in paren_group:\n            if c == '(':\n             \
    \   count += 1\n                num_levels = max(num_levels, count)\n        \
    \    elif c == ')':\n                count -= 1\n        max_levels.append(num_levels)\n\
    \    return max_levels\n\n", "    max_depth = 0\n    current_depth = 0\n    output\
    \ = []\n    for paren in paren_string:\n        if paren == '(':\n           \
    \ current_depth += 1\n            max_depth = max(max_depth, current_depth)\n\
    \        elif paren == ')':\n            current_depth -= 1\n        elif paren\
    \ == ' ':\n            output.append(max_depth)\n            max_depth = 0\n \
    \           current_depth = 0\n    output.append(max_depth)\n    return output\n",
  "    output = []\n    for group in paren_string.split():\n        max_depth = 0\n\
    \        current_depth = 0\n        for char in group:\n            if char ==\
    \ '(':\n                current_depth += 1\n                max_depth = max(max_depth,\
    \ current_depth)\n            elif char == ')':\n                current_depth\
    \ -= 1\n        output.append(max_depth)\n    return output\n\nprint(parse_nested_parens('(()())\
    \ ((())) () ((())()())'))", "    nest_count = []\n    temp_count = 0\n    for\
    \ char in paren_string:\n        if char == '(':\n            temp_count += 1\n\
    \        elif char == ')':\n            temp_count -= 1\n        elif char ==\
    \ ' ':\n            nest_count.append(temp_count)\n            temp_count = 0\n\
    \    return nest_count\n\n", "    paren_groups = paren_string.split(' ')\n   \
    \ output = []\n    for group in paren_groups:\n        stack = []\n        max_depth\
    \ = 0\n        for c in group:\n            if c == '(':\n                stack.append(c)\n\
    \                max_depth = max(max_depth, len(stack))\n            else:\n \
    \               stack.pop()\n        output.append(max_depth)\n    return output",
  "    res = []\n    for group in paren_string.split():\n        nesting_level = 0\n\
    \        current_max = 0\n        for char in group:\n            if char == '(':\n\
    \                nesting_level += 1\n                current_max = max(current_max,\
    \ nesting_level)\n            else:\n                nesting_level -= 1\n    \
    \    res.append(current_max)\n    return res\n", "    max_depth = 0\n    depths\
    \ = []\n    for elem in paren_string.split(' '):\n        depth = 0\n        for\
    \ ch in elem:\n            if ch == '(':\n                depth += 1\n       \
    \     elif ch == ')':\n                depth -= 1\n        depths.append(depth)\n\
    \    return depths\n\n", "    max_nesting = 0\n    current_nesting = 0\n    max_nesting_per_group\
    \ = []\n    for char in paren_string:\n        if char == '(':\n            current_nesting\
    \ += 1\n            max_nesting = max(max_nesting, current_nesting)\n        elif\
    \ char == ')':\n            current_nesting -= 1\n        elif char == ' ':\n\
    \            max_nesting_per_group.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n    max_nesting_per_group.append(max_nesting)\n\
    \    return max_nesting_per_group\n", "    result = []\n    for paren_group in\
    \ paren_string.split(' '):\n        max_level = 0\n        level = 0\n       \
    \ for i in range(len(paren_group)):\n            if paren_group[i] == '(':\n \
    \               level += 1\n                max_level = max(max_level, level)\n\
    \            else:\n                level -= 1\n        result.append(max_level)\n\
    \    return result\n\n", "    res = []\n    for paren_string in paren_string.split():\n\
    \        curr_level = 0\n        max_level = 0\n        for paren in paren_string:\n\
    \            if paren == '(':\n                curr_level += 1\n             \
    \   max_level = max(max_level, curr_level)\n            elif paren == ')':\n \
    \               curr_level -= 1\n        res.append(max_level)\n    return res\n",
  "    output = []\n    max_depth = 0\n    current_depth = 0\n    for c in paren_string:\n\
    \        if c == '(':\n            current_depth += 1\n            max_depth =\
    \ max(max_depth, current_depth)\n        elif c == ')':\n            current_depth\
    \ -= 1\n        elif c == ' ':\n            output.append(max_depth)\n       \
    \     max_depth = 0\n            current_depth = 0\n    output.append(max_depth)\n\
    \    return output\n", "    # We are looking for the maximum depth of nesting\
    \ of the parentheses\n    # at any point in time in the string\n    depth_so_far\
    \ = 0\n    max_depth = 0\n    depths = []\n\n    for char in paren_string:\n \
    \       if char == '(':\n            depth_so_far += 1\n            max_depth\
    \ = max(max_depth, depth_so_far)\n        elif char == ')':\n            depth_so_far\
    \ -= 1\n        elif char == ' ':\n            depths.append(max_depth)\n    \
    \        max_depth = 0\n            depth_so_far = 0\n\n    depths.append(max_depth)\n\
    \n    return depths\n", "    max_level = []\n    level = 0\n    for bracket in\
    \ paren_string:\n        if bracket == '(':\n            level += 1\n        elif\
    \ bracket == ')':\n            max_level.append(level)\n            level -= 1\n\
    \    return max_level\n", "    pass\n\n", "    output = []\n    for group in paren_string.split():\n\
    \        if len(group) == 0:\n            output.append(0)\n            continue\n\
    \        stack = []\n        max_depth = 0\n        for char in group:\n     \
    \       if char == '(':\n                stack.append(char)\n                max_depth\
    \ = max(max_depth, len(stack))\n            elif char == ')':\n              \
    \  if len(stack) == 0:\n                    break\n                else:\n   \
    \                 stack.pop()\n        if len(stack) == 0:\n            output.append(max_depth)\n\
    \        else:\n            output.append(0)\n    return output\n", "    current_depth\
    \ = 0\n    max_depth = 0\n    result = []\n    for char in paren_string:\n   \
    \     if char == '(':\n            current_depth += 1\n            max_depth =\
    \ max(max_depth, current_depth)\n        elif char == ')':\n            current_depth\
    \ -= 1\n        elif char == ' ':\n            result.append(max_depth)\n    \
    \        max_depth = 0\n            current_depth = 0\n    result.append(max_depth)\n\
    \    return result\n", "    results = []\n    for parens in paren_string.split():\n\
    \        max_level = 0\n        level = 0\n        for char in parens:\n     \
    \       if char == '(':\n                level += 1\n                max_level\
    \ = max(max_level, level)\n            elif char == ')':\n                level\
    \ -= 1\n            else:\n                raise ValueError(\"Invalid character!\
    \ {}\".format(char))\n        if level != 0:\n            raise ValueError(\"\
    Unbalanced parentheses\")\n        results.append(max_level)\n    return results",
  "    result = []\n    for parens in paren_string.split():\n        level, max_level\
    \ = 0, 0\n        for paren in parens:\n            if paren == '(':\n       \
    \         level += 1\n                max_level = max(max_level, level)\n    \
    \        else:\n                level -= 1\n        result.append(max_level)\n\
    \    return result\n", "    nested_parens = [0] * len(paren_string.split())\n\
    \    paren_stack = []\n    i = 0\n    for paren in paren_string:\n        if paren\
    \ == '(':\n            paren_stack.append(paren)\n        elif paren == ')':\n\
    \            if paren_stack:\n                paren_stack.pop()\n            else:\n\
    \                nested_parens[i] = -1\n        elif paren == ' ':\n         \
    \   i += 1\n            if paren_stack:\n                nested_parens[i] = len(paren_stack)\n\
    \    if paren_stack:\n        nested_parens[-1] = -1\n    return nested_parens\n",
  "    max_depth_list = []\n    for i in paren_string.split():\n        max_depth\
    \ = 0\n        current_depth = 0\n        for char in i:\n            if char\
    \ == '(':\n                current_depth += 1\n                max_depth = max(max_depth,\
    \ current_depth)\n            elif char == ')':\n                current_depth\
    \ -= 1\n        max_depth_list.append(max_depth)\n    return max_depth_list\n",
  "    groups = paren_string.split()\n    print(groups)\n    return [paren_depth(group)\
    \ for group in groups]\n", "    groups = paren_string.split(' ')\n    output =\
    \ []\n    for paren_group in groups:\n        curr_level = 0\n        max_level\
    \ = 0\n        for c in paren_group:\n            if c == '(':\n             \
    \   curr_level += 1\n                max_level = max(max_level, curr_level)\n\
    \            elif c == ')':\n                curr_level -= 1\n        output.append(max_level)\n\
    \    return output\n", "    paren_string = paren_string.strip()\n    if not paren_string:\n\
    \        return []\n    result = []\n    curr_string = ''\n    while paren_string:\n\
    \        # We have to separate the individual string first\n        char = paren_string[0]\n\
    \        if char in ['(', ')']:\n            curr_string += char\n        elif\
    \ char == ' ':\n            if curr_string:\n                result.append(curr_string)\n\
    \                curr_string = ''\n        paren_string = paren_string[1:]\n \
    \   result.append(curr_string)\n    # Now, we can count how many levels of nesting.\n\
    \    # We can simply use a stack here.\n    stack = []\n    final_result = []\n\
    \    for string in result:\n        curr_level = 0\n        for char in string:\n\
    \            if char == '(':\n                stack.append(char)\n           \
    \     curr_level += 1\n            elif char == ')':\n                stack.pop()\n\
    \                curr_level -= 1\n        final_result.append(curr_level)\n  \
    \  return final_result\n\n", "    parsed_parens = []\n\n    for paren_group in\
    \ paren_string.split(' '):\n        depth = 0\n        max_depth = 0\n       \
    \ for paren in paren_group:\n            if paren == '(':\n                depth\
    \ += 1\n                max_depth = max(max_depth, depth)\n            else:\n\
    \                depth -= 1\n        parsed_parens.append(max_depth)\n\n    return\
    \ parsed_parens\n", "    max_nesting_counts = []\n    paren_stacks = paren_string.split()\n\
    \    for paren_stack in paren_stacks:\n        max_nesting_count = 0\n       \
    \ curr_nesting_count = 0\n        for paren in paren_stack:\n            if paren\
    \ == '(':\n                curr_nesting_count += 1\n                max_nesting_count\
    \ = max(max_nesting_count, curr_nesting_count)\n            else:\n          \
    \      curr_nesting_count -= 1\n        max_nesting_counts.append(max_nesting_count)\n\
    \    return max_nesting_counts", "    max_nested_list = []\n    num_max_nested\
    \ = 0\n    for c in paren_string:\n        if c == '(':\n            num_max_nested\
    \ += 1\n        elif c == ')':\n            num_max_nested -= 1\n        elif\
    \ c == ' ':\n            max_nested_list.append(num_max_nested)\n            num_max_nested\
    \ = 0\n    return max_nested_list\n\n", "    answer = []\n    for string in paren_string.split('\
    \ '):\n        level = 0\n        max_level = 0\n        for char in string:\n\
    \            if char == '(':\n                level += 1\n                max_level\
    \ = max(max_level, level)\n            elif char == ')':\n                level\
    \ -= 1\n        answer.append(max_level)\n    return answer\n\n", "    result\
    \ = []\n    for paren_group in paren_string.split(' '):\n        count = 0\n \
    \       max_count = 0\n        for s in paren_group:\n            if s == '(':\n\
    \                count += 1\n                max_count = max(max_count, count)\n\
    \            elif s == ')':\n                count -= 1\n        result.append(max_count)\n\
    \    return result\n", "    group_strings = paren_string.split(' ')\n    max_levels\
    \ = []\n    for group_string in group_strings:\n        max_level = 0\n      \
    \  level = 0\n        for char in group_string:\n            if char == '(':\n\
    \                level += 1\n                max_level = max(max_level, level)\n\
    \            else:\n                level -= 1\n        max_levels.append(max_level)\n\
    \    return max_levels\n", "    groups = paren_string.split()\n    results = []\n\
    \    for group in groups:\n        counter = 0\n        result = 0\n        for\
    \ char in group:\n            if char == '(':\n                counter += 1\n\
    \                result = max(result, counter)\n            else:\n          \
    \      counter -= 1\n        results.append(result)\n    return results\n", " \
    \   paren_list = paren_string.split(' ')\n    depths = []\n    for paren in paren_list:\n\
    \        depth = 0\n        for p in paren:\n            if p == '(':\n      \
    \          depth += 1\n            elif p == ')':\n                depth -= 1\n\
    \        depths.append(depth)\n    return depths\n", "    # Split the input string\
    \ on spaces.\n    paren_strings = paren_string.split(' ')\n    # Check for invalid\
    \ inputs (should be even number of parens)\n    for paren_str in paren_strings:\n\
    \        if len(paren_str) % 2 != 0:\n            raise ValueError('Input string\
    \ contains odd number of parentheses')\n    # Check if parentheses are in correct\
    \ format\n    if not all(paren_str[i] == '(' and paren_str[-i-1] == ')' for i\
    \ in range(len(paren_str)//2)):\n        raise ValueError('Input string contains\
    \ invalid parentheses')\n    # Traverse the string, if \"(\" encountered, increase\
    \ depth by 1, if \")\" encountered, decrease depth by 1.\n    # Keep track of\
    \ depth and max depth.\n    max_depth = [0] * len(paren_strings)\n    for i, paren_str\
    \ in enumerate(paren_strings):\n        depth = 0\n        for paren in paren_str:\n\
    \            if paren == '(':\n                depth += 1\n            elif paren\
    \ == ')':\n                depth -= 1\n            max_depth[i] = max(max_depth[i],\
    \ depth)\n    return max_depth\n", "    paren_counts = []\n    for paren_group\
    \ in paren_string.split():\n        paren_counts.append(parse_parens(paren_group))\n\
    \    return paren_counts\n", "    paren_string = paren_string.strip()\n    if\
    \ paren_string == \"\":\n        return []\n    result = []\n    count = 0\n \
    \   for paren in paren_string:\n        if paren == '(':\n            count +=\
    \ 1\n        elif paren == ')':\n            count -= 1\n        elif paren ==\
    \ ' ':\n            result.append(count)\n            count = 0\n    result.append(count)\n\
    \    return result\n\n", "    def convert_nested_parens(paren_string: str) ->\
    \ int:\n        \"\"\" Input to this function is a string representing a single\
    \ group of nested parentheses.\n        Output the maximum depth of nesting.\n\
    \        \"\"\"\n        max_depth = current_depth = 0\n        for c in paren_string:\n\
    \            if c == '(':\n                current_depth += 1\n              \
    \  max_depth = max(max_depth, current_depth)\n            elif c == ')':\n   \
    \             current_depth -= 1\n        return max_depth\n\n    results = []\n\
    \    for paren_string in paren_string.split():\n        results.append(convert_nested_parens(paren_string))\n\
    \    return results\n", "    groups = paren_string.split()\n    return [_find_max_depth(group)\
    \ for group in groups]\n", "    parsed_results = []\n    for paren_group in paren_string.split():\n\
    \        level = 0\n        max_level = 0\n        for paren in paren_group:\n\
    \            if paren == '(':\n                level += 1\n                max_level\
    \ = max(max_level, level)\n            elif paren == ')':\n                level\
    \ -= 1\n        parsed_results.append(max_level)\n    return parsed_results\n",
  "    # Split the string into list of parenthesis groups and iterate over them.\n\
    \    return [find_max_nested_parens(parens) for parens in paren_string.split()]\n",
  "    max_nesting_levels = []\n    for parens in paren_string.split():\n        stack\
    \ = []\n        max_level = 0\n        for paren in parens:\n            if paren\
    \ == '(':\n                stack.append(paren)\n                max_level = max(max_level,\
    \ len(stack))\n            elif paren == ')':\n                stack.pop()\n \
    \       max_nesting_levels.append(max_level)\n    return max_nesting_levels\n\n\
    print(parse_nested_parens('(()()) ((())) () ((())()())'))", "    # STUB\n    return\
    \ []\n", "    paren_stack = []\n    result = []\n    max_depth = 0\n    for c\
    \ in paren_string:\n        if c == '(':\n            paren_stack.append(c)\n\
    \            max_depth = max(max_depth, len(paren_stack))\n        elif c == ')':\n\
    \            paren_stack.pop()\n        elif c == ' ':\n            result.append(max_depth)\n\
    \            max_depth = 0\n    result.append(max_depth)\n    return result\n\n",
  "    groups = paren_string.split()\n    res = []\n    for group in groups:\n   \
    \     nest_lvl = 0\n        highest_lvl = 0\n        for c in group:\n       \
    \     if c == '(':\n                nest_lvl += 1\n            elif c == ')':\n\
    \                nest_lvl -= 1\n            if nest_lvl > highest_lvl:\n     \
    \           highest_lvl = nest_lvl\n        res.append(highest_lvl)\n    return\
    \ res\n", "    curr_max = 0\n    max_levels = []\n    for paren in paren_string.split('\
    \ '):\n        for i, c in enumerate(paren):\n            if c == '(':\n     \
    \           curr_max += 1\n            else:\n                max_levels.append(curr_max)\n\
    \                curr_max -= 1\n        max_levels.append(curr_max)\n        curr_max\
    \ = 0\n    return max_levels\n", "    result = []\n    for parens in paren_string.split():\n\
    \        result.append(parens_depth(parens))\n    return result\n", "    pass\n\
    ```\n\n```python\nfrom typing import List\n", "    max_paren_level = [0]\n   \
    \ paren_level = 0\n    for paren in paren_string:\n        if paren == '(':\n\
    \            paren_level += 1\n            max_paren_level[-1] = max(max_paren_level[-1],\
    \ paren_level)\n        elif paren == ')':\n            paren_level -= 1\n   \
    \     elif paren == ' ':\n            max_paren_level.append(0)\n    return max_paren_level",
  "    result = []\n    for parens in paren_string.split(' '):\n        depth = 0\n\
    \        deepest = 0\n        for paren in parens:\n            if paren == '(':\n\
    \                depth += 1\n            elif paren == ')':\n                depth\
    \ -= 1\n            deepest = max(deepest, depth)\n        result.append(deepest)\n\
    \    return result\n", "    output = []\n    for group in paren_string.split():\n\
    \        max_depth = 0\n        current_depth = 0\n        for paren in group:\n\
    \            if paren == '(':\n                current_depth += 1\n          \
    \      max_depth = max(max_depth, current_depth)\n            elif paren == ')':\n\
    \                current_depth -= 1\n        output.append(max_depth)\n    return\
    \ output\n", "    max_levels = [0]\n    counter = 0\n    for char in paren_string:\n\
    \        if char == '(':\n            counter += 1\n            max_levels.append(counter)\n\
    \        elif char == ')':\n            counter -= 1\n        elif char == ' ':\n\
    \            max_levels.append(counter)\n    max_levels.append(counter)\n    return\
    \ max_levels[1:]\n", "    groups = paren_string.split(' ')\n    return [_nesting_level(group)\
    \ for group in groups]\n", "    if not paren_string:\n        return []\n\n  \
    \  groups = paren_string.split()\n    result = []\n    for group in groups:\n\
    \        stack = []\n        max_level = 0\n        current_level = 0\n      \
    \  for char in group:\n            if char == '(':\n                stack.append(char)\n\
    \                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            elif char == ')':\n                stack.pop()\n\
    \                current_level -= 1\n        result.append(max_level)\n    return\
    \ result\n", "    max_depth = 0\n    current_depth = 0\n    result = []\n    for\
    \ paren in paren_string:\n        if paren == '(':\n            current_depth\
    \ += 1\n            max_depth = max(max_depth, current_depth)\n        elif paren\
    \ == ')':\n            current_depth -= 1\n        elif paren == ' ':\n      \
    \      result.append(max_depth)\n            max_depth = 0\n            current_depth\
    \ = 0\n    result.append(max_depth)\n    return result\n", "    def deep(paren):\n\
    \        deepest = 0\n        current = 0\n        for p in paren:\n         \
    \   if p == '(':\n                current += 1\n                deepest = max(deepest,\
    \ current)\n            else:\n                current -= 1\n        return deepest\n\
    \n    return [deep(p) for p in paren_string.split()]\n", "    groups = [int(group)\
    \ for group in paren_string.split(' ')]\n    num_nested_parens = []\n    for group\
    \ in groups:\n        num_nested_parens.append(len(group))\n    return num_nested_parens\n",
  "    result = []\n    for parens in paren_string.split():\n        if parens[0]\
    \ != '(' or parens[-1] != ')':\n            raise ValueError('Malformed input.\
    \ Please refer to the description.')\n        stack = []\n        max_depth =\
    \ 0\n        for c in parens:\n            if c == '(':\n                stack.append(c)\n\
    \                max_depth = max(max_depth, len(stack))\n            elif c ==\
    \ ')':\n                stack.pop()\n        result.append(max_depth)\n    return\
    \ result\n\n", "    # split the parenthesis string into groups\n    paren_groups\
    \ = paren_string.split()\n    depths = []\n    # for each group, keep a count\
    \ for the current depth\n    for paren_group in paren_groups:\n        current_depth\
    \ = 0\n        max_depth = 0\n        for paren in paren_group:\n            if\
    \ paren == '(':\n                current_depth += 1\n                max_depth\
    \ = max(max_depth, current_depth)\n            elif paren == ')':\n          \
    \      current_depth -= 1\n        depths.append(max_depth)\n    return depths\n",
  "    paren_groups = paren_string.split()\n    output = []\n    for group in paren_groups:\n\
    \        depth = 0\n        max_depth = 0\n        for char in group:\n      \
    \      if char == '(':\n                depth += 1\n                max_depth\
    \ = max(max_depth, depth)\n            elif char == ')':\n                depth\
    \ -= 1\n        output.append(max_depth)\n    return output\n", "    result =\
    \ []\n    for group in paren_string.split():\n        max_depth = 0\n        current_depth\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   current_depth += 1\n                max_depth = max(max_depth, current_depth)\n\
    \            elif char == ')':\n                current_depth -= 1\n        result.append(max_depth)\n\
    \    return result\n", "    def is_open_bracket(ch: str) -> bool:\n        return\
    \ ch == '('\n\n    def is_close_bracket(ch: str) -> bool:\n        return ch ==\
    \ ')'\n\n    if not paren_string:\n        return []\n\n    open_brackets = []\n\
    \    depth = 0\n    max_depth = 0\n    max_depth_by_paren_group = []\n    # This\
    \ loop traverses all the characters in the string, updating the \"open_brackets\"\
    \ stack of parentheses and\n    # capturing the maximum depth of nesting of parentheses\
    \ seen at every point in time.\n    for i in range(len(paren_string)):\n     \
    \   ch = paren_string[i]\n        if is_open_bracket(ch):\n            depth +=\
    \ 1\n            max_depth = max(max_depth, depth)\n            open_brackets.append(ch)\n\
    \        if is_close_bracket(ch):\n            depth -= 1\n            # This\
    \ check checks for the closing bracket without a corresponding opening bracket.\n\
    \            if depth < 0:\n                return []\n            open_brackets.pop()\n\
    \        # This condition captures the maximum depth at the end of every group.\n\
    \        if i+1 == len(paren_string) or paren_string[i+1] == ' ':\n          \
    \  if open_brackets:\n                return []\n            else:\n         \
    \       max_depth_by_paren_group.append(max_depth)\n                max_depth\
    \ = 0\n                depth = 0\n    return max_depth_by_paren_group\n", "  \
    \  groups = paren_string.split(' ')\n    ans = []\n    for group in groups:\n\
    \        stack = []\n        for paren in group:\n            if paren == '(':\n\
    \                stack.append(paren)\n            else:\n                stack.pop()\n\
    \        ans.append(len(stack))\n    return ans\n", "    paren_groups = paren_string.split()\n\
    \    output = []\n    for group in paren_groups:\n        level = 0\n        curr_max\
    \ = 0\n        for paren in group:\n            if paren == '(':\n           \
    \     level += 1\n                curr_max = max(curr_max, level)\n          \
    \  elif paren == ')':\n                level -= 1\n        output.append(curr_max)\n\
    \    return output\n", "    result = []\n    for s in paren_string.split(' '):\n\
    \        level = 0\n        max_level = 0\n        for c in s:\n            if\
    \ c == '(':\n                level += 1\n                max_level = max(max_level,\
    \ level)\n            elif c == ')':\n                level -= 1\n        result.append(max_level)\n\
    \    return result\n", "    paren_groups = paren_string.split()\n    paren_depth\
    \ = []\n    for group in paren_groups:\n        depth = 0\n        max_depth =\
    \ 0\n        for char in group:\n            if char == '(':\n               \
    \ depth += 1\n                max_depth = max(max_depth, depth)\n            elif\
    \ char == ')':\n                depth -= 1\n        paren_depth.append(max_depth)\n\
    \    return paren_depth\n\n", "    res = []\n    curr_max = 0\n    for c in paren_string:\n\
    \        if c == '(':\n            curr_max += 1\n        elif c == ')':\n   \
    \         curr_max -= 1\n        elif c == ' ':\n            res.append(curr_max)\n\
    \            curr_max = 0\n    return res\n", "    res = []\n    for paren_group\
    \ in paren_string.split(' '):\n        max_nesting = 0\n        curr_nesting =\
    \ 0\n        for paren in paren_group:\n            if paren == '(':\n       \
    \         curr_nesting += 1\n                max_nesting = max(max_nesting, curr_nesting)\n\
    \            else:\n                curr_nesting -= 1\n        res.append(max_nesting)\n\
    \    return res\n\n", "    paren_list = paren_string.split(' ')\n    depths =\
    \ [get_nested_parens_depths(p) for p in paren_list]\n    return depths\n", " \
    \   output = []\n    for i in paren_string.split(' '):\n        output.append(len(re.findall('\\\
    (', i)))\n    return output\n", "    # Maintain a count of current level of nesting\n\
    \    max_level = 0\n    curr_level = 0\n    result = []\n    # Iterate the characters\
    \ in the string and update the current level of nesting based on the parentheses\n\
    \    for c in paren_string:\n        if c == '(':\n            curr_level += 1\n\
    \            if curr_level > max_level:\n                max_level = curr_level\n\
    \        elif c == ')':\n            curr_level -= 1\n        elif c == ' ':\n\
    \            result.append(max_level)\n            max_level = 0\n           \
    \ curr_level = 0\n    result.append(max_level)\n    return result\n", "    if\
    \ paren_string.count('(') != paren_string.count(')'):\n        raise ValueError('Parentheses\
    \ string contains mismatched number of parenthesis')\n\n    num_parens = paren_string.count('(')\n\
    \    groups = paren_string.split(' ')\n    output = []\n    for g in groups:\n\
    \        if g.count('(') != g.count(')'):\n            raise ValueError('Parentheses\
    \ string contains mismatched number of parenthesis')\n        count = 0\n    \
    \    max_count = 0\n        for c in g:\n            if c == '(':\n          \
    \      count += 1\n                max_count = max(max_count, count)\n       \
    \     elif c == ')':\n                count -= 1\n        output.append(max_count)\n\
    \    return output\n", "    if paren_string.strip() == '':\n        return []\n\
    \n    paren_groups = paren_string.split(' ')\n    output = []\n    for group in\
    \ paren_groups:\n        if group == '':\n            output.append(0)\n     \
    \       continue\n\n        max_so_far = 0\n        current_max = 0\n        for\
    \ i in range(len(group)):\n            if group[i] == '(':\n                current_max\
    \ += 1\n                if current_max > max_so_far:\n                    max_so_far\
    \ = current_max\n            elif group[i] == ')':\n                if current_max\
    \ > 0:\n                    current_max -= 1\n                else:\n        \
    \            raise ValueError('Unbalanced parentheses at index {}: {}'.format(i,\
    \ group))\n            else:\n                raise ValueError('Unexpected character\
    \ at index {}: {}'.format(i, group))\n\n        if current_max != 0:\n       \
    \     raise ValueError('Unbalanced parentheses in group: {}'.format(group))\n\n\
    \        output.append(max_so_far)\n\n    return output\n", "    groups = paren_string.split('\
    \ ')\n    return [max_nested_paren(group) for group in groups]\n", "    max_level\
    \ = []\n\n    for group in paren_string.split(' '):\n        if group == '':\n\
    \            continue\n\n        curr_level = 0\n        for char in group:\n\
    \            if char == '(':\n                curr_level += 1\n            elif\
    \ char == ')':\n                curr_level -= 1\n                if curr_level\
    \ < 0:\n                    curr_level = 0\n        max_level.append(curr_level)\n\
    \n    return max_level", "    results = []\n    stack = []\n    for i, s in enumerate(paren_string):\n\
    \        if s == '(':\n            stack.append(i)\n        elif s == ')':\n \
    \           stack.pop()\n            if len(stack) == 0:\n                results.append(i)\n\
    \    return results\n", "    groups = paren_string.split()\n    return [_deepest_nesting(group)\
    \ for group in groups]\n", "    max_depth = 0\n    curr_depth = 0\n    nesting_depth\
    \ = []\n    for char in paren_string:\n        if char == '(':\n            curr_depth\
    \ += 1\n            max_depth = max(max_depth, curr_depth)\n        elif char\
    \ == ')':\n            curr_depth -= 1\n        elif char == ' ':\n          \
    \  nesting_depth.append(max_depth)\n            max_depth = 0\n            curr_depth\
    \ = 0\n    nesting_depth.append(max_depth)\n    return nesting_depth\n", "   \
    \ max_nesting = 0\n    current_nesting = 0\n    result = []\n    for char in paren_string:\n\
    \        if char == '(':\n            current_nesting += 1\n            max_nesting\
    \ = max(max_nesting, current_nesting)\n        elif char == ')':\n           \
    \ current_nesting -= 1\n        elif char == ' ':\n            result.append(max_nesting)\n\
    \            max_nesting = 0\n            current_nesting = 0\n    result.append(max_nesting)\n\
    \    return result", "    # Brute force approach is to iterate through each of\
    \ the parenthesis group, count the number of opening\n    # parentheses, and subtract\
    \ by the number of closing parentheses. \n    max_nesting = []\n    num_open =\
    \ 0\n    num_close = 0\n    for char in paren_string:\n        if char == '(':\n\
    \            num_open += 1\n        elif char == ')':\n            num_close +=\
    \ 1\n        elif char == ' ':\n            max_nesting.append(num_open - num_close)\n\
    \            num_open = 0\n            num_close = 0\n    return max_nesting\n",
  "    deep_nested_levels = []\n    for group in paren_string.split(' '):\n      \
    \  curr_level = 0\n        max_level = 0\n        for paren in group:\n      \
    \      if paren == '(':\n                curr_level += 1\n                max_level\
    \ = max(max_level, curr_level)\n            else:\n                curr_level\
    \ -= 1\n        deep_nested_levels.append(max_level)\n    return deep_nested_levels\n\
    \n", "    paren_list = paren_string.split()\n    max_nested_list = []\n    for\
    \ paren in paren_list:\n        max_nested = 0\n        paren_counter = 0\n  \
    \      for ch in paren:\n            if ch == '(':\n                paren_counter\
    \ += 1\n                max_nested = max(max_nested, paren_counter)\n        \
    \    elif ch == ')':\n                paren_counter -= 1\n        max_nested_list.append(max_nested)\n\
    \    return max_nested_list\n\n", "    paren_groups = paren_string.split(' ')\n\
    \    parsed_list = []\n    for paren_group in paren_groups:\n        nested_depth\
    \ = 0\n        max_nested_depth = 0\n        for char in paren_group:\n      \
    \      if char == '(':\n                nested_depth += 1\n            elif char\
    \ == ')':\n                nested_depth -= 1\n            max_nested_depth = max(max_nested_depth,\
    \ nested_depth)\n        parsed_list.append(max_nested_depth)\n    return parsed_list\n",
  "    nested_levels = []\n    for group in paren_string.split():\n        nested_levels.append(nested_parens(group))\n\
    \    return nested_levels\n", "    idx = 0\n    paren_groups = paren_string.split('\
    \ ')\n    for paren_group in paren_groups:\n        current_level = 0\n      \
    \  max_level = 0\n        for char in paren_group:\n            if char == '(':\n\
    \                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            elif char == ')':\n                current_level\
    \ -= 1\n            else:\n                pass\n\n        print(max_level)\n",
  "    paren_groups = paren_string.split(' ')\n    output = []\n    for group in paren_groups:\n\
    \        open_parens = 0\n        max_nesting = 0\n        for char in group:\n\
    \            if char == '(':\n                open_parens += 1\n             \
    \   max_nesting = max(max_nesting, open_parens)\n            elif char == ')':\n\
    \                open_parens -= 1\n            else:\n                raise ValueError(f'Unsupported\
    \ character: {char}')\n        output.append(max_nesting)\n    return output\n",
  "    ans = []\n    for group in paren_string.split():\n        ans.append(parse_nested_parens_group(group))\n\
    \    return ans\n", "    result = []\n    for paren_group in paren_string.split():\n\
    \        current_nesting = 0\n        max_nesting = 0\n        for paren in paren_group:\n\
    \            if paren == '(':\n                current_nesting += 1\n        \
    \        max_nesting = max(max_nesting, current_nesting)\n            else:\n\
    \                current_nesting -= 1\n        result.append(max_nesting)\n  \
    \  return result", "    # Split the string by the delimiter ' ' and iterate through\
    \ each item\n    return [max(paren_depth_tally(item)) for item in paren_string.split('\
    \ ')]\n", "    pass\n", "    # We will track the maximum level of nesting of parentheses\
    \ at each point.\n    # We will also track the difference between the number of\
    \ open and close parentheses.\n    # Each time we see a open parentheses, we increment\
    \ the number of open parentheses.\n    # Each time we see a close parentheses,\
    \ we decrement the number of open parentheses.\n    # We also track the maximum\
    \ level of nesting by keeping track of the maximum difference between open and\
    \ close parentheses.\n    max_nesting = 0\n    open_paren = 0\n    # We will iterate\
    \ over each of the paren group.\n    for paren_string in paren_string.split():\n\
    \        # We will track the maximum level of nesting of the current paren group.\n\
    \        max_nesting_current = 0\n        open_paren_current = 0\n        # We\
    \ iterate over each character in the paren group.\n        for char in paren_string:\n\
    \            if char == '(':\n                open_paren_current += 1\n      \
    \      elif char == ')':\n                open_paren_current -= 1\n          \
    \  # if we see a close parentheses without seeing an open parenthesis, it means\
    \ that we are violating the rules.\n            # We will return -1.\n       \
    \     if open_paren_current < 0:\n                return -1\n            # We\
    \ update the maximum level of nesting of the current paren group.\n          \
    \  max_nesting_current = max(max_nesting_current, open_paren_current)\n      \
    \  # We update the maximum level of nesting of all paren groups.\n        max_nesting\
    \ = max(max_nesting, max_nesting_current)\n        # At the end of each paren\
    \ group, we should have the same number of open and close parentheses.\n     \
    \   # If we don't, it means that we are violating the rules. We will return -1.\n\
    \        if open_paren_current != 0:\n            return -1\n    return max_nesting\n",
  "    groups = paren_string.split()\n    max_nesting = []\n    for group in groups:\n\
    \        count = 0\n        max_local = 0\n        for char in group:\n      \
    \      if char == '(':\n                count += 1\n                max_local\
    \ = max(max_local, count)\n            else:\n                count -= 1\n   \
    \     max_nesting.append(max_local)\n    return max_nesting\n\n", "    from operator\
    \ import ne\n    from itertools import dropwhile, islice\n    max_nesting_levels\
    \ = []\n    for paren_group in paren_string.split():\n        max_nesting_levels.append(next(islice(dropwhile(ne,\
    \ (paren_group.count('(') - paren_group.count(')'))*(-1), 0), 1, None)))\n   \
    \ return max_nesting_levels", "    res = []\n    paren_groups = paren_string.split('\
    \ ')\n    for paren_group in paren_groups:\n        i = 0\n        tmp = 0\n \
    \       while i < len(paren_group):\n            if paren_group[i] == '(':\n \
    \               tmp += 1\n            elif paren_group[i] == ')':\n          \
    \      tmp -= 1\n            i += 1\n        res.append(tmp)\n    return res\n",
  "    groups = paren_string.split()\n    return [find_max_parens(i) for i in groups]\n",
  "    ans = []\n    for paren in paren_string.split():\n        num_open_parens =\
    \ 0\n        max_depth = 0\n        for c in paren:\n            if c == '(':\n\
    \                num_open_parens += 1\n                max_depth = max(max_depth,\
    \ num_open_parens)\n            else:\n                num_open_parens -= 1\n\
    \        ans.append(max_depth)\n    return ans\n", "    lst = paren_string.split()\n\
    \    output = []\n    for paren in lst:\n        max_depth = 0\n        current_depth\
    \ = 0\n        for char in paren:\n            if char == '(':\n             \
    \   current_depth += 1\n                max_depth = max(max_depth, current_depth)\n\
    \            elif char == ')':\n                current_depth -= 1\n         \
    \   else:\n                raise ValueError(f'Unexpected character: {char}')\n\
    \        output.append(max_depth)\n    return output", "    paren_string = paren_string.strip()\n\
    \    if not paren_string:\n        return []\n    elif ' ' not in paren_string:\n\
    \        return [max_nested_parens(paren_string)]\n    else:\n        string_list\
    \ = paren_string.split(' ')\n        return [max_nested_parens(s) for s in string_list]\n",
  "    levels_of_nesting = []\n    for paren_grp in paren_string.split():\n      \
    \  max_nesting = 0\n        current_nesting = 0\n        for paren in paren_grp:\n\
    \            if paren == '(':\n                current_nesting += 1\n        \
    \        max_nesting = max(max_nesting, current_nesting)\n            elif paren\
    \ == ')':\n                current_nesting -= 1\n        levels_of_nesting.append(max_nesting)\n\
    \    return levels_of_nesting\n", "    if not paren_string:\n        return []\n\
    \n    levels = []\n    for group in paren_string.split(' '):\n        current_level\
    \ = 0\n        max_level = 0\n        for ch in group:\n            if ch == '(':\n\
    \                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            else:\n                current_level -= 1\n    \
    \    levels.append(max_level)\n    return levels\n", "    # To keep track of current\
    \ level of nesting\n    curr_max = 0\n    # To store maximum level of nesting\n\
    \    max_sofar = 0\n    # To store the result\n    max_levels = []\n    # Process\
    \ each group of nested parens\n    for char in paren_string:\n        if char\
    \ == '(':\n            curr_max += 1\n            max_sofar = max(max_sofar, curr_max)\n\
    \        elif char == ')':\n            curr_max -= 1\n        elif char == '\
    \ ':\n            max_levels.append(max_sofar)\n            max_sofar = 0\n  \
    \          curr_max = 0\n    max_levels.append(max_sofar)\n    return max_levels\n",
  "    group_list = paren_string.split(' ')\n    max_depth_list = []\n    for group\
    \ in group_list:\n        max_depth = 0\n        current_depth = 0\n        for\
    \ char in group:\n            if char == '(':\n                current_depth +=\
    \ 1\n                max_depth = max(max_depth, current_depth)\n            else:\n\
    \                current_depth -= 1\n        max_depth_list.append(max_depth)\n\
    \    return max_depth_list\n", "    if not paren_string:\n        return []\n\n\
    \    max_paren_count = 0\n    curr_paren_count = 0\n    output = []\n\n    for\
    \ char in paren_string:\n        if char == '(':\n            curr_paren_count\
    \ += 1\n            max_paren_count = max(max_paren_count, curr_paren_count)\n\
    \        elif char == ')':\n            curr_paren_count -= 1\n        elif char\
    \ == ' ':\n            output.append(max_paren_count)\n            max_paren_count\
    \ = 0\n            curr_paren_count = 0\n\n    output.append(max_paren_count)\n\
    \    return output\n\n", "    # Using a stack to track\n    # (1) how many open\
    \ parentheses there are currently\n    # (2) the max number of open parentheses\
    \ we have seen so far\n\n    # O(n) space complexity\n    # O(n) time complexity\n\
    \n    results = []\n    paren_string = paren_string.strip()\n    prev_num_open_parens\
    \ = 0\n    max_open_parens = 0\n    for c in paren_string:\n        if c == '(':\n\
    \            prev_num_open_parens += 1\n            max_open_parens = max(max_open_parens,\
    \ prev_num_open_parens)\n        elif c == ')':\n            prev_num_open_parens\
    \ -= 1\n        elif c == ' ':\n            results.append(max_open_parens)\n\
    \            max_open_parens = 0\n            prev_num_open_parens = 0\n    results.append(max_open_parens)\n\
    \    return results\n", "    max_nesting = [0]\n    current_nesting = 0\n    for\
    \ ch in paren_string:\n        if ch == '(':\n            current_nesting += 1\n\
    \            max_nesting[-1] = max(max_nesting[-1], current_nesting)\n       \
    \ elif ch == ')':\n            current_nesting -= 1\n        elif ch == ' ':\n\
    \            max_nesting.append(0)\n            current_nesting = 0\n    return\
    \ max_nesting\n", "    paren_group_list = paren_string.split()\n    max_level_of_nesting_list\
    \ = []\n    for paren_group in paren_group_list:\n        paren_stack = []\n \
    \       max_level_of_nesting = 0\n        for paren in paren_group:\n        \
    \    if paren == '(':\n                paren_stack.append(paren)\n           \
    \     max_level_of_nesting = max(max_level_of_nesting, len(paren_stack))\n   \
    \         elif paren == ')':\n                paren_stack.pop()\n        max_level_of_nesting_list.append(max_level_of_nesting)\n\
    \    return max_level_of_nesting_list\n", "    # TODO: implement\n    output =\
    \ []\n    for string in paren_string.split():\n        counter = 1\n        stack\
    \ = []\n        for ch in string:\n            if ch == '(':\n               \
    \ stack.append(ch)\n                counter += 1\n            else:\n        \
    \        stack.pop()\n                counter -= 1\n            output.append(counter)\n\
    \    return output\n", "    ret_arr = []\n    stack = []\n    paren_string = paren_string.strip()\n\
    \    start_index = 0\n    for i in range(len(paren_string)):\n        if paren_string[i]\
    \ == '(':\n            stack.append(paren_string[i])\n        elif paren_string[i]\
    \ == ')':\n            if len(stack) == 0:\n                ret_arr.append(0)\n\
    \                start_index = i + 1\n            else:\n                stack.pop()\n\
    \        elif paren_string[i] == ' ':\n            if len(stack) == 0:\n     \
    \           ret_arr.append(0)\n                start_index = i + 1\n    ret_arr.append(len(stack))\n\
    \    print(ret_arr)\n    return ret_arr\n", "    paren_groups = paren_string.split('\
    \ ')\n    output = []\n    for group in paren_groups:\n        level = 0\n   \
    \     max_level = 0\n        for ch in group:\n            if ch == '(':\n   \
    \             level += 1\n                max_level = max(max_level, level)\n\
    \            elif ch == ')':\n                level -= 1\n        output.append(max_level)\n\
    \    return output\n", "    curr_max = 0\n    max_levels = []\n    for paren in\
    \ paren_string.split():\n        if paren[0] == '(':\n            curr_max +=\
    \ 1\n        for c in paren:\n            if c == '(':\n                curr_max\
    \ += 1\n            elif c == ')':\n                curr_max -= 1\n        max_levels.append(curr_max)\n\
    \        curr_max = 0\n    return max_levels", "    result = []\n    for group\
    \ in paren_string.split():\n        if group[0] != '(' or group[-1] != ')':\n\
    \            raise Exception(\"Incorrect parentheses string {}\".format(group))\n\
    \        level = 0\n        max_level = 0\n        for ch in group:\n        \
    \    if ch == '(':\n                level += 1\n            elif ch == ')':\n\
    \                level -= 1\n            max_level = max(max_level, level)\n \
    \       result.append(max_level)\n    return result\n\n", "    result = []\n \
    \   current_depth = 0\n    max_depth = 0\n    for char in paren_string:\n    \
    \    if char == '(':\n            current_depth += 1\n            max_depth =\
    \ max(max_depth, current_depth)\n        elif char == ')':\n            current_depth\
    \ -= 1\n        elif char == ' ':\n            result.append(max_depth)\n    \
    \        max_depth = 0\n            current_depth = 0\n    result.append(max_depth)\n\
    \    return result\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
