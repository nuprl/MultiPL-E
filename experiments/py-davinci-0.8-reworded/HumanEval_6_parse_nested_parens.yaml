name: HumanEval_6_parse_nested_parens
language: py
prompt: "from typing import List\n\ndef parse_nested_parens(paren_string: str) ->\
  \ List[int]:\n    \"\"\" Input to this function is a string represented multiple\
  \ groups for nested parentheses separated by spaces.\n    For each of the group,\
  \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
  \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
  \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
  \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
  \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
  \ntest_check()\n"
completions: ["    result = []\n    for paren_group in paren_string.split(' '):\n\
    \        result.append(__find_deepest_nesting(paren_group))\n    return result\n",
  "    results = []\n    for parens in paren_string.split():\n        results.append(helper(parens))\n\
    \    return results\n", "    all_parens = paren_string.split()\n    # For each\
    \ paren, check if it is opened or closed.\n    # If it is opened, increment the\
    \ counter by 1.\n    # If it is closed, decrement the counter by 1.\n    # If\
    \ the decrement goes below zero, it means we have extra closed parens.\n    #\
    \ Return the highest value reached during the iteration.\n    paren_levels = [max(0,\
    \ sum(1 if ch == '(' else -1 for ch in paren)) for paren in all_parens]\n    return\
    \ paren_levels\n\n", "    result = []\n    for parens in paren_string.split('\
    \ '):\n        max_depth = 0\n        current_depth = 0\n        for paren in\
    \ parens:\n            if paren == '(':\n                current_depth += 1\n\
    \                max_depth = max(max_depth, current_depth)\n            elif paren\
    \ == ')':\n                current_depth -= 1\n        result.append(max_depth)\n\
    \    return result\n", "    ret = []\n    for group in paren_string.split():\n\
    \        counter = 0\n        depth = 0\n        for char in group:\n        \
    \    if char == '(':\n                counter += 1\n                depth = max(depth,\
    \ counter)\n            elif char == ')':\n                counter -= 1\n    \
    \    ret.append(depth)\n    return ret\n", "    output = []\n    for nested_parens\
    \ in paren_string.split(' '):\n        num_opened = 0\n        nested_depth =\
    \ 0\n        for char in nested_parens:\n            if char == '(':\n       \
    \         num_opened += 1\n                nested_depth = max(nested_depth, num_opened)\n\
    \            else:\n                num_opened -= 1\n        output.append(nested_depth)\n\
    \    return output", "    current_depth = 0\n    max_depth = 0\n    paren_depth\
    \ = []\n    for char in paren_string:\n        if char == '(':\n            current_depth\
    \ += 1\n            max_depth = max(max_depth, current_depth)\n        elif char\
    \ == ')':\n            paren_depth.append(max_depth)\n            max_depth =\
    \ 0\n            current_depth -= 1\n        elif char == ' ':\n            continue\n\
    \    return paren_depth\n\n", "    # TODO: implement this function\n    max_depth\
    \ = []\n    group = paren_string.split()\n    for g in group:\n        count =\
    \ 0\n        max_depth.append(0)\n        for i in g:\n            if i == '(':\n\
    \                count += 1\n                if count > max_depth[-1]:\n     \
    \               max_depth[-1] = count\n            if i == ')':\n            \
    \    count -= 1\n    return max_depth\n    pass\n", "    # Use this list to store\
    \ the result\n    result = []\n    # A helper function to count the maximum level\
    \ of nesting of parentheses\n    def max_level(p_string: str) -> int:\n      \
    \  # TODO: write your own function here\n        pass\n    # Parse the input string\
    \ and store the result\n    for p_string in paren_string.split():\n        result.append(max_level(p_string))\n\
    \    return result\n", "    result = []\n    for s in paren_string.split():\n\
    \        curr_max_depth = max_depth = depth = 0\n        for ch in s:\n      \
    \      if ch == '(':\n                depth += 1\n                curr_max_depth\
    \ = max(curr_max_depth, depth)\n            elif ch == ')':\n                depth\
    \ -= 1\n            else:\n                raise ValueError(\"Unknown character:\
    \ {}\".format(ch))\n        if depth != 0:\n            raise ValueError(\"Invalid\
    \ parenthesis string {}: {}\".format(s, depth))\n        result.append(curr_max_depth)\n\
    \    return result\n\n", "    max_level = 0\n    level = 0\n    max_levels = []\n\
    \    for char in paren_string:\n        if char == '(':\n            level +=\
    \ 1\n            max_level = max(max_level, level)\n        elif char == ')':\n\
    \            level -= 1\n        elif char == ' ':\n            max_levels.append(max_level)\n\
    \            max_level = 0\n            level = 0\n    max_levels.append(max_level)\n\
    \    return max_levels", "    res = []\n    for _str in paren_string.split(' '):\n\
    \        stack = []\n        max_len = 0\n        for c in _str:\n           \
    \ if c == '(':\n                stack.append(c)\n                max_len = max(max_len,\
    \ len(stack))\n            elif c == ')':\n                stack.pop()\n     \
    \   res.append(max_len)\n    return res\n\n", "    output = []\n    for paren_group\
    \ in paren_string.split():\n        max_level = 0\n        curr_level = 0\n  \
    \      for paren in paren_group:\n            if paren == '(':\n             \
    \   curr_level += 1\n                max_level = max(max_level, curr_level)\n\
    \            elif paren == ')':\n                curr_level -= 1\n           \
    \ else:\n                raise ValueError(f'Invalid paren in string: {paren}')\n\
    \        output.append(max_level)\n    return output\n", "    paren_groups = paren_string.split()\n\
    \    # print(paren_groups)\n    max_depth = []\n    for paren_group in paren_groups:\n\
    \        # print(paren_group)\n        current_depth = 0\n        for char in\
    \ paren_group:\n            if char == '(':\n                current_depth +=\
    \ 1\n            elif char == ')':\n                current_depth -= 1\n     \
    \       else:\n                raise ValueError('Improper input!')\n        max_depth.append(current_depth)\n\
    \    return max_depth\n\n", "    result = []\n    for s in paren_string.split():\n\
    \        start = 0\n        max_level = 0\n        level = 0\n        while start\
    \ < len(s):\n            if s[start] == '(':\n                level += 1\n   \
    \             max_level = max(max_level, level)\n            elif s[start] ==\
    \ ')':\n                level -= 1\n            start += 1\n        result.append(max_level)\n\
    \    return result\n\n", "    result = []\n    for group in paren_string.split('\
    \ '):\n        level = 0\n        max_level = 0\n        for c in group:\n   \
    \         if c == '(':\n                level += 1\n                max_level\
    \ = max(max_level, level)\n            else:\n                level -= 1\n   \
    \     result.append(max_level)\n    return result\n", "    paren_list = paren_string.split('\
    \ ')\n    return [max_nesting(substr) for substr in paren_list]\n", "    parsed_parens\
    \ = []\n    for paren_group in paren_string.split(' '):\n        # initialize\
    \ depth of each group to be 0\n        depth = 0\n        max_depth = 0\n    \
    \    for char in paren_group:\n            if char == '(':\n                depth\
    \ += 1\n                max_depth = max(max_depth, depth)\n            elif char\
    \ == ')':\n                depth -= 1\n            else:\n                raise\
    \ ValueError('Input string can only contain \"(\" or \")\"')\n        parsed_parens.append(max_depth)\n\
    \    return parsed_parens\n", "    pass\n\n", "    max_nesting = 0\n    current_nesting\
    \ = 0\n    max_nesting_list = []\n    for char in paren_string:\n        if char\
    \ == '(':\n            current_nesting += 1\n            max_nesting = max(max_nesting,\
    \ current_nesting)\n        elif char == ')':\n            current_nesting -=\
    \ 1\n        elif char == ' ':\n            max_nesting_list.append(max_nesting)\n\
    \            max_nesting = 0\n            current_nesting = 0\n    max_nesting_list.append(max_nesting)\n\
    \    return max_nesting_list\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
