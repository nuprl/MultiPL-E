name: HumanEval_11_string_xor
language: py
prompt: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
  \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
  \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
  \    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n\
  \    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') ==\
  \ '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
completions: ["    return ''.join(str(int(i) ^ int(j)) for i, j in zip(a, b))\n\n",
  "    assert len(a) == len(b)\n    xor = (int(a[0]) + int(b[0])) % 2\n    for i in\
    \ range(1, len(a)):\n        xor = xor * 10 + (int(a[i]) + int(b[i])) % 2\n  \
    \  return str(xor)\n\n", "    assert len(a) == len(b)\n    if len(a) < 1:\n  \
    \      return \"\"\n    if a[0] == b[0]:\n        return \"0\" + string_xor(a[1:],\
    \ b[1:])\n    else:\n        return \"1\" + string_xor(a[1:], b[1:])\n\n", " \
    \   if len(a) != len(b):\n        raise Exception(\"Length of strings should be\
    \ equal\")\n    # convert strings to array of integers\n    a = [int(i) for i\
    \ in a]\n    b = [int(i) for i in b]\n    res = [x ^ y for x, y in zip(a, b)]\n\
    \    return ''.join(str(i) for i in res)\n\n", "    return ''.join(str(int(a[i])\
    \ ^ int(b[i])) for i in range(len(a)))\n\n", "    return ''.join([str(int(x) ^\
    \ int(y)) for x, y in zip(a, b)])\n", "    return \"\".join([bin(int(x, 2) ^ int(y,\
    \ 2))[2:] for x, y in zip(a, b)])\n\n", "    # length of a and b must be equal\n\
    \    assert len(a) == len(b)\n    output = \"\"\n    for i in range(len(a)):\n\
    \        if a[i] == b[i]:\n            output += \"0\"\n        else:\n      \
    \      output += \"1\"\n    return output\n\n", "    #NOTE: This will only work\
    \ if both strings are the same length\n    assert len(a) == len(b)\n    return\
    \ ''.join(str(int(bool(int(a[i]) != int(b[i])))) for i in range(len(a)))\n", " \
    \   assert len(a) == len(b)\n    len_a = len(a)\n    assert len_a % 2 == 0\n\n\
    \    result = \"\"\n    for i in range(0, len_a, 2):\n        b_high = int(b[i:i+2],\
    \ 2)\n        a_high = int(a[i:i+2], 2)\n        result += (b_high ^ a_high).to_bytes(1,\
    \ 'big').hex()\n\n    return result\n\n", "    return format(int(a, 2) ^ int(b,\
    \ 2), 'b')\n\n", "    return ''.join(['1' if a[i] != b[i] else '0' for i in range(len(a))])\n\
    \n", "    return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n", " \
    \   assert len(a) == len(b)\n    s = []\n    for i in range(len(a)):\n       \
    \ if a[i] == b[i]:\n            s.append('0')\n        else:\n            s.append('1')\n\
    \    return ''.join(s)\n\n", "    #TODO: implement this method\n\n    return \"\
    {0:b}\".format(int(a, 2) ^ int(b, 2))\n\n", "    return ''.join([str(int(x) ^\
    \ int(y)) for x, y in zip(a, b)])\n", "    return ''.join(str(i) for i in list(np.array(list(a))\
    \ ^ np.array(list(b))))\n\n", "    if len(a) != len(b):\n        raise ValueError('Input\
    \ strings must be of equal length')\n    out = ''\n    for i in range(len(a)):\n\
    \        if a[i] == b[i]:\n            out += '0'\n        else:\n           \
    \ out += '1'\n    return out\n\n", "    assert len(a) == len(b)\n    res = ''\n\
    \    for bit_i in range(len(a)):\n        if a[bit_i] == b[bit_i]:\n         \
    \   res += '0'\n        else:\n            res += '1'\n    return res\n\n", " \
    \   return ''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))])\n", " \
    \   return \"\".join(map(lambda t: str(int(t[0]) ^ int(t[1])), zip(a, b)))\n\n",
  "    return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n", "    a = int(a,\
    \ 2)\n    b = int(b, 2)\n    return bin(a ^ b)[2:]\n\n", "    res = []\n    for\
    \ ai, bi in zip(a, b):\n        if ai == bi:\n            res.append('0')\n  \
    \      else:\n            res.append('1')\n    return ''.join(res)\n\n", "   \
    \ return ''.join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n", "  \
    \  return ''.join([str(int(ai) ^ int(bi)) for ai, bi in zip(a, b)])\n\n", "  \
    \  assert len(a) == len(b)\n    return \"\".join(str(i != j) for i, j in zip(a,\
    \ b))\n\n", "    return ''.join([str(int(not (a[i] == b[i]))) for i in range(len(a))])\n\
    \n", "    # Implementation:\n    return bin(int(a, 2) ^ int(b, 2))[2:]\n \n",
  "    # Convert strings to binary lists\n    a_list = [int(bit) for bit in a]\n \
    \   b_list = [int(bit) for bit in b]\n    # XOR lists and convert back to string\n\
    \    res = ''.join([str(xor(a_bit, b_bit)) for a_bit, b_bit in zip(a_list, b_list)])\n\
    \    return res\n\n", "    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a,\
    \ b))\n", "    # TODO: Write code here\n    pass\n\n", "    #first convert the\
    \ string of binary to byte array\n    byte_a = int(a, 2).to_bytes(len(a) // 8,\
    \ byteorder='big')\n    byte_b = int(b, 2).to_bytes(len(b) // 8, byteorder='big')\n\
    \    #perform XOR\n    xor_result = xor(byte_a, byte_b)\n    #return binary string\n\
    \    return xor_result.hex()\n\n", "    return ''.join(str(int(x) ^ int(y)) for\
    \ x, y in zip(a, b))\n\n", "    xor_lst = []\n    for i in range(len(a)):\n  \
    \      if a[i] == b[i]:\n            xor_lst.append(0)\n        else:\n      \
    \      xor_lst.append(1)\n    return ''.join(str(x) for x in xor_lst)\n\n", " \
    \   return \"\".join(chr(ord(x) ^ ord(y)) for x, y in zip(a, b))\n\n", "    assert\
    \ len(a) == len(b)\n    return ''.join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\
    \n", "    if len(a) != len(b):\n        raise ValueError('operands have different\
    \ length')\n    if not (set(a) <= {'0', '1'} and set(b) <= {'0', '1'}):\n    \
    \    raise ValueError('operands contain invalid characters')\n    return ''.join(str(int(c1)\
    \ ^ int(c2)) for c1, c2 in zip(a, b))\n\n", "    a_bits = pad_to_length(a, b)\n\
    \    b_bits = pad_to_length(b, a)\n    return ''.join(['1' if a_bits[i] != b_bits[i]\
    \ else '0' for i in range(len(a_bits))])\n\n", "    return bin(int(a, 2) ^ int(b,\
    \ 2))[2:]\n\n", "    if len(a) != len(b):\n        raise ValueError('a and b must\
    \ be of the same length')\n    return ''.join(str(int(c1) ^ int(c2)) for c1, c2\
    \ in zip(a, b))\n\n", "    return ''.join([str(int(a[i]) ^ int(b[i])) for i in\
    \ range(len(a))])\n\n", "    a = int(a, 2)\n    b = int(b, 2)\n    c = a ^ b\n\
    \    return bin(c)[2:]\n\n", "    return ''.join(['1' if (x == '0' and y == '1')\
    \ or (x == '1' and y == '0') else '0' for x, y in zip(a, b)])\n\n", "    return\
    \ bin(int(a, 2) ^ int(b, 2))[2:]\n\n", "    assert len(a) == len(b)\n    assert\
    \ set(a).issubset(set('01'))\n    assert set(b).issubset(set('01'))\n    return\
    \ ''.join([str(int(i) ^ int(j)) for i, j in zip(a, b)])\n\n", "    return ''.join(['1'\
    \ if a[i] != b[i] else '0' for i in range(len(a))])\n\n", "    if len(a) != len(b):\n\
    \        raise ValueError(\"The two strings have different lengths\")\n    return\
    \ \"\".join(str(int(ca) ^ int(cb)) for ca, cb in zip(a, b))\n\n", "    return\
    \ ''.join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, b)))\n\n", "    return\
    \ ''.join(['1' if a[i] != b[i] else '0' for i in range(len(a))])\n\n", "    assert\
    \ len(a) == len(b)\n    c = ''\n    for i in range(len(a)):\n        if a[i] ==\
    \ b[i]:\n            c += '0'\n        else:\n            c += '1'\n    return\
    \ c\n\n", "    return bin(int(a, 2) ^ int(b, 2))[2:]\n\n", "    return ''.join(str(x\
    \ ^ y) for x, y in zip(a, b))\n\n", "    if len(a) != len(b):\n        raise RuntimeError('Length\
    \ of input strings must be equal.')\n    return ''.join(str(int(i) ^ int(j)) for\
    \ i, j in zip(a, b))\n\n", "    return ''.join(str(int(a[i]) ^ int(b[i])) for\
    \ i in range(len(a)))\n\n", "    return ''.join(str(int(c) ^ int(d)) for c, d\
    \ in zip(a, b))\n\n", "    if len(a) != len(b):\n        raise ValueError('Inputs\
    \ are not the same length.')\n    return ''.join(str(int(i) ^ int(j)) for i, j\
    \ in zip(a, b))\n\n", "    return ''.join(str(int(not(int(a[i]) and int(b[i]))\
    \ and (int(a[i]) or int(b[i])))) for i in range(len(a)))\n\n", "    return int_to_bin(bin_to_int(a)\
    \ ^ bin_to_int(b))\n\n", "    return \"\".join([str(int(a[i]) ^ int(b[i])) for\
    \ i in range(len(a))])\n\n", "    assert len(a) == len(b)\n    return \"\".join([str(int(x)\
    \ ^ int(y)) for x, y in zip(a, b)])\n\n", "    if len(a) != len(b):\n        raise\
    \ ValueError('String lengths are not equal!')\n    return ''.join(str(int(i !=\
    \ j)) for i, j in zip(a, b))\n\n", "    return b''.join(bytes(i ^ j) for i, j\
    \ in zip(a.encode(), b.encode())).decode()\n\n", "    assert len(a) == len(b)\n\
    \    xor = []\n    for i in range(len(a)):\n        xor.append(str(int(a[i]) ^\
    \ int(b[i])))\n    return ''.join(xor)\n    \n    \n", "    return ''.join(str(int(bit_a)\
    \ ^ int(bit_b)) for bit_a, bit_b in zip(a, b))\n\n", "    return bin(int(a, 2)\
    \ ^ int(b, 2))[2:]\n\n", "    s = ''\n    for i in range(len(a)):\n        s +=\
    \ '1' if a[i] != b[i] else '0'\n    return s\n\n", "    # Fill in your code here.\n\
    \    c = ''\n    for i in range(len(a)):\n        if a[i] == b[i]:\n         \
    \   c += '0'\n        else:\n            c += '1'\n    return c\n\n", "    return\
    \ \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n", "    assert\
    \ len(a) == len(b)\n    assert len(a) % 8 == 0\n    result = ''\n    for n in\
    \ range(len(a)):\n        result += str(int(a[n]) ^ int(b[n]))\n    return result\n\
    \n", "    output = ''\n    for a_char, b_char in zip(a, b):\n        a_char =\
    \ int(a_char)\n        b_char = int(b_char)\n        if a_char ^ b_char == 0:\n\
    \            output += '0'\n        else:\n            output += '1'\n    return\
    \ output\n\n", "    return \"\".join(str(bin(int(x, 2) ^ int(y, 2))[2:].zfill(len(a)))\
    \ for x, y in zip(a, b))\n\n", "    return bin(int(a, 2) ^ int(b, 2))[2:]\n\n",
  "    if len(a) != len(b):\n        raise ValueError(\"Lengths of inputs not equal.\"\
    )\n    output = ''\n    for x, y in zip(a, b):\n        if x == y:\n         \
    \   output += '0'\n        else:\n            output += '1'\n    return output\n\
    \n", "    assert len(a) == len(b)\n    ret = ''\n    for i in range(len(a)):\n\
    \        ret += str(int(a[i]) ^ int(b[i]))\n    return ret\n\n", "    n = len(a)\n\
    \    res = ''\n    for i in range(n):\n        res += str(int(a[i]) ^ int(b[i]))\n\
    \    return res\n\n", "    c = \"\"\n    for i in range(len(a)):\n        if a[i]\
    \ == b[i]:\n            c += \"0\"\n        else:\n            c += \"1\"\n  \
    \  return c\n\n", "    return ''.join(chr(ord(x) ^ ord(y)) for x, y in zip(a,\
    \ b))\n\n", "    return ''.join(str(int(i) ^ int(j)) for i, j in zip(a, b))\n",
  "    a = int(a, 2)\n    b = int(b, 2)\n    res = bin(a ^ b)\n    return res[2:]\n\
    \n", "    assert len(a) == len(b)\n    ret = list()\n    for i in range(len(a)):\n\
    \        if a[i] == b[i]:\n            ret.append('0')\n        else:\n      \
    \      ret.append('1')\n    return ''.join(ret)\n\n", "    return ''.join([str(int(a[i])\
    \ ^ int(b[i])) for i in range(min(len(a), len(b)))])\n\n", "    assert len(a)\
    \ == len(b)\n    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n\n",
  "    return \"\".join([\"1\" if x != y else \"0\" for x, y in zip(a, b)])\n\n",
  "    return ''.join([str(int(c) ^ int(d)) for c, d in zip(a, b)])\n\n", "    return\
    \ ''.join(str(int(ai) ^ int(bi)) for ai, bi in zip(a, b))\n\n", "    return ''.join(str(int(i)\
    \ ^ int(j)) for i, j in zip(a, b))\n\n", "    out = ''\n    for i in range(len(a)):\n\
    \        out += str(int(a[i]) ^ int(b[i]))\n    return out\n\n", "    return ''.join(str(int(x)\
    \ ^ int(y)) for x, y in zip(a, b))\n\n", "    xor = []\n    for i in range(0,\
    \ len(a)):\n        if (a[i] == '0' and b[i] == '0') or (a[i] == '1' and b[i]\
    \ == '1'):\n            xor.append('0')\n        else:\n            xor.append('1')\n\
    \    return ''.join(xor)\n\n", "    return ''.join(str(int(i) ^ int(j)) for i,\
    \ j in zip(a, b))\n", "    # return (''.join(chr(ord(a) ^ ord(b)) for a, b in\
    \ zip(a, b)))\n\n    return ''.join(str(int(a) ^ int(b)) for a, b in zip(a, b))\n\
    \n", "    a_int = int(a, 2)\n    b_int = int(b, 2)\n    return bin(a_int ^ b_int)[2:]\n",
  "    return ''.join(str(int(i) ^ int(j)) for i, j in zip(a, b))\n\n", "    return\
    \ ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n\n", "    return ''.join(str(int(ai)\
    \ ^ int(bi)) for ai, bi in zip(a, b))\n\n", "    # Initialize for loop\n    output\
    \ = ''\n    # Iterate over both strings\n    for i in range(len(a)):\n       \
    \ # Check if values are equal\n        if a[i] == b[i]:\n            # If so,\
    \ append 0 to output\n            output += '0'\n        else:\n            #\
    \ Otherwise, append 1 to output\n            output += '1'\n    # Return output\n\
    \    return output\n\n", "    res = []\n    for i in range(len(a)):\n        res.append(str(int(a[i])\
    \ ^ int(b[i])))\n    return ''.join(res)\n\n", "    if len(a) != len(b):\n   \
    \     raise ValueError(\"a and b must be the same length\")\n    xor = int(a,\
    \ 2) ^ int(b, 2)\n    return f\"{xor:b}\"\n\n", "    return ''.join(str(i ^ j)\
    \ for i, j in zip(map(int, a), map(int, b)))\n\n", "    # Write your code here\n\
    \    return bin(int(a, 2) ^ int(b, 2))[2:]\n\n", "    # a_binary = int(a, 2)\n\
    \    # b_binary = int(b, 2)\n    # binary_xor = a_binary ^ b_binary\n    # xor_str\
    \ = str(bin(binary_xor))[2:]\n    # return xor_str\n    return bin(int(a, 2) ^\
    \ int(b, 2))[2:]\n\n", "    return \"\".join(str(int(x) ^ int(y)) for x, y in\
    \ zip(a, b))\n\n", "    assert len(a) == len(b)\n    xored = (int(i) ^ int(j)\
    \ for i, j in zip(a, b))\n    return ''.join(str(i) for i in xored)\n\n", "  \
    \  return \"\".join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n", " \
    \   if len(a) != len(b):\n        raise ValueError('The input strings must be\
    \ of equal length.')\n    output = ''\n    for i in range(len(a)):\n        if\
    \ a[i] == b[i]:\n            output += '0'\n        else:\n            output\
    \ += '1'\n    return output\n\n", "    nums = []\n    for i in range(len(a)):\n\
    \        nums.append(a[i] ^ b[i])\n    return ''.join(nums)\n\n", "    return\
    \ ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n", "    return \"{0:b}\"\
    .format(int(a, 2) ^ int(b, 2))\n\n", "    return ''.join(str(int(a[i]) ^ int(b[i]))\
    \ for i in range(len(a)))\n\n", "    return ''.join([str(int(ai) ^ int(bi)) for\
    \ ai, bi in zip(a, b)])\n", "    return \"\".join(str(x == y) for x, y in zip(a,\
    \ b))\n\n", "    return ''.join(str(int(i) ^ int(j)) for i, j in zip(a, b))\n\n",
  "    if a == b:\n        return '0' * len(a)\n    else:\n        return '1' * len(a)\n\
    \n", "    return ''.join(str(int(ch1) ^ int(ch2)) for ch1, ch2 in zip(a, b))\n\
    \n", "    if len(a) != len(b):\n        raise ValueError(f\"Expected two strings\
    \ of equal length, \"\n                         f\"got {len(a)} and {len(b)}\"\
    )\n    return \"\".join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n",
  "    assert len(a) == len(b)\n    return ''.join(str(int(x) ^ int(y)) for x, y in\
    \ zip(a, b))\n\n", "    return ''.join(['1' if a[x] != b[x] else '0' for x in\
    \ range(len(a))])\n\n", "    res = []\n    for c1, c2 in zip(a, b):\n        res.append(str(int(c1)\
    \ ^ int(c2)))\n    return ''.join(res)\n\n", "    c = []\n    for i in range(len(a)):\n\
    \        if a[i] == b[i]:\n            c.append('0')\n        else:\n        \
    \    c.append('1')\n    return ''.join(c)\n", "    return bin(int(a, 2) ^ int(b,\
    \ 2))[2:]\n\n", "    return ''.join(str(int(i) ^ int(j)) for i, j in zip(a, b))\n\
    \n", "    return bin(int(a, 2) ^ int(b, 2))[2:]\n\n", "    return ''.join([str(int(a[i])\
    \ ^ int(b[i])) for i in range(len(a))])\n\n", "    assert len(a) == len(b)\n \
    \   return ''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))])\n\n",
  "    assert len(a) == len(b)\n    a = int(a, 2)\n    b = int(b, 2)\n    c = bin(a\
    \ ^ b)[2:]\n    return c.zfill(len(a))\n", "    # Since we are only comparing\
    \ 1's and 0's, only need one of the input to be 1,\n    # in order to get the\
    \ output to be 1\n    output = ''\n    for x, y in zip(a, b):\n        if x ==\
    \ y:\n            output += '0'\n        else:\n            output += '1'\n  \
    \  return output\n\n", "    res = []\n    for x, y in zip(a, b):\n        res.append(chr(ord(x)\
    \ ^ ord(y)))\n    return ''.join(res)\n\n", "    # convert both strings to integer\n\
    \    first_value = int(a, 2)\n    second_value = int(b, 2)\n    # use bitwise\
    \ XOR to generate result\n    result = first_value ^ second_value\n    # return\
    \ result in its binary form as a string\n    return bin(result)[2:]\n\n", "  \
    \  return ''.join(str(int(a) ^ int(b)) for a, b in zip(a, b))\n", "    # TODO\n\
    \    pass\n\n", "    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n\
    \n", "    return ''.join([str(int(i) ^ int(j)) for i, j in zip(a, b)])\n\n", " \
    \   return ''.join(str(x ^ y) for x, y in zip(a, b))\n\n", "    return ''.join(\n\
    \        '1' if i != j else '0'\n        for i, j in zip(a, b)\n    )\n\n", " \
    \   return \"\".join([\"0\" if a[i] == b[i] else \"1\" for i in range(len(a))])\n\
    \n", "    assert len(a) == len(b)\n    return \"\".join(str(x ^ y) for x, y in\
    \ zip(map(int, a), map(int, b)))\n\n", "    assert len(a) == len(b)\n\n    res\
    \ = ''\n    for i in range(len(a)):\n        res += '1' if (a[i] == '0' and b[i]\
    \ == '1') or (a[i] == '1' and b[i] == '0') else '0'\n\n    return res\n\n", " \
    \   # convert strings to ints\n    a = int(a, 2)\n    b = int(b, 2)\n    # perform\
    \ XOR\n    c = a ^ b\n    # convert result to string and return\n    return bin(c)[2:]\n\
    \n", "    a = int(a, 2)\n    b = int(b, 2)\n    return bin(a ^ b)[2:]\n\n", " \
    \   return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n\n", "    pass\n",
  "    return \"\".join([str(i ^ j) for i, j in zip(a, b)])\n\n", "    return ''.join(str(int(x)\
    \ ^ int(y)) for x, y in zip(a, b))\n\n", "    return bin(int(a, 2) ^ int(b, 2))[2:]\n",
  "    xor = []\n    for i in range(min(len(a), len(b))):\n        xor.append(str(int(a[i])\
    \ ^ int(b[i])))\n    return ''.join(xor)\n\n", "    return ''.join(str(int(x)\
    \ ^ int(y)) for x, y in zip(a, b))\n\n", "    return ''.join(str(int(i != j))\
    \ for i, j in zip(a, b))\n", "    return int_to_binary(binary_to_int(a) ^ binary_to_int(b))\n\
    \n", "    assert len(a) == len(b)\n    # Split input string into list of characters.\n\
    \    a = list(a)\n    b = list(b)\n    ret = []\n    for i in range(len(a)):\n\
    \        if a[i] == b[i]:\n            ret.append('0')\n        else:\n      \
    \      ret.append('1')\n    return ''.join(ret)\n", "    s = []\n    for i in\
    \ range(len(a)):\n        s.append(str(int(a[i]) ^ int(b[i])))\n    return ''.join(s)\n\
    \n", "    # BEGIN\n    return ''.join(str(int(n1) ^ int(n2)) for n1, n2 in zip(a,\
    \ b))\n    # END\n\n", "    return ''.join(str(int(i) ^ int(j)) for i, j in zip(a,\
    \ b))\n", "    # convert inputs to integers\n    a_i = int(a, 2)\n    b_i = int(b,\
    \ 2)\n    # TODO: find the binary XOR\n    c_i = a_i ^ b_i\n    # convert the\
    \ integer result back to a string\n    c = bin(c_i)[2:]\n    return c\n\n", " \
    \   return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n", "    return\
    \ ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n\n", "    return hex(int(a,\
    \ 2) ^ int(b, 2))[2:]\n\n", "    return ''.join(str(int(i != j)) for i, j in zip(a,\
    \ b))\n\n", "    ret = ''\n    for i in range(len(a)):\n        if a[i] == b[i]:\n\
    \            ret += '0'\n        else:\n            ret += '1'\n    return ret\n\
    \n", "    if len(a) != len(b):\n        raise Exception(\"Inputs are not equal\
    \ length.\")\n    xor = \"\"\n    for i in range(len(a)):\n        if a[i] ==\
    \ b[i]:\n            xor += \"0\"\n        else:\n            xor += \"1\"\n \
    \   return xor\n\n", "    xor = lambda x, y: '0' if x == y else '1'\n    return\
    \ ''.join(xor(l, r) for l, r in zip(a, b))\n\n", "    return format(int(a, 2)\
    \ ^ int(b, 2), 'b')\n\n", "    # could use 'int' function instead,\n    # but\
    \ this is more clear on the type of conversion\n    ax = int(a, 2)\n    bx = int(b,\
    \ 2)\n    cx = ax ^ bx\n    return bin(cx)[2:]\n\n", "    return ''.join(str(int(ai)\
    \ ^ int(bi)) for ai, bi in zip(a, b))\n\n", "    assert a.replace('0', '').replace('1',\
    \ '') == ''\n    assert b.replace('0', '').replace('1', '') == ''\n    return\
    \ ''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))])\n\n", "    return\
    \ ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n", "    return ''.join(['1'\
    \ if a[i] != b[i] else '0' for i in range(len(a))])\n\n", "    if len(a) != len(b):\n\
    \        raise ValueError(\"a and b must be of equal length\")\n    return \"\"\
    .join(str(i^j) for i, j in zip(a, b))\n\n", "    answer = []\n    for i in range(len(a)):\n\
    \        answer.append(str(int(a[i]) ^ int(b[i])))\n    return ''.join(answer)\n\
    \n", "    return ''.join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, b)))\n\
    \n", "    assert isinstance(a, str) and isinstance(b, str)\n    res = ''\n   \
    \ for c1, c2 in zip(a, b):\n        res += '1' if c1 != c2 else '0'\n    return\
    \ res\n\n", "    if len(a) != len(b):\n        raise ValueError('Inputs must be\
    \ of the same length.')\n    return ''.join([str(int(a_bit) ^ int(b_bit)) for\
    \ a_bit, b_bit in zip(a, b)])\n\n", "    return ''.join(str(int(i != j)) for i,\
    \ j in zip(a, b))\n\n", "    return ''.join(str(ord(ai) ^ ord(bi)) for ai, bi\
    \ in zip(a, b))\n\n", "    return bin(int(a, 2) ^ int(b, 2))[2:]\n\n", "    return\
    \ string_from_int(int_from_string(a) ^ int_from_string(b))\n\n", "    return ''.join([str(int(c)\
    \ ^ int(b[i])) for i, c in enumerate(a)])\n\n", "    return ''.join(str(int(x)\
    \ ^ int(y)) for x, y in zip(a, b))\n\n", "    # convert to integers\n    int_a\
    \ = int(a, 2)\n    int_b = int(b, 2)\n    xor_int = int_a ^ int_b\n    return\
    \ f'{xor_int:b}'\n", "    assert len(a) == len(b)\n    res = \"\"\n    for i in\
    \ range(len(a)):\n        if a[i] == b[i]:\n            res += \"0\"\n       \
    \ else:\n            res += \"1\"\n    return res\n\n", "    a_int = int(a, 2)\n\
    \    b_int = int(b, 2)\n    c_int = a_int ^ b_int\n    return f'{c_int:08b}'\n\
    \n", "    assert len(a) == len(b)\n    return ''.join(str(int(bit1) ^ int(bit2))\
    \ for bit1, bit2 in zip(a, b))\n\n", "    int_a = int(a, 2)\n    int_b = int(b,\
    \ 2)\n    xor_ab = int_a ^ int_b\n    return bin(xor_ab)[2:]\n", "    if len(a)\
    \ != len(b):\n        raise TypeError(\"Must be same length!\")\n    if not set(a).issubset(set('01'))\
    \ or not set(b).issubset(set('01')):\n        raise TypeError(\"Must be binary\
    \ string!\")\n    return \"\".join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n\
    \n", "    return \"\".join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, b)))\n\
    \n", "    if len(a) != len(b):\n        raise ValueError(\"Length of input strings\
    \ should be equal.\")\n    c = ''.join([str(int(x) ^ int(y)) for x, y in zip(a,\
    \ b)])\n    return c\n \n ", "    return \"\".join(str(int(a[i]) ^ int(b[i]))\
    \ for i in range(len(a)))\n", "    return ''.join(str(int(a[i]) ^ int(b[i])) for\
    \ i in range(len(a)))\n\n", "    assert len(a) == len(b)\n    return ''.join(str(int(i)\
    \ ^ int(j)) for i, j in zip(a, b))\n\n", "    return bin(int(a, 2) ^ int(b, 2))[2:]\n\
    \n", "    #assert len(a) == len(b)\n    return \"\".join(str(x ^ y) for x, y in\
    \ zip(a, b))\n", "    assert len(a) == len(b)\n    return ''.join(['1' if a[i]\
    \ != b[i] else '0' for i in range(len(a))])\n\n", "    # TODO: complete this function!\n\
    \    a = int(a, 2)\n    b = int(b, 2)\n    return bin(a ^ b)[2:]\n\n", "    return\
    \ ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n", "    return format(int(a,\
    \ 2) ^ int(b, 2), 'b')\n\n", "    return str(bin(int(a, 2) ^ int(b, 2)))[2:]\n\
    \n", "    l = zip(a, b)\n    return ''.join([str(int(i == j)) for i, j in l])\n\
    \nassert string_xor('010', '110') == '100'\n", "    # Exercise\n\n", "    return\
    \ \"\".join(\n        str(int(x) ^ int(y)) for x, y in zip(a, b)\n    )  # Parens\
    \ around int(x) ^ int(y) are not required in Python 2.\n\n", "    # Your implementation\
    \ goes here.\n    if len(a) > len(b):\n        b = b.zfill(len(a))\n    elif len(a)\
    \ < len(b):\n        a = a.zfill(len(b))\n    result = int(a, 2) ^ int(b, 2)\n\
    \    return format(result, 'b')\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
