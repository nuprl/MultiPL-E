name: HumanEval_120_maximum
language: py
prompt: "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n\
  \    \"\"\"\n    Given an array arr of integers and a positive integer k, return\
  \ a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example\
  \ 1:\n\n    >>> maximum([-3, -4, 5], 3)\n    [-4, -3, 5]\n\n    Example 2:\n\n \
  \   >>> maximum([4, -4, 4], 2)\n    [4, 4]\n\n    Example 3:\n\n    >>> maximum([-3,\
  \ 2, 1, 2, -1, -2, 1], 1)\n    [2]\n\n    Note:\n        1. The length of the array\
  \ will be in the range of [1, 1000].\n        2. The elements in the array will\
  \ be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n\
  \    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1,\
  \ 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0, 1, 2, -3], 3)\
  \ == [2, 20, 123]\n    assert candidate([-123, 20, 0, 1, 2, -3], 4) == [0, 1, 2,\
  \ 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3,\
  \ 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1,\
  \ 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert\
  \ candidate([-10, 10], 2) == [-10, 10]\n    assert candidate([1, 2, 3, -23, 243,\
  \ -400, 0], 0) == []\n\ndef test_check():\n    check(maximum)\n\ntest_check()\n"
completions: ["    if not arr:\n        return []\n    if len(arr) == 1:\n       \
    \ return arr\n    if k >= len(arr):\n        return sorted(arr, reverse=True)\n\
    \    heap = Heap(k)\n    heap.add_key(arr[0])\n    for i in range(1, len(arr)):\n\
    \        if arr[i] > heap.peek():\n            heap.pop()\n            heap.add_key(arr[i])\n\
    \    return sorted(heap.heap, reverse=True)\n", "    heap = []\n    for x in arr:\n\
    \        heapq.heappush(heap, x)\n        if len(heap) > k:\n            heapq.heappop(heap)\n\
    \    return sorted(heap, reverse=True)\n", "    # solve problem using a max heap\n\
    \    # a max heap is a binary tree that has the largest element as the root node,\n\
    \    # and each child of the node is smaller than the parent\n    # an easy way\
    \ to visualize this is by thinking of a family tree where the \n    # oldest person\
    \ is at the root node\n    max_heap = MaxHeap()\n    for num in arr:\n       \
    \ max_heap.insert(num)\n    \n    result = []\n    for _ in range(k):\n      \
    \  result.append(max_heap.pop())\n    return result\n\n", "    def get_max(arr:\
    \ List[int], k: int) -> List[int]:\n        \"\"\"\n        Returns the maximum\
    \ k numbers in the given array\n        \"\"\"\n        if k == 0:\n         \
    \   return []\n        elif k == 1:\n            return [max(arr)]\n        else:\n\
    \            max_num = max(arr)\n            arr.remove(max_num)\n           \
    \ return [max_num] + get_max(arr, k - 1)\n\n    return sorted(get_max(arr, k))\n",
  "    return sorted(arr, reverse=True)[:k]\n", "    return sorted(arr, reverse=True)[:k]\n",
  "    if not arr:\n        return []\n    elif len(arr) == 1:\n        return arr\n\
    \    # convert the list to a heap\n    heapq.heapify(arr)\n    # remove k-1 items\
    \ from the heap\n    for _ in range(k-1):\n        heapq.heappop(arr)\n    # return\
    \ the sorted list of maxes\n    return sorted(arr, reverse=True)\n", "    return\
    \ sorted(arr, reverse=True)[:k]\n", "    return sorted(arr, reverse=True)[:k]\n",
  "    heap = []\n    minheap = Heap(heap, min)\n    for n in arr:\n        if len(heap)\
    \ < k:\n            minheap.insert(n)\n        elif n > heap[0]:\n           \
    \ minheap.pop()\n            minheap.insert(n)\n    return sorted(heap, reverse=True)",
  "    if k == 0:\n        return []\n    if k == len(arr):\n        return sorted(arr)\n\
    \    heap = []\n    heapq.heapify(heap)\n    # min heap\n    for i in range(k):\n\
    \        heapq.heappush(heap, -arr[i])\n    for i in range(k, len(arr)):\n   \
    \     if -arr[i] > heap[0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap,\
    \ -arr[i])\n    return sorted([-x for x in heap])", "    max_nums = sorted(arr,\
    \ reverse=True)[:k]\n    return max_nums\n", "    k_element = arr[:k]\n    for\
    \ idx in range(k, len(arr)):\n        for j in range(k):\n            if arr[idx]\
    \ > k_element[j]:\n                k_element[j] = arr[idx]\n                break\n\
    \    return sorted(k_element)\n", "    if k == 0:\n        return []\n    elif\
    \ k == len(arr):\n        return sorted(arr)\n    else:\n        max_val = max(arr)\n\
    \        max_idx = arr.index(max_val)\n        return [max_val] + maximum(arr[:max_idx]\
    \ + arr[max_idx+1:], k-1)", "    arr.sort()\n    return arr[-k:]\n", "    heap\
    \ = []\n    for i in range(k):\n        heapq.heappush(heap, arr[i])\n    for\
    \ i in range(k, len(arr)):\n        heapq.heappushpop(heap, arr[i])\n    return\
    \ heapq.nlargest(k, heap)\n", "    arr.sort()\n    return arr[-k:]\n\n", "   \
    \ max_heap = []\n    for el in arr:\n        heapq.heappush(max_heap, -el)\n \
    \       if len(max_heap) > k:\n            heapq.heappop(max_heap)\n    return\
    \ [-el for el in heapq.nlargest(k, max_heap)]\n", "    res = []\n    for i in\
    \ range(k):\n        max_val = -float('inf')\n        idx = -1\n        for j\
    \ in range(len(arr)):\n            if arr[j] > max_val:\n                max_val\
    \ = arr[j]\n                idx = j\n        res.append(max_val)\n        arr.pop(idx)\n\
    \    return res\n", "    arr.sort()\n    return arr[len(arr)-k:]\n", "    heap\
    \ = []\n    heapq.heapify(heap)\n    for x in arr:\n        heapq.heappush(heap,\
    \ -x)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return\
    \ [-x for x in heap]", "    _max = arr[0]\n    _max_indices = [0]\n    for i in\
    \ range(1, len(arr)):\n        if arr[i] > _max:\n            _max = arr[i]\n\
    \            _max_indices = [i]\n        elif arr[i] == _max:\n            _max_indices.append(i)\n\
    \    sorted_arr = []\n    i = 1\n    while i <= k:\n        _max = arr[0]\n  \
    \      _max_indices = [0]\n        for i in range(1, len(arr)):\n            if\
    \ arr[i] > _max:\n                _max = arr[i]\n                _max_indices\
    \ = [i]\n            elif arr[i] == _max:\n                _max_indices.append(i)\n\
    \        for j in _max_indices:\n            sorted_arr.append(arr[j])\n     \
    \       arr[j] = -float('inf')\n            i += 1\n    return sorted_arr\n",
  "    arr = sorted(arr, reverse=True)\n    return arr[:k]", "    if not arr:\n  \
    \      return []\n    if len(arr) <= k:\n        return sorted(arr, reverse=True)\n\
    \    return sorted(arr)[-k:]\n\n", "    # O(n log n) time | O(k) space\n    #\
    \ return sorted(arr, reverse=True)[:k]\n\n    # O(n log k) time | O(k) space\n\
    \    heap = []\n    for num in arr:\n        heapq.heappush(heap, num)\n     \
    \   if len(heap) > k:\n            heapq.heappop(heap)\n    return sorted(heap,\
    \ reverse=True)\n", "    if k == 0:\n        return []\n    return sorted(arr,\
    \ reverse=True)[:k]\n", "    arr.sort()\n    return arr[-k:]\n", "    if k ==\
    \ 0:\n        return []\n    if k == len(arr):\n        return sorted(arr)\n \
    \   arr.sort()\n    return arr[-k:]\n", '    return sorted(arr, reverse=True)[:k]',
  "    # Sort and return last k numbers\n    return sorted(arr)[-k:]\n\n", "    max_queue\
    \ = deque()\n    for i in range(k):\n        while max_queue and arr[i] > arr[max_queue[-1]]:\n\
    \            max_queue.pop()\n        max_queue.append(i)\n    for i in range(k,\
    \ len(arr)):\n        print(arr[max_queue[0]])\n        while max_queue and max_queue[0]\
    \ <= i - k:\n            max_queue.popleft()\n        while max_queue and arr[i]\
    \ > arr[max_queue[-1]]:\n            max_queue.pop()\n        max_queue.append(i)\n\
    \    print(arr[max_queue[0]])\n    return [arr[i] for i in max_queue]\n", "  \
    \  heap = []\n    for i in range(k):\n        heapq.heappush(heap, -arr[i])\n\
    \    for i in range(k, len(arr)):\n        if -arr[i] > heap[0]:\n           \
    \ heapq.heappop(heap)\n            heapq.heappush(heap, -arr[i])\n    return [-x\
    \ for x in heap]", "    arr.sort()\n    return arr[len(arr)-k:]\n\n", "    heapq.heapify(arr)\n\
    \    ans = []\n    for _ in range(k):\n        ans.append(heapq.heappop(arr))\n\
    \    return ans\n", "    heap = []\n    heapq.heapify(heap)\n    for num in arr:\n\
    \        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n\
    \    return sorted(heap, reverse=True)", "    out = sorted(arr, reverse=True)[:k]\n\
    \    return out\n", "    return sorted(arr, reverse=True)[:k]\n", "    heapq.heapify(arr)\n\
    \    top_k = heapq.nlargest(k, arr)\n    top_k.sort()\n    return top_k", "  \
    \  for i in range(k):\n        for j in range(len(arr) - i - 1):\n           \
    \ if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n\
    \    \n    return arr[:k]", '    return sorted(arr, reverse=True)[:k]', "    heap\
    \ = arr[:k]\n    heapq.heapify(heap)\n    for i in range(k, len(arr)):\n     \
    \   if arr[i] > heap[0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap,\
    \ arr[i])\n    return heapq.nlargest(k, heap)", "    heap = []\n    for num in\
    \ arr:\n        heapq.heappush(heap, (-num, num))\n    return [x[1] for x in heapq.nsmallest(k,\
    \ heap)]\n", "    if k == 0:\n        return []\n    elif k == len(arr):\n   \
    \     return sorted(arr)\n    else:\n        arr.sort()\n        return arr[-k:]\n",
  "    heap = []\n    for el in arr:\n        heapq.heappush(heap, -el)\n    return\
    \ [-heapq.heappop(heap) for _ in range(k)]\n", "    arr.sort()\n    return arr[len(arr)-k:]\n\
    \n", "    return list(sorted(arr, reverse=True)[:k])\n", "    return sorted(arr,\
    \ reverse=True)[:k]\n", "    def partition(left: int, right: int) -> int:\n  \
    \      pivot = arr[left]\n        i = left\n        j = right\n\n        while\
    \ i < j:\n            while i < j and arr[j] <= pivot:\n                j -= 1\n\
    \            while i < j and arr[i] >= pivot:\n                i += 1\n      \
    \      if i < j:\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[left],\
    \ arr[i] = arr[i], arr[left]\n        return i\n\n    left = 0\n    right = len(arr)\
    \ - 1\n    while left <= right:\n        mid = partition(left, right)\n      \
    \  if mid == k - 1:\n            break\n        elif mid < k - 1:\n          \
    \  left = mid + 1\n        else:\n            right = mid - 1\n    return arr[:k]\n",
  "    arr.sort()\n    return arr[-k:]\n", "    return sorted(arr, reverse=True)[:k]\n",
  "    return sorted(arr, reverse=True)[:k]\n", "    # heap method\n    if k == len(arr):\n\
    \        return arr\n    heap = []\n    for i in range(k):\n        heapq.heappush(heap,\
    \ arr[i])\n    for j in range(k, len(arr)):\n        if arr[j] > heap[0]:\n  \
    \          heapq.heappop(heap)\n            heapq.heappush(heap, arr[j])\n   \
    \ return heap\n\n", "    arr.sort()\n    return arr[-k:]\n", "    # Base case\n\
    \    if k == 1:\n        return [max(arr)]\n    else:\n        return maximum(arr[:len(arr)\
    \ - 1], k - 1) + [max(arr[len(arr) - k:])]\n", "    if k == 0:\n        return\
    \ []\n    return sorted(arr, reverse=True)[:k]", '    return sorted(arr, reverse=True)[:k]',
  "    max_list = []\n    for _ in range(k):\n        max_list.append(max(arr))\n\
    \        arr.remove(max(arr))\n    return max_list\n", "    res = arr[:k]\n  \
    \  heapq.heapify(res)\n    for n in arr[k:]:\n        heapq.heappushpop(res, n)\n\
    \    return sorted(res, reverse=True)\n", "    arr.sort()\n    arr = arr[-k:]\n\
    \    return arr\n", "    return sorted(arr, reverse=True)[:k]\n", "    for i in\
    \ range(k):\n        for j in range(len(arr) - i - 1):\n            if arr[j]\
    \ > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n   \
    \ return arr[len(arr) - k:]\n", "    temp = []\n    res = []\n    for i in range(len(arr)):\n\
    \        if len(temp) > 0:\n            while temp and temp[-1] < arr[i]:\n  \
    \              temp.pop()\n        temp.append(arr[i])\n    while len(res) < k:\n\
    \        res.append(temp.pop())\n    return res[::-1]\n", "    if not arr:\n \
    \       return []\n    return sorted(arr, reverse=True)[:k]\n", '    return sorted(arr,
    reverse=True)[:k]', '    return sorted(arr, reverse=True)[:k]', "    return sorted(arr,\
    \ reverse=True)[:k]\n", "    heap = [-i for i in arr[:k]]\n    heapq.heapify(heap)\n\
    \    for i in range(k, len(arr)):\n        if -heap[0] < arr[i]:\n           \
    \ heapq.heappop(heap)\n            heapq.heappush(heap, -arr[i])\n    return [-i\
    \ for i in heap]\n", '    return sorted(arr, reverse=True)[:k]', "    return sorted(arr,\
    \ reverse=True)[:k]\n", "    heap = Heap(arr, k)\n    return heap.sort()\n", " \
    \   max_heap = arr[:k]\n    heapq.heapify(max_heap)\n    for i in range(k, len(arr)):\n\
    \        if arr[i] > max_heap[0]:\n            heapq.heappop(max_heap)\n     \
    \       heapq.heappush(max_heap, arr[i])\n    return list(sorted(max_heap, reverse=True))\n",
  "    if k == len(arr):\n        return sorted(arr)\n    largest = list()\n    for\
    \ x in range(k):\n        largest.append(max(arr))\n        arr.remove(max(arr))\n\
    \    return sorted(largest)", "    arr.sort()\n    return arr[-k:]\n\n", "   \
    \ max_heap = [-float('inf')]\n    for elem in arr:\n        if elem > max_heap[0]:\n\
    \            heappush(max_heap, elem)\n            if len(max_heap) > k:\n   \
    \             heappop(max_heap)\n    return sorted(max_heap, reverse=True)\n",
  "    # Naive way: sort and get the first k\n    # return sorted(arr)[-k:]\n\n  \
    \  heap = []\n    res = []\n\n    for num in arr:\n        heapq.heappush(heap,\
    \ num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n\n    while\
    \ heap:\n        res.append(heapq.heappop(heap))\n\n    return res[::-1]\n", " \
    \   res = []\n    for num in arr:\n        if len(res) == k:\n            while\
    \ len(res) > 0 and res[-1] < num:\n                res.pop()\n            if len(res)\
    \ < k:\n                res.append(num)\n        else:\n            res.append(num)\n\
    \    return res\n\n", "    # heapq.nlargest(k, arr)\n    return sorted(arr, reverse=True)[:k]\n\
    \n", "    if k <= 0:\n        return []\n    return sorted(arr, reverse=True)[:k]\n",
  "    # Heap is a priority queue, in this case we want to keep the max values at\
    \ the\n    # top and pop them off first\n    # we keep the heap size to k so if\
    \ a value is added, we pop the top and add it\n    # if the new value is larger\n\
    \    heap = []\n    heapq.heapify(heap)\n    for n in arr:\n        if len(heap)\
    \ == k:\n            if n > heap[0]:\n                heapq.heappop(heap)\n  \
    \              heapq.heappush(heap, n)\n        else:\n            heapq.heappush(heap,\
    \ n)\n    return sorted(heap, reverse=True)\n", "    if k == len(arr):\n     \
    \   return sorted(arr)\n    if k == 1:\n        return [max(arr)]\n    max_stack\
    \ = []\n    max_num = -1001\n    for i in range(k):\n        if arr[i] > max_num:\n\
    \            max_num = arr[i]\n        max_stack.append(max_num)\n    for j in\
    \ range(k, len(arr)):\n        if arr[j] > max_stack[-1]:\n            max_stack.append(arr[j])\n\
    \            max_stack.pop(0)\n        else:\n            max_stack.append(max_stack[-1])\n\
    \            max_stack.pop(0)\n    return max_stack\n", '    return sorted(arr,
    reverse=True)[:k]', "    heap = []\n    for i in range(len(arr)):\n        if\
    \ i < k:\n            heapq.heappush(heap, arr[i])\n        else:\n          \
    \  if arr[i] > heap[0]:\n                heapq.heappop(heap)\n               \
    \ heapq.heappush(heap, arr[i])\n    return heapq.nlargest(k, heap)\n", "    if\
    \ k == 0:\n        return []\n    res = []\n    for i in range(k):\n        res.append(max(arr))\n\
    \        arr.remove(max(arr))\n    return res\n", "    res = [0] * k\n    i =\
    \ 0\n    while k > 0:\n        while k > 0 and i < len(arr):\n            res[k-1]\
    \ = max(res[k-1], arr[i])\n            i += 1\n            k -= 1\n        i =\
    \ 0\n        k = k + 1\n    return res\n", "    if k == 0:\n        return []\n\
    \    if k >= len(arr):\n        return sorted(arr)\n    if len(arr) == 1:\n  \
    \      return arr\n\n    pos_neg = False\n    if arr[0] < 0:\n        pos_neg\
    \ = True\n    return sorted(arr, reverse=pos_neg)[:k]\n", "    arr.sort()\n  \
    \  return arr[-k:]\n", "    max_vals = []\n    for _ in range(k):\n        max_val\
    \ = max(arr)\n        max_vals.append(max_val)\n        arr.remove(max_val)\n\
    \    return max_vals\n\n", "    return sorted(arr, reverse=True)[:k]\n", "   \
    \ sorted_arr = sorted(arr)\n    return sorted_arr[-k:]\n", "    sorted_arr = sorted(arr)\n\
    \    return sorted_arr[len(arr) - k:]", "    heap = Heap(arr, k)\n    heap.build_heap()\n\
    \    for idx in range(k, len(arr)):\n        heap.heapify(idx)\n    return heap.get_max_k()\n\
    \n", "    arr.sort()\n    return arr[len(arr)-k:]\n", "    if k > len(arr):\n\
    \        return arr\n    else:\n        return sorted(arr, reverse=True)[:k]\n",
  "    max_heap = []\n    for num in arr:\n        heapq.heappush(max_heap, (-num,\
    \ num))\n    output = []\n    for _ in range(k):\n        output.append(heapq.heappop(max_heap)[1])\n\
    \    return output\n", "    arr.sort()\n    return arr[len(arr)-k:]\n", "    if\
    \ not arr:\n        return []\n    heap = arr[:k]\n    heapq.heapify(heap)\n \
    \   for i in range(k, len(arr)):\n        if arr[i] > heap[0]:\n            heapq.heappop(heap)\n\
    \            heapq.heappush(heap, arr[i])\n    return heapq.nlargest(k, heap)",
  "    largest = heapq.nlargest(k, arr)\n    return sorted(largest)\n", '    return
    sorted(arr, reverse=True)[:k]', "    if not arr:\n        return []\n    # minheap\
    \ of size k\n    heap = []\n    for i in range(k):\n        heappush(heap, arr[i])\n\
    \    for i in range(k, len(arr)):\n        heappushpop(heap, arr[i])\n    return\
    \ sorted(heap, reverse=True)\n", "    mx = arr[:k]\n    mx.sort()\n    for i in\
    \ range(k, len(arr)):\n        if arr[i] > mx[0]:\n            mx[0] = arr[i]\n\
    \            mx.sort()\n    return mx\n", "    return sorted(arr, reverse=True)[:k]\n",
  "    maxs = sorted(arr)[::-1][:k]\n    maxs.sort()\n    return maxs\n", "    return\
    \ sorted(arr, reverse=True)[:k]\n", "    arr.sort()\n    return arr[-k:]\n", " \
    \   sorted_arr = sorted(arr)\n    if k == 0:\n        return []\n    return sorted_arr[::-1][:k]",
  "    from heapq import nlargest\n    return nlargest(k, arr)\n", "    result = heapq.nlargest(k,\
    \ arr)\n    return result\n\n", "    # return sorted(arr, reverse=True)[:k]\n\
    \    return sorted(arr, reverse=True)[:k] if len(arr) >= k else sorted(arr, reverse=True)\n",
  "    return sorted(arr, reverse=True)[:k]\n", '    return sorted(arr, reverse=True)[:k]',
  "    if k == 0:\n        return []\n    elif k == len(arr):\n        return sorted(arr)\n\
    \    else:\n        seen = set()\n        while len(seen) < k:\n            seen.add(max(arr))\n\
    \            arr.remove(max(arr))\n        return sorted(seen)\n", "    import\
    \ heapq\n    return heapq.nlargest(k, arr)\n", "    pass\n", "    if k == 0:\n\
    \        return []\n    elif k >= len(arr):\n        return sorted(arr)\n    else:\n\
    \        return sorted(arr)[-k:]\n", "    k_max = sorted(arr, reverse=True)[:k]\n\
    \    return k_max\n", "    max_nums = []\n    for i in range(k):\n        max_num\
    \ = max(arr)\n        max_nums.append(max_num)\n        arr.remove(max_num)\n\
    \    return max_nums\n\n", "    arr.sort()\n    arr.reverse()\n    return arr[:k]\n",
  "    count = len(arr) - k\n    q = []\n    for i in range(count):\n        heapq.heappush(q,\
    \ -heapq.heappop(arr))\n    return [-x for x in q]\n", "    if k == 0:\n     \
    \   return []\n    elif k == len(arr):\n        return sorted(arr)\n    else:\n\
    \        max_nums = sorted(arr)[-k:]\n        return sorted(max_nums)\n", "  \
    \  arr = [x for x in arr if x > 0]\n    return sorted(arr)[-k:]\n", "    arr.sort()\n\
    \    return arr[-k:]\n", "    arr.sort()\n    return arr[len(arr)-k:]\n\n", " \
    \   max_nums = sorted(arr)[-k:]\n    return max_nums\n", "    length = len(arr)\n\
    \    if length <= k:\n        return sorted(arr)\n    return sorted(arr, reverse=True)[:k]",
  "    maximums = sorted(arr)[-k:]\n    return maximums\n", "    return sorted(arr,\
    \ reverse=True)[:k]\n", "    if k == 0:\n        return []\n    return sorted(arr,\
    \ reverse=True)[:k]\n", "    return sorted(arr, reverse=True)[:k]\n", "    # Time\
    \ complexity: O(n log k)\n    # Space complexity: O(k)\n    queue = []\n    for\
    \ i in range(len(arr)):\n        heappush(queue, (-arr[i], arr[i]))\n        if\
    \ len(queue) > k:\n            heappop(queue)\n    res = []\n    while queue:\n\
    \        _, num = heappop(queue)\n        res.append(num)\n    return res[::-1]\n",
  "    arr.sort()\n    return arr[-k:]\n", "    arr.sort()\n    return arr[-k:]\n",
  "    # TC: O(nlogk), SC: O(k)\n    heap = []\n    for num in arr:\n        if len(heap)\
    \ < k:\n            heapq.heappush(heap, num)\n        else:\n            if num\
    \ > heap[0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap,\
    \ num)\n    return sorted(heap, reverse=True)\n", "    if not arr:\n        return\
    \ []\n    if len(arr) == 1:\n        return arr\n\n    k = min(k, len(arr))\n\
    \    max_heap = [-float('inf')] * k\n    heapq.heapify(max_heap)\n\n    for num\
    \ in arr:\n        if num > max_heap[0]:\n            heapq.heappop(max_heap)\n\
    \            heapq.heappush(max_heap, num)\n\n    return sorted(max_heap, reverse=True)\n\
    \n", "    # if k is less than or equal to half the length of the array, we can\
    \ simply\n    # return the first k smallest items. Otherwise, we can return the\
    \ last k \n    # items in the sorted array.\n    if k <= len(arr) // 2:\n    \
    \    return sorted(arr)[:k]\n    else:\n        return sorted(arr)[-k:]\n", " \
    \   arr.sort()\n    return arr[-k:]\n", '    return sorted(arr, reverse=True)[:k]',
  "    return sorted(arr, reverse=True)[:k]\n", "    def get_min_max(arr: List[int])\
    \ -> int:\n        min_val = max_val = arr[0]\n        for num in arr:\n     \
    \       if num < min_val:\n                min_val = num\n            if num >\
    \ max_val:\n                max_val = num\n        return min_val, max_val\n\n\
    \    def in_range(val: int, min_val: int, max_val: int) -> bool:\n        return\
    \ min_val <= val <= max_val\n\n    if not arr:\n        return []\n    min_val,\
    \ max_val = get_min_max(arr)\n    bucket_size = (max_val - min_val) // k\n   \
    \ count = [[] for _ in range(k)]\n    for num in arr:\n        bucket_index =\
    \ (num - min_val) // bucket_size\n        if bucket_index == k:\n            bucket_index\
    \ -= 1\n        count[bucket_index].append(num)\n    result = []\n    for bucket\
    \ in count:\n        if not bucket:\n            continue\n        bucket_min_val,\
    \ bucket_max_val = get_min_max(bucket)\n        if in_range(bucket_min_val, min_val,\
    \ max_val):\n            result.append(bucket_min_val)\n        if in_range(bucket_max_val,\
    \ min_val, max_val):\n            result.append(bucket_max_val)\n    return result[:k]\n",
  "    if not arr:\n        return []\n    if len(arr) == 1:\n        return arr\n\
    \    if k == 1:\n        return [max(arr)]\n    output = []\n    for _ in range(k):\n\
    \        m = max(arr)\n        output.append(m)\n        arr.remove(m)\n    return\
    \ output", "    from heapq import heappush, heappop\n    heap = []\n    for n\
    \ in arr:\n        heappush(heap, -n)\n        if len(heap) > k:\n           \
    \ heappop(heap)\n    return [-n for n in heap]\n", "    arr = sorted(arr)\n  \
    \  return arr[len(arr)-k:]\n", "    max_values = heapq.nlargest(k, arr)\n    return\
    \ sorted(max_values)\n", "    q = []\n    result = []\n    for i in range(len(arr)):\n\
    \        if len(q) < k:\n            heapq.heappush(q, arr[i])\n        else:\n\
    \            if arr[i] > q[0]:\n                heapq.heappop(q)\n           \
    \     heapq.heappush(q, arr[i])\n        result.append(q[0])\n    return result[k-1:]\n",
  "    arr.sort()\n    return arr[-k:]\n\n", "    return sorted(arr, reverse=True)[:k]\n",
  "    heap = []\n    for num in arr:\n        heapq.heappush(heap, (-num, num))\n\
    \    res = []\n    for _ in range(k):\n        res.append(heapq.heappop(heap)[1])\n\
    \    return res\n", "    max_k = sorted(arr, reverse=True)[:k]\n    return max_k\n\
    \n", "    # SOLUTION 1: using max heap\n\n    from heapq import heappush, heappop\n\
    \    max_heap = []\n\n    for i in range(k):\n        heappush(max_heap, (-arr[i],\
    \ arr[i]))\n\n    for i in range(k, len(arr)):\n        if arr[i] > max_heap[0][1]:\n\
    \            heappop(max_heap)\n            heappush(max_heap, (-arr[i], arr[i]))\n\
    \n    return [item[1] for item in max_heap]\n\n    # SOLUTION 2: using sorted\
    \ list\n\n    # arr.sort(reverse=True)\n    # return arr[:k]\n\n    # SOLUTION\
    \ 3: using selection algorithm\n\n    def select(arr, k):\n        if len(arr)\
    \ == 1:\n            return arr[0]\n\n        pivot = arr[0]\n        left, right\
    \ = [], []\n\n        for i in range(1, len(arr)):\n            if arr[i] < pivot:\n\
    \                left.append(arr[i])\n            else:\n                right.append(arr[i])\n\
    \n        if len(left) == k - 1:\n            return pivot\n        elif len(left)\
    \ > k - 1:\n            return select(left, k)\n        else:\n            return\
    \ select(right, k - len(left) - 1)\n\n    res = []\n    for i in range(k):\n \
    \       res.append(select(arr, k - i))\n        arr.remove(res[-1])\n\n    return\
    \ res\n", "    # Python's Timsort is way faster than my implementation for \n\
    \    # this problem.\n    arr.sort()\n    return arr[len(arr) - k:]\n\n", "  \
    \  start = 0\n    end = k\n    ans = []\n    while start < len(arr):\n       \
    \ temp = arr[start:end]\n        temp.sort()\n        ans.append(temp[-1])\n \
    \       start += 1\n        end += 1\n    return ans\n", "    return sorted(arr,\
    \ reverse=True)[:k]\n", "    k = min(k, len(arr))\n    if k == 0:\n        return\
    \ []\n    heapq.heapify(arr)\n    return heapq.nlargest(k, arr)", "    arr.sort()\n\
    \    return arr[-k:]\n", "    # Base case: If K is 1, return max of array\n  \
    \  if k == 1:\n        return [max(arr)]\n    # Recursively call maximum function\
    \ with new k value\n    # Append maximum value from recursive call with existing\
    \ maximum value\n    # Return sorted array\n    return [max(arr)] + maximum([x\
    \ for x in arr if x != max(arr)], k - 1)\n", "    arr.sort()\n    return arr[-k:]\n\
    \n", "    res = [float('-inf')] * k\n    for num in arr:\n        i = 0\n    \
    \    while i < k:\n            if num > res[i]:\n                res.insert(i,\
    \ num)\n                break\n            i += 1\n        res = res[:k]\n   \
    \ return res\n", "    # Time complexity: O(n logn)\n    # Space complexity: O(n)\n\
    \    arr.sort()\n    return arr[-k:]\n", "    arr.sort()\n    return arr[::-1][:k]\n",
  "    return sorted(arr, reverse=True)[:k]\n", "    return sorted(arr, reverse=True)[:k]\n",
  "    nums = [num for num in arr]\n    nums.sort()\n    return nums[-k:]\n", "  \
    \  max_heap = []\n    for i in range(k):\n        heapq.heappush(max_heap, arr[i])\n\
    \    for j in range(k, len(arr)):\n        if arr[j] > max_heap[0]:\n        \
    \    heapq.heappop(max_heap)\n            heapq.heappush(max_heap, arr[j])\n \
    \   return max_heap\n", "    n = len(arr)\n    if n == k:\n        return arr\n\
    \    max_heap = []\n    heapq.heapify(max_heap)\n    result = []\n    for el in\
    \ arr:\n        heapq.heappush(max_heap, (-el, el))\n    for _ in range(k):\n\
    \        result.append(heapq.heappop(max_heap)[1])\n    return result\n", '    return
    sorted(arr, reverse=True)[:k]', "    temp = []\n    for num in arr:\n        if\
    \ not temp:\n            temp.append(num)\n        else:\n            for i in\
    \ range(len(temp)):\n                if num > temp[i]:\n                    temp.insert(i,\
    \ num)\n                    break\n                elif i == len(temp) - 1:\n\
    \                    temp.append(num)\n    if len(temp) < k:\n        return temp\n\
    \    else:\n        return temp[:k]\n", "    # Create a new list from the max\
    \ k elements\n    return sorted(heapq.nlargest(k, arr))\n\n", "    # bubble sort\n\
    \    for i in range(len(arr)):\n        for j in range(len(arr) - 1):\n      \
    \      if arr[j] < arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1],\
    \ arr[j]\n    \n    return arr[:k]\n", "    n = len(arr)\n    k = min(k, n)\n\
    \    ind = heapq.nlargest(k, range(n), arr.__getitem__)\n    return [arr[i] for\
    \ i in ind]", "    k_heap = []\n    for num in arr:\n        if len(k_heap) <\
    \ k:\n            heapq.heappush(k_heap, num)\n        else:\n            if num\
    \ > k_heap[0]:\n                heapq.heappop(k_heap)\n                heapq.heappush(k_heap,\
    \ num)\n    return sorted(k_heap, reverse=True)\n", "    arr.sort()\n    return\
    \ arr[-k:]\n", "    if not arr:\n        return []\n    res = arr[:k]\n    for\
    \ i in range(k, len(arr)):\n        for j in range(k):\n            if arr[i]\
    \ >= res[j]:\n                res.insert(j, arr[i])\n                res.pop()\n\
    \                break\n    return res", '    return sorted(arr, reverse=True)[:k]',
  "    queue = []\n    for elem in arr:\n        if len(queue) < k:\n            queue.append(elem)\n\
    \        else:\n            if elem > queue[0]:\n                heapq.heappushpop(queue,\
    \ elem)\n    return sorted(queue, reverse=True)\n", "    if not arr:\n       \
    \ return []\n    arr.sort()\n    return arr[-k:]\n\n", '    return sorted(arr,
    reverse=True)[:k]', "    return sorted(arr, reverse=True)[:k]\n", "    pass\n",
  "    if k == 0:\n        return []\n    if k == len(arr):\n        return sorted(arr)\n\
    \    if k > len(arr):\n        raise ValueError(\"The array is shorter than k\"\
    )\n    elif k == 1:\n        return [max(arr)]\n    else:\n        return sorted(arr)[-k:]\n",
  "    if k == len(arr):\n        return sorted(arr)\n    pq = []\n    for el in arr:\n\
    \        if len(pq) == k:\n            heapq.heappushpop(pq, el)\n        else:\n\
    \            heapq.heappush(pq, el)\n    return sorted(pq, reverse=True)\n", '    return
    sorted(arr, reverse=True)[:k]', "    n = len(arr)\n    idx = [i for i in range(n)]\n\
    \    for i in range(k):\n        # Find max and move to index i\n        idx_max\
    \ = 0\n        for j in range(1, n-i):\n            if arr[idx[j]] > arr[idx[idx_max]]:\n\
    \                idx_max = j\n        idx[idx_max], idx[n-i-1] = idx[n-i-1], idx[idx_max]\n\
    \    return [arr[i] for i in idx[n-k:]]\n", "    temp = []\n    while k > 0:\n\
    \        max_num = arr[0]\n        for n in arr:\n            if n > max_num:\n\
    \                max_num = n\n        temp.append(max_num)\n        arr.remove(max_num)\n\
    \        k -= 1\n    return temp\n", "    # Sort the array\n    arr.sort()\n \
    \   # Return k elements from the last\n    return arr[len(arr) - k:]\n", "   \
    \ # O(n log n)\n    # arr.sort(reverse=True)\n    # return arr[:k]\n\n    # O(n\
    \ log k)\n    heap = [-float('inf')] * k\n    heapq.heapify(heap)\n    for num\
    \ in arr:\n        if num > heap[0]:\n            heapq.heappop(heap)\n      \
    \      heapq.heappush(heap, num)\n    return [-x for x in heap]\n\n", "    if\
    \ k >= len(arr):\n        return sorted(arr)\n    if k == 0:\n        return []\n\
    \    min_heap = []\n    for num in arr:\n        if len(min_heap) < k:\n     \
    \       heapq.heappush(min_heap, (-num, num))\n        else:\n            curr_max\
    \ = min_heap[0][1]\n            if num > curr_max:\n                heapq.heappop(min_heap)\n\
    \                heapq.heappush(min_heap, (-num, num))\n    res = [n for _, n\
    \ in min_heap]\n    return sorted(res)", "    arr.sort()\n    return arr[-k:]\n",
  "    return sorted(arr, reverse=True)[:k]\n", "    max_heap = Heap(k)\n    for el\
    \ in arr:\n        max_heap.add(el)\n    return max_heap.heap\n\n", "    results\
    \ = []\n    for i in range(len(arr)):\n        while results and k - len(results)\
    \ <= len(arr) - i and results[-1] < arr[i]:\n            results.pop()\n     \
    \   if len(results) < k:\n            results.append(arr[i])\n    return results\n",
  "    from heapq import heappush, heappop\n    heap = []\n    for n in arr:\n   \
    \     heappush(heap, -n)\n    return [-heappop(heap) for _ in range(k)]\n", " \
    \   if k == 0:\n        return []\n    elif k >= len(arr):\n        return sorted(arr)\n\
    \    else:\n        heap = []\n        for i in range(k):\n            heapq.heappush(heap,\
    \ arr[i])\n        for i in range(k, len(arr)):\n            if arr[i] > heap[0]:\n\
    \                heapq.heappop(heap)\n                heapq.heappush(heap, arr[i])\n\
    \        return sorted(heap)\n", "    if k == len(arr):\n        return sorted(arr)\n\
    \    if k == 1:\n        return [max(arr)]\n    return [arr[i] for i in range(len(arr))\
    \ if arr[i] >= max(arr[i+1:i+k])]\n\n", "    heap = Heap(mode='max')\n    for\
    \ num in arr:\n        heap.insert(num)\n        if len(heap) > k:\n         \
    \   heap.delete()\n    return sorted(heap.data, reverse=True)\n\n", "    arr.sort()\n\
    \    return arr[-k:]\n\n", "    ans = []\n    for _ in range(k):\n        max_val\
    \ = max(arr)\n        ans.append(max_val)\n        arr.remove(max_val)\n    return\
    \ ans\n", "    # Sort the array, and then slice it to the length of k.\n    #\
    \ The slicing operation is fast because of the O(n log n) time complexity\n  \
    \  # of sorting. It is O(n) time complexity, with O(n log n) space complexity.\n\
    \    arr.sort()\n    return arr[-k:]\n", "    # return sorted(arr, reverse=True)[:k]\n\
    \    if k >= len(arr):\n        return sorted(arr, reverse=True)\n    min_heap\
    \ = [float('inf')] * k\n    heapq.heapify(min_heap)\n    for num in arr:\n   \
    \     if num > min_heap[0]:\n            heapq.heapreplace(min_heap, num)\n  \
    \  return sorted(min_heap, reverse=True)\n", "    # return sorted(arr, reverse=True)[:k]\n\
    \n    result = []\n    for _ in range(k):\n        max_num = max(arr)\n      \
    \  result.append(max_num)\n        arr.remove(max_num)\n    return result\n",
  "    arr.sort()\n    return arr[-k:]\n\n", "    k = min(k, len(arr))\n    return\
    \ heapq.nlargest(k, arr)\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
