name: HumanEval_119_match_parens
language: py
results:
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    s = ''.join(lst)\n    num_open, num_close = 0, 0\n\
    \    for paren in s:\n        if paren == '(':\n            num_open += 1\n  \
    \      else:\n            num_close += 1\n        if num_close > num_open:\n \
    \           return 'No'\n    return 'Yes' if num_open == num_close else 'No'\n\
    def check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp86nxbwcr.py\", line\
    \ 47, in <module>\n    test_check()\n  File \"/tmp/tmp86nxbwcr.py\", line 45,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp86nxbwcr.py\", line\
    \ 34, in check\n    assert candidate([')())', '(()()(']) == 'Yes'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    str1, str2 = lst[0], lst[1]\n    count1, count2 = 0,\
    \ 0\n    for i in str1:\n        if i == '(':\n            count1 += 1\n     \
    \   else:\n            count1 -= 1\n    for i in str2:\n        if i == '(':\n\
    \            count2 += 1\n        else:\n            count2 -= 1\n    total =\
    \ count1 + count2\n    # when total is positive, need more ')'\n    # when total\
    \ is negative, need more '('\n    # when total is zero, need zero more '(' or\
    \ ')'\n    if total < 0:\n        str1 = str1 + str2\n        while total < 0:\n\
    \            str1 = str1 + ')'\n            total += 1\n        return str1\n\
    \    elif total > 0:\n        str1 = str1 + str2\n        while total > 0:\n \
    \           str1 = str1 + '('\n            total -= 1\n        return str1\n \
    \   else:\n        return str1 + str2\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0g14dwti.py\", line\
    \ 68, in <module>\n    test_check()\n  File \"/tmp/tmp0g14dwti.py\", line 66,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp0g14dwti.py\", line\
    \ 52, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    ret = 'Yes'\n    if lst[0].count('(') > lst[1].count('('):\n\
    \        return ret\n    if lst[0].count(')') > lst[1].count(')'):\n        return\
    \ ret\n    tmp = lst[0] + lst[1]\n    stk = []\n    for c in tmp:\n        if\
    \ c == '(':\n            stk.append(c)\n        else:\n            if not stk:\n\
    \                return 'No'\n            stk.pop()\n    if stk:\n        return\
    \ 'No'\n    return ret\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp_4fr45sh.py\", line\
    \ 54, in <module>\n    test_check()\n  File \"/tmp/tmp_4fr45sh.py\", line 52,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp_4fr45sh.py\", line\
    \ 40, in check\n    assert candidate(['(()(())', '())())']) == 'No'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    S = []\n    for c in lst[0]:\n        if c == '(':\n\
    \            S.append(c)\n        else:\n            S.pop()\n    for c in lst[1]:\n\
    \        if c == '(':\n            S.append(c)\n        else:\n            if\
    \ len(S) > 0:\n                S.pop()\n            else:\n                return\
    \ 'No'\n    if len(S) == 0:\n        return 'Yes'\n    else:\n        return 'No'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpksyhki2p.py\", line\
    \ 56, in <module>\n    test_check()\n  File \"/tmp/tmpksyhki2p.py\", line 54,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpksyhki2p.py\", line\
    \ 41, in check\n    assert candidate([')', ')']) == 'No'\n  File \"/tmp/tmpksyhki2p.py\"\
    , line 25, in match_parens\n    S.pop()\nIndexError: pop from empty list\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    parens = lst[0] + lst[1]\n    if parens[0] == ')':\n\
    \        return 'No'\n    depth = 0\n    for paren in parens:\n        if paren\
    \ == '(':\n            depth += 1\n        else:\n            depth -= 1\n   \
    \     if depth < 0:\n            return 'No'\n    if depth == 0:\n        return\
    \ 'Yes'\n    return 'No'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpu4h37tb4.py\", line\
    \ 52, in <module>\n    test_check()\n  File \"/tmp/tmpu4h37tb4.py\", line 50,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpu4h37tb4.py\", line\
    \ 39, in check\n    assert candidate([')())', '(()()(']) == 'Yes'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    s1, s2 = lst\n    # Concatenate the strings, with each\
    \ possible permutation.\n    strings = [s1 + s2, s2 + s1]\n    # Iterate over\
    \ each string, keeping track of how many open and closed parens\n    # there are\
    \ in the string.\n    for s in strings:\n        open_parens = 0\n        close_parens\
    \ = 0\n        for c in s:\n            if c == '(':\n                open_parens\
    \ += 1\n            elif c == ')':\n                if open_parens:\n        \
    \            open_parens -= 1\n                else:\n                    close_parens\
    \ += 1\n        # If there's a permutation that has no open or closed parens,\
    \ then it's a good string.\n        if open_parens == 0 and close_parens == 0:\n\
    \            return 'Yes'\n    return 'No'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    left, right = lst\n    if right.count(')') > left.count('('):\n\
    \        return 'No'\n    if not left:\n        return 'Yes'\n    if left[0] ==\
    \ ')':\n        if right[0] == ')':\n            return match_parens([left[1:],\
    \ right[1:]])\n        return match_parens([left[1:], right])\n    else:\n   \
    \     if right[0] == ')':\n            return match_parens([left, right[1:]])\n\
    \        return match_parens([left[1:], right])\n\ndef check(candidate):\n   \
    \ assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) ==\
    \ 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpem41fs83.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpem41fs83.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpem41fs83.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\n  File \"/tmp/tmpem41fs83.py\"\
    , line 31, in match_parens\n    return match_parens([left, right[1:]])\n  File\
    \ \"/tmp/tmpem41fs83.py\", line 30, in match_parens\n    if right[0] == ')':\n\
    IndexError: string index out of range\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    return 'Yes' if lst[0].count('(') == lst[1].count(')')\
    \ else 'No'\n\ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n\
    \    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())'])\
    \ == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpan9c6wwm.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmpan9c6wwm.py\", line 37,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpan9c6wwm.py\", line\
    \ 23, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    def _is_par_matched(s: str) -> bool:\n        par_cnt\
    \ = 0\n        for ch in s:\n            if ch == '(':\n                par_cnt\
    \ += 1\n            elif ch == ')':\n                par_cnt -= 1\n          \
    \  if par_cnt < 0:\n                return False\n        return par_cnt == 0\n\
    \n    if not _is_par_matched(lst[0]):\n        return 'No'\n    elif _is_par_matched(lst[0]\
    \ + lst[1]):\n        return 'Yes'\n    else:\n        return 'No'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpn_u1rjkc.py\", line\
    \ 55, in <module>\n    test_check()\n  File \"/tmp/tmpn_u1rjkc.py\", line 53,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpn_u1rjkc.py\", line\
    \ 39, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    left, right = 0, 0\n    for i in lst[0]:\n        if\
    \ i == '(':\n            left += 1\n        else:\n            left -= 1\n   \
    \ for i in lst[1]:\n        if i == '(':\n            right += 1\n        else:\n\
    \            right -= 1\n    if left + right == 0:\n        return 'Yes'\n   \
    \ return 'No'\n\ndef check(candidate):\n    assert candidate(['()(', ')']) ==\
    \ 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmplh60_fz6.py\", line\
    \ 52, in <module>\n    test_check()\n  File \"/tmp/tmplh60_fz6.py\", line 50,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmplh60_fz6.py\", line\
    \ 45, in check\n    assert candidate([')(', ')(']) == 'No'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    left = 0\n    right = 0\n    for c in lst[0]:\n   \
    \     if c == '(':\n            left += 1\n        else:\n            right +=\
    \ 1\n    if left == right:\n        return 'Yes'\n    else:\n        return 'No'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp8_p9yy6m.py\", line\
    \ 49, in <module>\n    test_check()\n  File \"/tmp/tmp8_p9yy6m.py\", line 47,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp8_p9yy6m.py\", line\
    \ 33, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    res = lst[0] + lst[1]\n    count = 0\n    for c in\
    \ res:\n        if c == '(':\n            count += 1\n        else:\n        \
    \    count -= 1\n        if count < 0:\n            return 'No'\n    return 'Yes'\
    \ if count == 0 else 'No'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjo4lderv.py\", line\
    \ 48, in <module>\n    test_check()\n  File \"/tmp/tmpjo4lderv.py\", line 46,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpjo4lderv.py\", line\
    \ 35, in check\n    assert candidate([')())', '(()()(']) == 'Yes'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack1 = []\n    stack2 = []\n    for char in lst[0]:\n\
    \        if char == '(':\n            stack1.append(char)\n        else:\n   \
    \         if stack1:\n                stack1.pop()\n            else:\n      \
    \          stack2.append(char)\n    for char in lst[1]:\n        if char == '(':\n\
    \            if stack2:\n                stack2.pop()\n            else:\n   \
    \             stack1.append(char)\n        else:\n            if stack1:\n   \
    \             stack1.pop()\n            else:\n                stack2.append(char)\n\
    \    if not stack1 and not stack2:\n        return 'Yes'\n    return 'No'\n\n\
    def check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp7eaair7d.py\", line\
    \ 62, in <module>\n    test_check()\n  File \"/tmp/tmp7eaair7d.py\", line 60,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp7eaair7d.py\", line\
    \ 55, in check\n    assert candidate([')(', ')(']) == 'No'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    if lst[0][0] == ')' or lst[1][0] == ')':\n        return\
    \ 'No'\n    if lst[0][-1] == '(' or lst[1][-1] == '(':\n        return 'No'\n\
    \    if '()' in lst[0] + lst[1]:\n        return 'Yes'\n    if ')(' in lst[0]\
    \ + lst[1]:\n        return 'Yes'\n    if ')(' in lst[0] + lst[1][::-1]:\n   \
    \     return 'Yes'\n    if '()' in lst[0] + lst[1][::-1]:\n        return 'Yes'\n\
    \    return 'No'\ndef check(candidate):\n    assert candidate(['()(', ')']) ==\
    \ 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpal3md1ps.py\", line\
    \ 50, in <module>\n    test_check()\n  File \"/tmp/tmpal3md1ps.py\", line 48,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpal3md1ps.py\", line\
    \ 34, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for c in lst[0]:\n        if c == '(':\n\
    \            stack.append(c)\n        else:\n            if stack:\n         \
    \       stack.pop()\n            else:\n                return 'No'\n    for c\
    \ in lst[1]:\n        if c == '(':\n            stack.append(c)\n        else:\n\
    \            if stack:\n                stack.pop()\n            else:\n     \
    \           return 'No'\n    if stack:\n        return 'No'\n    return 'Yes'\n\
    def check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpc4wm_9qi.py\", line\
    \ 57, in <module>\n    test_check()\n  File \"/tmp/tmpc4wm_9qi.py\", line 55,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpc4wm_9qi.py\", line\
    \ 44, in check\n    assert candidate([')())', '(()()(']) == 'Yes'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    if lst[0][0] == ')' or lst[1][0] == ')':\n        return\
    \ 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkxy2uz8e.py\", line\
    \ 41, in <module>\n    test_check()\n  File \"/tmp/tmpkxy2uz8e.py\", line 39,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpkxy2uz8e.py\", line\
    \ 25, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    if lst[0][0] == ')' or lst[1][0] == ')':\n        return\
    \ 'No'\n    elif lst[0][0] == '(' and lst[1][0] == '(':\n        return 'Yes'\n\
    \    else:\n        return 'No'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp03khvd82.py\", line\
    \ 44, in <module>\n    test_check()\n  File \"/tmp/tmp03khvd82.py\", line 42,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp03khvd82.py\", line\
    \ 28, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    s = ''.join(lst)\n    if len(s) % 2 == 1:\n       \
    \ return 'No'\n    num_open = 0\n    for ch in s:\n        if ch == '(':\n   \
    \         num_open += 1\n        else:\n            num_open -= 1\n        if\
    \ num_open < 0:\n            return 'No'\n    return 'Yes' if num_open == 0 else\
    \ 'No'\n\ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n\
    \    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())'])\
    \ == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmplyn20y0h.py\", line\
    \ 50, in <module>\n    test_check()\n  File \"/tmp/tmplyn20y0h.py\", line 48,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmplyn20y0h.py\", line\
    \ 37, in check\n    assert candidate([')())', '(()()(']) == 'Yes'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    counter = 0\n    for c in lst[0]:\n        if c ==\
    \ '(':\n            counter += 1\n        else:\n            counter -= 1\n  \
    \  for c in lst[1]:\n        if c == '(':\n            counter += 1\n        else:\n\
    \            counter -= 1\n    return 'Yes' if counter == 0 else 'No'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpc9d2siqp.py\", line\
    \ 50, in <module>\n    test_check()\n  File \"/tmp/tmpc9d2siqp.py\", line 48,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpc9d2siqp.py\", line\
    \ 43, in check\n    assert candidate([')(', ')(']) == 'No'\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    cnt = 0\n    s = ''.join(lst)\n    for c in s:\n  \
    \      if c == '(':\n            cnt += 1\n        elif c == ')':\n          \
    \  cnt -= 1\n        if cnt < 0:\n            return 'No'\n    return 'Yes' if\
    \ cnt == 0 else 'No'\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpeepwa3_9.py\", line\
    \ 47, in <module>\n    test_check()\n  File \"/tmp/tmpeepwa3_9.py\", line 45,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpeepwa3_9.py\", line\
    \ 34, in check\n    assert candidate([')())', '(()()(']) == 'Yes'\nAssertionError\n"
  exit_code: -1
  status: Exception
