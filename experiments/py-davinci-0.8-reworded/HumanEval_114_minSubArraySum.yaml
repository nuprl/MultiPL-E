name: HumanEval_114_minSubArraySum
language: py
prompt: "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n\
  \    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty\
  \ sub-array\n    of nums.\n    Example\n    >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n\
  \    1\n    >>> minSubArraySum([-1, -2, -3])\n    -6\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1\n   \
  \ assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10])\
  \ == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert\
  \ candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5])\
  \ == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10,\
  \ 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\
  \    assert candidate([-10]) == -10\n    assert candidate([7]) == 7\n    assert\
  \ candidate([1, -1]) == -1\n\ndef test_check():\n    check(minSubArraySum)\n\ntest_check()\n"
completions: ["    # O(n)\n    for i in range(1, len(nums)):\n        nums[i] = min(nums[i],\
    \ nums[i] + nums[i - 1])\n    return min(nums)\n", "    min_sum = nums[0]\n  \
    \  current_sum = nums[0]\n    for n in nums[1:]:\n        current_sum = min(current_sum\
    \ + n, n)\n        min_sum = min(min_sum, current_sum)\n    return min_sum\n",
  "    if not nums:\n        return 0\n    minimum = float('inf')\n    current = 0\n\
    \    for num in nums:\n        current += num\n        minimum = min(minimum,\
    \ current)\n        current = max(current, 0)\n    return minimum", "    if len(nums)\
    \ == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n  \
    \  if len(nums) == 2:\n        return min(nums[0], nums[1])\n    min_so_far =\
    \ nums[0]\n    min_ending_here = nums[0]\n    for i in range(1, len(nums)):\n\
    \        min_ending_here = min(nums[i], min_ending_here + nums[i])\n        min_so_far\
    \ = min(min_so_far, min_ending_here)\n    return min_so_far\n", "    curr_sum\
    \ = nums[0]\n    min_sum = nums[0]\n    for n in nums[1:]:\n        curr_sum =\
    \ min(n, curr_sum + n)\n        min_sum = min(min_sum, curr_sum)\n    return min_sum",
  "    s = 0\n    min_sum = 10000000000000000000000000000000\n    for i in range(len(nums)):\n\
    \        s += nums[i]\n        if min_sum > s:\n            min_sum = s\n    \
    \    if s > 0:\n            s = 0\n    return min_sum", "    minSum = None\n \
    \   for i in range(len(nums)):\n        currSum = 0\n        for j in range(i,\
    \ len(nums)):\n            currSum += nums[j]\n            if minSum is None or\
    \ currSum < minSum:\n                minSum = currSum\n    return minSum\n", " \
    \   min_val = float('inf')\n    curr_val = 0\n    for num in nums:\n        curr_val\
    \ += num\n        min_val = min(min_val, curr_val)\n        curr_val = max(curr_val,\
    \ 0)\n    return min_val\n", "    min_sum = nums[0]\n    current_sum = 0\n   \
    \ for n in nums:\n        current_sum += n\n        if current_sum < min_sum:\n\
    \            min_sum = current_sum\n        if current_sum > 0:\n            current_sum\
    \ = 0\n    return min_sum\n", "    # O(n) time\n    # O(1) space\n    _min = float('inf')\n\
    \    _sum = 0\n    for i in range(len(nums)):\n        _sum += nums[i]\n     \
    \   _min = min(_min, _sum)\n        if _sum > 0:\n            _sum = 0\n    return\
    \ _min", "    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n \
    \       return nums[0]\n    min_sum = float('inf')\n    for start in range(len(nums)):\n\
    \        for end in range(start, len(nums)):\n            sub_array_sum = sum(nums[start:end+1])\n\
    \            if sub_array_sum < min_sum:\n                min_sum = sub_array_sum\n\
    \    return min_sum", "    pass\n\n", "    min_sum = float('inf')\n    curr_sum\
    \ = 0\n    for num in nums:\n        curr_sum += num\n        min_sum = min(min_sum,\
    \ curr_sum)\n        curr_sum = max(curr_sum, 0)\n    return min_sum\n", "   \
    \ # approach:\n    # initialize a temp = 0\n    # loop through array\n    #  \
    \ if temp + current num < 0, reset temp = 0\n    #   else add num to temp\n  \
    \  #   keep track of lowest sum\n    # return lowest sum\n    temp = 0\n    minimum\
    \ = float('inf')\n    for num in nums:\n        if temp + num < 0:\n         \
    \   temp = 0\n        else:\n            temp += num\n        minimum = min(minimum,\
    \ temp)\n    return minimum\n", "    min_so_far = float('inf')\n    curr_min =\
    \ 0\n    for i in range(len(nums)):\n        curr_min = min(curr_min + nums[i],\
    \ nums[i])\n        min_so_far = min(min_so_far, curr_min)\n    return min_so_far\n",
  "    for i in range(1, len(nums)):\n        nums[i] = min(nums[i], nums[i] + nums[i\
    \ - 1])\n    return min(nums)\n", "    min_sum = min(nums)\n    total = 0\n  \
    \  for i in range(len(nums)):\n        for j in range(i, len(nums)):\n       \
    \     total += nums[j]\n            if total < min_sum:\n                min_sum\
    \ = total\n    return min_sum\n", "    global_min = nums[0]\n    local_min = 0\n\
    \    for num in nums:\n        local_min = min(local_min + num, num)\n       \
    \ global_min = min(global_min, local_min)\n    return global_min\n", "    # get\
    \ the minimum number in nums\n    if len(nums) == 1:\n        return nums[0]\n\
    \    min_num = min(nums)\n    # if all numbers are negative\n    if min_num <\
    \ 0:\n        return min_num\n    for i in range(len(nums)):\n        for j in\
    \ range(i, len(nums)):\n            min_num = min(min_num, sum(nums[i:j + 1]))\n\
    \    return min_num\n", "    n = len(nums)\n    if n == 0:\n        return 0\n\
    \    dp = [0] * n\n    dp[0] = nums[0]\n    for i in range(1, n):\n        dp[i]\
    \ = min(dp[i - 1] + nums[i], nums[i])\n    return min(dp)"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
