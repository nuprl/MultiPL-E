name: HumanEval_49_modp
language: py
prompt: "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware\
  \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n   \
  \ >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
  \    1\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101,\
  \ 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n\
  \    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert\
  \ candidate(31, 5) == 3\n\ndef test_check():\n    check(modp)\n\ntest_check()\n"
completions: ["    if p <= 0:\n        raise ValueError(\"modp: invalid p\")\n   \
    \ if n < 0:\n        raise ValueError(\"modp: invalid n\")\n    return 1 if n\
    \ == 0 else 2**(n % (p-1)) % p\n", "    if n == 0:\n        return 1\n    else:\n\
    \        r = 1\n        for i in range(n):\n            r = (r * 2) % p\n    \
    \    return r\n\n", "    result = 1\n    base = 2\n    while n > 0:\n        if\
    \ n % 2 == 1:\n            result = (result * base) % p\n        base = (base\
    \ * base) % p\n        n = n // 2\n    return result\n\n", "    if n == 0:\n \
    \       return 1\n    elif n % 2 == 0:\n        return modp(n // 2, p) ** 2 %\
    \ p\n    else:\n        return 2 * modp(n - 1, p) % p\n\n", "    if n == 0:\n\
    \        return 1\n    elif n % 2 == 0:\n        return (modp(n // 2, p) ** 2)\
    \ % p\n    elif n % 2 == 1:\n        return (2 * modp(n - 1, p)) % p\n    else:\n\
    \        assert False\n\n", "    if n == 0:\n        return 1\n    if n == 1:\n\
    \        return 2\n    if n % 2 == 0:\n        sqr = modp(n//2, p)\n        return\
    \ sqr * sqr % p\n    else:\n        return 2 * modp(n-1, p) % p\n\n", "    if\
    \ n == 0:\n        return 1\n    if n == 1:\n        return 2\n    a = modp(n//2,\
    \ p)\n    if n % 2 == 0:\n        return a * a % p\n    else:\n        return\
    \ 2 * a * a % p\n\n", "    M = 1\n    for _ in range(n):\n        M = (M * 2)\
    \ % p\n    return M\n\n", "    return pow(2, n, p)\n\n", "    r = 1\n    for i\
    \ in range(n):\n        r = (r * 2) % p\n    return r\n\n", "    assert n >= 0,\
    \ 'only non-negative numbers'\n    if n == 0:\n        return 1\n    elif n %\
    \ 2 == 0:\n        return modp(n // 2, p) ** 2 % p\n    else:\n        return\
    \ 2 * modp(n - 1, p) % p\n\n", "    x = 1\n    y = 2\n    while n > 0:\n     \
    \   if n % 2 == 0:\n            x = (x * y) % p\n            n = n / 2\n     \
    \   else:\n            n = n - 1\n            y = (x * y) % p\n    return x\n",
  "    a = 1\n    for i in range(n):\n        a = (a * 2) % p\n    return a\n", " \
    \   res = 1\n    for i in range(n):\n        res = res * 2 % p\n    return res\n\
    \n", "    if n == 0:\n        return 1\n    if n % 2 == 0:\n        return modp(n\
    \ // 2, p) ** 2 % p\n    return 2 * modp(n - 1, p) % p\n\n", "    a = 1\n    b\
    \ = 2\n    c = n\n    while c > 0:\n        if c % 2 == 1:\n            a = (a\
    \ * b) % p\n        b = (b * b) % p\n        c = c // 2\n    return a\n\n", " \
    \   if n == 0:\n        return 1\n    return pow(2, n % (p - 1), p)\n\n", "  \
    \  return (2 ** n) % p\n\n", "    if n == 0:\n        return 1\n    elif n ==\
    \ 1:\n        return 2\n    elif n % 2 == 0:\n        p1 = modp(n // 2, p)\n \
    \       return ((p1 * p1) % p)\n    else:\n        p1 = modp(n // 2, p)\n    \
    \    return ((p1 * p1 * 2) % p)\n\n", "    return pow(2, n, p)\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
