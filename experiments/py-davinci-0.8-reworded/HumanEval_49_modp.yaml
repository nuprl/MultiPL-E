name: HumanEval_49_modp
language: py
prompt: "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware\
  \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n   \
  \ >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
  \    1\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101,\
  \ 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n\
  \    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert\
  \ candidate(31, 5) == 3\n\ndef test_check():\n    check(modp)\n\ntest_check()\n"
completions: ["    if p <= 0:\n        raise ValueError(\"modp: invalid p\")\n   \
    \ if n < 0:\n        raise ValueError(\"modp: invalid n\")\n    return 1 if n\
    \ == 0 else 2**(n % (p-1)) % p\n", "    if n == 0:\n        return 1\n    else:\n\
    \        r = 1\n        for i in range(n):\n            r = (r * 2) % p\n    \
    \    return r\n\n", "    result = 1\n    base = 2\n    while n > 0:\n        if\
    \ n % 2 == 1:\n            result = (result * base) % p\n        base = (base\
    \ * base) % p\n        n = n // 2\n    return result\n\n", "    if n == 0:\n \
    \       return 1\n    elif n % 2 == 0:\n        return modp(n // 2, p) ** 2 %\
    \ p\n    else:\n        return 2 * modp(n - 1, p) % p\n\n", "    if n == 0:\n\
    \        return 1\n    elif n % 2 == 0:\n        return (modp(n // 2, p) ** 2)\
    \ % p\n    elif n % 2 == 1:\n        return (2 * modp(n - 1, p)) % p\n    else:\n\
    \        assert False\n\n", "    if n == 0:\n        return 1\n    if n == 1:\n\
    \        return 2\n    if n % 2 == 0:\n        sqr = modp(n//2, p)\n        return\
    \ sqr * sqr % p\n    else:\n        return 2 * modp(n-1, p) % p\n\n", "    if\
    \ n == 0:\n        return 1\n    if n == 1:\n        return 2\n    a = modp(n//2,\
    \ p)\n    if n % 2 == 0:\n        return a * a % p\n    else:\n        return\
    \ 2 * a * a % p\n\n", "    M = 1\n    for _ in range(n):\n        M = (M * 2)\
    \ % p\n    return M\n\n", "    return pow(2, n, p)\n\n", "    r = 1\n    for i\
    \ in range(n):\n        r = (r * 2) % p\n    return r\n\n", "    assert n >= 0,\
    \ 'only non-negative numbers'\n    if n == 0:\n        return 1\n    elif n %\
    \ 2 == 0:\n        return modp(n // 2, p) ** 2 % p\n    else:\n        return\
    \ 2 * modp(n - 1, p) % p\n\n", "    x = 1\n    y = 2\n    while n > 0:\n     \
    \   if n % 2 == 0:\n            x = (x * y) % p\n            n = n / 2\n     \
    \   else:\n            n = n - 1\n            y = (x * y) % p\n    return x\n",
  "    a = 1\n    for i in range(n):\n        a = (a * 2) % p\n    return a\n", " \
    \   res = 1\n    for i in range(n):\n        res = res * 2 % p\n    return res\n\
    \n", "    if n == 0:\n        return 1\n    if n % 2 == 0:\n        return modp(n\
    \ // 2, p) ** 2 % p\n    return 2 * modp(n - 1, p) % p\n\n", "    a = 1\n    b\
    \ = 2\n    c = n\n    while c > 0:\n        if c % 2 == 1:\n            a = (a\
    \ * b) % p\n        b = (b * b) % p\n        c = c // 2\n    return a\n\n", " \
    \   if n == 0:\n        return 1\n    return pow(2, n % (p - 1), p)\n\n", "  \
    \  return (2 ** n) % p\n\n", "    if n == 0:\n        return 1\n    elif n ==\
    \ 1:\n        return 2\n    elif n % 2 == 0:\n        p1 = modp(n // 2, p)\n \
    \       return ((p1 * p1) % p)\n    else:\n        p1 = modp(n // 2, p)\n    \
    \    return ((p1 * p1 * 2) % p)\n\n", "    return pow(2, n, p)\n", "    x = 1\n\
    \    for _ in range(n):\n        x = (x*2) % p\n    return x\n\n", "    if n ==\
    \ 0:\n        return 1\n    elif n == 1:\n        return 2\n    else:\n      \
    \  return pow(2, n, p)\n\n", "    if n == 0:\n        return 1\n    elif n ==\
    \ 1:\n        return 2\n    elif n % 2 == 0:\n        return modp(n // 2, p) **\
    \ 2 % p\n    else:\n        return (modp(n // 2, p) ** 2 % p) * 2 % p\n\n\n@functools.lru_cache(maxsize=None)",
  "    return (2 ** n) % p\n", "    total = 1\n    while n:\n        if n & 1:\n \
    \           total = (total * 2) % p\n        n >>= 1\n    return total\n\n", " \
    \   if n == 0:\n        return 1\n    return 2**(n % (p - 1)) % p\n\n", "    res\
    \ = 1\n    for i in range(n):\n        res = res * 2 % p\n    return res\n", " \
    \   res = 1\n    for _ in range(n):\n        res = res * 2 % p\n    return res\n\
    \n", "    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return pow(modp(n//2,\
    \ p), 2, p)\n    else:\n        return pow(2, n-1, p) * 2 % p\n\n", "    if n\
    \ == 0:\n        return 1\n    elif n % 2 == 0:\n        return modp(n // 2, p)\
    \ ** 2 % p\n    else:\n        return 2 * modp(n - 1, p) % p\n\n", "    return\
    \ pow(2, n, p)\n\n", "    # ToDo: find a better solution\n    return pow(2, n,\
    \ p)\n", "    x = 1\n    for i in range(n):\n        x = (x * 2) % p\n    return\
    \ x\n\n", "    res = 1\n    for i in range(n):\n        res = res * 2 % p\n  \
    \  return res\n\n", "    ans = 1\n    for i in range(n):\n        ans = (ans *\
    \ 2) % p\n    return ans\n\n", "    return bin_exp(2, n, p)\n\n", "    return\
    \ pow(2, n, p)\n\n", "    return int(2**n % p)\n\n", "    if n == 0:\n       \
    \ return 1\n    x = modp(n // 2, p)\n    if n % 2 == 0:\n        return (x * x)\
    \ % p\n    else:\n        return (2 * x * x) % p\n\n", "    if n == 0:\n     \
    \   return 1\n    elif n == 1:\n        return 2\n    elif n % 2 == 0:\n     \
    \   tmp = modp(n // 2, p)\n        return (tmp * tmp) % p\n    else:\n       \
    \ tmp = modp(n - 1, p)\n        return (2 * tmp) % p\n\n", "    return 2 ** n\
    \ % p\n\n", "    r = 1\n    for i in range(n):\n        r = (r * 2) % p\n    return\
    \ r\n\n", "    n = n % (p - 1)  # make n smaller\n    # repeated squaring (see\
    \ slide 53)\n    s = 1\n    while n > 0:\n        if n % 2 != 0:\n           \
    \ s = (s * 2) % p\n        n = n // 2\n        if n > 0:\n            2 *= 2 %\
    \ p\n    return s\n\n", "    if n == 0:\n        return 1\n    else:\n       \
    \ return pow(2, modp(n // 2, p), p) * modp(n % 2, p) % p\n\n", "    if n == 0:\n\
    \        return 1\n    if n == 1:\n        return 2\n    h = n // 2\n    m = n\
    \ % 2\n    if m == 0:\n        return modp(h, p)**2 % p\n    else:\n        return\
    \ (modp(h, p)**2 * 2) % p\n\n", "    if n == 0:\n        return 1\n    elif n\
    \ % 2 == 0:\n        res = modp(n // 2, p)\n        return (res * res) % p\n \
    \   else:\n        res = modp(n - 1, p)\n        return (2 * res) % p\n\n", " \
    \   return pow(2, n, p)\n", "    n = n % (p - 1)\n    return pow(2, n, p)\n\n",
  "    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return modp(n//2,\
    \ p)**2 % p\n    else:\n        return 2 * modp(n-1, p) % p\n\n", "    if n ==\
    \ 0:\n        return 1\n    elif n == 1:\n        return 2\n    else:\n      \
    \  res = 1\n        for i in range(n):\n            res = res * 2 % p\n      \
    \  return res\n\n", "    if n == 0:\n        return 1\n    elif n % 2 == 0:\n\
    \        return modp(n // 2, p) ** 2 % p\n    else:\n        return 2 * modp(n\
    \ - 1, p) % p\n", "    return pow(2, n, p)\n\n", "    # Your code here\n    if\
    \ n == 0:\n        return 1\n    x = 1\n    while n > 0:\n        if n % 2 ==\
    \ 1:\n            x = x * 2 % p\n        n = n // 2\n    return x % p\n", "  \
    \  if p == 1:\n        return 0\n    if n < 0:\n        raise ValueError(\"n must\
    \ be non-negative\")\n    if n == 0:\n        return 1\n    if n % 2 == 0:\n \
    \       r = modp(n // 2, p)\n        return r * r % p\n    return modp(n - 1,\
    \ p) * 2 % p\n", "    assert p > 1\n    return pow(2, n, p)\n\n", "    binary_n\
    \ = '{:b}'.format(n)\n    two_to_the_n = 2\n    while len(binary_n) > 1:\n   \
    \     if binary_n[-1] == '1':\n            two_to_the_n = (two_to_the_n * two_to_the_n)\
    \ % p\n        binary_n = binary_n[:-1]\n    return two_to_the_n\n\n", "    if\
    \ n == 0:\n        return 1\n    # Could probably use a faster algorithm here,\
    \ like binary exponentiation\n    # (see for example: https://en.wikipedia.org/wiki/Exponentiation_by_squaring)\n\
    \    return (2**n % p)\n\n", "    if n == 0:\n        return 1\n    elif n ==\
    \ 1:\n        return 2\n    elif n % 2 == 0:\n        return modp(n // 2, p) **\
    \ 2 % p\n    else:\n        return 2 * modp(n - 1, p) % p\n\n", "    if n == 0:\n\
    \        return 1\n    if n == 1:\n        return 2\n    if n % 2 == 0:\n    \
    \    m = modp(n // 2, p)\n        return (m ** 2) % p\n    else:\n        m =\
    \ modp(n // 2, p)\n        return (2 * m * m) % p\n\n", "    return 2 ** n % p\n\
    \n", "    def w(n: int) -> int:\n        if n == 0:\n            return 1\n  \
    \      elif n % 2 == 0:\n            return w(n//2)**2 % p\n        else:\n  \
    \          return 2 * w(n-1) % p\n    return w(n) % p\n", "    r = 1\n    for\
    \ i in range(n):\n        r = (r * 2) % p\n    return r\n\n", "    raise NotImplementedError\n\
    \n", "    assert p > 1\n    return pow(2, n, p)\n", "    # Lift the number to\
    \ modular level\n    n = n % p\n\n    r = 1\n    for _ in range(n):\n        r\
    \ = (r * 2) % p\n\n    return r\n\n", "    # First check: n < 0 (p must be > 0)\n\
    \    if n < 0:\n        n = n % p\n    if n == 0:\n        return 1\n    result\
    \ = 2\n    for _ in range(n - 1):\n        result = (result * 2) % p\n    return\
    \ result\n\n", "    return pow(2, n, p)\n\n", "    return pow(2, n, p)\n\n", " \
    \   if n <= 0:\n        return 1\n    elif n % 2 == 0:\n        half = modp(n\
    \ // 2, p)\n        return (half * half) % p\n    else:\n        return 2 * modp(n\
    \ - 1, p) % p\n\n", "    bin_n = bin(n)\n    result = 1\n    for c in reversed(bin_n[2:]):\n\
    \        result = (result**2) % p\n        if c == '1':\n            result =\
    \ (result * 2) % p\n    return result\n\n", "    res = 1\n    for i in range(n):\n\
    \        res = res * 2 % p\n    return res\n\n", "    # return 2**n % p\n\n  \
    \  # slow\n    # c = 1\n    # while n > 0:\n    #     c = (c*2) % p\n    #   \
    \  n -= 1\n    # return c\n\n    # faster\n    c = 1\n    while n > 0:\n     \
    \   if n % 2 == 1:\n            c = (c*2) % p\n        n //= 2\n        if n >\
    \ 0:\n            c = (c*c) % p\n    return c\n\n", "    t = 1\n    while n >\
    \ 0:\n        if n % 2 == 1:\n            t = (t * 2) % p\n        n = n // 2\n\
    \    return t\n\n", "    t = 1\n    while n > 0:\n        if n % 2 == 1:\n   \
    \         t = (t * 2) % p\n        n = n // 2\n    return t\n\n", "    r = 1\n\
    \    for b in bin(n)[3:]:\n        r = r * r % p\n        if b == '1':\n     \
    \       r = r * 2 % p\n    return r\n\n", "    if n == 0:\n        return 1\n\
    \    elif n == 1:\n        return 2\n    elif n % 2 == 0:\n        return modp(n//2,\
    \ p)**2 % p\n    else:\n        return 2 * modp(n-1, p) % p\n\n", "    if n ==\
    \ 0:\n        return 1\n    elif n == 1:\n        return 2\n    elif n % 2 ==\
    \ 0:\n        return (modp(n // 2, p) ** 2) % p\n    else:\n        return (2\
    \ * modp(n - 1, p)) % p\n\n", "    if n < 0:\n        return modp(-n, p)\n   \
    \ if n == 0:\n        return 1\n    elif n == 1:\n        return 2\n    elif n\
    \ % 2 == 0:\n        return modp(n//2, p)**2 % p\n    else:\n        return 2\
    \ * modp(n-1, p) % p\n\n", "    if n == 0:\n        return 1\n    if n % 2 ==\
    \ 0:\n        return modp(n//2, p)**2 % p\n    else:\n        return 2 * modp(n\
    \ - 1, p) % p\n", "    if n == 0:\n        return 1\n    if n % 2 == 0:\n    \
    \    return modp(n // 2, p) ** 2 % p\n    return 2 * modp(n - 1, p) % p\n\n",
  "    n = n % p\n    t = 2\n    if n == 0:\n        return 1\n    while n > 1:\n\
    \        t = (t*t) % p\n        n = n//2\n    return t\n\n", "    res = 1\n  \
    \  for i in range(n):\n        res = res * 2 % p\n    return res\n\n", "    if\
    \ p <= 0:\n        raise ValueError(f\"modp argument p must be positive, got {p}\"\
    )\n    return pow(2, n, p)\n\n", "    if n == 0:\n        return 1\n    if n %\
    \ 2 == 0:\n        return modp(n // 2, p) ** 2 % p\n    else:\n        return\
    \ modp(n - 1, p) * 2 % p\n\n", "    power = 1\n    n %= p - 1\n    while n > 0:\n\
    \        if n % 2 == 1:\n            power = (power * 2) % p\n        n = n //\
    \ 2\n    return power\n\n", "    if n == 0:\n        return 1\n    elif n % 2\
    \ == 0:\n        return modp(n//2, p)**2 % p\n    else:\n        return 2 * modp(n-1,\
    \ p) % p\n", "    if n == 0:\n        return 1\n    # p should be odd and a prime\n\
    \    assert p % 2 == 1\n    assert miller_rabin(p)\n    # if n < 2 or p < 2:\n\
    \    #     raise ValueError\n    t = 1\n    while n > 1:\n        if n % 2 ==\
    \ 1:\n            t = (t * 2) % p\n        n //= 2\n    return t % p\n\n\n@functools.lru_cache(maxsize=None)",
  "    if n == 0:\n        return 1\n    elif n == 1:\n        return 2\n    if n\
    \ % 2 == 0:\n        return (modp(n // 2, p) ** 2) % p\n    return (2 * modp(n\
    \ - 1, p)) % p\n\n", "    assert n >= 0\n    n = n % (p - 1)\n    r = 1\n    for\
    \ _ in range(n):\n        r = r * 2 % p\n    return r\n\n", "    if n == 0:\n\
    \        return 1\n    if n % 2 == 0:\n        return modp(n // 2, p) ** 2 % p\n\
    \    return 2 * modp(n - 1, p) % p\n\n", "    a = 2\n    n = n % (p - 1)\n   \
    \ res = 1\n    while n > 0:\n        if n % 2 == 1:\n            res = (res *\
    \ a) % p\n        a = (a * a) % p\n        n //= 2\n    return res\n\n", "   \
    \ if n == 0:\n        return 1\n    if n == 1:\n        return 2 % p\n    if n\
    \ % 2 == 0:\n        return modp(n // 2, p) ** 2 % p\n    return 2 * modp(n -\
    \ 1, p) % p\n\n", "    assert p > 0\n    if n == 0:\n        return 1\n    if\
    \ n % 2 == 0:\n        return modp(n // 2, p) ** 2 % p\n    else:\n        return\
    \ 2 * modp(n - 1, p) % p\n\n", "    if n == 0:\n        return 1\n    elif n ==\
    \ 1:\n        return 2\n    elif (n % 2) == 0:\n        return modp(n // 2, p)\
    \ ** 2 % p\n    else:\n        return (modp(n // 2, p) ** 2 * 2) % p\n\n", " \
    \   # Compute and return the result\n    return pow(2, n, p)\n\n\n@dataclass",
  "    if n == 0:\n        return 1\n    r = 1\n    for _ in range(n):\n        r\
    \ = (r * 2) % p\n    return r\n\n", "    return pow(2, n, p)\n\n", "    n %= p\
    \ - 1\n    return pow(2, n, p)\n\n", "    if p == 2:\n        if n % 2 == 0:\n\
    \            return 1\n        else:\n            return -1\n    else:\n     \
    \   return pow(2, n, p)\n", "    if n == 0:\n        return 1\n    else:\n   \
    \     i = n % (p - 1)\n        return pow(2, i, p)\n\n", "    if n == 0:\n   \
    \     return 1\n    return (2 * modp(n - 1, p)) % p\n\n", "    res = 1\n    for\
    \ i in range(n):\n        res = res * 2 % p\n    return res\n\n", "    if p ==\
    \ 1:\n        return 0\n    v = 1\n    for k in range(n):\n        v = (v*2) %\
    \ p\n    return v\n\n", "    c = 1\n    while n > 0:\n        if n % 2 == 1:\n\
    \            c = (c * 2) % p\n        n //= 2\n    return c\n", "    ret = 1\n\
    \    for _ in range(n):\n        ret = ret * 2 % p\n    return ret\n\n", "   \
    \ if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    if n % 2\
    \ == 0:\n        return (modp(n//2, p) ** 2) % p\n    else:\n        return (2\
    \ * modp(n//2, p) ** 2) % p\n\n", "    return pow(2, n, p)\n\n", "    # 2^(2n)\
    \ = (2^n)^2 = (2^n mod p)^2 mod p\n    # 2^(2n+1) = 2 * 2^(2n) = 2 * (2^n)^2 mod\
    \ p = 2 * (2^n mod p)^2 mod p\n    if n == 0:\n        return 1\n    if n % 2\
    \ == 0:\n        return pow(modp(n // 2, p), 2, p)\n    return 2 * pow(modp(n\
    \ // 2, p), 2, p) % p\n\n", "    r = 1\n    for i in range(n):\n        r = (r\
    \ * 2) % p\n    return r\n", "    if n == 0:\n        return 1\n    if n % 2 ==\
    \ 0:\n        return modp(n // 2, p) ** 2 % p\n    return 2 * modp(n - 1, p) %\
    \ p\n\n", "    if n == 0:\n        return 1\n    elif n == 1:\n        return\
    \ 2\n    elif n == 2:\n        return 4 % p\n    elif n % 2 == 0:\n        return\
    \ modp(n // 2, p) ** 2 % p\n    else:\n        return (modp(n // 2, p) ** 2 %\
    \ p) * 2 % p\n\n", "    if n == 0:\n        return 1\n    if n % 2 == 0:\n   \
    \     x = modp(n // 2, p)\n        return (x * x) % p\n    else:\n        return\
    \ (2 * modp(n - 1, p)) % p\n\n", "    return 2 ** n % p\n\n", "    ans = 1\n \
    \   for i in range(n):\n        ans = (ans * 2) % p\n    return ans\n\n", "  \
    \  r = 1\n    for i in range(n):\n        r = (r * 2) % p\n    return r\n\n",
  "    if n == 0:\n        return 1\n    temp = modp(n//2, p)\n    if n % 2 == 0:\n\
    \        return (temp * temp) % p\n    else:\n        return (2 * temp * temp)\
    \ % p\n\n", "    if n == 0:\n        return 1\n    if n == 1:\n        return\
    \ 2 % p\n    if n % 2 == 0:\n        return modp(n // 2, p) ** 2 % p\n    return\
    \ 2 * modp(n - 1, p) % p\n\n", "    return pow(2, n, p)\n", "    num = 2 ** n\n\
    \    return num % p\n\n", "    x = 1\n    while n > 0:\n        if n % 2 == 1:\n\
    \            x = (x * 2) % p\n        n = n // 2\n    return x\n\n", "    if n\
    \ == 0:\n        return 1\n    elif n == 1:\n        return 2\n    elif n % 2\
    \ == 0:\n        return modp(n // 2, p) ** 2 % p\n    else:\n        return 2\
    \ * modp(n - 1, p) % p\n\n", "    assert p >= 3 and p % 2 == 1, 'p must be an\
    \ odd prime'\n    x = 2\n    for i in range(n):\n        x = (x * x) % p\n   \
    \ return x\n\n", "    if n == 0:\n        return 1\n    if n == 1:\n        return\
    \ 2 % p\n    return pow(2, modp(n - 1, p), p)\n\n", "    if n == 0:\n        return\
    \ 1\n    else:\n        return pow(2, n, p)\n\n", "    if n < 0:\n        return\
    \ modp(-n, p)\n    if n == 0:\n        return 1\n    if n == 1:\n        return\
    \ 2\n    if n % 2 == 0:\n        x = modp(n // 2, p)\n        return (x * x) %\
    \ p\n    else:\n        return (2 * modp(n - 1, p)) % p\n\n", "    if n == 0:\n\
    \        return 1\n    elif n % 2 == 0:\n        return modp(n // 2, p) ** 2 %\
    \ p\n    else:\n        return 2 * modp(n - 1, p) % p\n    # 2n = (2n-1) * 2\n\
    \    # 2n = (2n-2) * 2**2\n    # 2n = (2n-4) * 2**3\n    # 2n = (2n-8) * 2**4\n\
    \    # ...\n    # 2n = (2n-2**k) * 2**(k+1)\n    # 2**(k+1) = 2n - 2**k\n    #\
    \ 2**(k+1) = 2n mod p - 2**k\n    # 2**(k+1) mod p = 2n mod p - 2**k\n    # 2**(k+1)\
    \ mod p = (2**(k+1) - 2**k) mod p\n    # 2**(k+1) mod p = (2**(k+1) - 2**k) mod\
    \ p\n\n", "    # Equivalent to using the binary exponentation\n    # if n == 0:\n\
    \    #     return 1\n    # else:\n    #     temp = modp(n // 2, p)\n    #    \
    \ if n % 2 == 0:\n    #         return (temp * temp) % p\n    #     else:\n  \
    \  #         return (2 * temp * temp) % p\n    # Equivalent to using the square-and-multiply\
    \ method\n    b = bin(n)\n    res = 1\n    for i in range(len(b) - 1, 0, -1):\n\
    \        res = (res * res) % p\n        if b[i] == '1':\n            res = (res\
    \ * 2) % p\n    return res\n\n", "    return pow(2, n, p)\n", "    if n == 0:\n\
    \        return 1\n    elif n % 2 == 0:\n        return modp(n // 2, p) ** 2 %\
    \ p\n    else:\n        return 2 * modp(n - 1, p) % p\n\n", "    # Simplest approach:\
    \ bin, a bit vector\n    b = bin(n)[2:]\n    # print(b)\n    res = 1\n    for\
    \ i in range(len(b)):\n        res = res ** 2 % p\n        if b[-i - 1] == '1':\n\
    \            res = res * 2 % p\n    return res\n\n", "    if n == 0:\n       \
    \ return 1\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return\
    \ 4 % p\n    else:\n        return ((modp(n - 1, p) ** 2) * 2) % p\n", "    if\
    \ n < 0:\n        return modp(-n, p)\n    if n == 0:\n        return 1\n    if\
    \ n == 1:\n        return 2\n    if (n & 1) == 0:\n        t = modp(n >> 1, p)\n\
    \        return (t * t) % p\n    else:\n        t = modp(n >> 1, p)\n        return\
    \ (2 * t * t) % p\n\n", "    return pow(2, n, p)\n\n", "    res = 1\n    for _\
    \ in range(n):\n        res = res * 2 % p\n    return res\n", "    if n == 0:\n\
    \        return 1\n    else:\n        return (2 * modp(n - 1, p)) % p\n", "  \
    \  res = 1\n    while n > 0:\n        if n % 2 != 0:\n            res = (res *\
    \ 2) % p\n        n = n // 2\n    return res\n\n", "    return pow(2, n, p)\n\n",
  "    c = 1\n    for _ in range(n):\n        c = c * 2 % p\n    return c\n", "  \
    \  ans = 1\n    while n > 0:\n        if n % 2 != 0:\n            ans = (ans *\
    \ 2) % p\n        n = n // 2\n    return ans\n", "    return pow(2, n, p)\n\n",
  "    return 2 ** n % p\n\n@functools.lru_cache(maxsize=None)", "    return 2 **\
    \ n % p\n\n", "    if n <= 0:\n        return 1\n    if n == 1:\n        return\
    \ 2\n    u = modp(n // 2, p)\n    u = u * u % p\n    if n % 2 == 1:\n        u\
    \ = u * 2 % p\n    return u\n\n", "    res = 1\n    for _ in range(n):\n     \
    \   res = (res * 2) % p\n    return res\n\n", "    if n == 0:\n        return\
    \ 1\n    if n % 2 == 0:\n        return modp(n // 2, p) ** 2 % p\n    return 2\
    \ * modp(n - 1, p) % p\n\n", "    ret = 1\n    for _ in range(n):\n        ret\
    \ = ret * 2 % p\n    return ret\n\n", "    if n == 0:\n        return 1\n    if\
    \ n == 1:\n        return 2\n    else:\n        return pow(2, n % (p - 1), p)\n\
    \n", "    a = 1\n    b = 1\n    while n > 0:\n        if n % 2 == 1:\n       \
    \     a = a * b % p\n        b = b * b % p\n        n //= 2\n    return a\n\n",
  "    assert isinstance(n, int) and isinstance(p, int)\n    if n == 0:\n        return\
    \ 1\n    r = modp(n // 2, p)\n    r = r * r % p\n    if n % 2:\n        r = r\
    \ * 2 % p\n    return r\n\n", "    exponent = 0\n    while (1 << exponent) <=\
    \ n:\n        exponent += 1\n    m = 1\n    while exponent > 0:\n        exponent\
    \ -= 1\n        m = (m << 1) % p\n        if (1 << exponent) & n:\n          \
    \  m = (m * 2) % p\n    return m\n", "    if n == 0:\n        return 1\n    elif\
    \ n == 1:\n        return 2\n    elif n % 2 == 0:\n        return modp(n // 2,\
    \ p) ** 2 % p\n    else:\n        return (modp(n // 2, p) ** 2 * 2) % p\n\n",
  "    return 2 ** n % p\n\n", "    res = 1\n    for _ in range(n):\n        res =\
    \ res * 2 % p\n    return res\n", "    res = 1\n    for i in range(n):\n     \
    \   res = res * 2 % p\n    return res\n\n", "    # https://en.wikipedia.org/wiki/Modular_exponentiation\n\
    \    r = 1\n    while n:\n        if n & 1:\n            r = (r * 2) % p\n   \
    \     n >>= 1\n    return r\n\n", "    power = 1\n    while n > 0:\n        if\
    \ n % 2 == 1:\n            power = (power * 2) % p\n        n = n // 2\n    return\
    \ power\n\n", "    if n == 0:\n        return 1\n    u = modp(n // 2, p)\n   \
    \ u = u * u % p\n    if n % 2 == 1:\n        u = u * 2 % p\n    return u\n\n",
  "    # assert n >= 0\n    bin = bin_value(n)\n    r = 1\n    for bit in bin:\n \
    \       r = (r * r) % p\n        if bit == 1:\n            r = (r * 2) % p\n \
    \   return r\n\n", "    r = 1\n    for k in range(n):\n        r = (r * 2) % p\n\
    \    return r\n", "    return pow(2, n, p)\n\n", "    if n == 0:\n        return\
    \ 1\n    elif n == 1:\n        return 2\n    elif n % 2 == 0:\n        return\
    \ modp(n // 2, p) ** 2 % p\n    else:\n        return (modp(n // 2, p) ** 2 *\
    \ 2) % p\n\n", "    return ((2 ** n) % p)\n\n", "    # Use exponentiation by squaring\n\
    \    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return modp(n\
    \ // 2, p) ** 2 % p\n    else:\n        return 2 * modp(n - 1, p) % p\n\n", " \
    \   res = 1\n    while n > 0:\n        res = res * 2 % p\n        n -= 1\n   \
    \ return res\n\n", "    res = 1\n    for i in range(n):\n        res = res * 2\
    \ % p\n    return res\n", "    # TODO: implement me\n    a = 2\n    if n == 0:\n\
    \        return 1\n    elif n == 1:\n        return a % p\n    elif n % 2 == 0:\n\
    \        return (modp(n // 2, p) ** 2) % p\n    else:\n        return (modp(n\
    \ - 1, p) * modp(1, p)) % p\n\n", "    if n == 0:\n        return 1\n    if n\
    \ == 1:\n        return 2 % p\n    assert n >= 0\n    res = 1\n    while n:\n\
    \        if n & 1:\n            res = res * 2 % p\n        n >>= 1\n        if\
    \ n:\n            res = res * res % p\n    return res\n\n", "    return 2 ** n\
    \ % p\n", "    if n == 0:\n        return 1\n    if n % 2 == 0:\n        return\
    \ modp(n//2, p)**2 % p\n    return 2 * modp(n-1, p) % p\n", "    # return p if\
    \ n < 0 else pow(2, n, p)\n    return p if n < 0 else pow(2, n % (p - 1), p)\n\
    \n", "    if n == 0:\n        return 1\n    x = 2\n    for i in range(n - 1):\n\
    \        x = (x * 2) % p\n    return x\n", "    return pow(2, n, p)\n\n", "  \
    \  if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return modp(n //\
    \ 2, p) ** 2 % p\n    else:\n        return 2 * modp(n - 1, p) % p\n\n", "   \
    \ ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = (ans *\
    \ 2) % p\n        n = n // 2\n    return ans\n\n", "    if n == 0:\n        return\
    \ 1\n    power = 1\n    a = 2\n    while n > 1:\n        if n % 2 == 1:\n    \
    \        power = (power * a) % p\n        a = (a * a) % p\n        n = n // 2\n\
    \    return (power * a) % p\n\n", "    if n == 0:\n        return 1\n    elif\
    \ n == 1:\n        return 2\n    elif n % 2 == 0:\n        return (modp(n//2,\
    \ p)**2) % p\n    else:\n        return (2 * modp(n-1, p)) % p\n\n", "    if p\
    \ == 2:\n        return 1\n    m = modp(n, p - 1)\n    if n % 2 == 0:\n      \
    \  return (m * m) % p\n    else:\n        return (2 * m * m) % p\n\n", "    res\
    \ = 1\n    for i in range(n):\n        res = res * 2 % p\n    return res\n", " \
    \   res = 1\n    base = 2\n    power = n\n    while power > 0:\n        if power\
    \ % 2 == 1:\n            res = (res * base) % p\n        base = (base * base)\
    \ % p\n        power = power // 2\n    return res\n\n", "    #return (2**n) %\
    \ p\n    return pow(2, n, p)\n", "    if n == 0:\n        return 1\n    if n %\
    \ 2 == 0:\n        return (modp(n // 2, p) ** 2) % p\n    return (2 * modp(n -\
    \ 1, p)) % p\n\n", "    if n == 0:\n        return 1\n    elif n == 1:\n     \
    \   return 2\n    else:\n        return (2 * modp(n - 1, p)) % p\n\n", "    return\
    \ pow(2, n, p)\n\n", "    s = 1\n    t = 2\n    while n > 0:\n        if n % 2\
    \ == 1:\n            s = (s * t) % p\n        t = (t * t) % p\n        n = n //\
    \ 2\n    return s\n\n", "    result = 1\n    for _ in range(n):\n        result\
    \ = (result * 2) % p\n    return result\n\n", "    assert p > 0\n    if p <= 3:\n\
    \        if p == 2:\n            return (n % 2) + 1\n        else:\n         \
    \   return ((n % p) ** 2) % p\n    else:\n        acc = modp(n // 2, p)\n    \
    \    acc = acc * acc % p\n        if n % 2 == 1:\n            acc = acc * 2 %\
    \ p\n        return acc\n\n", "    if n == 0:\n        return 1\n    if n == 1:\n\
    \        return 2 % p\n    if n % 2 == 0:\n        r = modp(n // 2, p)\n     \
    \   return (r * r) % p\n    else:\n        r = modp(n // 2, p)\n        return\
    \ (2 * r * r) % p\n\n", "    if n == 0:\n        return 1\n    if n % 2 == 0:\n\
    \        return modp(n // 2, p) ** 2 % p\n    else:\n        return 2 * modp(n\
    \ - 1, p) % p\n\n", "    if n > 1000000:\n        raise ValueError(\"n too large\"\
    )\n    if n == 0:\n        return 1\n    s = modp(n // 2, p)\n    if n % 2 ==\
    \ 0:\n        return s * s % p\n    else:\n        return 2 * s * s % p\n\n",
  "    if n == 0:\n        return 1\n    elif n == 1:\n        return 2\n    else:\n\
    \        x = modp(n//2, p)\n        x = (x * x) % p\n        if n % 2 == 1:\n\
    \            x = (x * 2) % p\n        return x\n", "    return pow(2, n, p)\n",
  "    if n == 0:\n        return 1\n    elif n == 1:\n        return 2\n    elif\
    \ n % 2 == 0:\n        return (modp(n // 2, p) ** 2) % p\n    else:\n        return\
    \ (2 * modp(n - 1, p)) % p\n", "    n = n % p\n    res = 1\n    for _ in range(n):\n\
    \        res = (res * 2) % p\n    return res\n\n", "    if p < 0:\n        p =\
    \ -p\n    result = 1\n    factor = 2\n    while n > 0:\n        if n % 2 == 1:\n\
    \            result = (result * factor) % p\n        factor = (factor * factor)\
    \ % p\n        n = n // 2\n    return result\n\n", "    if n == 0:\n        return\
    \ 1\n    if n % 2 == 0:\n        return (modp(n // 2, p) ** 2) % p\n    return\
    \ (2 * modp(n - 1, p)) % p\n\n", "    return pow(2, n, p)\n\n", "    assert p\
    \ > 0\n    assert n >= 0\n    return fast_exp(2, n, p)\n\n", "    res = 1\n  \
    \  while n:\n        if n % 2:\n            res = (res * 2) % p\n        n //=\
    \ 2\n    return res\n\n", "    res = 1\n    while n > 0:\n        if n % 2 ==\
    \ 1:\n            res = (res * 2) % p\n        n //= 2\n    return res\n\n", " \
    \   x = 1\n    for _ in range(n):\n        x = (x * 2) % p\n    return x\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
