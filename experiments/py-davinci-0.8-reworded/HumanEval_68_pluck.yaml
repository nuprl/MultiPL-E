name: HumanEval_68_pluck
language: py
prompt: "from typing import List\n\ndef pluck(arr: List[int]) -> List[int]:\n    \"\
  \"\"\n    \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n    your task is to pluck one of the nodes and return it.\n   \
  \ The plucked node should be the node with the smallest even value.\n    If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n\n    The plucked node should be returned in a list, [ smalest_value,\
  \ its index ],\n    If there are no even values or the given array is empty, return\
  \ [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n    [2, 1]\n    Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n\
  \    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation: 2 has the smallest even\
  \ value, and 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n  \
  \  []\n    \n    Example 4:\n    >>> pluck([5, 0, 3, 0, 4, 2])\n    [0, 1]\n   \
  \ Explanation: 0 is the smallest value, but  there are two zeros,\n            \
  \     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n\
  \        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([4, 2, 3]) == [2, 1]\n    assert\
  \ candidate([1, 2, 3]) == [2, 1]\n    assert candidate([]) == []\n    assert candidate([5,\
  \ 0, 3, 0, 4, 2]) == [0, 1]\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n\
  \    assert candidate([5, 4, 8, 4, 8]) == [4, 1]\n    assert candidate([7, 6, 7,\
  \ 1]) == [6, 1]\n    assert candidate([7, 9, 7, 1]) == []\n\ndef test_check():\n\
  \    check(pluck)\n\ntest_check()\n"
completions: ["    if len(arr) == 0:\n        return []\n    evens = [e for e in arr\
    \ if e % 2 == 0]\n    if len(evens) == 0:\n        return []\n    return [min(evens),\
    \ arr.index(min(evens))]\n", "    evens = [arr[i] for i in range(len(arr)) if\
    \ arr[i] % 2 == 0]\n    if not evens:\n        return []\n    smallest = min(evens)\n\
    \    return [smallest, arr.index(smallest)]", "    if not arr:\n        return\
    \ []\n    even_vals = [x for x in arr if x % 2 == 0]\n    if not even_vals:\n\
    \        return []\n    ind = min(even_vals)\n    return [ind, arr.index(ind)]",
  "    out = []\n    evens = [x for x in arr if x % 2 == 0]\n    if evens:\n     \
    \   out.append(min(evens))\n        out.append(arr.index(out[0]))\n    return\
    \ out\n", "    small_idx = 0\n    result = []\n    for idx, val in enumerate(arr):\n\
    \        if val == 0:\n            result = [0, idx]\n            break\n    \
    \    if val % 2 == 0 and val < arr[small_idx]:\n            small_idx = idx\n\
    \    if len(result) == 0 and small_idx != 0:\n        result = [arr[small_idx],\
    \ small_idx]\n    return result", "    evens = [v for v in arr if v % 2 == 0]\n\
    \    if evens:\n        min_even = min(evens)\n        return [min_even, arr.index(min_even)]\n\
    \    return []\n", "    if not arr:\n        return []\n    elif len(arr) == 1:\n\
    \        return [arr[0], 0] if arr[0] % 2 == 0 else []\n    else:\n        evens\
    \ = [x for x in arr if x % 2 == 0]\n        if not evens:\n            return\
    \ []\n        else:\n            min_even = min(evens)\n            return [min_even,\
    \ arr.index(min_even)]\n", "    smallest_even = 9999999999\n    smallest_index\
    \ = 9999999999\n    for i, v in enumerate(arr):\n        if v % 2 == 0 and v <\
    \ smallest_even:\n            smallest_even = v\n            smallest_index =\
    \ i\n    if smallest_even < 9999999999:\n        return [smallest_even, smallest_index]\n\
    \    return []", "    smallest_value = None\n    smallest_index = None\n    for\
    \ index, node in enumerate(arr):\n        if node % 2 == 0:\n            if smallest_value\
    \ is None or node < smallest_value:\n                smallest_value = node\n \
    \               smallest_index = index\n    if smallest_value is None:\n     \
    \   return []\n    return [smallest_value, smallest_index]\n", "    min_even =\
    \ [10002, 10000]\n\n    # Iterate from the end of the array\n    for i in range(len(arr)\
    \ - 1, -1, -1):\n        if arr[i] % 2 == 0 and arr[i] < min_even[0]:\n      \
    \      min_even = [arr[i], i]\n    if min_even[0] == 10002:\n        return []\n\
    \    return min_even\n", "    smallest_even_idx = min((idx for idx, value in enumerate(arr)\
    \ if value % 2 == 0), default=None)\n    if smallest_even_idx is None:\n     \
    \   return []\n    return [arr[smallest_even_idx], smallest_even_idx]\n", "  \
    \  if not arr:\n        return []\n    even_min = min(n for n in arr if n % 2\
    \ == 0)\n    min_index = arr.index(even_min)\n    return [even_min, min_index]",
  "    evens = [x for x in arr if x % 2 == 0]\n    if evens:\n        return [min(evens),\
    \ arr.index(min(evens))]\n    return []\n", "    evens = [num for num in arr if\
    \ num % 2 == 0]\n    min_value = min(evens) if evens else None\n    try:\n   \
    \     return [min_value, arr.index(min_value)]\n    except ValueError:\n     \
    \   return []", "    # Make a list of the values that are even\n    # Sort them\n\
    \    # Pluck the first one from the array (and its index)\n    even_values = [value\
    \ for value in arr if value % 2 == 0]\n    even_values.sort()\n    if even_values:\n\
    \        return [even_values[0], arr.index(even_values[0])]\n    return []", " \
    \   pass\n", "    evens = [n for n in arr if n % 2 == 0]\n    if evens:\n    \
    \    index = arr.index(min(evens))\n        return [min(evens), index]\n    return\
    \ []\n", "    if len(arr) == 0:\n        return []\n    evens = []\n    evens_indices\
    \ = []\n    for i, val in enumerate(arr):\n        if val % 2 == 0:\n        \
    \    evens.append(val)\n            evens_indices.append(i)\n    if len(evens)\
    \ == 0:\n        return []\n    min_even = min(evens)\n    min_even_index = min(evens_indices)\n\
    \    return [min_even, min_even_index]", "    sorted_arr = sorted(arr)\n    smallest_even\
    \ = -1\n    for i in sorted_arr:\n        if i % 2 == 0:\n            smallest_even\
    \ = i\n            break\n    if smallest_even == -1:\n        return []\n   \
    \ return [smallest_even, arr.index(smallest_even)]\n    \n    ", "    even_array\
    \ = sorted([i for i in arr if i % 2 == 0])\n    if even_array:\n        smallest_index\
    \ = min([index for index, value in enumerate(arr) if value == even_array[0]])\n\
    \        return [even_array[0], smallest_index]\n    return []"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
