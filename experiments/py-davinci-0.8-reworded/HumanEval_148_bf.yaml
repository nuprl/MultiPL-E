name: HumanEval_148_bf
language: py
prompt: "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str,\
  \ ...]:\n    \"\"\"\n    There are eight planets in our solar system: the closerst\
  \ to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter,\
  \ Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names\
  \ as strings planet1 and planet2. \n    The function should return a tuple containing\
  \ all planets whose orbits are \n    located between the orbit of planet1 and the\
  \ orbit of planet2, sorted by \n    the proximity to the sun. \n    The function\
  \ should return an empty tuple if planet1 or planet2\n    are not correct planet\
  \ names. \n    Examples\n    >>> bf('Jupiter', 'Neptune')\n    ('Saturn', 'Uranus')\n\
  \    >>> bf('Earth', 'Mercury')\n    'Venus'\n    >>> bf('Mercury', 'Uranus')\n\
  \    ('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate('Jupiter', 'Neptune') == ('Saturn',\
  \ 'Uranus')\n    assert candidate('Earth', 'Mercury') == ('Venus',)\n    assert\
  \ candidate('Mercury', 'Uranus') == ('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')\n\
  \    assert candidate('Neptune', 'Venus') == ('Earth', 'Mars', 'Jupiter', 'Saturn',\
  \ 'Uranus')\n    assert candidate('Earth', 'Earth') == ()\n    assert candidate('Mars',\
  \ 'Earth') == ()\n    assert candidate('Jupiter', 'Makemake') == ()\n\ndef test_check():\n\
  \    check(bf)\n\ntest_check()\n"
completions: ["    planets = ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn',\
    \ 'Uranus', 'Neptune')\n    if planet1 not in planets or planet2 not in planets:\n\
    \        return ()\n    start = planets.index(planet1)\n    end = planets.index(planet2)\n\
    \    if start < end:\n        planets = planets[start+1:end]\n    else:\n    \
    \    planets = planets[end+1:start]\n    return tuple(planets)", "    planets\
    \ = (\n        'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus',\n\
    \        'Neptune'\n    )\n    if planet1 not in planets or planet2 not in planets:\n\
    \        return ()\n    if planets.index(planet1) < planets.index(planet2):\n\
    \        return planets[planets.index(planet1) + 1:planets.index(planet2)]\n \
    \   else:\n        return planets[planets.index(planet2) + 1:planets.index(planet1)]",
  "    list = []\n    planet_list = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter',\
    \ 'Saturn', 'Uranus', 'Neptune']\n    if planet1 in planet_list and planet2 in\
    \ planet_list:\n        for i in range(len(planet_list)):\n            if planet_list[i]\
    \ == planet1:\n                first = i\n            if planet_list[i] == planet2:\n\
    \                second = i\n        if first < second:\n            for i in\
    \ range(first + 1, second):\n                list.append(planet_list[i])\n   \
    \     else:\n            for i in range(second + 1, first):\n                list.append(planet_list[i])\n\
    \        return tuple(list)\n    else:\n        return ()", "    planets = ['Mercury',\
    \ 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if\
    \ planet1 not in planets or planet2 not in planets:\n        return ()\n    min_planet\
    \ = planets.index(planet1)\n    max_planet = planets.index(planet2)\n    if min_planet\
    \ > max_planet:\n        min_planet, max_planet = max_planet, min_planet\n   \
    \ return tuple(planets[(min_planet + 1):max_planet])", "    planets = ('Mercury',\
    \ 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune')\n    if\
    \ planet1 not in planets or planet2 not in planets:\n        return ()\n    lower_bound\
    \ = planets.index(planet1)\n    upper_bound = planets.index(planet2)\n    if lower_bound\
    \ < upper_bound:\n        return planets[lower_bound+1:upper_bound]\n    else:\n\
    \        return planets[upper_bound+1:lower_bound]", "    planets = ('Mercury',\
    \ 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', \n    'Uranus', 'Neptune')\n\
    \    planet1_ind = planets.index(planet1)\n    planet2_ind = planets.index(planet2)\n\
    \    if planet1_ind < planet2_ind:\n        return tuple(planets[planet1_ind+1:planet2_ind])\n\
    \    else:\n        return tuple(planets[planet2_ind+1:planet1_ind])\n", "   \
    \ list_of_planets = ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn',\
    \ 'Uranus', 'Neptune')\n    planet1 = planet1.title()\n    planet2 = planet2.title()\n\
    \    if planet1 not in list_of_planets or planet2 not in list_of_planets:\n  \
    \      return ()\n    if list_of_planets.index(planet1) < list_of_planets.index(planet2):\n\
    \        return tuple(list_of_planets[list_of_planets.index(planet1)+1:list_of_planets.index(planet2)])\n\
    \    else:\n        return tuple(list_of_planets[list_of_planets.index(planet2)+1:list_of_planets.index(planet1)])\n",
  "    planets = ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus',\
    \ 'Neptune')\n    if planet1 not in planets or planet2 not in planets:\n     \
    \   return ()\n    f = planets.index(planet1)\n    s = planets.index(planet2)\n\
    \    min_ = min(f, s)\n    max_ = max(f, s)\n    return tuple(planets[min_+1:max_])\n",
  "    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus',\
    \ 'Neptune']\n    distances = []\n    for i in range(len(planets)):\n        distances.append(abs(planets.index(planet1)\
    \ - planets.index(planet2)))\n    if planet1 in planets and planet2 in planets:\n\
    \        return tuple(planets[min(distances):max(distances)])\n    else:\n   \
    \     return ()\n", "    planet_list = ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter',\
    \ 'Saturn', 'Uranus', 'Neptune')\n    p1 = planet_list.index(planet1)\n    p2\
    \ = planet_list.index(planet2)\n    if p1 > p2:\n        return tuple(planet_list[p2+1:p1])\n\
    \    else:\n        return tuple(planet_list[p1+1:p2])\n", "    orbit_order =\
    \ ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune')\n\
    \    planet1_index = orbit_order.index(planet1)\n    planet2_index = orbit_order.index(planet2)\n\
    \    if planet1_index > planet2_index:\n        # to swap value so that planet1\
    \ < planet2\n        planet1_index, planet2_index = planet2_index, planet1_index\n\
    \    selected_planets = orbit_order[planet1_index+1:planet2_index]\n    return\
    \ tuple(selected_planets)\n\nprint(bf('Jupiter', 'Neptune'))", "    planets =\
    \ ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune')\n\
    \    if planet1 not in planets or planet2 not in planets:\n        return ()\n\
    \    a = planets.index(planet1)\n    b = planets.index(planet2)\n    if a < b:\n\
    \        return tuple(planets[a + 1:b])\n    else:\n        return tuple(planets[b\
    \ + 1:a])\n\nprint(bf('Jupiter', 'Neptune'))\nprint(bf('Earth', 'Mercury'))\n\
    print(bf('Mercury', 'Uranus'))", "    order = {'Mercury': 0, 'Venus': 1, 'Earth':\
    \ 2, 'Mars': 3, 'Jupiter': 4, 'Saturn': 5, 'Uranus': 6, 'Neptune': 7}\n    planets\
    \ = ()\n    planet1 = order.get(planet1)\n    planet2 = order.get(planet2)\n \
    \   if planet1 and planet2:\n        if planet1 > planet2:\n            planet1,\
    \ planet2 = planet2, planet1\n        planets = tuple(sorted(order.keys(), key=lambda\
    \ x: order[x]))[planet1:planet2]\n    return planets", "    ...\n\n", "    assert\
    \ isinstance(planet1, str)\n    assert isinstance(planet2, str)\n    if planet1\
    \ not in ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus',\
    \ 'Neptune'):\n        return ()\n    if planet2 not in ('Mercury', 'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'):\n        return ()\n    planets\
    \ = ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune')\n\
    \    return tuple(planets[planets.index(planet1):planets.index(planet2)])", " \
    \   planets = ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus',\
    \ 'Neptune')\n    for p in planets:\n        if p == planet1:\n            start\
    \ = planets.index(p)\n        if p == planet2:\n            stop = planets.index(p)\n\
    \    return planets[start+1:stop]\n", "    planets = [\"Mercury\", \"Venus\",\
    \ \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n   \
    \ if planet1 not in planets or planet2 not in planets:\n        return ()\n  \
    \  idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    return\
    \ tuple(planets[idx1+1:idx2])\n\nprint(bf('Jupiter', 'Neptune'))\nprint(bf('Earth',\
    \ 'Mercury'))\nprint(bf('Mercury', 'Uranus'))", "    pass\n\n", "    planet1_i\
    \ = 0\n    planet2_i = 0\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    for i in range(len(planets)):\n\
    \        if planets[i] == planet1:\n            planet1_i = i\n        if planets[i]\
    \ == planet2:\n            planet2_i = i\n    if planet1_i == 0 or planet2_i ==\
    \ 0:\n        return ()\n    elif planet1_i < planet2_i:\n        return tuple(planets[planet1_i\
    \ + 1:planet2_i])\n    else:\n        return tuple(planets[planet2_i + 1:planet1_i])\n\
    \    ", "    planets = ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn',\
    \ 'Uranus', 'Neptune')\n    if planet1 not in planets or planet2 not in planets:\n\
    \        return ()\n    if planets.index(planet1) > planets.index(planet2):\n\
    \        return ()\n    return tuple(planets[planets.index(planet1) + 1:planets.index(planet2)])\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
