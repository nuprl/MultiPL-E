name: HumanEval_119_match_parens
language: py
prompt: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n   \
  \ \"\"\"\n    You are given a list of two strings, both strings consist of open\n\
  \    parentheses '(' or close parentheses ')' only.\n    Your job is to check if\
  \ it is possible to concatenate the two strings in\n    some order, that the resulting\
  \ string will be good.\n    A string S is considered to be good if and only if all\
  \ parentheses in S\n    are balanced. For example: the string '(())()' is good,\
  \ while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make\
  \ a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens(['()(',\
  \ ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n    'No'\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
  \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
  \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
  \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
  \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
  \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
  \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
  \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
completions: ["    s = ''.join(lst)\n    num_open, num_close = 0, 0\n    for paren\
    \ in s:\n        if paren == '(':\n            num_open += 1\n        else:\n\
    \            num_close += 1\n        if num_close > num_open:\n            return\
    \ 'No'\n    return 'Yes' if num_open == num_close else 'No'", "    str1, str2\
    \ = lst[0], lst[1]\n    count1, count2 = 0, 0\n    for i in str1:\n        if\
    \ i == '(':\n            count1 += 1\n        else:\n            count1 -= 1\n\
    \    for i in str2:\n        if i == '(':\n            count2 += 1\n        else:\n\
    \            count2 -= 1\n    total = count1 + count2\n    # when total is positive,\
    \ need more ')'\n    # when total is negative, need more '('\n    # when total\
    \ is zero, need zero more '(' or ')'\n    if total < 0:\n        str1 = str1 +\
    \ str2\n        while total < 0:\n            str1 = str1 + ')'\n            total\
    \ += 1\n        return str1\n    elif total > 0:\n        str1 = str1 + str2\n\
    \        while total > 0:\n            str1 = str1 + '('\n            total -=\
    \ 1\n        return str1\n    else:\n        return str1 + str2\n", "    ret =\
    \ 'Yes'\n    if lst[0].count('(') > lst[1].count('('):\n        return ret\n \
    \   if lst[0].count(')') > lst[1].count(')'):\n        return ret\n    tmp = lst[0]\
    \ + lst[1]\n    stk = []\n    for c in tmp:\n        if c == '(':\n          \
    \  stk.append(c)\n        else:\n            if not stk:\n                return\
    \ 'No'\n            stk.pop()\n    if stk:\n        return 'No'\n    return ret",
  "    S = []\n    for c in lst[0]:\n        if c == '(':\n            S.append(c)\n\
    \        else:\n            S.pop()\n    for c in lst[1]:\n        if c == '(':\n\
    \            S.append(c)\n        else:\n            if len(S) > 0:\n        \
    \        S.pop()\n            else:\n                return 'No'\n    if len(S)\
    \ == 0:\n        return 'Yes'\n    else:\n        return 'No'\n", "    parens\
    \ = lst[0] + lst[1]\n    if parens[0] == ')':\n        return 'No'\n    depth\
    \ = 0\n    for paren in parens:\n        if paren == '(':\n            depth +=\
    \ 1\n        else:\n            depth -= 1\n        if depth < 0:\n          \
    \  return 'No'\n    if depth == 0:\n        return 'Yes'\n    return 'No'\n",
  "    s1, s2 = lst\n    # Concatenate the strings, with each possible permutation.\n\
    \    strings = [s1 + s2, s2 + s1]\n    # Iterate over each string, keeping track\
    \ of how many open and closed parens\n    # there are in the string.\n    for\
    \ s in strings:\n        open_parens = 0\n        close_parens = 0\n        for\
    \ c in s:\n            if c == '(':\n                open_parens += 1\n      \
    \      elif c == ')':\n                if open_parens:\n                    open_parens\
    \ -= 1\n                else:\n                    close_parens += 1\n       \
    \ # If there's a permutation that has no open or closed parens, then it's a good\
    \ string.\n        if open_parens == 0 and close_parens == 0:\n            return\
    \ 'Yes'\n    return 'No'\n", "    left, right = lst\n    if right.count(')') >\
    \ left.count('('):\n        return 'No'\n    if not left:\n        return 'Yes'\n\
    \    if left[0] == ')':\n        if right[0] == ')':\n            return match_parens([left[1:],\
    \ right[1:]])\n        return match_parens([left[1:], right])\n    else:\n   \
    \     if right[0] == ')':\n            return match_parens([left, right[1:]])\n\
    \        return match_parens([left[1:], right])\n", "    return 'Yes' if lst[0].count('(')\
    \ == lst[1].count(')') else 'No'\n", "    def _is_par_matched(s: str) -> bool:\n\
    \        par_cnt = 0\n        for ch in s:\n            if ch == '(':\n      \
    \          par_cnt += 1\n            elif ch == ')':\n                par_cnt\
    \ -= 1\n            if par_cnt < 0:\n                return False\n        return\
    \ par_cnt == 0\n\n    if not _is_par_matched(lst[0]):\n        return 'No'\n \
    \   elif _is_par_matched(lst[0] + lst[1]):\n        return 'Yes'\n    else:\n\
    \        return 'No'\n", "    left, right = 0, 0\n    for i in lst[0]:\n     \
    \   if i == '(':\n            left += 1\n        else:\n            left -= 1\n\
    \    for i in lst[1]:\n        if i == '(':\n            right += 1\n        else:\n\
    \            right -= 1\n    if left + right == 0:\n        return 'Yes'\n   \
    \ return 'No'\n", "    left = 0\n    right = 0\n    for c in lst[0]:\n       \
    \ if c == '(':\n            left += 1\n        else:\n            right += 1\n\
    \    if left == right:\n        return 'Yes'\n    else:\n        return 'No'\n",
  "    res = lst[0] + lst[1]\n    count = 0\n    for c in res:\n        if c == '(':\n\
    \            count += 1\n        else:\n            count -= 1\n        if count\
    \ < 0:\n            return 'No'\n    return 'Yes' if count == 0 else 'No'\n",
  "    stack1 = []\n    stack2 = []\n    for char in lst[0]:\n        if char == '(':\n\
    \            stack1.append(char)\n        else:\n            if stack1:\n    \
    \            stack1.pop()\n            else:\n                stack2.append(char)\n\
    \    for char in lst[1]:\n        if char == '(':\n            if stack2:\n  \
    \              stack2.pop()\n            else:\n                stack1.append(char)\n\
    \        else:\n            if stack1:\n                stack1.pop()\n       \
    \     else:\n                stack2.append(char)\n    if not stack1 and not stack2:\n\
    \        return 'Yes'\n    return 'No'\n", "    if lst[0][0] == ')' or lst[1][0]\
    \ == ')':\n        return 'No'\n    if lst[0][-1] == '(' or lst[1][-1] == '(':\n\
    \        return 'No'\n    if '()' in lst[0] + lst[1]:\n        return 'Yes'\n\
    \    if ')(' in lst[0] + lst[1]:\n        return 'Yes'\n    if ')(' in lst[0]\
    \ + lst[1][::-1]:\n        return 'Yes'\n    if '()' in lst[0] + lst[1][::-1]:\n\
    \        return 'Yes'\n    return 'No'", "    stack = []\n    for c in lst[0]:\n\
    \        if c == '(':\n            stack.append(c)\n        else:\n          \
    \  if stack:\n                stack.pop()\n            else:\n               \
    \ return 'No'\n    for c in lst[1]:\n        if c == '(':\n            stack.append(c)\n\
    \        else:\n            if stack:\n                stack.pop()\n         \
    \   else:\n                return 'No'\n    if stack:\n        return 'No'\n \
    \   return 'Yes'", "    if lst[0][0] == ')' or lst[1][0] == ')':\n        return\
    \ 'No'\n    return 'Yes'\n", "    if lst[0][0] == ')' or lst[1][0] == ')':\n \
    \       return 'No'\n    elif lst[0][0] == '(' and lst[1][0] == '(':\n       \
    \ return 'Yes'\n    else:\n        return 'No'\n", "    s = ''.join(lst)\n   \
    \ if len(s) % 2 == 1:\n        return 'No'\n    num_open = 0\n    for ch in s:\n\
    \        if ch == '(':\n            num_open += 1\n        else:\n           \
    \ num_open -= 1\n        if num_open < 0:\n            return 'No'\n    return\
    \ 'Yes' if num_open == 0 else 'No'\n", "    counter = 0\n    for c in lst[0]:\n\
    \        if c == '(':\n            counter += 1\n        else:\n            counter\
    \ -= 1\n    for c in lst[1]:\n        if c == '(':\n            counter += 1\n\
    \        else:\n            counter -= 1\n    return 'Yes' if counter == 0 else\
    \ 'No'\n", "    cnt = 0\n    s = ''.join(lst)\n    for c in s:\n        if c ==\
    \ '(':\n            cnt += 1\n        elif c == ')':\n            cnt -= 1\n \
    \       if cnt < 0:\n            return 'No'\n    return 'Yes' if cnt == 0 else\
    \ 'No'"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
