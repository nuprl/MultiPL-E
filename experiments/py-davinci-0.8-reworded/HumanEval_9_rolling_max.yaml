name: HumanEval_9_rolling_max
language: py
prompt: "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n\
  \    \"\"\" From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3,\
  \ 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1,\
  \ 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n\
  \    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n\ndef test_check():\n\
  \    check(rolling_max)\n\ntest_check()\n"
completions: ["    rolling_max = numbers[0]\n    result = [rolling_max]\n    for i\
    \ in range(1, len(numbers)):\n        if numbers[i] > rolling_max:\n         \
    \   rolling_max = numbers[i]\n        result.append(rolling_max)\n    return result\n",
  "    # TODO: Implement this function.\n    return []\n", "    print(numbers)\n \
    \   # max_so_far = numbers[0]\n    # rolling_max = [max_so_far]\n    # for x in\
    \ numbers[1:]:\n    #     if x > max_so_far:\n    #         max_so_far = x\n \
    \   #     rolling_max.append(max_so_far)\n    # return rolling_max\n", "    if\
    \ len(numbers) == 0:\n        return []\n    else:\n        return [max(numbers[:i\
    \ + 1]) for i in range(len(numbers))]\n\n", "    output = []\n    max_so_far =\
    \ None\n    for num in numbers:\n        if max_so_far is None or num > max_so_far:\n\
    \            max_so_far = num\n        output.append(max_so_far)\n    return output\n\
    \n", "    # Precompute values\n    current_max = max(numbers)\n    result = [current_max]\n\
    \n    # Compute remaining values\n    for index in range(1, len(numbers)):\n \
    \       current_max = max(current_max, numbers[index])\n        result.append(current_max)\n\
    \n    return result\n", "    res = [max(numbers[:i+1]) for i in range(len(numbers))]\n\
    \    return res\n", "    result = []\n    maximum = numbers[0]\n    for i in range(len(numbers)):\n\
    \        if numbers[i] > maximum:\n            maximum = numbers[i]\n        result.append(maximum)\n\
    \    return result\n\nprint(rolling_max([1, 2, 3, 2, 3, 4, 2]))", "    if not\
    \ numbers:\n        return []\n    numbers_reversed = numbers[::-1]\n    max_elements\
    \ = [max(numbers_reversed[:i + 1]) for i in range(len(numbers_reversed))]\n  \
    \  return max_elements[::-1]\n", "    max_values = []\n    current_max = -1\n\
    \    for element in numbers:\n        if element > current_max:\n            current_max\
    \ = element\n        max_values.append(current_max)\n    return max_values\n",
  "    max_elems = [numbers[0]]\n    for i in range(1, len(numbers)):\n        max_elems.append(max(max_elems[i-1],\
    \ numbers[i]))\n    return max_elems\n\n", "    maximum = numbers[0]\n    for\
    \ i in range(1, len(numbers)):\n        maximum = max(maximum, numbers[i])\n \
    \       numbers[i] = maximum\n    return numbers\n", "    current_max = numbers[0]\n\
    \    current_max_list = [current_max]\n    for i in range(1, len(numbers)):\n\
    \        if numbers[i] > current_max:\n            current_max = numbers[i]\n\
    \        current_max_list.append(current_max)\n    return current_max_list\n",
  "    result = []\n    max_val = 0\n    for number in numbers:\n        if number\
    \ > max_val:\n            max_val = number\n        result.append(max_val)\n \
    \   return result\n", "    if len(numbers) == 0:\n        return []\n    result\
    \ = [numbers[0]]\n    for i in range(1, len(numbers)):\n        if numbers[i]\
    \ > result[-1]:\n            result.append(numbers[i])\n        else:\n      \
    \      result.append(result[-1])\n    return result\n", "    output = []\n   \
    \ maximum = numbers[0]\n    for num in numbers:\n        if num > maximum:\n \
    \           maximum = num\n        output.append(maximum)\n    return output\n",
  "    rolling_max = []\n    current_max = numbers[0]\n    rolling_max.append(current_max)\n\
    \    for number in numbers[1:]:\n        if number > current_max:\n          \
    \  current_max = number\n        rolling_max.append(current_max)\n    return rolling_max\n\
    \n", "    max_so_far = []\n    for index, item in enumerate(numbers):\n      \
    \  if index == 0:\n            max_so_far.append(item)\n        else:\n      \
    \      max_so_far.append(max(max_so_far[index - 1], item))\n    return max_so_far\n\
    \n", "    result = []\n    current_max = 0\n    for n in numbers:\n        if\
    \ n > current_max:\n            current_max = n\n        result.append(current_max)\n\
    \    return result", "    current_max = numbers[0]\n    max_list = [current_max]\n\
    \    for number in numbers[1:]:\n        if number > current_max:\n          \
    \  current_max = number\n        max_list.append(current_max)\n    return max_list\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
