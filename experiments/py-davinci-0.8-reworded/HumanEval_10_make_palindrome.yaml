name: HumanEval_10_make_palindrome
language: py
prompt: "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome\
  \ that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find\
  \ the longest postfix of supplied string that is a palindrome.\n    - Append to\
  \ the end of the string reverse of a string prefix that comes before the palindromic\
  \ suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n\
  \    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x')\
  \ == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') ==\
  \ 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n\ndef test_check():\n   \
  \ check(make_palindrome)\n\ntest_check()\n"
completions: ["    # Shortcut for empty string\n    if not string:\n        return\
    \ string\n\n    # Prefix must be reversed to create the palindrome\n    prefix\
    \ = string[::-1]\n\n    # Find the longest palindromic postfix of the original\
    \ string\n    # To do so, compare each postfix of the original string with each\
    \ prefix of the reversed original string\n    # If the postfix and prefix match\
    \ we have found a palindrome, otherwise keep looking for bigger one\n    for i\
    \ in range(len(string)):\n        if string[i:] == prefix[:len(string) - i]:\n\
    \            return string + prefix[len(string) - i:]\n\n    # If no palindromic\
    \ postfix was found the whole string is a palindrome\n    return string\n\n",
  "    if not string:\n        return string\n    reverse_string = string[::-1]\n\
    \    return string + reverse_string[len(get_palindromic_suffix(string)):]\n\n",
  "    i = 0\n    while i < len(string) and not is_palindrome(string[i:]):\n     \
    \   i += 1\n    return string + string[:i][::-1]\n\n", "    if len(string) <=\
    \ 1:\n        return string\n    end = len(string) - 1\n    while end >= 0:\n\
    \        if is_palindrome(string[0:end + 1]):\n            return string + string[:end:-1]\n\
    \        end -= 1\n    return string\n\n", "    reversed_prefix = reverse(string)\n\
    \    for index in range(len(string)):\n        if reversed_prefix[index:] == string[:len(string)\
    \ - index]:\n            return string + reversed_prefix[:index]\n    return string\
    \ + reversed_prefix\n\n", "    length = len(string)\n    for i in range(length\
    \ + 1):\n        if string[:length - i] == string[:length - i][::-1]:\n      \
    \      return string + string[:length - i][::-1]\n\n", "    l = len(string)\n\
    \    if l == 0:\n        return string\n    if l == 1:\n        return string\
    \ + string\n    if l == 2:\n        return string if string[0] == string[1] else\
    \ string + string[1] + string[0]\n\n    # ##############################################\n\
    \    # 1. Find the longest suffix that is a palindrome\n    # ##############################################\n\
    \    longest_palindrome_suffix_length = 0\n    for i in range(1, l + 1):\n   \
    \     if is_palindrome(string[-i:]):\n            longest_palindrome_suffix_length\
    \ = i\n            break\n\n    # ##############################################\n\
    \    # 2. The string prefix that comes before palindromic suffix is a reverse\
    \ of a string\n    #    to be appended to the end of the supplied string.\n  \
    \  # ##############################################\n    string_to_append = string[:l\
    \ - longest_palindrome_suffix_length]\n    return string + string_to_append[::-1]\n\
    \n", "    lps = get_longest_palindromic_suffix(string)\n    if lps is None:\n\
    \        return string + string[::-1]\n    else:\n        return string + string[:len(string)\
    \ - lps[0]][::-1]\n\n", "    string_len = len(string)\n    if string_len == 0:\n\
    \        return string\n    if string_len == 1:\n        return string * 2\n \
    \   if string_len == 2:\n        if string[0] == string[1]:\n            return\
    \ string * 2\n        else:\n            return string + string[::-1]\n    for\
    \ idx in range(string_len):\n        if is_palindrome(string[-idx:]):\n      \
    \      return string + string[:-idx - 1:-1]\n\n", "    # find the longest postfix\
    \ of the string that is a palindrome\n    postfix = find_longest_palindrome_postfix(string)\n\
    \    # return palindrome formed by appending reverse of the prefix to the end\
    \ of the string\n    return string + string[:len(string) - len(postfix)][::-1]\n\
    \n", "    string = string.lower()\n    for l in range(len(string), 0, -1):\n \
    \       postfix = string[-l:]\n        if is_palindrome(postfix):\n          \
    \  return string + string[:-l][::-1]\n    return string\n\n", "    def is_palindrome(string:\
    \ str) -> bool:\n        \"\"\" Check whether a string is a palindrome. \"\"\"\
    \n        return string == string[::-1]\n\n    if not string:\n        return\
    \ string\n\n    # find the longest palindromic suffix of a string\n    for i in\
    \ range(len(string), 0, -1):\n        if is_palindrome(string[-i:]):\n       \
    \     return string + string[0:len(string) - i][::-1]\n\n    return string", " \
    \   N = len(string)\n    if N == 0:\n        return ''\n    if N == 1:\n     \
    \   return string + string\n\n    # Find the longest postfix of supplied string\
    \ that is a palindrome\n    # using Manacher algorithm with simple optimizations.\n\
    \    P = [0] * (2 * N + 1)\n    # Buffer is used to avoid bounds checks when calculating\
    \ P.\n    # Buffer is filled with dots.\n    buffer = ['.'] * (2 * N + 1)\n  \
    \  for i in range(N):\n        buffer[2 * i + 1] = string[i]\n    mx = 0\n   \
    \ id = 0\n    for i in range(2 * N + 1):\n        if mx > i:\n            P[i]\
    \ = min(P[2 * id - i], mx - i)\n        else:\n            P[i] = 1\n        while\
    \ i - P[i] >= 0 and i + P[i] < 2 * N + 1 and buffer[i - P[i]] == buffer[i + P[i]]:\n\
    \            P[i] += 1\n        if P[i] + i > mx:\n            mx = P[i] + i\n\
    \            id = i\n    # Palindromic suffix is a substring of string from index\
    \ 0 to P[2 * N - 1] - 1.\n    palindromic_suffix = string[0:P[2 * N - 1] - 1]\n\
    \    # Reverse of a string prefix that comes before the palindromic suffix.\n\
    \    reverse_of_prefix = string[P[2 * N - 1] - 1::-1]\n    return palindromic_suffix\
    \ + reverse_of_prefix", "    def _longest_palindromic_suffix(string: str) -> str:\n\
    \        \"\"\" Find the longest postfix of supplied string that is a palindrome.\n\
    \        >>> _longest_palindromic_suffix('')\n        ''\n        >>> _longest_palindromic_suffix('cat')\n\
    \        't'\n        >>> _longest_palindromic_suffix('cata')\n        'ata'\n\
    \        \"\"\"\n        for i in range(len(string), 0, -1):\n            if string[:i]\
    \ == string[:i][::-1]:\n                return string[:i]\n        return ''\n\
    \n    if not string:\n        return string\n    palindromic_suffix = _longest_palindromic_suffix(string)\n\
    \    return string + string[:len(string) - len(palindromic_suffix)][::-1]\n\n",
  "    if not string:\n        return string\n    suffix_len = get_palindrome_suffix_len(string)\n\
    \    return string + string[:-suffix_len - 1:-1]\n\n", "    if not string:\n \
    \       return string\n    if len(string) == 1:\n        return string * 2\n \
    \   if len(string) == 2:\n        return string + string[::-1]\n\n    # Find the\
    \ longest palindromic suffix.\n    end = string\n    for _ in range(len(string)):\n\
    \        if is_palindrome(end):\n            break\n        end = end[1:]\n\n\
    \    # If supplied string is a palindrome.\n    if not end:\n        return string\
    \ + string[::-1]\n\n    # Otherwise reverse and append the string prefix to the\
    \ end of the string.\n    return string + string[:len(string) - len(end)][::-1]\n\
    \n", "    # If the input string is empty or is a palindrome itself, return it.\n\
    \    if not string or string == string[::-1]:\n        return string\n\n    #\
    \ Find the first character that does not participate in a palindrome (by comparing\
    \ it with the reversed string).\n    for pos, ch in enumerate(string):\n     \
    \   if ch != string[-pos - 1]:\n            break\n\n    # Append a reverse of\
    \ prefix that comes before the palindromic suffix.\n    return string + string[:pos:-1]\n\
    \n", "    if string == '':\n        return ''\n    return string + string[:find_longest_palindrome_postfix(string)][::-1]\n\
    \n", "    i = len(string)\n    while i > 0:\n        if is_palindrome(string[:i]):\n\
    \            break\n        i -= 1\n    return string + string[:i - len(string)][::-1]\n\
    \n", "    if not string:\n        return string\n    longest_palindrome_suffix\
    \ = find_longest_palindrome_suffix(string)\n    return string + string[:len(string)\
    \ - len(longest_palindrome_suffix)][::-1]\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
