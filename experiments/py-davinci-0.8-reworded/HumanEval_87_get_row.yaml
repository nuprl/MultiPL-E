name: HumanEval_87_get_row
language: py
prompt: "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int)\
  \ -> List[Tuple[int, int]]:\n    \"\"\"\n    You are given a 2 dimensional data,\
  \ as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
  \    each row may contain a different number of columns.\n    Given lst, and integer\
  \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
  \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
  \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
  \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
  \    >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n\
  \    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n\
  \    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3,\
  \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\
  \    assert candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
  \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
  \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([[1, 2, 3, 4, 5, 6],\
  \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6],\
  \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
  \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([],\
  \ 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1],\
  \ [1, 2, 3]], 3) == [(2, 2)]\n\ndef test_check():\n    check(get_row)\n\ntest_check()\n"
completions: ["    res = [(i, j) for i in range(len(lst)) for j in range(len(lst[i]))\
    \ if lst[i][j] == x]\n    res.sort(key=lambda t: (t[0], -t[1]))\n    return res\n\
    \n", "    coordinates = []\n    #Add your code here\n    i = 0\n    while i <\
    \ len(lst):\n        j = 0\n        while j < len(lst[i]):\n            if lst[i][j]\
    \ == x:\n                coordinates.append((i, j))\n            j += 1\n    \
    \    i += 1\n    def key_func(coordinate):\n        return (-coordinate[1], coordinate[0])\n\
    \    coordinates.sort(key=key_func)\n    return coordinates\n", "    result =\
    \ []\n    for index_row, row in enumerate(lst):\n        if x in row:\n      \
    \      col_ind = [i for i, value in enumerate(row) if value == x]\n          \
    \  for c in col_ind:\n                result.append((index_row, c))\n    return\
    \ sorted(result, key=lambda x: x[0])\n\n", "    # a = [(j, i) for i, l in enumerate(lst)\
    \ for j, a in enumerate(l) if a == x]\n    # a.sort(key=lambda a: (a[1], -a[0]))\n\
    \    # return a\n    return sorted([(j, i) for i, l in enumerate(lst) for j, a\
    \ in enumerate(l) if a == x], key=lambda a: (a[1], -a[0]))\n\n", "    # your code\
    \ here\n    pass\n\n", "    pass\n", "    pass\n", "    indexes = []\n    for\
    \ i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if\
    \ lst[i][j] == x:\n                indexes.append((i, j))\n    indexes.sort()\n\
    \    return [indexes[i] for i in range(len(indexes) - 1, -1, -1)]", "    row_to_tuple_lst\
    \ = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, item in\
    \ enumerate(row):\n            if item == x:\n                row_to_tuple_lst.append((row_idx,\
    \ col_idx))\n    row_to_tuple_lst.sort()\n    return row_to_tuple_lst\n\n", " \
    \   # A list to store our result\n    res: List[Tuple[int, int]] = []\n    # Loop\
    \ through the given list of lists\n    for y, row in enumerate(lst):\n       \
    \ # Loop through the inner lists\n        for x1, val in enumerate(row):\n   \
    \         # Check if the value we look for is in the list\n            if val\
    \ == x:\n                # Append the index to the result\n                res.append((y,\
    \ x1))\n    # Sort the result by rows in ascending order\n    res.sort(key=lambda\
    \ x: x[0])\n    # Sort the result by columns in descending order\n    res.sort(key=lambda\
    \ x: -x[1])\n    return res\n", "    pass\n", "    #return [(i,j) for j in range(len(lst[i]))\
    \ for i in range(len(lst)) if lst[i][j] == x]\n    output = []\n    for i in range(len(lst)):\n\
    \        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n      \
    \          output.append((i,j))\n    return output\n", "    x_coords = []\n  \
    \  for (r, row) in enumerate(lst):\n        if x in row:\n            x_coords.extend([(r,\
    \ row.index(x)),] * row.count(x))\n    return sorted(x_coords, key=lambda x: (x[0],\
    \ -x[1]))\n", "    res = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n\
    \            if lst[i][j] == x:\n                res.append((i, j))\n    return\
    \ sorted(res, key=lambda x: x[0])\n", "    res = []\n    for i in range(len(lst)):\n\
    \        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n      \
    \          res.append((i, j))\n    return sorted(res, key=lambda tup: (-tup[1],\
    \ tup[0]))\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    ", "    res = []\n    for i in range(len(lst)):\n\
    \        indexes = []\n        for j in range(len(lst[i])):\n            if lst[i][j]\
    \ == x:\n                indexes.append(j)\n        if indexes:\n            res.append((i,\
    \ max(indexes)))\n    return res\n\nprint(get_row([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\nprint(get_row([], 1))\nprint(get_row([[],\
    \ [1], [1, 2, 3]], 3))", "    result = []\n    for i in range(len(lst)):\n   \
    \     indexes = [j for j in range(len(lst[i])) if lst[i][j] == x]\n        for\
    \ index in indexes:\n            result.append((i, index))\n    result.sort(key=lambda\
    \ x: x[0])\n    for x in range(len(result)):\n        result[x] = (result[x][0],\
    \ result[x][1] * -1)\n    result.sort(key=lambda x: x[1])\n    for x in range(len(result)):\n\
    \        result[x] = (result[x][0], result[x][1] * -1)\n    return result\n  \
    \  \n    \n    ", "    # Place for your code\n    ans = []\n    for i in range(len(lst)):\n\
    \        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n      \
    \          ans.append((i, j))\n    \n    ans.sort(key=lambda x: (-x[1], x[0]))\n\
    \    return ans\n", "    # total_list = []\n    # for i in range(len(lst)):\n\
    \    #     for j in range(len(lst[i])):\n    #         if lst[i][j] == x:\n  \
    \  #             total_list.append((i, j))\n    # return total_list\n    # one-liner\n\
    \    return sorted([(i, j) for i in range(len(lst)) for j in range(len(lst[i]))\
    \ if lst[i][j] == x], key=lambda x: (x[0], -x[1]))\n", "    result = []\n    #\
    \ BEGIN (write your solution here)\n    for i in range(len(lst)):\n        for\
    \ j in range(len(lst[i])):\n            if lst[i][j] == x:\n                result.append((i,\
    \ j))\n    result.sort(key=lambda x: (x[0], -x[1]))\n    # END\n    return result\n\
    \n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
