name: HumanEval_115_max_fill
language: py
prompt: "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity:\
  \ int) -> int:\n    \"\"\"\n    You are given a rectangular grid of wells. Each\
  \ row represents a single well,\n    and each 1 in a row represents a single unit\
  \ of water.\n    Each well has a corresponding bucket that can be used to extract\
  \ water from it, \n    and all buckets have the same capacity.\n    Your task is\
  \ to use the buckets to empty the wells.\n    Output the number of times you need\
  \ to lower the buckets.\n\n    Example 1:\n    >>> max_fill([[0, 0, 1, 0], [0, 1,\
  \ 0, 0], [1, 1, 1, 1]], 1)\n    6\n\n    Example 2:\n    >>> max_fill([[0, 0, 1,\
  \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n    5\n    \n    Example 3:\n\
  \    >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n    0\n\n    Constraints:\n      \
  \  * all wells have the same length\n        * 1 <= grid.length <= 10^2\n      \
  \  * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <=\
  \ capacity <= 10\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
  \ 1, 1, 1]], 1) == 6\n    assert candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
  \ 1], [0, 1, 1, 1]], 2) == 5\n    assert candidate([[0, 0, 0], [0, 0, 0]], 5) ==\
  \ 0\n    assert candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2) == 4\n    assert candidate([[1,\
  \ 1, 1, 1], [1, 1, 1, 1]], 9) == 2\n\ndef test_check():\n    check(max_fill)\n\n\
  test_check()\n"
completions: ["    return sum(\n        sum(row[i] for row in grid)//capacity + sum(row[i]\
    \ for row in grid)%capacity\n        for i in range(len(grid[0]))\n    )\n", " \
    \   # TODO\n    pass\n", "    columns = len(grid[0])\n    fill_count = 0\n   \
    \ filled_cols = set()\n    while len(filled_cols) < columns:\n        filled_cols.clear()\n\
    \        for column in range(columns):\n            # fill each well\n       \
    \     for row in range(len(grid)):\n                if grid[row][column] == 1:\n\
    \                    grid[row][column] = 0\n                    filled_cols.add(column)\n\
    \                    fill_count += 1\n                    if fill_count == capacity:\n\
    \                        fill_count = 0\n                        break\n     \
    \       if fill_count == 0:\n                break\n    return fill_count\n",
  "    # init fill count\n    fill_count = 0\n    # iterate over the rows\n    for\
    \ row in grid:\n        # filter out all the 1's\n        units = list(filter(lambda\
    \ cell: cell == 1, row))\n        # if there are no 1's skip this row\n      \
    \  if len(units) == 0:\n            continue\n        # calculate the number of\
    \ fills\n        fills = int(ceil(len(units) / capacity))\n        # update the\
    \ fill count\n        fill_count += fills\n    # return the fill count\n    return\
    \ fill_count\n", "    # TODO: implement me\n    pass\n", "    total_fill = 0\n\
    \    start_col = 0\n    while True:\n        # Find the leftmost column that has\
    \ a filled well, starting from the current start column\n        # (or reset to\
    \ 0 if the last maximum fill was achieved with the rightmost column)\n       \
    \ col = start_col\n        while col < len(grid[0]) and not any(grid[row][col]\
    \ for row in range(len(grid))):\n            col += 1\n        if col == len(grid[0]):\n\
    \            # All wells empty, terminate\n            break\n        # Fill up\
    \ the buckets from this leftmost column\n        total_fill += capacity\n    \
    \    for row in range(len(grid)):\n            if grid[row][col]:\n          \
    \      grid[row][col] = 0\n                for col2 in range(col + 1, len(grid[0])):\n\
    \                    if grid[row][col2]:\n                        grid[row][col2]\
    \ = 0\n                        break\n        # Start from the left of the next\
    \ column in the next iteration\n        start_col = (col + 1) % len(grid[0])\n\
    \    return total_fill\n", "    max_bucket = 0\n    times = 0\n    for row in\
    \ grid:\n        bucket = sum(row)\n        times += len(row) - bucket\n     \
    \   if bucket > max_bucket:\n            max_bucket = bucket\n    return max_bucket\
    \ * (times // max_bucket) + max_bucket\n", "    bucket_count = 0\n    is_filling\
    \ = True\n    while is_filling:\n        is_filling = False\n        for i in\
    \ range(len(grid)):\n            for j in range(len(grid[i])):\n             \
    \   if grid[i][j] == 1:\n                    is_filling = True\n             \
    \       grid[i][j] = 0\n                    bucket_count += 1\n    return bucket_count\n",
  "    n_rows = len(grid)\n    n_cols = len(grid[0])\n    buckets = [0] * n_cols\n\
    \    for i in range(n_rows):\n        for j in range(n_cols):\n            if\
    \ grid[i][j] == 1:\n                buckets[j] += 1\n    return sum(buckets)\n",
  '    return sum(max(0, bucket_size - bucket_level) for bucket_size, bucket_level
    in zip(*map(sum, grid)))', "    pass\n", "    num_row = len(grid)\n    num_col\
    \ = len(grid[0])\n    if num_row == 0 or num_col == 0:\n        return 0\n   \
    \ # initalize grid_counter to the same size as grid\n    grid_counter = [[0 for\
    \ _ in range(num_col)] for _ in range(num_row)]\n    max_count = float('-inf')\n\
    \    for row in range(num_row):\n        for col in range(num_col):\n        \
    \    if grid[row][col] == 1:\n                grid_counter[row][col] = 1\n   \
    \             max_count = max(max_count, grid_counter[row][col])\n    iteration\
    \ = 0\n    while max_count > 0:\n        #print('iteration:', iteration)\n   \
    \     # fill the grids of current iteration\n        for row in range(num_row):\n\
    \            for col in range(num_col):\n                if grid_counter[row][col]\
    \ == iteration:\n                    grid_counter[row][col] = 0\n            \
    \        if row < num_row - 1:\n                        grid_counter[row + 1][col]\
    \ += 1\n                    if col < num_col - 1:\n                        grid_counter[row][col\
    \ + 1] += 1\n        # update max_count\n        max_count = float('-inf')\n \
    \       for row in range(num_row):\n            for col in range(num_col):\n \
    \               max_count = max(max_count, grid_counter[row][col])\n        iteration\
    \ += 1\n    #print(grid_counter)\n    return iteration\n", "    water_from_wells\
    \ = []\n    lowest_water_from_wells = float('inf')\n    current_water_from_wells\
    \ = 0\n    time = 0\n    for row in grid:\n        for well in row:\n        \
    \    if well == 1:\n                current_water_from_wells += 1\n        water_from_wells.append(current_water_from_wells)\n\
    \        current_water_from_wells = 0\n    \n    for i in range(len(water_from_wells)):\n\
    \        if water_from_wells[i] < lowest_water_from_wells:\n            lowest_water_from_wells\
    \ = water_from_wells[i]\n    \n    number_of_emptied_wells = 0\n    while number_of_emptied_wells\
    \ < len(water_from_wells):\n        max_time = 0\n        for i in range(len(water_from_wells)):\n\
    \            if water_from_wells[i] > 0:\n                max_time += capacity\n\
    \            if water_from_wells[i] - capacity > 0:\n                water_from_wells[i]\
    \ -= capacity\n            else:\n                water_from_wells[i] = 0\n  \
    \      time += max_time\n        number_of_emptied_wells = 0\n        for item\
    \ in water_from_wells:\n            if item == 0:\n                number_of_emptied_wells\
    \ += 1\n    return time\n", "    # count holes in first row and column\n    num_holes\
    \ = sum(grid[0]) + sum(grid[i][0] for i in range(len(grid)))\n    # check how\
    \ many wells can be filled in a single bucket drop\n    while not all(all(row)\
    \ for row in grid):\n        # drop bucket\n        num_holes += 1\n        #\
    \ fill wells\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n\
    \                if i == 0 or j == 0:\n                    grid[i][j] = 1\n  \
    \              elif grid[i][j] == 0 and grid[i-1][j] == 1 and grid[i][j-1] ==\
    \ 1:\n                    grid[i][j] = 1\n    return num_holes - 2", "    len_rows\
    \ = len(grid)\n    len_cols = len(grid[0])\n    res = 0\n    for j in range(len_cols):\n\
    \        row_sum = sum(grid[i][j] for i in range(len_rows))\n        if row_sum\
    \ > capacity:\n            res += row_sum - capacity\n    return res\n", "   \
    \ n_rows = len(grid)\n    n_cols = len(grid[0])\n    total_fill = 0\n    for col\
    \ in range(n_cols):\n        for row in range(n_rows):\n            if grid[row][col]\
    \ == 1:\n                if capacity == 0:\n                    total_fill +=\
    \ 1\n                    capacity = 1\n                capacity -= 1\n    return\
    \ total_fill\n", "    rows = len(grid)\n    cols = len(grid[0])\n    water_count\
    \ = 0\n    moves = 0\n    while water_count < rows * cols:\n        moves += 1\n\
    \        water_count = 0\n        for i in range(rows):\n            for j in\
    \ range(cols):\n                if grid[i][j] >= capacity:\n                 \
    \   grid[i][j] -= capacity\n                    water_count += capacity\n    \
    \            else:\n                    water_count += grid[i][j]\n          \
    \          grid[i][j] = 0\n    return moves\n", "    pass\n\n", "    num_rows\
    \ = len(grid)\n    num_cols = len(grid[0])\n    # in each step, we fill up the\
    \ first row.\n    # then we dump every other row into it\n    steps = 0\n    for\
    \ col in range(num_cols):\n        if grid[0][col] == 1:\n            steps +=\
    \ 1\n            grid[0][col] = 0\n        for row in range(1, num_rows):\n  \
    \          if grid[row][col] == 1:\n                steps += 1\n             \
    \   grid[row][col] = 0\n                fill_row(grid[0], col, capacity)\n   \
    \ return steps\n", "    def dfs(x, y, grid, visited):\n        visited[x][y] =\
    \ True\n        for dx, dy in dirs:\n            if x + dx < 0 or x + dx >= len(grid)\
    \ or y + dy < 0 or y + dy >= len(grid[0]) or visited[x + dx][y + dy]:\n      \
    \          continue\n            if grid[x + dx][y + dy] == 1:\n             \
    \   if y + dy == 0:\n                    return True\n                else:\n\
    \                    if dfs(x + dx, y + dy, grid, visited):\n                \
    \        return True\n        return False\n\n    dirs = [(0, -1), (0, 1), (-1,\
    \ 0), (1, 0)]\n    row_len = len(grid[0])\n    unit_len = row_len // capacity\n\
    \    row_sum = [sum(row) for row in grid]\n    ans = 0\n    for i in range(unit_len):\n\
    \        for j in range(len(grid)):\n            if row_sum[j] == 0:\n       \
    \         continue\n            visited = [[False for _ in range(row_len)] for\
    \ _ in range(len(grid))]\n            if dfs(j, i * capacity, grid, visited):\n\
    \                ans += 1\n                for x in range(len(grid)):\n      \
    \              for y in range(row_len):\n                        if visited[x][y]:\n\
    \                            grid[x][y] = 0\n                            row_sum[x]\
    \ -= 1\n    return ans\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
