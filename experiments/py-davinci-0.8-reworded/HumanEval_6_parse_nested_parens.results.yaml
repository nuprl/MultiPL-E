language: py
name: HumanEval_6_parse_nested_parens
results:
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ paren_group in paren_string.split(' '):\n        result.append(__find_deepest_nesting(paren_group))\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgxwv_qif.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpgxwv_qif.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpgxwv_qif.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpgxwv_qif.py\", line 13, in parse_nested_parens\n\
    \    result.append(__find_deepest_nesting(paren_group))\nNameError: name '__find_deepest_nesting'\
    \ is not defined\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    results = []\n   \
    \ for parens in paren_string.split():\n        results.append(helper(parens))\n\
    \    return results\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp3ghj06p6.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmp3ghj06p6.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp3ghj06p6.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp3ghj06p6.py\", line 13, in parse_nested_parens\n\
    \    results.append(helper(parens))\nNameError: name 'helper' is not defined\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    all_parens = paren_string.split()\n\
    \    # For each paren, check if it is opened or closed.\n    # If it is opened,\
    \ increment the counter by 1.\n    # If it is closed, decrement the counter by\
    \ 1.\n    # If the decrement goes below zero, it means we have extra closed parens.\n\
    \    # Return the highest value reached during the iteration.\n    paren_levels\
    \ = [max(0, sum(1 if ch == '(' else -1 for ch in paren)) for paren in all_parens]\n\
    \    return paren_levels\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmps0e18zhn.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmps0e18zhn.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmps0e18zhn.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ parens in paren_string.split(' '):\n        max_depth = 0\n        current_depth\
    \ = 0\n        for paren in parens:\n            if paren == '(':\n          \
    \      current_depth += 1\n                max_depth = max(max_depth, current_depth)\n\
    \            elif paren == ')':\n                current_depth -= 1\n        result.append(max_depth)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    ret = []\n    for\
    \ group in paren_string.split():\n        counter = 0\n        depth = 0\n   \
    \     for char in group:\n            if char == '(':\n                counter\
    \ += 1\n                depth = max(depth, counter)\n            elif char ==\
    \ ')':\n                counter -= 1\n        ret.append(depth)\n    return ret\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for\
    \ nested_parens in paren_string.split(' '):\n        num_opened = 0\n        nested_depth\
    \ = 0\n        for char in nested_parens:\n            if char == '(':\n     \
    \           num_opened += 1\n                nested_depth = max(nested_depth,\
    \ num_opened)\n            else:\n                num_opened -= 1\n        output.append(nested_depth)\n\
    \    return output\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    current_depth = 0\n\
    \    max_depth = 0\n    paren_depth = []\n    for char in paren_string:\n    \
    \    if char == '(':\n            current_depth += 1\n            max_depth =\
    \ max(max_depth, current_depth)\n        elif char == ')':\n            paren_depth.append(max_depth)\n\
    \            max_depth = 0\n            current_depth -= 1\n        elif char\
    \ == ' ':\n            continue\n    return paren_depth\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmph8g1cthk.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmph8g1cthk.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmph8g1cthk.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO: implement\
    \ this function\n    max_depth = []\n    group = paren_string.split()\n    for\
    \ g in group:\n        count = 0\n        max_depth.append(0)\n        for i in\
    \ g:\n            if i == '(':\n                count += 1\n                if\
    \ count > max_depth[-1]:\n                    max_depth[-1] = count\n        \
    \    if i == ')':\n                count -= 1\n    return max_depth\n    pass\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Use this list to\
    \ store the result\n    result = []\n    # A helper function to count the maximum\
    \ level of nesting of parentheses\n    def max_level(p_string: str) -> int:\n\
    \        # TODO: write your own function here\n        pass\n    # Parse the input\
    \ string and store the result\n    for p_string in paren_string.split():\n   \
    \     result.append(max_level(p_string))\n    return result\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjrtx0rcs.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpjrtx0rcs.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpjrtx0rcs.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ s in paren_string.split():\n        curr_max_depth = max_depth = depth = 0\n\
    \        for ch in s:\n            if ch == '(':\n                depth += 1\n\
    \                curr_max_depth = max(curr_max_depth, depth)\n            elif\
    \ ch == ')':\n                depth -= 1\n            else:\n                raise\
    \ ValueError(\"Unknown character: {}\".format(ch))\n        if depth != 0:\n \
    \           raise ValueError(\"Invalid parenthesis string {}: {}\".format(s, depth))\n\
    \        result.append(curr_max_depth)\n    return result\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_level = 0\n  \
    \  level = 0\n    max_levels = []\n    for char in paren_string:\n        if char\
    \ == '(':\n            level += 1\n            max_level = max(max_level, level)\n\
    \        elif char == ')':\n            level -= 1\n        elif char == ' ':\n\
    \            max_levels.append(max_level)\n            max_level = 0\n       \
    \     level = 0\n    max_levels.append(max_level)\n    return max_levels\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ _str in paren_string.split(' '):\n        stack = []\n        max_len = 0\n\
    \        for c in _str:\n            if c == '(':\n                stack.append(c)\n\
    \                max_len = max(max_len, len(stack))\n            elif c == ')':\n\
    \                stack.pop()\n        res.append(max_len)\n    return res\n\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for\
    \ paren_group in paren_string.split():\n        max_level = 0\n        curr_level\
    \ = 0\n        for paren in paren_group:\n            if paren == '(':\n     \
    \           curr_level += 1\n                max_level = max(max_level, curr_level)\n\
    \            elif paren == ')':\n                curr_level -= 1\n           \
    \ else:\n                raise ValueError(f'Invalid paren in string: {paren}')\n\
    \        output.append(max_level)\n    return output\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n\
    \    # print(paren_groups)\n    max_depth = []\n    for paren_group in paren_groups:\n\
    \        # print(paren_group)\n        current_depth = 0\n        for char in\
    \ paren_group:\n            if char == '(':\n                current_depth +=\
    \ 1\n            elif char == ')':\n                current_depth -= 1\n     \
    \       else:\n                raise ValueError('Improper input!')\n        max_depth.append(current_depth)\n\
    \    return max_depth\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvp78ovli.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmpvp78ovli.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpvp78ovli.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ s in paren_string.split():\n        start = 0\n        max_level = 0\n     \
    \   level = 0\n        while start < len(s):\n            if s[start] == '(':\n\
    \                level += 1\n                max_level = max(max_level, level)\n\
    \            elif s[start] == ')':\n                level -= 1\n            start\
    \ += 1\n        result.append(max_level)\n    return result\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ group in paren_string.split(' '):\n        level = 0\n        max_level = 0\n\
    \        for c in group:\n            if c == '(':\n                level += 1\n\
    \                max_level = max(max_level, level)\n            else:\n      \
    \          level -= 1\n        result.append(max_level)\n    return result\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split('\
    \ ')\n    return [max_nesting(substr) for substr in paren_list]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmiq3opvd.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpmiq3opvd.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpmiq3opvd.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpmiq3opvd.py\", line 12, in parse_nested_parens\n\
    \    return [max_nesting(substr) for substr in paren_list]\n  File \"/tmp/tmpmiq3opvd.py\"\
    , line 12, in <listcomp>\n    return [max_nesting(substr) for substr in paren_list]\n\
    NameError: name 'max_nesting' is not defined\n"
  stdout: ''
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed_parens = []\n\
    \    for paren_group in paren_string.split(' '):\n        # initialize depth of\
    \ each group to be 0\n        depth = 0\n        max_depth = 0\n        for char\
    \ in paren_group:\n            if char == '(':\n                depth += 1\n \
    \               max_depth = max(max_depth, depth)\n            elif char == ')':\n\
    \                depth -= 1\n            else:\n                raise ValueError('Input\
    \ string can only contain \"(\" or \")\"')\n        parsed_parens.append(max_depth)\n\
    \    return parsed_parens\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pass\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmport6yg46.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmport6yg46.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmport6yg46.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nesting = 0\n\
    \    current_nesting = 0\n    max_nesting_list = []\n    for char in paren_string:\n\
    \        if char == '(':\n            current_nesting += 1\n            max_nesting\
    \ = max(max_nesting, current_nesting)\n        elif char == ')':\n           \
    \ current_nesting -= 1\n        elif char == ' ':\n            max_nesting_list.append(max_nesting)\n\
    \            max_nesting = 0\n            current_nesting = 0\n    max_nesting_list.append(max_nesting)\n\
    \    return max_nesting_list\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split('\
    \ ')\n    return [nested_parens(group) for group in paren_groups]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpwn8pl00c.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpwn8pl00c.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpwn8pl00c.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpwn8pl00c.py\", line 12, in parse_nested_parens\n\
    \    return [nested_parens(group) for group in paren_groups]\n  File \"/tmp/tmpwn8pl00c.py\"\
    , line 12, in <listcomp>\n    return [nested_parens(group) for group in paren_groups]\n\
    NameError: name 'nested_parens' is not defined\n"
  stdout: ''
  timestamp: 1659822095
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    bracket_stack = []\n\
    \    bracket_pair = {'(': ')'}\n    max_level = 0\n    levels = []\n    for idx,\
    \ bracket in enumerate(paren_string):\n        if bracket == '(':\n          \
    \  bracket_stack.append(bracket)\n            max_level += 1\n        elif bracket\
    \ == ')':\n            if bracket_stack[-1] == '(':\n                bracket_stack.pop()\n\
    \                max_level -= 1\n            elif bracket_stack[-1] == ' ':\n\
    \                bracket_stack.pop()\n                levels.append(max_level)\n\
    \                max_level = 0\n        elif bracket == ' ':\n            bracket_stack.append(bracket)\n\
    \    return levels\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpw5psiruf.py\", line\
    \ 40, in <module>\n    test_check()\n  File \"/tmp/tmpw5psiruf.py\", line 38,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpw5psiruf.py\"\
    , line 33, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split('\
    \ ')\n    depths = []\n    for paren_group in paren_groups:\n        depths.append(calculate_depth(paren_group))\n\
    \    return depths\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkdrlh133.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpkdrlh133.py\", line 23,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkdrlh133.py\"\
    , line 18, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpkdrlh133.py\", line 14, in parse_nested_parens\n\
    \    depths.append(calculate_depth(paren_group))\nNameError: name 'calculate_depth'\
    \ is not defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_strings = paren_string.split()\n\
    \    paren_count = []\n    for paren_string in paren_strings:\n        paren_stack\
    \ = []\n        max_nesting = 0\n        for ch in paren_string:\n           \
    \ if ch == '(':\n                paren_stack.append(ch)\n                max_nesting\
    \ = max(max_nesting, len(paren_stack))\n            elif ch == ')':\n        \
    \        paren_stack.pop()\n        paren_count.append(max_nesting)\n    return\
    \ paren_count\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822095
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ group in paren_string.split(' '):\n        stack = []\n        max_level = -1\n\
    \        for paren in group:\n            if paren == '(':\n                stack.append(paren)\n\
    \                max_level = max(max_level, len(stack))\n            elif paren\
    \ == ')':\n                stack.pop()\n        result.append(max_level)\n   \
    \ return result\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth, max_depth =\
    \ 0, 0\n    result = []\n    for paren in paren_string:\n        if paren == '(':\n\
    \            depth += 1\n            max_depth = max(max_depth, depth)\n     \
    \   elif paren == ')':\n            depth -= 1\n        elif paren == ' ':\n \
    \           result.append(max_depth)\n            max_depth = 0\n    result.append(max_depth)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822095
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    open_count = 0\n \
    \   max_count = 0\n    output = []\n    for char in paren_string:\n        if\
    \ char == '(':\n            open_count += 1\n            max_count = max(max_count,\
    \ open_count)\n        elif char == ')':\n            open_count -= 1\n      \
    \  elif char == ' ':\n            output.append(max_count)\n            max_count\
    \ = 0\n            open_count = 0\n    output.append(max_count)\n    return output\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    count_nested_parens\
    \ = []\n    for paren_group in paren_string.split():\n        stack = []\n   \
    \     max_nested_count = 0\n        for paren in paren_group:\n            if\
    \ paren == '(':\n                stack.append(paren)\n                max_nested_count\
    \ = max(max_nested_count, len(stack))\n            else:\n                stack.pop()\n\
    \        count_nested_parens.append(max_nested_count)\n    return count_nested_parens\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Each character in\
    \ the string is { or } or a character other than { or }.\n    # It can be considered\
    \ as a string of char[]\n    # initialize a stack to store the counts of each\
    \ level of nesting\n    max_level = 0\n    levels = [0]\n    for c in paren_string:\n\
    \        if c == '(':\n            levels.append(levels[-1] + 1)\n           \
    \ max_level = max(max_level, levels[-1])\n        elif c == ')':\n           \
    \ levels.pop()\n        else:\n            levels[-1] = max_level\n    return\
    \ levels\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpl1tx9bq5.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpl1tx9bq5.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpl1tx9bq5.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ group in paren_string.split(' '):\n        paren_stack = []\n        max_nesting\
    \ = 0\n        for paren in group:\n            if paren == '(':\n           \
    \     paren_stack.append(paren)\n                max_nesting = max(max_nesting,\
    \ len(paren_stack))\n            elif paren == ')':\n                paren_stack.pop()\n\
    \        res.append(max_nesting)\n    return res\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    deepest_levels = []\n\
    \    for paren_group in paren_string.split():\n        max_level = 0\n       \
    \ level = 0\n        for paren in paren_group:\n            if paren == '(':\n\
    \                level += 1\n                max_level = max(max_level, level)\n\
    \            else:\n                level -= 1\n        deepest_levels.append(max_level)\n\
    \    return deepest_levels\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ paren_group in paren_string.split():\n        max_depth = 0\n        depth =\
    \ 0\n        for char in paren_group:\n            if char == '(':\n         \
    \       depth += 1\n                max_depth = max(max_depth, depth)\n      \
    \      elif char == ')':\n                depth -= 1\n        result.append(max_depth)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth = 0\n  \
    \  current_depth = 0\n    output = []\n    for paren in paren_string:\n      \
    \  if paren == '(':\n            current_depth += 1\n            max_depth = max(max_depth,\
    \ current_depth)\n        elif paren == ')':\n            current_depth -= 1\n\
    \        elif paren == ' ':\n            output.append(max_depth)\n          \
    \  max_depth = 0\n            current_depth = 0\n    if current_depth == 0:\n\
    \        output.append(max_depth)\n    return output\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth = 0\n    output\
    \ = []\n    for i in paren_string:\n        if i == '(':\n            depth +=\
    \ 1\n        elif i == ')':\n            output.append(depth)\n            depth\
    \ -= 1\n    return output\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbuiajqy6.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpbuiajqy6.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpbuiajqy6.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n\
    \    paren_groups = paren_string.split(' ')\n    return [parse_nested_parens_group(group)\
    \ for group in paren_groups]\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpl8ped0mz.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpl8ped0mz.py\", line 21,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpl8ped0mz.py\"\
    , line 16, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpl8ped0mz.py\", line 13, in parse_nested_parens\n\
    \    return [parse_nested_parens_group(group) for group in paren_groups]\n  File\
    \ \"/tmp/tmpl8ped0mz.py\", line 13, in <listcomp>\n    return [parse_nested_parens_group(group)\
    \ for group in paren_groups]\nNameError: name 'parse_nested_parens_group' is not\
    \ defined. Did you mean: 'parse_nested_parens'?\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    splits = paren_string.split('\
    \ ')\n    outputs = []\n    for split in splits:\n        st = []\n        max_counter\
    \ = 0\n        counter = 0\n        for char in split:\n            if char ==\
    \ '(':\n                st.append(char)\n                counter += 1\n      \
    \          max_counter = max(max_counter, counter)\n            else:\n      \
    \          st.pop()\n                counter -= 1\n        outputs.append(max_counter)\n\
    \    return outputs\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split('\
    \ ')\n    return [max_nested_parens(paren_group) for paren_group in paren_groups]\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9xdv9xu6.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmp9xdv9xu6.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9xdv9xu6.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp9xdv9xu6.py\", line 12, in parse_nested_parens\n\
    \    return [max_nested_parens(paren_group) for paren_group in paren_groups]\n\
    \  File \"/tmp/tmp9xdv9xu6.py\", line 12, in <listcomp>\n    return [max_nested_parens(paren_group)\
    \ for paren_group in paren_groups]\nNameError: name 'max_nested_parens' is not\
    \ defined. Did you mean: 'parse_nested_parens'?\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group_list = paren_string.split()\n\
    \    res = []\n    for group in group_list:\n        if not group:\n         \
    \   res.append(0)\n            continue\n        depth = 0\n        max_depth\
    \ = 0\n        for item in group:\n            if item == '(':\n             \
    \   depth += 1\n                max_depth = max(max_depth, depth)\n          \
    \  elif item == ')':\n                depth -= 1\n        res.append(max_depth)\n\
    \    return res\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    deepest_level = 0\n\
    \    result = []\n    for c in paren_string:\n        if c == '(':\n         \
    \   deepest_level += 1\n        elif c == ')':\n            deepest_level -= 1\n\
    \        elif c == ' ':\n            result.append(deepest_level)\n          \
    \  deepest_level = 0\n    return result\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnxxqk0k7.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpnxxqk0k7.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpnxxqk0k7.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n\
    \    max_nested_levels = []\n    for group in paren_groups:\n        max_nested_levels.append(parse_single_paren_group(group))\n\
    \    return max_nested_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpxsb3_1ca.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpxsb3_1ca.py\", line 23,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxsb3_1ca.py\"\
    , line 18, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpxsb3_1ca.py\", line 14, in parse_nested_parens\n\
    \    max_nested_levels.append(parse_single_paren_group(group))\nNameError: name\
    \ 'parse_single_paren_group' is not defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ g in paren_string.split():\n        depth = 0\n        max_depth = 0\n     \
    \   for c in g:\n            if c == '(':\n                depth += 1\n      \
    \          max_depth = max(max_depth, depth)\n            elif c == ')':\n   \
    \             depth -= 1\n        res.append(max_depth)\n    return res\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [len(s) - len(s.replace('(',\
    \ '')) for s in paren_string.split()]\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp57cc8fil.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmp57cc8fil.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp57cc8fil.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def max_nesting(paren_string:\
    \ str) -> int:\n        \"\"\" Helper function to calculate the deepest level\
    \ of nesting of parentheses.\n        \"\"\"\n        max_nesting_level = 0\n\
    \        num_open_parens = 0\n        for c in paren_string:\n            if c\
    \ == '(':\n                num_open_parens += 1\n                max_nesting_level\
    \ = max(max_nesting_level, num_open_parens)\n            elif c == ')':\n    \
    \            num_open_parens -= 1\n        return max_nesting_level\n\n    return\
    \ [max_nesting(s) for s in paren_string.split()]\n\ndef check(candidate):\n  \
    \  assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    level\
    \ = 0\n    max_level = 0\n    for i in paren_string:\n        if i == '(':\n \
    \           level += 1\n            max_level = max(max_level, level)\n      \
    \  elif i == ')':\n            level -= 1\n        elif i == ' ':\n          \
    \  res.append(max_level)\n            max_level = 0\n            level = 0\n \
    \   res.append(max_level)\n    return res\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    ret = []\n    for\
    \ parens in paren_string.split():\n        stack = []\n        max_nesting = 0\n\
    \        for paren in parens:\n            if paren == '(':\n                stack.append(paren)\n\
    \                max_nesting = max(max_nesting, len(stack))\n            elif\
    \ paren == ')':\n                stack.pop()\n        ret.append(max_nesting)\n\
    \    return ret\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split('\
    \ ')\n    return [len(group) - group.count('(') for group in groups]\n\nprint(parse_nested_parens('(()())\
    \ ((())) () ((())()())'))\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpcexs2tfe.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpcexs2tfe.py\", line 21,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpcexs2tfe.py\"\
    , line 16, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: '[3, 3, 1, 5]

    '
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Remove all the whitespaces\n\
    \    paren_string = paren_string.replace(' ', '')\n    max_depth = 0\n    current_depth\
    \ = 0\n    results = []\n    for char in paren_string:\n        if char == '(':\n\
    \            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n\
    \        elif char == ')':\n            results.append(max_depth)\n          \
    \  current_depth -= 1\n            max_depth = 0\n    return results\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpalvlgwfz.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpalvlgwfz.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpalvlgwfz.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ paren_group in paren_string.split(' '):\n        level = 0\n        max_level\
    \ = 0\n        for paren in paren_group:\n            if paren == '(':\n     \
    \           level += 1\n                max_level = max(max_level, level)\n  \
    \          elif paren == ')':\n                level -= 1\n        res.append(max_level)\n\
    \    return res\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_level = 0\n  \
    \  levels = []\n    for c in paren_string:\n        if c == '(':\n           \
    \ max_level += 1\n            levels.append(max_level)\n        if c == ')':\n\
    \            levels.append(max_level)\n            max_level -= 1\n    return\
    \ levels\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpxj2jvxlk.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpxj2jvxlk.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxj2jvxlk.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ parens in paren_string.split(' '):\n        parens_level = 0\n        for paren\
    \ in parens:\n            if paren == '(':\n                parens_level += 1\n\
    \            else:\n                parens_level -= 1\n            result.append(parens_level)\n\
    \    return result\n\nprint(parse_nested_parens('(()()) ((())) () ((())()())'))\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp6de07ft7.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmp6de07ft7.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp6de07ft7.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: '[1, 2, 1, 2, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 3, 2, 1, 2, 1, 2, 1, 0]

    '
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ paren in paren_string.split(' '):\n        if not paren:\n            res.append(0)\n\
    \            continue\n        stack = []\n        max_depth = 0\n        for\
    \ c in paren:\n            if c == '(':\n                stack.append(c)\n   \
    \             max_depth = max(max_depth, len(stack))\n            else:\n    \
    \            stack.pop()\n        res.append(max_depth)\n    return res\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nesting = []\n\
    \    for parens in paren_string.split(' '):\n        paren_stack = []\n      \
    \  max_nesting_in_this_group = 0\n        for paren in parens:\n            if\
    \ paren == '(':\n                paren_stack.append(paren)\n                max_nesting_in_this_group\
    \ = max(max_nesting_in_this_group, len(paren_stack))\n            elif paren ==\
    \ ')':\n                paren_stack.pop()\n        max_nesting.append(max_nesting_in_this_group)\n\
    \    return max_nesting\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group_strings = paren_string.split()\n\
    \    return [nest_level(gs) for gs in group_strings]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp3sq4uxpn.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmp3sq4uxpn.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp3sq4uxpn.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp3sq4uxpn.py\", line 12, in parse_nested_parens\n\
    \    return [nest_level(gs) for gs in group_strings]\n  File \"/tmp/tmp3sq4uxpn.py\"\
    , line 12, in <listcomp>\n    return [nest_level(gs) for gs in group_strings]\n\
    NameError: name 'nest_level' is not defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split('\
    \ ')\n    return [nested_paren_level(paren) for paren in paren_list]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnpxfmum0.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpnpxfmum0.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpnpxfmum0.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpnpxfmum0.py\", line 12, in parse_nested_parens\n\
    \    return [nested_paren_level(paren) for paren in paren_list]\n  File \"/tmp/tmpnpxfmum0.py\"\
    , line 12, in <listcomp>\n    return [nested_paren_level(paren) for paren in paren_list]\n\
    NameError: name 'nested_paren_level' is not defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_indices = []\n\
    \n    for parentheses in paren_string.split():\n        max_nested_count = 0\n\
    \        current_count = 0\n        for paren in parentheses:\n            if\
    \ paren == '(':\n                current_count += 1\n                max_nested_count\
    \ = max(max_nested_count, current_count)\n            elif paren == ')':\n   \
    \             current_count -= 1\n        paren_indices.append(max_nested_count)\n\
    \n    return paren_indices\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ group in paren_string.split():\n        stack = []\n        max_nest = 0\n \
    \       for char in group:\n            if char == '(':\n                stack.append(char)\n\
    \                max_nest = max(max_nest, len(stack))\n            else:\n   \
    \             stack.pop()\n        result.append(max_nest)\n    return result\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed_string = paren_string.split('\
    \ ')\n    max_depth = 0\n    curr_depth = 0\n    output = []\n    for word in\
    \ parsed_string:\n        for char in word:\n            if char == '(':\n   \
    \             curr_depth += 1\n                max_depth = max(max_depth, curr_depth)\n\
    \            else:\n                curr_depth -= 1\n        output.append(max_depth)\n\
    \        max_depth = 0\n        curr_depth = 0\n    return output\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    levels = []\n    level\
    \ = 0\n    for c in paren_string:\n        if c == '(':\n            level +=\
    \ 1\n        elif c == ')':\n            level -= 1\n        elif c == ' ':\n\
    \            levels.append(level)\n            level = 0\n    return levels\n\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpdfszq5ew.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpdfszq5ew.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdfszq5ew.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    max_depth = []\n    for group in groups:\n        depth = 0\n        max_depth_curr\
    \ = 0\n        for paren in group:\n            if paren == '(':\n           \
    \     depth += 1\n                max_depth_curr = max(max_depth_curr, depth)\n\
    \            elif paren == ')':\n                depth -= 1\n        max_depth.append(max_depth_curr)\n\
    \    return max_depth\n\nprint(parse_nested_parens('(()()) ((())) () ((())()())'))\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: '[2, 3, 1, 3]

    '
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    def count_nested_parens(paren_group: str) -> int:\n\
    \        paren_count = 0\n        deepest_nested_paren = 0\n        for c in paren_group:\n\
    \            if c == '(':\n                paren_count += 1\n                deepest_nested_paren\
    \ = max(paren_count, deepest_nested_paren)\n            else:\n              \
    \  paren_count -= 1\n        return deepest_nested_paren\n\n    return [count_nested_parens(s)\
    \ for s in paren_string.split()]\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split('\
    \ ')\n    ans = []\n    for group in groups:\n        ans.append(get_max_nesting(group))\n\
    \    return ans\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpsy04_kfw.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpsy04_kfw.py\", line 23,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpsy04_kfw.py\"\
    , line 18, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpsy04_kfw.py\", line 14, in parse_nested_parens\n\
    \    ans.append(get_max_nesting(group))\nNameError: name 'get_max_nesting' is\
    \ not defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pass\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmport6yg46.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmport6yg46.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmport6yg46.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Let's assume that\
    \ the input is well formed - i.e. each parentheses is either opening or closing\
    \ but not both.\n    paren_stack = []\n    max_height = 0\n    result = []\n \
    \   for paren in paren_string:\n        if paren == '(':\n            paren_stack.append(paren)\n\
    \            max_height = max(max_height, len(paren_stack))\n        elif paren\
    \ == ')':\n            paren_stack.pop()\n        elif paren == ' ':\n       \
    \     result.append(max_height)\n            max_height = 0\n    result.append(max_height)\n\
    \n    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ paren_group in paren_string.split(' '):\n        depth = 0\n        max_depth\
    \ = 0\n        for s in paren_group:\n            if s == '(':\n             \
    \   depth += 1\n                max_depth = max(max_depth, depth)\n          \
    \  elif s == ')':\n                depth -= 1\n        res.append(max_depth)\n\
    \    return res\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth_list = []\n\n\
    \    for nested_parens in paren_string.split():\n        assert nested_parens[0]\
    \ == '(' and nested_parens[-1] == ')'\n        depth = 0\n        max_depth =\
    \ 0\n        for paren in nested_parens:\n            if paren == '(':\n     \
    \           depth += 1\n                max_depth = max(max_depth, depth)\n  \
    \          elif paren == ')':\n                depth -= 1\n            else:\n\
    \                raise ValueError\n        depth_list.append(max_depth)\n\n  \
    \  return depth_list\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth = 0\n  \
    \  current_depth = 0\n    depths = []\n    for paren in paren_string:\n      \
    \  if paren == '(':\n            current_depth += 1\n            max_depth = max(max_depth,\
    \ current_depth)\n        elif paren == ')':\n            current_depth -= 1\n\
    \        elif paren == ' ':\n            depths.append(max_depth)\n          \
    \  max_depth = 0\n            current_depth = 0\n    depths.append(max_depth)\n\
    \    return depths\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split('\
    \ ')\n    levels = []\n    for group in groups:\n        current_level = 0\n \
    \       max_level = 0\n        for paren in group:\n            if paren == '(':\n\
    \                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            else:\n                current_level -= 1\n    \
    \    levels.append(max_level)\n    return levels\n\ndef check(candidate):\n  \
    \  assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    ans = []\n    for\
    \ s in paren_string.split():\n        # assume input string is valid\n       \
    \ stack = []\n        max_nesting = 0\n        for c in s:\n            if c ==\
    \ '(':\n                stack.append(c)\n                max_nesting = max(max_nesting,\
    \ len(stack))\n            else:\n                stack.pop()\n        ans.append(max_nesting)\n\
    \    return ans\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO: complete this\
    \ function\n    raise NotImplementedError\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfibkhi7g.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmpfibkhi7g.py\", line 19,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpfibkhi7g.py\"\
    , line 14, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpfibkhi7g.py\", line 12, in parse_nested_parens\n\
    \    raise NotImplementedError\nNotImplementedError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO write your\
    \ code here\n    return []\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfl2vt62z.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpfl2vt62z.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpfl2vt62z.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def get_max_nesting(paren_string:\
    \ str) -> int:\n        max_nesting = 0\n        current_nesting = 0\n       \
    \ for paren in paren_string:\n            if paren == '(':\n                current_nesting\
    \ += 1\n                max_nesting = max(max_nesting, current_nesting)\n    \
    \        elif paren == ')':\n                current_nesting -= 1\n        return\
    \ max_nesting\n\n    return [get_max_nesting(paren_string) for paren_string in\
    \ paren_string.split()]\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    rv = []\n    for paren_group\
    \ in paren_string.split():\n        rv.append(max_nesting(paren_group))\n    return\
    \ rv\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpp8rsrbxo.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpp8rsrbxo.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpp8rsrbxo.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpp8rsrbxo.py\", line 13, in parse_nested_parens\n\
    \    rv.append(max_nesting(paren_group))\nNameError: name 'max_nesting' is not\
    \ defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split('\
    \ ')\n    depth_list = [0] * len(paren_list)\n    for idx, paren in enumerate(paren_list):\n\
    \        depth = 0\n        for p in paren:\n            if p == '(':\n      \
    \          depth += 1\n            else:\n                depth -= 1\n       \
    \     depth_list[idx] = max(depth, depth_list[idx])\n    return depth_list\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group_parens = paren_string.split('\
    \ ')\n    return [len(re.findall(r'\\(\\(', group)) for group in group_parens]\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpd5x6a5zr.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpd5x6a5zr.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpd5x6a5zr.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpd5x6a5zr.py\", line 12, in parse_nested_parens\n\
    \    return [len(re.findall(r'\\(\\(', group)) for group in group_parens]\n  File\
    \ \"/tmp/tmpd5x6a5zr.py\", line 12, in <listcomp>\n    return [len(re.findall(r'\\\
    (\\(', group)) for group in group_parens]\nNameError: name 're' is not defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # O(n) time and O(1)\
    \ space\n    # Base case: either empty string or '('\n    # If string starts with\
    \ ')', return 0\n    # If there is no parenthesis then just return 0\n    if not\
    \ paren_string:\n        return 0\n    open_count = 0\n    max_count = 0\n   \
    \ for char in paren_string:\n        if char == '(':\n            open_count +=\
    \ 1\n            max_count = max(max_count, open_count)\n        elif char ==\
    \ ')':\n            open_count -= 1\n    return max_count\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpijj43nl1.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpijj43nl1.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpijj43nl1.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    max_nesting\
    \ = 0\n    current_nesting = 0\n    for char in paren_string:\n        if char\
    \ == '(':\n            current_nesting += 1\n            max_nesting = max(max_nesting,\
    \ current_nesting)\n        elif char == ')':\n            current_nesting -=\
    \ 1\n        elif char == ' ':\n            output.append(max_nesting)\n     \
    \       max_nesting = 0\n            current_nesting = 0\n    output.append(max_nesting)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split('\
    \ ')\n    return [max_nesting_parens(paren_group) for paren_group in paren_groups]\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfpy6cii2.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpfpy6cii2.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpfpy6cii2.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpfpy6cii2.py\", line 12, in parse_nested_parens\n\
    \    return [max_nesting_parens(paren_group) for paren_group in paren_groups]\n\
    \  File \"/tmp/tmpfpy6cii2.py\", line 12, in <listcomp>\n    return [max_nesting_parens(paren_group)\
    \ for paren_group in paren_groups]\nNameError: name 'max_nesting_parens' is not\
    \ defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nested_nums =\
    \ []\n    for parens in paren_string.split():\n        current_level = 0\n   \
    \     max_level = 0\n        for paren in parens:\n            if paren == '(':\n\
    \                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            elif paren == ')':\n                current_level\
    \ -= 1\n        max_nested_nums.append(max_level)\n    return max_nested_nums\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth = 0\n    result\
    \ = []\n    for char in paren_string:\n        if char == '(':\n            depth\
    \ += 1\n        elif char == ')':\n            result.append(depth)\n        \
    \    depth -= 1\n    return result\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp_f5k3ag7.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmp_f5k3ag7.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp_f5k3ag7.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def compute_max_depth(paren_group:\
    \ str) -> int:\n        max_depth = 0\n        running_depth = 0\n        for\
    \ char in paren_group:\n            if char == '(':\n                running_depth\
    \ += 1\n                max_depth = max(max_depth, running_depth)\n          \
    \  elif char == ')':\n                running_depth -= 1\n        return max_depth\n\
    \n    paren_groups = paren_string.split(' ')\n    return [compute_max_depth(group)\
    \ for group in paren_groups]\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    max_nesting = []\n    for group in groups:\n        level = 0\n        max_level\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   level += 1\n                max_level = max(max_level, level)\n          \
    \  else:\n                level -= 1\n        max_nesting.append(max_level)\n\
    \    return max_nesting\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ paren_group in paren_string.split():\n        # To track nesting level, we use\
    \ a stack of elements.\n        # Each time we encounter an opening parenthesis,\
    \ we push a marker to the stack.\n        # Each time we encounter a closing parenthesis,\
    \ we pop an element from the stack.\n        # The deepest level of nesting is\
    \ the length of the stack when we are done traversing the group.\n        stack\
    \ = []\n        for paren in paren_group:\n            if paren == '(':\n    \
    \            stack.append(paren)\n            elif paren == ')':\n           \
    \     stack.pop()\n        result.append(len(stack))\n    return result\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpzuor25ez.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpzuor25ez.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpzuor25ez.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # split the input\
    \ string into multiple groups of nested parentheses\n    paren_groups = paren_string.split()\n\
    \    # array to hold the maximum level of nesting\n    max_level = []\n    # loop\
    \ through each of the groups\n    for group in paren_groups:\n        # variable\
    \ to hold the level of nesting\n        level = 0\n        # variable to hold\
    \ the maximum level of nesting for a group\n        max_level_group = 0\n    \
    \    # loop through each of the characters in the group\n        for char in group:\n\
    \            # if character is an opening parenthesis, increment the level of\
    \ nesting\n            if char == '(':\n                level += 1\n         \
    \   # if character is a closing parenthesis, decrement the level of nesting\n\
    \            if char == ')':\n                level -= 1\n            # if the\
    \ current level of nesting is greater than the maximum level\n            # of\
    \ nesting for the group, then update the maximum level of nesting\n          \
    \  if level > max_level_group:\n                max_level_group = level\n    \
    \    # append the maximum level of nesting for the group to the array\n      \
    \  max_level.append(max_level_group)\n    # return the array\n    return max_level\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    ans = []\n    for\
    \ paren_group in paren_string.split():\n        max_level = 0\n        curr_level\
    \ = 0\n        for char in paren_group:\n            if char == '(':\n       \
    \         curr_level += 1\n                max_level = max(max_level, curr_level)\n\
    \            elif char == ')':\n                curr_level -= 1\n        ans.append(max_level)\n\
    \    return ans\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def _parse_nested_parens(current_str):\n\
    \        \"\"\"Parse string recursively and return max nesting level of current\
    \ substring.\"\"\"\n        if not current_str:\n            return 0\n      \
    \  else:\n            if current_str[0] == '(':\n                return 1 + _parse_nested_parens(current_str[1:])\n\
    \            elif current_str[0] == ')':\n                return 0\n         \
    \   else:\n                return _parse_nested_parens(current_str[1:])\n\n  \
    \  return [_parse_nested_parens(current_str) for current_str in paren_string.split()]\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpdn2_dv4r.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpdn2_dv4r.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdn2_dv4r.py\"\
    , line 29, in check\n    assert candidate('(()(())((())))') == [4]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    deepest_levels = []\n\
    \    for paren_group in paren_string.split():\n        max_level = 0\n       \
    \ curr_level = 0\n        for char in paren_group:\n            if char == '(':\n\
    \                curr_level += 1\n                max_level = max(max_level, curr_level)\n\
    \            else:\n                curr_level -= 1\n        deepest_levels.append(max_level)\n\
    \    return deepest_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split('\
    \ ')\n    max_depth = []\n    for paren_group in paren_groups:\n        curr_depth\
    \ = 0\n        max_depth_group = 0\n        for paren in paren_group:\n      \
    \      if paren == '(':\n                curr_depth += 1\n            elif paren\
    \ == ')':\n                curr_depth -= 1\n            max_depth_group = max(max_depth_group,\
    \ curr_depth)\n        max_depth.append(max_depth_group)\n    return max_depth\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # You code goes here\n\
    \    return [2, 3, 1, 3]\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpy0k4lerd.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpy0k4lerd.py\", line 21,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpy0k4lerd.py\"\
    , line 17, in check\n    assert candidate('() (()) ((())) (((())))') == [1, 2,\
    \ 3, 4]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ paren_group in paren_string.split():\n        max_level = 0\n        curr_level\
    \ = 0\n        for paren in paren_group:\n            if paren == '(':\n     \
    \           curr_level += 1\n                max_level = max(max_level, curr_level)\n\
    \            elif paren == ')':\n                curr_level -= 1\n        result.append(max_level)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nested_parens\
    \ = []\n    for paren_group in paren_string.split():\n        max_so_far = 0\n\
    \        current_nested_parens = 0\n        for char in paren_group:\n       \
    \     if char == '(':\n                current_nested_parens += 1\n          \
    \      max_so_far = max(max_so_far, current_nested_parens)\n            else:\n\
    \                current_nested_parens -= 1\n        max_nested_parens.append(max_so_far)\n\
    \    return max_nested_parens\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_levels = []\n\
    \    for paren_group in paren_string.split():\n        current_level = 0\n   \
    \     max_level = 0\n        for char in paren_group:\n            if char ==\
    \ '(':\n                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            elif char == ')':\n                current_level\
    \ -= 1\n        max_levels.append(max_level)\n    return max_levels\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split()\n\
    \    max_levels = []\n    for paren_group in paren_list:\n        count = 0\n\
    \        num_levels = 0\n        for c in paren_group:\n            if c == '(':\n\
    \                count += 1\n                num_levels = max(num_levels, count)\n\
    \            elif c == ')':\n                count -= 1\n        max_levels.append(num_levels)\n\
    \    return max_levels\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth = 0\n  \
    \  current_depth = 0\n    output = []\n    for paren in paren_string:\n      \
    \  if paren == '(':\n            current_depth += 1\n            max_depth = max(max_depth,\
    \ current_depth)\n        elif paren == ')':\n            current_depth -= 1\n\
    \        elif paren == ' ':\n            output.append(max_depth)\n          \
    \  max_depth = 0\n            current_depth = 0\n    output.append(max_depth)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for\
    \ group in paren_string.split():\n        max_depth = 0\n        current_depth\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   current_depth += 1\n                max_depth = max(max_depth, current_depth)\n\
    \            elif char == ')':\n                current_depth -= 1\n        output.append(max_depth)\n\
    \    return output\n\nprint(parse_nested_parens('(()()) ((())) () ((())()())'))\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: '[2, 3, 1, 3]

    '
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nest_count = []\n\
    \    temp_count = 0\n    for char in paren_string:\n        if char == '(':\n\
    \            temp_count += 1\n        elif char == ')':\n            temp_count\
    \ -= 1\n        elif char == ' ':\n            nest_count.append(temp_count)\n\
    \            temp_count = 0\n    return nest_count\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmplzv46959.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmplzv46959.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmplzv46959.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split('\
    \ ')\n    output = []\n    for group in paren_groups:\n        stack = []\n  \
    \      max_depth = 0\n        for c in group:\n            if c == '(':\n    \
    \            stack.append(c)\n                max_depth = max(max_depth, len(stack))\n\
    \            else:\n                stack.pop()\n        output.append(max_depth)\n\
    \    return output\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ group in paren_string.split():\n        nesting_level = 0\n        current_max\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   nesting_level += 1\n                current_max = max(current_max, nesting_level)\n\
    \            else:\n                nesting_level -= 1\n        res.append(current_max)\n\
    \    return res\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth = 0\n  \
    \  depths = []\n    for elem in paren_string.split(' '):\n        depth = 0\n\
    \        for ch in elem:\n            if ch == '(':\n                depth +=\
    \ 1\n            elif ch == ')':\n                depth -= 1\n        depths.append(depth)\n\
    \    return depths\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9kikb9ce.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmp9kikb9ce.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9kikb9ce.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nesting = 0\n\
    \    current_nesting = 0\n    max_nesting_per_group = []\n    for char in paren_string:\n\
    \        if char == '(':\n            current_nesting += 1\n            max_nesting\
    \ = max(max_nesting, current_nesting)\n        elif char == ')':\n           \
    \ current_nesting -= 1\n        elif char == ' ':\n            max_nesting_per_group.append(max_nesting)\n\
    \            max_nesting = 0\n            current_nesting = 0\n    max_nesting_per_group.append(max_nesting)\n\
    \    return max_nesting_per_group\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ paren_group in paren_string.split(' '):\n        max_level = 0\n        level\
    \ = 0\n        for i in range(len(paren_group)):\n            if paren_group[i]\
    \ == '(':\n                level += 1\n                max_level = max(max_level,\
    \ level)\n            else:\n                level -= 1\n        result.append(max_level)\n\
    \    return result\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ paren_string in paren_string.split():\n        curr_level = 0\n        max_level\
    \ = 0\n        for paren in paren_string:\n            if paren == '(':\n    \
    \            curr_level += 1\n                max_level = max(max_level, curr_level)\n\
    \            elif paren == ')':\n                curr_level -= 1\n        res.append(max_level)\n\
    \    return res\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    max_depth\
    \ = 0\n    current_depth = 0\n    for c in paren_string:\n        if c == '(':\n\
    \            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n\
    \        elif c == ')':\n            current_depth -= 1\n        elif c == ' ':\n\
    \            output.append(max_depth)\n            max_depth = 0\n           \
    \ current_depth = 0\n    output.append(max_depth)\n    return output\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # We are looking for\
    \ the maximum depth of nesting of the parentheses\n    # at any point in time\
    \ in the string\n    depth_so_far = 0\n    max_depth = 0\n    depths = []\n\n\
    \    for char in paren_string:\n        if char == '(':\n            depth_so_far\
    \ += 1\n            max_depth = max(max_depth, depth_so_far)\n        elif char\
    \ == ')':\n            depth_so_far -= 1\n        elif char == ' ':\n        \
    \    depths.append(max_depth)\n            max_depth = 0\n            depth_so_far\
    \ = 0\n\n    depths.append(max_depth)\n\n    return depths\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_level = []\n \
    \   level = 0\n    for bracket in paren_string:\n        if bracket == '(':\n\
    \            level += 1\n        elif bracket == ')':\n            max_level.append(level)\n\
    \            level -= 1\n    return max_level\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpp843x6ys.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmpp843x6ys.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpp843x6ys.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pass\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmport6yg46.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmport6yg46.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmport6yg46.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for\
    \ group in paren_string.split():\n        if len(group) == 0:\n            output.append(0)\n\
    \            continue\n        stack = []\n        max_depth = 0\n        for\
    \ char in group:\n            if char == '(':\n                stack.append(char)\n\
    \                max_depth = max(max_depth, len(stack))\n            elif char\
    \ == ')':\n                if len(stack) == 0:\n                    break\n  \
    \              else:\n                    stack.pop()\n        if len(stack) ==\
    \ 0:\n            output.append(max_depth)\n        else:\n            output.append(0)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    current_depth = 0\n\
    \    max_depth = 0\n    result = []\n    for char in paren_string:\n        if\
    \ char == '(':\n            current_depth += 1\n            max_depth = max(max_depth,\
    \ current_depth)\n        elif char == ')':\n            current_depth -= 1\n\
    \        elif char == ' ':\n            result.append(max_depth)\n           \
    \ max_depth = 0\n            current_depth = 0\n    result.append(max_depth)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    results = []\n   \
    \ for parens in paren_string.split():\n        max_level = 0\n        level =\
    \ 0\n        for char in parens:\n            if char == '(':\n              \
    \  level += 1\n                max_level = max(max_level, level)\n           \
    \ elif char == ')':\n                level -= 1\n            else:\n         \
    \       raise ValueError(\"Invalid character! {}\".format(char))\n        if level\
    \ != 0:\n            raise ValueError(\"Unbalanced parentheses\")\n        results.append(max_level)\n\
    \    return results\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ parens in paren_string.split():\n        level, max_level = 0, 0\n        for\
    \ paren in parens:\n            if paren == '(':\n                level += 1\n\
    \                max_level = max(max_level, level)\n            else:\n      \
    \          level -= 1\n        result.append(max_level)\n    return result\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = [0]\
    \ * len(paren_string.split())\n    paren_stack = []\n    i = 0\n    for paren\
    \ in paren_string:\n        if paren == '(':\n            paren_stack.append(paren)\n\
    \        elif paren == ')':\n            if paren_stack:\n                paren_stack.pop()\n\
    \            else:\n                nested_parens[i] = -1\n        elif paren\
    \ == ' ':\n            i += 1\n            if paren_stack:\n                nested_parens[i]\
    \ = len(paren_stack)\n    if paren_stack:\n        nested_parens[-1] = -1\n  \
    \  return nested_parens\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpr55_2c_7.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmpr55_2c_7.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpr55_2c_7.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth_list = []\n\
    \    for i in paren_string.split():\n        max_depth = 0\n        current_depth\
    \ = 0\n        for char in i:\n            if char == '(':\n                current_depth\
    \ += 1\n                max_depth = max(max_depth, current_depth)\n          \
    \  elif char == ')':\n                current_depth -= 1\n        max_depth_list.append(max_depth)\n\
    \    return max_depth_list\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    print(groups)\n    return [paren_depth(group) for group in groups]\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpsf_kit4a.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpsf_kit4a.py\", line 21,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpsf_kit4a.py\"\
    , line 16, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpsf_kit4a.py\", line 13, in parse_nested_parens\n\
    \    return [paren_depth(group) for group in groups]\n  File \"/tmp/tmpsf_kit4a.py\"\
    , line 13, in <listcomp>\n    return [paren_depth(group) for group in groups]\n\
    NameError: name 'paren_depth' is not defined\n"
  stdout: '[''(()())'', ''((()))'', ''()'', ''((())()())'']

    '
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split('\
    \ ')\n    output = []\n    for paren_group in groups:\n        curr_level = 0\n\
    \        max_level = 0\n        for c in paren_group:\n            if c == '(':\n\
    \                curr_level += 1\n                max_level = max(max_level, curr_level)\n\
    \            elif c == ')':\n                curr_level -= 1\n        output.append(max_level)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n\
    \    if not paren_string:\n        return []\n    result = []\n    curr_string\
    \ = ''\n    while paren_string:\n        # We have to separate the individual\
    \ string first\n        char = paren_string[0]\n        if char in ['(', ')']:\n\
    \            curr_string += char\n        elif char == ' ':\n            if curr_string:\n\
    \                result.append(curr_string)\n                curr_string = ''\n\
    \        paren_string = paren_string[1:]\n    result.append(curr_string)\n   \
    \ # Now, we can count how many levels of nesting.\n    # We can simply use a stack\
    \ here.\n    stack = []\n    final_result = []\n    for string in result:\n  \
    \      curr_level = 0\n        for char in string:\n            if char == '(':\n\
    \                stack.append(char)\n                curr_level += 1\n       \
    \     elif char == ')':\n                stack.pop()\n                curr_level\
    \ -= 1\n        final_result.append(curr_level)\n    return final_result\n\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpff6texzn.py\", line\
    \ 52, in <module>\n    test_check()\n  File \"/tmp/tmpff6texzn.py\", line 50,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpff6texzn.py\"\
    , line 45, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed_parens = []\n\
    \n    for paren_group in paren_string.split(' '):\n        depth = 0\n       \
    \ max_depth = 0\n        for paren in paren_group:\n            if paren == '(':\n\
    \                depth += 1\n                max_depth = max(max_depth, depth)\n\
    \            else:\n                depth -= 1\n        parsed_parens.append(max_depth)\n\
    \n    return parsed_parens\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nesting_counts\
    \ = []\n    paren_stacks = paren_string.split()\n    for paren_stack in paren_stacks:\n\
    \        max_nesting_count = 0\n        curr_nesting_count = 0\n        for paren\
    \ in paren_stack:\n            if paren == '(':\n                curr_nesting_count\
    \ += 1\n                max_nesting_count = max(max_nesting_count, curr_nesting_count)\n\
    \            else:\n                curr_nesting_count -= 1\n        max_nesting_counts.append(max_nesting_count)\n\
    \    return max_nesting_counts\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nested_list =\
    \ []\n    num_max_nested = 0\n    for c in paren_string:\n        if c == '(':\n\
    \            num_max_nested += 1\n        elif c == ')':\n            num_max_nested\
    \ -= 1\n        elif c == ' ':\n            max_nested_list.append(num_max_nested)\n\
    \            num_max_nested = 0\n    return max_nested_list\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmppj4hx4o1.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmppj4hx4o1.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmppj4hx4o1.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    answer = []\n    for\
    \ string in paren_string.split(' '):\n        level = 0\n        max_level = 0\n\
    \        for char in string:\n            if char == '(':\n                level\
    \ += 1\n                max_level = max(max_level, level)\n            elif char\
    \ == ')':\n                level -= 1\n        answer.append(max_level)\n    return\
    \ answer\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ paren_group in paren_string.split(' '):\n        count = 0\n        max_count\
    \ = 0\n        for s in paren_group:\n            if s == '(':\n             \
    \   count += 1\n                max_count = max(max_count, count)\n          \
    \  elif s == ')':\n                count -= 1\n        result.append(max_count)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group_strings = paren_string.split('\
    \ ')\n    max_levels = []\n    for group_string in group_strings:\n        max_level\
    \ = 0\n        level = 0\n        for char in group_string:\n            if char\
    \ == '(':\n                level += 1\n                max_level = max(max_level,\
    \ level)\n            else:\n                level -= 1\n        max_levels.append(max_level)\n\
    \    return max_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    results = []\n    for group in groups:\n        counter = 0\n        result\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   counter += 1\n                result = max(result, counter)\n            else:\n\
    \                counter -= 1\n        results.append(result)\n    return results\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split('\
    \ ')\n    depths = []\n    for paren in paren_list:\n        depth = 0\n     \
    \   for p in paren:\n            if p == '(':\n                depth += 1\n  \
    \          elif p == ')':\n                depth -= 1\n        depths.append(depth)\n\
    \    return depths\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpo38peu3x.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpo38peu3x.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpo38peu3x.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Split the input\
    \ string on spaces.\n    paren_strings = paren_string.split(' ')\n    # Check\
    \ for invalid inputs (should be even number of parens)\n    for paren_str in paren_strings:\n\
    \        if len(paren_str) % 2 != 0:\n            raise ValueError('Input string\
    \ contains odd number of parentheses')\n    # Check if parentheses are in correct\
    \ format\n    if not all(paren_str[i] == '(' and paren_str[-i-1] == ')' for i\
    \ in range(len(paren_str)//2)):\n        raise ValueError('Input string contains\
    \ invalid parentheses')\n    # Traverse the string, if \"(\" encountered, increase\
    \ depth by 1, if \")\" encountered, decrease depth by 1.\n    # Keep track of\
    \ depth and max depth.\n    max_depth = [0] * len(paren_strings)\n    for i, paren_str\
    \ in enumerate(paren_strings):\n        depth = 0\n        for paren in paren_str:\n\
    \            if paren == '(':\n                depth += 1\n            elif paren\
    \ == ')':\n                depth -= 1\n            max_depth[i] = max(max_depth[i],\
    \ depth)\n    return max_depth\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpyoax7maf.py\", line\
    \ 41, in <module>\n    test_check()\n  File \"/tmp/tmpyoax7maf.py\", line 39,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpyoax7maf.py\"\
    , line 34, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpyoax7maf.py\", line 19, in parse_nested_parens\n\
    \    raise ValueError('Input string contains invalid parentheses')\nValueError:\
    \ Input string contains invalid parentheses\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_counts = []\n\
    \    for paren_group in paren_string.split():\n        paren_counts.append(parse_parens(paren_group))\n\
    \    return paren_counts\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpenoxtiwb.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpenoxtiwb.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpenoxtiwb.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpenoxtiwb.py\", line 13, in parse_nested_parens\n\
    \    paren_counts.append(parse_parens(paren_group))\nNameError: name 'parse_parens'\
    \ is not defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n\
    \    if paren_string == \"\":\n        return []\n    result = []\n    count =\
    \ 0\n    for paren in paren_string:\n        if paren == '(':\n            count\
    \ += 1\n        elif paren == ')':\n            count -= 1\n        elif paren\
    \ == ' ':\n            result.append(count)\n            count = 0\n    result.append(count)\n\
    \    return result\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2s73a_9l.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmp2s73a_9l.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2s73a_9l.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def convert_nested_parens(paren_string:\
    \ str) -> int:\n        \"\"\" Input to this function is a string representing\
    \ a single group of nested parentheses.\n        Output the maximum depth of nesting.\n\
    \        \"\"\"\n        max_depth = current_depth = 0\n        for c in paren_string:\n\
    \            if c == '(':\n                current_depth += 1\n              \
    \  max_depth = max(max_depth, current_depth)\n            elif c == ')':\n   \
    \             current_depth -= 1\n        return max_depth\n\n    results = []\n\
    \    for paren_string in paren_string.split():\n        results.append(convert_nested_parens(paren_string))\n\
    \    return results\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    return [_find_max_depth(group) for group in groups]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp23wzy7z1.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmp23wzy7z1.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp23wzy7z1.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp23wzy7z1.py\", line 12, in parse_nested_parens\n\
    \    return [_find_max_depth(group) for group in groups]\n  File \"/tmp/tmp23wzy7z1.py\"\
    , line 12, in <listcomp>\n    return [_find_max_depth(group) for group in groups]\n\
    NameError: name '_find_max_depth' is not defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed_results = []\n\
    \    for paren_group in paren_string.split():\n        level = 0\n        max_level\
    \ = 0\n        for paren in paren_group:\n            if paren == '(':\n     \
    \           level += 1\n                max_level = max(max_level, level)\n  \
    \          elif paren == ')':\n                level -= 1\n        parsed_results.append(max_level)\n\
    \    return parsed_results\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Split the string\
    \ into list of parenthesis groups and iterate over them.\n    return [find_max_nested_parens(parens)\
    \ for parens in paren_string.split()]\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmphgch0wva.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmphgch0wva.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmphgch0wva.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmphgch0wva.py\", line 12, in parse_nested_parens\n\
    \    return [find_max_nested_parens(parens) for parens in paren_string.split()]\n\
    \  File \"/tmp/tmphgch0wva.py\", line 12, in <listcomp>\n    return [find_max_nested_parens(parens)\
    \ for parens in paren_string.split()]\nNameError: name 'find_max_nested_parens'\
    \ is not defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nesting_levels\
    \ = []\n    for parens in paren_string.split():\n        stack = []\n        max_level\
    \ = 0\n        for paren in parens:\n            if paren == '(':\n          \
    \      stack.append(paren)\n                max_level = max(max_level, len(stack))\n\
    \            elif paren == ')':\n                stack.pop()\n        max_nesting_levels.append(max_level)\n\
    \    return max_nesting_levels\n\nprint(parse_nested_parens('(()()) ((())) ()\
    \ ((())()())'))\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: '[2, 3, 1, 3]

    '
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # STUB\n    return\
    \ []\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjo8d07rw.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpjo8d07rw.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpjo8d07rw.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n\
    \    result = []\n    max_depth = 0\n    for c in paren_string:\n        if c\
    \ == '(':\n            paren_stack.append(c)\n            max_depth = max(max_depth,\
    \ len(paren_stack))\n        elif c == ')':\n            paren_stack.pop()\n \
    \       elif c == ' ':\n            result.append(max_depth)\n            max_depth\
    \ = 0\n    result.append(max_depth)\n    return result\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    res = []\n    for group in groups:\n        nest_lvl = 0\n        highest_lvl\
    \ = 0\n        for c in group:\n            if c == '(':\n                nest_lvl\
    \ += 1\n            elif c == ')':\n                nest_lvl -= 1\n          \
    \  if nest_lvl > highest_lvl:\n                highest_lvl = nest_lvl\n      \
    \  res.append(highest_lvl)\n    return res\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    curr_max = 0\n   \
    \ max_levels = []\n    for paren in paren_string.split(' '):\n        for i, c\
    \ in enumerate(paren):\n            if c == '(':\n                curr_max +=\
    \ 1\n            else:\n                max_levels.append(curr_max)\n        \
    \        curr_max -= 1\n        max_levels.append(curr_max)\n        curr_max\
    \ = 0\n    return max_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp4zp0i553.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmp4zp0i553.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp4zp0i553.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ parens in paren_string.split():\n        result.append(parens_depth(parens))\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp1ugimx1k.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmp1ugimx1k.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1ugimx1k.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp1ugimx1k.py\", line 13, in parse_nested_parens\n\
    \    result.append(parens_depth(parens))\nNameError: name 'parens_depth' is not\
    \ defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pass\n```\n\n```python\n\
    from typing import List\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpoqu04tvw.py\", line 12\n    ```\n    ^\nSyntaxError: invalid\
    \ syntax\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_paren_level =\
    \ [0]\n    paren_level = 0\n    for paren in paren_string:\n        if paren ==\
    \ '(':\n            paren_level += 1\n            max_paren_level[-1] = max(max_paren_level[-1],\
    \ paren_level)\n        elif paren == ')':\n            paren_level -= 1\n   \
    \     elif paren == ' ':\n            max_paren_level.append(0)\n    return max_paren_level\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ parens in paren_string.split(' '):\n        depth = 0\n        deepest = 0\n\
    \        for paren in parens:\n            if paren == '(':\n                depth\
    \ += 1\n            elif paren == ')':\n                depth -= 1\n         \
    \   deepest = max(deepest, depth)\n        result.append(deepest)\n    return\
    \ result\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for\
    \ group in paren_string.split():\n        max_depth = 0\n        current_depth\
    \ = 0\n        for paren in group:\n            if paren == '(':\n           \
    \     current_depth += 1\n                max_depth = max(max_depth, current_depth)\n\
    \            elif paren == ')':\n                current_depth -= 1\n        output.append(max_depth)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_levels = [0]\n\
    \    counter = 0\n    for char in paren_string:\n        if char == '(':\n   \
    \         counter += 1\n            max_levels.append(counter)\n        elif char\
    \ == ')':\n            counter -= 1\n        elif char == ' ':\n            max_levels.append(counter)\n\
    \    max_levels.append(counter)\n    return max_levels[1:]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpybdr6d5_.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpybdr6d5_.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpybdr6d5_.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split('\
    \ ')\n    return [_nesting_level(group) for group in groups]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpa8spw2xh.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpa8spw2xh.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpa8spw2xh.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpa8spw2xh.py\", line 12, in parse_nested_parens\n\
    \    return [_nesting_level(group) for group in groups]\n  File \"/tmp/tmpa8spw2xh.py\"\
    , line 12, in <listcomp>\n    return [_nesting_level(group) for group in groups]\n\
    NameError: name '_nesting_level' is not defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    groups = paren_string.split()\n    result = []\n   \
    \ for group in groups:\n        stack = []\n        max_level = 0\n        current_level\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   stack.append(char)\n                current_level += 1\n                max_level\
    \ = max(max_level, current_level)\n            elif char == ')':\n           \
    \     stack.pop()\n                current_level -= 1\n        result.append(max_level)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth = 0\n  \
    \  current_depth = 0\n    result = []\n    for paren in paren_string:\n      \
    \  if paren == '(':\n            current_depth += 1\n            max_depth = max(max_depth,\
    \ current_depth)\n        elif paren == ')':\n            current_depth -= 1\n\
    \        elif paren == ' ':\n            result.append(max_depth)\n          \
    \  max_depth = 0\n            current_depth = 0\n    result.append(max_depth)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def deep(paren):\n\
    \        deepest = 0\n        current = 0\n        for p in paren:\n         \
    \   if p == '(':\n                current += 1\n                deepest = max(deepest,\
    \ current)\n            else:\n                current -= 1\n        return deepest\n\
    \n    return [deep(p) for p in paren_string.split()]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = [int(group)\
    \ for group in paren_string.split(' ')]\n    num_nested_parens = []\n    for group\
    \ in groups:\n        num_nested_parens.append(len(group))\n    return num_nested_parens\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmnyzwuk1.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpmnyzwuk1.py\", line 23,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpmnyzwuk1.py\"\
    , line 18, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpmnyzwuk1.py\", line 11, in parse_nested_parens\n\
    \    groups = [int(group) for group in paren_string.split(' ')]\n  File \"/tmp/tmpmnyzwuk1.py\"\
    , line 11, in <listcomp>\n    groups = [int(group) for group in paren_string.split('\
    \ ')]\nValueError: invalid literal for int() with base 10: '(()())'\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ parens in paren_string.split():\n        if parens[0] != '(' or parens[-1] !=\
    \ ')':\n            raise ValueError('Malformed input. Please refer to the description.')\n\
    \        stack = []\n        max_depth = 0\n        for c in parens:\n       \
    \     if c == '(':\n                stack.append(c)\n                max_depth\
    \ = max(max_depth, len(stack))\n            elif c == ')':\n                stack.pop()\n\
    \        result.append(max_depth)\n    return result\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # split the parenthesis\
    \ string into groups\n    paren_groups = paren_string.split()\n    depths = []\n\
    \    # for each group, keep a count for the current depth\n    for paren_group\
    \ in paren_groups:\n        current_depth = 0\n        max_depth = 0\n       \
    \ for paren in paren_group:\n            if paren == '(':\n                current_depth\
    \ += 1\n                max_depth = max(max_depth, current_depth)\n          \
    \  elif paren == ')':\n                current_depth -= 1\n        depths.append(max_depth)\n\
    \    return depths\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n\
    \    output = []\n    for group in paren_groups:\n        depth = 0\n        max_depth\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   depth += 1\n                max_depth = max(max_depth, depth)\n          \
    \  elif char == ')':\n                depth -= 1\n        output.append(max_depth)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ group in paren_string.split():\n        max_depth = 0\n        current_depth\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   current_depth += 1\n                max_depth = max(max_depth, current_depth)\n\
    \            elif char == ')':\n                current_depth -= 1\n        result.append(max_depth)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def is_open_bracket(ch:\
    \ str) -> bool:\n        return ch == '('\n\n    def is_close_bracket(ch: str)\
    \ -> bool:\n        return ch == ')'\n\n    if not paren_string:\n        return\
    \ []\n\n    open_brackets = []\n    depth = 0\n    max_depth = 0\n    max_depth_by_paren_group\
    \ = []\n    # This loop traverses all the characters in the string, updating the\
    \ \"open_brackets\" stack of parentheses and\n    # capturing the maximum depth\
    \ of nesting of parentheses seen at every point in time.\n    for i in range(len(paren_string)):\n\
    \        ch = paren_string[i]\n        if is_open_bracket(ch):\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n            open_brackets.append(ch)\n\
    \        if is_close_bracket(ch):\n            depth -= 1\n            # This\
    \ check checks for the closing bracket without a corresponding opening bracket.\n\
    \            if depth < 0:\n                return []\n            open_brackets.pop()\n\
    \        # This condition captures the maximum depth at the end of every group.\n\
    \        if i+1 == len(paren_string) or paren_string[i+1] == ' ':\n          \
    \  if open_brackets:\n                return []\n            else:\n         \
    \       max_depth_by_paren_group.append(max_depth)\n                max_depth\
    \ = 0\n                depth = 0\n    return max_depth_by_paren_group\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split('\
    \ ')\n    ans = []\n    for group in groups:\n        stack = []\n        for\
    \ paren in group:\n            if paren == '(':\n                stack.append(paren)\n\
    \            else:\n                stack.pop()\n        ans.append(len(stack))\n\
    \    return ans\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjqrzkulq.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpjqrzkulq.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpjqrzkulq.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n\
    \    output = []\n    for group in paren_groups:\n        level = 0\n        curr_max\
    \ = 0\n        for paren in group:\n            if paren == '(':\n           \
    \     level += 1\n                curr_max = max(curr_max, level)\n          \
    \  elif paren == ')':\n                level -= 1\n        output.append(curr_max)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ s in paren_string.split(' '):\n        level = 0\n        max_level = 0\n  \
    \      for c in s:\n            if c == '(':\n                level += 1\n   \
    \             max_level = max(max_level, level)\n            elif c == ')':\n\
    \                level -= 1\n        result.append(max_level)\n    return result\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n\
    \    paren_depth = []\n    for group in paren_groups:\n        depth = 0\n   \
    \     max_depth = 0\n        for char in group:\n            if char == '(':\n\
    \                depth += 1\n                max_depth = max(max_depth, depth)\n\
    \            elif char == ')':\n                depth -= 1\n        paren_depth.append(max_depth)\n\
    \    return paren_depth\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    curr_max\
    \ = 0\n    for c in paren_string:\n        if c == '(':\n            curr_max\
    \ += 1\n        elif c == ')':\n            curr_max -= 1\n        elif c == '\
    \ ':\n            res.append(curr_max)\n            curr_max = 0\n    return res\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp3q_b8sbr.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmp3q_b8sbr.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp3q_b8sbr.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ paren_group in paren_string.split(' '):\n        max_nesting = 0\n        curr_nesting\
    \ = 0\n        for paren in paren_group:\n            if paren == '(':\n     \
    \           curr_nesting += 1\n                max_nesting = max(max_nesting,\
    \ curr_nesting)\n            else:\n                curr_nesting -= 1\n      \
    \  res.append(max_nesting)\n    return res\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split('\
    \ ')\n    depths = [get_nested_parens_depths(p) for p in paren_list]\n    return\
    \ depths\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpcub3o0pp.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpcub3o0pp.py\", line 21,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpcub3o0pp.py\"\
    , line 16, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpcub3o0pp.py\", line 12, in parse_nested_parens\n\
    \    depths = [get_nested_parens_depths(p) for p in paren_list]\n  File \"/tmp/tmpcub3o0pp.py\"\
    , line 12, in <listcomp>\n    depths = [get_nested_parens_depths(p) for p in paren_list]\n\
    NameError: name 'get_nested_parens_depths' is not defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for\
    \ i in paren_string.split(' '):\n        output.append(len(re.findall('\\(', i)))\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpc8_xi_sj.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpc8_xi_sj.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpc8_xi_sj.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpc8_xi_sj.py\", line 13, in parse_nested_parens\n\
    \    output.append(len(re.findall('\\(', i)))\nNameError: name 're' is not defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Maintain a count\
    \ of current level of nesting\n    max_level = 0\n    curr_level = 0\n    result\
    \ = []\n    # Iterate the characters in the string and update the current level\
    \ of nesting based on the parentheses\n    for c in paren_string:\n        if\
    \ c == '(':\n            curr_level += 1\n            if curr_level > max_level:\n\
    \                max_level = curr_level\n        elif c == ')':\n            curr_level\
    \ -= 1\n        elif c == ' ':\n            result.append(max_level)\n       \
    \     max_level = 0\n            curr_level = 0\n    result.append(max_level)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string.count('(')\
    \ != paren_string.count(')'):\n        raise ValueError('Parentheses string contains\
    \ mismatched number of parenthesis')\n\n    num_parens = paren_string.count('(')\n\
    \    groups = paren_string.split(' ')\n    output = []\n    for g in groups:\n\
    \        if g.count('(') != g.count(')'):\n            raise ValueError('Parentheses\
    \ string contains mismatched number of parenthesis')\n        count = 0\n    \
    \    max_count = 0\n        for c in g:\n            if c == '(':\n          \
    \      count += 1\n                max_count = max(max_count, count)\n       \
    \     elif c == ')':\n                count -= 1\n        output.append(max_count)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string.strip()\
    \ == '':\n        return []\n\n    paren_groups = paren_string.split(' ')\n  \
    \  output = []\n    for group in paren_groups:\n        if group == '':\n    \
    \        output.append(0)\n            continue\n\n        max_so_far = 0\n  \
    \      current_max = 0\n        for i in range(len(group)):\n            if group[i]\
    \ == '(':\n                current_max += 1\n                if current_max >\
    \ max_so_far:\n                    max_so_far = current_max\n            elif\
    \ group[i] == ')':\n                if current_max > 0:\n                    current_max\
    \ -= 1\n                else:\n                    raise ValueError('Unbalanced\
    \ parentheses at index {}: {}'.format(i, group))\n            else:\n        \
    \        raise ValueError('Unexpected character at index {}: {}'.format(i, group))\n\
    \n        if current_max != 0:\n            raise ValueError('Unbalanced parentheses\
    \ in group: {}'.format(group))\n\n        output.append(max_so_far)\n\n    return\
    \ output\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split('\
    \ ')\n    return [max_nested_paren(group) for group in groups]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpl845sbbw.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpl845sbbw.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpl845sbbw.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpl845sbbw.py\", line 12, in parse_nested_parens\n\
    \    return [max_nested_paren(group) for group in groups]\n  File \"/tmp/tmpl845sbbw.py\"\
    , line 12, in <listcomp>\n    return [max_nested_paren(group) for group in groups]\n\
    NameError: name 'max_nested_paren' is not defined. Did you mean: 'parse_nested_parens'?\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_level = []\n\n\
    \    for group in paren_string.split(' '):\n        if group == '':\n        \
    \    continue\n\n        curr_level = 0\n        for char in group:\n        \
    \    if char == '(':\n                curr_level += 1\n            elif char ==\
    \ ')':\n                curr_level -= 1\n                if curr_level < 0:\n\
    \                    curr_level = 0\n        max_level.append(curr_level)\n\n\
    \    return max_level\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp20ajeo30.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmp20ajeo30.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp20ajeo30.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    results = []\n   \
    \ stack = []\n    for i, s in enumerate(paren_string):\n        if s == '(':\n\
    \            stack.append(i)\n        elif s == ')':\n            stack.pop()\n\
    \            if len(stack) == 0:\n                results.append(i)\n    return\
    \ results\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpejt9gqat.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpejt9gqat.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpejt9gqat.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    return [_deepest_nesting(group) for group in groups]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpo3wfz36n.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpo3wfz36n.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpo3wfz36n.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpo3wfz36n.py\", line 12, in parse_nested_parens\n\
    \    return [_deepest_nesting(group) for group in groups]\n  File \"/tmp/tmpo3wfz36n.py\"\
    , line 12, in <listcomp>\n    return [_deepest_nesting(group) for group in groups]\n\
    NameError: name '_deepest_nesting' is not defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth = 0\n  \
    \  curr_depth = 0\n    nesting_depth = []\n    for char in paren_string:\n   \
    \     if char == '(':\n            curr_depth += 1\n            max_depth = max(max_depth,\
    \ curr_depth)\n        elif char == ')':\n            curr_depth -= 1\n      \
    \  elif char == ' ':\n            nesting_depth.append(max_depth)\n          \
    \  max_depth = 0\n            curr_depth = 0\n    nesting_depth.append(max_depth)\n\
    \    return nesting_depth\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nesting = 0\n\
    \    current_nesting = 0\n    result = []\n    for char in paren_string:\n   \
    \     if char == '(':\n            current_nesting += 1\n            max_nesting\
    \ = max(max_nesting, current_nesting)\n        elif char == ')':\n           \
    \ current_nesting -= 1\n        elif char == ' ':\n            result.append(max_nesting)\n\
    \            max_nesting = 0\n            current_nesting = 0\n    result.append(max_nesting)\n\
    \    return result\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Brute force approach\
    \ is to iterate through each of the parenthesis group, count the number of opening\n\
    \    # parentheses, and subtract by the number of closing parentheses. \n    max_nesting\
    \ = []\n    num_open = 0\n    num_close = 0\n    for char in paren_string:\n \
    \       if char == '(':\n            num_open += 1\n        elif char == ')':\n\
    \            num_close += 1\n        elif char == ' ':\n            max_nesting.append(num_open\
    \ - num_close)\n            num_open = 0\n            num_close = 0\n    return\
    \ max_nesting\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpezvxon4d.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpezvxon4d.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpezvxon4d.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    deep_nested_levels\
    \ = []\n    for group in paren_string.split(' '):\n        curr_level = 0\n  \
    \      max_level = 0\n        for paren in group:\n            if paren == '(':\n\
    \                curr_level += 1\n                max_level = max(max_level, curr_level)\n\
    \            else:\n                curr_level -= 1\n        deep_nested_levels.append(max_level)\n\
    \    return deep_nested_levels\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split()\n\
    \    max_nested_list = []\n    for paren in paren_list:\n        max_nested =\
    \ 0\n        paren_counter = 0\n        for ch in paren:\n            if ch ==\
    \ '(':\n                paren_counter += 1\n                max_nested = max(max_nested,\
    \ paren_counter)\n            elif ch == ')':\n                paren_counter -=\
    \ 1\n        max_nested_list.append(max_nested)\n    return max_nested_list\n\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split('\
    \ ')\n    parsed_list = []\n    for paren_group in paren_groups:\n        nested_depth\
    \ = 0\n        max_nested_depth = 0\n        for char in paren_group:\n      \
    \      if char == '(':\n                nested_depth += 1\n            elif char\
    \ == ')':\n                nested_depth -= 1\n            max_nested_depth = max(max_nested_depth,\
    \ nested_depth)\n        parsed_list.append(max_nested_depth)\n    return parsed_list\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_levels = []\n\
    \    for group in paren_string.split():\n        nested_levels.append(nested_parens(group))\n\
    \    return nested_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpsl12yhpz.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpsl12yhpz.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpsl12yhpz.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpsl12yhpz.py\", line 13, in parse_nested_parens\n\
    \    nested_levels.append(nested_parens(group))\nNameError: name 'nested_parens'\
    \ is not defined. Did you mean: 'nested_levels'?\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    idx = 0\n    paren_groups\
    \ = paren_string.split(' ')\n    for paren_group in paren_groups:\n        current_level\
    \ = 0\n        max_level = 0\n        for char in paren_group:\n            if\
    \ char == '(':\n                current_level += 1\n                max_level\
    \ = max(max_level, current_level)\n            elif char == ')':\n           \
    \     current_level -= 1\n            else:\n                pass\n\n        print(max_level)\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpcr1zge4z.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpcr1zge4z.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpcr1zge4z.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: '2

    3

    1

    3

    '
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split('\
    \ ')\n    output = []\n    for group in paren_groups:\n        open_parens = 0\n\
    \        max_nesting = 0\n        for char in group:\n            if char == '(':\n\
    \                open_parens += 1\n                max_nesting = max(max_nesting,\
    \ open_parens)\n            elif char == ')':\n                open_parens -=\
    \ 1\n            else:\n                raise ValueError(f'Unsupported character:\
    \ {char}')\n        output.append(max_nesting)\n    return output\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    ans = []\n    for\
    \ group in paren_string.split():\n        ans.append(parse_nested_parens_group(group))\n\
    \    return ans\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpcu2d_8gn.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpcu2d_8gn.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpcu2d_8gn.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpcu2d_8gn.py\", line 13, in parse_nested_parens\n\
    \    ans.append(parse_nested_parens_group(group))\nNameError: name 'parse_nested_parens_group'\
    \ is not defined. Did you mean: 'parse_nested_parens'?\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ paren_group in paren_string.split():\n        current_nesting = 0\n        max_nesting\
    \ = 0\n        for paren in paren_group:\n            if paren == '(':\n     \
    \           current_nesting += 1\n                max_nesting = max(max_nesting,\
    \ current_nesting)\n            else:\n                current_nesting -= 1\n\
    \        result.append(max_nesting)\n    return result\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Split the string\
    \ by the delimiter ' ' and iterate through each item\n    return [max(paren_depth_tally(item))\
    \ for item in paren_string.split(' ')]\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpxjeqbee_.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpxjeqbee_.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxjeqbee_.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpxjeqbee_.py\", line 12, in parse_nested_parens\n\
    \    return [max(paren_depth_tally(item)) for item in paren_string.split(' ')]\n\
    \  File \"/tmp/tmpxjeqbee_.py\", line 12, in <listcomp>\n    return [max(paren_depth_tally(item))\
    \ for item in paren_string.split(' ')]\nNameError: name 'paren_depth_tally' is\
    \ not defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pass\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmps1uvr4_a.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmps1uvr4_a.py\", line 19,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmps1uvr4_a.py\"\
    , line 14, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # We will track the\
    \ maximum level of nesting of parentheses at each point.\n    # We will also track\
    \ the difference between the number of open and close parentheses.\n    # Each\
    \ time we see a open parentheses, we increment the number of open parentheses.\n\
    \    # Each time we see a close parentheses, we decrement the number of open parentheses.\n\
    \    # We also track the maximum level of nesting by keeping track of the maximum\
    \ difference between open and close parentheses.\n    max_nesting = 0\n    open_paren\
    \ = 0\n    # We will iterate over each of the paren group.\n    for paren_string\
    \ in paren_string.split():\n        # We will track the maximum level of nesting\
    \ of the current paren group.\n        max_nesting_current = 0\n        open_paren_current\
    \ = 0\n        # We iterate over each character in the paren group.\n        for\
    \ char in paren_string:\n            if char == '(':\n                open_paren_current\
    \ += 1\n            elif char == ')':\n                open_paren_current -= 1\n\
    \            # if we see a close parentheses without seeing an open parenthesis,\
    \ it means that we are violating the rules.\n            # We will return -1.\n\
    \            if open_paren_current < 0:\n                return -1\n         \
    \   # We update the maximum level of nesting of the current paren group.\n   \
    \         max_nesting_current = max(max_nesting_current, open_paren_current)\n\
    \        # We update the maximum level of nesting of all paren groups.\n     \
    \   max_nesting = max(max_nesting, max_nesting_current)\n        # At the end\
    \ of each paren group, we should have the same number of open and close parentheses.\n\
    \        # If we don't, it means that we are violating the rules. We will return\
    \ -1.\n        if open_paren_current != 0:\n            return -1\n    return\
    \ max_nesting\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpzlm48qfw.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpzlm48qfw.py\", line 49,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpzlm48qfw.py\"\
    , line 44, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    max_nesting = []\n    for group in groups:\n        count = 0\n        max_local\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   count += 1\n                max_local = max(max_local, count)\n          \
    \  else:\n                count -= 1\n        max_nesting.append(max_local)\n\
    \    return max_nesting\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    from operator import\
    \ ne\n    from itertools import dropwhile, islice\n    max_nesting_levels = []\n\
    \    for paren_group in paren_string.split():\n        max_nesting_levels.append(next(islice(dropwhile(ne,\
    \ (paren_group.count('(') - paren_group.count(')'))*(-1), 0), 1, None)))\n   \
    \ return max_nesting_levels\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp841g3ols.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmp841g3ols.py\", line 23,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp841g3ols.py\"\
    , line 18, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp841g3ols.py\", line 15, in parse_nested_parens\n\
    \    max_nesting_levels.append(next(islice(dropwhile(ne, (paren_group.count('(')\
    \ - paren_group.count(')'))*(-1), 0), 1, None)))\nTypeError: dropwhile expected\
    \ 2 arguments, got 3\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    paren_groups\
    \ = paren_string.split(' ')\n    for paren_group in paren_groups:\n        i =\
    \ 0\n        tmp = 0\n        while i < len(paren_group):\n            if paren_group[i]\
    \ == '(':\n                tmp += 1\n            elif paren_group[i] == ')':\n\
    \                tmp -= 1\n            i += 1\n        res.append(tmp)\n    return\
    \ res\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpxu3sxuoe.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmpxu3sxuoe.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxu3sxuoe.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    return [find_max_parens(i) for i in groups]\n\ndef check(candidate):\n  \
    \  assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2ud730un.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmp2ud730un.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2ud730un.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp2ud730un.py\", line 12, in parse_nested_parens\n\
    \    return [find_max_parens(i) for i in groups]\n  File \"/tmp/tmp2ud730un.py\"\
    , line 12, in <listcomp>\n    return [find_max_parens(i) for i in groups]\nNameError:\
    \ name 'find_max_parens' is not defined\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    ans = []\n    for\
    \ paren in paren_string.split():\n        num_open_parens = 0\n        max_depth\
    \ = 0\n        for c in paren:\n            if c == '(':\n                num_open_parens\
    \ += 1\n                max_depth = max(max_depth, num_open_parens)\n        \
    \    else:\n                num_open_parens -= 1\n        ans.append(max_depth)\n\
    \    return ans\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    lst = paren_string.split()\n\
    \    output = []\n    for paren in lst:\n        max_depth = 0\n        current_depth\
    \ = 0\n        for char in paren:\n            if char == '(':\n             \
    \   current_depth += 1\n                max_depth = max(max_depth, current_depth)\n\
    \            elif char == ')':\n                current_depth -= 1\n         \
    \   else:\n                raise ValueError(f'Unexpected character: {char}')\n\
    \        output.append(max_depth)\n    return output\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n\
    \    if not paren_string:\n        return []\n    elif ' ' not in paren_string:\n\
    \        return [max_nested_parens(paren_string)]\n    else:\n        string_list\
    \ = paren_string.split(' ')\n        return [max_nested_parens(s) for s in string_list]\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp_6zbingx.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmp_6zbingx.py\", line 26,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp_6zbingx.py\"\
    , line 21, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp_6zbingx.py\", line 18, in parse_nested_parens\n\
    \    return [max_nested_parens(s) for s in string_list]\n  File \"/tmp/tmp_6zbingx.py\"\
    , line 18, in <listcomp>\n    return [max_nested_parens(s) for s in string_list]\n\
    NameError: name 'max_nested_parens' is not defined. Did you mean: 'parse_nested_parens'?\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    levels_of_nesting\
    \ = []\n    for paren_grp in paren_string.split():\n        max_nesting = 0\n\
    \        current_nesting = 0\n        for paren in paren_grp:\n            if\
    \ paren == '(':\n                current_nesting += 1\n                max_nesting\
    \ = max(max_nesting, current_nesting)\n            elif paren == ')':\n      \
    \          current_nesting -= 1\n        levels_of_nesting.append(max_nesting)\n\
    \    return levels_of_nesting\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    levels = []\n    for group in paren_string.split(' '):\n\
    \        current_level = 0\n        max_level = 0\n        for ch in group:\n\
    \            if ch == '(':\n                current_level += 1\n             \
    \   max_level = max(max_level, current_level)\n            else:\n           \
    \     current_level -= 1\n        levels.append(max_level)\n    return levels\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # To keep track of\
    \ current level of nesting\n    curr_max = 0\n    # To store maximum level of\
    \ nesting\n    max_sofar = 0\n    # To store the result\n    max_levels = []\n\
    \    # Process each group of nested parens\n    for char in paren_string:\n  \
    \      if char == '(':\n            curr_max += 1\n            max_sofar = max(max_sofar,\
    \ curr_max)\n        elif char == ')':\n            curr_max -= 1\n        elif\
    \ char == ' ':\n            max_levels.append(max_sofar)\n            max_sofar\
    \ = 0\n            curr_max = 0\n    max_levels.append(max_sofar)\n    return\
    \ max_levels\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group_list = paren_string.split('\
    \ ')\n    max_depth_list = []\n    for group in group_list:\n        max_depth\
    \ = 0\n        current_depth = 0\n        for char in group:\n            if char\
    \ == '(':\n                current_depth += 1\n                max_depth = max(max_depth,\
    \ current_depth)\n            else:\n                current_depth -= 1\n    \
    \    max_depth_list.append(max_depth)\n    return max_depth_list\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    max_paren_count = 0\n    curr_paren_count = 0\n    output\
    \ = []\n\n    for char in paren_string:\n        if char == '(':\n           \
    \ curr_paren_count += 1\n            max_paren_count = max(max_paren_count, curr_paren_count)\n\
    \        elif char == ')':\n            curr_paren_count -= 1\n        elif char\
    \ == ' ':\n            output.append(max_paren_count)\n            max_paren_count\
    \ = 0\n            curr_paren_count = 0\n\n    output.append(max_paren_count)\n\
    \    return output\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Using a stack to\
    \ track\n    # (1) how many open parentheses there are currently\n    # (2) the\
    \ max number of open parentheses we have seen so far\n\n    # O(n) space complexity\n\
    \    # O(n) time complexity\n\n    results = []\n    paren_string = paren_string.strip()\n\
    \    prev_num_open_parens = 0\n    max_open_parens = 0\n    for c in paren_string:\n\
    \        if c == '(':\n            prev_num_open_parens += 1\n            max_open_parens\
    \ = max(max_open_parens, prev_num_open_parens)\n        elif c == ')':\n     \
    \       prev_num_open_parens -= 1\n        elif c == ' ':\n            results.append(max_open_parens)\n\
    \            max_open_parens = 0\n            prev_num_open_parens = 0\n    results.append(max_open_parens)\n\
    \    return results\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nesting = [0]\n\
    \    current_nesting = 0\n    for ch in paren_string:\n        if ch == '(':\n\
    \            current_nesting += 1\n            max_nesting[-1] = max(max_nesting[-1],\
    \ current_nesting)\n        elif ch == ')':\n            current_nesting -= 1\n\
    \        elif ch == ' ':\n            max_nesting.append(0)\n            current_nesting\
    \ = 0\n    return max_nesting\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_group_list =\
    \ paren_string.split()\n    max_level_of_nesting_list = []\n    for paren_group\
    \ in paren_group_list:\n        paren_stack = []\n        max_level_of_nesting\
    \ = 0\n        for paren in paren_group:\n            if paren == '(':\n     \
    \           paren_stack.append(paren)\n                max_level_of_nesting =\
    \ max(max_level_of_nesting, len(paren_stack))\n            elif paren == ')':\n\
    \                paren_stack.pop()\n        max_level_of_nesting_list.append(max_level_of_nesting)\n\
    \    return max_level_of_nesting_list\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO: implement\n\
    \    output = []\n    for string in paren_string.split():\n        counter = 1\n\
    \        stack = []\n        for ch in string:\n            if ch == '(':\n  \
    \              stack.append(ch)\n                counter += 1\n            else:\n\
    \                stack.pop()\n                counter -= 1\n            output.append(counter)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpuhe42cap.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpuhe42cap.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpuhe42cap.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    ret_arr = []\n   \
    \ stack = []\n    paren_string = paren_string.strip()\n    start_index = 0\n \
    \   for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n \
    \           stack.append(paren_string[i])\n        elif paren_string[i] == ')':\n\
    \            if len(stack) == 0:\n                ret_arr.append(0)\n        \
    \        start_index = i + 1\n            else:\n                stack.pop()\n\
    \        elif paren_string[i] == ' ':\n            if len(stack) == 0:\n     \
    \           ret_arr.append(0)\n                start_index = i + 1\n    ret_arr.append(len(stack))\n\
    \    print(ret_arr)\n    return ret_arr\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp5h4eqivf.py\", line\
    \ 40, in <module>\n    test_check()\n  File \"/tmp/tmp5h4eqivf.py\", line 38,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp5h4eqivf.py\"\
    , line 33, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: '[0, 0, 0, 0]

    '
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split('\
    \ ')\n    output = []\n    for group in paren_groups:\n        level = 0\n   \
    \     max_level = 0\n        for ch in group:\n            if ch == '(':\n   \
    \             level += 1\n                max_level = max(max_level, level)\n\
    \            elif ch == ')':\n                level -= 1\n        output.append(max_level)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    curr_max = 0\n   \
    \ max_levels = []\n    for paren in paren_string.split():\n        if paren[0]\
    \ == '(':\n            curr_max += 1\n        for c in paren:\n            if\
    \ c == '(':\n                curr_max += 1\n            elif c == ')':\n     \
    \           curr_max -= 1\n        max_levels.append(curr_max)\n        curr_max\
    \ = 0\n    return max_levels\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp8xppod47.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmp8xppod47.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp8xppod47.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ group in paren_string.split():\n        if group[0] != '(' or group[-1] != ')':\n\
    \            raise Exception(\"Incorrect parentheses string {}\".format(group))\n\
    \        level = 0\n        max_level = 0\n        for ch in group:\n        \
    \    if ch == '(':\n                level += 1\n            elif ch == ')':\n\
    \                level -= 1\n            max_level = max(max_level, level)\n \
    \       result.append(max_level)\n    return result\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    current_depth\
    \ = 0\n    max_depth = 0\n    for char in paren_string:\n        if char == '(':\n\
    \            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n\
    \        elif char == ')':\n            current_depth -= 1\n        elif char\
    \ == ' ':\n            result.append(max_depth)\n            max_depth = 0\n \
    \           current_depth = 0\n    result.append(max_depth)\n    return result\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822096
