name: HumanEval_12_longest
language: py
prompt: "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n\
  \    \"\"\" Out of list of strings, return the longest one. Return the first one\
  \ in case of multiple\n    strings of the same length. Return None in case the input\
  \ list is empty.\n    >>> longest([])\n    None\n    >>> longest(['a', 'b', 'c'])\n\
  \    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x',\
  \ 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc'])\
  \ == 'zzzz'\n\ndef test_check():\n    check(longest)\n\ntest_check()\n"
completions: ["    if not strings:\n        return None\n    else:\n        long =\
    \ strings[0]\n        for s in strings:\n            if len(s) > len(long):\n\
    \                long = s\n        return long\n", "    pass\n ", '    return
    max(strings, key=len) if strings else None', "    if not strings:\n        return\
    \ None\n    res = strings[0]\n    for s in strings:\n        if len(s) > len(res):\n\
    \            res = s\n    return res\n\n", "    if not strings:\n        return\
    \ None\n    longest_string = strings[0]\n    for string in strings:\n        if\
    \ len(string) > len(longest_string):\n            longest_string = string\n  \
    \  return longest_string", "    if not strings:\n        return None\n    if len(strings)\
    \ == 1:\n        return strings[0]\n    else:\n        longest_so_far = strings[0]\n\
    \        for string in strings[1:]:\n            if len(string) > len(longest_so_far):\n\
    \                longest_so_far = string\n        return longest_so_far\n", " \
    \   if len(strings) == 0:\n        return None\n    longest = strings[0]\n   \
    \ for element in strings:\n        if len(element) > len(longest):\n         \
    \   longest = element\n    return longest\n", "    pass\n\n", "    return (strings\
    \ or [None])[0]\n\n", "    if not strings:\n        return None\n    longest_so_far\
    \ = strings[0]\n    for next_string in strings[1:]:\n        if len(next_string)\
    \ > len(longest_so_far):\n            longest_so_far = next_string\n    return\
    \ longest_so_far\n", "    longest = None\n    for string in strings:\n       \
    \ if longest is None or len(string) > len(longest):\n            longest = string\n\
    \    return longest\n", "    if len(strings) == 0:\n        return None\n    return\
    \ sorted(strings, key=len)[-1]", "    # TODO: implement me\n    return None\n",
  "    if not strings:\n        return None\n    return max(strings, key=len)\n",
  "    if len(strings) == 0:\n        return None\n    longest_string = strings[0]\n\
    \    for string in strings:\n        if len(string) > len(longest_string):\n \
    \           longest_string = string\n    return longest_string\n", "    if not\
    \ strings:\n        return None\n    return max(strings, key=len)\n", "    if\
    \ not strings:\n        return None\n    else:\n        longest = strings[0]\n\
    \        for s in strings:\n            if len(s) > len(longest):\n          \
    \      longest = s\n        return longest\n", "    if not strings:\n        return\
    \ None\n    longest_string = strings[0]\n    for s in strings:\n        if len(s)\
    \ > len(longest_string):\n            longest_string = s\n    return longest_string\n",
  "    if len(strings) == 0:\n        return None\n    else:\n        lengths = map(len,\
    \ strings)\n        max_index = lengths.index(max(lengths))\n        return strings[max_index]\n",
  "    ...\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
