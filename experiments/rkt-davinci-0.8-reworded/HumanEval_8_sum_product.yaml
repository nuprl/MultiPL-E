name: HumanEval_8_sum_product
language: rkt
prompt: "#lang racket\n\n;; For a given list of integers, return a list consisting\
  \ of a sum and a product of all the integers in a list.\n;; Empty sum should be\
  \ equal to 0 and empty product should be equal to 1.\n;; >>> (sum_product (list\
  \ ))\n;; (list 0 1)\n;; >>> (sum_product (list 1 2 3 4))\n;; (list 10 24)\n(define\
  \ (sum_product numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_product))\n\
  \    (check-equal? (candidate (list )) (list 0 1))\n    (check-equal? (candidate\
  \ (list 1 1 1)) (list 3 1))\n    (check-equal? (candidate (list 100 0)) (list 100\
  \ 0))\n    (check-equal? (candidate (list 3 5 7)) (list 15 105))\n    (check-equal?\
  \ (candidate (list 10)) (list 10 10))\n))\n\n(test-humaneval)"
completions: ["  (list (apply + numbers) (apply * numbers)))\n", "  (let (\n     \
    \   (sum (apply + numbers))\n        (product (apply * numbers)))\n    (list sum\
    \ product)))\n", "  (list (foldl + 0 numbers)\n        (foldl * 1 numbers)))\n",
  "  (match numbers\n    [(list) (list 0 1)]\n    [(list x ...) (list (+ x (sum_product\
    \ (list ...))) (* x (sum_product (list ...))))]))", "  (list (foldl + 0 numbers)\n\
    \        (foldl * 1 numbers)))\n", "  (define (helper numbers result)\n    (if\
    \ (null? numbers)\n        result\n        (helper (cdr numbers) (list (+ (car\
    \ numbers) (car result)) (* (car numbers) (cadr result))))))\n  (helper numbers\
    \ (list 0 1)))\n", "  (define (sum-pair a b)\n    (list (+ a b) (* a b)))\n  (foldl\
    \ sum-pair '(0 1) numbers))\n", "  (list\n   (apply + numbers)\n   (apply * numbers)))\n",
  "  (list (sum numbers) (product numbers)))\n", "  (list\n   (apply + numbers)\n\
    \   (apply * numbers)))\n", "  (define (helper sum product rest)\n    (if (null?\
    \ rest)\n        (list sum product)\n        (helper (+ sum (car rest)) (* product\
    \ (car rest)) (cdr rest))))\n  (helper 0 1 numbers))\n", "  (list\n   (foldl +\
    \ 0 numbers)\n   (foldl * 1 numbers)))\n", "  (list (apply + numbers) (apply *\
    \ numbers)))\n```\n\n```racket\n#lang racket\n", "  (list (+ 0 (list-ref numbers\
    \ 0)) (* 1 (list-ref numbers 0))))\n```\n\nHere is the same program if we had\
    \ not learned the essence of programming yet:\n\n```racket\n#lang racket\n", " \
    \   (let ([sum (apply + numbers)]\n          [product (apply * numbers)])\n  \
    \      (list sum product)))\n", "  (let loop ((numbers numbers)\n            \
    \ (sum 0)\n             (product 1))\n    (if (null? numbers)\n        (list sum\
    \ product)\n        (loop (cdr numbers)\n              (+ sum (car numbers))\n\
    \              (* product (car numbers))))))\n", "  (match numbers\n    [(list)\
    \ (list 0 1)]\n    [(list head tail ...) (list (+ head (car (sum_product tail)))\
    \ (* head (car (sum_product tail))))]))\n```\n\n**Racket source**:\n\n```racket\n\
    #lang racket\n", "  (list (apply + numbers) (apply * numbers)))\n```\n\n```racket\n\
    #lang racket\n", "    (define (sum l)\n        (if (null? l)\n            0\n\
    \            (+ (car l) (sum (cdr l)))))\n    (define (product l)\n        (if\
    \ (null? l)\n            1\n            (* (car l) (product (cdr l)))))\n    (list\
    \ (sum numbers) (product numbers)))\n\n", "  (list (apply + numbers)\n       \
    \ (apply * numbers)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
