name: HumanEval_48_is_palindrome
language: rkt
prompt: "#lang racket\n\n;; Checks if given string is a palindrome\n;; >>> (is_palindrome\
  \ \"\")\n;; #t\n;; >>> (is_palindrome \"aba\")\n;; #t\n;; >>> (is_palindrome \"\
  aaaaa\")\n;; #t\n;; >>> (is_palindrome \"zbcd\")\n;; #f\n(define (is_palindrome\
  \ text)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_palindrome))\n\
  \    (check-equal? (candidate \"\") #t)\n    (check-equal? (candidate \"aba\") #t)\n\
  \    (check-equal? (candidate \"aaaaa\") #t)\n    (check-equal? (candidate \"zbcd\"\
  ) #f)\n    (check-equal? (candidate \"xywyx\") #t)\n    (check-equal? (candidate\
  \ \"xywyz\") #f)\n    (check-equal? (candidate \"xywzx\") #f)\n))\n\n(test-humaneval)"
completions: ["  (cond [(string= text \"\") #t]\n        [(not (string= text (string-reverse\
    \ text))) #f]\n        [else #t]))\n", "  (define (is_palindrome_iter text reverse)\n\
    \    (if (string=? text \"\")\n        (string=? text reverse)\n        (is_palindrome_iter\
    \ (substring text 1) (string-append (substring reverse 0 1) (substring text 0\
    \ 1)))))\n  (is_palindrome_iter text \"\"))\n", "  (if (or (= (string-length text)\
    \ 0) (= (string-length text) 1))\n      #t\n      (let* ([len (string-length text)]\n\
    \             [mid (quotient len 2)]\n             [left (substring text 0 mid)]\n\
    \             [right (substring text (- len mid) len)])\n        (string=? left\
    \ (string-reverse right)))))\n", "  (define (match_letters match_fst match_snd)\n\
    \    (and\n      (= (string-length text)\n         (+ 1 (string-length (string-trim-both\
    \ text \" \"))))\n      (match_fst (substring text 0 (- (string-length text) 1))\n\
    \                (substring text 1 (string-length text)))))\n  (define (match_letters_forward\
    \ text)\n    (match_letters string-prefix? string-suffix?))\n  (define (match_letters_backward\
    \ text)\n    (match_letters string-suffix? string-prefix?))\n  (or (match_letters_forward\
    \ text)\n      (match_letters_backward text)))\n```\n\n## Tests\n\n```racket\n\
    #lang racket\n", "  (and\n   (not (null? text))\n   (or\n    (equal? (first text)\
    \ (last text))\n    (is_palindrome (substring text 1 (- (string-length text) 1))))))\n",
  "  (equal? (string-reverse text) text))\n", "  (if (= (string-length text) 0)\n\
    \      #t\n      (if (= (string-ref text 0) (string-ref text (- (string-length\
    \ text) 1)))\n          (is_palindrome (substring text 1 (- (string-length text)\
    \ 1)))\n          #f)))\n", "  (match (string-length text)\n         [(0) true]\n\
    \         [(1) true]\n         [(cnt)\n          (equal?\n           (substring\
    \ text 0 1)\n           (substring text (- cnt 1) cnt))\n          (is_palindrome\
    \ (substring text 1 (- cnt 1)))]))\n", "  (string=? text (string-reverse text)))\n",
  "  (if (empty? text)\n      #t\n      (let ([first (first text)]\n            [last\
    \ (last text)])\n        (if (equal? first last)\n            (is_palindrome (substring\
    \ text 1 (sub1 (string-length text))))\n            #f))))\n", "  (cond [(empty?\
    \ text) #t]\n        [(= (first text) (last text))\n         (is_palindrome (rest\
    \ (butlast text)))]\n        [else #f]))\n", "  (define (looper str left right)\n\
    \    (if (or (= left right)\n            (> left right))\n        #t\n       \
    \ (if (equal? (substring str left 1)\n                    (substring str right\
    \ 1))\n            (looper str (+ left 1) (- right 1))\n            #f)))\n  (looper\
    \ text 0 (- (string-length text) 1)))\n", "  (define (palindrome-helper text idx-beg\
    \ idx-end)\n    (if (or (= idx-beg idx-end) (> idx-beg idx-end))\n        #t\n\
    \        (let ([letter-beg (string-ref text idx-beg)]\n              [letter-end\
    \ (string-ref text idx-end)])\n          (if (or (char=? letter-beg letter-end)\n\
    \                  (char=? letter-beg (char-downcase letter-end))\n          \
    \        (char=? letter-beg (char-upcase letter-end)))\n              (palindrome-helper\
    \ text (+ idx-beg 1) (- idx-end 1))\n              #f))))\n  (palindrome-helper\
    \ text 0 (- (string-length text) 1)))\n", "  (define (is_it_palindrome text-list)\n\
    \    (if (null? text-list)\n        #t\n        (let ([first (car text-list)]\n\
    \              [last (car (reverse text-list))])\n          (if (string=? first\
    \ last)\n              (is_it_palindrome (cdr (reverse (cdr text-list))))\n  \
    \            #f))))\n  (is_it_palindrome (string-&gt;list text)))\n</code>\nNote\
    \ that I don't want the use of <code>string-reverse</code> or <code>string-copy</code>.\n\
    \n\nA:\n\nIf you want to use <code>string-&gt;list</code> and <code>list-&gt;string</code>,\
    \ you can use them like this:\n<code>(define (is_palindrome text)\n  (define (is_it_palindrome\
    \ text-list)\n    (if (null? text-list)\n        #t\n        (let ([first (car\
    \ text-list)]\n              [last (car (reverse text-list))])\n          (if\
    \ (string=? first last)\n              (is_it_palindrome (cdr (reverse (cdr text-list))))\n\
    \              #f))))\n  (is_it_palindrome (string-&gt;list text)))\n</code>\n\
    Otherwise, the most idiomatic way to do this without the above restrictions is\
    \ to use <code>string-ref</code> and <code>string-length</code> like this:\n<code>(define\
    \ (is_palindrome text)\n  (let loop ((i 0) (len (string-length text)))\n    (or\
    \ (= i len)\n        (and (string=? (string-ref text i) (string-ref text (- len\
    \ 1 i)))\n             (loop (+ i 1) len)))))\n</code>\n", "  (equal? (reverse\
    \ text) text))\n", "  (cond ((string=? \"\" text)\n         #t)\n        ((string=?\
    \ (string-reverse text) text)\n         #t)\n        (else\n         #f)))\n```\n\
    \n```racket", "  (if (= (string-length text) 0)\n      #t\n      (let ([ch (string-ref\
    \ text 0)]\n            [last-ch (string-ref text (- (string-length text) 1))])\n\
    \        (if (= ch last-ch)\n            (is_palindrome (substring text 1 (- (string-length\
    \ text) 1)))\n            #f))))\n", "  (let loop ([text text] [len (string-length\
    \ text)])\n    (if (equal? len 0)\n        #t\n        (and (equal? (string-ref\
    \ text 0) (string-ref text (- len 1)))\n             (loop (substring text 1 (-\
    \ len 2)) (- len 2))))))\n", "  (define (iter left right)\n    (cond [(= left\
    \ right) #t]\n          [(= left (- right 1)) #t]\n          [(char=? (string-ref\
    \ text left) (string-ref text right))\n           (iter (+ left 1) (- right 1))]\n\
    \          [else #f]))\n  (iter 0 (- (string-length text) 1)))\n", "  (define\
    \ (helper text1 text2)\n    (cond ((string=? text1 \"\") #t)\n          ((string=?\
    \ (substring text1 0 1) (substring text2 0 1)) (helper (substring text1 1) (substring\
    \ text2 -1)))\n          (else #f)))\n  (helper text text))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
