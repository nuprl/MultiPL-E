name: HumanEval_48_is_palindrome
language: rkt
prompt: "#lang racket\n\n;; Checks if given string is a palindrome\n;; >>> (is_palindrome\
  \ \"\")\n;; #t\n;; >>> (is_palindrome \"aba\")\n;; #t\n;; >>> (is_palindrome \"\
  aaaaa\")\n;; #t\n;; >>> (is_palindrome \"zbcd\")\n;; #f\n(define (is_palindrome\
  \ text)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_palindrome))\n\
  \    (check-equal? (candidate \"\") #t)\n    (check-equal? (candidate \"aba\") #t)\n\
  \    (check-equal? (candidate \"aaaaa\") #t)\n    (check-equal? (candidate \"zbcd\"\
  ) #f)\n    (check-equal? (candidate \"xywyx\") #t)\n    (check-equal? (candidate\
  \ \"xywyz\") #f)\n    (check-equal? (candidate \"xywzx\") #f)\n))\n\n(test-humaneval)"
completions: ["  (cond [(string= text \"\") #t]\n        [(not (string= text (string-reverse\
    \ text))) #f]\n        [else #t]))\n", "  (define (is_palindrome_iter text reverse)\n\
    \    (if (string=? text \"\")\n        (string=? text reverse)\n        (is_palindrome_iter\
    \ (substring text 1) (string-append (substring reverse 0 1) (substring text 0\
    \ 1)))))\n  (is_palindrome_iter text \"\"))\n", "  (if (or (= (string-length text)\
    \ 0) (= (string-length text) 1))\n      #t\n      (let* ([len (string-length text)]\n\
    \             [mid (quotient len 2)]\n             [left (substring text 0 mid)]\n\
    \             [right (substring text (- len mid) len)])\n        (string=? left\
    \ (string-reverse right)))))\n", "  (define (match_letters match_fst match_snd)\n\
    \    (and\n      (= (string-length text)\n         (+ 1 (string-length (string-trim-both\
    \ text \" \"))))\n      (match_fst (substring text 0 (- (string-length text) 1))\n\
    \                (substring text 1 (string-length text)))))\n  (define (match_letters_forward\
    \ text)\n    (match_letters string-prefix? string-suffix?))\n  (define (match_letters_backward\
    \ text)\n    (match_letters string-suffix? string-prefix?))\n  (or (match_letters_forward\
    \ text)\n      (match_letters_backward text)))\n```\n\n## Tests\n\n```racket\n\
    #lang racket\n", "  (and\n   (not (null? text))\n   (or\n    (equal? (first text)\
    \ (last text))\n    (is_palindrome (substring text 1 (- (string-length text) 1))))))\n",
  "  (equal? (string-reverse text) text))\n", "  (if (= (string-length text) 0)\n\
    \      #t\n      (if (= (string-ref text 0) (string-ref text (- (string-length\
    \ text) 1)))\n          (is_palindrome (substring text 1 (- (string-length text)\
    \ 1)))\n          #f)))\n", "  (match (string-length text)\n         [(0) true]\n\
    \         [(1) true]\n         [(cnt)\n          (equal?\n           (substring\
    \ text 0 1)\n           (substring text (- cnt 1) cnt))\n          (is_palindrome\
    \ (substring text 1 (- cnt 1)))]))\n", "  (string=? text (string-reverse text)))\n",
  "  (if (empty? text)\n      #t\n      (let ([first (first text)]\n            [last\
    \ (last text)])\n        (if (equal? first last)\n            (is_palindrome (substring\
    \ text 1 (sub1 (string-length text))))\n            #f))))\n", "  (cond [(empty?\
    \ text) #t]\n        [(= (first text) (last text))\n         (is_palindrome (rest\
    \ (butlast text)))]\n        [else #f]))\n", "  (define (looper str left right)\n\
    \    (if (or (= left right)\n            (> left right))\n        #t\n       \
    \ (if (equal? (substring str left 1)\n                    (substring str right\
    \ 1))\n            (looper str (+ left 1) (- right 1))\n            #f)))\n  (looper\
    \ text 0 (- (string-length text) 1)))\n", "  (define (palindrome-helper text idx-beg\
    \ idx-end)\n    (if (or (= idx-beg idx-end) (> idx-beg idx-end))\n        #t\n\
    \        (let ([letter-beg (string-ref text idx-beg)]\n              [letter-end\
    \ (string-ref text idx-end)])\n          (if (or (char=? letter-beg letter-end)\n\
    \                  (char=? letter-beg (char-downcase letter-end))\n          \
    \        (char=? letter-beg (char-upcase letter-end)))\n              (palindrome-helper\
    \ text (+ idx-beg 1) (- idx-end 1))\n              #f))))\n  (palindrome-helper\
    \ text 0 (- (string-length text) 1)))\n", "  (define (is_it_palindrome text-list)\n\
    \    (if (null? text-list)\n        #t\n        (let ([first (car text-list)]\n\
    \              [last (car (reverse text-list))])\n          (if (string=? first\
    \ last)\n              (is_it_palindrome (cdr (reverse (cdr text-list))))\n  \
    \            #f))))\n  (is_it_palindrome (string-&gt;list text)))\n</code>\nNote\
    \ that I don't want the use of <code>string-reverse</code> or <code>string-copy</code>.\n\
    \n\nA:\n\nIf you want to use <code>string-&gt;list</code> and <code>list-&gt;string</code>,\
    \ you can use them like this:\n<code>(define (is_palindrome text)\n  (define (is_it_palindrome\
    \ text-list)\n    (if (null? text-list)\n        #t\n        (let ([first (car\
    \ text-list)]\n              [last (car (reverse text-list))])\n          (if\
    \ (string=? first last)\n              (is_it_palindrome (cdr (reverse (cdr text-list))))\n\
    \              #f))))\n  (is_it_palindrome (string-&gt;list text)))\n</code>\n\
    Otherwise, the most idiomatic way to do this without the above restrictions is\
    \ to use <code>string-ref</code> and <code>string-length</code> like this:\n<code>(define\
    \ (is_palindrome text)\n  (let loop ((i 0) (len (string-length text)))\n    (or\
    \ (= i len)\n        (and (string=? (string-ref text i) (string-ref text (- len\
    \ 1 i)))\n             (loop (+ i 1) len)))))\n</code>\n", "  (equal? (reverse\
    \ text) text))\n", "  (cond ((string=? \"\" text)\n         #t)\n        ((string=?\
    \ (string-reverse text) text)\n         #t)\n        (else\n         #f)))\n```\n\
    \n```racket", "  (if (= (string-length text) 0)\n      #t\n      (let ([ch (string-ref\
    \ text 0)]\n            [last-ch (string-ref text (- (string-length text) 1))])\n\
    \        (if (= ch last-ch)\n            (is_palindrome (substring text 1 (- (string-length\
    \ text) 1)))\n            #f))))\n", "  (let loop ([text text] [len (string-length\
    \ text)])\n    (if (equal? len 0)\n        #t\n        (and (equal? (string-ref\
    \ text 0) (string-ref text (- len 1)))\n             (loop (substring text 1 (-\
    \ len 2)) (- len 2))))))\n", "  (define (iter left right)\n    (cond [(= left\
    \ right) #t]\n          [(= left (- right 1)) #t]\n          [(char=? (string-ref\
    \ text left) (string-ref text right))\n           (iter (+ left 1) (- right 1))]\n\
    \          [else #f]))\n  (iter 0 (- (string-length text) 1)))\n", "  (define\
    \ (helper text1 text2)\n    (cond ((string=? text1 \"\") #t)\n          ((string=?\
    \ (substring text1 0 1) (substring text2 0 1)) (helper (substring text1 1) (substring\
    \ text2 -1)))\n          (else #f)))\n  (helper text text))\n", "  (string= text\
    \ (string-reverse text)))\n", "  (equal? (list->string (reverse (string->list\
    \ text))) text))\n", "  (define (helper left right)\n    (if (&lt; left right)\n\
    \        (and (char=? (string-ref text left) (string-ref text right))\n      \
    \       (helper (+ left 1) (- right 1)))\n        #t))\n  (helper 0 (- (string-length\
    \ text) 1)))\n", "  (or (= 0 (string-length text))\n      (and (= (string-ref\
    \ text 0) (string-ref text (- (string-length text) 1)))\n           (is_palindrome\
    \ (substring text 1 (- (string-length text) 1))))))\n```\n\n- [Recursion example](https://github.com/pambonan/racket-examples/blob/master/recursion.rkt)\n\
    \n```racket\n#lang racket\n", "  (string= text (string-reverse text)))\n", " \
    \ (cond\n    [(empty? text) true]\n    [(= (first text) (last text)) (is_palindrome\
    \ (substring text 1 (- (length text) 1)))]\n    [else false]))\n", "  (define\
    \ (iter text left right)\n    (cond\n      ((equal? left right) #t)\n      ((equal?\
    \ (string-ref text left) (string-ref text right))\n        (iter text (+ left\
    \ 1) (- right 1)))\n      (else #f)))\n  (iter text 0 (- (string-length text)\
    \ 1)))\n", "  (if (empty? text)\n      #t\n      (if (empty? (rest text))\n  \
    \        #t\n          (if (equal? (first text) (first (rest (reverse text))))\n\
    \              (is_palindrome (rest (rest text)))\n              #f))))\n", " \
    \ (cond ((string=? text \"\") #t)\n        ((string=? (substring text 0 1) (substring\
    \ text (- (string-length text) 1) (string-length text))) (is_palindrome (substring\
    \ text 1 (- (string-length text) 1))))\n        (else #f)))\n", "  (if (null?\
    \ text)\n      #t\n      (if (equal? (char-upcase (string-ref text 0)) (char-upcase\
    \ (string-ref text (- (string-length text) 1))))\n          (is_palindrome (substring\
    \ text 1 (- (string-length text) 1)))\n          #f)))\n", "  (define (is_palindrome_iter\
    \ n)\n    (cond\n      ((= n 1) #t)\n      ((even? n)\n       (and (char=? (string-ref\
    \ text (/ n 2)) (string-ref text (+ (/ n 2) 1)))\n            (is_palindrome_iter\
    \ (- n 2))))\n      (else\n       (and (char=? (string-ref text (/ n 2)) (string-ref\
    \ text (- (/ n 2) 1)))\n            (is_palindrome_iter (- n 2))))))\n  (is_palindrome_iter\
    \ (string-length text)))\n", "  (let ([len (string-length text)])\n    (if (string=\
    \ text (substring text 0 1))\n        (if (odd? len)\n            (is_palindrome\
    \ (substring text 1 (- len 1)))\n            (is_palindrome (substring text 1\
    \ len)))\n        #f)))\n", "  (define (helper text lower upper)\n    (cond ((>\
    \ lower upper) #t)\n          ((char=? (string-ref text lower) (string-ref text\
    \ upper))\n           (helper text (+ lower 1) (- upper 1)))\n          (else\
    \ #f)))\n  (helper text 0 (- (string-length text) 1)))\n", "  (define (helper\
    \ first-index second-index)\n    (cond\n      [(> first-index second-index) #t]\n\
    \      [(char=? (string-ref text first-index) (string-ref text second-index))\n\
    \       (helper (+ first-index 1) (- second-index 1))]\n      [else #f]))\n  (helper\
    \ 0 (- (string-length text) 1)))\n", "  (let loop ([current_text text]\n     \
    \        [sub_text (substring text 1 (sub1 (string-length text)))])\n    (if (=\
    \ (string-length current_text) 0)\n        #t\n        (if (= (string-length current_text)\
    \ 1)\n            #t\n            (if (string= (substring current_text 0 1)\n\
    \                         (substring current_text (sub1 (string-length current_text))\
    \ (string-length current_text)))\n                (loop sub_text (substring sub_text\
    \ 1 (sub1 (string-length sub_text))))\n                #f)))))\n", "  (define\
    \ (is_palindrome-iter text left right)\n    (if (or (= left right) (&lt; left\
    \ right))\n        #t\n        (if (equal? (string-ref text left) (string-ref\
    \ text right))\n            (is_palindrome-iter text (+ left 1) (- right 1))\n\
    \            #f)))\n  (is_palindrome-iter text 0 (- (string-length text) 1)))\n",
  "  (string=? text (reverse-string text)))\n", "  (cond\n    [(empty? text) #t]\n\
    \    [(empty? (rest text)) #t]\n    [(equal? (first text) (last text))\n     (is_palindrome\
    \ (substring text 1 (- (string-length text) 1)))]\n    [else #f]))\n```\n\n###\
    \ `is_palindrome` (`Racket` version with `for`)\n\n<!-- ```racket -->\n<!-- #lang\
    \ racket -->\n\n<!-- ;; Checks if given string is a palindrome -->\n<!-- ;; >>>\
    \ (is_palindrome \"\") -->\n<!-- ;; #t -->\n<!-- ;; >>> (is_palindrome \"aba\"\
    ) -->\n<!-- ;; #t -->\n<!-- ;; >>> (is_palindrome \"aaaaa\") -->\n<!-- ;; #t -->\n\
    <!-- ;; >>> (is_palindrome \"zbcd\") -->\n<!-- ;; #f -->\n<!-- (define (is_palindrome\
    \ text) -->\n<!--   (cond -->\n<!--     [(empty? text) #t] -->\n<!--     [(empty?\
    \ (rest text)) #t] -->\n<!--     [(equal? (first text) (last text)) -->\n<!--\
    \      (is_palindrome (substring text 1 (- (string-length text) 1)))] -->\n<!--\
    \     [else #f])) -->\n<!-- ``` -->\n\n### `pivot` (`Python` version)\n\n```python\n\
    def pivot(array, value):\n    \"\"\"\n    Returns start and end of values in array\
    \ that are >= value.\n    >>> pivot([1, 2, 3, 4, 5], 2)\n    (1, 4)\n    >>> pivot([5,\
    \ 2, 3, 2, 1], 2)\n    (1, 2)\n    >>> pivot([5, 2, 1, 2, 1], 2)\n    (1, 1)\n\
    \    >>> pivot([5, 2, 1, 2, 3], 2)\n    (1, 4)\n    >>> pivot([5, 2, 1, 2, 1],\
    \ 0)\n    (0, 0)\n    >>> pivot([5, 2, 1, 2, 1], 6)\n    (5, 5)\n   ", "  (define\
    \ (aux end begin)\n    (cond\n      ((< begin end)\n       (if (= (char-downcase\
    \ (string-ref text begin))\n              (char-downcase (string-ref text end)))\n\
    \           (aux (- end 1) (+ begin 1))\n           #f))\n      (else #t)))\n\
    \  (aux (- (string-length text) 1) 0))\n", "  (define (iter s)\n    (cond\n  \
    \    [(empty? s) #t]\n      [(equal? (first s) (last s)) (iter (rest (butlast\
    \ s)))]\n      [else #f]))\n  (iter (string->list text)))\n", "  (define (iter\
    \ text)\n    (cond\n      [(empty? text) #t]\n      [(equal? (first text) (last\
    \ text)) (iter (rest (butlast text)))]\n      [else #f]))\n  (iter text))\n",
  "  (cond\n    [(empty? text)\n     #t]\n    [(empty? (rest text))\n     #t]\n  \
    \  [(char=? (first text) (last text))\n     (is_palindrome (rest (butlast text)))]\n\
    \    [else\n     #f]))\n", "  (define (helper text beg end)\n    (if (< beg end)\n\
    \        (if (char=? (string-ref text beg) (string-ref text end))\n          \
    \  (helper text (+ beg 1) (- end 1))\n            #f)\n        #t))\n  (helper\
    \ text 0 (- (string-length text) 1)))\n", "  (string=? text (reverse text)))\n",
  "  (and (not (empty? text))\n       (or (equal? text (reverse text))\n         \
    \  (is_palindrome (substring text 1 (- (string-length text) 1))))))\n", "  (or\
    \ (= (string-length text) 0) \n      (and (char=? (string-ref text 0) (string-ref\
    \ text (- (string-length text) 1)))\n           (is_palindrome (substring text\
    \ 1 (- (string-length text) 1))))))\n", "  (string=? text (string-reverse text)))\n",
  "  (cond [(empty? text) true]\n        [(not (equal? (string-ref text 0) (string-ref\
    \ text (- (string-length text) 1)))) false]\n        [else (is_palindrome (substring\
    \ text 1 (- (string-length text) 1)))]))\n", "  (cond [(equal? text \"\") #t]\n\
    \        [(equal? (string-take text 1) (string-take text (- (string-length text)\
    \ 1)))\n         (is_palindrome (string-drop text 1) (string-drop text (- (string-length\
    \ text) 1)))]\n        [else #f]))\n", "  (define (is_palindrome_aux text i len)\n\
    \    (if (< i len)\n        (and (equal? (substring text i (+ i 1))\n        \
    \             (substring text (- len i 1) (- len i)))\n             (is_palindrome_aux\
    \ text (+ i 1) len))\n        #t))\n  (is_palindrome_aux text 0 (string-length\
    \ text)))\n", "  (define (aux str acc)\n    (if (null? str)\n        acc\n   \
    \     (aux (rest str) (append (list (first str)) acc))))\n  (equal? text (aux\
    \ text '())))\n", "  (let ([n (string-length text)])\n    (and (not (zero? n))\n\
    \         (or (and (= n 1) #t)\n             (and (= (substring text 0 1) (substring\
    \ text (- n 1) n))\n                  (is_palindrome (substring text 1 (- n 1))))))))\n",
  "  (cond\n    [(empty? text) #t]\n    [(= (first text) (last text)) (is_palindrome\
    \ (rest (butlast text)))]\n    [else #f]))\n", "  (equal? text (reverse text)))\n",
  "  (define length (string-length text))\n  (define (rec text n)\n    (cond ((= n\
    \ (/ length 2)) #t)\n          ((char=? (string-ref text n) (string-ref text (-\
    \ length n 1)))\n           (rec text (+ n 1)))\n          (else #f)))\n  (rec\
    \ text 0))\n", "  (define (helper i j)\n    (cond\n      [(> j i) #t]\n      [(string-ci=?\
    \ (string-ref text i) (string-ref text j)) (helper (+ i 1) (- j 1))]\n      [else\
    \ #f]))\n  (helper 0 (- (string-length text) 1)))\n", "  (cond\n    [(empty? text)\n\
    \     #t]\n    [(empty? (cdr text))\n     #t]\n    [(char=? (car text) (last text))\n\
    \     (is_palindrome (reverse (cdr (reverse (cdr text)))))]\n    [else\n     #f]))\n",
  "  (if (<= (string-length text) 1)\n      #t\n      (and\n       (string=? (string-normalize-spaces\
    \ (string-trim (string-append text))) (string-normalize-spaces (string-trim (string-reverse\
    \ text))))\n       #t)))\n", "  (define (is_palindrome-helper text left right)\n\
    \    (if (or (> left right) (= left right))\n        #t\n        (if (string-ci=?\
    \ (string-ref text left) (string-ref text right))\n            (is_palindrome-helper\
    \ text (+ left 1) (- right 1))\n            #f)))\n  (is_palindrome-helper text\
    \ 0 (- (string-length text) 1)))\n", "  (define (check index)\n    (cond ((&lt;=\
    \ index (- (string-length text) 2))\n           (and (equal? (string-ref text\
    \ index) (string-ref text (- (string-length text) 1 index)))\n               \
    \ (check (+ index 1))))\n          (else #t)))\n  (check 0))\n", "  (let loop\
    \ ([i 0] [j (- (string-length text) 1)])\n    (cond [(> i j) #t]\n          [(char=?\
    \ (string-ref text i) (string-ref text j))\n           (loop (+ i 1) (- j 1))]\n\
    \          [else #f])))\n", "  (let ([len (string-length text)])\n    (and\n \
    \    (not (eq? len 0))\n     (let ([left 0]\n           [right (- len 1)])\n \
    \      (cond\n        [(eq? left right) #t]\n        [(eq? left (- right 1))\n\
    \         (string=? (string-ref text left) (string-ref text right))]\n       \
    \ [else\n         (and\n          (string=? (string-ref text left) (string-ref\
    \ text right))\n          (is_palindrome (substring text (+ left 1) (- right 1))))])))))\n\
    ```\n\n## Find all palindromes\n\nLet's find all the palindromes in a given string:\n\
    \n```racket\n#lang racket\n", "  ;; Base case: If empty string\n  (if (string=?\
    \ text \"\")\n      #t\n      ;; Recurse:\n      ;; Two cases:\n      ;;   1.\
    \ If first and last elements are the same\n      ;;   2. If they are not the same\n\
    \      (cond\n        ;; Case 1:\n        [(string=? (substring text 0 1) (substring\
    \ text (- (string-length text) 1) (string-length text)))\n         (is_palindrome\
    \ (substring text 1 (- (string-length text) 1)))]\n        ;; Case 2:\n      \
    \  [else #f])))\n", "  (local [(define (iter s left right)\n            (cond\
    \ [(or (empty? s) (= left right)) #t]\n                  [(or (char=? (string-ref\
    \ s left) (string-ref s right))\n                       (char=? (string-ref s\
    \ left) (char-upcase (string-ref s right)))\n                       (char=? (char-upcase\
    \ (string-ref s left)) (string-ref s right)))\n                   (iter s (+ left\
    \ 1) (- right 1))]\n                  [else #f]))]\n    (iter text 0 (- (string-length\
    \ text) 1))))\n", "  (cond\n    [(empty? text)\n     #t]\n    [(and\n      (one-item?\
    \ text)\n      (empty? (rest text)))\n     #t]\n    [(= (first text) (last text))\n\
    \     (is_palindrome (substring text 1 (- (length text) 1)))]\n    [else\n   \
    \  #f]))\n", "  (define (equal-chars a b)\n    (equal? (char-downcase a) (char-downcase\
    \ b)))\n  (define (is-palindrome-iter text-left text-right)\n    (if (and (not\
    \ (empty? text-left)) (not (empty? text-right)))\n        (if (equal-chars (first\
    \ text-left) (first text-right))\n            (is-palindrome-iter (rest text-left)\
    \ (rest text-right))\n            #f)\n        #t))\n  (is-palindrome-iter (string-&gt;list\
    \ text) (reverse (string-&gt;list text))))\n</code>\n", "  (define (helper x y)\n\
    \    (and (not (= x y))\n         (and (char=? (string-ref text x) (string-ref\
    \ text y))\n              (helper (+ x 1) (- y 1)))))\n  (helper 0 (- (string-length\
    \ text) 1)))\n```\n\n[Back to top](#top)\n\n### Reverse words\n\n`\"Alice likes\
    \ Bob\"` becomes `\"Bob likes Alice\"`\n\n```racket\n#lang racket\n", "  (define\
    \ (reverse string index)\n    (cond ((= index 0) (string-append \"\" (string-ref\
    \ string 0)))\n          (else (string-append (reverse string (- index 1))\n \
    \                              (string-ref string index)))))\n  (define (compare\
    \ string1 string2)\n    (cond ((string=? string1 string2) #t)\n          (else\
    \ #f)))\n  (compare text (reverse text (- (string-length text) 1))))\n", "  (let\
    \ loop ([text text] [i 0] [j (- (string-length text) 1)])\n    (cond\n      [(string=?\
    \ \"\" text) #t]\n      [(string=? (substring text i (add1 i)) (substring text\
    \ j (sub1 j)))\n       (loop (substring text 1 (sub1 (string-length text))) 0\
    \ (- j 2))]\n      [else #f])))\n```\n\n[\u2B05\uFE0F Back to Index](#index)\n\
    \n## Reverse and Add\n\n```racket\n#lang racket\n", "  (if (empty? text)\n   \
    \   #t\n      (if (equal? (first text) (last text))\n          (is_palindrome\
    \ (but-last (rest text)))\n          #f)))\n", "  (cond\n    [(null? text) #t]\n\
    \    [(or (= (string-length text) 1)\n         (string=? (string-ref text 0) (string-ref\
    \ text (- (string-length text) 1))))\n     (is_palindrome (substring text 1 (-\
    \ (string-length text) 1)))]\n    [else #f]))\n", "  (define (is_palindrome-inner\
    \ text i j)\n    (cond\n      [(> i j)\n       #t]\n      [(char=? (string-ref\
    \ text i) (string-ref text j))\n       (is_palindrome-inner text (+ i 1) (- j\
    \ 1))]\n      [else\n       #f]))\n  (is_palindrome-inner text 0 (- (string-length\
    \ text) 1)))\n", "  (define (is_palindrome_helper text result)\n    (if (string-empty?\
    \ text)\n        result\n        (is_palindrome_helper (substring text 1 (- (string-length\
    \ text) 1)) (and result (string=? (substring text 0 1) (substring text (- (string-length\
    \ text) 1) (string-length text)))))))\n  (is_palindrome_helper text #t))\n```\n\
    \n#### \u041E\u043F\u0438\u0441\u0430\u043D\u0438\u0435 \u0432\u044B\u0445\u043E\
    \u0434\u0430 \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\u0430 \u043D\u0430\
    \ \u043F\u0440\u0438\u043C\u0435\u0440\u0435\n```\n#lang racket\n", "  ;; <PLACEHOLDER>\n\
    \  )\n", "  (string=? (reverse-string text) text))\n", "  (cond [(empty? text)\
    \ #t]\n        [(equal? (first text) (last text))\n         (is_palindrome (rest\
    \ (butlast text)))]\n        [else #f]))\n", "  (define (f [s l] #:with [m (quotient\
    \ l 2)])\n    (if (zero? l)\n        #t\n        (if (char=? (string-ref s (sub1\
    \ l)) (string-ref s 0))\n            (f (substring s 1 (sub1 l)) (sub1 l))\n \
    \           #f)))\n  (f text (string-length text)))\n", "  (if (= (string-length\
    \ text) 0)\n      #t\n      (is_palindrome_help (string-append text) 1)))\n",
  "  (define (is_palindrome-iter text n)\n    (cond ((or (= n 1) (= n 0)) #t)\n  \
    \        ((and (string-length text)\n                (equal? (string-ref text\
    \ 0) (string-ref text (- (string-length text) 1))))\n            (is_palindrome-iter\
    \ (substring text 1 (- (string-length text) 1))\n                            \
    \    (- n 2)))\n          (else #f)))\n  (is_palindrome-iter text (string-length\
    \ text)))\n", "  (define (is_palindrome-rec text start end)\n    (if (= start\
    \ end)\n        #t\n        (and (equal? (string-ref text start) (string-ref text\
    \ end))\n             (is_palindrome-rec text (+ start 1) (- end 1)))))\n  (is_palindrome-rec\
    \ text 0 (- (string-length text) 1)))\n", "  (cond [(empty? text)\n         #t]\n\
    \        [(null? (rest text))\n         #t]\n        [(char=? (first text) (last\
    \ text))\n         (is_palindrome (substring text 1 (- (string-length text) 1)))]\n\
    \        [else\n         #f]))\n", "  (let ([string-in text])\n    (if (empty?\
    \ string-in) #t\n      (define (is_palindrome_aux string-in string-rev)\n    \
    \    (if (empty? string-in) #t\n          (if (equal? (first string-in) (first\
    \ string-rev))\n              (is_palindrome_aux (rest string-in) (rest string-rev))\n\
    \              #f\n              )\n          )\n        )\n      (is_palindrome_aux\
    \ string-in (string-reverse string-in))\n      )\n    )\n  )\n", "  (define (iter\
    \ left right)\n    (cond ((<= left right)\n           (and (char=? (string-ref\
    \ text left) (string-ref text right))\n                (iter (+ left 1) (- right\
    \ 1))))\n          (else #t)))\n  (iter 0 (- (string-length text) 1)))\n\n", " \
    \ (define (loop text left right)\n    (cond [(empty? text) (null? text)]\n   \
    \       [(= left right) true]\n          [(string=? (substring text left 1) (substring\
    \ text right 1))\n           (loop text (+ left 1) (- right 1))]\n          [else\
    \ false]))\n  (loop text 0 (- (string-length text) 1)))\n", "  (cond\n    [(empty?\
    \ text) true]\n    [(= (string-length text) 1) true]\n    [(= (string-ref text\
    \ 0) (string-ref text (- (string-length text) 1)))\n      (is_palindrome (substring\
    \ text 1 (- (string-length text) 1)))]\n    [else false]))", "  (if (empty? text)\n\
    \      #t\n      (if (or (eq? (first text) (last text))\n              (eq? (first\
    \ text) (last text) 'ignore-case))\n          (is_palindrome (substring text 1\
    \ (- (string-length text) 1)))\n          #f)))\n", "  (cond\n    [(null? text)\
    \ #t]\n    [(or (char=? (car text) (last text))\n         (char=? (car text) (last\
    \ text)))\n     (is_palindrome (string-drop text 1 (sub1 (string-length text))))]\n\
    \    [else #f]))\n", "  (if (string=? text \"\")\n      #t\n      (let ([last-index\
    \ (- (string-length text) 1)])\n        (if (string=? (string-ref text 0) (string-ref\
    \ text last-index))\n            (is_palindrome (substring text 1 (- last-index\
    \ 1)))\n            #f))))\n", "  (define (rec text-len)\n    (cond ((= 0 text-len)\
    \ #t)\n          ((= 1 text-len) #t)\n          ((string=? (string-ref text (-\
    \ text-len 1)) (string-ref text 0))\n           (rec (- text-len 2)))\n      \
    \    (else #f)))\n  (rec (string-length text)))\n", "  (define (recurse text)\n\
    \    (if (string-empty? text)\n        #t\n        (and (string=? (substring text\
    \ 0 1) (substring text (- (string-length text) 1) (string-length text)))\n   \
    \          (recurse (substring text 1 (- (string-length text) 1))))))\n  (recurse\
    \ text))\n", "  (if (= (string-length text) 0)\n      #t\n      (or (string= (string-append\
    \ (string-take text 1)\n                                 (string-take text (-\
    \ (string-length text) 1)))\n                  (string-append (string-take text\
    \ (- (string-length text) 1))\n                                 (string-take text\
    \ 1)))\n          (is_palindrome (string-drop text 1)))))\n```\n\n## 3.\n```racket\n\
    #lang racket\n", "  (cond\n    ((eq? (string-length text) 0) #t)\n    ((eq? (string-length\
    \ text) 1) #t)\n    ((eq? (string-ref text 0) (string-ref text (- (string-length\
    \ text) 1)))\n     (is_palindrome (substring text 1 (- (string-length text) 1))))\n\
    \    (else #f)))\n", "  (define (loop text)\n    (cond\n      [(empty? text) #t]\n\
    \      [(string=? (first text) (last text)) (loop (string-drop-right text 1))]\n\
    \      [else #f]))\n  (loop text))\n", "  (define (helper lst)\n    (cond\n  \
    \    [(null? lst) #t]\n      [(null? (cdr lst)) #t]\n      [(equal? (car lst)\
    \ (car (cdr (reverse lst)))) (helper (cdr lst))]\n      [else #f]))\n  (helper\
    \ (string->list text)))\n", "  (and (= (length text)\n          (length (string-append\
    \ (string-reverse text))))\n       (= (substring text 0 (quotient (length text)\
    \ 2))\n          (substring text (quotient (length text) 2) (length text)))))\n",
  "  (cond\n    [(= (string-length text) 0) #t]\n    [(char=? (string-ref text 0)\
    \ (string-ref text (- (string-length text) 1)))\n     (is_palindrome (substring\
    \ text 1 (- (string-length text) 1)))]\n    [else #f]))\n", "  (if (string=? text\
    \ \"\")\n      #t\n      (if (string=? (string-head text) (string-tail text))\n\
    \          (is_palindrome (string-drop text 2))\n          #f)))\n", "  (string=?\
    \ text (reverse text)))\n", "  (define (palindrome-loop text left right)\n   \
    \ (cond ((= left right) #t)\n          ((not (= (string-ref text left) (string-ref\
    \ text right))) #f)\n          (else (palindrome-loop text (+ left 1) (- right\
    \ 1)))))\n  (palindrome-loop text 0 (- (string-length text) 1)))\n", "  (define\
    \ (is_palindrome_iter text left right)\n    (if (= left right)\n        #t\n \
    \       (and (= (string-ref text left) (string-ref text right))\n            \
    \ (is_palindrome_iter text (+ left 1) (- right 1)))))\n  (is_palindrome_iter text\
    \ 0 (- (string-length text) 1)))\n", "  (if (string=? text \"\")\n      #t\n \
    \     (or\n       (string=? (string-upcase text) (string-upcase (string-reverse\
    \ text)))\n       (is_palindrome (substring text 1 (- (string-length text) 1))))))\n",
  "  (if (null? text)\n      #t\n      (if (or (= (string-length text) 1)\n      \
    \        (equal? (substring text 0 1) (substring text -1))\n              (is_palindrome\
    \ (substring text 1 (- (string-length text) 1))))\n          #t\n          #f)))\n",
  "  (define (rec text len)\n    (cond [(> len 1) (and (= (string-ref text 0) (string-ref\
    \ text (- len 1))) (rec (substring text 1 (- len 2)) (- len 2)))]\n          [(=\
    \ len 1) #t]\n          [else #f]))\n  (rec text (string-length text)))", "  (define\
    \ (palindrome? text)\n    (if (or (empty? text)\n            (empty? (rest text)))\n\
    \        #t\n        (and (char=? (first text) (last text))\n             (palindrome?\
    \ (but-last (rest text))))))\n  (palindrome? (string-&gt;list text)))\n", "  (define\
    \ (is_palindrome-rec text left right)\n    (cond ((< left right) #t)\n       \
    \   ((= left right) (string=? (string-ref text left)\n                       \
    \             (string-ref text right)))\n          ((string=? (string-ref text\
    \ left)\n                     (string-ref text right))\n           (is_palindrome-rec\
    \ text (+ left 1) (- right 1)))\n          (else #f)))\n  (is_palindrome-rec text\
    \ 0 (- (string-length text) 1)))\n```\n\nCreate a module and try it out:\n\n```racket\n\
    #lang racket\n", "  (define (equal? first second)\n    (equal? (string-ref text\
    \ first) (string-ref text second)))\n  (define (loop start end)\n    (cond ((equal?\
    \ start end) #t)\n          ((equal? start (sub1 end)) #t)\n          ((equal?\
    \ start (- end 1)) #t)\n          ((equal? (string-ref text start) (string-ref\
    \ text end))\n           (loop (add1 start) (sub1 end)))\n          (else #f)))\n\
    \  (loop 0 (sub1 (string-length text))))\n", "  (define (solve text rev)\n   \
    \ (cond [(string=? text rev) #t]\n          [(or (string=? text \"\") (string=?\
    \ rev \"\")) #f]\n          [else (solve (substring text 1) (substring rev 0 (-\
    \ (string-length rev) 1)))]))\n  (solve text (reverse text)))\n", "  (not (let\
    \ loop ([i 1] [j (- (string-length text) 1)])\n          (and (not (= i j))\n\
    \               (or (not (= (string-ref text i) (string-ref text j)))\n      \
    \             (loop (+ i 1) (- j 1)))))))\n", "  (define (palindrome? first last)\n\
    \    (and (not (null? text))\n         (or (equal? first last)\n             (equal?\
    \ (string-ref text first) (string-ref text last))\n             (palindrome? (add1\
    \ first) (sub1 last)))))\n  (palindrome? 0 (sub1 (string-length text))))\n```\n\
    \n## Performance characteristics\n\nConsider this implementation:\n\n```Racket",
  "  (define (is_palindrome-inner text i length)\n    (cond ((> i (- length 1)) #t)\n\
    \          ((= (string-ref text i) (string-ref text (- length 1 i))) (is_palindrome-inner\
    \ text (+ i 1) length))\n          (else #f)))\n  (is_palindrome-inner text 0\
    \ (string-length text)))\n", "  (if (empty? text)\n      #t\n      (define (is_palindrome_p\
    \ start end)\n        (if (equal? start end)\n            #t\n            (if\
    \ (equal? (string-ref text start) (string-ref text end))\n                (is_palindrome_p\
    \ (+ start 1) (- end 1))\n                #f)))\n      (is_palindrome_p 0 (- (string-length\
    \ text) 1))))\n", "  (cond\n    [(empty? text) #t]\n    [(empty? (rest text))\
    \ #t]\n    [(equal? (first text) (last text))\n     (is_palindrome (substring\
    \ (rest text) 0 (- (string-length text) 2)))]\n    [else #f]))\n", "  (define\
    \ (palindrome-helper i j)\n    (cond ((> i j) #t)\n          ((char=? (string-ref\
    \ text i) (string-ref text j)) (palindrome-helper (+ i 1) (- j 1)))\n        \
    \  (else #f)))\n  (palindrome-helper 0 (- (string-length text) 1)))\n", "  (if\
    \ (or (empty? text) (equal? (length text) 1))\n      #t\n      (if (equal? (first\
    \ text) (last text))\n          (is_palindrome (rest (butlast text)))\n      \
    \    #f)))\n", "  (define (is_palindrome_helper text reversed-prefix)\n    (cond\
    \ [(null? text) reversed-prefix]\n          [(is_palindrome_helper (rest text)\
    \ (cons (first text) reversed-prefix))]\n          [else #f]))\n  (is_palindrome_helper\
    \ text '()))\n", "  (cond\n    [(empty? text) true]\n    [(not (empty? (rest text)))\n\
    \     (and (equal? (first text) (last text))\n          (is_palindrome (substring\
    \ (rest text) 0 (- (length text) 2))))]\n    [else false]))\n", "  (not (not (string=?\
    \ (reverse text) text))))\n", "  (define (helper [text (equal?)] a_txt)\n    (if\
    \ (or (null? text) (equal? a_txt \"\"))\n        #t\n        (if (equal? (first\
    \ text) (first a_txt))\n            (helper (rest text) (rest a_txt))\n      \
    \      #f)))\n  (helper (string->list text) (reverse (string->list text))))\n",
  "  (define (palindrome-helper text reversed)\n    (cond ((null? text) #t)\n    \
    \      ((char=? (car text) (car reversed))\n           (palindrome-helper (cdr\
    \ text) (cdr reversed)))\n          (else #f)))\n  (palindrome-helper text (reverse\
    \ text)))\n", "  (if (or (empty? text) (= (string-length text) 1))\n      #t\n\
    \      (if (char=? (string-ref text 0) (string-ref text (- (string-length text)\
    \ 1)))\n          (is_palindrome (substring text 1 (- (string-length text) 1)))\n\
    \          #f)))\n", "  (if (string=? text \"\")\n      #t\n      (let ([last\
    \ (substring text (- (string-length text) 1) (string-length text))]\n        \
    \    [mid (substring text 1 (- (string-length text) 1))])\n        (and (string=?\
    \ (string-upcase last) (string-upcase (substring text 0 1)))\n             (is_palindrome\
    \ mid)))))\n", "  (define (iter i j)\n    (if (or (= i j)\n            (= i (-\
    \ j 1)))\n        #t\n        (if (equal? (string-ref text i)\n              \
    \      (string-ref text j))\n            (iter (+ i 1) (- j 1))\n            #f)))\n\
    \  (iter 0 (- (string-length text) 1)))\n", "  (define (is_palindrome_iter text\
    \ start end)\n    (cond ((< start (- end 1))\n           (if (string-eq? (string-ref\
    \ text start) (string-ref text (- end 1)))\n               (is_palindrome_iter\
    \ text (+ start 1) (- end 1))\n               #f))\n          ((= start (- end\
    \ 1)) #t)\n          (#t #t)))\n  (is_palindrome_iter text 0 (string-length text)))\n",
  "  (cond\n    [(empty? text) #t]\n    [(string=? (first text) (last text)) (is_palindrome\
    \ (rest (butlast text)))]\n    [else #f]))\n", "  (cond\n    [(empty? text) #t]\n\
    \    [(string=? (first text) (last text)) (is_palindrome (string-tail (string-drop-right\
    \ text 1)))]\n    [else #f]))\n", "  (and (not (empty? text))\n       (equal?\
    \ (first text) (last text))\n       (is_palindrome (rest (butlast text)))))\n",
  "  (define (reverse-text s)\n    (if (string-empty? s)\n        \"\"\n        (string-append\
    \ (reverse-text (substring s 1 (- (string-length s) 1)))\n                   \
    \    (string-take s 1))))\n  (if (string-empty? text)\n      #t\n      (if (string=?\
    \ text (reverse-text text))\n          #t\n          #f)))", "  (equal? (string-normalize-spaces\
    \ text)\n          (string-normalize-spaces (string-reverse text))))\n```\n\n\
    ### Reverse a string\n\n```racket\n#lang racket\n", "  (let ([length (string-length\
    \ text)])\n    (and (<= length 1)\n         (equal? (string-append (substring\
    \ text 0 1)\n                                (substring text (- length 1) length))\n\
    \                 text))))\n", "  (string=? (string-&gt;list text) (string-&gt;list\
    \ (string-reverse text))))\n", "  (define (check-reverse i j)\n    (and (< i j)\n\
    \         (and (char=? (string-ref text i) (string-ref text j))\n            \
    \  (check-reverse (+ i 1) (- j 1)))))\n  (check-reverse 0 (- (string-length text)\
    \ 1)))\n", "  (cond [(string=? \"\" text) #t]\n        [(string=? (substring text\
    \ 0 1) (substring text (- (string-length text) 1) -1))\n         (is_palindrome\
    \ (substring text 1 (- (string-length text) 1)))]\n        [else #f]))\n", " \
    \ (if (empty? text)\n      #t\n      (let* ([l (string-length text)]\n       \
    \      [first (string-ref text 0)]\n             [last (string-ref text (- l 1))])\n\
    \        (if (equal? first last)\n            (is_palindrome (substring text 1\
    \ (- l 1)))\n            #f))))\n", "  (define (is_palindrome-helper forward-index\
    \ backward-index)\n    (if (= forward-index backward-index)\n        #t\n    \
    \    (if (char=? (string-ref text forward-index) (string-ref text backward-index))\n\
    \            (is_palindrome-helper (+ forward-index 1) (- backward-index 1))\n\
    \            #f)))\n  (is_palindrome-helper 0 (- (string-length text) 1)))\n",
  "  (if (empty? text)\n      #t\n      (define mid (/ (string-length text) 2))\n\
    \      (let loop ((i 0) (j (- (string-length text) 1)))\n        (if (= i mid)\n\
    \            #t\n            (if (equal? (string-ref text i) (string-ref text\
    \ j))\n                (loop (+ i 1) (- j 1))\n                #f)))))\n", " \
    \ (cond ((null? text) #t)\n        ((and (symbol? (first text)) (symbol? (last\
    \ text)))\n         (and (string=? (symbol->string (first text)) (symbol->string\
    \ (last text)))\n              (is_palindrome (substring text 1 (- (string-length\
    \ text) 1)))))\n        (else #f)))\n", "  (define (is_palindrome_inner l r)\n\
    \    (cond [(or (= l r) (< l r)) #t]\n          [(char=? (string-ref text l) (string-ref\
    \ text r))\n           (is_palindrome_inner (+ l 1) (- r 1))]\n          [else\
    \ #f]))\n  (is_palindrome_inner 0 (- (string-length text) 1)))", "  (define (is_palindrome_rec\
    \ text reversed_text)\n    (cond ((empty? text)\n           (equal? text reversed_text))\n\
    \          ((empty? (rest text))\n           (equal? text (string-append reversed_text\
    \ (string (first text)))))\n          (else\n           (is_palindrome_rec (rest\
    \ text) (string-append reversed_text (string (first text)))))))\n  (is_palindrome_rec\
    \ text \"\"))\n\n", "  (let loop ([left 0] [right (- (string-length text) 1)])\n\
    \    (or (= left right)\n        (and (char=? (string-ref text left) (string-ref\
    \ text right))\n             (loop (+ left 1) (- right 1))))))\n", "  ;; first\
    \ check if text is empty\n  (if (null? text)\n      #t\n      ;; otherwise, check\
    \ if first and last character are the same\n      (if (string=? (string-ref text\
    \ 0) (string-ref text (- (string-length text) 1)))\n          ;; remove first\
    \ and last character\n          (is_palindrome (substring text 1 (- (string-length\
    \ text) 1)))\n          #f)))\n", "  (define (iter-text left right)\n    (cond\n\
    \      ((null? text)\n       #t)\n      ((> left right)\n       #t)\n      ((char=?\
    \ (string-ref text left) (string-ref text right))\n       (iter-text (+ left 1)\
    \ (- right 1)))\n      (else\n       #f)))\n  (iter-text 0 (- (string-length text)\
    \ 1)))\n", "  (define (is_palindrome-rec text left right)\n    (if (and (zero?\
    \ left) (zero? right)) #t\n        (and (char=? (string-ref text left) (string-ref\
    \ text right))\n             (is_palindrome-rec text (- left 1) (- right 1)))))\n\
    \  (is_palindrome-rec text (- (string-length text) 1) 0))\n", "  (if (string=?\
    \ \"\" text)\n      #t\n      (is_palindrome_helper (string-&gt;list text) 0 (-\
    \ (string-length text) 1))))\n", "  (define (is_palindrome_iter text count)\n\
    \    (if (= count 0)\n        #t\n        (and (= (string-ref text count) (string-ref\
    \ text (- count 1)))\n             (is_palindrome_iter text (- count 1)))))\n\
    \  (is_palindrome_iter text (- (string-length text) 1)))\n", "  (define (is_palindrome_aux\
    \ text left right)\n    (if (>= left right)\n        #t\n        (if (char=? (string-ref\
    \ text left) (string-ref text right))\n            (is_palindrome_aux text (+\
    \ left 1) (- right 1))\n            #f)))\n  (is_palindrome_aux text 0 (- (string-length\
    \ text) 1)))\n", "  (if (or (empty? text) (equal? (first text) (last text)))\n\
    \      (if (&lt;= (length text) 3)\n          #t\n          (is_palindrome (rest\
    \ (butlast text))))\n      #f))\n", "  (define (iter left right)\n    (if (= left\
    \ right)\n        #t\n        (if (= (string-ref text left) (string-ref text right))\n\
    \            (iter (+ left 1) (- right 1))\n            #f)))\n  (iter 0 (- (string-length\
    \ text) 1)))\n", "  (string=? text (string-reverse text)))\n", "  (define (aux\
    \ text)\n    (if (empty? text) #t\n        (define (is_first_eq_last_char text)\n\
    \          (equal? (first text) (last text)))\n      (if (is_first_eq_last_char\
    \ text)\n          (aux (rest (butlast text)))\n          #f)))\n  (aux text))\n",
  "  ;; consume first and last symbols\n  (define (consume first last lst)\n    (if\
    \ (empty? lst)\n        #t\n        (if (char=? first last)\n            (consume\
    \ (string-ref lst 0) (string-ref lst (- (string-length lst) 1)) (substring lst\
    \ 1 (- (string-length lst) 1)))\n            #f)))\n  (cond\n    [(empty? text)\
    \ #t]\n    [(= (string-length text) 1) #t]\n    [else (consume (string-ref text\
    \ 0) (string-ref text (- (string-length text) 1)) (substring text 1 (- (string-length\
    \ text) 1)))]))\n```\n\n```racket\n#lang racket\n", "  (let loop ([text text]\
    \ [last 0])\n    (if (eq? (substring text last) \"\")\n        #t\n        (loop\
    \ (substring text 1) (+ last 1)))))\n", "  (equal? text (string-reverse text)))\n",
  "  ;; if text is one character, it is a palindrome\n  (if (string=? (string-length\
    \ text) 1)\n      #t\n      ;; if text is more than one character, check first\
    \ and last character are the same\n      (if (string=? (string-ref text 0) (string-ref\
    \ text (- (string-length text) 1)))\n          ;; if they are, check if the substring\
    \ without the first and last characters is a palindrome\n          (is_palindrome\
    \ (substring text 1 (- (string-length text) 1)))\n          ;; if they aren't,\
    \ text is not a palindrome\n          #f)))\n", "  (define (rec t)\n    (if (=\
    \ (string-length t) 0)\n        #t\n        (let* ([first (string-ref t 0)]\n\
    \               [last (string-ref t (- (string-length t) 1))])\n          (if\
    \ (= first last)\n              (rec (substring t 1 (- (string-length t) 1)))\n\
    \              #f))))\n  (rec text))\n", "  (define (aux text len)\n    (cond\n\
    \      [(= len 1) #t]\n      [(= len 2) (equal? (string-ref text 0) (string-ref\
    \ text 1))]\n      [else (and (equal? (string-ref text 0) (string-ref text (-\
    \ len 1)))\n                 (aux (substring text 1 (- len 2)) (- len 2)))]))\n\
    \  (aux text (string-length text)))\n", "  ;; Checks if given string is the same\
    \ length as its reverse\n  (define (helper text)\n    (equal? text (string-reverse\
    \ text)))\n  (helper text))\n", "  (string=? (reverse-string text) text))\n",
  "  (string=? text (string-reverse text)))\n", "  (define (is_palindrome_iter text\
    \ i j)\n    (cond ((= i j) #t)\n          ((= (- j i) 1) #t)\n          ((char=?\
    \ (string-ref text i) (string-ref text j))\n           (is_palindrome_iter text\
    \ (+ i 1) (- j 1)))\n          (else #f)))\n  (is_palindrome_iter text 0 (- (string-length\
    \ text) 1)))\n", "  (is_palindrome-iter text))\n", "  (cond\n    ((= (string-length\
    \ text) 0) #t)\n    ((= (string-length text) 1) #t)\n    ((= (string-ref text\
    \ 0) (string-ref text (- (string-length text) 1)))\n        (is_palindrome (substring\
    \ text 1 (- (string-length text) 1))))\n    (else #f)))\n", "  (cond [(empty?\
    \ text) #t]\n        [(equal? (first text) (last text)) (is_palindrome (rest (butlast\
    \ text)))]\n        [else #f]))\n", "  (if (or (empty? text) (empty? (rest text)))\n\
    \      #t\n      (if (equal? (first text) (last text))\n          (is_palindrome\
    \ (rest (butlast text)))\n          #f)))\n", "  (if (= (string-length text) 0)\n\
    \      #t\n      (let ((first (string-ref text 0))\n            (last  (string-ref\
    \ text (- (string-length text) 1))))\n        (and (= first last)\n          \
    \   (is_palindrome (substring text 1 (- (string-length text) 1)))))))\n", "  (cond\n\
    \    [(empty? text) #t]\n    [(char=? (first text) (last text))\n     (is_palindrome\
    \ (string-drop-right (string-drop text 1) 1))]\n    [else #f]))\n", "  (match\
    \ text\n    [(struct string? text\n             (? (and (eq? (string-length text)\
    \ 0)\n                     #t)))\n     #t]\n    [(struct string? text\n      \
    \       (? (and (eq? (string-length text) 1)\n                     #t)))\n   \
    \  #t]\n    [(struct string? text\n             (? (and (> (string-length text)\
    \ 1)\n                     #t)))\n     (string=? text (string-reverse text))]))\n",
  "  (define (helper text left right)\n    (if (or (empty? (rest text)) (= left right))\n\
    \        #t\n        (if (equal? (list-ref text left) (list-ref text right))\n\
    \            (helper text (+ left 1) (- right 1))\n            #f)))\n  (helper\
    \ text 0 (- (length text) 1)))\n", "  (eq? text (string-reverse text)))\n", " \
    \ (define (iter first last)\n    (if (equal? last first)\n        #t\n       \
    \ (if (char=? (string-ref text first) (string-ref text last))\n            (iter\
    \ (+ first 1) (- last 1))\n            #f)))\n  (iter 0 (- (string-length text)\
    \ 1)))\n```\n\n### Trzy najd\u0142u\u017Csze palindromy z zadanego tekstu\n\n\
    ```scheme\n#lang racket\n", "  (define (remaining_letters beg)\n    (remaining_letters_iter\
    \ beg (+ beg (string-length text))))\n  (define (remaining_letters_iter beg end)\n\
    \    (if (= beg end)\n        '()\n        (cons (string-ref text beg) (remaining_letters_iter\
    \ (+ beg 1) end))))\n  (define (palindrome-checker letters)\n    (if (null? letters)\n\
    \        #t\n        (if (null? (cdr letters))\n            #t\n            (and\
    \ (= (car letters) (car (cdr letters)))\n                 (palindrome-checker\
    \ (cdr (cdr letters)))))))\n  (palindrome-checker (remaining_letters 0)))\n\n\
    ```\n\n```lisp\n#lang racket\n", "  (let ((index (floor (/ (string-length text)\
    \ 2))))\n    (define (palindrome-helper start end)\n      (if (equal? start end)\n\
    \          #t\n          (if (equal? (string-ref text start) (string-ref text\
    \ end))\n              (palindrome-helper (+ start 1) (- end 1))\n           \
    \   #f)))\n    (palindrome-helper 0 (- (string-length text) 1))))\n", "  (define\
    \ (check left right)\n    (cond\n      ((or (empty? text) (= left right)) #t)\n\
    \      ((not (= (string-ref text left) (string-ref text right))) #f)\n      (else\
    \ (check (+ left 1) (- right 1)))))\n  (check 0 (- (string-length text) 1)))\n",
  "  (define (loop text left right)\n    (cond\n      [(string=? left right) #t]\n\
    \      [(string=? left \"\") #f]\n      [(string=? right \"\") #f]\n      [(string=?\
    \ (string-ref left 0) (string-ref right 0))\n       (loop text (substring left\
    \ 1 (string-length left))\n             (substring right 0 (- (string-length right)\
    \ 1)))]\n      [else #f]))\n  (loop text text (substring text (string-length text)\
    \ 0)))\n", "  (define n (- (string-length text) 1))\n  (define (helper lo hi)\n\
    \    (if (>= lo hi)\n        #t\n        (if (char=? (string-ref text lo) (string-ref\
    \ text hi))\n            (helper (+ lo 1) (- hi 1))\n            #f)))\n  (helper\
    \ 0 n))", "  (define (test text)\n    (cond ((empty? text) true)\n          ((char=?\
    \ (first text) (last text)) (test (substring (rest text) 0 -1)))\n          (else\
    \ false)))\n  (test text))\n```\n\n#### Iterative palindrome finder\n\n```racket\n\
    #lang racket\n", "  (cond\n    [(empty? text) true]\n    [(empty? (rest text))\
    \ true]\n    [(equal? (first text) (last text)) (is_palindrome (substring (rest\
    \ text) 0 -1))]\n    [else false]))", "  (if (string=? text \"\")\n      #t\n\
    \      (or\n       (string=? (string-append (substring text 0 1) (substring text\
    \ (- (string-length text) 1) (string-length text))) text)\n       (is_palindrome\
    \ (substring text 1 (- (string-length text) 1))))))\n", "  (cond [(empty? text)\
    \ true]\n        [(not (= (string-length text) 1))\n         (and (= (string-ref\
    \ text 0) (string-ref text (- (string-length text) 1)))\n              (is_palindrome\
    \ (substring text 1 (- (string-length text) 1))))]\n        [else true]))\n",
  "  (if (string=? text \"\")\n      #t\n      (if (string=? (substring text 0 1)\
    \ (substring text (sub1 (string-length text)) (string-length text)))\n       \
    \   (is_palindrome (substring text 1 (sub1 (string-length text))))\n         \
    \ #f)))\n", "  (if (or (null? text)\n          (= (string-length text) 1))\n \
    \     #t\n      (let ([c (string-ref text 0)]\n            [len (- (string-length\
    \ text) 1)])\n        (and (= c (string-ref text len))\n             (is_palindrome\
    \ (substring text 1 (- len 1)))))))\n", "  (define (palindrome-helper left right)\n\
    \    (cond\n      [(= left right)\n       true]\n      [(> left right)\n     \
    \  true]\n      [(= (string-ref text left) (string-ref text right))\n       (palindrome-helper\
    \ (+ left 1) (- right 1))]\n      [else\n       false]))\n  (if (equal? text \"\
    \")\n      true\n      (palindrome-helper 0 (- (string-length text) 1))))\n",
  "  (if (null? text)\n      #t\n      (equal? text (reverse text))))\n", "  (define\
    \ (char-at pos)\n    (if (= (string-length text) pos)\n        #\\0\n        (string-ref\
    \ text pos)))\n  (define (is-char-equal pos1 pos2)\n    (eq? (char-at pos1) (char-at\
    \ pos2)))\n  (define (iter pos1 pos2)\n    (if (and (not (is-char-equal pos1 pos2))\
    \ \n             (is-char-equal (- pos1 1) (- pos2 1)))\n        #f\n        (if\
    \ (or (= pos1 (- pos2 1))\n                (= pos1 pos2))\n            #t\n  \
    \          (iter (+ pos1 1) (- pos2 1)))))\n  (iter 0 (- (string-length text)\
    \ 1)))\n", "  (equal? (string-reverse text) text))\n", "  (match text\n    [(list)\
    \ #t]\n    [(list first (cons second rest)) (and (equal? first second) (is_palindrome\
    \ rest))]))\n", "  (or (null? text)\n      (and (char=? (string-ref text 0) (string-ref\
    \ text (- (string-length text) 1)))\n           (is_palindrome (substring text\
    \ 1 (- (string-length text) 1))))))\n```\n\n```", "  (cond ((or (empty? text)\
    \ (empty? (rest text))) #t)\n        ((equal? (first text) (last text)) (is_palindrome\
    \ (rest (butlast text))))\n        (else #f)))\n", "  (cond\n    [(empty? text)\n\
    \     #t]\n    [(char=? (first text) (last text))\n     (is_palindrome (rest (butlast\
    \ text)))]\n    [else\n     #f]))\n", "  (or (string=? text \"\")\n      (and\
    \ (string=? (substring text 0 1) (substring text -1))\n           (is_palindrome\
    \ (substring text 1 -1)))))\n", "  (if (string=? text \"\")\n      #t\n      (string=?\
    \ (string-reverse text) text)))\n", "  (equal? text (string-reverse text)))\n",
  "  (and (not (equal? (length text) 0)) (string=? (first text) (last text)) (is_palindrome\
    \ (rest (remove-last text)))))\n", "  (define (iter text i j)\n    (cond\n   \
    \   ((> i j) #t)\n      ((not (string=? (string-ref text i) (string-ref text j)))\
    \ #f)\n      (else (iter text (+ i 1) (- j 1)))))\n  (iter text 0 (- (string-length\
    \ text) 1)))\n", "  (define len (string-length text))\n  (and (not (eq? 0 len))\n\
    \       (string=? text (string-reverse text))))\n", "  (local [(define (helper\
    \ t)\n            (if (<= (string-length t) 1)\n                #t\n         \
    \       (and (char=? (string-ref t 0) (string-ref t (- (string-length t) 1)))\n\
    \                     (helper (substring t 1 (- (string-length t) 1))))))]\n \
    \   (helper text)))\n", "  (define (inner text)\n    (cond [(empty? text) empty]\n\
    \          [(cons-pair? text)\n           (if (char=? (car text) (cdr text))\n\
    \               (inner (cdr (cdr text)))\n               (list (car text) (cdr\
    \ text)))]\n          [else\n           (list (car text) (cdr text))]))\n  (null?\
    \ (inner text)))\n", "  (if (empty? text)\n      #t\n      (is_palindrome_helper\
    \ (string-upcase text) 0 (- (string-length text) 1))))\n", "  (is_palindrome-iter\
    \ text 0 (string-length text)))\n", "  (define (is_palindrome-helper i j)\n  \
    \  (cond [(= i j) #t]\n          [(= i (- j 1)) #t]\n          [(string-ci=? (string-ref\
    \ text i) (string-ref text j))\n           (is_palindrome-helper (+ i 1) (- j\
    \ 1))]\n          [else #f]))\n  (is_palindrome-helper 0 (- (string-length text)\
    \ 1)))", "  (define (loop text first_char last_char)\n    (if (and (= first_char\
    \ last_char) (not (= first_char -1)))\n        #t\n        (if (and (= (string-ref\
    \ text first_char) (string-ref text last_char))\n                 (= (- first_char\
    \ last_char) -2))\n            (loop text (+ first_char 1) (- last_char 1))\n\
    \            #f)))\n  (loop text 0 (- (string-length text) 1)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
