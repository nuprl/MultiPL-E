name: HumanEval_108_count_nums
language: rkt
prompt: "#lang racket\n\n;; Write a function count_nums which takes a list of integers\
  \ and returns\n;; the number of elements which has a sum of digits > 0.\n;; If a\
  \ number is negative, then its first signed digit will be negative:\n;; e.g. -123\
  \ has signed digits -1, 2, and 3.\n;; >>> (count_nums (list ))\n;; 0\n;; >>> (count_nums\
  \ (list -1 11 -11))\n;; 1\n;; >>> (count_nums (list 1 1 2))\n;; 3\n(define (count_nums\
  \ arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_nums))\n\
  \    (check-equal? (candidate (list )) 0)\n    (check-equal? (candidate (list -1\
  \ -2 0)) 0)\n    (check-equal? (candidate (list 1 1 2 -2 3 4 5)) 6)\n    (check-equal?\
  \ (candidate (list 1 6 9 -6 0 1 5)) 5)\n    (check-equal? (candidate (list 1 100\
  \ 98 -7 1 -1)) 4)\n    (check-equal? (candidate (list 12 23 34 -45 -56 0)) 5)\n\
  \    (check-equal? (candidate (list 0 1)) 1)\n    (check-equal? (candidate (list\
  \ 1)) 1)\n))\n\n(test-humaneval)"
completions: ["  (if (null? arr)\n      0\n      (+ (eq? (sum-digits (abs (car arr)))\
    \ 0)\n         (count_nums (cdr arr)))))\n", "  (if (empty? arr)\n      0\n  \
    \    (+ 1 (count_nums (cdr arr)))))\n", "  (count_nums_helper arr 0))\n", "  (define\
    \ (helper arr sum-cnt)\n    (if (null? arr)\n        sum-cnt\n        (let ((digits\
    \ (abs (car arr))))\n          (helper (cdr arr) (+ sum-cnt (if (> (+ digits (car\
    \ (remainder/modulo digits 10))) 0) 1 0))))))\n  (helper arr 0))\n", "  (let loop\
    \ ([n 0] [arr arr])\n    (cond [(empty? arr) n]\n          [(> (absolute (apply\
    \ + (map number->string (string->list (number->string (car arr)))))) 0) (loop\
    \ (+ n 1) (cdr arr))]\n          [else (loop n (cdr arr))])))\n", "  (cond\n \
    \   ((empty? arr) 0)\n    ((> (sum_of_digits (first arr)) 0)\n     (+ 1 (count_nums\
    \ (rest arr))))\n    (else (count_nums (rest arr)))))\n", "  (count-if (lambda\
    \ (x) (> (abs (foldl + 0 (map abs (string->list (number->string x)))) 0)) arr))\n\
    )\n", "  (cond\n    [(empty? arr) 0]\n    [else\n     (if (positive? (sum_digits\
    \ (first arr)))\n         (+ 1 (count_nums (rest arr)))\n         (count_nums\
    \ (rest arr)))]))\n", "  (cond ((null? arr) 0)\n        ((>= (abs (car arr)) 10)\
    \ (add1 (count_nums (cdr arr))))\n        ((< (abs (car arr)) 10) (count_nums\
    \ (cdr arr)))))\n", "  (let loop ([arr arr] [count 0])\n    (cond [(empty? arr)\
    \ count]\n          [(positive? (list-sum (list->digits (first arr))))\n     \
    \      (loop (rest arr) (+ count 1))]\n          [else (loop (rest arr) count)])))\n",
  "  (cond\n    [(empty? arr) 0]\n    [else\n     (if (equal? 0 (sum_digits (car arr)))\n\
    \         (count_nums (cdr arr))\n         (+ 1 (count_nums (cdr arr))))]))\n",
  "  (let loop ([arr arr] [i 0])\n    (cond [(empty? arr) i]\n          [(> (sum-digits\
    \ (car arr)) 0) (loop (cdr arr) (+ i 1))]\n          [else (loop (cdr arr) i)])))\n",
  "  (if (null? arr)\n      0\n      (+ (if (sum (abs (map (lambda (x) (if (zero?\
    \ x) 0 x)) (list-ref arr 0)))) 0) 1 0)\n         (count_nums (cdr arr)))))\n",
  "  (cond\n    [(empty? arr) 0]\n    [else (+ (positive? (sum-digits (first arr)))\n\
    \             (count_nums (rest arr)))]))\n", "  (length (filter sum_of_digits?\
    \ arr)))\n", "  (cond\n    [(empty? arr) 0]\n    [else\n     (if (positive? (sum-of-digits\
    \ (first arr)))\n         (+ 1 (count_nums (rest arr)))\n         (count_nums\
    \ (rest arr)))]))\n", "  (cond [(empty? arr) 0]\n        [else\n         (if (>\
    \ (abs (signed-digit-sum (first arr))) 0)\n             (+ 1 (count_nums (rest\
    \ arr)))\n             (count_nums (rest arr)))]))\n", "  (cond\n    [(null? arr)\
    \ 0]\n    [else\n     (if (> (abs (car arr)) 9)\n         (+ (count_nums (cdr\
    \ arr)) 1)\n         (count_nums (cdr arr)))]))\n", "  (if (null? arr)\n     \
    \ 0\n      (+ (if (> (+ (abs (car arr))\n                   (modulo (abs (car\
    \ arr)) 10))\n              0)\n             1\n             0)\n         (count_nums\
    \ (cdr arr)))))\n", "  (define (iter a acc)\n    (cond [(empty? a) acc]\n    \
    \      [(= (abs (car a)) (car a))\n           (iter (cdr a) (add1 acc))]\n   \
    \       [else (iter (cdr a) acc)]))\n  (iter arr 0))"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
