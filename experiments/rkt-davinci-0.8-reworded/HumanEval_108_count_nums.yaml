name: HumanEval_108_count_nums
language: rkt
prompt: "#lang racket\n\n;; Write a function count_nums which takes a list of integers\
  \ and returns\n;; the number of elements which has a sum of digits > 0.\n;; If a\
  \ number is negative, then its first signed digit will be negative:\n;; e.g. -123\
  \ has signed digits -1, 2, and 3.\n;; >>> (count_nums (list ))\n;; 0\n;; >>> (count_nums\
  \ (list -1 11 -11))\n;; 1\n;; >>> (count_nums (list 1 1 2))\n;; 3\n(define (count_nums\
  \ arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_nums))\n\
  \    (check-equal? (candidate (list )) 0)\n    (check-equal? (candidate (list -1\
  \ -2 0)) 0)\n    (check-equal? (candidate (list 1 1 2 -2 3 4 5)) 6)\n    (check-equal?\
  \ (candidate (list 1 6 9 -6 0 1 5)) 5)\n    (check-equal? (candidate (list 1 100\
  \ 98 -7 1 -1)) 4)\n    (check-equal? (candidate (list 12 23 34 -45 -56 0)) 5)\n\
  \    (check-equal? (candidate (list 0 1)) 1)\n    (check-equal? (candidate (list\
  \ 1)) 1)\n))\n\n(test-humaneval)"
completions: ["  (if (null? arr)\n      0\n      (+ (eq? (sum-digits (abs (car arr)))\
    \ 0)\n         (count_nums (cdr arr)))))\n", "  (if (empty? arr)\n      0\n  \
    \    (+ 1 (count_nums (cdr arr)))))\n", "  (count_nums_helper arr 0))\n", "  (define\
    \ (helper arr sum-cnt)\n    (if (null? arr)\n        sum-cnt\n        (let ((digits\
    \ (abs (car arr))))\n          (helper (cdr arr) (+ sum-cnt (if (> (+ digits (car\
    \ (remainder/modulo digits 10))) 0) 1 0))))))\n  (helper arr 0))\n", "  (let loop\
    \ ([n 0] [arr arr])\n    (cond [(empty? arr) n]\n          [(> (absolute (apply\
    \ + (map number->string (string->list (number->string (car arr)))))) 0) (loop\
    \ (+ n 1) (cdr arr))]\n          [else (loop n (cdr arr))])))\n", "  (cond\n \
    \   ((empty? arr) 0)\n    ((> (sum_of_digits (first arr)) 0)\n     (+ 1 (count_nums\
    \ (rest arr))))\n    (else (count_nums (rest arr)))))\n", "  (count-if (lambda\
    \ (x) (> (abs (foldl + 0 (map abs (string->list (number->string x)))) 0)) arr))\n\
    )\n", "  (cond\n    [(empty? arr) 0]\n    [else\n     (if (positive? (sum_digits\
    \ (first arr)))\n         (+ 1 (count_nums (rest arr)))\n         (count_nums\
    \ (rest arr)))]))\n", "  (cond ((null? arr) 0)\n        ((>= (abs (car arr)) 10)\
    \ (add1 (count_nums (cdr arr))))\n        ((< (abs (car arr)) 10) (count_nums\
    \ (cdr arr)))))\n", "  (let loop ([arr arr] [count 0])\n    (cond [(empty? arr)\
    \ count]\n          [(positive? (list-sum (list->digits (first arr))))\n     \
    \      (loop (rest arr) (+ count 1))]\n          [else (loop (rest arr) count)])))\n",
  "  (cond\n    [(empty? arr) 0]\n    [else\n     (if (equal? 0 (sum_digits (car arr)))\n\
    \         (count_nums (cdr arr))\n         (+ 1 (count_nums (cdr arr))))]))\n",
  "  (let loop ([arr arr] [i 0])\n    (cond [(empty? arr) i]\n          [(> (sum-digits\
    \ (car arr)) 0) (loop (cdr arr) (+ i 1))]\n          [else (loop (cdr arr) i)])))\n",
  "  (if (null? arr)\n      0\n      (+ (if (sum (abs (map (lambda (x) (if (zero?\
    \ x) 0 x)) (list-ref arr 0)))) 0) 1 0)\n         (count_nums (cdr arr)))))\n",
  "  (cond\n    [(empty? arr) 0]\n    [else (+ (positive? (sum-digits (first arr)))\n\
    \             (count_nums (rest arr)))]))\n", "  (length (filter sum_of_digits?\
    \ arr)))\n", "  (cond\n    [(empty? arr) 0]\n    [else\n     (if (positive? (sum-of-digits\
    \ (first arr)))\n         (+ 1 (count_nums (rest arr)))\n         (count_nums\
    \ (rest arr)))]))\n", "  (cond [(empty? arr) 0]\n        [else\n         (if (>\
    \ (abs (signed-digit-sum (first arr))) 0)\n             (+ 1 (count_nums (rest\
    \ arr)))\n             (count_nums (rest arr)))]))\n", "  (cond\n    [(null? arr)\
    \ 0]\n    [else\n     (if (> (abs (car arr)) 9)\n         (+ (count_nums (cdr\
    \ arr)) 1)\n         (count_nums (cdr arr)))]))\n", "  (if (null? arr)\n     \
    \ 0\n      (+ (if (> (+ (abs (car arr))\n                   (modulo (abs (car\
    \ arr)) 10))\n              0)\n             1\n             0)\n         (count_nums\
    \ (cdr arr)))))\n", "  (define (iter a acc)\n    (cond [(empty? a) acc]\n    \
    \      [(= (abs (car a)) (car a))\n           (iter (cdr a) (add1 acc))]\n   \
    \       [else (iter (cdr a) acc)]))\n  (iter arr 0))", "  (cond\n    [(empty?\
    \ arr) 0]\n    [else (+ 1 (count_nums (cdr arr)))]))\n```\n\n``` #lang racket",
  "  (cond [(null? arr) 0]\n        [else (+ (if (> (absolute (sum_digits (car arr)))\
    \ 0) 1 0)\n                 (count_nums (cdr arr)))]))\n", "  (length (filter\
    \ (lambda (x)\n                    (> (reduce + (map abs (list->digits x))) 0))\n\
    \                  arr)))\n", "  (if (null? arr)\n      0\n      (+ (if (sum-digits\
    \ (abs (car arr))) 1 0)\n         (count_nums (cdr arr)))))\n", "  (cond [(null?\
    \ arr) 0]\n        [else (+ (cond [(= 0 (abs (- (car arr)))) 0]\n            \
    \          [else 1])\n                 (count_nums (cdr arr)))]))\n", "  (length\
    \ (filter (lambda (x) (> (apply + (map (lambda (y) (abs y)) (digits x))) 0)) arr)))\n",
  "  (length (filter (lambda (n)\n                    (> (apply + (map abs (map (lambda\
    \ (d) (string->number (list d))) (string->list (number->string n)))))) 0)) arr)))\n",
  "  (length (filter (lambda (x) (not (or (zero? x) (negative? x)))) arr)))\n", " \
    \ (cond [(empty? arr) 0]\n        [else (+ (check_nums (car arr)) (count_nums\
    \ (cdr arr)))]))\n", "  (define (signed-digits n)\n    (if (and (negative? n)\
    \ (not (positive? (modulo n 10))))\n        (append (signed-digits (abs n)) (list\
    \ -1))\n        (number->list n)))\n  (if (null? arr)\n      0\n      (+ (if (>\
    \ (apply + (signed-digits (car arr))) 0) 1 0)\n         (count_nums (cdr arr)))))",
  "  (cond\n    [(null? arr) 0]\n    [else (+ (if (if (< 0 (abs (car arr))) 1 0) 1\
    \ 0) (count_nums (cdr arr)))]))", "  (if (empty? arr)\n      0\n      (+ (if (>\
    \ (apply + (abs (flatten (map (lambda (x) (string->list (number->string x))) (list->vector\
    \ arr)))))) 0) 1 0)\n         (count_nums (rest arr)))))", "  (define (convert-digit\
    \ n)\n    (cond\n      [(< n 0) (- n)]\n      [else n]))\n  (define (convert-number\
    \ n)\n    (cond\n      [(< n 0) (- n)]\n      [else n]))\n  (define (digitsum\
    \ n)\n    (cond\n      [(= n 0) 0]\n      [else (+ (convert-digit (remainder n\
    \ 10)) (digitsum (quotient n 10)))]))\n  (cond\n    [(empty? arr) 0]\n    [else\
    \ (+ (if (> (digitsum (convert-number (first arr))) 0) 1 0) (count_nums (rest\
    \ arr)))]))\n", "  (cond ((null? arr) 0)\n        ((> (abs (car arr)) 9)\n   \
    \      (+ 1 (count_nums (cdr arr))))\n        ((= (abs (car arr)) 9)\n       \
    \  (+ 1 (count_nums (cdr arr))))\n        ((> (abs (car arr)) 0)\n         (+\
    \ 1 (count_nums (cdr arr))))\n        (else (count_nums (cdr arr)))))\n\n", " \
    \ (define (digitize num)\n    (cond\n      [(< num 0)\n       (cons (- num)\n\
    \             (digitize (quotient (+ num (* (- num) 10)) 10)))]\n      [(> num\
    \ 0)\n       (cons (remainder num 10)\n             (digitize (quotient num 10)))]\n\
    \      [else\n       empty]))\n  (define (sum-digits nums)\n    (cond\n      [(empty?\
    \ nums)\n       0]\n      [else\n       (+ (first nums)\n          (sum-digits\
    \ (rest nums)))]))\n  (define (iter arr total)\n    (cond\n      [(empty? arr)\n\
    \       total]\n      [(> (sum-digits (digitize (first arr))) 0)\n       (iter\
    \ (rest arr) (+ total 1))]\n      [else\n       (iter (rest arr) total)]))\n \
    \ (iter arr 0))\n", "  (define (signed-digit x)\n    (cond ((= x 0) 0)\n     \
    \     ((> x 0) (modulo x 10))\n          ((< x 0) (modulo (- x) 10))))\n  (define\
    \ (sums-positive? arr)\n    (cond ((null? arr) #f)\n          ((<= 0 (apply +\
    \ (map (signed-digit) arr))) #t)\n          (else (sums-positive? (cdr arr)))))\n\
    \  (define (count arr)\n    (cond ((null? arr) 0)\n          ((sums-positive?\
    \ arr) (+ 1 (count (cdr arr))))\n          (else (count (cdr arr)))))\n  (count\
    \ arr))\n", "  (define (sign x)\n    (if (> x 0) x (* -1 x)))\n  (define (sum_digits\
    \ x)\n    (if (= x 0) 0 (+ (sign x) (sum_digits (quotient x 10)))))\n  (define\
    \ (count_nums_iter arr acc)\n    (if (null? arr) acc\n      (if (> (sum_digits\
    \ (car arr)) 0)\n          (count_nums_iter (cdr arr) (+ acc 1))\n          (count_nums_iter\
    \ (cdr arr) acc))))\n  (count_nums_iter arr 0))\n", "  (count (apply + (map abs\
    \ (map signed-digits arr))) arr))\n</code>\nHere is the error message:\n<code>count.rkt:5:5:\
    \ apply: not enough arguments\n  in: (apply + (map abs (map signed-digits arr)))\n\
    \  context...:\n   /home/ubuntu/workspace/count.rkt:5:5\n</code>\nWhat am I doing\
    \ wrong here?\n\n\nA:\n\nThe problem is that the <code>signed-digits</code> procedure\
    \ takes a single number, whereas the <code>map</code> procedure takes a procedure\
    \ and a list of arguments. The <code>map</code> procedure applies the given procedure\
    \ to all the elements of the list.\nIn this case, the <code>map</code> procedure\
    \ applies the <code>signed-digits</code> procedure to all the elements of the\
    \ list. Since the <code>signed-digits</code> procedure takes a single number,\
    \ this ends up calling <code>signed-digits</code> with each number as the first\
    \ argument and the rest of the list as the second argument.\nTo fix this, you\
    \ need to call <code>signed-digits</code> on each number of the list. You can\
    \ do this by replacing the <code>map</code> procedure call with:\n<code>(for/list\
    \ ([x arr]) (signed-digits x))\n</code>\nThis will give you the list of numbers\
    \ generated by applying <code>signed-digits</code> to each number in the list.\n",
  "  (cond [(empty? arr) 0]\n        [else\n         (if (> (sum_digits (first arr))\
    \ 0)\n             (+ 1 (count_nums (rest arr)))\n             (count_nums (rest\
    \ arr)))]))\n", "  (cond ((null? arr) 0)\n        ((> (+ (abs (car arr)) (abs\
    \ (cadr arr))) 0)\n         (+ 1 (count_nums (cdr arr))))\n        (else (count_nums\
    \ (cdr arr)))))\n", "  (cond\n    [(empty? arr) 0]\n    [else (+ (if (> (sum_of_digits\
    \ (first arr)) 0) 1 0)\n             (count_nums (rest arr)))]))\n", "  (cond\n\
    \    [(empty? arr) 0]\n    [else\n     (define sum_digits (lambda (n)\n\t\t\t\
    \  (cond\n\t\t\t    [(= n 0) 0]\n\t\t\t    [else\n\t\t\t     (+ (modulo n 10)\n\
    \t\t\t\t(sum_digits (quotient n 10)))])))\n     (define first_digits (lambda (n)\n\
    \t\t\t    (cond\n\t\t\t      [(= n 0) 0]\n\t\t\t      [else\n\t\t\t       (quotient\
    \ n (expt 10\n\t\t\t\t\t\t  (quotient (abs (log (abs n)))\n\t\t\t\t\t\t\t    (log\
    \ 10))))])))\n     (cond\n       [(positive? (sum_digits (first arr)))\n\t(+ 1\
    \ (count_nums (rest arr)))]\n       [(positive? (sum_digits (first_digits (first\
    \ arr))))\n\t(+ 1 (count_nums (rest arr)))]\n       [else\n\t(count_nums (rest\
    \ arr))])])\n", "  (cond\n    [(empty? arr) 0]\n    [else (+ (and (sum_of_digits\
    \ (first arr)) 1) (count_nums (rest arr)))]))\n", "  (define (iter count arr)\n\
    \    (cond ((null? arr) count)\n          ((&gt; (abs (car arr)) 0)\n        \
    \   (iter (+ count 1) (cdr arr)))\n          (else (iter count (cdr arr)))))\n\
    \  (iter 0 arr))\n</code>\nI'm getting this error:\n<code>&gt; (define (count_nums\
    \ arr)\n  (define (iter count arr)\n    (cond ((null? arr) count)\n          ((&gt;\
    \ (abs (car arr)) 0)\n           (iter (+ count 1) (cdr arr)))\n          (else\
    \ (iter count (cdr arr)))))\n  (iter 0 arr))\n\nprocedure application: expected\
    \ procedure, given: #&lt;void&gt;; arguments were: 10 #f\n</code>\nWhat's going\
    \ on? I have no idea how to tackle this error.\n\n\nA:\n\nIn the specific case\
    \ of <code>negative?</code>, <code>&gt;</code>, and <code>=</code>, it's not an\
    \ error. The reason is that these procedures are defined by your implementation\
    \ to provide a default value when necessary, in this case 0.\nFor example, <code>&gt;</code>\
    \ is defined like this:\n<code>(define (&gt; x y)\n  (apply &gt; (append (list\
    \ x) y)))\n</code>\nand <code>append</code> is defined like this:\n<code>(define\
    \ (append x y)\n  (if (null? x)\n      y\n      (cons (car x) (append (cdr x)\
    \ y))))\n</code>\nthe result is that you can write:\n<code>(&gt; 1) ; evaluates\
    \ to #t\n</code>\nBut this is not the case with <code>+</code> because it's not\
    \ defined by the implementation to take only one argument.\n<code>(+ 1) ; error\n\
    </code>\nYou should replace the <code>&gt;</code> in your code with <code>&gt;=</code>\
    \ and everything will work as expected.\n", "  (define (helper arr)\n    (cond\
    \ ((null? arr) 0)\n          ((>= 0 (sum_digits (abs (car arr)))) (helper (cdr\
    \ arr)))\n          (else (+ 1 (helper (cdr arr))))))\n  (helper arr))\n", " \
    \ (cond [(null? arr) 0]\n        [else (if (> (+ (abs (quotient (car arr) 10))\n\
    \                       (remainder (car arr) 10)) 0)\n                  (+ 1 (count_nums\
    \ (cdr arr)))\n                  (count_nums (cdr arr)))]))\n", "  (cond\n   \
    \ [(null? arr) 0]\n    [else\n     (let ([sum (reduce + (map (lambda (x) (if (negative?\
    \ x) (- x) x)) arr))])\n       (+ (if (> sum 0) 1 0) (count_nums (cdr arr))))]))\n",
  "  (cond [(null? arr) 0]\n        [else (define (sum-digits x)\n               \
    \ (cond [(= x 0) 0]\n                      [else (+ (sum-digits (quotient x 10))\
    \ (remainder x 10))]))\n              (cond [(> (sum-digits (abs (car arr))) 0)\
    \ (+ 1 (count_nums (cdr arr)))]\n                    [else (count_nums (cdr arr))])]))\n",
  "  (cond [(null? arr) 0]\n        [else (if (and (and (> (abs (car arr)) 0)\n  \
    \                          (> (+ (abs (remainder (car arr) 10))\n            \
    \                      (abs (remainder (abs (car arr)) 10))\n                \
    \                  (abs (remainder (abs (car arr)) 10))) 0)))\n              \
    \      1)\n                 0)]\n        [else (+ (count_nums (cdr arr))\n   \
    \              (if (and (and (> (abs (car arr)) 0)\n                         \
    \      (> (+ (abs (remainder (car arr) 10))\n                                \
    \     (abs (remainder (abs (car arr)) 10))\n                                 \
    \    (abs (remainder (abs (car arr)) 10))) 0)))\n                     1)\n   \
    \              0))]))\n", "  (cond\n    [(empty? arr) 0]\n    [(&gt; (count_nums\
    \ (rest arr)) 0)\n     (if (&gt; (sum_digits (first arr)) 0)\n         (+ 1 (count_nums\
    \ (rest arr)))\n         (count_nums (rest arr)))]\n    [else\n     (+ 1 (count_nums\
    \ (rest arr)))]))\n", "  (length (filter (lambda (n) (&gt; (sum-digits n) 0))\
    \ arr)))\n", "  (cond\n    [(empty? arr) 0]\n    [else\n     (if (sum_digits (first\
    \ arr))\n         (+ 1 (count_nums (rest arr)))\n         (count_nums (rest arr)))]))\n",
  "  (cond\n    [(empty? arr) 0]\n    [else\n     (if (> (sum-digits (first arr))\
    \ 0)\n         (+ 1 (count_nums (rest arr)))\n         (count_nums (rest arr)))]))\n",
  "    (cond\n        [(empty? arr) 0]\n        [else\n         (if (> (foldl + 0\
    \ (map abs (map sign-extend (list->vector arr)))) 0)\n             (+ 1 (count_nums\
    \ (cdr arr)))\n             (count_nums (cdr arr)))]))\n", "  (foldl (lambda (el\
    \ acc)\n           (if (> (+ (remainder el 10) (remainder (quotient el 10) 10))\
    \ 0)\n               (+ acc 1)\n               acc))\n         0\n         arr))\n",
  "  (cond\n    [(empty? arr) 0]\n    [else\n     (if (sum_digits (first arr))\n \
    \        (+ 1 (count_nums (rest arr)))\n         (count_nums (rest arr)))]))\n",
  "  (if (null? arr)\n      0\n      (+ (sum_digits (car arr)) (count_nums (cdr arr)))))\n",
  "  (define (iter arr acc)\n    (cond ((null? arr) acc)\n          ((> (apply + (append\
    \ (list (abs (car arr)))\n                                (list->digits (abs (car\
    \ arr))))))\n              0)\n           (else (iter (cdr arr) (+ acc 1))))))\n\
    \  (iter arr 0))\n", "  (cond\n    [(empty? arr) 0]\n    [else (+ (sum (map sign\
    \ (abs (first arr))))\n             (count_nums (rest arr)))]))\n", "  (cond\n\
    \    [(null? arr) 0]\n    [else\n     (if (not (= (sum_digits (car arr)) 0))\n\
    \         (+ 1 (count_nums (cdr arr)))\n         (count_nums (cdr arr)))]))\n",
  "  (cond\n    [(null? arr) 0]\n    [else\n     (cond\n       [(> (+ (abs (car arr))\
    \ (abs (modulo (car arr) 10))) 0)\n        (+ 1 (count_nums (cdr arr)))]\n   \
    \    [else\n        (count_nums (cdr arr))])]))", "  (foldl (lambda (a b)\n  \
    \         (cond ((= b 0) b)\n                 ((< a 0) (+ b (abs a)))\n      \
    \           (else (+ b a))))\n         0\n         arr))\n", "  (cond\n    [(null?\
    \ arr) 0]\n    [else (+ (satisfies? (car arr)) (count_nums (cdr arr)))]))\n",
  "  (let count ((a (reverse arr)) (n 0))\n    (if (null? a)\n        n\n        (count\
    \ (cdr a) (if (positive? (sum_digits (car a)))\n                           (+\
    \ n 1)\n                           n)))))\n", "  (count-if (lambda (x) (> (sum-abs-digits\
    \ x) 0)) arr))\n", "  (define (count_nums_iter arr acc)\n    (cond\n      [(empty?\
    \ arr) acc]\n      [(<= (sum_digits (first arr)) 0) (count_nums_iter (rest arr)\
    \ acc)]\n      [else (count_nums_iter (rest arr) (+ acc 1))]))\n  (count_nums_iter\
    \ arr 0))\n", "  (apply + (map (lambda (x) (if (and (not (zero? x)) (> x 0)) 1\
    \ 0)) arr)))\n", "  (cond\n    [(null? arr) 0]\n    [else\n     (if (not (negative?\
    \ (car arr)))\n         (+ (count_nums (cdr arr)) 1)\n         (count_nums (cdr\
    \ arr)))]))\n", "  (length (filter (lambda (x)\n                    (if (eq? (abs\
    \ x) x)\n                        (filter (lambda (c)\n                       \
    \           (char-numeric? c))\n                                (number->string\
    \ x))\n                        (filter (lambda (c)\n                         \
    \         (char-numeric? c))\n                                (number->string\
    \ (abs x)))))\n                  arr)))\n```\n\n```scheme\n#lang racket\n", " \
    \ (for/sum ([el (in-list arr)])\n    (define (digit-sum x)\n      (if (negative?\
    \ x)\n          (+ (modulo x 10) (digit-sum (quotient x 10)))\n          (if (&lt;\
    \ x 10)\n              x\n              (+ (modulo x 10) (digit-sum (quotient\
    \ x 10))))))\n    (if (&gt; (digit-sum el) 0)\n        1\n        0)))\n", " \
    \ (count (lambda (n)\n           (andmap (lambda (d) (> (+ d) 0))\n          \
    \         (signed-digits n)))\n          arr))\n", "  (define (sum-digits n)\n\
    \    (cond\n      [(< n 0) (+ (- n) (sum-digits (- n)))]\n      [(= n 0) 0]\n\
    \      [else (+ (modulo n 10) (sum-digits (quotient n 10)))]))\n  (count (lambda\
    \ (x) (> (sum-digits x) 0)) arr))", "  (cond [(null? arr) 0]\n        [else (cond\
    \ [(> (signed-sum (car arr)) 0) (+ 1 (count_nums (cdr arr)))]\n              \
    \     [else (count_nums (cdr arr))])]))\n", "  (cond\n    [(null? arr) 0]\n  \
    \  [else\n     (let ([n (first arr)])\n       (+ (if (not (zero? (count_digits\
    \ n))) 1 0)\n          (count_nums (rest arr))))]))\n", "  (length (filter (lambda\
    \ (n) (> (sum_digits n) 0)) arr)))\n", "  (define (count_nums_helper arr count)\n\
    \    (cond\n      [(empty? arr) count]\n      [(> (sum_digits (first arr)) 0)\
    \ (count_nums_helper (rest arr) (+ count 1))]\n      [else (count_nums_helper\
    \ (rest arr) count)]))\n  (count_nums_helper arr 0))\n", "  (cond\n    [(empty?\
    \ arr) 0]\n    [else (+ 1 (count_nums (cdr arr)))]))\n", "  (cond [(empty? arr)\
    \ 0]\n        [else (+ (is-positive? (sum-digits (first arr)))\n             \
    \    (count_nums (rest arr)))]))\n", "  (let ((count 0))\n    (for ([i arr])\n\
    \      (let ((sum (get-sum i)))\n        (when (> sum 0)\n          (set! count\
    \ (+ count 1)))))\n    count))\n", "  (for/sum ([x arr])\n    (if (> (sum_digits\
    \ x) 0) 1 0)))", "  (cond\n    [(empty? arr) 0]\n    [else\n     (if (< (abs (-\
    \ (apply + (map abs (car arr))) (car arr))) 10)\n       (+ 1 (count_nums (cdr\
    \ arr)))\n       (count_nums (cdr arr)))]))\n", "  (cond [(empty? arr) 0]\n  \
    \      [else (+ (if (> (sum_of_digits (first arr)) 0) 1 0)\n                 (count_nums\
    \ (rest arr)))]))\n", "  (define (sum_digits n)\n    (cond [(= n 0) 0]\n     \
    \     [else (+ (abs (remainder n 10))\n                   (sum_digits (quotient\
    \ n 10)))]))\n  (foldl (lambda (x y) (if (> (sum_digits x) 0)\n              \
    \             (+ y 1)\n                           y))\n         0\n         arr))\n\
    ```\n\n```racket\n#lang racket\n", "  (letrec ([positive? (lambda (n)\n      \
    \                 (cond\n                         [(negative? n) false]\n    \
    \                     [(zero? n) false]\n                         [else true]))]\n\
    \           [signed-digits (lambda (n)\n                            (if (positive?\
    \ n)\n                                (modulo n 10)\n                        \
    \        (- (modulo n 10))))]\n           [digits (lambda (n)\n              \
    \       (cond\n                       [(negative? n) (cons (signed-digits n) (digits\
    \ (- n)))]\n                       [(zero? n) (list)]\n                      \
    \ [else (cons (signed-digits n) (digits (quotient n 10)))]))]\n           [sum\
    \ (lambda (n)\n                  (apply + (digits n)))]\n           [sum>zero?\
    \ (lambda (n)\n                        (positive? (sum n)))]\n           [aux\
    \ (lambda (arr acc)\n                  (cond\n                    [(empty? arr)\
    \ acc]\n                    [else (aux (rest arr) (+ acc (if (sum>zero? (first\
    \ arr)) 1 0)))]))])\n    (aux arr 0)))\n", "  (let loop ([arr arr] [count 0])\n\
    \    (cond [(empty? arr) count]\n          [(> (sum-digits (first arr)) 0) (loop\
    \ (rest arr) (+ count 1))]\n          [else (loop (rest arr) count)])))\n", " \
    \ (define (sum-digits n)\n    (cond\n      [(> n 0) (+ (modulo n 10) (sum-digits\
    \ (quotient n 10)))]\n      [(= n 0) 0]\n      [else (+ (- n) (sum-digits (- n)))]))\n\
    \n  (define (iter xs count)\n    (cond\n      [(null? xs) count]\n      [(> (sum-digits\
    \ (car xs)) 0) (iter (cdr xs) (+ count 1))]\n      [else (iter (cdr xs) count)]))\n\
    \n  (iter arr 0))", "  (cond\n    [(empty? arr) 0]\n    [else\n     (if (> (sum_digits\
    \ (first arr)) 0)\n         (+ 1 (count_nums (rest arr)))\n         (count_nums\
    \ (rest arr)))]))\n", "    (cond\n        [(empty? arr) 0]\n        [else\n  \
    \          (if (> (apply + (map abs (digits (car arr)))) 0)\n                (+\
    \ 1 (count_nums (cdr arr)))\n                (count_nums (cdr arr)))]))\n", " \
    \ (cond\n    [(empty? arr) 0]\n    [(&gt; (abs (first arr)) 9) (count_nums (rest\
    \ arr))]\n    [else (+ 1 (count_nums (rest arr)))]))\n", "  (cond\n    [(empty?\
    \ arr) 0]\n    [else\n     (cond\n       [(sum-digits (first arr))\n        (+\
    \ 1 (count_nums (rest arr)))]\n       [else\n        (count_nums (rest arr))])]))\n",
  "  (if (empty? arr)\n      0\n      (+ 1 (count_nums (cdr arr)))))", "  (if (null?\
    \ arr)\n      0\n      (+ (if (> (abs (car arr)) 9)\n             0\n        \
    \     1)\n         (count_nums (cdr arr)))))\n", "  (cond [(null? arr) 0]\n  \
    \      [else (+ (if (> (+ (remainder (abs (car arr)) 10)\n                   \
    \       (remainder (abs (car (cdr arr))) 10))\n                      0)\n    \
    \                1\n                    0)\n                  (count_nums (cdr\
    \ arr)))]))\n", "  (cond\n    [(empty? arr) 0]\n    [else\n     (if (> (foldl\
    \ + 0 (abs (number->list (car arr)))) 0)\n         (+ 1 (count_nums (cdr arr)))\n\
    \         (count_nums (cdr arr)))]))\n", "  (if (null? arr)\n      0\n      (+\
    \ (if (> (apply + (map abs (map string->number (string-split (number->string (car\
    \ arr)) #\\)))) 0) 1 0)\n         (count_nums (cdr arr)))))", "  (cond\n    [(empty?\
    \ arr) 0]\n    [else\n     (define (sum_digits n)\n       (cond\n         [(<\
    \ n 0) (- n)]\n         [(> n 0) (+ (remainder n 10) (sum_digits (quotient n 10)))]\n\
    \         [else 0]))\n     (if (> (sum_digits (first arr)) 0)\n         (+ 1 (count_nums\
    \ (rest arr)))\n         (count_nums (rest arr)))]))\n", "  (apply + (map (lambda\
    \ (num)\n                  (if (not (zero? num))\n                      (if (negative?\
    \ num)\n                          (- num (/ num (expt 10 (floor (log10 (abs num))))))\n\
    \                        (let loop ((num num) (sum 0))\n                     \
    \     (if (zero? num)\n                              sum\n                   \
    \           (loop (/ num 10) (+ sum (% num 10))))))\n                      0))\n\
    \                arr)))", "  (cond\n    [(empty? arr) 0]\n    [else (+ (is_num_gt_0?\
    \ (first arr)) (count_nums (rest arr)))]))\n", "  (if (empty? arr)\n      0\n\
    \      (+ (if (> (+ (abs (first arr)) (abs (modulo (first arr) 10))) 0) 1 0)\n\
    \         (count_nums (rest arr)))))\n```\n\n# Problem 3 (optional): \nWrite a\
    \ function called `join_lists` which takes an arbitrarily long list of lists and\
    \ returns a single list that is the concatenation of all of the given lists. Write\
    \ an alternate function called `join_lists_2` using `append` or `append!`. Try\
    \ to implement these two functions in point-free style.\n\n```racket\n#lang racket\n",
  "  (foldl + 0\n         (map (\u03BB (n)\n                (if (> (sum-digits n)\
    \ 0)\n                    1\n                    0))\n              arr)))\n",
  "  (match arr\n    [(list) 0]\n    [(list first rest ...)\n     (cond [(> (abs first)\
    \ 0) (add1 (count_nums rest))]\n           [else (count_nums rest)])]))\n", " \
    \ (cond\n    [(empty? arr) 0]\n    [else (+ (has-digits-sum? (first arr)) (count_nums\
    \ (rest arr)))]))\n", "  (define (count n)\n    (if (negative? n)\n        (if\
    \ (= n -1)\n            1\n            (+ 1 (count (+ n 1))))\n        (if (=\
    \ n 0)\n            0\n            (+ (remainder n 10) (count (quotient n 10))))))\n\
    \  (cond ((null? arr) 0)\n        ((< (count (car arr)) 1) (count_nums (cdr arr)))\n\
    \        (else (+ 1 (count_nums (cdr arr))))))", "  (foldl (lambda (elt acc)\n\
    \           (if (and (not (integer? elt))\n                    (not (negative?\
    \ elt)))\n               acc\n               (+ acc (abs (sum_of_digits elt)))))\n\
    \         0\n         arr))\n", "  (cond [(empty? arr) 0]\n        [else\n   \
    \      (if (> (sum_of_abs_digits (first arr)) 0)\n             (+ 1 (count_nums\
    \ (rest arr)))\n             (count_nums (rest arr)))]))\n", "  (apply + (map\
    \ (lambda (x)\n                  (if (> (apply + (map (lambda (x) (abs x)) (string->list\
    \ (number->string x)))) 0)\n                      1\n                      0))\n\
    \                arr)))\n", "  (cond [(null? arr) 0]\n        [else (+ (if (>\
    \ (sum-digits (car arr)) 0) 1 0)\n                 (count_nums (cdr arr)))]))\n",
  "  (cond\n    [(empty? arr) 0]\n    [else (+ (count_nums (rest arr))\n         \
    \    (if (> (+ (abs (first arr))\n                       (abs (remainder (first\
    \ arr) 10)))\n                  0)\n                 1\n                 0))]))\n\
    </code>\nThis solution is quite simple, using recursion and a <code>if</code>\
    \ check. This returns 1 where it should. However, when I run this using <code>check-expect</code>,\
    \ all my tests fail. Why?\n<code>#lang racket\n", "  (define (sum_digits n)\n\
    \    (if (= n 0)\n        0\n        (+ (modulo n 10) (sum_digits (quotient n\
    \ 10)))))\n  (let count_nums_iter ((arr arr) (count 0))\n    (if (null? arr)\n\
    \        count\n        (if (< (sum_digits (car arr)) 0)\n            (count_nums_iter\
    \ (cdr arr) (+ count 1))\n            (count_nums_iter (cdr arr) count)))))\n",
  "  (cond\n    [(null? arr) 0]\n    [else\n     (let ([sum (apply + (for/list ([digit\
    \ (in-list (string->list (number->string (abs (car arr)))))]\n               \
    \                     #:when (number? digit))\n                          (- (char->integer\
    \ digit) (char->integer #\\0))))])\n       (+ (if (> sum 0) 1 0) (count_nums (cdr\
    \ arr))))]))\n", "  (length (filter (lambda (x) (> (sum_digits x) 0)) arr)))\n",
  "    (for/fold ([total 0]) ([i arr])\n        (if (&gt; (sum_digits i) 0)\n    \
    \        (add1 total)\n            total)))\n", "  (cond\n    [(empty? arr) 0]\n\
    \    [else (+ (if (> (sum_digits (first arr)) 0) 1 0)\n              (count_nums\
    \ (rest arr)))]))\n", "  (count-where (\u03BB (x) (> (sum_digits x) 0)) arr))\n",
  "  (length (filter (lambda (e) (sum_digits e) > 0) arr)))\n", "    (length (filter\
    \ (lambda (x) (> (count-digits x) 0)) arr)))\n", "  (length (list-of-positive-digit-sums\
    \ arr)))\n", "  (cond [(null? arr) 0]\n        [else (if (sum_digits (car arr))\n\
    \                  (+ 1 (count_nums (cdr arr)))\n                  (count_nums\
    \ (cdr arr)))]))\n", "  (if (not (empty? arr))\n      (if (< (sum_digits (first\
    \ arr)) 0)\n          (count_nums (rest arr))\n          (+ 1 (count_nums (rest\
    \ arr))))\n      0))\n", "  (let loop ([num -1] [numbers arr] [count 0])\n   \
    \ (if (empty? numbers)\n        count\n        (if (> (sum_abs_digits (car numbers))\
    \ 0)\n            (loop (cdr numbers) (+ count 1))\n            (loop (cdr numbers)\
    \ count)))))\n", "  (apply + (map sum_digits arr)))\n", "  (if (empty? arr)\n\
    \      0\n      (+ (if (sum-of-digits (car arr)) 1 0)\n         (count_nums (cdr\
    \ arr)))))\n", "  (cond\n    [(empty? arr) 0]\n    [else\n     (cond\n       [(>\
    \ (sum-of-digits (first arr)) 0)\n        (+ 1 (count_nums (rest arr)))]\n   \
    \    [else\n        (count_nums (rest arr))])]))\n", "  (define (sum-digits n)\n\
    \    (cond ((< n 0) (- n))\n          ((< n 10) n)\n          (else (+ (modulo\
    \ n 10) (sum-digits (quotient n 10))))))\n  (cond ((null? arr) 0)\n        ((>\
    \ (sum-digits (car arr)) 0)\n         (+ 1 (count_nums (cdr arr))))\n        (else\
    \ (count_nums (cdr arr)))))\n", "  (cond\n    [(empty? arr) 0]\n    [else\n  \
    \   (if (> (apply + (map abs (map (\u03BB (d)\n                              \
    \       (cond\n                                       [(= 0 d) 0]\n          \
    \                             [(= #\\- d) -1]\n                              \
    \         [else d]))\n                                   (string->list (number->string\
    \ (car arr))))))\n            0)\n         (+ 1 (count_nums (cdr arr)))\n    \
    \     (count_nums (cdr arr)))]))\n```\n\n### Racket\n```#lang racket\n", "  (length\
    \ (filter (lambda (x) (not (zero? (sum_digits x)))) arr)))\n", "  (if (null? arr)\n\
    \      0\n      (+ (has-sum-of-digits? (car arr))\n         (count_nums (cdr arr)))))\n",
  "  (if (null? arr)\n      0\n      (+ (if (not (zero? (sum-digits (car arr)))) 1\
    \ 0)\n         (count_nums (cdr arr)))))\n", "  (cond\n    [(empty? arr) 0]\n\
    \    [else\n     (if (> (sum_digits (car arr)) 0)\n         (+ 1 (count_nums (cdr\
    \ arr)))\n         (count_nums (cdr arr)))]))\n", "  (define (count_nums-inner\
    \ arr count)\n    (if (empty? arr)\n        count\n        (if (> (sum-digits\
    \ (first arr)) 0)\n            (count_nums-inner (rest arr) (+ count 1))\n   \
    \         (count_nums-inner (rest arr) count))))\n  (count_nums-inner arr 0))\n",
  "  (length (filter (lambda (x) (> (sum-digits x) 0)) arr)))\n", "  (cond [(null?\
    \ arr) 0]\n        [else\n         (if (> (+ (abs (quotient (car arr) 10)) (remainder\
    \ (car arr) 10)) 0)\n             (+ 1 (count_nums (cdr arr)))\n             (count_nums\
    \ (cdr arr)))]))", "  (cond ((null? arr) 0)\n        ((> (apply + (map abs (number->list\
    \ (car arr)))) 0)\n         (+ 1 (count_nums (cdr arr))))\n        (else (count_nums\
    \ (cdr arr)))))\n", "  (let ((accum 0))\n    (for ([elem arr])\n      (if (and\
    \ (not (zero? elem)) (> (abs elem) 9))\n          (let ((single-digits (string->list\
    \ (number->string (abs elem)))))\n            (let loop ((single-digits single-digits)\
    \ (accum 0))\n              (if (null? single-digits)\n                  (if (not\
    \ (zero? accum))\n                      (set! accum (+ accum 1))\n           \
    \           accum)\n                  (loop (cdr single-digits) (+ accum (string->number\
    \ (car single-digits)))))))\n          (if (not (zero? elem))\n              (set!\
    \ accum (+ accum 1))\n              accum)))\n    accum))", "  (foldl (lambda\
    \ (x y)\n           (if (sum_digits x)\n               (+ y 1)\n             \
    \  y))\n         0\n         arr))\n", "  (define (sum-digits x)\n    (if (negative?\
    \ x)\n        (add1 (sum-digits (abs x)))\n        (cond\n          [(zero? x)\
    \ 0]\n          [else (+ (remainder x 10) (sum-digits (quotient x 10)))])))\n\
    \  (define (count_nums-helper arr accum)\n    (cond\n      [(empty? arr) accum]\n\
    \      [(> (sum-digits (first arr)) 0) (count_nums-helper (rest arr) (add1 accum))]\n\
    \      [else (count_nums-helper (rest arr) accum)]))\n  (count_nums-helper arr\
    \ 0))\n", "  (count-positive? arr))\n", "  (length (filter (lambda (x)\n     \
    \               (and (> x 0)\n                         (> (sum-digits x) 0)))\n\
    \                  arr)))\n", "  (cond\n    [(null? arr) 0]\n    [else\n     (cond\n\
    \       [(> (sum_digits (abs (car arr))) 0) (+ 1 (count_nums (cdr arr)))]\n  \
    \     [else (count_nums (cdr arr))])]))\n", "  (define (inner arr n)\n    (cond\
    \ [(empty? arr) n]\n          [(> (+ (abs (car arr))\n                 (abs (remainder\
    \ (car arr) 10)))\n             0)\n           (inner (cdr arr) (+ n 1))]\n  \
    \        [else (inner (cdr arr) n)]))\n  (inner arr 0))", "  (count (filter (lambda\
    \ (x) (> (sum_digits x) 0)) arr)))\n", "  (cond\n    [(empty? arr) 0]\n    [(&gt;\
    \ (sum-digits (first arr)) 0)\n     (+ 1 (count_nums (rest arr)))]\n    [else\
    \ (count_nums (rest arr))]))\n", "  (count (lambda (x) (> (+ (abs (quotient x\
    \ 10)) (remainder x 10)) 0)) arr))\n", "  (count-if (\u03BB (x) (not (zero? (sig-digits\
    \ x)))) arr))\n", "  (if (empty? arr)\n      0\n      (+ (if (odd? (sum_digits\
    \ (car arr))) 1 0)\n         (count_nums (cdr arr)))))\n", "  (for/sum ([i arr]\
    \ #:when (> (sum_digits i) 0))\n    1))\n", "  (if (empty? arr)\n      0\n   \
    \   (+ 1 (count_nums (cdr arr)))))\n", "  (cond\n    [(null? arr) 0]\n    [(&gt;\
    \ (sum-digits (car arr)) 0) (+ 1 (count_nums (cdr arr)))]\n    [else (count_nums\
    \ (cdr arr))]))\n</code>\nI have a sum_digits function and I want to insert it\
    \ as a predicate to the cond statement above. I tried to write one but I got some\
    \ errors. How can I write a sum_digits function and then insert it in the cond\
    \ statement above?\n\n\nA:\n\nYou could use <code>foldl</code> to sum the digits\
    \ for each integer and then use <code>foldl</code> again to sum the values that\
    \ you got from the previous operation.\n<code>(define (sum-digits n)\n  (foldl\
    \ + 0 (map (lambda (n) (remainder n 10)) (iterate (lambda (n) (quotient n 10))\
    \ n))))\n", "  (cond [(empty? arr) 0]\n        [else (+ (count_nums (rest arr))\n\
    \                 (if (positive? (sum-signed-digits (first arr))) 1 0))]))\n",
  "  (length (filter (lambda (x) (> (sum_digits x) 0)) arr)))\n", "    (if (null?\
    \ arr)\n        0\n        (+ 1 (count_nums (cdr arr)))))\n", "  (let ([n (length\
    \ arr)])\n    (if (< n 1)\n        0\n        (+ (if (> (sum_of_digits (abs (vector-ref\
    \ arr 0))) 0) 1 0)\n           (count_nums (vector-copy (vector-ref arr 1)))))))\n",
  "  (define (sign-digit n)\n    (if (>= n 0)\n        n\n        (- n)))\n  (if (null?\
    \ arr)\n      0\n      (+ (if (> (apply + (map sign-digit (integer->list (car\
    \ arr)))) 0)\n             1\n             0)\n         (count_nums (cdr arr)))))\n",
  "  (cond ((null? arr) 0)\n        ((<= (sum_of_digits (car arr)) 0)\n         (count_nums\
    \ (cdr arr)))\n        (else (+ 1 (count_nums (cdr arr))))))\n", "  (count (compose\
    \ abs sum) arr))\n", "  (cond\n    ((null? arr) 0)\n    ((> (apply + (map abs\
    \ (digits (car arr)))) 0)\n     (+ 1 (count_nums (cdr arr))))\n    (else (count_nums\
    \ (cdr arr)))))\n", "  (if (null? arr)\n      0\n      (+ (if (sum_digits (abs\
    \ (car arr))) 1 0)\n         (count_nums (cdr arr)))))\n", "  (let loop ([arr\
    \ arr] [res 0])\n    (cond\n      [(empty? arr) res]\n      [(> (abs (car arr))\
    \ 0) (loop (cdr arr) (+ res 1))]\n      [else (loop (cdr arr) res)])))\n", " \
    \ (cond\n    [(empty? arr) 0]\n    [else\n     (let ([sign (first arr)])\n   \
    \    (if (> sign 0) 1 -1))]))\n", "  (count-if\n   (lambda (x)\n     (not (zero?\
    \ (sum-digits x))))\n   arr))\n", "  (if (empty? arr)\n      0\n      (+ (if (>\
    \ (abs (car arr)) 9)\n             (if (> (car arr) 0)\n                 1\n \
    \                (- 1))\n             0)\n         (count_nums (cdr arr)))))\n",
  "  (if (null? arr)\n      0\n      (+ (if (positive? (sum-digits (car arr))) 1 0)\n\
    \         (count_nums (cdr arr)))))\n", "  (cond [(empty? arr) 0]\n        [else\
    \ (+ (sum_digits (first arr))\n                 (count_nums (rest arr)))]))\n",
  "  (if (empty? arr)\n      0\n      (+ 1 (count_nums (cdr arr)))))\n", "  (cond\
    \ [(empty? arr) 0]\n        [else (+ (pos-sum? (first arr)) (count_nums (rest\
    \ arr)))]))\n", "  (if (null? arr)\n      0\n      (+ (if (<= (sum-digits (abs\
    \ (car arr))) 0)\n\t     0\n\t     1)\n\t (count_nums (cdr arr)))))\n", "  (define\
    \ (sum_nums arr)\n    (cond ((null? arr) 0)\n          ((< (car arr) 0) (+ (abs\
    \ (car arr)) (sum_nums (cdr arr))))\n          (else (+ (car arr) (sum_nums (cdr\
    \ arr))))))\n  (cond ((null? arr) 0)\n        ((= (sum_nums (list (car arr)))\
    \ 0) (count_nums (cdr arr)))\n        (else (+ 1 (count_nums (cdr arr))))))\n",
  "  (if (not (list? arr))\n      (error \"bad arr\")\n      (apply + (map (lambda\
    \ (num)\n                      (if (> (sum_digits num) 0)\n                  \
    \        1\n                          0))\n                    arr))))\n", " \
    \ (cond [(null? arr) 0]\n        [else (+ (count_nums (cdr arr))\n           \
    \      (cond [(> (sum-of-digits (car arr)) 0) 1]\n                       [else\
    \ 0]))]))\n", "  (cond [(empty? arr) 0]\n        [else\n         (if (> (sum_digits\
    \ (first arr)) 0)\n             (+ 1 (count_nums (rest arr)))\n             (count_nums\
    \ (rest arr)))]))\n", "  (cond ((empty? arr) 0)\n        ((&gt; (abs (car arr))\
    \ 0) (add1 (count_nums (cdr arr))))\n        (else (count_nums (cdr arr)))))\n",
  "  (define (signed-first-digit n)\n    (if (negative? n)\n        (+ (- n (quotient\
    \ n 10)) -1)\n        (quotient n 10)))\n  (define (signed-sum-digits n)\n   \
    \ (if (negative? n)\n        (- (sum-digits n) (signed-first-digit n))\n     \
    \   (sum-digits n)))\n  (define (count arr acc)\n    (if (null? arr)\n       \
    \ acc\n        (if (positive? (signed-sum-digits (car arr)))\n            (count\
    \ (cdr arr) (+ acc 1))\n            (count (cdr arr) acc))))\n  (count arr 0))\n",
  "  (define (sum_digits i)\n    (cond\n      [(zero? i) 0]\n      [else (+ (modulo\
    \ i 10) (sum_digits (quotient i 10)))]))\n  (cond\n    [(null? arr) 0]\n    [(zero?\
    \ (sum_digits (car arr))) (count_nums (cdr arr))]\n    [else (+ 1 (count_nums\
    \ (cdr arr)))]))\n", "  (foldl (lambda (x acc)\n           (if (&gt; (+ (sgn x)\
    \ (abs (quotient x 10)) (abs (modulo x 10))) 0)\n               (+ acc 1)\n  \
    \             acc))\n         0\n         arr))\n</code>\n", "  (cond\n    [(empty?\
    \ arr) 0]\n    [else\n     (if (> (sum-of-digits (first arr)) 0)\n         (+\
    \ 1 (count_nums (rest arr)))\n         (count_nums (rest arr)))]))\n", "  (cond\n\
    \    [(empty? arr) 0]\n    [(&gt;= (sum_digits (first arr)) 0) (+ 1 (count_nums\
    \ (rest arr)))]\n    [else (count_nums (rest arr))]))\n", "  (if (null? arr)\n\
    \      0\n      (+ (if (> (+ (abs (remainder (car arr) 10))\n                \
    \ (abs (remainder (quotient (car arr) 10) 10))\n                 (abs (quotient\
    \ (car arr) 100)))\n              0)\n            1\n            0)\n        \
    \ (count_nums (cdr arr)))))\n", "  (length (filter (lambda (x) (> (abs (sum-digits\
    \ x)) 0)) arr)))\n", "  (define (sum x)\n    (if (zero? x)\n        0\n      \
    \  (+ (modulo x 10) (sum (quotient x 10)))))\n  (define (count x)\n    (if (null?\
    \ x)\n        0\n        (+ (if (< (sum (abs (car x))) 0) 0 1) (count (cdr x)))))\n\
    \  (count arr))", "  (define (sum_digits n)\n    (define (abs n)\n      (if (<\
    \ n 0) (- n) n))\n    (define (sum_digits_helper n acc)\n      (if (zero? n)\n\
    \          acc\n          (sum_digits_helper (quotient n 10) (+ acc (modulo n\
    \ 10)))))\n    (sum_digits_helper (abs n) 0))\n  (define (count_nums_helper arr\
    \ cnt)\n    (if (null? arr)\n        cnt\n        (if (> (sum_digits (car arr))\
    \ 0)\n            (count_nums_helper (cdr arr) (+ cnt 1))\n            (count_nums_helper\
    \ (cdr arr) cnt))))\n  (count_nums_helper arr 0))\n", "  (cond\n    [(empty? arr)\
    \ 0]\n    [else\n     (cond\n       [(positive? (car arr))\n        (+ 1 (count_nums\
    \ (cdr arr)))]\n       [(negative? (car arr))\n        (+ 1 (count_nums (cdr arr)))]\n\
    \       [else\n        (count_nums (cdr arr))])]))\n", "  (define (abs x)\n  \
    \  (if (< x 0) (- x) x))\n  (define (signed-digits n)\n    (if (< n 0)\n     \
    \   (cons (- n) (signed-digits (- n)))\n        (if (= n 0) '() (cons n (signed-digits\
    \ (/ n 10))))))\n  (define (sum-digits ns)\n    (if (null? ns) 0 (+ (car ns) (sum-digits\
    \ (cdr ns)))))\n  (define (signed-digits-sum n)\n    (sum-digits (signed-digits\
    \ n)))\n  (define (count_nums-it acc rest)\n    (if (null? rest) acc\n       \
    \ (if (< (signed-digits-sum (car rest)) 0)\n            (count_nums-it acc (cdr\
    \ rest))\n            (count_nums-it (+ acc 1) (cdr rest)))))\n  (count_nums-it\
    \ 0 arr))\n", "  (letrec ([digit-sum (lambda (i)\n                        (if\
    \ (and (integer? i) (not (= i 0)))\n                            (+ (modulo i 10)\
    \ (digit-sum (quotient i 10)))\n                            0))]\n           [sum-gt-0?\
    \ (lambda (i)\n                        (> (digit-sum i) 0))])\n    (length (filter\
    \ sum-gt-0? arr))))\n```\n\n```\n#lang racket\n", "  (cond\n    ((null? arr) 0)\n\
    \    ((> (abs (first arr)) 0)\n      (+ 1 (count_nums (rest arr))))\n    (else\
    \ (count_nums (rest arr)))))\n```", "  (count\n   (map (\u03BB (x) (if (positive?\
    \ x) 1 0))\n        (map (\u03BB (x) (apply + (map string->number (string-&gt;list\
    \ (number-&gt;string x)))))\n             arr))))\n</code>\nWhat is the better\
    \ way to write this function?\n\n\nA:\n\nMy first reaction was:\n<code>(define\
    \ (count_nums arr)\n  (apply + (map string-&gt;number (string-&gt;list (number-&gt;string\
    \ (apply + arr))))))\n</code>\nbut now that I read the problem more carefully,\
    \ that doesn't work.\nFirst thing I thought of:\n<code>(define (count_nums arr)\n\
    \  (apply + (map (\u03BB (x)\n                  (apply + (map string-&gt;number\
    \ (string-&gt;list (number-&gt;string x)))))\n                arr)))\n</code>\n\
    There's got to be a better way. (I'm sure there's a simpler way to convert an\
    \ integer to a list of single-digit integers, but I don't know it.)\n", "  (let\
    \ loop ([arr arr] [count 0])\n    (cond\n      [(empty? arr) count]\n      [(>\
    \ (apply + (signed-digits (first arr))) 0) (loop (rest arr) (+ count 1))]\n  \
    \    [else (loop (rest arr) count)])))\n", "  (length (filter (lambda (e) (> (abs\
    \ e) 0)) arr)))\n", "  (define (sign v)\n    (if (< v 0) -1 1))\n  (define (digits\
    \ v)\n    (if (<= v 0) null\n        (cons (modulo v 10) (digits (quotient v 10)))))\n\
    \  (define (sum ds)\n    (cond ((null? ds) 0)\n          (else (+ (car ds) (sum\
    \ (cdr ds))))))\n  (define (not-zero? v)\n    (> (sum (digits (sign v) v)) 0))\n\
    \  (define (filter f l)\n    (cond ((null? l) null)\n          ((f (car l)) (cons\
    \ (car l) (filter f (cdr l))))\n          (else (filter f (cdr l)))))\n  (length\
    \ (filter not-zero? arr)))\n", "  (cond [(empty? arr) 0]\n        [else (+ (sign_digits_sum\
    \ (first arr))\n                 (count_nums (rest arr)))]))\n", "  (for/sum ([n\
    \ arr])\n    (if (apply + (map abs (string->list (number->string n))))\n     \
    \   1\n        0)))", "  (cond\n    [(empty? arr) 0]\n    [else\n     (if (> (sum_digits\
    \ (first arr)) 0)\n         (+ 1 (count_nums (rest arr)))\n         (count_nums\
    \ (rest arr)))]))\n", "  (cond ((null? arr) 0)\n        ((&gt; (sum_digits (car\
    \ arr)) 0) (+ 1 (count_nums (cdr arr))))\n        (else (count_nums (cdr arr)))))\n",
  "  (cond [(empty? arr) 0]\n        [else\n         (if (positive? (sum_digits (car\
    \ arr)))\n             (+ 1 (count_nums (cdr arr)))\n             (count_nums\
    \ (cdr arr)))]))\n", "  (length (filter (lambda (x) (> (+ (abs (remainder x 10))\n\
    \                                     (abs (remainder (quotient x 10) 10))\n \
    \                                    (abs (quotient x 100)))\n               \
    \                   0))\n                   arr)))\n", "  (define (count_nums-helper\
    \ arr count)\n    (cond [(null? arr) count]\n          [(> (+ (abs (car arr))\n\
    \                 (abs (modulo (car arr) 10))\n                 (abs (modulo (/\
    \ (car arr) 10) 10))\n                 (abs (modulo (/ (car arr) 100) 10))) 0)\n\
    \           (count_nums-helper (cdr arr) (+ count 1))]\n          [else (count_nums-helper\
    \ (cdr arr) count)]))\n  (count_nums-helper arr 0))", "  (cond\n    [(empty? arr)\
    \ 0]\n    [else\n     (define (sum-digits a)\n       (if (negative? a)\n     \
    \      (apply + (abs a))\n           (apply + a)))\n     (cond\n       [(> (sum-digits\
    \ (first arr)) 0)\n        (+ 1 (count_nums (rest arr)))]\n       [else\n    \
    \    (count_nums (rest arr))])]))", "  (length (filter (lambda (n) (> (apply +\
    \ (map abs (digits n))) 0)) arr)))\n", "  (if (null? arr)\n      0\n      (+ (if\
    \ (> (sum_of_digits (car arr)) 0) 1 0)\n         (count_nums (cdr arr)))))\n",
  "  (count-if (lambda (x) (sum-digits x)) arr))\n", "  (accumulate + 0 (map (\u03BB\
    \ (x) (if (positive? (sum_digits x)) 1 0)) arr)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
