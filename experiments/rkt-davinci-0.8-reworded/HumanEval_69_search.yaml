name: HumanEval_69_search
language: rkt
prompt: "#lang racket\n\n;; You are given a non-empty list of positive integers. Return\
  \ the greatest integer that is greater than \n;; zero, and has a frequency greater\
  \ than or equal to the value of the integer itself. \n;; The frequency of an integer\
  \ is the number of times it appears in the list.\n;; If no such a value exist, return\
  \ -1.\n;; Examples:\n;; >>> (search (list 4 1 2 2 3 1))\n;; 2\n;; >>> (search (list\
  \ 1 2 2 3 3 3 4 4 4))\n;; 3\n;; >>> (search (list 5 5 4 4 4))\n;; -1\n(define (search\
  \ lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate search))\n\
  \    (check-equal? (candidate (list 5 5 5 5 1)) 1)\n    (check-equal? (candidate\
  \ (list 4 1 4 1 4 4)) 4)\n    (check-equal? (candidate (list 3 3)) -1)\n    (check-equal?\
  \ (candidate (list 8 8 8 8 8 8 8 8)) 8)\n    (check-equal? (candidate (list 2 3\
  \ 3 2 2)) 2)\n    (check-equal? (candidate (list 2 7 8 8 4 8 7 3 9 6 5 10 4 3 6\
  \ 7 1 7 4 10 8 1)) 1)\n    (check-equal? (candidate (list 3 2 8 2)) 2)\n    (check-equal?\
  \ (candidate (list 6 7 1 8 8 10 5 8 5 3 10)) 1)\n    (check-equal? (candidate (list\
  \ 8 8 3 6 5 6 4)) -1)\n    (check-equal? (candidate (list 6 9 6 7 1 4 7 1 8 8 9\
  \ 8 10 10 8 4 10 4 10 1 2 9 5 7 9)) 1)\n    (check-equal? (candidate (list 1 9 10\
  \ 1 3)) 1)\n    (check-equal? (candidate (list 6 9 7 5 8 7 5 3 7 5 10 10 3 6 10\
  \ 2 8 6 5 4 9 5 3 10)) 5)\n    (check-equal? (candidate (list 1)) 1)\n    (check-equal?\
  \ (candidate (list 8 8 10 6 4 3 5 8 2 4 2 8 4 6 10 4 2 1 10 2 1 1 5)) 4)\n    (check-equal?\
  \ (candidate (list 2 10 4 8 2 10 5 1 2 9 5 5 6 3 8 6 4 10)) 2)\n    (check-equal?\
  \ (candidate (list 1 6 10 1 6 9 10 8 6 8 7 3)) 1)\n    (check-equal? (candidate\
  \ (list 9 2 4 1 5 1 5 2 5 7 7 7 3 10 1 5 4 2 8 4 1 9 10 7 10 2 8 10 9 4)) 4)\n \
  \   (check-equal? (candidate (list 2 6 4 2 8 7 5 6 4 10 4 6 3 7 8 8 3 1 4 2 2 10\
  \ 7)) 4)\n    (check-equal? (candidate (list 9 8 6 10 2 6 10 2 7 8 10 3 8 2 6 2\
  \ 3 1)) 2)\n    (check-equal? (candidate (list 5 5 3 9 5 6 3 2 8 5 6 10 10 6 8 4\
  \ 10 7 7 10 8)) -1)\n    (check-equal? (candidate (list 10)) -1)\n    (check-equal?\
  \ (candidate (list 9 7 7 2 4 7 2 10 9 7 5 7 2)) 2)\n    (check-equal? (candidate\
  \ (list 5 4 10 2 1 1 10 3 6 1 8)) 1)\n    (check-equal? (candidate (list 7 9 9 9\
  \ 3 4 1 5 9 1 2 1 1 10 7 5 6 7 6 7 7 6)) 1)\n    (check-equal? (candidate (list\
  \ 3 10 10 9 2)) -1)\n))\n\n(test-humaneval)"
completions: ["  (define (greatest-freq lst)\n    (if (null? lst) (list 0 -1)\n  \
    \    (let ((lst (sort (map (lambda (x) (list (length x) (car x))) (group lst))\
    \ <)))\n        (if (>= (car (car lst)) (cadr (car lst))) (car lst) (greatest-freq\
    \ (cdr lst))))))\n  (cadr (greatest-freq lst)))", "  (local [(define frequency-list\
    \ (frequency-helper lst))]\n    (find-greatest frequency-list)))\n", "  ;; A helper\
    \ function that returns a list of pairs (X . Y) with X the integers in lst and\
    \ Y the number of \n  ;; times X appears in lst.\n  (define (freq-lst lst)\n \
    \   (let loop ([lst lst] [lst-of-pairs '()])\n      (cond\n        [(empty? lst)\
    \ lst-of-pairs]\n        [else (define x (first lst))\n          (define freq\
    \ (count x lst))\n          (loop (remove x lst) (cons (cons x freq) lst-of-pairs))])))\n\
    \  ;; A helper function that returns the integer X with the greatest frequency\
    \ in the list of pairs lst\n  (define (best-freq lst)\n    (cond\n      [(empty?\
    \ lst) 0]\n      [else (let loop ([lst lst] [freq-max 0] [freq-max-num 0])\n \
    \              (cond\n                 [(empty? lst) freq-max-num]\n         \
    \        [else (define pair (first lst))\n                   (define x (car pair))\n\
    \                   (define freq (cdr pair))\n                   (if (> freq freq-max)\n\
    \                       (loop (rest lst) freq freq-max-num)\n                \
    \       (loop (rest lst) freq-max freq-max-num))]))]))\n  ;; The main function\n\
    \  (let loop ([lst lst] [freq-lst (freq-lst lst)] [best-num 0])\n    (cond\n \
    \     [(empty? lst) best-num]\n      [else (define x (first lst))\n        (define\
    \ freq (count x lst))\n        (if (>= freq x)\n            (if (> x best-num)\n\
    \                (loop (rest lst) freq-lst x)\n                (loop (rest lst)\
    \ freq-lst best-num))\n            (if (zero? best-num)\n                (loop\
    \ (rest lst) freq-lst (best-freq freq-lst))\n                (loop (rest lst)\
    \ freq-lst best", "  (let ([max-val (- 1 (foldl max 0 lst))])\n    (if (and (in?\
    \ max-val lst) (>= (count max-val lst) max-val))\n      max-val\n      -1)))\n",
  "  (for/fold ([count 0] [max -1]) ([a lst])\n    (match (count (cut list-index=?\
    \ a <>) lst)\n      [(>= a count) (values a a)]\n      [else (values count max)])))\n",
  "  (for/first ([i (in-list lst)]\n              [j (in-list lst)]\n            \
    \  #:when (= i j))\n    i))", "  (define (search-aux lst count max)\n    (cond\
    \ [(null? lst) (if (&gt;= count max) max -1)]\n          [(= count (car lst))\
    \ (search-aux (cdr lst) (add1 count) (car lst))]\n          [else (search-aux\
    \ (cdr lst) 1 (max (car lst) max))]))\n  (search-aux lst 1 0))\n", "  (foldl (lambda\
    \ (x t)\n           (if (&gt; x 0)\n               (let ([c (count x lst)])\n\
    \                 (if (&gt;= x c)\n                     (max x t)\n          \
    \           t))\n               t))\n         -1\n         lst))\n", "  (define\
    \ (frequencies lst)\n    (cond [(empty? lst) empty]\n          [else (cons (list\
    \ (first lst) (count (first lst) lst)) (frequencies (rest lst)))]))\n  (define\
    \ (greatest-frequency lst)\n    (cond [(empty? lst) (list 0)]\n          [(empty?\
    \ (rest lst)) (first lst)]\n          [else (if (> (second (first lst)) (second\
    \ (first (rest lst))))\n                   (first lst)\n                   (greatest-frequency\
    \ (rest lst)))]))\n  (define (greatest-frequency-value lst)\n    (if (empty? lst)\
    \ -1\n        (cond [(= (second (first lst)) (first (first lst))) (first (first\
    \ lst))]\n              [else (greatest-frequency-value (rest lst))])))\n  (greatest-frequency-value\
    \ (greatest-frequency (frequencies lst))))", "  (define (search' lst gt)\n   \
    \ (cond [(null? lst) -1]\n          [(>= (length (filter (lambda (x) (= x (car\
    \ lst))) lst)) (car lst)) (max (car lst) gt)]\n          [else (search' (cdr lst)\
    \ gt)]))\n  (search' lst 0))\n", "  (cond\n    [(empty? lst) -1]\n    [(< (count\
    \ (first lst) lst) (first lst)) (search (rest lst))]\n    [else (first lst)]))",
  "    (if (not (null? lst))\n        (if (&gt;= (length (filter (lambda (x) (= x\
    \ (car lst))) lst)) (car lst))\n            (car lst)\n            (search (cdr\
    \ lst)))\n        -1))\n", "  (let ([freq (frequency lst)]\n        [res -1])\n\
    \    (for ([i (in-list lst)])\n      (when (and (> i 0)\n                 (>=\
    \ i (hash-ref freq i)))\n        (set! res i)))\n    res))\n", "  (define (within\
    \ lst1 num)\n    (cond [(null? lst1) #f]\n          [(= (car lst1) num) #t]\n\
    \          [else (within (cdr lst1) num)]))\n  (cond [(<= (length lst) 0) -1]\n\
    \        [(null? lst) -1]\n        [(within lst (car lst)) (car lst)]\n      \
    \  [else (search (cdr lst))]))\n", "  (let ([grt-freq-grt-0 (for/fold ([greatest\
    \ -1]\n                                   [frequency 0])\n                   \
    \               ([i (in-list lst)])\n                                  (cond \n\
    \                                    [(< i greatest) greatest frequency]\n   \
    \                                 [(> i greatest) i (count i lst)]\n         \
    \                           [(= i greatest) greatest (count i lst)]))])\n    (cond\
    \ \n      [(> (first grt-freq-grt-0) (second grt-freq-grt-0)) -1]\n      [else\
    \ (first grt-freq-grt-0)])))\n```\n\n```racket\n#lang racket\n", "  (letrec ([pairs\
    \ (for/list ([e (in-list lst)])\n                     (let ([count (length (filter\
    \ (\u03BB (x) (= x e)) lst))])\n                       (list e count)))]\n   \
    \        [result (for/first ([e (in-list pairs)] #:when (and (not (= (cadr e)\
    \ 0)) (>= (cadr e) (car e))))\n                     (car e))])\n    (if result\n\
    \        result\n        -1)))", "  ;; add your code here\n  )", "  (define (f\
    \ x)\n    (cond ((= x 0) 0)\n          ((>= (length (filter (lambda (y) (= x y))\
    \ lst)) x) x)\n          (else (f (- x 1)))))\n  (f (length lst)))", "  (cond\
    \ [(empty? lst) -1]\n        [else (let ([freq (frequency (first lst) lst)])\n\
    \                (if (&gt;= (first lst) freq)\n                    (first lst)\n\
    \                    (search (rest lst))))]))\n", "  (define (count x lst)\n \
    \   (cond ((null? lst) 0)\n          ((= x (car lst)) (+ 1 (count x (cdr lst))))\n\
    \          (else (count x (cdr lst)))))\n  (let loop ((temp lst) (m 0))\n    (cond\
    \ ((null? temp) (if (>= m (car lst)) m -1))\n          ((and (>= (count (car temp)\
    \ lst) (car temp))\n                (> (car temp) m)) (loop (cdr temp) (car temp)))\n\
    \          (else (loop (cdr temp) m)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
