name: HumanEval_9_rolling_max
language: rkt
prompt: "#lang racket\n\n;; From a given list of integers, generate a list of rolling\
  \ maximum element found until given moment\n;; in the sequence.\n;; >>> (rolling_max\
  \ (list 1 2 3 2 3 4 2))\n;; (list 1 2 3 3 3 4 4)\n(define (rolling_max numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rolling_max))\n\
  \    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate (list\
  \ 1 2 3 4)) (list 1 2 3 4))\n    (check-equal? (candidate (list 4 3 2 1)) (list\
  \ 4 4 4 4))\n    (check-equal? (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100))\n\
  ))\n\n(test-humaneval)"
completions: ["  (local [(define (rolling-max numbers max)\n            (cond [(empty?\
    \ numbers) '()]\n                  [(&gt; (first numbers) max) (cons (first numbers)\
    \ (rolling-max (rest numbers) (first numbers)))]\n                  [else (cons\
    \ max (rolling-max (rest numbers) max))]))]\n    (rolling-max numbers 0)))\n",
  "  (define (rolling_max-helper numbers maxes)\n    (if (null? numbers)\n       \
    \ (reverse maxes)\n        (rolling_max-helper (cdr numbers)\n               \
    \             (cons (max (car numbers) (car maxes)) maxes))))\n  (rolling_max-helper\
    \ (cdr numbers) (list (car numbers))))\n", "  (define (rolling_max_aux numbers\
    \ current-max answer)\n    (cond [(empty? numbers) answer]\n          [(= (first\
    \ numbers) current-max) (rolling_max_aux (rest numbers) current-max answer)]\n\
    \          [(> (first numbers) current-max) (rolling_max_aux (rest numbers) (first\
    \ numbers) (cons (first numbers) answer))]\n          [else (rolling_max_aux (rest\
    \ numbers) current-max (cons current-max answer))]))\n  (reverse (rolling_max_aux\
    \ numbers (first numbers) (list (first numbers)))))\n", "  (if (null? numbers)\
    \ '()\n      (let loop ([remaining-numbers (cdr numbers)]\n                 [maximum-up-to-this-point\
    \ (car numbers)]\n                 [result (list maximum-up-to-this-point)])\n\
    \        (cond\n          [(null? remaining-numbers) result]\n          [(> (car\
    \ remaining-numbers) maximum-up-to-this-point)\n           (loop (cdr remaining-numbers)\n\
    \                 (car remaining-numbers)\n                 (append result (list\
    \ (car remaining-numbers))))]\n          [else (loop (cdr remaining-numbers)\n\
    \                      maximum-up-to-this-point\n                      (append\
    \ result (list maximum-up-to-this-point)))]))))\n", "  (for/fold ([acc 0])\n \
    \           ([number numbers])\n            (cons (max acc number) acc)))\n",
  "  (define (iter numbers max-elements)\n    (if (null? numbers)\n        max-elements\n\
    \        (iter (cdr numbers)\n              (cons (if (&gt; (car numbers) (car\
    \ max-elements))\n                      (car numbers)\n                      (car\
    \ max-elements))\n                    max-elements))))\n  (if (null? numbers)\n\
    \      numbers\n      (iter (cdr numbers) (list (car numbers)))))\n", "  (define\
    \ (recur numbers acc)\n    (if (null? numbers)\n        acc\n        (let* ([n\
    \ (car numbers)]\n               [m (if (null? acc) n (max n (car acc)))]\n  \
    \             [new-acc (cons m acc)])\n          (recur (cdr numbers) new-acc))))\n\
    \  (reverse (recur numbers '())))\n", "  (if (null? numbers)\n      '()\n    \
    \  (cons (apply max numbers)\n            (rolling_max (cdr numbers)))))\n", " \
    \ (apply max (list)))\n", "  (local ((define (rolling_max_helper numbers acc)\n\
    \            (cond\n              [(empty? numbers) (reverse acc)]\n         \
    \     [(> (first numbers) (first acc)) (rolling_max_helper (rest numbers) (cons\
    \ (first numbers) acc))]\n              [else (rolling_max_helper (rest numbers)\
    \ (cons (first acc) acc))])))\n    (rolling_max_helper numbers (list (first numbers)))))\n",
  "  (if (empty? numbers)\n      (list)\n      (cons (max-of-list numbers)\n     \
    \       (rolling_max (cdr numbers)))))", "    (define (iter current-max nums result)\n\
    \        (if (null? nums)\n            result\n            (let ([next-value (car\
    \ nums)])\n                (iter (max current-max next-value) (cdr nums) (cons\
    \ (max current-max next-value) result)))))\n    (reverse (iter (car numbers) (cdr\
    \ numbers) (list (car numbers)))))\n```\n\n## Racket version\n\n```racket\n#lang\
    \ racket\n", "  (if (null? numbers)\n      '()\n      (cons (max (car numbers)\
    \ (car (rolling_max (cdr numbers))))\n            (rolling_max (cdr numbers)))))\n",
  "  (if (empty? numbers)\n      (list)\n      (cons (foldl max (first numbers) numbers)\n\
    \            (rolling_max (rest numbers)))))\n", "  (if (null? numbers)\n    \
    \  '()\n      (cons (max (car numbers) (car (rolling_max (cdr numbers))))\n  \
    \          (rolling_max (cdr numbers)))))\n", "  (cond\n    [(empty? numbers)\
    \ empty]\n    [(equal? 1 (length numbers)) numbers]\n    [else\n     (cons (max\
    \ (first numbers) (second numbers))\n           (rolling_max (rest numbers)))]))\n",
  "  (local [(define (rolling-max-iter current-max rest_numbers acc)\n           \
    \ (cond [(empty? rest_numbers) (reverse acc)]\n                  [(>= (first rest_numbers)\
    \ current-max)\n                   (rolling-max-iter (first rest_numbers) (rest\
    \ rest_numbers) (cons (first rest_numbers) acc))]\n                  [else (rolling-max-iter\
    \ current-max (rest rest_numbers) (cons current-max acc))]))]\n    (rolling-max-iter\
    \ (first numbers) (rest numbers) (list (first numbers)))))\n", "    (define (iter\
    \ maxes nums)\n      (if (null? nums)\n          maxes\n          (let ((max (if\
    \ (null? maxes) (car nums) (max (car nums) (car maxes)))))\n            (iter\
    \ (cons max maxes) (cdr nums)))))\n    (reverse (iter '() numbers)))\n", "  (if\
    \ (empty? numbers)\n      empty\n      (cons (fold max 0 numbers)\n          \
    \  (rolling_max (rest numbers)))))\n", "  (for/fold ([max (first numbers)])\n\
    \            ([n (in-list (rest numbers))])\n    (if (> n max)\n        n\n  \
    \      max)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
