name: HumanEval_66_digitSum
language: rkt
prompt: "#lang racket\n\n;; Task\n;; Write a function that takes a string as input\
  \ and returns the sum of the upper characters only'\n;; ASCII codes.\n;; Examples:\n\
  ;; >>> (digitSum \"\")\n;; 0\n;; >>> (digitSum \"abAB\")\n;; 131\n;; >>> (digitSum\
  \ \"abcCd\")\n;; 67\n;; >>> (digitSum \"helloE\")\n;; 69\n;; >>> (digitSum \"woArBld\"\
  )\n;; 131\n;; >>> (digitSum \"aAaaaXa\")\n;; 153\n(define (digitSum s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digitSum))\n\
  \    (check-equal? (candidate \"\") 0)\n    (check-equal? (candidate \"abAB\") 131)\n\
  \    (check-equal? (candidate \"abcCd\") 67)\n    (check-equal? (candidate \"helloE\"\
  ) 69)\n    (check-equal? (candidate \"woArBld\") 131)\n    (check-equal? (candidate\
  \ \"aAaaaXa\") 153)\n    (check-equal? (candidate \" How are yOu?\") 151)\n    (check-equal?\
  \ (candidate \"You arE Very Smart\") 327)\n))\n\n(test-humaneval)"
completions: ["  (if (string=? s \"\")\n      0\n      (let\n          ([charVal (string-&gt;number\
    \ (string-&gt;symbol (string-append \"#\\\\\" (string-ref s 0))))])\n        (+\
    \ (if (&gt;= charVal 65)\n               charVal\n               0)\n        \
    \   (digitSum (substring s 1))))))\n</code>\n", "  (for/sum ([c (in-string s)]\n\
    \            #:when (char-upcase? c))\n    (char->integer c)))", "  (local [(define\
    \ (letter? ch)\n            (let [(l 'a)(h 'z)]\n              (and (>= ch l)\
    \ (<= ch h))))\n          (define (digit? ch)\n            (let [(l 0)(h 9)]\n\
    \              (and (>= ch l) (<= ch h))))\n          (define (sum-ch ch)\n  \
    \          (cond [(letter? ch) (+ ch 22)]\n                  [(digit? ch) ch]\n\
    \                  [else 0]))]\n    (apply + (map sum-ch (string->list s)))))",
  "  (define (loop s acc)\n    (cond [(empty? s) acc]\n          [(char-upper-case?\
    \ (first s)) (loop (rest s) (+ acc (char->integer (first s))))]\n          [else\
    \ (loop (rest s) acc)]))\n  (loop s 0))\n", "  (define (upper-char-sum c)\n  \
    \  (cond\n      [(char=? c (char-upcase c)) (char->integer c)]\n      [else 0]))\n\
    \  (apply + (string-map upper-char-sum s)))", "  (define (sum s n)\n    (if (string-empty?\
    \ s)\n        n\n        (let ((c (string-ref s 0)))\n          (if (char-upper-case?\
    \ c)\n              (sum (substring s 1) (+ n c))\n              (sum (substring\
    \ s 1) n)))))\n  (sum s 0))\n", "  (sum (map char->integer\n             (filter\
    \ (lambda (char) (char-upcase char)) s))))\n```\n\n### [String split](https://github.com/Mooophy/Cpp-Primer/tree/master/ch16#exercise-1635)\n\
    \n```racket\n#lang racket\n", "  (accumulate + 0 (map (lambda (x) (if (char-numeric?\
    \ x) (char->integer x) 0)) s)))\n", "  (define (isUpper? c)\n    (and (>= c #\\\
    A) (<= c #\\Z)))\n  (cond\n    [(empty? s) 0]\n    [(isUpper? (first s)) (+ (char->integer\
    \ (first s)) (digitSum (rest s)))]\n    [else (digitSum (rest s))]))\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(and (char-uppercase? (string-ref s 0)) (number? (string-ref\
    \ s 0))) (+ (string-ref s 0) (digitSum (substring s 1)))]\n    [else (digitSum\
    \ (substring s 1))]))", "  (define L (string->list s))\n  (define NIL 0)\n  (define\
    \ len (length L))\n  (cond\n    [(= NIL len) NIL]\n    [(char-upcase? (car L))\
    \ (+ (char->integer (car L)) (digitSum (cdr L)))]\n    [else (digitSum (cdr L))]))\n",
  "  (cond\n    [(empty? s) 0]\n    [(char-numeric? (first s)) (digitSum (rest s))]\n\
    \    [(char-lower-case? (first s)) (digitSum (rest s))]\n    [else (+ (first s)\
    \ (digitSum (rest s)))]))", "  (cond\n    [(string=? s \"\") 0]\n    [else (let\
    \ ([upper-chars (build-list (string-length s) char-&gt;integer)])\n        (let\
    \ ([upper-chars-sum 0])\n          (let ([i 0])\n            (while (&lt; i (string-length\
    \ s))\n              (if (char-upcase? (string-ref s i))\n                  (set!\
    \ upper-chars-sum (+ upper-chars-sum (string-ref s i)))\n                  (set!\
    \ upper-chars-sum (+ upper-chars-sum 0))\n              )\n              (set!\
    \ i (+ i 1))\n            )\n            upper-chars-sum\n          )\n      \
    \  )\n      )\n    ]\n  )\n)\n</code>\nI hope somebody can help me. I know that\
    \ \"char-&integer\" is wrong, but I don't know how to convert the string to the\
    \ corresponding ASCII code.\n\n\nA:\n\nAs Eli Barzilay pointed out, you could\
    \ use <code>char-&gt;integer</code> to convert a character to its ASCII code,\
    \ then you could just add each character's code to the previous one. Here's an\
    \ approach:\n<code>(define (digit-sum s)\n  (cond ((empty? s) 0)\n        (else\
    \ (+ (char-&gt;integer (car s))\n                 (digit-sum (cdr s))))))\n</code>\n\
    Notice that it's a recursive function that's using the helper procedure <code>car</code>\
    \ to get the first character, and <code>cdr</code> to get the rest of the characters;\
    \ also, <code>empty?</code> is a procedure that tests whether a string is empty,\
    \ returning <code>#t</code> or <code>#f</code>.\nFor example:\n<code>(digit-sum\
    \ \"abAB\")\n=&gt; 131\n</code>\n", "  (if (string=? s \"\")\n      0\n      (let*\
    \ ((c (string-ref s 0))\n             (s (substring s 1)))\n        (if (and (>=\
    \ c 65) (<= c 90))\n            (+ (digitSum s) c)\n            (digitSum s)))))\n",
  "  (string-sum (map string-&gt;number (filter (lambda (c) (char-upper-case? c))\
    \ (string-&gt;list s)))))\n", "  (apply +\n         (map (lambda (s)\n       \
    \         (cond ((char-ci=? s #\\a) 1)\n                      ((char-ci=? s #\\\
    b) 2)\n                      ((char-ci=? s #\\c) 3)\n                      ((char-ci=?\
    \ s #\\d) 4)\n                      ((char-ci=? s #\\e) 5)\n                 \
    \     ((char-ci=? s #\\f) 6)\n                      ((char-ci=? s #\\g) 7)\n \
    \                     ((char-ci=? s #\\h) 8)\n                      ((char-ci=?\
    \ s #\\i) 9)\n                      ((char-ci=? s #\\j) 10)\n                \
    \      ((char-ci=? s #\\k) 11)\n                      ((char-ci=? s #\\l) 12)\n\
    \                      ((char-ci=? s #\\m) 13)\n                      ((char-ci=?\
    \ s #\\n) 14)\n                      ((char-ci=? s #\\o) 15)\n               \
    \       ((char-ci=? s #\\p) 16)\n                      ((char-ci=? s #\\q) 17)\n\
    \                      ((char-ci=? s #\\r) 18)\n                      ((char-ci=?\
    \ s #\\s) 19)\n                      ((char-ci=? s #\\t) 20)\n               \
    \       ((char-ci=? s #\\u) 21)\n                      ((char-ci=? s #\\v) 22)\n\
    \                      ((char-ci=? s #\\w) 23)\n                      ((char-ci=?\
    \ s #\\x) 24)\n                      ((char-ci=? s #\\y) 25)\n               \
    \       ((char-ci=? s #\\z) 26)\n                      ((char-ci=? s #\\A) 1)\n\
    \                      ((char-ci=? s #\\B) 2)\n                      ((char-ci=?\
    \ s #\\C) 3)\n                      ((char-ci=? s #\\D) 4)\n                 \
    \     ((char-ci=? s #\\E) 5)\n                      ((char-ci=? s #\\F) 6)\n \
    \                     ((char-ci=? s #\\G) 7)\n", "  (cond [(empty? s) 0]\n   \
    \     [else (+ (char-&gt;integer (car s))\n                 (digitSum (cdr s)))]))\n",
  '  (apply + (map (lambda (c) (if (char-upcase? c) (char->integer c) 0)) s)))', " \
    \ (let loop ((i 0) (sum 0))\n    (cond ((= i (string-length s)) sum)\n       \
    \   ((char-upcase? (string-ref s i)) (loop (+ i 1) (+ sum (char->integer (string-ref\
    \ s i)))))\n          (else (loop (+ i 1) sum)))))\n", "  (cond ((null? s) 0)\n\
    \        ((or (= (char-upcase (car s)) 'A)\n             (= (char-upcase (car\
    \ s)) 'B)\n             (= (char-upcase (car s)) 'C)\n             (= (char-upcase\
    \ (car s)) 'D)\n             (= (char-upcase (car s)) 'E)\n             (= (char-upcase\
    \ (car s)) 'F)\n             (= (char-upcase (car s)) 'G)\n             (= (char-upcase\
    \ (car s)) 'H)\n             (= (char-upcase (car s)) 'I)\n             (= (char-upcase\
    \ (car s)) 'J)\n             (= (char-upcase (car s)) 'K)\n             (= (char-upcase\
    \ (car s)) 'L)\n             (= (char-upcase (car s)) 'M)\n             (= (char-upcase\
    \ (car s)) 'N)\n             (= (char-upcase (car s)) 'O)\n             (= (char-upcase\
    \ (car s)) 'P)\n             (= (char-upcase (car s)) 'Q)\n             (= (char-upcase\
    \ (car s)) 'R)\n             (= (char-upcase (car s)) 'S)\n             (= (char-upcase\
    \ (car s)) 'T)\n             (= (char-upcase (car s)) 'U)\n             (= (char-upcase\
    \ (car s)) 'V)\n             (= (char-upcase (car s)) 'W)\n             (= (char-upcase\
    \ (car s)) 'X)\n             (= (char-upcase (car s)) 'Y)\n             (= (char-upcase\
    \ (car s)) 'Z))\n         (+ (char->integer (car s)) (digitSum (cdr s))))\n  \
    \      (else (digitSum (cdr s)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
