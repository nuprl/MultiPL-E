name: HumanEval_66_digitSum
language: rkt
prompt: "#lang racket\n\n;; Task\n;; Write a function that takes a string as input\
  \ and returns the sum of the upper characters only'\n;; ASCII codes.\n;; Examples:\n\
  ;; >>> (digitSum \"\")\n;; 0\n;; >>> (digitSum \"abAB\")\n;; 131\n;; >>> (digitSum\
  \ \"abcCd\")\n;; 67\n;; >>> (digitSum \"helloE\")\n;; 69\n;; >>> (digitSum \"woArBld\"\
  )\n;; 131\n;; >>> (digitSum \"aAaaaXa\")\n;; 153\n(define (digitSum s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digitSum))\n\
  \    (check-equal? (candidate \"\") 0)\n    (check-equal? (candidate \"abAB\") 131)\n\
  \    (check-equal? (candidate \"abcCd\") 67)\n    (check-equal? (candidate \"helloE\"\
  ) 69)\n    (check-equal? (candidate \"woArBld\") 131)\n    (check-equal? (candidate\
  \ \"aAaaaXa\") 153)\n    (check-equal? (candidate \" How are yOu?\") 151)\n    (check-equal?\
  \ (candidate \"You arE Very Smart\") 327)\n))\n\n(test-humaneval)"
completions: ["  (if (string=? s \"\")\n      0\n      (let\n          ([charVal (string-&gt;number\
    \ (string-&gt;symbol (string-append \"#\\\\\" (string-ref s 0))))])\n        (+\
    \ (if (&gt;= charVal 65)\n               charVal\n               0)\n        \
    \   (digitSum (substring s 1))))))\n</code>\n", "  (for/sum ([c (in-string s)]\n\
    \            #:when (char-upcase? c))\n    (char->integer c)))", "  (local [(define\
    \ (letter? ch)\n            (let [(l 'a)(h 'z)]\n              (and (>= ch l)\
    \ (<= ch h))))\n          (define (digit? ch)\n            (let [(l 0)(h 9)]\n\
    \              (and (>= ch l) (<= ch h))))\n          (define (sum-ch ch)\n  \
    \          (cond [(letter? ch) (+ ch 22)]\n                  [(digit? ch) ch]\n\
    \                  [else 0]))]\n    (apply + (map sum-ch (string->list s)))))",
  "  (define (loop s acc)\n    (cond [(empty? s) acc]\n          [(char-upper-case?\
    \ (first s)) (loop (rest s) (+ acc (char->integer (first s))))]\n          [else\
    \ (loop (rest s) acc)]))\n  (loop s 0))\n", "  (define (upper-char-sum c)\n  \
    \  (cond\n      [(char=? c (char-upcase c)) (char->integer c)]\n      [else 0]))\n\
    \  (apply + (string-map upper-char-sum s)))", "  (define (sum s n)\n    (if (string-empty?\
    \ s)\n        n\n        (let ((c (string-ref s 0)))\n          (if (char-upper-case?\
    \ c)\n              (sum (substring s 1) (+ n c))\n              (sum (substring\
    \ s 1) n)))))\n  (sum s 0))\n", "  (sum (map char->integer\n             (filter\
    \ (lambda (char) (char-upcase char)) s))))\n```\n\n### [String split](https://github.com/Mooophy/Cpp-Primer/tree/master/ch16#exercise-1635)\n\
    \n```racket\n#lang racket\n", "  (accumulate + 0 (map (lambda (x) (if (char-numeric?\
    \ x) (char->integer x) 0)) s)))\n", "  (define (isUpper? c)\n    (and (>= c #\\\
    A) (<= c #\\Z)))\n  (cond\n    [(empty? s) 0]\n    [(isUpper? (first s)) (+ (char->integer\
    \ (first s)) (digitSum (rest s)))]\n    [else (digitSum (rest s))]))\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(and (char-uppercase? (string-ref s 0)) (number? (string-ref\
    \ s 0))) (+ (string-ref s 0) (digitSum (substring s 1)))]\n    [else (digitSum\
    \ (substring s 1))]))", "  (define L (string->list s))\n  (define NIL 0)\n  (define\
    \ len (length L))\n  (cond\n    [(= NIL len) NIL]\n    [(char-upcase? (car L))\
    \ (+ (char->integer (car L)) (digitSum (cdr L)))]\n    [else (digitSum (cdr L))]))\n",
  "  (cond\n    [(empty? s) 0]\n    [(char-numeric? (first s)) (digitSum (rest s))]\n\
    \    [(char-lower-case? (first s)) (digitSum (rest s))]\n    [else (+ (first s)\
    \ (digitSum (rest s)))]))", "  (cond\n    [(string=? s \"\") 0]\n    [else (let\
    \ ([upper-chars (build-list (string-length s) char-&gt;integer)])\n        (let\
    \ ([upper-chars-sum 0])\n          (let ([i 0])\n            (while (&lt; i (string-length\
    \ s))\n              (if (char-upcase? (string-ref s i))\n                  (set!\
    \ upper-chars-sum (+ upper-chars-sum (string-ref s i)))\n                  (set!\
    \ upper-chars-sum (+ upper-chars-sum 0))\n              )\n              (set!\
    \ i (+ i 1))\n            )\n            upper-chars-sum\n          )\n      \
    \  )\n      )\n    ]\n  )\n)\n</code>\nI hope somebody can help me. I know that\
    \ \"char-&integer\" is wrong, but I don't know how to convert the string to the\
    \ corresponding ASCII code.\n\n\nA:\n\nAs Eli Barzilay pointed out, you could\
    \ use <code>char-&gt;integer</code> to convert a character to its ASCII code,\
    \ then you could just add each character's code to the previous one. Here's an\
    \ approach:\n<code>(define (digit-sum s)\n  (cond ((empty? s) 0)\n        (else\
    \ (+ (char-&gt;integer (car s))\n                 (digit-sum (cdr s))))))\n</code>\n\
    Notice that it's a recursive function that's using the helper procedure <code>car</code>\
    \ to get the first character, and <code>cdr</code> to get the rest of the characters;\
    \ also, <code>empty?</code> is a procedure that tests whether a string is empty,\
    \ returning <code>#t</code> or <code>#f</code>.\nFor example:\n<code>(digit-sum\
    \ \"abAB\")\n=&gt; 131\n</code>\n", "  (if (string=? s \"\")\n      0\n      (let*\
    \ ((c (string-ref s 0))\n             (s (substring s 1)))\n        (if (and (>=\
    \ c 65) (<= c 90))\n            (+ (digitSum s) c)\n            (digitSum s)))))\n",
  "  (string-sum (map string-&gt;number (filter (lambda (c) (char-upper-case? c))\
    \ (string-&gt;list s)))))\n", "  (apply +\n         (map (lambda (s)\n       \
    \         (cond ((char-ci=? s #\\a) 1)\n                      ((char-ci=? s #\\\
    b) 2)\n                      ((char-ci=? s #\\c) 3)\n                      ((char-ci=?\
    \ s #\\d) 4)\n                      ((char-ci=? s #\\e) 5)\n                 \
    \     ((char-ci=? s #\\f) 6)\n                      ((char-ci=? s #\\g) 7)\n \
    \                     ((char-ci=? s #\\h) 8)\n                      ((char-ci=?\
    \ s #\\i) 9)\n                      ((char-ci=? s #\\j) 10)\n                \
    \      ((char-ci=? s #\\k) 11)\n                      ((char-ci=? s #\\l) 12)\n\
    \                      ((char-ci=? s #\\m) 13)\n                      ((char-ci=?\
    \ s #\\n) 14)\n                      ((char-ci=? s #\\o) 15)\n               \
    \       ((char-ci=? s #\\p) 16)\n                      ((char-ci=? s #\\q) 17)\n\
    \                      ((char-ci=? s #\\r) 18)\n                      ((char-ci=?\
    \ s #\\s) 19)\n                      ((char-ci=? s #\\t) 20)\n               \
    \       ((char-ci=? s #\\u) 21)\n                      ((char-ci=? s #\\v) 22)\n\
    \                      ((char-ci=? s #\\w) 23)\n                      ((char-ci=?\
    \ s #\\x) 24)\n                      ((char-ci=? s #\\y) 25)\n               \
    \       ((char-ci=? s #\\z) 26)\n                      ((char-ci=? s #\\A) 1)\n\
    \                      ((char-ci=? s #\\B) 2)\n                      ((char-ci=?\
    \ s #\\C) 3)\n                      ((char-ci=? s #\\D) 4)\n                 \
    \     ((char-ci=? s #\\E) 5)\n                      ((char-ci=? s #\\F) 6)\n \
    \                     ((char-ci=? s #\\G) 7)\n", "  (cond [(empty? s) 0]\n   \
    \     [else (+ (char-&gt;integer (car s))\n                 (digitSum (cdr s)))]))\n",
  '  (apply + (map (lambda (c) (if (char-upcase? c) (char->integer c) 0)) s)))', " \
    \ (let loop ((i 0) (sum 0))\n    (cond ((= i (string-length s)) sum)\n       \
    \   ((char-upcase? (string-ref s i)) (loop (+ i 1) (+ sum (char->integer (string-ref\
    \ s i)))))\n          (else (loop (+ i 1) sum)))))\n", "  (cond ((null? s) 0)\n\
    \        ((or (= (char-upcase (car s)) 'A)\n             (= (char-upcase (car\
    \ s)) 'B)\n             (= (char-upcase (car s)) 'C)\n             (= (char-upcase\
    \ (car s)) 'D)\n             (= (char-upcase (car s)) 'E)\n             (= (char-upcase\
    \ (car s)) 'F)\n             (= (char-upcase (car s)) 'G)\n             (= (char-upcase\
    \ (car s)) 'H)\n             (= (char-upcase (car s)) 'I)\n             (= (char-upcase\
    \ (car s)) 'J)\n             (= (char-upcase (car s)) 'K)\n             (= (char-upcase\
    \ (car s)) 'L)\n             (= (char-upcase (car s)) 'M)\n             (= (char-upcase\
    \ (car s)) 'N)\n             (= (char-upcase (car s)) 'O)\n             (= (char-upcase\
    \ (car s)) 'P)\n             (= (char-upcase (car s)) 'Q)\n             (= (char-upcase\
    \ (car s)) 'R)\n             (= (char-upcase (car s)) 'S)\n             (= (char-upcase\
    \ (car s)) 'T)\n             (= (char-upcase (car s)) 'U)\n             (= (char-upcase\
    \ (car s)) 'V)\n             (= (char-upcase (car s)) 'W)\n             (= (char-upcase\
    \ (car s)) 'X)\n             (= (char-upcase (car s)) 'Y)\n             (= (char-upcase\
    \ (car s)) 'Z))\n         (+ (char->integer (car s)) (digitSum (cdr s))))\n  \
    \      (else (digitSum (cdr s)))))\n", "  (define (loop s acc)\n    (cond\n  \
    \    [(empty? s) acc]\n      [(char-upcase? (first s)) (loop (rest s) (+ acc (char->integer\
    \ (first s))))]\n      [else (loop (rest s) acc)]))\n  (loop s 0))\n", "  (cond\n\
    \    [(string=? s \"\") 0]\n    [else (+ (char->integer (string-ref s 0)) (digitSum\
    \ (substring s 1 (string-length s))))]))", "  (string-ref s 0))\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(equal? (string-upper-case (string (first s))) (string\
    \ (first s))) (+ (char->integer (first s)) (digitSum (rest s)))]\n    [else (digitSum\
    \ (rest s))]))", "  (apply + (map char->integer (filter char-alphabetic? (map\
    \ char-upcase s)))))\n", "  (define (sum-of-upper-codes s)\n    (cond [(empty?\
    \ s) 0]\n          [(char-upper-case? (first s)) (+ (char->integer (first s))\
    \ (sum-of-upper-codes (rest s)))]\n          [else (sum-of-upper-codes (rest s))]))\n\
    \  (sum-of-upper-codes s))\n", "  (define cs (map char->integer s))\n  (define\
    \ upper-cs (filter (lambda (c) (and (>= c 65) (<= c 90))) cs))\n  (apply + upper-cs))\n",
  "  (string-fold\n   (lambda (c acc)\n     (if (and (>= c #\\A) (<= c #\\Z))\n  \
    \       (+ c acc)\n         acc))\n   0\n   s))", "  (let ([sum 0])\n    (for\
    \ ([c (in-string s)])\n      (cond\n        [(char-upper-case? c)\n         (set!\
    \ sum (+ sum (char->integer c)))]))\n    sum))\n", "  (define (loop acc s)\n \
    \   (cond [(empty? s)\n           acc]\n          [(upper? (first s))\n      \
    \     (loop (+ acc (char->integer (first s))) (rest s))]\n          [else\n  \
    \         (loop acc (rest s))]))\n  (loop 0 s))\n", "  (apply + (map (\u03BB (x)\
    \ (if (char-alphabetic? x) (char->integer x) 0)) s)))\n", "  (let ((acc 0))\n\
    \    (for ((x (string->list s)))\n      (if (char-upper-case? x)\n          (set!\
    \ acc (+ acc (char->integer x)))))\n    acc))\n", "  (apply + (map (lambda (x)\
    \ (if (>= x 65) x 0)) (string->list s))))\n", "  (define (isUpper? c)\n    (and\
    \ (>= c 65) (<= c 90)))\n  (apply + (map (lambda (c)\n                  (if (isUpper?\
    \ c)\n                      c\n                      0))\n                (string->list\
    \ s))))\n```\n\n5. Write a function that takes a string as input and returns the\
    \ sum of the lower characters only'\nASCII codes.\n\n```racket\n#lang racket\n",
  "  (define (inc-if-upper c)\n    (if (char-numeric? c) 0 (+ 1 c)))\n  (apply + (string-&gt;list\
    \ s)))\n", "  (if (string=? s \"\")\n      0\n      (if (char-numeric? (string-ref\
    \ s 0))\n          (+ (char->integer (string-ref s 0)) (digitSum (substring s\
    \ 1)))\n          (digitSum (substring s 1)))))\n", "  (accumulate + 0 (filter\
    \ char-upper-case? (string->list s))))\n", "  (define (sum s)\n    (define (sum-helper\
    \ s acc)\n      (cond ((null? s) acc)\n            ((<= #\\a (string-ref s 0)\
    \ #\\z) (sum-helper (substring s 1) (+ acc (string-ref s 0))))\n            ((<=\
    \ #\\A (string-ref s 0) #\\Z) (sum-helper (substring s 1) (+ acc (string-ref s\
    \ 0))))\n            (else (sum-helper (substring s 1) acc))))\n    (sum-helper\
    \ s 0))\n  (sum s))\n", "  (let ([s (string-upper-case s)])\n    (for/sum ([c\
    \ (in-string s)])\n      (if (and (char-numeric? c)\n               (char-&gt;integer\
    \ c)\n               (&gt; (char-&gt;integer c) 47)\n               (&lt; (char-&gt;integer\
    \ c) 58))\n          (char-&gt;integer c)\n          0))))\n", "  (if (zero? (string-length\
    \ s))\n      0\n      (+ (char->integer (string-ref s 0))\n         (digitSum\
    \ (substring s 1)))))\n", "  (sum (map char->integer (filter char-upcase? (string->list\
    \ s)))))\n```\n\n```Racket\n#lang racket\n", "  (foldl (lambda (item sum)\n  \
    \         (if (and (<= #\\A item)\n                    (<= item #\\Z))\n     \
    \          (+ sum item)\n               sum))\n         0\n         (string->list\
    \ s)))\n", "  (let rcv ([s s] [acc 0])\n    (cond [(empty? s) acc]\n         \
    \ [(char-upcase? (car s)) (rcv (cdr s) (+ acc (char->integer (car s))))]\n   \
    \       [else (rcv (cdr s) acc)])))\n", "  (apply + (map char->integer (filter\
    \ (lambda (c) (char-upper-case? c)) s))))\n", "  (define (summable? char)\n  \
    \  (and (char-upper-case? char)\n         (&gt; char #\\A)\n         (&lt; char\
    \ #\\Z)))\n  (accumulate + 0 (map (\u03BB (ch) (- ch #\\A)) (filter summable?\
    \ (string-&gt;list s)))))\n", "  (let f ([s s] [c (string-length s)])\n    (if\
    \ (zero? c)\n        0\n        (let ([ch (substring s (- c 1) c)])\n        \
    \  (if (char-ci&gt;=? ch #\\A)\n              (+ (if (char-ci&lt;=? ch #\\Z)\n\
    \                     (- (char-&gt;integer ch) 64)\n                     (- (char-&gt;integer\
    \ ch) 96))\n                 (f (substring s 0 (- c 1)) (- c 1)))\n          \
    \    (f (substring s 0 (- c 1)) (- c 1)))))))\n</code>\n", "  (if (string=? s\
    \ \"\")\n      0\n      (if (char&lt;=? #\\a (string-ref s 0))\n          (digitSum\
    \ (substring s 1))\n          (+ (char-&gt;integer (string-ref s 0)) (digitSum\
    \ (substring s 1))))))\n</code>\nAnd this one:\n<code>#lang racket\n", "  (let\
    \ helper ([] 0)\n    (lambda (s)\n      (for ([x (in-string s)])\n        (if\
    \ (char-upper-case? x)\n            (helper (add1 (helper)))\n            0)))))\n",
  "  (apply + (map (\u03BB (s) (char->integer s)) (filter (\u03BB (c) (and (&gt;=\
    \ c #\\A) (&lt;= c #\\Z))) s))))\n</code>\nYou can also use regexp to filter out\
    \ non-alphabetical characters.\n<code>#lang racket\n", "  (define (ssum c)\n \
    \   (cond [(string=? c \"\") 0]\n          [(and (&gt;= (string-&gt;number (substring\
    \ c 0 1)) 65)\n                (&lt;= (string-&gt;number (substring c 0 1)) 90))\n\
    \           (+ (string-&gt;number (substring c 0 1)) (ssum (substring c 1)))]\n\
    \          [else (ssum (substring c 1))]))\n  (ssum s))\n</code>\nIt works. But\
    \ when I wrote a python version,\n<code>def digitSum(s):\n    def ssum(c):\n \
    \       if c == \"\":\n            return 0\n        elif ord(c[0]) &gt;= 65 and\
    \ ord(c[0]) &lt;= 90:\n            return ord(c[0]) + ssum(c[1:])\n        else:\n\
    \            return ssum(c[1:])\n    return ssum(s)\n</code>\nit works, too.\n\
    I think both code are the same. But I still have doubts about the second 'else'\
    \ in the first\ncode, it seems to be redundant. Can anyone help me?\nThanks in\
    \ advance.\n\n\nA:\n\nThe 'else' isn't really redundant, but it doesn't really\
    \ add anything either.\nThe reason for this is that the last line, <code>(ssum\
    \ (substring c 1))</code>, will always be executed, regardless of whether or not\
    \ the if or the elif block was executed.\nThe 'else' is only needed if this was\
    \ not the case.\nNow, you could have written the if and elif block such that the\
    \ last line is only executed if one of them is true, but this is exactly what\
    \ your 'else' is doing: making sure the last line is only executed if the 'else'\
    \ is true.\nBut this is exactly what the else is doing: making sure the last line\
    \ is only executed if the 'else' is true. So you could remove the else, the last\
    \ line will still be only executed if the 'else' is true.\nYou could remove the\
    \ if and elif, the last line will still be only executed if the if and elif are\
    \ not true.\nIn short, they all do the same thing.", "  (if (string=? s \"\")\n\
    \      0\n      (if (char-upper-case? (string-ref s 0))\n          (+ (digitSum\
    \ (substring s 1)) (char->integer (string-ref s 0)))\n          (digitSum (substring\
    \ s 1)))))\n", "  (define (isUpper? c)\n    (and (&gt;= c 65) (&lt;= c 90)))\n\
    \  (let loop ([s s] [sum 0])\n    (if (&gt; (string-length s) 0)\n        (loop\
    \ (substring s 1 (string-length s))\n              (+ sum (char-&gt;integer (string-ref\
    \ s 0))))\n        sum)))\n</code>\nAny of the solutions I found online just return\
    \ 0, as if the upper case character can't be > 0, but I can't see any place where\
    \ that assumption is made, or any place that doesn't treat the input as a string.\n\
    \n\nA:\n\nAs user143462 pointed out, there was a bug in my code that I hadn't\
    \ noticed.\nIt should have been\n<code>(+ sum (if (isUpper? (string-ref s 0))\n\
    \              (char-&gt;integer (string-ref s 0))\n              0)))\n</code>\n\
    instead of \n<code>(+ sum (char-&gt;integer (string-ref s 0))))\n</code>\n", " \
    \ (apply + (map (lambda (c)\n                  (if (char-upcase? c)\n        \
    \              (char->integer c)\n                      0))\n                (string->list\
    \ s))))\n```\n\n---\n\n### Digit Sum - Part 2\n\n```racket\n#lang racket\n", " \
    \ (for/sum ([char (in-string s)]\n            #:when (char-upcase? char))\n  \
    \  (char->integer char)))\n</code>\nThe goal is to make the <code>digitSum</code>\
    \ function as short as possible.\n", "  (let ([S (string->list s)])\n    (apply\
    \ + (map (lambda (x) (if (and (>= x 65) (<= x 90)) (- x 64) 0)) S))))\n", "  (sum\
    \ (map (lambda (c)\n              (if (char-upper-case? c) (- c 32) 0))\n    \
    \        (string->list s))))\n", "  (apply + (filter (\u03BB (x) (char&lt;=? #\\\
    A x #\\Z)) (string-&gt;list s))))\n", "  (apply + (map char->integer\n       \
    \          (filter char-upcase?\n                         (string->list s)))))\n",
  "  (letrec\n      ([sum-uppers\n        (lambda (chars)\n          (cond\n     \
    \       [(empty? chars) 0]\n            [(upper-case? (first chars))\n       \
    \      (+ (char->integer (first chars))\n                (sum-uppers (rest chars)))]\n\
    \            [else (sum-uppers (rest chars))]))])\n    (sum-uppers (string->list\
    \ s))))", '  (apply + (map (lambda (c) (if (char-upcase? c) (char->integer c)
    0)) (string->list s))))', "  (accumulate + 0 (map char->integer (filter (lambda\
    \ (c) (not (char-lower-case? c))) s))))\n", "  (cond\n    ((null? s) 0)\n    ((char-upcase?\
    \ (car s)) (+ (char->integer (car s)) (digitSum (cdr s))))\n    (else (digitSum\
    \ (cdr s)))))\n", "  (let ([acc 0])\n    (for ([c (in-string s)])\n      (if (and\
    \ (>= c #\\A) (<= c #\\Z))\n          (set! acc (+ acc c))))\n    acc))\n", '  (apply
    + (map char->integer (filter char-upcase? (string->list s)))))', "  (foldl (lambda\
    \ (x y)\n           (if (and (<= 65 x) (<= x 90))\n               (+ y x)\n  \
    \             y))\n         0\n         (string->list s)))\n```\n\n12. The butterfly\
    \ numbers are a sequence of numbers (1,1,2,1,4,2,6,4,8,8,10,4,12,6,...) \n```\n\
    #lang racket\n", "  (for/sum ((c (in-string s))\n            #:when (char-upcase?\
    \ c))\n    (char->integer c)))\n", '  (accumulate + 0 (map char->integer (filter
    char-upcase? (string->list s)))))', "  (define (digitSumHelper index acc)\n  \
    \  (if (&gt;= index (string-length s))\n        acc\n        (digitSumHelper (+\
    \ index 1)\n                        (+ acc (char-&gt;integer (string-ref s index))))))\n\
    \  (digitSumHelper 0 0))\n</code>\n", "  (apply + (map digitSum1 (string->list\
    \ s))))\n", "  (accumulate + 0 (map char->integer (filter char-upper-case? (string->list\
    \ s)))))\n", "  (apply + (filter (\u03BB (c) (and (char-upper-case? c)\n     \
    \                          (char-numeric? c)))\n                    (string->list\
    \ s))))\n", "  (define (acc s acc)\n    (cond\n      [(empty? s) acc]\n      [(empty?\
    \ (rest s)) (if (char-alphabetic? (first s))\n                            (+ acc\
    \ (char->integer (first s)))\n                            acc)]\n      [else (if\
    \ (char-alphabetic? (first s))\n               (acc (rest s) (+ acc (char->integer\
    \ (first s))))\n               (acc (rest s) acc))]))\n  (acc s 0))\n```\n\n###\
    \ 7. Define a function (make-polynomial term1 term2 ...) that returns a polynomial\
    \ where each term has the form (coeff exp).\n#### Example:\n```racket\n#lang racket\n",
  "  (cond ((string=? s \"\") 0)\n        ((and (char=? (string-ref s 0) (char-upcase\
    \ (string-ref s 0))) (char&lt;=? (string-ref s 0) #\\Z))\n         (+ (char-&gt;integer\
    \ (string-ref s 0)) (digitSum (substring s 1))))\n        (else (digitSum (substring\
    \ s 1)))))\n</code>\nNOTE:  There is no reason for <code>cond</code> here since\
    \ the cases are mutually exclusive, but I have seen <code>cond</code> used when\
    \ the only non-<code>#f</code> predicate is the last.\nAlso, this is the first\
    \ time that I have seen <code>char=?</code> used with <code>string-ref</code>.\
    \  It seems to make sense to do so, but I have never seen it.  Is this a good\
    \ practice?\n", "  (cond [(empty? s) 0]\n        [else (+ (char-&gt;integer (string-ref\
    \ s 0)) (digitSum (string-tail s)))]))\n</code>\nIf I run the following test:\n\
    <code>(check-expect (digitSum \"abAB\") 131)\n</code>\nI get the following error:\n\
    <code>check-expect: expected 131, but got 0\n</code>\nI can't figure out why I'm\
    \ getting this error.\n\n\nA:\n\nYou're using <code>string-tail</code> which is\
    \ non-destructive - it returns a new string:\n<code>(string-tail \"abAB\")\n=&gt;\
    \ \"bAB\"\n</code>\nInstead use <code>substring</code>, which is destructive -\
    \ it returns a substring of a string:\n<code>(substring \"abAB\" 1)\n=&gt; \"\
    bAB\"\n</code>\n", "  (accumulate + 0 (map (\u03BB (x) (if (in-range? (char->integer\
    \ x) #\\A #\\Z)\n                              (char->integer x)\n           \
    \                   0))\n                       (string->list s))))", "  (if (equal?\
    \ s \"\")\n      0\n      (let* ((x (char->integer (string-ref s 0)))\n      \
    \       (remaining (substring s 1)))\n        (if (and (>= x 65) (<= x 90))\n\
    \            (+ x (digitSum remaining))\n            (digitSum remaining)))))\n",
  "  (cond\n    [(empty? s) 0]\n    [(char-upcase? (first s)) (+ (char->integer (first\
    \ s)) (digitSum (rest s)))]\n    [else (digitSum (rest s))]))\n", "  (apply +\n\
    \         (map char->integer\n              (filter char-upcase?\n           \
    \           (string->list s)))))\n", "  (define (singleDigitSum c)\n    (if (and\
    \ (char-upper-case? c) (char-numeric? c))\n        (- (char->integer c) 48)\n\
    \        0))\n  (apply + (map singleDigitSum (string->list s))))\n", "  (cond\
    \ [(equal? s \"\") 0]\n        [else (+ (char->integer (string-ref s 0))\n   \
    \              (digitSum (substring s 1)))]))\n", "  (if (null? s)\n      0\n\
    \      (+ (ascii-&gt;integer (string-upcase (string-ref s 0)))\n         (digitSum\
    \ (substring s 1)))))\n</code>\nI've no idea how to add the function to the repl.\n\
    Thanks!\n\n\nA:\n\nSince you've tagged this as <code>beginner</code>, I'll give\
    \ you a few hints to get you started.\nYou should always write a predicate that\
    \ answers the question: \"is this the empty list?\"\n<code>(define (empty? xs)\n\
    \  (null? xs))\n</code>\nThat way, you can ask the question, and give a specific\
    \ answer for the empty list.\n<code>(cond [(empty? xs) ...]\n      [else     \
    \   ...])\n</code>\nWe need a way to break the problem down into a simpler one.\
    \  If we have a list <code>xs</code>, we want to pick out the first element and\
    \ the rest of the list.\n<code>(define (first xs)\n  (car xs))\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(empty? (regexp-match #rx\"[A-Z]\" s)) (digitSum (rest\
    \ s))]\n    [else (+ (char->integer (first s)) (digitSum (rest s)))]))", "  (sum\
    \ (map string-&gt;number (filter char-upper-case? (string-&gt;list s)))))\n</code>\n\
    Here is my attempt in Ruby. What am I doing wrong?\n<code>def digitSum(s)\n  \
    \  return s.split('').select { |c| c.upcase }.map { |c| c.ord }.sum\nend\n</code>\n\
    \n\nA:\n\nYou can't use <code>upcase</code> like that. It returns a new String\
    \ where all the letters are uppercase (e.g. <code>\"a\".upcase #=&gt; \"A\"</code>).\
    \ To check if a letter is uppercase, use <code>upcase == c</code> (e.g. <code>\"\
    a\".upcase == \"a\" #=&gt; false</code>).\nAlso, <code>string-&gt;number</code>\
    \ isn't just the ASCII code. It's the numeric value of the digit as a character.\
    \ For example, <code>\"1\".ord #=&gt; 49</code>, but <code>string-&gt;number \"\
    1\" #=&gt; 1</code>. To make this work, you can use <code>c.ord - \"A\".ord +\
    \ 1</code> for example.\n", "  (cond\n    ((string=? s \"\") 0)\n    ((and (&lt;=\
    \ (string-&gt;char s) 65) (&gt;= (string-&gt;char s) 90)) (+ (digitSum (substring\
    \ s 1)) (string-&gt;char s)))\n    ((and (&lt;= (string-&gt;char s) 97) (&gt;=\
    \ (string-&gt;char s) 122)) (digitSum (substring s 1)))\n    (else 0)))\n</code>\n\
    I've come up with a solution, but I just can't understand why it gives me the\
    \ error.\n\n\nA:\n\nHere's a start:\n<code>(define (digitSum s)\n  (cond\n   \
    \ ((string=? s \"\") 0)\n    ((and (&lt;= (string-&gt;char s) 65) (&gt;= (string-&gt;char\
    \ s) 90)) (+ (digitSum (substring s 1)) (string-&gt;char s)))\n    ((and (&lt;=\
    \ (string-&gt;char s) 97) (&gt;= (string-&gt;char s) 122)) (digitSum (substring\
    \ s 1)))\n    (else 0)))\n</code>\nOne problem is that you are trying to compare\
    \ the result of <code>string-&gt;char</code> to a number.  You probably want to\
    \ compare the result of <code>string-&gt;char</code> to a character.\n", "  (apply\
    \ + (string-&gt;list s)))\n</code>\n", "  (let loop ([s s] [sum 0])\n    (cond\n\
    \      [(empty? s) sum]\n      [(char-upper-case? (first s))\n       (loop (rest\
    \ s) (+ sum (char->integer (first s))))]\n      [else (loop (rest s) sum)])))\n",
  "  (cond\n    [(equal? s \"\") 0]\n    [(string-upper-case? (string-ref s 0))\n\
    \     (+ (digitSum (substring s 1))\n        (char->integer (string-ref s 0)))]\n\
    \    [else (digitSum (substring s 1))]))\n", "  (cond\n    [(empty? s)\n     0]\n\
    \    [(>= (string-upper-case? (first s)) 65)\n     (+ (digitSum (rest s)) (char->integer\
    \ (first s)))]\n    [else\n     (digitSum (rest s))]))", "  (cond ((null? s) 0)\n\
    \        ((char-upper-case? (car s))\n         (+ (car s) (digitSum (cdr s))))\n\
    \        (else (digitSum (cdr s)))))\n", "  (list->number\n   (number->list\n\
    \    (string->number\n     (for/fold ([a 0]) ([ch s])\n       (match ch\n    \
    \     [(or \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"\
    L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"\
    Y\" \"Z\")\n          (+ a (char->integer ch))]\n         [_ a]))))))\n", "  (apply\
    \ + (map string-&gt;number (regexp-match* #rx\"[A-Z]\" s))))\n</code>\n", "  (apply\
    \ + (map char->integer (filter char-upcase? (string->list s)))))\n", "  (let loop([s\
    \ s] [sum 0])\n    (cond\n      [(string=? s \"\") sum]\n      [(char-upcase?\
    \ (string-ref s 0)) (loop (substring s 1) (+ sum (string-ref s 0)))]\n      [else\
    \ (loop (substring s 1) sum)])))\n```\n\n---\n\n* [Question 10](./10)\n\n```racket\n\
    #lang racket\n", "  (cond ((null? s) 0)\n        ((char-numeric? (string-ref s\
    \ 0)) (+ (digitSum (substring s 1)) (string-ref s 0)))\n        ((char-alphabetic?\
    \ (string-ref s 0)) (+ (digitSum (substring s 1)) (if (char-upper-case? (string-ref\
    \ s 0)) (string-ref s 0) 0)))\n        (else (digitSum (substring s 1)))))\n",
  "  (if (string=? s \"\")\n      0\n      (let ([chars (string->list s)])\n     \
    \   (if (char-upcase? (car chars))\n            (+ (char->integer (car chars))\
    \ (digitSum (list->string (cdr chars))))\n            (digitSum (list->string\
    \ (cdr chars)))))))\n", "  (apply + (map char->integer (filter char-upcase? (string->list\
    \ s)))))\n", "  (cond\n    [(empty? s) 0]\n    [(and (char-upper-case? (string-ref\
    \ s 0)) (integer? (string-ref s 0)))\n     (+ (string-ref s 0) (digitSum (substring\
    \ s 1)))]\n    [else (digitSum (substring s 1))]))", "  (cond\n    [(string=?\
    \ s \"\") 0]\n    [else\n     (apply + (map (\u03BB (x) (cond\n              \
    \       [(char=? x #\\a) 65]\n                     [(char=? x #\\b) 66]\n    \
    \                 [(char=? x #\\c) 67]\n                     [(char=? x #\\d)\
    \ 68]\n                     [(char=? x #\\e) 69]\n                     [(char=?\
    \ x #\\f) 70]\n                     [(char=? x #\\g) 71]\n                   \
    \  [(char=? x #\\h) 72]\n                     [(char=? x #\\i) 73]\n         \
    \            [(char=? x #\\j) 74]\n                     [(char=? x #\\k) 75]\n\
    \                     [(char=? x #\\l) 76]\n                     [(char=? x #\\\
    m) 77]\n                     [(char=? x #\\n) 78]\n                     [(char=?\
    \ x #\\o) 79]\n                     [(char=? x #\\p) 80]\n                   \
    \  [(char=? x #\\q) 81]\n                     [(char=? x #\\r) 82]\n         \
    \            [(char=? x #\\s) 83]\n                     [(char=? x #\\t) 84]\n\
    \                     [(char=? x #\\u) 85]\n                     [(char=? x #\\\
    v) 86]\n                     [(char=? x #\\w) 87]\n                     [(char=?\
    \ x #\\x) 88]\n                     [(char=? x #\\y) 89]\n                   \
    \  [(char=? x #\\z) 90]\n                     [else 0]))\n              (string->list\
    \ s))))])\n", "  (letrec ([f (lambda (s)\n                (cond [(null? s) 0]\n\
    \                      [(and (not (null? s)) (not (char-lower-case? (car s))))\n\
    \                       (+ (char->integer (car s)) (f (cdr s)))]\n           \
    \           [else (f (cdr s))]))])\n    (f s)))\n", "  (apply + (map char->integer\
    \ (filter char-upcase? (string->list s)))))\n", "  (let loop ([s s] [acc 0])\n\
    \    (cond\n      [(empty? s) acc]\n      [(and (char-upcase? (first s)) (char-numeric?\
    \ (first s)))\n       (loop (rest s) (+ acc (string->number (string (first s)))))]\n\
    \      [(and (char-upcase? (first s)) (not (char-numeric? (first s))))\n     \
    \  (loop (rest s) (+ acc (char->integer (first s))))]\n      [else (loop (rest\
    \ s) acc)])))", "  (apply + (map (\u03BB (x) (if (> x 64) x 0)) (string->list\
    \ s))))", "  (define (char-to-int c)\n    (- c #\\A))\n  (define (char-to-int-cps\
    \ c)\n    (lambda (k)\n      (k (- c #\\A))))\n  (define (loop i sum)\n    (if\
    \ (= i (string-length s))\n        sum\n        (if (char-numeric? (string-ref\
    \ s i))\n            (loop (+ i 1) (+ sum (char-to-int (string-ref s i))))\n \
    \           (loop (+ i 1) sum))))\n  (loop 0 0))\n", "  (apply + (map (lambda\
    \ (c) (if (char-upcase? c) (char->integer c) 0)) (string->list s))))\n", "  (if\
    \ (string=? s \"\")\n      0\n      (cond\n        [(and\n          (char&lt;=?\
    \ #\\A (string-ref s 0))\n          (char&lt;=? (string-ref s 0) #\\Z))\n    \
    \     (+ (digitSum (substring s 1)) (char-&gt;integer (string-ref s 0)))]\n  \
    \      [else (digitSum (substring s 1))])))\n</code>\nEdit:\n<code>#lang racket\n",
  "  (define (toUpper l)\n    (char-upcase l))\n  (define (upper? c)\n    (eq? (toUpper\
    \ c) c))\n  (define (add c)\n    (if (upper? c)\n        (string->number (char->string\
    \ c))\n        0))\n  (accumulate + 0 (map add (string->list s))))", "  (cond\n\
    \    [(empty? s) 0]\n    [(upper? (string-ref s 0))\n     (+ (char->integer (string-ref\
    \ s 0))\n        (digitSum (substring s 1)))]\n    [else (digitSum (substring\
    \ s 1))]))\n", "  (accumulate + 0 (map char->integer (filter char-uppercase? (string->list\
    \ s)))))\n", "  (if (empty? s)\n      0\n      (+ (char-&gt;integer (string-ref\
    \ s 0))\n         (digitSum (substring s 1)))))\n</code>\nI want to use <code>ASCII</code>\
    \ codes here, but I don't know how to do that.\n\n\nA:\n\nUse <code>char-&gt;integer</code>:\n\
    <code>(char-&gt;integer #\\A)\n=&gt; 65\n</code>\nSo you can test if the letter\
    \ is uppercase with:\n<code>(&lt;= (char-&gt;integer c) 90)\n</code>\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(and (&lt;= (char-&gt;integer (string-ref s 0)) 122)\n\
    \          (&gt;= (char-&gt;integer (string-ref s 0)) 97)) (+ (digitSum (substring\
    \ s 1)) 0)]\n    [else (+ (digitSum (substring s 1)) (char-&gt;integer (string-ref\
    \ s 0)))]))\n</code>\nThe code above is working perfectly, but I am trying to\
    \ write one using <code>map</code> function.\n<code>#lang racket\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(upper? (first s))\n     (+ (char->integer (first s))\
    \ (digitSum (rest s)))]\n    [else (digitSum (rest s))]))\n", "  (cond ((string=?\
    \ s \"\") 0)\n        ((char-upcase? (string-ref s 0))\n         (+ (char->integer\
    \ (string-ref s 0))\n            (digitSum (substring s 1))))\n        (else (digitSum\
    \ (substring s 1)))))\n", "  (if (not (empty? s))\n      (let ([c (first s)])\n\
    \        (+ (digitSum (rest s))\n           (if (char-upper-case? c)\n       \
    \        (char->integer c)\n               0)))\n      0))\n", "  (cond [(empty?\
    \ s) 0]\n        [else (+ (char-&gt;integer (car s)) (digitSum (cdr s)))]))\n",
  "  (apply + (map (lambda (x) (char->integer x))\n                (filter char-upper-case?\
    \ (string->list s)))))\n", "  (foldl + 0 (map ascii-upper (string->list s))))\n\
    ```\n\n<hr>\n\n##### Task 10\n```racket\n#lang racket\n", "  (define (isupper?\
    \ c)\n    (and (>= c #\\A) (<= c #\\Z)))\n  (define (sum s)\n    (if (null? s)\n\
    \        0\n        (+ (if (isupper? (car s))\n               (- (car s) #\\A)\n\
    \               0)\n           (sum (cdr s)))))\n  (sum (string->list s)))\n",
  "  (if (string=? s \"\")\n      0\n      (if (char&lt;=? #\\a (string-ref s 0))\n\
    \          (digitSum (substring s 1))\n          (+ (char-&gt;integer (string-ref\
    \ s 0)) (digitSum (substring s 1))))))\n</code>\nNote: I am trying to learn recursion\
    \ so looking for advice there.\n\n\nA:\n\nYour algorithm works, but your code\
    \ is not idiomatic. You might try to take a peek at Racket - a language I've never\
    \ used myself - and ask yourself: how do I write idiomatic Racket code?\n\nDon't\
    \ ever use <code>string=?</code>, it's the wrong tool for the job. Use <code>string-empty?</code>\
    \ instead.\nLearn to love <code>cond</code> and <code>when</code>. When you start\
    \ using them, your code will be cleaner and more readable.\n\nHere's a version\
    \ of your program that uses both <code>cond</code> and <code>when</code>:\n<code>(define\
    \ (digit-sum s)\n  (cond\n    [(string-empty? s) 0]\n    [else\n     (let ([c\
    \ (string-ref s 0)])\n       (when (char&lt;=? #\\a c)\n         (+ (char-&gt;integer\
    \ c) (digit-sum (substring s 1)))))]))\n</code>\nYou can see that the structure\
    \ of the program is more evident, and it's easy to see at a glance that the program\
    \ terminates and doesn't get stuck in an infinite loop of <code>substring</code>\
    \ calls.\nEdit: I agree with the comment by @Sebastian that a function called\
    \ <code>digit-sum</code> ought to only operate on strings containing digits. I've\
    \ changed the name to <code>upper-sum</code> instead.\n", "  (for/sum ([ch (in-string\
    \ s)]\n            #:when (char-upcase? ch))\n    (char->integer ch)))\n</code>\n\
    In the example above I create a numeric vector (type <code>VecN</code>) of the\
    \ characters in the string and then operate on that.\nA more straightforward solution\
    \ (but less efficient) would be:\n<code>#lang racket\n", "  (reduce + (filter\
    \ #(char&gt;=? #\\A %) (string-&gt;list s))))\n</code>\nIs this answer good? Is\
    \ there a better way?\nNote: I want to use the high-order function <code>filter</code>\
    \ and <code>reduce</code>\n\n\nA:\n\nYou're probably looking for <code>string-ref</code>\
    \ and <code>char-&gt;integer</code>.\n<code>(define (digitSum s)\n  (reduce +\
    \ (map char-&gt;integer (string-&gt;list s))))\n</code>\n", "  (let loop ([s s]\
    \ [sum 0])\n    (if (null? s)\n      sum\n      (if (and (>= (car s) #\\A) (<=\
    \ (car s) #\\Z))\n        (loop (cdr s) (+ sum (car s)))\n        (loop (cdr s)\
    \ sum)))))\n", "  (cond [(empty? s) 0]\n        [else (if (eq? (char-upcase (first\
    \ s)) (first s))\n                  (+ (char->integer (first s)) (digitSum (rest\
    \ s)))\n                  (digitSum (rest s)))]))", "  (cond ((null? s) 0)\n \
    \       ((char&lt;=? #\\a (string-ref s 0)) (digitSum (substring s 1)))\n    \
    \    (else (+ (char-&gt;integer (string-ref s 0)) (digitSum (substring s 1))))))\n",
  "  (if (string=? s \"\")\n      0\n      (accumulate + 0\n                  (map\
    \ string-&gt;number\n                       (filter char-upper-case?\n       \
    \                        (string-&gt;list s))))))\n</code>\nI have used the following\
    \ code to test the function:\n<code>#lang racket\n", "  (foldl \n   (lambda (acc\
    \ x)\n     (cond\n      ((char=? (char-upcase x) x)\n       (+ acc (char->integer\
    \ x)))\n      (else\n       acc)))\n   0 (string->list s)))\n", '  (for/sum ([c
    (in-string s)] #:when (char-upper-case? c)) (char->integer c)))', "  (foldr (lambda\
    \ (c a)\n           (if (and (>= c 65) (<= c 90))\n               (+ a c)\n  \
    \             a))\n         0\n         (string->list s)))\n```\n\n## Debugging\
    \ practice - 2\n\n```racket\n#lang racket\n", "  (display s)\n  (display \"\\\
    n\")\n  (apply + (map (\u03BB (c)\n                 (define n (char->integer c))\n\
    \                 (if (or (>= n 65)\n                         (>= n 97))\n   \
    \                  n\n                     0))\n               (string->list s))))",
  "  (apply + (map char->integer (regexp-match* #rx\"[A-Z]\" s))))\n", "  (let loop\
    \ ((i 0) (sum 0))\n    (cond\n      [(>= i (string-length s)) sum]\n      [(char-upcase?\
    \ (string-ref s i)) (loop (+ i 1) (+ sum (char->integer (string-ref s i))))]\n\
    \      [else (loop (+ i 1) sum)])))\n", "  (if (null? s)\n      0\n      (+\n\
    \       (if (char-upcase? (string-ref s 0))\n           (char->integer (string-ref\
    \ s 0))\n           0)\n       (digitSum (substring s 1)))))", "  (cond [(string=?\
    \ s \"\") 0]\n        [else (define (accumulator n) (if (= (string-ref s n) #\\\
    A) (+ 65 accumulator(+ n 1)) 0))]))\n</code>\nI'm getting a \" reference to undefined\
    \ identifier: accumulator \" error.\nI just don't know how to initialize the accumulator(n)\
    \ part.\nCan anyone help?\nBest,\n\n\nA:\n\nRacket has a builtin function named\
    \ <code>accumulate</code> that can be used to combine values in a list (or an\
    \ string in your case) using a procedure. The first argument of <code>accumulate</code>\
    \ is the procedure that will be used to combine elements of the list. It can be\
    \ a lambda expression. In your case, if you want to sum the ASCII values of the\
    \ uppercase characters in the string, you can do it this way:\n<code>(define (digit-sum\
    \ s)\n  (accumulate + 0\n              (map (lambda (c) (if (char-upper-case?\
    \ c) c 0))\n                   s)))\n</code>\n", "  (apply +\n         (map char->integer\n\
    \              (filter char-upper-case?\n                      (string->list s)))))\n",
  "  (if (string=? s \"\")\n      0\n      (let loop ([s s] [sum 0])\n        (if\
    \ (empty? s)\n            sum\n            (if (char-numeric? (car s))\n     \
    \           (loop (cdr s) (+ sum (car s)))\n                (loop (cdr s) sum))))))\n",
  "  (let ([chars (string->list s)])\n    (apply + (for/list ([c chars])\n       \
    \         (when (char-upper-case? c)\n                  (char->integer c))))))\n",
  "  (apply + (map (\u03BB (x) (if (= x #\\A) 65 \n                            (if\
    \ (= x #\\B) 66 \n                                (if (= x #\\C) 67 \n       \
    \                             (if (= x #\\D) 68 \n                           \
    \             (if (= x #\\E) 69 \n                                           \
    \ (if (= x #\\F) 70 \n                                                (if (= x\
    \ #\\G) 71 \n                                                    (if (= x #\\\
    H) 72 \n                                                        (if (= x #\\I)\
    \ 73 \n                                                            (if (= x #\\\
    J) 74 \n                                                                (if (=\
    \ x #\\K) 75 \n                                                              \
    \      (if (= x #\\L) 76 \n                                                  \
    \                      (if (= x #\\M) 77 \n                                  \
    \                                          (if (= x #\\N) 78 \n              \
    \                                                                  (if (= x #\\\
    O) 79 \n                                                                     \
    \               (if (= x #\\P) 80 \n                                         \
    \                                               (if (= x #\\Q) 81 \n         \
    \                                                                            \
    \       (if (= x #\\R) 82 \n                                                 \
    \                                               (if (= x #\\S) 83 \n         \
    \                                                                            \
    \               (if (= x #\\T) 84 \n                                         \
    \                                                               (if (= x #\\U)\
    \ 85 \n                                                                      \
    \                                      (if (= x #\\V) 86 \n                  \
    \                                                                            \
    \                  (if (= x #\\W) 87 \n                                      \
    \                                                                            \
    \  (if (= x #\\X) 88 \n                                                      \
    \                                                                  (if (= x #\\\
    Y) 89 \n                                                                     \
    \                                                       (if (= x #\\Z) 90 0))))))))))))))))))))))))))))\
    \ (string->list s))))", "  (if (null? s)\n      0\n      (+ (if (&gt;= (string-&gt;integer\
    \ (string-ref s 0)) 65)\n             (string-&gt;integer (string-ref s 0))\n\
    \             0)\n         (digitSum (substring s 1)))))\n</code>\nWhen I load\
    \ the code and execute:\n<code>(digitSum \"woArBld\")\n</code>\nIt returns:\n\
    <code>#&lt;procedure:digitSum&gt;\n</code>\nBut when I execute,\n<code>(define\
    \ x (digitSum \"woArBld\"))", "  (cond [(empty? s) 0]\n        [else (+ (andmap\
    \ upper-case? (string->list s)) (digitSum (substring s 1)))]))\n", "  (accumulate\
    \ + 0 (map ascii-upper-case s)))\n```\n\n### Caesar Cipher\nA simple encoding\
    \ scheme that replaces each character in a string with a different character that\
    \ is a fixed number of positions later in the alphabet.\n\n```#lang racket", " \
    \ (foldl (lambda (c acc)\n           (if (and (>= c 65) (<= c 90)) (+ acc c) acc))\n\
    \         0\n         (string->list s)))\n```\n\n```#lang racket", "  (if (null?\
    \ s)\n      0\n      (+ (char->integer (string-upcase (string (car s))))\n   \
    \      (digitSum (string-drop s 1)))))", "  (apply + (map (\u03BB (x) (cond\n\
    \                          ((and (<= 65 x) (<= x 90)) x)\n                   \
    \       ((and (<= 97 x) (<= x 122)) (- x 32))\n                          (else\
    \ 0)))\n                  (string->list s))))", "  (if (equal? s \"\")\n     \
    \ 0\n      (letrec ([next (car s)]\n               [newS (string-append (cdr s)\
    \ \"\")])\n        (if (and (<= (char->integer next) 90)\n                 (>=\
    \ (char->integer next) 65))\n            (+ (char->integer next) (digitSum newS))\n\
    \            (digitSum newS)))))\n", "  (for/sum ([c (in-string s)]\n        \
    \    #:when (and (>= c 65) (<= c 90)))\n    c))\n", "  (let ([sum 0])\n    (for\
    \ ([x (in-string s)])\n      (when (char-upper-case? x)\n        (set! sum (+\
    \ sum x))))\n    sum))\n", "  (apply + (map (\u03BB (c)\n                  (if\
    \ (char-upper-case? c)\n                      (char->integer c)\n            \
    \          0))\n                (string->list s))))\n", "  (cond [(empty? s) 0]\n\
    \        [else (cond [(char&lt;=? #\\A (car s))\n                     (+ (char-&gt;integer\
    \ (car s)) (digitSum (cdr s)))]\n                    [else (digitSum (cdr s))])]))\n\
    </code>\nThe following code written in CoffeeScript\n<code># Task\n# Write a function\
    \ that takes a string as input and returns the sum of the upper characters only'\n\
    # ASCII codes.\n# Examples:\n# &gt;&gt;&gt; (digitSum \"\")\n# 0\n# &gt;&gt;&gt;\
    \ (digitSum \"abAB\")\n# 131\n# &gt;&gt;&gt; (digitSum \"abcCd\")\n# 67\n# &gt;&gt;&gt;\
    \ (digitSum \"helloE\")\n# 69\n# &gt;&gt;&gt; (digitSum \"woArBld\")\n# 131\n\
    # &gt;&gt;&gt; (digitSum \"aAaaaXa\")\n# 153\ndigitSum = (s) -&gt;\n  if s ==\
    \ \"\"\n    0\n  else\n    if s[0] &gt;= \"A\" and s[0] &lt;= \"Z\"\n      (s[0].charCodeAt(0))\
    \ + digitSum(s.slice(1))\n    else\n      digitSum(s.slice(1))\n</code>\nand the\
    \ code in JavaScript\n<code>// Task\n// Write a function that takes a string as\
    \ input and returns the sum of the upper characters only'\n// ASCII codes.\n//\
    \ Examples:\n// &gt;&gt;&gt; (digitSum \"\")\n// 0\n// &gt;&gt;&gt; (digitSum\
    \ \"abAB\")\n// 131\n// &gt;&gt;&gt; (digitSum \"abcCd\")\n// 67\n// &gt;&gt;&gt;\
    \ (digitSum \"helloE\")\n// 69\n// &gt;&gt;&gt; (digitSum \"woArBld\")\n// 131\n\
    // &gt;&gt;&gt; (digitSum \"aAaaaXa\")\n// 153\nfunction digit", "  (apply + (for/list\
    \ ([c (in-string s)])\n             (cond [(char-numeric? c)\n               \
    \     (string->number (string c))]\n                   [(char-upcase? c)\n   \
    \                 (char->integer c)]\n                   [else 0]))))\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(and (char-alphabetic? (first s))\n          (char-upper-case?\
    \ (first s)))\n     (+ (char->integer (first s))\n        (digitSum (rest s)))]\n\
    \    [else (digitSum (rest s))]))\n", "  (for/sum ([char (in-string s)]\n    \
    \        #:when (char-upcase? char))\n    (char->integer char)))\n", "    (foldl\
    \ + 0 (map char->integer (filter char-upcase? (string->list s)))))\n", "  (let\
    \ loop ((i 0) (sum 0))\n    (cond\n      [(>= i (string-length s)) sum]\n    \
    \  [(char-upper-case? (string-ref s i))\n       (loop (+ i 1) (+ sum (char->integer\
    \ (string-ref s i))))]\n      [else (loop (+ i 1) sum)])))\n", "  (for/sum ([c\
    \ (in-string s)] #:when (char-upcase? c))\n            (char->integer c)))\n",
  "  (cond\n    [(empty? s) 0]\n    [(upper? (first s))\n     (+ (char->integer (first\
    \ s)) (digitSum (rest s)))]\n    [else (digitSum (rest s))]))\n", "  (cond [(empty?\
    \ s) 0]\n        [else (+ (digitSum (rest s)) (if (and (>= (first s) #\\A) (<=\
    \ (first s) #\\Z)) (first s) 0))]))\n", "  (cond\n    [(string=? s \"\") 0]\n\
    \    [else\n     (let ([str-list (string->list s)])\n       (let ([upper-list\
    \ (filter char-upper-case? str-list)])\n         (let ([sum 0])\n           (for\
    \ ([c upper-list])\n             (set! sum (+ sum (char->integer c))))\n     \
    \      sum)))]))\n", "  (if (string=? s \"\")\n      0\n      (let ([s (string-upcase\
    \ s)])\n        (apply +\n               (for/list ([c (in-string s)])\n     \
    \            (if (char-numeric? c)\n                     (char->integer c)\n \
    \                    0))))))", "  (apply + (map char->integer (filter char-upper-case?\
    \ (string->list s)))))\n", "  (if (= s \"\")\n      0\n      (let ((ascii (char->integer\
    \ (string-ref s 0))))\n        (+ (if (>= ascii 65) ascii 0)\n           (digitSum\
    \ (substring s 1))))))\n", "  (apply + (filter (lambda (char)\n              \
    \       (and (>= char 65) (<= char 90)))\n                   (string->list s))))\n",
  "  (apply + (map char->integer (filter char-alphabetic? (string-upper-case s)))))\n",
  "  (define (iter s acc)\n    (cond ((null? s) acc)\n          ((char<? (car s) #\\\
    A) (iter (cdr s) acc))\n          ((char<? #\\Z (car s)) (iter (cdr s) acc))\n\
    \          (else (iter (cdr s) (+ acc (char->integer (car s)))))))\n  (iter s\
    \ 0))", "  (list->string (list->set (string->list s))))\n", '  (foldl + 0 (map
    char->integer (filter char-upper-case? (string->list s)))))', "  (if (empty? s)\n\
    \      0\n      (+ (char->integer (car s))\n         (digitSum (cdr s)))))\n",
  "  (define (sum-upper-chars c)\n    (if (and (>= c 65) (<= c 90))\n        c\n \
    \       0))\n  (apply + (map sum-upper-chars (string->list s))))\n", "  (apply\
    \ + (for/list ([x (in-string s)])\n            (cond\n              [(char-upcase?\
    \ x) (char->integer x)]\n              [else 0]))))\n", "  (cond [(empty? s) 0]\n\
    \        [else (+ (char->integer (car s)) (digitSum (cdr s)))]))", "  (if (empty?\
    \ s)\n      0\n      (+ (char->integer (string-ref s 0))\n         (digitSum (substring\
    \ s 1)))))\n", "  (cond\n    ((string=? s \"\") 0)\n    ((char-upcase? (string-ref\
    \ s 0))\n     (+ (char->integer (string-ref s 0))\n        (digitSum (substring\
    \ s 1))))\n    (else (digitSum (substring s 1)))))\n", "  (apply + (filter (lambda\
    \ (c) (and (&gt;= c 65) (&lt;= c 90))) (map char-&gt;integer (string-&gt;list\
    \ s)))))\n</code>\nI have a \"soft spot\" for this problem because I keep getting\
    \ asked it during job interviews and am always in awe of the elegant solutions\
    \ others have. \n", "  (if (equal? (string-length s) 0)\n      0\n      (let ([first-char\
    \ (string-ref s 0)])\n        (if (char-alphabetic? first-char)\n            (if\
    \ (char-numeric? first-char)\n                (string->number (string first-char))\n\
    \                (let ([first-char-ascii (char->integer first-char)])\n      \
    \            (if (or (= first-char-ascii 65) (= first-char-ascii 97))\n      \
    \                (+ first-char-ascii (digitSum (substring s 1)))\n           \
    \           (digitSum (substring s 1)))))\n            (digitSum (substring s\
    \ 1))))))", "  (apply +\n         (map char->integer\n              (filter char-upper-case?\n\
    \                      (string->list s)))))\n", "  (apply + (map (lambda (c) (char->integer\
    \ c))\n                (filter (lambda (c) (char-upper-case? c))\n           \
    \             (string->list s)))))\n", "  (let loop ((s s) (sum 0))\n    (cond\
    \ ((null? s) sum)\n          ((= #\\A (car s)) (loop (cdr s) (+ sum 65)))\n  \
    \        ((= #\\B (car s)) (loop (cdr s) (+ sum 66)))\n          ((= #\\C (car\
    \ s)) (loop (cdr s) (+ sum 67)))\n          ((= #\\D (car s)) (loop (cdr s) (+\
    \ sum 68)))\n          ((= #\\E (car s)) (loop (cdr s) (+ sum 69)))\n        \
    \  ((= #\\F (car s)) (loop (cdr s) (+ sum 70)))\n          ((= #\\G (car s)) (loop\
    \ (cdr s) (+ sum 71)))\n          ((= #\\H (car s)) (loop (cdr s) (+ sum 72)))\n\
    \          ((= #\\I (car s)) (loop (cdr s) (+ sum 73)))\n          ((= #\\J (car\
    \ s)) (loop (cdr s) (+ sum 74)))\n          ((= #\\K (car s)) (loop (cdr s) (+\
    \ sum 75)))\n          ((= #\\L (car s)) (loop (cdr s) (+ sum 76)))\n        \
    \  ((= #\\M (car s)) (loop (cdr s) (+ sum 77)))\n          ((= #\\N (car s)) (loop\
    \ (cdr s) (+ sum 78)))\n          ((= #\\O (car s)) (loop (cdr s) (+ sum 79)))\n\
    \          ((= #\\P (car s)) (loop (cdr s) (+ sum 80)))\n          ((= #\\Q (car\
    \ s)) (loop (cdr s) (+ sum 81)))\n          ((= #\\R (car s)) (loop (cdr s) (+\
    \ sum 82)))\n          ((= #\\S (car s)) (loop (cdr s) (+ sum 83)))\n        \
    \  ((= #\\T (car s)) (loop (cdr s) (+ sum 84)))\n          ((= #\\U (car s)) (loop\
    \ (cdr s) (+ sum 85)))\n          ((= #\\V (car s)) (loop (cdr s) (+ sum 86)))\n\
    \          ((=", "  (let ([t (string->list s)])\n    (apply + (map (lambda (x)\
    \ (if (and (>= x #\\A) (<= x #\\Z)) (- x 32) x)) t))))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(upper? (first s)) (+ (digitSum (rest s)) (char->integer (first\
    \ s)))]\n    [else (digitSum (rest s))]))\n", "  (let ([myList (string->list s)])\n\
    \    (cond\n      [(empty? myList) 0]\n      [(char&lt;=? (car myList) #\\Z)\n\
    \       (+ (digitSum (cdr myList))\n          (char-&gt;integer (car myList)))]\n\
    \      [(char&lt;=? #\\a (car myList))\n       (+ (digitSum (cdr myList))\n  \
    \        (char-&gt;integer (car myList)))]\n      [else (digitSum (cdr myList))])))\n\
    </code>\nI wish I could post more problems, but these were all the ones I tried\
    \ and failed to solve.\n\n\nA:\n\nI don't think you need to reinvent the wheel\
    \ here. As you can see in my solution, I used the built-in procedure <code>char-numeric?</code>\
    \ to get the ones you want.\nIt is used with a predicate, which basically is a\
    \ function that will return a true/false depending on the conditions.\nThere is\
    \ also a <code>string-numeric?</code> that you can use directly, without converting\
    \ to list.\n<code>(define (add-upper s)\n  (apply +\n         (map char-&gt;integer\
    \ (filter char-numeric? (string-&gt;list s)))))\n</code>\n", "  (if (empty? s)\n\
    \      0\n      (+ (digitSum (rest s))\n         (if (and (&gt;= (char-&gt;integer\
    \ (first s)) 65)\n                  (&lt;= (char-&gt;integer (first s)) 90))\n\
    \             (char-&gt;integer (first s))\n             0))))\n</code>\nTest\n\
    <code>&gt; (digitSum \"\")\n0\n&gt; (digitSum \"abAB\")\n131\n&gt; (digitSum \"\
    abcCd\")\n67\n&gt; (digitSum \"helloE\")\n69\n&gt; (digitSum \"woArBld\")\n131\n\
    &gt; (digitSum \"aAaaaXa\")\n153\n</code>\n", "  (cond [(string=? s \"\") 0]\n\
    \        [else (+ (digitSum (substring s 1)) (ascii-value (string-ref s 0)))]))\n\
    </code>\nIt actually makes it more difficult to grasp the code when being explicit\
    \ about the recursion base case. But I think that the second one is more readable.\n\
    \n\nA:\n\nI think you should have a look at the standard library when writing\
    \ these functions. This will help you get used to their interface, but also to\
    \ improve your code.\nI see two main issues with your code:\n\nyou need to convert\
    \ the character to the corresponding ASCII code, which can be done with <code>char-&gt;integer</code>.\n\
    you need to check if the character is uppercase, which can be done with <code>char-upcase</code>.\n\
    \nWith these two functions, it's easy to write your function, without the need\
    \ for nested <code>cond</code>s:\n<code>(define (digit-sum str)\n  (if (string-empty?\
    \ str)\n      0\n      (+ (char-&gt;integer (char-upcase (string-ref str 0)))\n\
    \         (digit-sum (substring str 1)))))\n</code>\nYou might have noticed that\
    \ if you just call <code>char-&gt;integer</code> on every character, you get an\
    \ even simpler solution:\n<code>(define (digit-sum str)\n  (if (string-empty?\
    \ str)\n      0\n      (+ (char-&gt;integer (string-ref str 0))\n         (digit-sum\
    \ (substring str 1)))))\n</code>\nBut the downside is that this function doesn't\
    \ work as intended with lowercase characters. If you don't care about them, then\
    \ this is probably enough, but that's not really how the problem was meant to\
    \ be solved.\nThe second version is also easier to read and understand.\n", " \
    \ (define (char-upper? c)\n    (and (char? c)\n         (>= c #\\A)\n        \
    \ (<= c #\\Z)))\n  (cond [(empty? s) 0]\n        [(char-upper? (first s)) (+ (char->integer\
    \ (first s)) (digitSum (rest s)))]\n        [else (digitSum (rest s))]))\n", " \
    \ (if (string=? s \"\")\n      0\n      (displayln s)\n      (if (string-ci=?\
    \ (substring s 0 1) \"A\")\n          (+ (char->integer (substring s 0 1)) (digitSum\
    \ (substring s 1)))\n          (if (string-ci=? (substring s 0 1) \"B\")\n   \
    \           (+ (char->integer (substring s 0 1)) (digitSum (substring s 1)))\n\
    \              (if (string-ci=? (substring s 0 1) \"C\")\n                  (+\
    \ (char->integer (substring s 0 1)) (digitSum (substring s 1)))\n            \
    \      (if (string-ci=? (substring s 0 1) \"D\")\n                      (+ (char->integer\
    \ (substring s 0 1)) (digitSum (substring s 1)))\n                      (if (string-ci=?\
    \ (substring s 0 1) \"E\")\n                          (+ (char->integer (substring\
    \ s 0 1)) (digitSum (substring s 1)))\n                          (if (string-ci=?\
    \ (substring s 0 1) \"F\")\n                              (+ (char->integer (substring\
    \ s 0 1)) (digitSum (substring s 1)))\n                              (if (string-ci=?\
    \ (substring s 0 1) \"G\")\n                                  (+ (char->integer\
    \ (substring s 0 1)) (digitSum (substring s 1)))\n                           \
    \       (if (string-ci=? (substring s 0 1) \"H\")\n                          \
    \            (+ (char->integer (substring s 0 1)) (digitSum (substring s 1)))\n\
    \                                      (if (string-ci=? (substring s 0 1) \"I\"\
    )\n                                          (+ (char->integer (substring s 0\
    \ 1)) (digitSum (substring s 1)))\n                                          (if\
    \ (string-ci=? (substring s 0 1) \"J\")\n                                    \
    \          (+ (char->integer (substring s 0 1)) (digitSum (substring s 1)))\n\
    \                                              (if (string-ci=? (substring s 0\
    \ 1) \"K\")\n                                                  (+ (char->integer\
    \ (substring s 0 1)) (digitSum (substring s 1)))", "  (apply + (map (lambda (c)\
    \ (char->integer c))\n                (filter char-upper-case? (string->list s)))))\n",
  "    (apply + (string-&gt;list s)))\n</code>\n<code>#lang racket\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(char-upper-case? (string-ref s 0))\n     (+ (char->integer\
    \ (string-ref s 0)) (digitSum (substring s 1)))]\n    [else (digitSum (substring\
    \ s 1))]))\n", "  (sum (filter (lambda (c) (char&lt;=? #\\A c #\\Z)) (string-&gt;list\
    \ s))))\n</code>\nFor some reason, this function isn't working. It doesn't give\
    \ me an error message, but it doesn't work properly when I run it.\nAny help would\
    \ be appreciated.\nThanks\n\n\nA:\n\nYou have used the wrong predicate. <code>char&lt;=?</code>\
    \ is used for lexicographic comparison, <code>char-ci&lt;=?</code> is case-insensitive:\n\
    <code>(define (digitSum s)\n  (sum (filter (lambda (c) (char-ci&lt;=? #\\A c #\\\
    Z)) (string-&gt;list s))))\n</code>\n", "  (define (acc c s)\n    (if (string=?\
    \ s \"\")\n        0\n        (if (or (char=? c #\\A) (char=? c #\\B) (char=?\
    \ c #\\C) (char=? c #\\D) (char=? c #\\E) (char=? c #\\F) (char=? c #\\G) (char=?\
    \ c #\\H) (char=? c #\\I) (char=? c #\\J) (char=? c #\\K) (char=? c #\\L) (char=?\
    \ c #\\M) (char=? c #\\N) (char=? c #\\O) (char=? c #\\P) (char=? c #\\Q) (char=?\
    \ c #\\R) (char=? c #\\S) (char=? c #\\T) (char=? c #\\U) (char=? c #\\V) (char=?\
    \ c #\\W) (char=? c #\\X) (char=? c #\\Y) (char=? c #\\Z))\n            (+ (char->integer\
    \ c) (acc (string-ref s 0) (substring s 1)))\n            (acc (string-ref s 0)\
    \ (substring s 1))))\n  (acc (string-ref s 0) (substring s 1)))\n", "  (apply\
    \ + (map ascii-upper-case (string->list s))))\n", "    (apply + (for/list ([char\
    \ (in-string s)])\n        (cond\n            [(char-numeric? char)\n        \
    \     (string->number (string char))]\n            [(char-upper-case? char)\n\
    \             (char->integer char)]\n            [else 0]))))\n", '  (accumulate
    + 0 (filter char-upper-case? (string->list s))))', "  (let ([s (string-&gt;list\
    \ s)])\n    (if (empty? s)\n        0\n        (+\n         (if (char-upper-case?\
    \ (car s))\n             (char-&gt;integer (car s))\n             0)\n       \
    \  (digitSum (cdr s))))))\n</code>\nI can't get this to run as I need to convert\
    \ the string to a list of chars.\nBut when I do this, it says it can't compare.\n\
    Can someone help me understand why this isn't working?\nThanks!\n\n\nA:\n\nTo\
    \ make it a list of characters, use <code>string-&gt;list</code> and the comparison\
    \ changes to <code>char=?</code>\n<code>(define (digitSum s)\n  (let ([s (string-&gt;list\
    \ s)])\n    (if (empty? s)\n        0\n        (+\n         (if (char-upper-case?\
    \ (car s))\n             (char-&gt;integer (car s))\n             0)\n       \
    \  (digitSum (cdr s))))))\n</code>\n", "  (define (to-upper x)\n    (if (char-alphabetic?\
    \ x)\n      (char-upcase x)\n      x))\n  (if (string=? \"\" s)\n    0\n    (if\
    \ (char-numeric? (string-ref s 0))\n      (+ (string->number (substring s 0 1))\
    \ (digitSum (substring s 1)))\n      (if (char-alphabetic? (string-ref s 0))\n\
    \        (+ (char->integer (to-upper (string-ref s 0))) (digitSum (substring s\
    \ 1)))\n        (digitSum (substring s 1))))))", "  (cond [(null? s) 0]\n    \
    \    [else (+ (if (char-numeric? (string-ref s 0))\n                    (string->number\
    \ (list->string (list (string-ref s 0))))\n                    0)\n          \
    \       (digitSum (substring s 1)))]))", "  (define (loop s acc)\n    (cond [(empty?\
    \ s) acc]\n          [(char-upper-case? (first s)) (loop (rest s) (+ acc (char->integer\
    \ (first s))))]\n          [else (loop (rest s) acc)]))\n  (loop s 0))\n", " \
    \ (cond\n    [(empty? s) 0]\n    [(char-upper-case? (string-ref s 0)) (+ (char->integer\
    \ (string-ref s 0)) (digitSum (substring s 1)))]\n    [else (digitSum (substring\
    \ s 1))]))", "  (cond\n    [(empty? s) 0]\n    [(character-upper-case? (string-ref\
    \ s 0))\n     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]\n\
    \    [else (digitSum (substring s 1))]))", "  (let loop ((i 0) (sum 0))\n    (cond\
    \ ((= i (string-length s)) sum)\n          ((char-upper-case? (string-ref s i))\n\
    \           (loop (+ i 1) (+ sum (char->integer (string-ref s i)))))\n       \
    \   (else (loop (+ i 1) sum)))))\n", "  (if (string=? s \"\")\n      0\n     \
    \ (let* ([first (substring s 0 1)]\n             [rest (substring s 1)])\n   \
    \     (if (char-alphabetic? (string->char first))\n            (if (char-upper-case?\
    \ (string->char first))\n                (+ (char->integer (string->char first))\
    \ (digitSum rest))\n                (digitSum rest))\n            (digitSum rest)))))",
  "  (apply + (filter even? (map char->integer (string-upper-case s)))))\n```\n\n\
    ```racket\n#lang racket\n", "  (apply + (map char->integer\n                 (filter\
    \ (lambda (c) (and (char-upper-case? c)\n                                    \
    \     (char-numeric? c)))\n                         s))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
