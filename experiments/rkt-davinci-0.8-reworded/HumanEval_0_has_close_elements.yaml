name: HumanEval_0_has_close_elements
language: rkt
prompt: "#lang racket\n\n;; Check if in given list of numbers, are any two numbers\
  \ closer to each other than\n;; given threshold.\n;; >>> (has_close_elements (list\
  \ 1.0 2.0 3.0) 0.5)\n;; #f\n;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0\
  \ 2.0) 0.3)\n;; #t\n(define (has_close_elements numbers threshold)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate has_close_elements))\n\
  \    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)\n    (check-equal?\
  \ (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)\n    (check-equal? (candidate\
  \ (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)\n    (check-equal? (candidate (list 1.0 2.0\
  \ 5.9 4.0 5.0) 0.8) #f)\n    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0\
  \ 2.0) 0.1) #t)\n    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)\n\
  \    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)\n))\n\n(test-humaneval)"
completions: ["  (define (closer? num1 num2)\n    (< (abs (- num1 num2)) threshold))\n\
    \  (cond ((null? numbers) #f)\n        ((null? (cdr numbers)) #f)\n        ((closer?\
    \ (car numbers) (cadr numbers)) #t)\n        (else (has_close_elements (cdr numbers)\
    \ threshold))))\n", "  (cond\n    [(empty? numbers) false]\n    [(> (length numbers)\
    \ 1)\n     (or\n       (has_close_elements (rest numbers) threshold)\n       (and\n\
    \         (< (- (first numbers) (second numbers)) threshold)\n         true))]\n\
    \    [else false]))\n```\n\n## Exercise 4\n```racket\n#lang racket\n", "  (define\
    \ (aux a b threshold)\n    (cond\n      [(empty? b) #f]\n      [(> (abs (- (first\
    \ a) (first b))) threshold) (aux a (rest b) threshold)]\n      [else #t]))\n \
    \ (cond\n    [(empty? numbers) #f]\n    [(aux (rest numbers) (rest numbers) threshold)\
    \ #t]\n    [else (has_close_elements (rest numbers) threshold)]))\n", "  (not\
    \ (null? (closer-than-threshold? (pairwise numbers) threshold))))\n", "  (for/or\
    \ ([(x y) (in-nested-list numbers)]\n           #:when (< (abs (- x y)) threshold))\n\
    \    #t))\n```\n\n## Task 5\n\nCheck if given list of numbers contains a number\
    \ less than minimum of the list.\n```#lang racket\n", "  (cond\n    [(empty? numbers)\
    \ #f]\n    [(empty? (rest numbers)) #f]\n    [else\n     (or (distance_smaller_than_threshold\
    \ (first numbers) (first (rest numbers)) threshold)\n         (has_close_elements\
    \ (rest numbers) threshold))]))\n", "  (define (has_close_elements* n1 n2 numbers)\n\
    \    (cond\n      [(empty? numbers) #f]\n      [(< (abs (- (first numbers) n1))\
    \ threshold) #t]\n      [(< (abs (- (first numbers) n2)) threshold) #t]\n    \
    \  [else (has_close_elements* n1 n2 (rest numbers))]))\n  (cond\n    [(empty?\
    \ numbers) #f]\n    [(< (length numbers) 2) #f]\n    [else (has_close_elements*\
    \ (first numbers) (second numbers) (rest (rest numbers)))]))\n", "  (let loop\
    \ ([remaining-numbers (cdr numbers)]\n             [prev-number (car numbers)])\n\
    \    (cond [(empty? remaining-numbers) #f]\n          [(< (- (car remaining-numbers)\
    \ prev-number) threshold) #t]\n          [else (loop (cdr remaining-numbers) (car\
    \ remaining-numbers))])))\n", "  (cond\n    [(empty? numbers) false]\n    [(=\
    \ 1 (length numbers)) false]\n    [else\n     (cond\n       [(< (abs (- (first\
    \ numbers) (second numbers))) threshold) true]\n       [else (has_close_elements\
    \ (rest numbers) threshold)])]))\n", "  (cond\n    [(empty? numbers) false]\n\
    \    [(= (length numbers) 1) false]\n    [else\n     (cond\n       [(has_close_elements\
    \ (cdr numbers) threshold) true]\n       [(< (abs (- (car numbers) (car (cdr numbers))))\
    \ threshold) true]\n       [else false])]))\n\n", "  (define (has_close_elements-rec\
    \ ns)\n    (if (null? (cdr ns))\n        #f\n        (if (> (abs (- (car ns) (car\
    \ (cdr ns)))) threshold)\n            (has_close_elements-rec (cdr ns))\n    \
    \        #t)))\n  (has_close_elements-rec numbers))\n", "  (cond ((null? numbers)\
    \ #f)\n        ((= (length numbers) 1) #f)\n        ((< (abs (- (car numbers)\
    \ (cadr numbers))) threshold) #t)\n        (else (has_close_elements (cdr numbers)\
    \ threshold))))\n", "  (foldl\n   (lambda (n1 n2)\n     (or\n      (abs (- n1\
    \ n2))\n      threshold))\n   numbers))\n", "  (define (loop max-distance numbers)\n\
    \    (cond\n      [(empty? numbers) max-distance]\n      [(empty? (rest numbers))\
    \ max-distance]\n      [else\n       (let ([distance (- (first numbers) (second\
    \ numbers))])\n         (loop (min max-distance distance) (rest numbers)))]))\n\
    \  (> (loop (first numbers) numbers) threshold))\n", "  (define (helper numbers\
    \ threshold result)\n    (cond ((null? numbers) result)\n          ((= threshold\
    \ (abs (- (car numbers) (cadr numbers))))\n           (helper (cdr numbers) threshold\
    \ #t))\n          (else (helper (cdr numbers) threshold result))))\n  (helper\
    \ numbers threshold #f))\n```\n\n```scheme\n#lang racket\n", "  (define first-numbers\
    \ numbers)\n  (define second-numbers (cdr numbers))\n  (cond\n    [(empty? second-numbers)\
    \ #f]\n    [(< (abs (- (car first-numbers) (car second-numbers))) threshold) #t]\n\
    \    [else (has_close_elements second-numbers threshold)]))\n", "  (cond\n   \
    \ [(empty? numbers) #f]\n    [(empty? (rest numbers)) #f]\n    [else\n     (define\
    \ first (first numbers))\n     (define rest (rest numbers))\n     (define second\
    \ (first rest))\n     (if (< (abs (- first second)) threshold)\n         #t\n\
    \         (has_close_elements rest threshold))]))\n", "  (cond [(empty? numbers)\
    \ #f]\n        [(close-to? (first numbers) (first (rest numbers)) threshold) #t]\n\
    \        [else (has_close_elements (rest numbers) threshold)]))\n", "  (cond [(empty?\
    \ numbers) #f]\n        [(and (rest numbers)\n              (< (- (first numbers)\
    \ (second numbers)) threshold))\n         #t]\n        [else (has_close_elements\
    \ (rest numbers) threshold)]))\n", "  (define (iter numbers distance)\n    (if\
    \ (null? numbers)\n        #f\n        (let ((distance (abs (- (car numbers) (cadr\
    \ numbers)))))\n          (if (< distance threshold)\n              #t\n     \
    \         (iter (cdr numbers) distance)))))\n  (iter numbers threshold))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
