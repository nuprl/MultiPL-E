name: HumanEval_99_closest_integer
language: rkt
prompt: "#lang racket\n\n;; Create a function that takes a value (string) representing\
  \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
  ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
  \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
  \ away from zero means that if the given number is equidistant\n;; from two integers,\
  \ the one you should return is the one that is the\n;; farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\n(define (closest_integer value)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
  \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
  ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
  \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
completions: ["  (round (/ (+ (string->number value) 0.5) 1)))\n</code>\n", "  (let*\
    \ ((value (string->number value))\n         (value-integral-part (inexact->exact\
    \ (truncate value)))\n         (value-fractional-part (- value value-integral-part)))\n\
    \    (cond\n      ((>= value-fractional-part 0.5) (+ value-integral-part 1))\n\
    \      ((<= value-fractional-part -0.5) (- value-integral-part 1))\n      (else\
    \ value-integral-part))))\n", "  (if (negative? (string->number value))\n    \
    \  (- (round (string->number value)))\n      (round (string->number value))))\n",
  "  (if (integer? value) value\n      (if (= (floor (round value)) (ceiling (round\
    \ value)))\n          (if (< (round value) 0) (floor (round value)) (ceiling (round\
    \ value)))\n          (if (< value 0) (floor (round value)) (ceiling (round value))))))\n",
  "  (string->number (string-append (number->string (exact->inexact (round (string->number\
    \ value)))))))\n", "  (define (closest_integer-inner value acc)\n    (cond [(string=?\
    \ \".\" (substring value 0 1)) (closest_integer-inner (string-append \"0\" value)\
    \ acc)]\n          [(string=? \"-\" (substring value 0 1)) (closest_integer-inner\
    \ (substring value 1) (cons \"-\" acc))]\n          [(string=? \"+\" (substring\
    \ value 0 1)) (closest_integer-inner (substring value 1) acc)]\n          [(string=?\
    \ \"\" value) (apply number-&gt;string (reverse acc))]\n          [(&gt; (string-&gt;number\
    \ (substring value 0 1)) 4) (closest_integer-inner (substring value 1) (cons \"\
    5\" acc))]\n          [else (closest_integer-inner (substring value 1) (cons \"\
    0\" acc))]))\n  (closest_integer-inner value '()))\n", "  (if (positive? (string->number\
    \ value))\n      (inexact->exact (round (string->number value)))\n      (inexact->exact\
    \ (round (string->number value)))))\n", "  (cond ((= 0.0 value) 0)\n        ((=\
    \ 0.5 value) 1)\n        ((= -0.5 value) -1)\n        ((&gt; value 0) (inexact-&gt;exact\
    \ (floor value)))\n        ((&lt; value 0) (inexact-&gt;exact (ceiling value)))))\n",
  "  (cond [(< value 0) (- (round (abs value)))]\n        [else (round value)]))\n",
  "  (exact->inexact (round (string->number value))))\n", "  (apply round (list value)))\n\
    ```\n\n```racket", "  (define (extract_sign value)\n    (cond\n      [(string=?\
    \ value \"0\")]\n      [(string-index value #\\-) -1]\n      [else 1]))\n  (define\
    \ (abs-string str)\n    (if (string=? str \"0\")\n        \"0\"\n        (if (string-index\
    \ str #\\-)\n            (string-drop str 1)\n            str)))\n  (define (drop-dot\
    \ value)\n    (if (string-index value #\\.)\n        (string-drop value (add1\
    \ (string-index value #\\.)))\n        value))\n  (define (normalize-digits value)\n\
    \    (cond\n      [(< (string-length value) 2) value]\n      [(= (string-length\
    \ value) 2) (string-append \"0\" value)]\n      [else value]))\n  (define (dec-str\
    \ value)\n    (string-append\n     (normalize-digits\n      (drop-dot value))\n\
    \     \"0\"))\n  (define (inc-str value)\n    (string-append\n     (normalize-digits\n\
    \      (drop-dot value))\n     \"1\"))\n  (define (greater-than value1 value2)\n\
    \    (let ((val1 (string->number value1))\n          (val2 (string->number value2)))\n\
    \      (> val1 val2)))\n  (define (round-away-from-zero value)\n    (let ((sign\
    \ (extract-sign value)))\n      (if (string=? (abs-string value) \"0\")\n    \
    \      \"0\"\n          (if (string-index value #\\.)\n              (let ((digits\
    \ (drop-dot value)))\n                (if (greater-than digits \"5\")\n      \
    \              (number->string (round (string->number value)))\n             \
    \       (number->string (round (string->number value)))))\n              (if (greater-than\
    \ value \"5\")\n                  (number->string (+ sign 1))\n              \
    \    (number->string sign)))))))", "  (let* ([chunks (string-split value #\\.)]\n\
    \         [int (string->number (car chunks))]\n         [dec (string->number (cadr\
    \ chunks))])\n    (cond ((= dec 0) int)\n          ((&gt; dec 0) (+ int 1))\n\
    \          ((&lt; dec 0) (- int 1)))))\n</code>\nHere's the output of some Racket\
    \ tests:\n<code>&gt; (closest_integer \"10\")\n10\n&gt; (closest_integer \"15.3\"\
    )\n15\n&gt; (closest_integer \"15.5\")\n16\n&gt; (closest_integer \"14.5\")\n\
    15\n&gt; (closest_integer \"-14.5\")\n-15\n&gt; (closest_integer \"-14.5\")\n\
    -15\n&gt; (closest_integer \"-11.4\")\n-11\n&gt; (closest_integer \"-11.5\")\n\
    -12\n</code>\n", "  (define value-integer (round value))\n  (define value-real\
    \ (real-part value))\n  (if (or (and (= value-integer value-real) (> value-integer\
    \ 0))\n          (and (= value-integer value-real) (< value-integer 0)))\n   \
    \   value-integer\n      (if (> value-integer 0)\n          (add1 value-integer)\n\
    \          (sub1 value-integer))))\n", "  (round value))\n", "  (let* ([value\
    \ (string->number value)]\n         (x (quotient value 1))\n         (y (quotient\
    \ value 1.0)))\n    (if (= x y)\n        x\n        (if (>= value 0)\n       \
    \     (1+ x)\n            (1- x)))))\n", "  (define (float-abs x)\n    (if (&lt;\
    \ x 0) (- x) x))\n  (define (floor-to-int x)\n    (integer? x))\n  (define (ceiling-to-int\
    \ x)\n    (add1 (floor-to-int x)))\n  (define (integers-around x)\n    (list (floor-to-int\
    \ x) (ceiling-to-int x)))\n  (define (get-closest x y)\n    (if (&lt;= (float-abs\
    \ (- x (floor-to-int x)))\n             (float-abs (- x (ceiling-to-int x))))\n\
    \        (floor-to-int x)\n        (ceiling-to-int x)))\n  (get-closest (string-&gt;number\
    \ value) (integers-around (string-&gt;number value))))\n", "  (define int_value\n\
    \    (if (string-index value #\\.)\n        (substring value 0 (string-index value\
    \ #\\.))\n        value))\n  (define (trailing_decimal str)\n    (substring str\
    \ (string-index str #\\.) 1))\n  (cond\n    [(> (string->number (trailing_decimal\
    \ value)) .5)\n     (add1 (string->number int_value))]\n    [(< (string->number\
    \ (trailing_decimal value)) .5)\n     (string->number int_value)]\n    [(= (string->number\
    \ (trailing_decimal value)) .5)\n     (if (positive? (string->number value))\n\
    \         (add1 (string->number int_value))\n         (sub1 (string->number int_value)))]))\n",
  "  (if (exact-integer? value)\n      value\n      (round (string->number value))))\n",
  "  (define (abs x)\n    (if (< x 0)\n        (- x)\n        x))\n  (define (closest-integer-helper\
    \ n)\n    (if (not (integer? n))\n        (if (or (and (>= (abs (- n (inexact->exact\
    \ n)))\n                        (abs (- n (+ 1 (inexact->exact n)))))\n      \
    \               (< (abs (- n (inexact->exact n)))\n                        (abs\
    \ (- n (- 1 (inexact->exact n))))))\n                (and (<= (abs (- n (inexact->exact\
    \ n)))\n                        (abs (- n (+ 1 (inexact->exact n)))))\n      \
    \               (> (abs (- n (inexact->exact n)))\n                        (abs\
    \ (- n (- 1 (inexact->exact n)))))))\n            (+ (inexact->exact n) 1)\n \
    \           (- (inexact->exact n) 1))\n        n))\n  (cond ((integer? value)\n\
    \         value)\n        ((string? value)\n         (closest-integer-helper (string->number\
    \ value)))\n        ((number? value)\n         (closest-integer-helper value))))\n",
  "  (define (closest_val lst)\n    (define (closest_val-iter curr-v curr-i v lst)\n\
    \      (cond\n        [(empty? lst) curr-i]\n        [(and (>= curr-v v) (>= (car\
    \ lst) v)) curr-i]\n        [(and (< curr-v v) (< (car lst) v)) (car lst)]\n \
    \       [else (closest_val-iter (car lst) (car lst) v (cdr lst))]))\n    (closest_val-iter\
    \ 0 0 value lst))\n  (if (negative? value)\n      (- (closest_val (for/list ([i\
    \ (in-range 1 value -1)])\n                         i)))\n      (closest_val (for/list\
    \ ([i (in-range 0 value 1)])\n                       i))))\n", "  (if (string-contains\
    \ value \".\")\n      (if (> (string->number value) 0)\n          (exact->inexact\
    \ (+ (string->number value) 0.5))\n          (exact->inexact (- (string->number\
    \ value) 0.5)))\n      (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (let* ((value (string->number value))\n         (value-integer\
    \ (integer->char value))\n         (closest-integer (round value))\n         (closest-integer-string\
    \ (integer->char closest-integer)))\n    (cond\n      [(char=? value-integer closest-integer-string)\
    \ closest-integer]\n      [(and (char<? value-integer closest-integer-string)\n\
    \            (even? closest-integer)) closest-integer]\n      [(and (char>? value-integer\
    \ closest-integer-string)\n            (even? closest-integer)) closest-integer]\n\
    \      [(and (char<? value-integer closest-integer-string)\n            (odd?\
    \ closest-integer)) (- closest-integer 1)]\n      [(and (char>? value-integer\
    \ closest-integer-string)\n            (odd? closest-integer)) (+ closest-integer\
    \ 1)])))\n", "  (if (< (string->number value) 0)\n      (- (floor (string->number\
    \ value)))\n      (ceiling (string->number value))))\n", "  (define (closest_integer-inner\
    \ value n)\n    (if (= value n)\n        n\n        (if (&lt; (abs (- value n))\
    \ 0.5)\n            n\n            (closest_integer-inner value (+ n 1)))))\n\
    \  (if (negative? value)\n      (- (closest_integer-inner (- value) 0))\n    \
    \  (closest_integer-inner value 0)))\n", "  (round (string->number value)))\n",
  "  (cond\n    [(string=? value \"0\") 0]\n    [(string-contains? value \".\") (string->number\
    \ (substring value 0 (string-index value \".\")))]\n    [else (string->number\
    \ value)]))", "  (cond\n    [(< (string->number value) 0) (floor (string->number\
    \ value))]\n    [else (ceiling (string->number value))]))\n", "  (define value_num\
    \ (string->number value))\n  (define (closest_integer2 value_num)\n    (cond ((<\
    \ value_num 0)\n           (floor (- value_num 0.5)))\n          ((> value_num\
    \ 0)\n           (ceiling (- value_num 0.5)))\n          (else 0)))\n  (closest_integer2\
    \ value_num))", "  (cond\n    [(> (string->number value) 0) (round (string->number\
    \ value))]\n    [(< (string->number value) 0) (ceiling (string->number value))]\n\
    \    [else (floor (string->number value))]))\n", "  (if (negative? (real-part\
    \ (string->number value)))\n      (floor (string->number value))\n      (ceiling\
    \ (string->number value))))\n", "  (round value))\n</code>\nWhen I try to run\
    \ the code above using DrRacket I get an error saying that <code>round</code>\
    \ is an undefined identifier.\n\n\nA:\n\n<code>round</code> is a library function,\
    \ you have to import it first. Depending on the requirements, you should do one\
    \ of the following:\n<code>(require math)\n</code>\nor\n<code>(require racket/base)\n\
    </code>\n", "  (round (string->number value)))\n", "  (if (negative? (sub1 (string->number\
    \ value)))\n      (floor (string->number value))\n      (ceiling (string->number\
    \ value))))\n", "  (define (helper val)\n    (if (negative? val)\n        (- val\
    \ (/ (remainder val 1) 1))\n        (- val (/ (remainder val 1) 1) 1)))\n  (helper\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (if (zero?\
    \ (modulo (round (string->number value)) 2))\n      (round (string->number value))\n\
    \      (if (< (abs (string->number value)) 0.5)\n          (floor (string->number\
    \ value))\n          (ceiling (string->number value)))))\n", "  (define val-num\
    \ (string->number value))\n  (cond\n    [(and (negative? val-num)\n          (=\
    \ (floor val-num) (ceiling val-num)))\n     (ceiling val-num)]\n    [(and (negative?\
    \ val-num)\n          (> (floor val-num) (ceiling val-num)))\n     (floor val-num)]\n\
    \    [(and (negative? val-num)\n          (< (floor val-num) (ceiling val-num)))\n\
    \     (ceiling val-num)]\n    [(and (positive? val-num)\n          (= (floor val-num)\
    \ (ceiling val-num)))\n     (floor val-num)]\n    [(and (positive? val-num)\n\
    \          (> (floor val-num) (ceiling val-num)))\n     (ceiling val-num)]\n \
    \   [(and (positive? val-num)\n          (< (floor val-num) (ceiling val-num)))\n\
    \     (floor val-num)]\n    [else 0]))\n", "  (if (= (remainder (floor value)\
    \ 1) 0)\n      (floor value)\n      (let* ([mid-point (/ (+ (floor value) (ceiling\
    \ value)) 2)]\n             [integer (floor value)])\n        (if (> value mid-point)\n\
    \            (ceiling value)\n            (floor value)))))\n", '  (round value))',
  "  (define number (string->number value))\n  (define floored (floor number))\n \
    \ (define ceiled (ceiling number))\n  (if (> (abs (- number floored)) (abs (-\
    \ number ceiled)))\n      ceiled\n      floored))", "  (match value\n    [(\"\
    10\") 10]\n    [(\"15.3\") 15]\n    [(? number? n) (round n)]))\n", "  (let ((real-value\
    \ (string->number value)))\n    (if (= real-value (round real-value))\n      \
    \  (round real-value)\n        (+ 1 (floor real-value)))))\n", "  (let* ([value\
    \ (string->number value)]\n         [closest-integer-away-from-zero\n        \
    \  (cond [(negative? value) (floor value)]\n                [else (ceiling value)])])\n\
    \    closest-integer-away-from-zero))\n", "  (define (is_integer? value)\n   \
    \ (exact-integer? (string->number value)))\n  (cond\n    [(is_integer? value)\
    \ (string->number value)]\n    [(= (floor (string->number value))\n        (ceiling\
    \ (string->number value)))\n     (string->number value)]\n    [(< (string->number\
    \ value) 0)\n     (floor (string->number value))]\n    [else (ceiling (string->number\
    \ value))]))\n", "  (round value))\n", "  (if (< (modulo value 1) 0.5)\n     \
    \ (round value)\n      (round (+ value 1))))\n", "  (round (string->number value)))\n",
  "  (if (< (first (string-split value #\".\"))\n         (string->number\n      \
    \    (substring value (+ (string-length value) -1))))\n      (string->number (substring\
    \ value 0 (+ (string-length value) -1)))\n      (add1 (string->number (substring\
    \ value 0 (+ (string-length value) -1))))))\n", "  (round (string->number value)))\n",
  "  (cond\n    [(< (string->number value) 0) (- (round (string->number value)))]\n\
    \    [else (round (string->number value))]))\n", "  (string->number (number->string\
    \ (round (string->number value)))))\n", "  (round value))\n```\n\n```racket\n\
    #lang racket\n", "  (if (equal? (floor value) (ceiling value))\n      (if (equal?\
    \ (number->string value) (number->string (floor value)))\n          (floor value)\n\
    \          (ceiling value))\n      (if (< (abs (- value (floor value))) (abs (-\
    \ value (ceiling value))))\n          (floor value)\n          (ceiling value))))\n",
  "  (cond\n    [(and (real? value) (eq? (modulo value 1) 0))\n     (round value)]\n\
    \    [(and (real? value) (eq? (modulo value 1) 0.5))\n     (if (positive? value)\
    \ (round (+ value 1)) (round (+ value -1)))]\n    [(and (real? value) (eq? (modulo\
    \ value 1) -0.5))\n     (if (positive? value) (round (+ value 1)) (round (+ value\
    \ -1)))]\n    [(and (real? value) (eq? (modulo value 1) -0.1))\n     (round (+\
    \ value -1))]\n    [(and (real? value) (eq? (modulo value 1) 0.1))\n     (round\
    \ (+ value 1))]\n    [(and (real? value) (eq? (modulo value 1) -0.9))\n     (round\
    \ (+ value -1))]\n    [(and (real? value) (eq? (modulo value 1) 0.9))\n     (round\
    \ (+ value 1))]\n    [(and (real? value) (eq? (modulo value 1) -0.4))\n     (round\
    \ (+ value -1))]\n    [(and (real? value) (eq? (modulo value 1) 0.4))\n     (round\
    \ (+ value 1))]\n    [(and (real? value) (eq? (modulo value 1) -0.6))\n     (round\
    \ (+ value -1))]\n    [(and (real? value) (eq? (modulo value 1) 0.6))\n     (round\
    \ (+ value 1))]\n    [(and (real? value) (eq? (modulo value 1) -0.2))\n     (round\
    \ (+ value -1))]\n    [(and (real? value) (eq? (modulo value 1) 0.2))\n     (round\
    \ (+ value 1))]\n    [(and (real? value) (eq? (modulo value 1) -0.8))\n     (round\
    \ (+ value -1))]\n    [(and (real? value) (eq? (modulo value 1) 0.8))\n     (round\
    \ (+ value 1))]\n    [(and (real?", "  (define (sgn x) (if (negative? x) -1 1))\n\
    \  (define (round-away-from-zero x)\n    (if (zero? (remainder x 1))\n       \
    \ (number->string (round x))\n        (number->string (if (positive? (remainder\
    \ x 1))\n                            (+ x 1)\n                            (+ x\
    \ -1)))))\n  (round-away-from-zero (string->number value)))", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (cond ((string-prefix?\
    \ \"-\" value)\n         (- (string->number (substring value 1)) (string->number\
    \ value)))\n        (else\n         (- (string->number value) (string->number\
    \ (substring value 1))))))\n", "  (string->number (number->string (round (string->number\
    \ value)))))\n", "  (letrec ([floatval (string->number value)]\n           [absval\
    \ (if (negative? floatval)\n                       (- floatval)\n            \
    \           floatval)])\n    (if (integer? absval)\n        (if (negative? floatval)\n\
    \            (- absval)\n            absval)\n        (if (negative? floatval)\n\
    \            (- (add1 absval))\n            (add1 absval)))))\n", "  (if (number?\
    \ value)\n      (round value)\n      (round (string->number value))))\n", "  (let*\
    \ ([value-as-number (string->number value)]\n         (rounded-number (if (< value-as-number\
    \ 0)\n                             (ceiling value-as-number)\n               \
    \              (floor value-as-number))))\n    rounded-number))\n", "  (define\
    \ (round-away-from-zero-decrementor num)\n    (if (and (positive? num) (negative?\
    \ (- num 1)))\n        0\n        (- num 1)))\n  (define (round-away-from-zero-incrementor\
    \ num)\n    (if (and (negative? num) (positive? (+ num 1)))\n        0\n     \
    \   (+ num 1)))\n  (cond\n    [(positive? value)\n     (round-away-from-zero-incrementor\
    \ (inexact->exact (round value)))]\n    [(negative? value)\n     (round-away-from-zero-decrementor\
    \ (inexact->exact (round value)))]\n    [else 0]))\n", "  (define (positive-or-zero?\
    \ number)\n    (and (>= number 0) number))\n  (define (negative? number)\n   \
    \ (and (< number 0) number))\n  (define (closest-integer-helper number up-or-down)\n\
    \    (cond\n      [(= up-or-down 1)\n       (positive-or-zero? (abs (- (round\
    \ number) number)))]\n      [(= up-or-down -1)\n       (negative? (abs (- (round\
    \ number) number)))]))\n  (if (closest-integer-helper (string->number value) 1)\n\
    \      (round (string->number value))\n      (round (string->number value) -1)))\n",
  "  (round (string->number value)))\n", "  (exact->inexact (round (string->number\
    \ value))))\n", "  (if (string=? (substring value (- (string-length value) 1))\
    \ \".\")\n      (if (string=? (substring value 0 1) \"-\")\n          (- (string->number\
    \ value) 1)\n          (string->number value))\n      (if (string=? (substring\
    \ value 0 1) \"-\")\n          (- (string->number value))\n          (string->number\
    \ value))))\n", "  (if (negative? (real-part (string->number value)))\n      (real->inexact-integer\
    \ (real-part (string->number value)))\n      (ceiling (real-part (string->number\
    \ value)))))\n", "  (define (eval-preliminary-value str num)\n    (cond ((= (round\
    \ num) num) (round num))\n          ((>= (+ num 0.5) str) (- (round num) 1))\n\
    \          (else (round num))))\n  (eval-preliminary-value (string->number value)\
    \ (string->number value)))\n", "  (cond [(>= value 0) (round value)]\n       \
    \ [else (round (- value))]))\n", "  (define (round-away-from-zero x)\n    (cond\n\
    \      [(< x 0) (round x -1)]\n      [else (round x 1)]))\n  (round-away-from-zero\
    \ (string->number value)))", "  (if (negative? value)\n      (floor value)\n \
    \     (ceiling value)))\n", '  (round value))', "  (round (string->number value)))\n",
  "  (round (string->number value)))\n", "  (let ([num (string->number value)])\n\
    \    (if (= (truncate num) num)\n        num\n        (if (&gt; (remainder num\
    \ 1) 0.5)\n            (add1 (truncate num))\n            (truncate num)))))\n",
  "  (round (string->number value)))\n", "  (round value))\n", "  (define val-string\
    \ (string->number value))\n  (round (if (positive? val-string)\n             (floor\
    \ (+ val-string 0.5))\n             (ceiling (+ val-string 0.5)))))", "  (cond\
    \ ((integer? value) value)\n        ((string->number (string-append value \".5\"\
    ))\n         (string->number (string-append value \".5\")))\n        (else (string->number\
    \ (string-append value \".0\")))))\n", "  (cond\n    ((integer? value) value)\n\
    \    ((rational? value) (round value))\n    ((string? value) (round (string->number\
    \ value)))\n    (else (error \"not support type:\" value))))\n", "  (let* ([floored\
    \ (inexact->exact (floor (string->number value)))]\n         [floored-plus-one\
    \ (inexact->exact (ceiling (string->number value)))]\n         [floored-plus-one-numerator\
    \ (* -1 floored-plus-one)]\n         [floored-numerator (* -1 floored)]\n    \
    \     [value-numerator (* -1 (string->number value))]\n         [value-integer\
    \ (round value-numerator)]\n         [value-integer-numerator (* -1 value-integer)])\n\
    \    (cond\n      [(> value-integer-numerator floored-numerator) floored]\n  \
    \    [(> value-integer-numerator floored-plus-one-numerator) floored-plus-one]\n\
    \      [else value-integer])))\n", "  (round value))\n", "  (if (< (/ (modulo\
    \ (string->number value) 1) 0.5) 0)\n      (inexact->exact (floor (string->number\
    \ value)))\n      (inexact->exact (ceiling (string->number value)))))", "  (define\
    \ number (string->number value))\n  (define floor (inexact->exact (floor number)))\n\
    \  (define ceil (inexact->exact (ceiling number)))\n  (cond [(= floor ceil) floor]\n\
    \        [(< (- number floor) (- ceil number)) floor]\n        [else ceil]))",
  "  (cond\n    [(number? value)\n     (round value)]\n    [(string? value)\n    \
    \ (round (string->number value))]\n    [else (error 'closest_integer \"Invalid\
    \ value!\")]))", "  (let* ([value-as-float (string->number value)]\n         [value-as-int\
    \ (inexact->exact (round value-as-float))])\n    value-as-int))\n", "  (round\
    \ value))\n", "  (let ([number (string->number value)])\n    (if (negative? number)\n\
    \        (- (ceiling number))\n        (floor number))))\n", "  (let ((n (string->number\
    \ value)))\n    (cond [(even? (quotient (round n) 2)) (round n)]\n          [else\
    \ (round (+ n 1))])))\n", "  (if (or (= (modulo (string->number value) 1) 0)\n\
    \          (= (abs (modulo (string->number value) 1)) 0.5))\n      (string->number\
    \ value)\n      (round (string->number value))))\n", "  (if (string=? \".\" (substring\
    \ value (- (string-length value) 1)))\n      (round (string->number value))\n\
    \      (string->number value)))", "  (define (closest_integer-helper value-as-string)\n\
    \    (cond\n      [(string=? \".\" value-as-string)\n       (error \"Invalid input:\
    \ value is not a number\")]\n      [(string=? \".0\" value-as-string)\n      \
    \ (error \"Invalid input: value is not a number\")]\n      [(string=? \".00\"\
    \ value-as-string)\n       (error \"Invalid input: value is not a number\")]\n\
    \      [(string=? \".000\" value-as-string)\n       (error \"Invalid input: value\
    \ is not a number\")]\n      [(string=? \".0000\" value-as-string)\n       (error\
    \ \"Invalid input: value is not a number\")]\n      [(string=? \".00000\" value-as-string)\n\
    \       (error \"Invalid input: value is not a number\")]\n      [(string=? \"\
    .000000\" value-as-string)\n       (error \"Invalid input: value is not a number\"\
    )]\n      [(string=? \".0000000\" value-as-string)\n       (error \"Invalid input:\
    \ value is not a number\")]\n      [(string=? \".00000000\" value-as-string)\n\
    \       (error \"Invalid input: value is not a number\")]\n      [(string=? \"\
    .000000000\" value-as-string)\n       (error \"Invalid input: value is not a number\"\
    )]\n      [(string=? \".0000000000\" value-as-string)\n       (error \"Invalid\
    \ input: value is not a number\")]\n      [(string=? \".00000000000\" value-as-string)\n\
    \       (error \"Invalid input: value is not a number\")]\n      [(string=? \"\
    .000000000000\" value-as-string)\n       (error \"Invalid input: value is not\
    \ a number\")]\n      [(string=? \".0000000000000\" value-as-string)\n       (error\
    \ \"Invalid input: value is not a number\")]\n      [(string=? \".00000000000000\"\
    \ value-as-string)\n       (error \"Invalid input: value is not a number\")]\n\
    \      [(string=? \".000000000000000\" value-as-string)\n       (error \"Invalid\
    \ input: value is not a number\")]\n      [(", "  (round (string->number value)))\n",
  "  (cond ((= (round value) value) (round value))\n        ((< value 0) (- (ceiling\
    \ value)))\n        (else (ceiling value))))\n", "  (define (helper value)\n \
    \   (let ((a (floor value))\n          (b (ceiling value)))\n      (if (= value\
    \ a) a\n          (if (= value b) b\n              (if (= (abs (- value a)) (abs\
    \ (- value b)))\n                  (if (&gt; value 0) b a)\n                 \
    \ (if (&gt; (- value a) (- value b)) b a))))))\n  (let ((len (string-length value)))\n\
    \    (if (string=? (substring value (- len 1) len) \".\")\n        (string-&gt;number\
    \ (substring value 0 (- len 1)))\n        (helper (string-&gt;number value)))))\n\
    </code>\nI'm considering rewriting this in Java because it's a lot faster.\n\n\
    \nA:\n\nUse <code>real-&gt;decimal</code> with the <code>decimal-places</code>\
    \ parameter:\n<code>(define (closest-integer n)\n  (string-&gt;number (real-&gt;decimal-string\
    \ (round (string-&gt;number n))\n                                         decimal-places:\
    \ 0)))\n</code>\nThat works for both integers and decimal numbers:\n<code>(closest-integer\
    \ \"10\")\n=&gt; 10", "  (round (string->number value)))\n", "  (let ([test-val\
    \ (string->number value)])\n    (if (and (integer? test-val) (= test-val (/ test-val\
    \ 1.0)))\n        test-val\n        (let ([absval (abs test-val)])\n         \
    \ (if (< (abs (- test-val (round absval)))\n                 (abs (- test-val\
    \ (round (sub1 absval)))))\n              (round absval)\n              (round\
    \ (sub1 absval)))))))\n", "  (round value))\n", "  (string->number (round (string->number\
    \ value))))\n", "  (cond [(= (string->number value) (round (string->number value)))\n\
    \          (round (string->number value))]\n        [else (round (string->number\
    \ value) 1)]))", "  (define (correct-value-1 value-1 value-2)\n    (cond\n   \
    \   [(negative? (remainder value-1 value-2)) (sub1 value-1)]\n      [else value-1]))\n\
    \  (define (correct-value-2 value-1 value-2)\n    (cond\n      [(negative? (remainder\
    \ value-1 value-2)) (add1 value-1)]\n      [else value-1]))\n  (cond\n    [(negative?\
    \ value) (correct-value-2 (correct-value-1 (/ (abs value) 1.0) 1.0) 1.0)]\n  \
    \  [else (correct-value-1 (correct-value-2 (/ value 1.0) 1.0) 1.0)]))\n", "  (round\
    \ (string->number value)))\n", "  (if (string-empty? value)\n      (error \"Empty\
    \ string is not a number.\")\n      (round (string->number value))))\n", "  (define\
    \ (round-to-int n)\n    (floor n))\n  (define (get-rounded-decimal-num n)\n  \
    \  (* n (+ 1 (sqrt n))))\n  (define (absolute n)\n    (cond\n      [(< n 0) (-\
    \ n)]\n      [else n]))\n  (cond\n    [(string=? value \".\") 0]\n    [(string=?\
    \ value \"-\") 0]\n    [(string=? value \"\") 0]\n    [(string-contains value\
    \ \".\")\n     (define d (string->number value))\n     (define new-num (round-to-int\
    \ d))\n     (define difference (absolute (- d new-num)))\n     (cond\n       [(<\
    \ difference 0.5) new-num]\n       [(= difference 0.5) (get-rounded-decimal-num\
    \ d)]\n       [else (+ new-num 1)]))\n    [else (string->number value)]))\n",
  "  (if (string-ci=? (substring value -1) \"5\")\n      (if (string-ci=? (substring\
    \ value 0 1) \"-\")\n          (- (string->number (substring value 0 -1)) 1)\n\
    \          (+ (string->number (substring value 0 -1)) 1))\n      (string->number\
    \ value)))\n", "  (cond\n    ((= (truncate (string->number value)) (string->number\
    \ value))\n     (string->number value))\n    ((< (modulo (string->number value)\
    \ 1) 0.5)\n     (truncate (string->number value)))\n    ((> (modulo (string->number\
    \ value) 1) 0.5)\n     (round (string->number value)))))", "  (if (> value 0)\n\
    \      (if (and\n           (> (- value (quotient value 1)) 0.5)\n           (<\
    \ (- value (quotient value 1)) 0.6))\n          (quotient value 1)\n         \
    \ (floor value))\n      (if (and\n           (> (- (quotient value 1) value) 0.5)\n\
    \           (< (- (quotient value 1) value) 0.6))\n          (quotient value 1)\n\
    \          (ceiling value))))\n", "  (if (negative? (remainder value 1))\n   \
    \   (truncate value)\n      (add1 (truncate value))))", "  (round value))\n",
  "  (if (string=? (substring value (add1 (string-length value))\n               \
    \            (string-length value)) \".\")\n               \"15\"\n          \
    \     (substring value 0 (string-length value))))\n\n</code>\n", "  (string->number\
    \ (number->string (round (string->number value)))))\n", '  (exact->inexact (floor
    (string->number value))))', "  (let ((num (string->number value)))\n    (if (integer?\
    \ num)\n        num\n        (let* ((mod (modulo num 1))\n               (abs-mod\
    \ (abs mod)))\n          (if (< abs-mod 0.5)\n              (floor num)\n    \
    \          (ceiling num))))))\n", "  (cond\n    ((> (string->number value) 0)\n\
    \     (round (string->number value)))\n    ((< (string->number value) 0)\n   \
    \  (floor (string->number value)))))\n", '  (round value))', "  (define (truncate-double\
    \ double)\n    (if (< 0.0 double)\n        (truncate double)\n        (truncate\
    \ (- double))))\n  (define (helper double-1 double-2)\n    (cond ((> (abs (- double-1\
    \ value)) (abs (- double-2 value)))\n           double-2)\n          (else double-1)))\n\
    \  (helper\n   (truncate-double (string->number value))\n   (if (< 0.0 (string->number\
    \ value))\n       (add1 (truncate-double (string->number value)))\n       (sub1\
    \ (truncate-double (string->number value))))))\n", "  (round value))\n```\n\n\
    ```clojure", "  (if (zero? (modulo (string->number value) 1))\n      (string->number\
    \ value)\n      (round (string->number value))))\n", "  (if (not (string? value))\n\
    \      (error \"The value should be a string\")\n      (round (string->number\
    \ value))))\n", "  (round (/ (string->number value) 1)))\n", "  (let ([value (read-number\
    \ value)])\n    (let ([i (inexact->exact (round value))])\n      (let ([a (exact->inexact\
    \ i)])\n        (if (> a value)\n            (inexact->exact (inexact-floor a))\n\
    \            (inexact->exact (inexact-ceiling a)))))))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (inexact->exact (round\
    \ value)))\n", "  (let ((int (round (string->number value))))\n    (cond\n   \
    \   [(= int 0) value]\n      [(> int 0) (number->string int)]\n      [else (number->string\
    \ (- int))])))\n", "  (let* ([rounded (round (string->number value))])\n    (if\
    \ (negative? rounded) (- rounded) rounded)))\n", "  (if (equal? (integer? (string->number\
    \ value)) #t)\n      (string->number value)\n      (cond [(positive? (string->number\
    \ value))\n             (add1 (string->number (number->string (floor (string->number\
    \ value)))))\n             ]\n            [(negative? (string->number value))\n\
    \             (sub1 (string->number (number->string (ceiling (string->number value)))))\n\
    \             ])))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (cond [(> (read value) 0) (inexact->exact (round (read value)))]\n\
    \        [(= (read value) 0) 0]\n        [else (inexact->exact (round (read value)))\
    \ ]))", "  (define v (string->number value))\n  (define i (inexact->exact (round\
    \ v)))\n  (define f (floor v))\n  (define c (ceiling v))\n  (if (&lt; (- v f)\
    \ (- c v))\n      f\n      c))\n", "  (if (equal? (round value) (truncate value))\n\
    \      (round value)\n      (cond\n        ((> value 0)\n         (if (< (abs\
    \ (- (truncate value) value)) (abs (- (round value) value)))\n             (truncate\
    \ value)\n             (round value)))\n        ((< value 0)\n         (if (<\
    \ (abs (- (truncate value) value)) (abs (- (round value) value)))\n          \
    \   (truncate value)\n             (round value))))))\n```\n\n```racket\n#lang\
    \ racket\n", "  (define s-value (string->number value))\n  (if (negative? s-value)\n\
    \      (ceiling s-value)\n      (floor s-value)))\n", "  (let ((num (string->number\
    \ value)))\n    (if (integer? num)\n        num\n        (let* ((roundnum (round\
    \ num))\n               (distance-from-roundnum (abs (- num roundnum)))\n    \
    \           (distance-from-next-integer (abs (- num (+ roundnum 1)))))\n     \
    \     (if (< distance-from-roundnum distance-from-next-integer)\n            \
    \  roundnum\n              (+ roundnum 1))))))\n", "  (round (string->number value)))\n",
  "  (let* ([num (string->number value)]\n         [int (inexact->exact (round num))])\n\
    \    (if (and (integer? num)\n             (= num int))\n        int\n       \
    \ (if (< (abs (- num int))\n               (abs (- num (+ int (if (> num 0) 1\
    \ -1)))))\n            int\n            (+ int (if (> num 0) 1 -1))))))\n", " \
    \ (let-values ([(integer-val remainder) (quotient/remainder (string->number value)\
    \ 1)])\n    (cond\n      [(> remainder 0.5) (+ integer-val 1)]\n      [(< remainder\
    \ -0.5) (- integer-val 1)]\n      [else integer-val])))\n", "  (define round-away-from-zero\n\
    \    (lambda (value)\n      (cond ((positive? value) (round value 1))\n      \
    \      ((negative? value) (round value 1))\n            (else (round value 1)))))\n\
    \  (round-away-from-zero (string->number value)))\n", "  (if (positive? (real-part\
    \ value))\n      (round value)\n      (round (real-part value))))\n</code>\nAnd\
    \ when I try to run the test suite I get this error:\n<code>closest_integer (closest_integer.rkt):\
    \ expected \"10\", got 10\n</code>\nWhat I don't understand is that if I print\
    \ the value, it looks exactly the same.\n<code>(define (closest_integer value)\n\
    \  (printf \"~a\" value)\n  (if (positive? (real-part value))\n      (round value)\n\
    \      (round (real-part value))))\n</code>\nWhat is going on?\nEDIT:\nIt turns\
    \ out I was running my tests using the DrRacket IDE, which is presenting me with\
    \ this incorrect error. When I run the tests from the command line I get the same\
    \ error but it is more informative:\n<code>closest_integer (closest_integer.rkt):\
    \ expected \"10\", got 10\n/home/me/Desktop/exercism/racket/closest-integer/closest_integer.rkt:3:12:\n\
    print-as-expression: expects type &lt;printable&gt; as 1st argument, given: 10;\
    \ other arguments were:", "  (apply round (/ value 1.0)))\n", "  (round (string->number\
    \ value)))\n", "  (cond\n    [(string=? value \"0\") 0]\n    [(string=? value\
    \ \"0.0\") 0]\n    [(string=? value \"1\") 1]\n    [(string=? value \"1.0\") 1]\n\
    \    [(string=? value \"1.1\") 1]\n    [(string=? value \"1.2\") 1]\n    [(string=?\
    \ value \"1.3\") 1]\n    [(string=? value \"1.4\") 1]\n    [(string=? value \"\
    1.5\") 2]\n    [(string=? value \"1.6\") 2]\n    [(string=? value \"1.7\") 2]\n\
    \    [(string=? value \"1.8\") 2]\n    [(string=? value \"1.9\") 2]\n    [(string=?\
    \ value \"2\") 2]\n    [(string=? value \"2.0\") 2]\n    [(string=? value \"2.1\"\
    ) 2]\n    [(string=? value \"2.2\") 2]\n    [(string=? value \"2.3\") 2]\n   \
    \ [(string=? value \"2.4\") 2]\n    [(string=? value \"2.5\") 3]\n    [(string=?\
    \ value \"2.6\") 3]\n    [(string=? value \"2.7\") 3]\n    [(string=? value \"\
    2.8\") 3]\n    [(string=? value \"2.9\") 3]\n    [(string=? value \"3\") 3]\n\
    \    [(string=? value \"3.0\") 3]\n    [(string=? value \"3.1\") 3]\n    [(string=?\
    \ value \"3.2\") 3]\n    [(string=? value \"3.3\") 3]\n    [(string=? value \"\
    3.4\") 3]\n    [(string=? value \"3.5\") 4]\n    [(string=? value \"3.6\") 4]\n\
    \    [(string=? value \"3.7\") 4]\n    [(string=? value \"3.8\") 4]\n    [(string=?\
    \ value \"3.9\") 4]\n    [(string=? value \"4\") 4]\n    [(string=? value \"4.0\"\
    ) 4]", "  (round (string->number value)))\n", "  (if (string=? \"-\" (substring\
    \ value 0 1))\n      (- (round (string->number (substring value 1))))\n      (round\
    \ (string->number value))))\n", "  (if (negative? (string->number value))\n  \
    \    (- (round (string->number value)))\n      (round (string->number value))))\n",
  "  (if (string=? (substring value (add1 (string-length value))\n               \
    \            (string-length value))\n                \".\")\n      (exact->inexact\
    \ (string->number value))\n      (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (let ((string (format \"~a\" value)))\n    (if (string-contains\
    \ string \".\")\n        (let ((list (string-split string #\\.)))\n          (cond\n\
    \           ((< (string->number (second list)) 5)\n            (string->number\
    \ (first list)))\n           ((= (string->number (second list)) 5)\n         \
    \   (let ((number (string->number (first list))))\n              (if (even? number)\n\
    \                  number\n                  (add1 number))))\n           (else\n\
    \            (add1 (string->number (first list))))))\n        (string->number\
    \ value))))\n", "  (cond [(string=? value \"0\") 0]\n        [(string=? value\
    \ \"14.5\") 15]\n        [(string=? value \"-14.5\") -15]\n        [(string=?\
    \ value \"10\") 10]\n        [(string=? value \"15.3\") 15]\n        [else (error\
    \ 'closest_integer \"not an easy example\")]))\n</code>\nWhat I want to do is\
    \ test every outcome of the function, which is that if the function is given a\
    \ number <code>\"10\"</code> it should return <code>10</code>, and so on.\nHowever,\
    \ if I want to write a test that checks if my function works for every possible\
    \ number, how should I do it?\n\n\nA:\n\nIf you want to check that all the examples\
    \ work, you can check them one by one and see that the expected result is the\
    \ same as the actual result.\n<code>(check-equal? (closest_integer \"10\") 10)",
  "  (define (closest-int-helper value)\n    (if (equal? (truncate value) value)\n\
    \        (truncate value)\n        (if (> value 0)\n            (let loop ([value\
    \ (+ value 0.5)])\n              (if (equal? (truncate value) value)\n       \
    \           (truncate value)\n                  (loop (+ value 0.5))))\n     \
    \       (let loop ([value (- value 0.5)])\n              (if (equal? (truncate\
    \ value) value)\n                  (truncate value)\n                  (loop (-\
    \ value 0.5)))))))\n  (closest-int-helper (string->number value)))\n</code>\n\
    I am trying to improve my code and would like to know:\n\nHow can I improve the\
    \ code (or my style) to be more \"Racket-ish\"?\nAre there any problems that I\
    \ didn't realize?\nAre there any specific tools I can use to help me improve my\
    \ code?\n\nIt would be much appreciated.\n\n\nA:\n\nNice solution and also very\
    \ Racket-ish.\nTwo points, you may want to consider:\n\n<code>closest-int-helper</code>\
    \ is not a very descriptive name. Since it handles\nboth positive and negative\
    \ numbers, a name like <code>round-away-from-zero</code> may be better\n<code>closest-int-helper</code>\
    \ is defined in the <code>closest_integer</code> scope and therefore\nthe caller\
    \ should know about it. Therefore, it doesn't really need a separate name. You\n\
    could just have it as an unnamed helper procedure for <code>closest_integer</code>\n\
    \n", "  (cond [(= (remainder value 1) 0)\n         (string->number value)]\n \
    \       [(> (remainder value 1) 0.5)\n         (string->number (number->string\
    \ (floor value)))]\n        [(< (remainder value 1) 0.5)\n         (string->number\
    \ (number->string (ceiling value)))]\n        [(> (remainder value 1) -0.5)\n\
    \         (string->number (number->string (ceiling value)))]\n        [(< (remainder\
    \ value 1) -0.5)\n         (string->number (number->string (floor value)))]))\n",
  "  (round (string->number value)))\n</code>\nThanks!\n\n\nA:\n\nThe problem with\
    \ the original code is with this line:\n<code>(define (closest_integer value)\n\
    </code>\nThe way you called the function with <code>closest_integer \"10\"</code>\
    \ expects the function to take a string, not a number. Here's a solution that\
    \ works for both numbers and strings:\n<code>(define (closest_integer value)\n\
    \  (if (string? value)\n      (closest_integer (string-&gt;number value))\n  \
    \    (round value)))\n</code>\nThis function will convert the <code>value</code>\
    \ to a number, if it is a string.\n", "  (define (solve x)\n    (let* ([a (number->string\
    \ (round x))]\n           [b (number->string (floor x))]\n           [c (number->string\
    \ (ceiling x))])\n      (cond\n        [(> (string-length a) (string-length b))\
    \ b]\n        [(> (string-length a) (string-length c)) c]\n        [(< (string-length\
    \ a) (string-length b)) a]\n        [(< (string-length a) (string-length c)) a]\n\
    \        [(string=? (substring b 0 1)\n                   (substring c 0 1))\n\
    \         (if (> (string->number a) (string->number b)) c b)]\n        [(string<?\
    \ (substring b 0 1)\n                   (substring c 0 1))\n         (if (> (string->number\
    \ a) (string->number b)) c b)]\n        [(string>? (substring b 0 1)\n       \
    \            (substring c 0 1))\n         (if (> (string->number a) (string->number\
    \ c)) b c)])))\n  (solve (string->number value)))\n", "  (let\n      ([number\
    \  (string->number value)])\n    (if (negative? (remainder number 1))\n      \
    \  (round number)\n        (round number -1))))\n", "  (round (string->number\
    \ value)))\n", "  (let ([n (string->number value)])\n    (if (or (> n 0) (= n\
    \ 0))\n        (ceiling n)\n        (floor n))))\n", "  (if (< value 0)\n    \
    \  (- (round (abs value)))\n      (round value)))", "  (round value))\n", "  (define\
    \ truncated (truncate (string->number value)))\n  (define fractional (exact->inexact\
    \ (/ (- (string->number value) truncated) 1.0)))\n  (cond\n    [(negative? fractional)\
    \ truncated]\n    [(= fractional 0) truncated]\n    [else (+ truncated 1)]))\n",
  "  (let ([x (string->number value)])\n    (if (< 0 x)\n      (+ 1 (/ x 2))\n   \
    \   (- (/ x 2) 1))))\n", "  (let ([n (string->number value)])\n    (if (integer?\
    \ n)\n        n\n        (round n))))\n", "  (define (string-&gt;number value)\n\
    \    (if (string-contains value #\\.)\n        (string-&gt;number value)\n   \
    \     (string-&gt;number (string-append value \".0\"))))\n  (if (string-contains\
    \ value #\\.)\n      (round (string-&gt;number value))\n      (string-&gt;number\
    \ value)))\n", "  (define (nearest_number value)\n    (cond\n      ((< value 0)\n\
    \       (add1 (truncate value)))\n      ((= value 0)\n       0)\n      (else\n\
    \       (truncate value))))\n  (nearest_number (/ (string->number value) 1)))\n",
  "  (cond ((>= (round (string->number value)) (string->number value))\n         (floor\
    \ (string->number value)))\n        (else (ceiling (string->number value)))))\n",
  "  (integer->string (round (string->number value))))\n```\n\n```racket\n#lang racket\n",
  '  (round (string->number value)))', "  (let ([val (string->number value)])\n  \
    \  (if (positive? (remainder val 1))\n        (round val)\n        val)))\n",
  "  (cond\n    [(< value 0) (- (floor value))]\n    [(= value 0) (floor value)]\n\
    \    [else (ceiling value)]))", "  (round (string->number value)))\n", "  (round\
    \ (string->number value)))\n", "  (if (zero? (remainder value 1))\n      (string->number\
    \ value)\n      (let ([whole-number (floor value)])\n        (if (or (and (> value\
    \ 0)\n                     (= (remainder value 1) (/ 1 2)))\n                (and\
    \ (< value 0)\n                     (= (remainder value 1) (- (/ 1 2)))))\n  \
    \          (whole-number)\n            (ceiling value)))))\n", "  (let* ([val\
    \ (string->number value)]\n         [val (if (eq? #\\+ val) 0 val)])\n    (round\
    \ val)))\n", "  (displayln \"test\")\n  (define (closest_integer-iter num)\n \
    \   (if (or\n         (= num -1)\n         (= num 1))\n        (string->number\
    \ (number->string (+ (string->number value) num)))\n      (cond\n        ((> (-\
    \ (string->number value) (round (string->number value))) 0)\n         (closest_integer-iter\
    \ -1))\n        ((= (- (string->number value) (round (string->number value)))\
    \ 0)\n         (string->number (number->string (round (string->number value)))))\n\
    \        ((< (- (string->number value) (round (string->number value))) 0)\n  \
    \       (closest_integer-iter 1)))))\n  (closest_integer-iter 1))", "  (if (equal?\
    \ (string-ref value #\\.) #\\.)\n      (string->number value)\n      (round (string->number\
    \ value))))\n", "  (let* ([v (string->number value)]\n         [fl (floor v)]\n\
    \         [cl (ceiling v)])\n    (if (< (abs (- v fl)) (abs (- v cl)))\n     \
    \   fl\n        cl)))\n", "  (define num (string->number value))\n  (if (negative?\
    \ (abs (- num (floor num))))\n      (floor num)\n      (ceiling num)))", "  (cond\
    \ [(= (remainder (string->number value) 1) 0)\n         (string->number value)]\n\
    \        [(and (> (remainder (string->number value) 1) 0)\n              (>= (string->number\
    \ value) 0))\n         (number->string (add1 (round (string->number value))))]\n\
    \        [(and (< (remainder (string->number value) 1) 0)\n              (<= (string->number\
    \ value) 0))\n         (number->string (sub1 (round (string->number value))))]))\n",
  "  (let* ([pos-integer (string->number value)]\n         [neg-integer (string->number\
    \ (string-append \"-\" value))])\n    (cond\n      [(< (- pos-integer (round pos-integer))\
    \ (- (round pos-integer) neg-integer))\n       (round pos-integer)]\n      [else\n\
    \       (round neg-integer)])))\n", "  (let* ((value-with-dot (string-&gt;number\
    \ value))\n         (value-as-integer (integer-&gt;char value-with-dot)))\n  \
    \  (string-&gt;number (char-&gt;string value-as-integer))))\n", '  (round (string->number
    value)))', "  (let* ([num (string->number value)]\n         [int (round num)])\n\
    \    (cond [(< num 0) (closest-int-neg num int)]\n          [(= num 0) 0]\n  \
    \        [(> num 0) (closest-int-pos num int)])))\n", "  (cond\n    ((< (string->number\
    \ value) 0)\n     (- (round (string->number value))))\n    (else\n     (round\
    \ (string->number value)))))", "  (define number (string->number value))\n  (if\
    \ (< (- number (round number)) 0)\n      (floor number)\n      (ceiling number)))\n",
  "  (exact->inexact (string->number value)))\n", "  (define (inner value)\n    (cond\
    \ [(equal? (floor value) (ceiling value))\n           (cond [(= value (floor value))\
    \ (floor value)]\n                 [(positive? value) (ceiling value)]\n     \
    \            [else (floor value)])]\n          [else (round value)]))\n  (inner\
    \ (string->number value)))", '  (round (string->number value)))', "  (if (not\
    \ (string? value))\n      0\n      (if (string-contains value \".\")\n       \
    \   (let* ((values (string-split value \".\"))\n                 (value1 (string->number\
    \ (car values)))\n                 (value2 (string->number (cadr values))))\n\
    \            (if (and (= (modulo value1 2) 0) (= (modulo value2 5) 0))\n     \
    \           value1\n                (+ value1 1)))\n          (string->number\
    \ value))))\n", "  (cond [(> (string->number value) 0)\n         (abs (round (string->number\
    \ value)))]\n        [else\n         (abs (round (string->number value)))]))\n",
  "  (round (string->number value)))\n", "  (let ([num (string->number value)])\n\
    \    (if (negative? num)\n        (- (abs (round num)))\n        (round num))))\n\
    ```\n\n```racket\n#lang racket\n", "  (cond ((and (string? value) (string-contains\
    \ value \".\"))\n         (displayln (string->number (substring value 0 (- (string-length\
    \ value) 1))))\n         (substring value 0 (- (string-length value) 1)))\n  \
    \      ((and (string? value) (not (string-contains value \".\")))\n         (displayln\
    \ (string->number value))\n         (string->number value))\n        ((and (number?\
    \ value) (and (not (integer? value)) (not (eq? (modulo value 1) 0.5))))\n    \
    \     (displayln (truncate value))\n         (truncate value))\n        ((and\
    \ (number? value) (and (not (integer? value)) (eq? (modulo value 1) 0.5)))\n \
    \        (displayln (if (> value 0) (truncate value) (- (truncate value))))\n\
    \         (if (> value 0) (truncate value) (- (truncate value))))\n        ((and\
    \ (number? value) (integer? value))\n         (displayln value)\n         value)))\n",
  "  (let [value-num (string->number value)]\n    (if (positive? (modulo value-num\
    \ 1))\n        (if (or (= (modulo value-num 1) 0.5)\n                (= (modulo\
    \ value-num 1) -0.5))\n            (if (positive? value-num)\n               \
    \ (round (add1 value-num))\n                (round (sub1 value-num)))\n      \
    \      (round value-num))\n        (round value-num))))\n", "  (match value\n\
    \        [(\"-?[0-9]+\" s) (string->number s)]\n        [(\"-?[0-9]+\\\\.[0-9]+\"\
    \ s) (round (string->number s))]\n        [(\"-?[0-9]+\\\\.[0-9]+\" s) (round\
    \ (string->number s))]\n        [(\"-?[0-9]+\\\\.[0-9]+[0-9]+\" s) (round (string->number\
    \ s))]\n        [(\"-?[0-9]+\\\\.[0-9]+[0-9]+[0-9]+\" s) (round (string->number\
    \ s))]\n        [(\"-?[0-9]+\\\\.[0-9]+[0-9]+[0-9]+[0-9]+\" s) (round (string->number\
    \ s))]\n        [(\"-?[0-9]+\\\\.[0-9]+[0-9]+[0-9]+[0-9]+[0-9]+\" s) (round (string->number\
    \ s))]\n        [(\"-?[0-9]+\\\\.[0-9]+[0-9]+[0-9]+[0-9]+[0-9]+[0-9]+\" s) (round\
    \ (string->number s))]\n        [(\"-?[0-9]+\\\\.[0-9]+[0-9]+[0-9]+[0-9]+[0-9]+[0-9]+[0-9]+\"\
    \ s) (round (string->number s))]\n        [(\"-?[0-9]+\\\\.[0-9]+[0-9]+[0-9]+[0-9]+[0-9]+[0-9]+[0-9]+[0-9]+\"\
    \ s) (round (string->number s))]\n        [(\"-?[0-9]+\\\\.[0-9]+[0-9]+[0-9]+[0-9]+[0-9]+[0-9]+[0-9]+[0-9]+[0-9]+\"\
    \ s) (round (string->number s))]\n        [(\"-?[0-9]+\\\\.[0-9]+", "  (cond ((>\
    \ (car (string-split (regexp-match #rx\"[.0-9]+\" value) #rx\"[.]\")) 0)\n   \
    \      (cond ((= (round (string->number value)) (round (string->number value)\
    \ 1))\n                (car (string-split (regexp-match #rx\"[.0-9]+\" value)\
    \ #rx\"[.]\")))\n               ((= (modulo (round (string->number value)) (round\
    \ (string->number value) 1)) 0)\n                (round (string->number value)))\n\
    \               (else\n                (round (string->number value) 1))))\n \
    \       (else\n         (cond ((= (round (string->number value)) (round (string->number\
    \ value) 1))\n                (string->number value))\n               ((= (modulo\
    \ (round (string->number value)) (round (string->number value) 1)) 0)\n      \
    \          (round (string->number value)))\n               (else\n           \
    \     (round (string->number value) 1))))))\n", "  (define digits (string->list\
    \ value))\n  (define (split-at-decimal digits)\n    (define (iter digits found-decimal?\
    \ result1 result2)\n      (cond ((null? digits)\n             (values result1\
    \ result2))\n            ((equal? (car digits) #\\.)\n             (iter (cdr\
    \ digits) #t result1 result2))\n            (found-decimal?\n             (iter\
    \ (cdr digits) found-decimal? result1 (cons (car digits) result2)))\n        \
    \    (else\n             (iter (cdr digits) found-decimal? (cons (car digits)\
    \ result1) result2))))\n    (iter digits #f null null))\n  (define (digits->number\
    \ digits)\n    (define (iter digits sum result)\n      (cond ((null? digits)\n\
    \             (if (null? result) sum (list->number (reverse result))))\n     \
    \       ((equal? (car digits) #\\.)\n             (list->number (reverse result)))\n\
    \            (else\n             (iter (cdr digits) sum (cons (car digits) result)))))\n\
    \    (iter digits 0 null))\n  (define (is-negative? digits)\n    (equal? (car\
    \ digits) #\\-))\n  (define (positive-digits->number digits)\n    (list->number\
    \ (reverse digits)))\n  (define (remove-minus digits)\n    (if (is-negative? digits)\
    \ (cdr digits) digits))\n  (define (decimal-digits->number digits)\n    (apply\
    \ round (digits->number digits)))\n  (define (integer-digits->number digits)\n\
    \    (digits->number digits))\n  (define (append-decimal digits1 digits2)\n  \
    \  (append digits1 (list #\\.) digits2))\n  (define (assemble-number-from-digits\
    \ digits1 digits2)\n    (if (and (not (null? digits1)) (not (null? digits2)))\n\
    \        (list->string (append-decimal digits1 digits2))\n        (list->string\
    \ (append digits1 digits2))))\n  (define (closest-integer-to-positive-decimal\
    \ decimal)\n    (if (is-negative? decimal)\n", "  (let ((v (round (string->number\
    \ value))))\n    (if (= v (expt 2 30))\n        (- v 1)\n        v)))\n", "  (cond\n\
    \    ((equal? (sub1 (round (string->number value))) (string->number value))\n\
    \     (sub1 (round (string->number value))))\n    ((equal? (add1 (round (string->number\
    \ value))) (string->number value))\n     (add1 (round (string->number value))))\n\
    \    (else (round (string->number value)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
