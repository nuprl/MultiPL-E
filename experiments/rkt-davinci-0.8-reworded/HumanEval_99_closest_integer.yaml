name: HumanEval_99_closest_integer
language: rkt
prompt: "#lang racket\n\n;; Create a function that takes a value (string) representing\
  \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
  ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
  \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
  \ away from zero means that if the given number is equidistant\n;; from two integers,\
  \ the one you should return is the one that is the\n;; farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\n(define (closest_integer value)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
  \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
  ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
  \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
completions: ["  (round (/ (+ (string->number value) 0.5) 1)))\n</code>\n", "  (let*\
    \ ((value (string->number value))\n         (value-integral-part (inexact->exact\
    \ (truncate value)))\n         (value-fractional-part (- value value-integral-part)))\n\
    \    (cond\n      ((>= value-fractional-part 0.5) (+ value-integral-part 1))\n\
    \      ((<= value-fractional-part -0.5) (- value-integral-part 1))\n      (else\
    \ value-integral-part))))\n", "  (if (negative? (string->number value))\n    \
    \  (- (round (string->number value)))\n      (round (string->number value))))\n",
  "  (if (integer? value) value\n      (if (= (floor (round value)) (ceiling (round\
    \ value)))\n          (if (< (round value) 0) (floor (round value)) (ceiling (round\
    \ value)))\n          (if (< value 0) (floor (round value)) (ceiling (round value))))))\n",
  "  (string->number (string-append (number->string (exact->inexact (round (string->number\
    \ value)))))))\n", "  (define (closest_integer-inner value acc)\n    (cond [(string=?\
    \ \".\" (substring value 0 1)) (closest_integer-inner (string-append \"0\" value)\
    \ acc)]\n          [(string=? \"-\" (substring value 0 1)) (closest_integer-inner\
    \ (substring value 1) (cons \"-\" acc))]\n          [(string=? \"+\" (substring\
    \ value 0 1)) (closest_integer-inner (substring value 1) acc)]\n          [(string=?\
    \ \"\" value) (apply number-&gt;string (reverse acc))]\n          [(&gt; (string-&gt;number\
    \ (substring value 0 1)) 4) (closest_integer-inner (substring value 1) (cons \"\
    5\" acc))]\n          [else (closest_integer-inner (substring value 1) (cons \"\
    0\" acc))]))\n  (closest_integer-inner value '()))\n", "  (if (positive? (string->number\
    \ value))\n      (inexact->exact (round (string->number value)))\n      (inexact->exact\
    \ (round (string->number value)))))\n", "  (cond ((= 0.0 value) 0)\n        ((=\
    \ 0.5 value) 1)\n        ((= -0.5 value) -1)\n        ((&gt; value 0) (inexact-&gt;exact\
    \ (floor value)))\n        ((&lt; value 0) (inexact-&gt;exact (ceiling value)))))\n",
  "  (cond [(< value 0) (- (round (abs value)))]\n        [else (round value)]))\n",
  "  (exact->inexact (round (string->number value))))\n", "  (apply round (list value)))\n\
    ```\n\n```racket", "  (define (extract_sign value)\n    (cond\n      [(string=?\
    \ value \"0\")]\n      [(string-index value #\\-) -1]\n      [else 1]))\n  (define\
    \ (abs-string str)\n    (if (string=? str \"0\")\n        \"0\"\n        (if (string-index\
    \ str #\\-)\n            (string-drop str 1)\n            str)))\n  (define (drop-dot\
    \ value)\n    (if (string-index value #\\.)\n        (string-drop value (add1\
    \ (string-index value #\\.)))\n        value))\n  (define (normalize-digits value)\n\
    \    (cond\n      [(< (string-length value) 2) value]\n      [(= (string-length\
    \ value) 2) (string-append \"0\" value)]\n      [else value]))\n  (define (dec-str\
    \ value)\n    (string-append\n     (normalize-digits\n      (drop-dot value))\n\
    \     \"0\"))\n  (define (inc-str value)\n    (string-append\n     (normalize-digits\n\
    \      (drop-dot value))\n     \"1\"))\n  (define (greater-than value1 value2)\n\
    \    (let ((val1 (string->number value1))\n          (val2 (string->number value2)))\n\
    \      (> val1 val2)))\n  (define (round-away-from-zero value)\n    (let ((sign\
    \ (extract-sign value)))\n      (if (string=? (abs-string value) \"0\")\n    \
    \      \"0\"\n          (if (string-index value #\\.)\n              (let ((digits\
    \ (drop-dot value)))\n                (if (greater-than digits \"5\")\n      \
    \              (number->string (round (string->number value)))\n             \
    \       (number->string (round (string->number value)))))\n              (if (greater-than\
    \ value \"5\")\n                  (number->string (+ sign 1))\n              \
    \    (number->string sign)))))))", "  (let* ([chunks (string-split value #\\.)]\n\
    \         [int (string->number (car chunks))]\n         [dec (string->number (cadr\
    \ chunks))])\n    (cond ((= dec 0) int)\n          ((&gt; dec 0) (+ int 1))\n\
    \          ((&lt; dec 0) (- int 1)))))\n</code>\nHere's the output of some Racket\
    \ tests:\n<code>&gt; (closest_integer \"10\")\n10\n&gt; (closest_integer \"15.3\"\
    )\n15\n&gt; (closest_integer \"15.5\")\n16\n&gt; (closest_integer \"14.5\")\n\
    15\n&gt; (closest_integer \"-14.5\")\n-15\n&gt; (closest_integer \"-14.5\")\n\
    -15\n&gt; (closest_integer \"-11.4\")\n-11\n&gt; (closest_integer \"-11.5\")\n\
    -12\n</code>\n", "  (define value-integer (round value))\n  (define value-real\
    \ (real-part value))\n  (if (or (and (= value-integer value-real) (> value-integer\
    \ 0))\n          (and (= value-integer value-real) (< value-integer 0)))\n   \
    \   value-integer\n      (if (> value-integer 0)\n          (add1 value-integer)\n\
    \          (sub1 value-integer))))\n", "  (round value))\n", "  (let* ([value\
    \ (string->number value)]\n         (x (quotient value 1))\n         (y (quotient\
    \ value 1.0)))\n    (if (= x y)\n        x\n        (if (>= value 0)\n       \
    \     (1+ x)\n            (1- x)))))\n", "  (define (float-abs x)\n    (if (&lt;\
    \ x 0) (- x) x))\n  (define (floor-to-int x)\n    (integer? x))\n  (define (ceiling-to-int\
    \ x)\n    (add1 (floor-to-int x)))\n  (define (integers-around x)\n    (list (floor-to-int\
    \ x) (ceiling-to-int x)))\n  (define (get-closest x y)\n    (if (&lt;= (float-abs\
    \ (- x (floor-to-int x)))\n             (float-abs (- x (ceiling-to-int x))))\n\
    \        (floor-to-int x)\n        (ceiling-to-int x)))\n  (get-closest (string-&gt;number\
    \ value) (integers-around (string-&gt;number value))))\n", "  (define int_value\n\
    \    (if (string-index value #\\.)\n        (substring value 0 (string-index value\
    \ #\\.))\n        value))\n  (define (trailing_decimal str)\n    (substring str\
    \ (string-index str #\\.) 1))\n  (cond\n    [(> (string->number (trailing_decimal\
    \ value)) .5)\n     (add1 (string->number int_value))]\n    [(< (string->number\
    \ (trailing_decimal value)) .5)\n     (string->number int_value)]\n    [(= (string->number\
    \ (trailing_decimal value)) .5)\n     (if (positive? (string->number value))\n\
    \         (add1 (string->number int_value))\n         (sub1 (string->number int_value)))]))\n",
  "  (if (exact-integer? value)\n      value\n      (round (string->number value))))\n",
  "  (define (abs x)\n    (if (< x 0)\n        (- x)\n        x))\n  (define (closest-integer-helper\
    \ n)\n    (if (not (integer? n))\n        (if (or (and (>= (abs (- n (inexact->exact\
    \ n)))\n                        (abs (- n (+ 1 (inexact->exact n)))))\n      \
    \               (< (abs (- n (inexact->exact n)))\n                        (abs\
    \ (- n (- 1 (inexact->exact n))))))\n                (and (<= (abs (- n (inexact->exact\
    \ n)))\n                        (abs (- n (+ 1 (inexact->exact n)))))\n      \
    \               (> (abs (- n (inexact->exact n)))\n                        (abs\
    \ (- n (- 1 (inexact->exact n)))))))\n            (+ (inexact->exact n) 1)\n \
    \           (- (inexact->exact n) 1))\n        n))\n  (cond ((integer? value)\n\
    \         value)\n        ((string? value)\n         (closest-integer-helper (string->number\
    \ value)))\n        ((number? value)\n         (closest-integer-helper value))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
