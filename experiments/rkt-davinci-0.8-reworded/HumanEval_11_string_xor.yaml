name: HumanEval_11_string_xor
language: rkt
prompt: "#lang racket\n\n;; Input are two strings a and b consisting only of 1s and\
  \ 0s.\n;; Perform binary XOR on these inputs and return result also as a string.\n\
  ;; >>> (string_xor \"010\" \"110\")\n;; \"100\"\n(define (string_xor a b)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_xor))\n\
  \    (check-equal? (candidate \"111000\" \"101010\") \"010010\")\n    (check-equal?\
  \ (candidate \"1\" \"1\") \"0\")\n    (check-equal? (candidate \"0101\" \"0000\"\
  ) \"0101\")\n))\n\n(test-humaneval)"
completions: ["  (assert (and (equal? (string-length a) (string-length b))\n     \
    \          (exact-positive-integer? (string-length a))))\n  (let ((n (string-length\
    \ a)))\n    (let loop ((i 0) (res (make-string n #\\space)))\n      (if (= i n)\n\
    \          res\n          (begin\n            (string-set! res i (integer->char\n\
    \                                (bitwise-xor (char->integer (string-ref a i))\n\
    \                                             (char->integer (string-ref b i)))))\n\
    \            (loop (+ i 1) res))))))\n", "  (let ([a-list (string->list a)]\n\
    \        [b-list (string->list b)])\n    (string-join (map (\u03BB (ab) (logxor\
    \ (car ab) (cadr ab))) (zip a-list b-list)))))\n", "  (let* ((a-bytes (string->bytes/utf-8\
    \ a))\n         (b-bytes (string->bytes/utf-8 b))\n         (num-chars (min (string-length\
    \ a) (string-length b)))\n         (xor-bytes (for/list ([ch-a (in-list a-bytes)])\n\
    \                       (for/list ([ch-b (in-list b-bytes)])\n               \
    \          (logxor ch-a ch-b)))))\n    (bytes->string (flatten xor-bytes))))\n",
  "  (let ([al (string-&gt;list a)]\n        [bl (string-&gt;list b)])\n    (map (lambda\
    \ (x y) (if (equal? x y) #\\0 #\\1)) al bl)))\n", "  (string-join\n   (apply string\n\
    \          (map (lambda (x y)\n                 (if (and x y)\n              \
    \       #\\0\n                     (if (or x y)\n                         #\\\
    1\n                         #\\0)))\n               (string-&gt;list a)\n    \
    \           (string-&gt;list b)))))\n", "  (cond\n    [(empty? a) b]\n    [(empty?\
    \ b) a]\n    [else (cons (char-upcase (integer->char (logxor (char->integer (string-ref\
    \ a 0)) (char->integer (string-ref b 0))))) (string_xor (substring a 1) (substring\
    \ b 1)))]))\n```\n\n```python\n# lang python\n\n# Input are two strings a and\
    \ b consisting only of 1s and 0s.\n# Perform binary XOR on these inputs and return\
    \ result also as a string.\n# >>> (string_xor \"010\" \"110\")\n# \"100\"\ndef\
    \ string_xor(a, b):\n    return str(int(a) ^ int(b))\n```\n\n```ruby\n# lang ruby\n\
    \n# Input are two strings a and b consisting only of 1s and 0s.\n# Perform binary\
    \ XOR on these inputs and return result also as a string.\n# >>> (string_xor \"\
    010\" \"110\")\n# \"100\"\ndef string_xor(a, b)\n  (a.to_i(2) ^ b.to_i(2)).to_s(2)\n\
    end\n```\n\n```rust\n// lang rust\n\n// Input are two strings a and b consisting\
    \ only of 1s and 0s.\n// Perform binary XOR on these inputs and return result\
    \ also as a string.\n// >>> (string_xor \"010\" \"110\")\n// \"100\"\nfn string_xor(a:\
    \ &str, b: &str) -> String {\n    let (a, b) = (a.parse::<u32>().unwrap(), b.parse::<u32>().unwrap());\n\
    \    format!(\"{:b}\", a ^ b)\n}\n```\n\n```go\n// lang go\n\n// Input are two\
    \ strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these\
    \ inputs and return result also as a string.\n// >>> (string_xor \"010\" \"110\"\
    )\n// \"100\"\npackage kata\n\nimport (\n\t\"strconv\"\n)\n\nfunc StringXor(a,\
    \ b string", "  (define (char-xor a b)\n    (cond\n      ((= a #\\0) b)\n    \
    \  ((= a #\\1) (cond\n                   ((= b #\\0) #\\1)\n                 \
    \  ((= b #\\1) #\\0)))\n      (else #\\0)))\n  (define (xor a b)\n    (cond\n\
    \      ((null? a) b)\n      ((null? b) a)\n      (else (cons (char-xor (car a)\
    \ (car b)) (xor (cdr a) (cdr b))))))\n  (string-join (xor (string->list a) (string->list\
    \ b))))\n", "  (cond [(and (equal? (first a) \"0\") (equal? (first b) \"0\"))\
    \ (cons \"0\" (string_xor (rest a) (rest b)))]\n        [(and (equal? (first a)\
    \ \"1\") (equal? (first b) \"1\")) (cons \"0\" (string_xor (rest a) (rest b)))]\n\
    \        [(and (equal? (first a) \"0\") (equal? (first b) \"1\")) (cons \"1\"\
    \ (string_xor (rest a) (rest b)))]\n        [(and (equal? (first a) \"1\") (equal?\
    \ (first b) \"0\")) (cons \"1\" (string_xor (rest a) (rest b)))]\n        [else\
    \ (cons \"0\" (string_xor (rest a) (rest b)))]))\n", "  (let ([alen (string-length\
    \ a)]\n        [blen (string-length b)])\n    (if (= blen alen)\n        (let\
    \ loop ([a a] [b b] [pos (- alen 1)] [rslt \"\"])\n          (cond [(zero? pos)\
    \ rslt]\n                [(string=? (substring a pos (+ pos 1))\n            \
    \               (substring b pos (+ pos 1)))\n                 (loop a b (- pos\
    \ 1) (string-append rslt \"0\"))]\n                [else (loop a b (- pos 1) (string-append\
    \ rslt \"1\"))]))\n        \"Inputs of different length.\")))", "  (string-join\
    \ (map (\u03BB (a b) (number->string (xor (string->number a) (string->number b))))\
    \ (string-&gt;list a) (string-&gt;list b))))\n", "  (cond\n    [(empty? a) b]\n\
    \    [(empty? b) a]\n    [else (string_xor (rest a) (rest b))]))\n```\n\n###7.\
    \ Parity bit\nA parity bit, or check bit, is a bit added to a string of binary\
    \ code to ensure that the total number of 1-bits in the string is even or odd.\
    \ Parity bits are used as the simplest form of error detecting code.\n\nFor example,\
    \ we can represent the 4-bit number 0100 as \"4\" and add a parity bit to give\
    \ 01001. The parity bit can be 0 or 1 such that the number of 1-bits in the string\
    \ - including the parity bit - is even (in this case three). The parity bit is\
    \ chosen to make the number of 1-bits in the string even, so this string has even\
    \ parity.\n\nIf you were presented with the string 01001, you could check if it\
    \ has even parity by counting the number of 1-bits and confirming that it is even.\
    \ The following strings would have even parity:\n\n```\n01001010\n01101111\n01101110\n\
    11101001\n```\n\nThe following strings would have odd parity:\n\n```\n01001011\n\
    01101110\n11111101\n```\n\nWe would like you to write a function that takes a\
    \ string of 1s and 0s and checks whether the string has even parity.\n\n###8.\
    \ Bouncy Numbers\n\nA number is called bouncy if the difference between the number\
    \ of increasing and decreasing digits is not equal to 1.\n\nFor example, the following\
    \ numbers are all bouncy:\n\n```\n5349\n5479\n5309\n234543\n5\n1\n3456497\n89\n\
    ```\n\nThe following numbers are not bouncy:\n\n```\n134468\n134467\n538\n5 (digits\
    \ never decrease)\n56789 (digits never increase)\n```\n\nYou are given the percentage\
    \ of bouncy numbers for the numbers between 1 and n.\n\nYour task is to find the\
    \ largest n for which the percentage of bouncy numbers is exactly equal to the\
    \ given number.\n\n###9. Car Numberplates\n\nA car's number plate is made up of\
    \ a letter-code denoting the city, and a number", "  (string-append (map (lambda\
    \ (x y) (if (xor x y) #\\1 #\\0))\n                      (string->list a)\n  \
    \                    (string->list b))))\n```\n\n### 16. Create a function that\
    \ generates a random n-bit prime.\n\n```racket\n#lang racket\n", "  (define (xor\
    \ c1 c2)\n    (cond ((eq? c1 c2) '0)\n          (else '1)))\n  (string-join\n\
    \   (map xor (string->list a) (string->list b))))\n", "  (define (go a b res)\n\
    \    (cond\n      [(zero? (string-length a)) res]\n      [(zero? (string-length\
    \ b)) res]\n      [else\n       (let ([ch (string-ref a 0)]\n             [ch2\
    \ (string-ref b 0)])\n         (go (substring a 1) (substring b 1)\n         \
    \    (if (equal? ch ch2)\n                 (string-append res \"0\")\n       \
    \          (string-append res \"1\"))))]))\n  (go a b \"\"))\n", "  (apply string\
    \ (map bitwise-xor (string->list a) (string->list b))))\n```", "  (if (zero? (string-length\
    \ a))\n      \"\"\n      (string\n       (if (equal? (string-ref a 0) (string-ref\
    \ b 0))\n           #\\0\n           #\\1)\n       (string_xor (substring a 1)\
    \ (substring b 1)))))\n", "  (apply string (map (lambda (x y) (if (eq? x y) #\\\
    0 #\\1)) a b)))\n", "  (cond [(string=? a \"\") b]\n        [(string=? b \"\"\
    ) a]\n        [else (bytes->string/utf-8\n               (byte-xor (string->bytes/utf-8\
    \ a)\n                         (string->bytes/utf-8 b)))]))\n```\n\n```racket\n\
    #lang racket\n", "  (string (bitwise-xor (string->number a) (string->number b))))\n",
  "  (string (bitwise-xor (string->number a 2) (string->number b 2) 2)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
