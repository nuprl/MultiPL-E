name: HumanEval_11_string_xor
language: rkt
prompt: "#lang racket\n\n;; Input are two strings a and b consisting only of 1s and\
  \ 0s.\n;; Perform binary XOR on these inputs and return result also as a string.\n\
  ;; >>> (string_xor \"010\" \"110\")\n;; \"100\"\n(define (string_xor a b)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_xor))\n\
  \    (check-equal? (candidate \"111000\" \"101010\") \"010010\")\n    (check-equal?\
  \ (candidate \"1\" \"1\") \"0\")\n    (check-equal? (candidate \"0101\" \"0000\"\
  ) \"0101\")\n))\n\n(test-humaneval)"
completions: ["  (assert (and (equal? (string-length a) (string-length b))\n     \
    \          (exact-positive-integer? (string-length a))))\n  (let ((n (string-length\
    \ a)))\n    (let loop ((i 0) (res (make-string n #\\space)))\n      (if (= i n)\n\
    \          res\n          (begin\n            (string-set! res i (integer->char\n\
    \                                (bitwise-xor (char->integer (string-ref a i))\n\
    \                                             (char->integer (string-ref b i)))))\n\
    \            (loop (+ i 1) res))))))\n", "  (let ([a-list (string->list a)]\n\
    \        [b-list (string->list b)])\n    (string-join (map (\u03BB (ab) (logxor\
    \ (car ab) (cadr ab))) (zip a-list b-list)))))\n", "  (let* ((a-bytes (string->bytes/utf-8\
    \ a))\n         (b-bytes (string->bytes/utf-8 b))\n         (num-chars (min (string-length\
    \ a) (string-length b)))\n         (xor-bytes (for/list ([ch-a (in-list a-bytes)])\n\
    \                       (for/list ([ch-b (in-list b-bytes)])\n               \
    \          (logxor ch-a ch-b)))))\n    (bytes->string (flatten xor-bytes))))\n",
  "  (let ([al (string-&gt;list a)]\n        [bl (string-&gt;list b)])\n    (map (lambda\
    \ (x y) (if (equal? x y) #\\0 #\\1)) al bl)))\n", "  (string-join\n   (apply string\n\
    \          (map (lambda (x y)\n                 (if (and x y)\n              \
    \       #\\0\n                     (if (or x y)\n                         #\\\
    1\n                         #\\0)))\n               (string-&gt;list a)\n    \
    \           (string-&gt;list b)))))\n", "  (cond\n    [(empty? a) b]\n    [(empty?\
    \ b) a]\n    [else (cons (char-upcase (integer->char (logxor (char->integer (string-ref\
    \ a 0)) (char->integer (string-ref b 0))))) (string_xor (substring a 1) (substring\
    \ b 1)))]))\n```\n\n```python\n# lang python\n\n# Input are two strings a and\
    \ b consisting only of 1s and 0s.\n# Perform binary XOR on these inputs and return\
    \ result also as a string.\n# >>> (string_xor \"010\" \"110\")\n# \"100\"\ndef\
    \ string_xor(a, b):\n    return str(int(a) ^ int(b))\n```\n\n```ruby\n# lang ruby\n\
    \n# Input are two strings a and b consisting only of 1s and 0s.\n# Perform binary\
    \ XOR on these inputs and return result also as a string.\n# >>> (string_xor \"\
    010\" \"110\")\n# \"100\"\ndef string_xor(a, b)\n  (a.to_i(2) ^ b.to_i(2)).to_s(2)\n\
    end\n```\n\n```rust\n// lang rust\n\n// Input are two strings a and b consisting\
    \ only of 1s and 0s.\n// Perform binary XOR on these inputs and return result\
    \ also as a string.\n// >>> (string_xor \"010\" \"110\")\n// \"100\"\nfn string_xor(a:\
    \ &str, b: &str) -> String {\n    let (a, b) = (a.parse::<u32>().unwrap(), b.parse::<u32>().unwrap());\n\
    \    format!(\"{:b}\", a ^ b)\n}\n```\n\n```go\n// lang go\n\n// Input are two\
    \ strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these\
    \ inputs and return result also as a string.\n// >>> (string_xor \"010\" \"110\"\
    )\n// \"100\"\npackage kata\n\nimport (\n\t\"strconv\"\n)\n\nfunc StringXor(a,\
    \ b string", "  (define (char-xor a b)\n    (cond\n      ((= a #\\0) b)\n    \
    \  ((= a #\\1) (cond\n                   ((= b #\\0) #\\1)\n                 \
    \  ((= b #\\1) #\\0)))\n      (else #\\0)))\n  (define (xor a b)\n    (cond\n\
    \      ((null? a) b)\n      ((null? b) a)\n      (else (cons (char-xor (car a)\
    \ (car b)) (xor (cdr a) (cdr b))))))\n  (string-join (xor (string->list a) (string->list\
    \ b))))\n", "  (cond [(and (equal? (first a) \"0\") (equal? (first b) \"0\"))\
    \ (cons \"0\" (string_xor (rest a) (rest b)))]\n        [(and (equal? (first a)\
    \ \"1\") (equal? (first b) \"1\")) (cons \"0\" (string_xor (rest a) (rest b)))]\n\
    \        [(and (equal? (first a) \"0\") (equal? (first b) \"1\")) (cons \"1\"\
    \ (string_xor (rest a) (rest b)))]\n        [(and (equal? (first a) \"1\") (equal?\
    \ (first b) \"0\")) (cons \"1\" (string_xor (rest a) (rest b)))]\n        [else\
    \ (cons \"0\" (string_xor (rest a) (rest b)))]))\n", "  (let ([alen (string-length\
    \ a)]\n        [blen (string-length b)])\n    (if (= blen alen)\n        (let\
    \ loop ([a a] [b b] [pos (- alen 1)] [rslt \"\"])\n          (cond [(zero? pos)\
    \ rslt]\n                [(string=? (substring a pos (+ pos 1))\n            \
    \               (substring b pos (+ pos 1)))\n                 (loop a b (- pos\
    \ 1) (string-append rslt \"0\"))]\n                [else (loop a b (- pos 1) (string-append\
    \ rslt \"1\"))]))\n        \"Inputs of different length.\")))", "  (string-join\
    \ (map (\u03BB (a b) (number->string (xor (string->number a) (string->number b))))\
    \ (string-&gt;list a) (string-&gt;list b))))\n", "  (cond\n    [(empty? a) b]\n\
    \    [(empty? b) a]\n    [else (string_xor (rest a) (rest b))]))\n```\n\n###7.\
    \ Parity bit\nA parity bit, or check bit, is a bit added to a string of binary\
    \ code to ensure that the total number of 1-bits in the string is even or odd.\
    \ Parity bits are used as the simplest form of error detecting code.\n\nFor example,\
    \ we can represent the 4-bit number 0100 as \"4\" and add a parity bit to give\
    \ 01001. The parity bit can be 0 or 1 such that the number of 1-bits in the string\
    \ - including the parity bit - is even (in this case three). The parity bit is\
    \ chosen to make the number of 1-bits in the string even, so this string has even\
    \ parity.\n\nIf you were presented with the string 01001, you could check if it\
    \ has even parity by counting the number of 1-bits and confirming that it is even.\
    \ The following strings would have even parity:\n\n```\n01001010\n01101111\n01101110\n\
    11101001\n```\n\nThe following strings would have odd parity:\n\n```\n01001011\n\
    01101110\n11111101\n```\n\nWe would like you to write a function that takes a\
    \ string of 1s and 0s and checks whether the string has even parity.\n\n###8.\
    \ Bouncy Numbers\n\nA number is called bouncy if the difference between the number\
    \ of increasing and decreasing digits is not equal to 1.\n\nFor example, the following\
    \ numbers are all bouncy:\n\n```\n5349\n5479\n5309\n234543\n5\n1\n3456497\n89\n\
    ```\n\nThe following numbers are not bouncy:\n\n```\n134468\n134467\n538\n5 (digits\
    \ never decrease)\n56789 (digits never increase)\n```\n\nYou are given the percentage\
    \ of bouncy numbers for the numbers between 1 and n.\n\nYour task is to find the\
    \ largest n for which the percentage of bouncy numbers is exactly equal to the\
    \ given number.\n\n###9. Car Numberplates\n\nA car's number plate is made up of\
    \ a letter-code denoting the city, and a number", "  (string-append (map (lambda\
    \ (x y) (if (xor x y) #\\1 #\\0))\n                      (string->list a)\n  \
    \                    (string->list b))))\n```\n\n### 16. Create a function that\
    \ generates a random n-bit prime.\n\n```racket\n#lang racket\n", "  (define (xor\
    \ c1 c2)\n    (cond ((eq? c1 c2) '0)\n          (else '1)))\n  (string-join\n\
    \   (map xor (string->list a) (string->list b))))\n", "  (define (go a b res)\n\
    \    (cond\n      [(zero? (string-length a)) res]\n      [(zero? (string-length\
    \ b)) res]\n      [else\n       (let ([ch (string-ref a 0)]\n             [ch2\
    \ (string-ref b 0)])\n         (go (substring a 1) (substring b 1)\n         \
    \    (if (equal? ch ch2)\n                 (string-append res \"0\")\n       \
    \          (string-append res \"1\"))))]))\n  (go a b \"\"))\n", "  (apply string\
    \ (map bitwise-xor (string->list a) (string->list b))))\n```", "  (if (zero? (string-length\
    \ a))\n      \"\"\n      (string\n       (if (equal? (string-ref a 0) (string-ref\
    \ b 0))\n           #\\0\n           #\\1)\n       (string_xor (substring a 1)\
    \ (substring b 1)))))\n", "  (apply string (map (lambda (x y) (if (eq? x y) #\\\
    0 #\\1)) a b)))\n", "  (cond [(string=? a \"\") b]\n        [(string=? b \"\"\
    ) a]\n        [else (bytes->string/utf-8\n               (byte-xor (string->bytes/utf-8\
    \ a)\n                         (string->bytes/utf-8 b)))]))\n```\n\n```racket\n\
    #lang racket\n", "  (string (bitwise-xor (string->number a) (string->number b))))\n",
  "  (string (bitwise-xor (string->number a 2) (string->number b 2) 2)))\n", "  ;;\
    \ We could use a couple of loops to iterate through the string,\n  ;; converting\
    \ chars to 0s and 1s and performing XOR and then building\n  ;; the result by\
    \ converting 0s and 1s back to string. But there is a\n  ;; faster way.\n  ;;\
    \ First step is to convert the strings to numbers. The first argument\n  ;; to\
    \ read-number is the number base.\n  (number->string (string-&gt;number a 2) 2))\n\
    </code>\nWhat would be the fastest way to accomplish this task in Racket?\n\n\n\
    A:\n\nYou're almost there! You just need to finish the function:\n<code>(define\
    \ (string_xor a b)\n  (number-&gt;string\n   (logxor (string-&gt;number a 2)\n\
    \           (string-&gt;number b 2))\n   2))\n</code>\nIt works as expected:\n\
    <code>(string_xor \"010\" \"110\")\n=&gt; \"100\"\n", "  (string-join\n   (map\
    \ (lambda (x) (number->string x))\n        (map (lambda (x y) (logxor x y))\n\
    \             (string-&gt;list a)\n             (string-&gt;list b)))\n   \"\"\
    ))\n", "  (string-append\n   (map (lambda (x) (number->string (bitwise-xor (string-&gt;number\
    \ (string x))\n                                                 (string-&gt;number\
    \ (string (string-ref b (string-index x a)))))))\n        (string-&gt;list a))))\n",
  "  (cond [(string=? a \"\") b]\n        [(string=? b \"\") a]\n        [else (string-append\
    \ (string (xor (string-&gt;number (string-ref a 0))\n                        \
    \                  (string-&gt;number (string-ref b 0))))\n                  \
    \           (string_xor (substring a 1) (substring b 1)))]))\n</code>\nThe code\
    \ seems to work as long as the input strings are of equal length. If they're not,\
    \ then, as expected, it throws an error.\nMy question is: how would you write\
    \ a test to check the length of the input strings and throw an error if they're\
    \ not equal?\n\n\nA:\n\nThere are a few things to notice here:\n\nYou already\
    \ have the <code>cond</code> statement doing all the base cases, and it has a\
    \ catch-all clause to throw an error.\nMaking it more general than that is likely\
    \ to make the function much less efficient. The reason is that it's not really\
    \ possible to determine the length of a string without comparing it to every string\
    \ of a longer length. I think you will find that even more efficient languages\
    \ than Racket, like C, will call this a \"time complexity\" of <code>O(n)</code>,\
    \ which means that the time it takes to process the string grows with the length\
    \ of the string, i.e. the longer the string is, the longer it takes.\n\nNow, in\
    \ your case, assuming you're dealing with strings of some fixed length, you could\
    \ do this:\n<code>(if (not (= (string-length a) (string-length b)))\n    \"ERROR\"\
    \n    (cond [(string=? a \"\") b]\n          [(string=? b \"\") a]\n         \
    \ [else (string-append (string (xor (string-&gt;number (string-ref a 0))\n   \
    \                                         (string-&gt;number (string-ref b 0))))\n\
    \                               (string_xor (substring a 1) (substring b 1)))]))\n\
    </code>\n", "  (cond [(empty? a) b]\n        [(empty? b) a]\n        [else (cons\
    \ (equal? (first a) (first b))\n                    (string_xor (rest a) (rest\
    \ b)))]))\n```\n\n```racket\n#lang racket\n", "  (cond\n    [(equal? a b) \"0\"\
    ]\n    [else \"1\"]))\n", "  (let ([a (string->list a)]\n        [b (string->list\
    \ b)])\n    (string-join (map (lambda (x) (number->string (xor (string->number\
    \ (car x)) (string->number (cadr x))))) (zip a b)))))\n", "  ;; Ensure that the\
    \ shorter string is in 'a' and the longer in 'b'.\n  (if (&gt; (string-length\
    \ a) (string-length b))\n      (values b a)\n      (values a b))\n  (string-join\n\
    \   (map\n    (\u03BB (c)\n      (if (char=? c #\\0)\n          #\\1\n       \
    \   #\\0))\n    (string-&gt;list\n     (string-xor* a b)))\n   \"\"))\n", "  (foldl\
    \ string-append \"\"\n         (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ x) 1)))\n              (string-split a \"\"))))\n", "  (letrec ([xor (lambda\
    \ (x y)\n                  (cond\n                    [(zero? x) y]\n        \
    \            [(zero? y) x]\n                    [else (add1 (xor (sub1 x) (sub1\
    \ y)))]))])\n    (cond\n      [(and (equal? (string-length a) (string-length b))\n\
    \            (not (equal? a b)))\n       (number->string (xor (string->number\
    \ a 2) (string->number b 2)) 2)]\n      [else \"\"])))\n", "  (cond\n    [(and\
    \ (eq? (string-length a) 1) (eq? (string-length b) 1))\n     (string (bitwise-xor\
    \ (string-&gt;number (substring a 0 1))\n                          (string-&gt;number\
    \ (substring b 0 1))))]\n    [else\n     (let ([bit-xor (bitwise-xor (string-&gt;number\
    \ (substring a 0 1))\n                                 (string-&gt;number (substring\
    \ b 0 1)))])\n       (cond\n         [(eq? bit-xor 1)\n          (string-append\
    \ (string bit-xor)\n                         (string_xor (substring a 1) (substring\
    \ b 1)))]\n         [else\n          (string-append (string bit-xor)\n       \
    \                  (string_xor (substring a 1) (substring b 1)))]))]))\n</code>\n\
    When I now run this code and call this function for example with:\n<code>(string_xor\
    \ \"010\" \"110\")\n</code>\nRacket will, as expected, print <code>\"100\"</code>.\
    \ The problem is that the function takes too long on longer strings.\nIs there\
    \ a way to speed this up?\n\n\nA:\n\nThere's no need to call the <code>substring</code>\
    \ function twice, and you could use <code>map</code> instead of writing two <code>cond</code>\
    \ statements, we can write it like this:\n<code>(define (string-xor a b)\n  (let\
    \ loop ([a (string-&gt;list a)]\n             [b (string-&gt;list b)])\n    (if\
    \ (null? a)\n        \"\"\n        (let ([bit-xor (bitwise-xor (string-&gt;number\
    \ (car a))\n                                    (string-&gt;number (car b)))])\n\
    \          (string-append (string bit-xor)\n                         (loop (cdr\
    \ a) (cdr b)))))))\n</code>\n", "  (cond\n    [(equal? (string-length a) 0) b]\n\
    \    [(equal? (string-length b) 0) a]\n    [else (string (xor (string-ref a 0)\
    \ (string-ref b 0)))\n\t  (string_xor (substring a 1) (substring b 1))]))\n",
  "  (define to_char\n    (\u03BB (i)\n      (number->string i)))\n  (string-join\
    \ (map to_char (xor-helper (string->list a) (string->list b))) \"\"))\n", "  (match-define\
    \ (list ac bc) (map string->list (list a b)))\n  (apply string (map (curry bitwise-xor)\
    \ ac bc)))\n```\n\n```racket\n#lang racket\n", "  (cond\n    [(equal? (string-length\
    \ a) 0) \"\"]\n    [(equal? (string-length b) 0) \"\"]\n    [(equal? (string-ref\
    \ a 0) #\\0)\n     (string-append\n      (string #\\0)\n      (string_xor (substring\
    \ a 1) (substring b 1)))]\n    [(equal? (string-ref a 0) #\\1)\n     (string-append\n\
    \      (string #\\1)\n      (string_xor (substring a 1) (substring b 1)))]\n \
    \   [(equal? (string-ref b 0) #\\0)\n     (string-append\n      (string #\\1)\n\
    \      (string_xor (substring a 1) (substring b 1)))]\n    [(equal? (string-ref\
    \ b 0) #\\1)\n     (string-append\n      (string #\\0)\n      (string_xor (substring\
    \ a 1) (substring b 1)))]))\n", "  (string \"00\"))\n", "  (string (bitwise-xor\
    \ (string->number a 2) (string->number b 2) 2)))\n", "  (string (bitwise-xor (string->number\
    \ a 2) (string->number b 2) 2)))\n", "  (apply string (map xor (string-&gt;list\
    \ a) (string-&gt;list b))))\n", "  (apply string (map xor (string-&gt;list a)\
    \ (string-&gt;list b))))\n</code>\nExample usage:\n<code>&gt; (string_xor \"010\"\
    \ \"110\")\n\"100\"\n</code>\n", "  (define (xor-char a b)\n    (if (equal? a\
    \ b)\n        #\\0\n        #\\1))\n  (string-append (list-&gt;string (map xor-char\
    \ (string-&gt;list a) (string-&gt;list b)))))\n", "  (cond\n    [(string=? a \"\
    \") (string-append b)]\n    [(string=? b \"\") (string-append a)]\n    [(string=?\
    \ (string-ref a 0) (string-ref b 0))\n     (string-append \"0\" (string_xor (substring\
    \ a 1) (substring b 1)))]\n    [else\n     (string-append \"1\" (string_xor (substring\
    \ a 1) (substring b 1)))]))\n```\n\n## Task 4\n\nFind the largest rectangle within\
    \ an arbitrarily shaped 2D grid of 1s and 0s\nthat is entirely filled with 1s.\n\
    ```\n#lang racket\n", '  (string (bitwise-xor (string->number a 2) (string->number
    b 2) 2)))', "  (define (string-xor-helper a b)\n    (cond ((or (empty? a) (empty?\
    \ b)) \"\")\n          ((equal? (first a) (first b)) \"0\")\n          (else \"\
    1\")))\n  (local ((define (xor-string s)\n            (cond ((zero? (string-length\
    \ s)) \"\")\n                  ((or (equal? (substring s 0 1) \"0\")\n       \
    \                (equal? (substring s 0 1) \"1\"))\n                   (string-append\
    \ (string-xor-helper (substring s 0 1) (substring s 1 2))\n                  \
    \                (xor-string (substring s 1 (string-length s)))))\n          \
    \        (else (error \"string_xor\" \"Argument is not a binary string\")))))\n\
    \    (xor-string a)))", "  (define (length-helper l s)\n    (if (eq? (string-length\
    \ s) l)\n        s\n        (length-helper l (string-append \"0\" s))))\n  (define\
    \ (xor-helper a b res)\n    (if (eq? (string-length a) 0)\n        res\n     \
    \   (xor-helper (substring a 1) (substring b 1) (string-append (string (logxor\
    \ (string->number (string-ref a 0)) (string->number (string-ref b 0)))) res))))\n\
    \  (let ((a (length-helper (string-length b) a))\n        (b (length-helper (string-length\
    \ a) b)))\n    (xor-helper a b \"\")))\n", "  (map\n   (\u03BB (x) (if (eql? x\
    \ '(#\\0 #\\0)) #\\0 #\\1))\n   (zip a b)))\n```\n\n### A Racket implementation\
    \ of the DES encryption algorithm.\n\nThe code here is a direct implementation\
    \ of the algorithm shown in the textbook,\nwith a few minor changes to the notation:\
    \ where the text uses the notation\n`L(i-1)` and `R(i-1)` to denote the left and\
    \ right parts of the block of input\nat the previous iteration, I have used `l0`\
    \ and `r0` and then `l1` and `r1` for\nthe first iteration, `l2` and `r2` for\
    \ the second iteration, and so on. \n\nAs with the textbook, the initial permutation\
    \ is done with the permutation\nindices in the order they are given in the text\
    \ (8, 16, 24, ..., 63, 1, 9, ...,\n55). This is *not* the order given in the bit\
    \ string, where the lowest order\nbit is bit 0.\n\n`block-encrypt` is a function\
    \ that converts a block of 64 bits into its\ncorresponding encrypted block of\
    \ 64 bits. It takes two arguments: the 64-bit\ninput, and the key.\n\n`encrypt`\
    \ is a function that runs `block-encrypt` on a block of 8-bit ASCII\ncharacters.\
    \ It takes two arguments: a string of characters to be encrypted, and\nthe encryption\
    \ key. The output is a string of encrypted characters.\n\n`decrypt` does the reverse\
    \ of `encrypt`.\n\n```\n#lang racket\n", "  (cond ((equal? a b) \"0\")\n     \
    \   ((equal? a \"0\") b)\n        ((equal? b \"0\") a)\n        (else \"1\")))\n",
  "  (if (equal? (string-length a) 0) \"\"\n      (if (equal? (string-length b) 0)\
    \ \"\"\n          (string (logxor (string-&gt;number (string-ref a 0))\n     \
    \                     (string-&gt;number (string-ref b 0))))\n          (string_xor\
    \ (substring a 1) (substring b 1)))))\n</code>\nI keep getting a warning that\
    \ <code>string_xor</code> is not defined when I load the file. How do I go about\
    \ defining a helper function in Racket?\nEdit: I am able to load the file if I\
    \ move the helper function above the top-level function. If this is the only way\
    \ to define a helper function in Racket, what is the point of putting the function\
    \ definitions at the bottom of the file?\n\n\nA:\n\nThe way you've written it,\
    \ the body of <code>string_xor</code> is just a series of expressions, but it's\
    \ not clear what you want to happen as a result of evaluating those expressions.\
    \ Using Racket's syntax, you need to write something like this to properly define\
    \ the function:\n<code>(define (string_xor a b)\n  (if (equal? (string-length\
    \ a) 0)\n      \"\"\n      (if (equal? (string-length b) 0)\n          \"\"\n\
    \          (string (logxor (string-&gt;number (string-ref a 0))\n            \
    \              (string-&gt;number (string-ref b 0))))\n          (string_xor (substring\
    \ a 1) (substring b 1)))))\n</code>\nYou need to add parentheses to mark which\
    \ expressions are part of a conditional clause. I also added newlines for clarity,\
    \ but that's up to you.\nYou can learn more about Racket's syntax from the documentation.\n",
  "  (define (helper a b)\n    (cond\n      ((string=? (substring a 0 1) \"0\") (string-append\
    \ (string-append \"0\" (substring a 1))))\n      ((string=? (substring a 0 1)\
    \ \"1\") (string-append (string-append \"1\" (substring a 1))))))\n  (cond\n \
    \   ((string=? a b) \"0\")\n    ((string=? (string-append (string-append (substring\
    \ a 0 1) (substring b 0 1)) \"\") \"00\") (string-append (string-append \"0\"\
    \ (string_xor (substring a 1) (substring b 1)))))\n    ((string=? (string-append\
    \ (string-append (substring a 0 1) (substring b 0 1)) \"\") \"01\") (string-append\
    \ (string-append \"1\" (string_xor (substring a 1) (substring b 1)))))\n    ((string=?\
    \ (string-append (string-append (substring a 0 1) (substring b 0 1)) \"\") \"\
    10\") (string-append (string-append \"1\" (string_xor (substring a 1) (substring\
    \ b 1)))))\n    ((string=? (string-append (string-append (substring a 0 1) (substring\
    \ b 0 1)) \"\") \"11\") (string-append (string-append \"0\" (string_xor (substring\
    \ a 1) (substring b 1)))))))\n", "  (for/fold ([acc \"\"]) ([i (in-range (string-length\
    \ a))])\n    (string-append acc (if (equal? (string-ref a i) (string-ref b i))\
    \ \"0\" \"1\"))))\n", "  ;; make sure that both strings are the same length (pad\
    \ with 0s)\n  (define a-len (string-length a))\n  (define b-len (string-length\
    \ b))\n  (define n (max a-len b-len))\n  (define a-pad (string-append (make-string\
    \ (- n a-len) #\\0) a))\n  (define b-pad (string-append (make-string (- n b-len)\
    \ #\\0) b))\n  ;; perform XOR\n  (define result (make-string n))\n  (for ([i (in-range\
    \ n)])\n    (set! (string-ref result i) (if (char=? (string-ref a-pad i) (string-ref\
    \ b-pad i)) #\\0 #\\1)))\n  result)\n", "  (string (bitwise-xor (string->number\
    \ a 2) (string->number b 2) 2)))\n", "  (regexp-replace* #rx\".\" #:a a #:b b\n\
    \                   #:s #rx\"\\\\1\" #:m #rx\"[01]\"\n                   #:m #rx\"\
    \\\\2\" #:s #rx\"[01]\"\n                   #:replacement (\u03BB (c1 c2)\n  \
    \                                (if (string=? c1 c2) \"0\" \"1\"))))\n", "  (string\
    \ (if (equal? (string-ref a 0) (string-ref b 0)) #\\0 #\\1)\n          (if (equal?\
    \ (string-ref a 1) (string-ref b 1)) #\\0 #\\1)\n          (if (equal? (string-ref\
    \ a 2) (string-ref b 2)) #\\0 #\\1)))\n", "  (cond\n    ((string=? \"\" a) b)\n\
    \    ((string=? \"\" b) a)\n    (else (string_xor (substring a 1) (substring b\
    \ 1)))))\n", "  (let ([blen (string-length b)])\n    (apply string\n         \
    \  (map (lambda (x)\n                  (cond\n                    [(eq? x (string-ref\
    \ b 0)) (number->string 1)]\n                    [else (number->string 0)]))\n\
    \                a))))\n", "  (string (logxor (string->number a 2) (string->number\
    \ b 2) 2)))\n", "  (if (or (string=? \"\" a) (string=? \"\" b))\n      \"\"\n\
    \      (let ([a-first (substring a 0 1)]\n            [b-first (substring b 0\
    \ 1)])\n        (if (string=? a-first b-first)\n            (string (string_xor\
    \ (substring a 1) (substring b 1)))\n            (string \"1\" (string_xor (substring\
    \ a 1) (substring b 1)))))))\n", "  (string-append\n   (if (and (= (string-ref\
    \ a 0) #\\1) (= (string-ref b 0) #\\0)) \"1\" \"0\")\n   (if (and (= (string-ref\
    \ a 1) #\\1) (= (string-ref b 1) #\\0)) \"1\" \"0\")\n   (if (and (= (string-ref\
    \ a 2) #\\1) (= (string-ref b 2) #\\0)) \"1\" \"0\")))\n", "  (if (string=? a\
    \ \"\")\n      b\n      (if (string=? b \"\")\n          a\n          (string-append\n\
    \           (if (string=? (string-take a 1) \"0\") \"1\" \"0\")\n           (string_xor\
    \ (string-drop a 1) (string-drop b 1)))\n          )))", "  (cond [(= (string-length\
    \ a) 0) \"\"]\n        [(= (string-length b) 0) \"\"]\n        [else (string\n\
    \               (xor (string-&gt;number (string-ref a 0))\n                  \
    \  (string-&gt;number (string-ref b 0))))\n               (string_xor (substring\
    \ a 1) (substring b 1))]))\n</code>\nThis seems to work, but I don't think it's\
    \ very elegant. Any suggestions would be appreciated.\n\n\nA:\n\nLike most Racket\
    \ code, you can simplify this by using higher-order functions. For example, your\
    \ code can be simplified to something like this:\n<code>(define (string-xor a\
    \ b)\n  (apply string\n         (map (\u03BB (i) (bitwise-xor (string-&gt;number\
    \ (string-ref a i))\n                                  (string-&gt;number (string-ref\
    \ b i))))\n              (range (min (string-length a) (string-length b))))))\n\
    </code>\nOr, in many cases, it's even possible to avoid writing your own code\
    \ at all, and instead to use the library functions that are already available,\
    \ for example:\n<code>(define (string-xor a b)\n  (map (\u03BB (i) (bitwise-xor\
    \ (string-&gt;number (string-ref a i))\n                           (string-&gt;number\
    \ (string-ref b i))))\n       (range (min (string-length a) (string-length b)))))\n\
    </code>\nBut, unless you want to build on top of the library, the first version\
    \ is probably the most convenient:\n<code>(displayln (string-xor \"010\" \"110\"\
    ))", "  (string-join (map bit-xor (map string->number (string-split a))\n    \
    \                        (map string->number (string-split b)))\n            \
    \   \"\"))\n", "  (if (equal? (car a) (car b))\n      (string_xor (cdr a) (cdr\
    \ b))\n      (cons (+ 1 (car a)) (string_xor (cdr a) (cdr b)))))\n```\n\n####\
    \ Output:\n```\n-> (string_xor \"1010101\" \"1100110\")\n#<procedure:string_xor>\n\
    #<procedure:string_xor>\n#<procedure:string_xor>\n#<procedure:string_xor>\n#<procedure:string_xor>\n\
    #<procedure:string_xor>\n#<procedure:string_xor>\n'(1 1 1 0 1 0 1)\n```\n####\
    \ Implementation:\n```\n#lang racket\n", "  (cond [(empty? a) b]\n        [(empty?\
    \ b) a]\n        [else (append (string_xor (rest a) (rest b))\n              \
    \        (string (xor (char->integer (first a))\n                            \
    \       (char->integer (first b)))))]))\n", "  (define (char-xor c d)\n    (if\
    \ (and (char=? c #\\1) (char=? d #\\0))\n        #\\1\n        (if (and (char=?\
    \ c #\\0) (char=? d #\\1))\n            #\\1\n            #\\0)))\n  (define (helper\
    \ ca cb acc)\n    (if (or (and (not (char-ready? ca)) (not (char-ready? cb)))\n\
    \            (and (char-ready? ca) (char-ready? cb)))\n        (string-reverse\
    \ acc)\n        (if (char-ready? ca)\n            (if (char-ready? cb)\n     \
    \           (helper (read-char ca) (read-char cb) (string-append (list (char-xor\
    \ (peek-char ca) (peek-char cb))) acc))\n                (helper (read-char ca)\
    \ cb (string-append (list (char-xor (peek-char ca) #\\0)) acc)))\n           \
    \ (if (char-ready? cb)\n                (helper ca (read-char cb) (string-append\
    \ (list (char-xor #\\0 (peek-char cb))) acc))\n                #f))))\n  (helper\
    \ (open-input-string a) (open-input-string b) \"\"))\n", "  (apply string (map\
    \ (\u03BB (x) (if (equal? (car x) (cadr x)) #\\0 #\\1)) (zip (string->list a)\
    \ (string->list b)))))\n", "  ;; expand shorter string with zeros\n  (let ([la\
    \ (string-length a)]\n        [lb (string-length b)])\n    (if (< la lb)\n   \
    \     (set! a (string-append a (make-string (- lb la) #\\0)))\n        (set! b\
    \ (string-append b (make-string (- la lb) #\\0)))))\n  (let loop ([i 0] [s #f])\n\
    \    (cond\n      [(= i (string-length a)) (if s s \"\")]\n      [(= (string-ref\
    \ a i) (string-ref b i)) (loop (+ i 1) s)]\n      [else (loop (+ i 1) (if s (string-append\
    \ s (substring a i (+ i 1)))\n                             (substring a i (+ i\
    \ 1))))])))\n", "  (string-append (map (lambda (a b)\n                       \
    \ (number->string (logxor (string-&gt;number (string a))\n                   \
    \                             (string-&gt;number (string b)))))\n            \
    \          a b)))\n", "  (define (char-xor ca cb)\n    (cond [(and (char=? ca\
    \ #\\1) (char=? cb #\\0)) #\\1]\n          [(and (char=? ca #\\0) (char=? cb #\\\
    1)) #\\1]\n          [else #\\0]))\n  (list->string (map char-xor (string->list\
    \ a) (string->list b))))\n", "  (string\n   (bitwise-xor\n    (string->number\
    \ a 2)\n    (string->number b 2)\n    2)))\n", "  (define (xor a b)\n    (if (equal?\
    \ a b) 0 1))\n  (if (and (equal? (string-length a) 1) (equal? (string-length b)\
    \ 1))\n      (number->string (xor (string-&gt;number (substring a 0 1))\n    \
    \                       (string-&gt;number (substring b 0 1))))\n      (string_xor\
    \ (string_xor (substring a 0 1) (substring b 0 1))\n                  (string_xor\
    \ (substring a 1) (substring b 1)))))\n</code>\nThis works fine, but I think it's\
    \ too ugly to put it here. Can somebody help me to simplify it?\n\n\nA:\n\nHere's\
    \ one way to do it in plain Racket:\n<code>(define (string-xor a b)\n  (apply\
    \ string\n         (map (lambda (x y)\n                (if (zero? x) y (sub1 y)))\n\
    \              (string-&gt;list a)\n              (string-&gt;list b))))\n</code>\n",
  "  (if (empty? a)\n      b\n      (if (empty? b)\n          a\n          (local\n\
    \           [(define head-a (substring a 0 1))\n            (define head-b (substring\
    \ b 0 1))\n            (define tail-a (substring a 1))\n            (define tail-b\
    \ (substring b 1))]\n           (string\n            (bitwise-xor (string->number\
    \ head-a) (string->number head-b))\n            (string_xor tail-a tail-b))))))",
  "  (string-join (map (curry bitwise-xor a) b)))\n", "  (apply string (map (\u03BB\
    \ (x) (if (char=? #\\0 x) #\\1 #\\0)) (string-map (\u03BB (a b) (number->char\
    \ (char-&gt;integer a) (char-&gt;integer b))) a b))))\n", "  (let ([a (string->list\
    \ a)]\n        [b (string->list b)])\n    (cond [(empty? a) b]\n          [(empty?\
    \ b) a]\n          [else (cons (xor (car a) (car b))\n                      (string_xor\
    \ (cdr a) (cdr b)))])))\n", "  (string-append\n   (string\n    (if (eq? #\\0 (string-ref\
    \ a 0)) #\\1 #\\0))\n   (string\n    (if (eq? #\\0 (string-ref b 0)) #\\1 #\\\
    0))\n   (string\n    (if (eq? #\\0 (string-ref a 1)) #\\1 #\\0))\n   (string\n\
    \    (if (eq? #\\0 (string-ref b 1)) #\\1 #\\0))\n   (string\n    (if (eq? #\\\
    0 (string-ref a 2)) #\\1 #\\0))\n   (string\n    (if (eq? #\\0 (string-ref b 2))\
    \ #\\1 #\\0))))\n```\n\n## License\n\nRacket is distributed under the [MIT\nLicense](http://opensource.org/licenses/MIT).",
  "  (let\n    ;; Make sure that the two strings are of equal length.\n    ;; If a\
    \ is shorter than b, pad it with zeros to the left.\n    ;; If b is shorter than\
    \ a, pad it with zeros to the left.\n    ((pad-length (lambda (a b)\n      (if\
    \ (> (string-length a) (string-length b))\n        (string-pad b (- (string-length\
    \ a) (string-length b)) #\\0 #:prefix)\n        (string-pad a (- (string-length\
    \ b) (string-length a)) #\\0 #:prefix))))\n    ;; The actual string-xor function\n\
    \    (string-xor\n      (lambda (a b)\n        (apply string (map (lambda (x y)\n\
    \          (if (and (char=? (string-ref x 0) #\\1) (char=? (string-ref y 0) #\\\
    1))\n            #\\0\n            (if (or (char=? (string-ref x 0) #\\1) (char=?\
    \ (string-ref y 0) #\\1))\n              #\\1\n              #\\0)))\n       \
    \   (string->list (pad-length a b))\n          (string->list (pad-length b a)))))))\n\
    \  (string-xor a b)))\n", "  (string-append (map (\u03BB (i) (integer->char (+\
    \ (char->integer (string-ref a i)) (char->integer (string-ref b i))))) (build-list\
    \ (string-length a) (\u03BB (x) x)))))\n", "  (string-append (map (lambda (x y)\
    \ (if (equal? x y) \"0\" \"1\")) a b)))\n", "  (let* ([a (string->list a)]\n \
    \        [b (string->list b)]\n         [r (make-string (length a))])\n    (define\
    \ (xor_strings i a b r)\n      (if (= i (length a))\n          (list->string r)\n\
    \          (begin\n            (string-set! r i (number->string (bitwise-xor (string->number\
    \ (string (list-ref a i))) (string->number (string (list-ref b i))))))\n     \
    \       (xor_strings (+ i 1) a b r))))\n    (xor_strings 0 a b r)))\n", "  (apply\
    \ string (map (lambda (x y)\n                       (if (or (and (equal? #\\1\
    \ x) (equal? #\\0 y))\n                               (and (equal? #\\0 x) (equal?\
    \ #\\1 y)))\n                           #\\1\n                           #\\0))\n\
    \                     (string->list a)\n                     (string->list b))))\n",
  "  (cond\n    [(= (string-length a) 0) b]\n    [(= (string-length b) 0) a]\n   \
    \ [else (if (= (string-ref a 0) #\\0)\n             (string-append (string #\\\
    0) (string_xor (substring a 1) (substring b 1)))\n             (string-append\
    \ (string #\\1) (string_xor (substring a 1) (substring b 1))))]))\n", "  (apply\
    \ string (map ~ (string->list a) (string->list b))))\n", "  (if (and (= (string-length\
    \ a) 1) (= (string-length b) 1))\n      (string (bitwise-xor (string-&gt;number\
    \ (substring a 0 1))\n                           (string-&gt;number (substring\
    \ b 0 1))))\n      (let loop ((a (substring a 0 (subtract 1 (string-length a))))\n\
    \                 (b (substring b 0 (subtract 1 (string-length b)))))\n      \
    \  (string-append (string_xor (substring a 0 1) (substring b 0 1))\n         \
    \              (loop (substring a 1) (substring b 1))))))\n</code>\n", "  (let\
    \ ([xs (string->list a)]\n        [ys (string->list b)])\n    (for/fold ([acc\
    \ '()]) ([x (in-list xs)] [y (in-list ys)])\n      (cons (if (equal? x y)\n  \
    \              #\\0\n                #\\1)\n            acc))))\n\n", "  (string-join\n\
    \   (map\n    (lambda (x)\n      (number->string (bitwise-xor (string->number\
    \ (string-ref x 0))\n                                   (string->number (string-ref\
    \ x 1)))))\n    (partition a b))\n   \"\"))\n", "  (if (string=? a \"\")\n   \
    \   b\n      (if (string=? b \"\")\n          a\n          (string (logxor (string-&gt;number\
    \ (substring a 0 1))\n                         (string-&gt;number (substring b\
    \ 0 1)))\n                  (string_xor (substring a 1) (substring b 1))))))\n",
  "  (local [(define (xor-one-bit a b)\n            (if (char=? a b) \"0\" \"1\"))]\n\
    \    (string-append (xor-one-bit (string-ref a 0) (string-ref b 0))\n        \
    \          (xor-one-bit (string-ref a 1) (string-ref b 1))\n                 \
    \ (xor-one-bit (string-ref a 2) (string-ref b 2)))))\n```\n\n```racket\n#lang\
    \ racket\n", "  (cond [(eq? a \"\") \"\"]\n        [(eq? b \"\") \"\"]\n     \
    \   [else (apply string (map (lambda (a b) (if (eq? a b) 0 1)) a b))]))\n", " \
    \ (regexp-replace* #rx\"\"\n                   (apply string\n               \
    \           (map (lambda (x) (logxor (string->number (car x))\n              \
    \                                     (string->number (cadr x))))\n          \
    \                     (map (lambda (x) (match-all #rx\"(\\d)(\\d)\" x))\n    \
    \                                (list a b))))))\n", "  (if (and (string? a) (string?\
    \ b))\n      (if (and (= (string-length a) (string-length b)) (> (string-length\
    \ a) 0))\n          (string (logxor (string->number a 2) (string->number b 2)))\n\
    \          (error \"Input strings must be the same length.\"))\n      (error \"\
    Inputs must be strings.\")))\n", "  (string-join (map string-&gt;number (map (\u03BB\
    \ (a b)\n                                           (if (and (eq? a 1) (eq? b\
    \ 1))\n                                               0\n                    \
    \                           (if (or (eq? a 1) (eq? b 1))\n                   \
    \                                1\n                                         \
    \          0)))\n                                         (string-&gt;list a)\n\
    \                                         (string-&gt;list b)))\n            \
    \   \"\"))\n</code>\nI'm not sure how I can improve the loop. I feel like using\
    \ <code>map</code> will be more of a performance hit than what I want. Is there\
    \ any way I can make it shorter and more performant?\n\n\nA:\n\nThis is your original\
    \ code, slightly indented, and with comments:\n<code>(define (string_xor a b)\n\
    \  (string-join (map string-&gt;number (map (\u03BB (a b)\n                  \
    \                         (if (and (eq? a 1) (eq? b 1))\n                    \
    \                           0\n                                              \
    \ (if (or (eq? a 1) (eq? b 1))\n                                             \
    \      1\n                                                   0)))\n          \
    \                               (string-&gt;list a)\n                        \
    \                 (string-&gt;list b)))\n               \"\"))\n</code>\nThe first\
    \ thing that jumps out to me is that you're using <code>map</code> twice when\
    \ you don't need to. You can use <code>for/list</code> to eliminate this.\n<code>(define\
    \ (string_xor a b)\n  (string-join\n   (for/list ([chr1 (in-string a)])\n    \
    \ (string-&gt;number (\u03BB (chr2)\n                       (if (and (eq? chr1\
    \ 1) (eq? chr2 1))\n                           0\n                           (if\
    \ (or (eq? chr1 1) (eq? chr2 1))\n                               1\n         \
    \                      0)))))\n   (in-string b)\n   \"\"))\n</code>\nThis solution\
    \ is not any more efficient than the original, since it has to convert the characters\
    \ to numbers twice. But it does have the advantage of being a bit more concise\
    \ and readable.", "  (cond [(empty? a) b]\n        [(empty? b) a]\n        [else\
    \ (cons (integer->char (xor (char->integer (car a)) (char->integer (car b))))\n\
    \                    (string_xor (cdr a) (cdr b)))]))\n", "  (define (xor a b)\n\
    \    (or (and (not a) b) (and a (not b))))\n  (for/fold ([a \"\"\n           \
    \   (string-append a (number->string (xor (string-&gt;number (string-ref a i))\n\
    \                                                    (string-&gt;number (string-ref\
    \ b i)))))]\n             [i 0 (add1 i)])\n    #t\n    a))\n", "  (define (string-&gt;list-of-integers\
    \ string)\n    (map string-&gt;number (string-&gt;list string)))\n  (define (list-of-integers-&gt;string\
    \ integers)\n    (list-&gt;string (map number-&gt;string integers)))\n  (list-of-integers-&gt;string\n\
    \   (map bitwise-xor\n        (string-&gt;list-of-integers a)\n        (string-&gt;list-of-integers\
    \ b))))\n</code>\n", "  (string-join\n   (map\n    (lambda (x)\n      (string-&gt;number\
    \ (string-join (map string-&gt;number x))))\n    (map list\n         (string-&gt;list\
    \ a)\n         (string-&gt;list b)))\n   \"\"))\n</code>\nAs you see, I'm using\
    \ the <code>string-&gt;number</code> operation so that the XOR is performed in\
    \ the numeric (bitwise) domain, and then I convert the result back to a string\
    \ with <code>number-&gt;string</code>.\nI think the intent of your code is to\
    \ perform a bitwise XOR, however your use of <code>char=?</code> and <code>char-&gt;integer</code>\
    \ together with <code>xor</code> will not work as expected. You are comparing\
    \ ASCII values of characters, which means that any non-numeric character will\
    \ be considered \"0\" and any number will be considered \"1\".\n", "  (let loop\
    \ ([na (string->list a)] [nb (string->list b)] [result '()])\n    (if (and (null?\
    \ na) (null? nb))\n        (list->string (reverse result))\n        (loop (cdr\
    \ na) (cdr nb)\n              (cons (if (equal? (car na) (car nb))\n         \
    \             #\\0\n                      #\\1)\n                    result)))))\n",
  "  (define (char-xor c d)\n    (integer->char (bitwise-xor (char->integer c) (char->integer\
    \ d))))\n  (let loop ((a (string->list a))\n             (b (string->list b))\n\
    \             (r '()))\n    (if (or (null? a) (null? b))\n        (list->string\
    \ (reverse r))\n        (loop (cdr a)\n              (cdr b)\n              (cons\
    \ (char-xor (car a) (car b)) r)))))\n", "  (string\n   (map (lambda (pair)\n \
    \         (if (equal? (car pair) (cadr pair)) #\\0 #\\1))\n        (map list (string->list\
    \ a) (string->list b)))))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n\
    \    [else (string (char-&gt;integer (logxor (string-&gt;char (first a)) (string-&gt;char\
    \ (first b)))))\n          (string_xor (rest a) (rest b))]))\n</code>\nThis works\
    \ fine for strings of the same length, but I need this to work for strings of\
    \ different lengths as well. The longer string should be padded with 0s at the\
    \ end until it is the same length as the shorter string. How can I do this?\n\n\
    \nA:\n\nI'd do it with a <code>for/fold</code>:\n<code>(define (string-xor a b)\n\
    \  (let ((len (max (string-length a) (string-length b))))\n    (for/fold ([res\
    \ (make-string len)])\n              ([i (in-range len)])\n      (string-set!\
    \ res i (integer-&gt;char (logxor (string-ref a i) (string-ref b i))))\n     \
    \ res)))\n</code>\nThis way we're not creating any unnecessary intermediate strings,\
    \ it's also going to be more efficient because <code>string-set!</code> mutates\
    \ the string in place, and it doesn't matter if the input strings are different\
    \ lengths.\n", "  (string (bitwise-xor (string->number a 2) (string->number b\
    \ 2) 2)))\n", "  (let ([lena (string-length a)]\n        [lenb (string-length\
    \ b)])\n    (cond [(> lena lenb)\n           (string-append (substring a 0 (-\
    \ lena lenb))\n                          (bitwise-xor-strings (substring a (-\
    \ lena lenb)) b))]\n          [(< lena lenb)\n           (string-append (substring\
    \ b 0 (- lenb lena))\n                          (bitwise-xor-strings (substring\
    \ b (- lenb lena)) a))]\n          [else\n           (bitwise-xor-strings a b)])))\n\
    ```\n\n### Exercise 2.9\n```racket\n#lang racket\n", "  (cond\n    [(equal? a\
    \ b) \"0\"]\n    [else \"1\"]))\n", "  (regexp-replace* #rx\"[^1]\" (binary-xor\
    \ a b) \"\"))\n", "  (string-join (list-map (lambda (a b)\n                  \
    \         (if (or (and (equal? a #\\1) (equal? b #\\0))\n                    \
    \               (and (equal? a #\\0) (equal? b #\\1)))\n                     \
    \          #\\1\n                               #\\0))\n                     \
    \    (string->list a)\n                         (string->list b))\n          \
    \     \"\"))\n", "  (if (and (= 1 (string-length a)) (= 1 (string-length b)))\n\
    \      (if (equal? (string-ref a 0) (string-ref b 0))\n          \"0\"\n     \
    \     \"1\")\n      (if (equal? (string-ref a 0) (string-ref b 0))\n         \
    \ (string_xor (substring a 1) (substring b 1))\n          (cons (string-ref a\
    \ 0) (string_xor (substring a 1) (substring b 1))))))\n", "  (string-append (map\
    \ (lambda (c) (string (xor (char-&gt;integer c) (char-&gt;integer (string-ref\
    \ b (char-&gt;integer c)))))) a)))\n", "  ;; TODO\n  )\n```\n\n**Logic**\n\n1.\
    \ Create a list of integers from 0 to n.\n2. Exclude elements from this list which\
    \ are multiple of 3 or 5\n3. Sum all elements of the list and return that number.\n\
    \n**Sample Tests**\n\n```racket", "  (cond [(empty? a) b]\n        [(empty? b)\
    \ a]\n        [else (cons (string_xor-car a b) (string_xor (cdr a) (cdr b)))]))\n",
  "  (string-join\n   (map\n    (lambda (a b)\n      (if (string=? (string a) \"0\"\
    ) (string b)\n       (if (string=? (string b) \"0\") (string a)\n        \"0\"\
    )))\n    (string->list a)\n    (string->list b))))\n```\n## Challenge 69\nI know,\
    \ right? We finally get to the crypto challenges.\n\n[Client-side](https://cryptopals.com/sets/6/challenges/69)\n\
    \n```racket\n#lang racket\n", "  (define (xor a b)\n    (if (= a b)\n        #f\n\
    \        #t))\n  (apply string (map xor (string-&gt;list a) (string-&gt;list b))))\n",
  "  (if (zero? (string-length a)) \"\"\n      (if (zero? (string-length b)) \"\"\n\
    \          (string\n           (bitwise-xor (string-&gt;number (substring a 0\
    \ 1))\n                        (string-&gt;number (substring b 0 1)))\n      \
    \     (string_xor (substring a 1) (substring b 1))))))\n</code>\nTest:\n<code>&gt;\
    \ (string_xor \"010\" \"110\")\n\"100\"\n</code>\n", "  (define (str-to-list x)\n\
    \    (map string->number (string-&gt;list x)))\n  (define (list-to-str x)\n  \
    \  (list-&gt;string (map number-&gt;string x)))\n  (list-to-str (map (lambda (x\
    \ y)\n                     (cond ((= x 1) 0)\n                           ((= x\
    \ 0) 1)\n                           (else (error \"Unexpected character in string\"\
    ))))\n                    (str-to-list a)\n                    (str-to-list b))))\n\
    </code>\nRunning the above program\n<code>&gt; (string_xor \"010\" \"110\")\n\"\
    100\"\n</code>\n", "  (let ([m (length a)]\n        [n (length b)])\n    (if (&gt;\
    \ m n)\n        (string_xor b a)\n        (let ([s (build-string (- n m) #\\0)])\n\
    \          (string-append (build-string (vector-ref (string-&gt;integer a 2)\n\
    \                                                   (vector-ref (string-&gt;integer\
    \ b 2)\n                                                               (string-append\
    \ s (substring b (- n m))))))\n                         )))))\n</code>\nBut I'm\
    \ getting a wrong type error:\n<code>string-xor.rkt:11:2: expected: string?\n\
    \                          given: #&lt;vector&gt;\n  in: the 1st argument of\n\
    \      (- m)\n  in: the 1st argument of\n      (build-string (- m))\n  in: the\
    \ 1st argument of\n      (string-append (build-string (- m)) ...)\n  in: the 1st\
    \ argument of\n      (string-append (build-string (- m)) ...)\n  in: the 1st argument\
    \ of\n      (string-append (build-string (- m)) ...)\n  in: the 1st argument of\n\
    \      (let ...)\n  in: the 1st argument of\n      (let ...)\n  in: the 1st argument\
    \ of\n      (let ...)\n  in: the 1st argument of\n      (let ...)\n  in: the 1st\
    \ argument of\n      (if (&gt; m n) ...)\n  in: the 1st argument of\n      (let\
    \ ...)\n  in: the 1st argument of\n      (let ...)\n  in: the 1st argument of\n\
    \      (let ...)\n  in: the 1st argument of\n      (let ...)\n  in: the 1st argument\
    \ of\n      (let ...)\n  in: the 1st argument of\n      (let ...)\n  in: an application\
    \ of\n      (method expect:args:racket:racket-value-pred (racket:check:expect:data)\n\
    \               (racket:check:expect:args)\n               (racket:racket-value-pred\
    \ (list:list-&gt", "  (cond ((empty? a) b)\n        ((empty? b) a)\n        (else\
    \ (string_xor (rest a) (rest b)))))\n", "  (define (string-to-list s)\n    (map\
    \ string->number (string-&gt;list s)))\n  (string-join (map number-&gt;string\
    \ (map xor (string-to-list a) (string-to-list b))) \"\"))\n", "  (number->string\
    \ (bitwise-xor (string->number a 2) (string->number b 2) 2)))\n", "  (list->string\
    \ (map (\u03BB (pair)\n                       (if (member (car pair) (list #\\\
    0 #\\1))\n                           (if (member (cadr pair) (list #\\0 #\\1))\n\
    \                               (if (equal? (car pair) (cadr pair))\n        \
    \                           #\\0\n                                   #\\1)\n \
    \                              (error \"Bad input\"))\n                      \
    \     (error \"Bad input\")))\n                     (map (\u03BB (pair)\n    \
    \                        (list (car pair) (cadr pair)))\n                    \
    \      (map (\u03BB (letter)\n                                 (if (member letter\
    \ (list #\\0 #\\1))\n                                     letter\n           \
    \                          (error \"Bad input\")))\n                         \
    \      (string->list a)))\n                     (map (\u03BB (letter)\n      \
    \                      (if (member letter (list #\\0 #\\1))\n                \
    \                letter\n                                (error \"Bad input\"\
    )))\n                          (string->list b)))))\n", "  (bytes->string\n  \
    \ (bytes-xor\n    (string->bytes a)\n    (string->bytes b))))\n", "  (if (empty?\
    \ a)\n      b\n      (if (empty? b)\n          a\n          (string (if (= (string-ref\
    \ a 0) (string-ref b 0))\n                      #\\0\n                      #\\\
    1)\n                  (string_xor (substring a 1) (substring b 1))))))\n```",
  "  (define (xor-char char1 char2)\n    (if (string=? char1 char2)\n        \"0\"\
    \n        \"1\"))\n  (string-join (map xor-char (string->list a) (string->list\
    \ b))))\n```\n\n[MitchellBaker/kata-eight/string-xor.rkt at master \xB7 MitchellBaker/kata-eight](https://github.com/MitchellBaker/kata-eight/blob/master/string-xor.rkt)\n\
    \n## Elixir\n\n[KataEight.exs in kata-eight-elixir \xB7 MitchellBaker/kata-eight-elixir](https://github.com/MitchellBaker/kata-eight-elixir/blob/master/lib/kata_eight.exs)\n\
    \n## TypeScript\n\n[string_xor.ts in kata-eight-typescript \xB7 MitchellBaker/kata-eight-typescript](https://github.com/MitchellBaker/kata-eight-typescript/blob/master/string_xor.ts)\n\
    \n## Elm\n\n[string_xor.elm in kata-eight-elm \xB7 MitchellBaker/kata-eight-elm](https://github.com/MitchellBaker/kata-eight-elm/blob/master/string_xor.elm)\n\
    \n## Haskell\n\n[string-xor.hs in kata-eight-haskell \xB7 MitchellBaker/kata-eight-haskell](https://github.com/MitchellBaker/kata-eight-haskell/blob/master/string-xor.hs)\n\
    \n## Racket\n\n[string-xor.rkt in kata-eight-racket \xB7 MitchellBaker/kata-eight-racket](https://github.com/MitchellBaker/kata-eight-racket/blob/master/string-xor.rkt)",
  "  (let loop ([a (string->list a)]\n             [b (string->list b)]\n        \
    \     [accum '()])\n    (cond [(or (empty? a) (empty? b))\n           (string-join\
    \ (reverse accum))]\n          [(char=? (car a) (car b))\n           (loop (cdr\
    \ a) (cdr b) (cons #\\0 accum))]\n          [else\n           (loop (cdr a) (cdr\
    \ b) (cons #\\1 accum))])))\n", "  (let loop ([i 0] [l (string-length a)])\n \
    \   (if (= i l)\n        #\"\"\n        (string-append (if (char=? (string-ref\
    \ a i) (string-ref b i))\n                          #\"0\"\n                 \
    \         #\"1\")\n                      (loop (+ i 1) l)))))\n", "  (cond\n \
    \   [(or (string=? a \"0\") (string=? b \"0\")) b]\n    [(or (string=? a \"1\"\
    ) (string=? b \"1\")) a]\n    [else \"fail\"]))\n", "  (define (recur n)\n   \
    \ (cond ((equal? n 0) \"\")\n          ((equal? (string-ref a n) (string-ref b\
    \ n)) \"0\")\n          (else \"1\")))\n  (define (string-reverse s)\n    (if\
    \ (string-empty? s)\n        s\n        (string-append (string-reverse (substring\
    \ s 1)) (string-ref s 0))))\n  (string-reverse (string-concatenate (build-list\
    \ (string-length a) recur))))\n", "  (cond [(string=? a b) \"0\"]\n        [else\
    \ \"1\"]))\n", "  (apply string (map (lambda (x y) (logxor x y)) (string->list\
    \ a) (string->list b))))\n", "  (cond ((string=? a \"\") \"\")\n        ((string=?\
    \ b \"\") \"\")\n        ((string=? (string-ref a 0) (string-ref b 0)) \"0\")\n\
    \        (else \"1\")))\n", "  (string-append (string-append\n               \
    \    (if (eq? (string-ref a 0) #\\1) (string-append #\\0) (string-append #\\1))\n\
    \                   (if (eq? (string-ref a 1) #\\1) (string-append #\\0) (string-append\
    \ #\\1)))\n                 (if (eq? (string-ref a 2) #\\1) (string-append #\\\
    0) (string-append #\\1))))\n", "  (bytes->string/utf-8 (string-xor (string->bytes/utf-8\
    \ a) (string->bytes/utf-8 b))))\n", "  (define (xor-p x y)\n    (if (eq? x y)\
    \ 0 1))\n  (string-append\n   (string (xor-p (string-ref a 0) (string-ref b 0)))\n\
    \   (string (xor-p (string-ref a 1) (string-ref b 1)))\n   (string (xor-p (string-ref\
    \ a 2) (string-ref b 2)))))\n```\n\n## [@lodash](https://lodash.com/)\n\n```javascript\n\
    // https://lodash.com/docs/4.17.4#xorBy\n\n/**\n * This method is like `_.xor`\
    \ except that it accepts `iteratee` which is\n * invoked for each element of each\
    \ `arrays` to generate the criterion by\n * which by which they're compared. The\
    \ iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf\
    \ _\n * @since 4.0.0\n * @category Array\n * @param {...Array} [arrays] The arrays\
    \ to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked\
    \ per element.\n * @returns {Array} Returns the new array of filtered values.\n\
    \ * @example\n *\n * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n * // => [1.2,\
    \ 3.4]\n *\n * // The `_.property` iteratee shorthand.\n * _.xorBy([{ 'x': 1 }],\
    \ [{ 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 2 }]\n */\nvar xorBy = baseRest(function(arrays)\
    \ {\n  var iteratee = last(arrays);\n  if (isArrayLikeObject(iteratee)) {\n  \
    \  iteratee = undefined;\n  }\n  return baseXor(arrayFilter(arrays, isArrayLikeObject),\
    \ getIteratee(iteratee, 2));\n});\n```\n\n## [@ramda](http://ramdajs.com/)\n\n\
    ```", "  (bytes->string/utf-8\n   (bytes-xor\n    (string->bytes/utf-8 a)\n  \
    \  (string->bytes/utf-8 b))))\n", "  (if (equal? (string-length a) (string-length\
    \ b))\n      (build-string (string-length a)\n                    (lambda (n)\n\
    \                      (integer->char\n                       (if (char=? (string-ref\
    \ a n) (string-ref b n))\n                           #x30 ;0\n               \
    \            #x31 ;1\n                           )\n                       )\n\
    \                      )\n                    )\n      (error \"string_xor: Inputs\
    \ are of different lengths!\")\n      )\n  )\n", "  (define (xor_int i j)\n  \
    \  (cond\n      [(= i 0) (char->integer j)]\n      [(= j 0) (char->integer i)]\n\
    \      [else 48]))\n  (define (xor_char i j)\n    (integer->char (xor_int i j)))\n\
    \  (define (xor_string a b)\n    (string-append\n      (list (xor_char (string-ref\
    \ a 0) (string-ref b 0)))\n      (list (xor_char (string-ref a 1) (string-ref\
    \ b 1)))\n      (list (xor_char (string-ref a 2) (string-ref b 2)))))\n  (xor_string\
    \ a b))", "  (apply string (map (lambda (x y) (xor x y)) (string->list a) (string->list\
    \ b))))\n", "  (apply string (map logical-xor (string-&gt;list a) (string-&gt;list\
    \ b))))\n", "  (string (bitwise-xor (string->number a 2) (string->number b 2)\
    \ 2)))\n", "  (cond\n    [(= (string-length a) 1) (string (logxor (string-&gt;number\
    \ (substring a 0 1)) (string-&gt;number (substring b 0 1))))]\n    [else (string\
    \ (logxor (string-&gt;number (substring a 0 1)) (string-&gt;number (substring\
    \ b 0 1)))) (string_xor (substring a 1) (substring b 1))]))\n</code>\nI am getting\
    \ this error:\n<code>logxor: expects type &lt;number&gt; as 1st argument, given\
    \ \"0\"; other arguments were: 0\n</code>\nI don't understand why I am getting\
    \ this error. I have done several test to make sure that I am passing numbers\
    \ to logxor function.\nCan someone please help me to find the bug in my code?\n\
    \n\nA:\n\nYour main bug is here:\n<code>[else (string (logxor (string-&gt;number\
    \ (substring a 0 1)) (string-&gt;number (substring b 0 1)))) (string_xor (substring\
    \ a 1) (substring b 1))]\n</code>\nYou're not properly concatenating the strings,\
    \ which is causing the error. This is where you should use <code>string-append</code>\
    \ in order to correctly process the recursion.\nAlso, you're not taking into account\
    \ the base case of the function, when the input has a length of <code>0</code>,\
    \ but there are probably other problems with the algorithm. Here's a different\
    \ approach that does what you ask:\n<code>(define (string-xor a b)\n  (let loop\
    \ ([a (string-&gt;list a)]\n             [b (string-&gt;list b)]\n           \
    \  [acc '()])\n    (cond [(empty? a) (string-&gt;list (apply string-append (reverse\
    \ acc)))]\n          [(empty? b) (string-&gt;list (apply string-append (reverse\
    \ acc)))]\n          [else (loop (rest a)\n                      (rest b)\n  \
    \                    (cons (number-&gt;string (logxor (string-&gt;number (first\
    \ a))\n                                                    (string-", "  (define\
    \ c 0)\n  (define s \"\")\n  (for ([i (in-range (string-length a))])\n    (set!\
    \ c (bitwise-xor (string-ref a i) (string-ref b i)))\n    (set! s (string-append\
    \ s (number->string c))))\n  s)\n```\n\n```racket\n#lang racket\n", "  (if (string=?\
    \ a \"\")\n      b\n      (if (string=? b \"\")\n          a\n          (if (string=?\
    \ (substring a 0 1) \"0\")\n              (if (string=? (substring b 0 1) \"0\"\
    )\n                  (string_xor (substring a 1) (substring b 1))\n          \
    \        (cons #\\1 (string_xor (substring a 1) (substring b 1))))\n         \
    \     (if (string=? (substring b 0 1) \"0\")\n                  (cons #\\1 (string_xor\
    \ (substring a 1) (substring b 1)))\n                  (string_xor (substring\
    \ a 1) (substring b 1)))))))\n</code>\nThe example in the question is extremely\
    \ short.  My version seems a bit longer, but what if we did it with lists?\n<code>#lang\
    \ racket\n", "  (local [\n    (define (xor x y)\n      (apply string\n       \
    \      (map (\u03BB (p) (if (equal? (car p) (cadr p)) \"0\" \"1\"))\n        \
    \          (zip (string->list x) (string->list y)))))])\n  (xor a b))\n", "  (apply\
    \ string (map (curryr op xor) (map string->number (string-&gt;list a)) (map string->number\
    \ (string-&gt;list b)))))\n", "  (cond [(eq? \"\" a) \"\" ]\n        [(eq? \"\"\
    \ b) \"\" ]\n        [else (string (bitwise-xor (string-&gt;number (string-ref\
    \ a 0))\n                                   (string-&gt;number (string-ref b 0))))\n\
    \              (string_xor (substring a 1) (substring b 1))]))\n</code>\nI suppose\
    \ the problem is in the last line where I'm trying to append the results of string_xor\
    \ on the substring of the input recursively.\n<code>&gt; (string_xor \"010\" \"\
    110\")\n\"100\"100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100\n\
    </code>\nI can't figure out why this is. What's the problem with the above implementation\
    \ appended result?\n\n\nA:\n\nYou are not appending the strings correctly. Your\
    \ last line should be:\n<code>(string-append (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                                    (string-&gt;number (string-ref\
    \ b 0))))\n              (string_xor (substring a 1) (substring b 1)))\n</code>\n\
    Basically the <code>string</code> function returns a string, but the <code>string_xor</code>\
    \ function returns the string <code>\"100\"</code> followed by a lot of extra\
    \ <code>\"100\"</code> strings.  This is because after you have done the <code>string</code>\
    \ call, you are just returning the <code>(string_xor (substring a 1) (substring\
    \ b 1))</code> value, which returns all of the <code>\"100\"", "  (define (single-xor\
    \ a b)\n    (cond ((= a 0) b)\n          ((= b 0) a)\n          (else 1)))\n \
    \ (let* ([xor-length (min (string-length a) (string-length b))]\n         [result\
    \ (make-string xor-length)]\n         [a-bytes (bytes-append (make-bytes xor-length\
    \ 0) (string->bytes a))]\n         [b-bytes (bytes-append (make-bytes xor-length\
    \ 0) (string->bytes b))])\n    (for/fold ([res-bytes result]) ([i (in-range xor-length)])\n\
    \      (bytes-set! res-bytes i (single-xor (bytes-ref a-bytes i) (bytes-ref b-bytes\
    \ i))))))\n```\n\n```\n#lang racket\n", "  (define (bit-xor? a b)\n    (cond\n\
    \      ((eq? a b) #f)\n      (else #t)))\n  (let ([result \"\"])\n    (let loop\
    \ ([i 0])\n      (when (&lt; i (string-length a))\n        (string-append! result\
    \ (bit-xor? (string-ref a i) (string-ref b i)))\n        (loop (+ i 1))))\n  \
    \  result))\n</code>\nBut I'm getting the following error:\n<code>; compile-context:\
    \ expected a procedure that can be applied to arguments", "  (string-append\n\
    \   (cond [(string=? (string-ref a 0) #\\0) \"0\"] [else \"1\"])\n   (cond [(string=?\
    \ (string-ref a 1) #\\0) \"0\"] [else \"1\"])\n   (cond [(string=? (string-ref\
    \ a 2) #\\0) \"0\"] [else \"1\"])))\n", "  (define (helper x y)\n    (cond [(and\
    \ (equal? x #\\1) (equal? y #\\0)) \"1\"]\n          [(and (equal? x #\\0) (equal?\
    \ y #\\1)) \"1\"]\n          [else \"0\"]))\n  (apply string (map helper (string->list\
    \ a) (string->list b))))", "  (let ([m (min (string-length a) (string-length b))])\n\
    \    (string-join (for/list ([i (in-range m)])\n                  (let ([ac (string-ref\
    \ a i)]\n                        [bc (string-ref b i)])\n                    (if\
    \ (and (char=? ac #\\1) (char=? bc #\\1))\n                        #\\0\n    \
    \                    (if (or (char=? ac #\\1) (char=? bc #\\1))\n            \
    \                #\\1\n                            #\\0)))))))\n", "  (define\
    \ (bit x y)\n    (cond [(and (= x 1) (= y 1)) 0]\n          [(or (= x 1) (= y\
    \ 1)) 1]\n          [else 0]))\n  (define (bits xs ys)\n    (cond [(empty? xs)\
    \ (empty ys)]\n          [(empty? ys) (empty xs)]\n          [else (cons (bit\
    \ (first xs) (first ys)) (bits (rest xs) (rest ys)))]))\n  (apply string (reverse\
    \ (bits (string->list a) (string->list b)))))\n\n", "  (cond\n    [(empty? a)\
    \ (string->list b)]\n    [(empty? b) (string->list a)]\n    [else (cons (xor (string-&gt;number\
    \ (string-ref a 0))\n                    (string-&gt;number (string-ref b 0)))\n\
    \                (string_xor (substring a 1) (substring b 1)))]))\n</code>\n",
  "  (list->string (map (lambda (x y)\n                       (integer->char (string-&gt;number\
    \ (number-&gt;string (char-&gt;integer x) 2)\n                               \
    \                          (char-&gt;integer y) 2)))\n                     (string-&gt;list\
    \ a)\n                     (string-&gt;list b))))\n</code>\n", "  (if (or (not\
    \ (string? a)) (not (string? b)))\n      \"Inputs must be strings of 1s and 0s\"\
    \n      (string-join\n       (map (lambda (x) (number->string (bitwise-xor (string-&gt;number\
    \ (car x)) (string-&gt;number (cadr x)))))\n            (apply append (map (lambda\
    \ (x) (list (list (car x) (cadr x)) (list (cadr x) (car x)))) (string-split a\
    \ #\\space))))\n       #\\space)))\n</code>\nThe outermost call to <code>string-join</code>\
    \ concatenates the result of <code>map</code> into a single string.\nThe <code>map</code>\
    \ is applied to the result of <code>apply append</code>, which is necessary because\
    \ we have to get the pairs <code>(a b)</code> and <code>(b a)</code> from the\
    \ list <code>(a b)</code>. Then, <code>map</code> applies <code>bitwise-xor</code>\
    \ to each pair. <code>bitwise-xor</code> works on numbers, so we have to convert\
    \ the string input to a number, do the bitwise-xor, and then convert the number\
    \ back to a string.\n", "  (define (xor a-char b-char)\n    (if (char=? #\\0 a-char)\n\
    \        b-char\n        (if (char=? #\\0 b-char)\n            a-char\n      \
    \      #\\0)))\n  (define (xor-string a b)\n    (if (string=? a \"\")\n      \
    \  b\n        (if (string=? b \"\")\n            a\n            (string-append\
    \ (string (xor (string-ref a 0) (string-ref b 0)))\n                         \
    \  (xor-string (substring a 1) (substring b 1))))))\n  (xor-string a b))\n", " \
    \ (define (xor-helper a b)\n    (if (or (zero? a) (zero? b))\n        (if (and\
    \ (zero? a) (zero? b))\n            0\n            (if (zero? a)\n           \
    \     b\n                a))\n        (cons (xor (modulo a 2) (modulo b 2))\n\
    \              (xor-helper (floor (/ a 2)) (floor (/ b 2))))))\n  (define (xor-list\
    \ a b)\n    (if (and (zero? a) (zero? b))\n        '()\n        (cons (xor (modulo\
    \ a 2) (modulo b 2))\n              (xor-list (floor (/ a 2)) (floor (/ b 2))))))\n\
    \  (define (xor-str a b)\n    (list->string (xor-list (string->number a 2) (string->number\
    \ b 2))))\n  (xor-str a b))\n", "  (string-join (map (\u03BB (x) (number->string\
    \ (xor (string-&gt;number (substring a (car x) (+ 1 (car x)))) (string-&gt;number\
    \ (substring b (cadr x) (+ 1 (cadr x))))))) (range (string-length a))) \"\"))\n",
  "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (car x)) (string->number (cadr x)))))\n        (zip (map (lambda (x) (number->string\
    \ x)) (string-&gt;list a))\n             (map (lambda (x) (number->string x))\
    \ (string-&gt;list b))))))\n", "  (string\n   (fold\n    (lambda (d res)\n   \
    \   (or\n       (and\n        (equal? d #\\0)\n        (and\n         (equal?\
    \ (string-ref a res) #\\0)\n         (equal? (string-ref b res) #\\0)))\n    \
    \   (and\n        (equal? d #\\1)\n        (not\n         (equal? (string-ref\
    \ a res) (string-ref b res))))))\n    0\n    (build-list (string-length a) (lambda\
    \ (i) #\\1)))))", "  (string-&gt;list a))\n", "  (let loop ([xor #f] [a (string->list\
    \ a)] [b (string->list b)])\n    (if (and (null? a) (null? b))\n        (apply\
    \ string (reverse xor))\n        (loop (cons (if (equal? (car a) (car b)) #\\\
    0 #\\1) xor)\n              (cdr a) (cdr b)))))\n", "  (if (equal? (string-length\
    \ a) 0)\n      \"\"\n      (if (equal? (string-length b) 0)\n          \"\"\n\
    \          (if (equal? (string-ref a 0) (string-ref b 0))\n              (string\
    \ (string-ref a 0) (string_xor (substring a 1) (substring b 1)))\n           \
    \   (string (logxor (string-ref a 0) (string-ref b 0)) (string_xor (substring\
    \ a 1) (substring b 1)))))))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b)\
    \ a]\n    [else\n     (string\n      (char (\n        (not (equal?\n         \
    \ (char-numeric (string-ref a 0))\n          (char-numeric (string-ref b 0))))\n\
    \          49 48)))\n      (string_xor (substring a 1) (substring b 1))]))\n",
  "  (bytes->string/utf-8 (string-xor (string->bytes/utf-8 a) (string->bytes/utf-8\
    \ b))))\n", "  (let loop ([a a] [b b] [r \"\"])\n    (cond [(null? a) r]\n   \
    \       [(null? b) r]\n          [else\n           (loop (rest a) (rest b) (string-append\
    \ r (string (bitwise-xor (char->integer (car a)) (char->integer (car b))))))])))\n",
  "  (cond\n    [(= (string-length a) 1)\n     (cond\n       [(= (string-ref a 0)\
    \ #\\0) b]\n       [else (string-append (string (logxor (string-ref a 0) #\\1))\
    \ (substring b 1))])]\n    [else (string-append (string (logxor (string-ref a\
    \ 0) (string-ref b 0))) (string_xor (substring a 1) (substring b 1)))]))\n", " \
    \ (apply string (map (curryr xor) (string->list a) (string->list b))))\n", " \
    \ (letrec ([f (\u03BB (a b idx)\n               (let ([x (string-ref a idx)]\n\
    \                     [y (string-ref b idx)])\n                 (if (and (equal?\
    \ x #\\0) (equal? y #\\0))\n                     #\\0\n                     (if\
    \ (and (equal? x #\\1) (equal? y #\\1))\n                         #\\0\n     \
    \                    #\\1))))])\n    (let loop ([acc \"\" : string]\n        \
    \       [a   a   : string]\n               [b   b   : string]\n              \
    \ [idx 0   : integer])\n      (if (&lt; idx (string-length a))\n          (loop\
    \ (string-append acc (string (f a b idx)))\n                a\n              \
    \  b\n                (+ idx 1))\n          acc))))\n</code>\n", "  (cond\n  \
    \  [(empty? a) b]\n    [(empty? b) a]\n    [else (cons (xor (string-&gt;number\
    \ (string (first a)))\n                     (string-&gt;number (string (first\
    \ b))))\n                (string_xor (rest a) (rest b)))]))\n</code>\nWhat I don't\
    \ like is the <code>(string-&gt;number (string (first a)))</code> part. Is there\
    \ a nicer way to do this?\n\n\nA:\n\nIt should work with a <code>char-&gt;number</code>\
    \ call instead of the <code>string-&gt;number</code> call.\n<code>(define (string_xor\
    \ a b)\n  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else (cons (xor\
    \ (char-&gt;number (first a))\n                     (char-&gt;number (first b)))\n\
    \                (string_xor (rest a) (rest b)))]))\n</code>\n", "  (cond [(equal?\
    \ a \"\") b]\n        [(equal? b \"\") a]\n        [else (make-string 1\n    \
    \                       (string-ref (string_xor (substring a 1) (substring b 1))\
    \ 0))]))\n", "  (let* ([len-a (string-length a)]\n         [len-b (string-length\
    \ b)]\n         [longest (max len-a len-b)]\n         [a-s (string->list a)]\n\
    \         [b-s (string->list b)])\n    (let loop ([i 0] [acc (list)])\n      (if\
    \ (= i longest)\n          (apply string acc)\n          (let ([x (char-&gt;integer\
    \ (if (&lt; i len-a) (list-ref a-s i) #\\0))]\n                [y (char-&gt;integer\
    \ (if (&lt; i len-b) (list-ref b-s i) #\\0))])\n            (loop (+ i 1) (cons\
    \ (integer-&gt;char (bitwise-xor x y)) acc)))))))\n</code>\n", "  (if (or (empty?\
    \ a) (empty? b))\n      \"\"\n      (number->string (bitwise-xor (string-&gt;number\
    \ (string a) 2)\n                                   (string-&gt;number (string\
    \ b) 2))\n                     2)))\n", "  (define (xor-lists xs ys)\n    (map\
    \ (lambda (x y)\n           (if (eq? (xor x y) 1)\n               #\\1\n     \
    \          #\\0))\n         xs\n         ys))\n  (apply string (xor-lists (string->list\
    \ a) (string->list b))))\n", "  (apply string (map ~ (map char-numeric-value (string-&gt;list\
    \ a)) (map char-numeric-value (string-&gt;list b)))))\n", "  (string-join (map\
    \ (\u03BB (p) (number->string (bitwise-xor (string-&gt;number (car p)) (string-&gt;number\
    \ (cadr p))))) (map (\u03BB (x) (list (substring a x (+ x 1)) (substring b x (+\
    \ x 1)))) (range (length a))))))\n</code>\nChallenge 2\nYour task is to translate\
    \ this code into any programming language that is NOT specified in the following\
    \ list:\n\nRacket\nScheme\nCommon Lisp\nLisp\nEmacs Lisp\nClojure\nOCaml\nHaskell\n\
    F#\nMercury\nLogo\nProlog\nScala\nLua\nPerl\nTcl\nawk\nsed\nBash\n\nYour code\
    \ should work correctly for any two strings of binary bits, both of which are\
    \ of equal length.\nPlease note that the XOR is not commutative (order of arguments\
    \ matters).\nIt is up to you to decide whether you want to check that the inputs\
    \ are valid (i.e. only contain 1s and 0s) or not.\nThe shortest code wins.\n\n\
    \nA:\n\nJ, 9 8 bytes\n<code>0^/^:@:\n</code>\nTry it online!\n", "  (regexp-replace*\
    \ #rx\"(.)\" (string-append a b) #:replace (\u03BB (m) (if (equal? (vector-ref\
    \ m 1) \"0\") \"1\" \"0\"))))\n", "  (cond [(and (= (string-length a) 1) (= (string-length\
    \ b) 1))\n         (if (and (equal? (string-ref a 0) #\\1)\n                 \
    \ (equal? (string-ref b 0) #\\1))\n             \"0\"\n             (if (or (equal?\
    \ (string-ref a 0) #\\1)\n                     (equal? (string-ref b 0) #\\1))\n\
    \                 \"1\"\n                 \"0\"))]\n        [else\n         (string_xor\
    \ (substring a 0 (- (string-length a) 1))\n                     (substring b 0\
    \ (- (string-length b) 1)))]))\n", "  (let ([alist (string-&gt;list a)]\n    \
    \    [blist (string-&gt;list b)])\n    (string-join\n     (map (lambda (x y) (integer-&gt;char\
    \ (char-&gt;integer x) (char-&gt;integer y)))\n          alist blist))))\n", " \
    \ (define (xor-chars a b)\n    (cond\n      [(and (char=? a #\\0) (char=? b #\\\
    0)) #\\0]\n      [(and (char=? a #\\1) (char=? b #\\1)) #\\0]\n      [else #\\\
    1]))\n  (string-join (map (lambda (c) (xor-chars (car c) (cadr c))) (zip (string->list\
    \ a) (string->list b))) \"\"))\n", "  (let loop ([as (string->list a)] [bs (string->list\
    \ b)] [r '()])\n    (cond [(null? as) (list->string (reverse r))]\n          [(null?\
    \ bs) (list->string (reverse r))]\n          [else\n           (let* ([c (string-ref\
    \ a (length as)]\n                  [d (string-ref b (length bs))])\n        \
    \     (cond\n               [(and (char=? c #\\1) (char=? d #\\1))\n         \
    \       (loop (rest as) (rest bs) (cons #\\0 r))]\n               [(or (and (char=?\
    \ c #\\1) (char=? d #\\0))\n                    (and (char=? c #\\0) (char=? d\
    \ #\\1)))\n                (loop (rest as) (rest bs) (cons #\\1 r))]\n       \
    \        [else\n                (loop (rest as) (rest bs) (cons #\\0 r))]))])))\n\
    </code>\n", "  (string-join (map (\u03BB (x) (number->string (xor (string-&gt;number\
    \ (string x))\n                                                (string-&gt;number\
    \ (string y)))))\n                    (string-&gt;list a))\n               \"\"\
    ))\n</code>\nI'm getting this error:\n<code>reference to undefined identifier:\
    \ x\n</code>\nI think it has something to do with the way I'm using map and the\
    \ anonymous function, but I can't figure out the correct way to do it. \n\n\n\
    A:\n\nThe problem is that the variables <code>x</code> and <code>y</code> are\
    \ not visible inside the function body.\nYou could try <code>lambda</code>, like\
    \ this:\n<code>(lambda (x y) (xor (string-&gt;number (string x))\n           \
    \        (string-&gt;number (string y))))\n</code>\n", "  (cond\n    [(= (string-length\
    \ a) 0) b]\n    [(= (string-length b) 0) a]\n    [else\n     (string-append\n\
    \      (string (logxor (string-ref a 0) (string-ref b 0)))\n      (string_xor\
    \ (substring a 1) (substring b 1)))]))\n```\n\n## [Pangrams](https://www.codewars.com/kata/pangram/ruby)\n\
    ```ruby\ndef pangram?(sentence)\n  sentence.downcase.chars.uniq.select{|x| x =~\
    \ /[a-z]/}.size == 26\nend\n```\n\n## [Human Readable Time](https://www.codewars.com/kata/human-readable-time/ruby)\n\
    ```ruby\ndef make_readable(seconds)\n  time = [seconds / 3600, seconds % 3600\
    \ / 60, seconds % 60]\n  time.map { |t| t.to_s.rjust(2, '0') }.join(':')\nend\n\
    ```\n\n## [Narcissistic Numbers](https://www.codewars.com/kata/narcissistic-numbers/ruby)\n\
    ```ruby\ndef narcissistic?(value)\n  str = value.to_s\n  value == str.chars.map\
    \ { |ch| ch.to_i ** str.size }.reduce(:+)\nend\n```\n\n## [Pick Peaks](https://www.codewars.com/kata/pick-peaks/ruby)\n\
    ```ruby\ndef pick_peaks(arr)\n  output = {'pos' => [], 'peaks' => []}\n  peak\
    \ = false\n  pos = 0\n  arr.each_with_index do |el, i|\n    if peak\n      if\
    \ el < arr[i - 1]\n        peak = false\n        output['pos'] << pos\n      \
    \  output['peaks'] << arr[pos]\n      end\n    elsif el > arr[i + 1]\n      peak\
    \ = true\n      pos = i\n    end\n  end\n  output\nend\n", "  (define (helper\
    \ a b i acc)\n    (if (and (&lt; i (string-length a))\n             (&lt; i (string-length\
    \ b)))\n        (helper a b (+ i 1) (string-append acc (if (eq? (string-ref a\
    \ i) (string-ref b i))\n                                                    \"\
    0\"\n                                                    \"1\")))\n        acc))\n\
    \  (helper a b 0 \"\"))\n", "  (if (string=? a \"\")\n      \"\"\n      (string-append\
    \ (string #\\0 (if (and (char=? (string-ref a 0) #\\1)\n                     \
    \                    (char=? (string-ref b 0) #\\1))\n                       \
    \             #\\0\n                                    #\\1))\n             \
    \         (string_xor (substring a 1) (substring b 1)))))\n", "  (string-join\
    \ (map (lambda (x) (cond ((= (car x) (cadr x))\n                             \
    \           #\\0)\n                                       (else\n            \
    \                            #\\1)))\n                     (zip (string->list\
    \ a) (string->list b)))\n               \"\"))\n", "  (define (do-xor x y)\n \
    \   (cond\n      ((or (equal? x '0) (equal? y '0)) '0)\n      ((or (equal? x '1)\
    \ (equal? y '1)) '1)\n      (else (error \"invalid input\"))))\n  (apply string\
    \ (for/list ([x (in-string a)]\n                          [y (in-string b)])\n\
    \                 (do-xor x y))))\n", "  (define (xor x y)\n    (cond\n      [(=\
    \ x y) \"0\"]\n      [else \"1\"]))\n  (define (shorten str)\n    (if (string=?\
    \ str \"\")\n        \"0\"\n        str))\n  (define (string-XOR-helper a b c)\n\
    \    (if (or (string=? a \"\") (string=? b \"\"))\n        (string-append c (shorten\
    \ a) (shorten b))\n        (string-XOR-helper (string-tail a) (string-tail b)\
    \ (string-append c (xor (string-ref a 0) (string-ref b 0))))))\n  (string-XOR-helper\
    \ a b \"\"))\n", "  ;; You can make a list of strings consisting of 1s and 0s\n\
    \  ;; by applying string-append on a list of numbers.\n  ;; You may find (expt\
    \ 2 -1) useful.\n  (error \"todo\"))\n```\n\n## Running\n\n```\n$ racket reversi.rkt\n\
    ```\n\n## Testing\n\n```\n$ racket test.rkt\n```", "  (define (xor-char ac bc)\n\
    \    (cond [(string=? \"0\" ac) bc]\n          [(string=? \"0\" bc) ac]\n    \
    \      [else \"0\"]))\n  (define (xor-helper i acc)\n    (if (&lt; i (string-length\
    \ a))\n        (xor-helper (+ i 1) (string-append acc (xor-char (string-ref a\
    \ i) (string-ref b i))))\n        acc))\n  (xor-helper 0 \"\"))\n", "  (define\
    \ (xor a b)\n    (if (or (and (equal? a #\\1) (equal? b #\\0))\n            (and\
    \ (equal? a #\\0) (equal? b #\\1)))\n        #\\1\n        #\\0))\n  (apply string\
    \ (map xor (string->list a) (string->list b))))", "  (string-&gt;list a))\n",
  "  (number->string (xor (string->number a 2) (string->number b 2) 2)))\n", "  (number->string\n\
    \   (bitwise-xor (string->number a 2) (string->number b 2))))\n", "  (string (logxor\
    \ (string->number a 2) (string->number b 2) 2)))\n", "  (define (int_to_bin i)\n\
    \    (if (= i 0) \"\"\n        (string (remainder i 2))\n        (int_to_bin (quotient\
    \ i 2))))\n  (define (bin_to_int bin)\n    (if (string=? bin \"\") 0\n       \
    \ (+ (* (string-&gt;number (string (string-ref bin 0)))\n              (expt 2\
    \ (string-length bin)))\n           (bin_to_int (substring bin 1)))))\n  (define\
    \ (xor a b)\n    (string (if (and (string=? (string-ref a 0) #\\1)\n         \
    \             (string=? (string-ref b 0) #\\0))\n                 #\\1\n     \
    \            (if (and (string=? (string-ref a 0) #\\0)\n                     \
    \     (string=? (string-ref b 0) #\\1))\n                     #\\1\n         \
    \            #\\0)))\n    (if (zero? (string-length a)) \"\"\n        (xor (substring\
    \ a 1) (substring b 1))))\n  (define (add bin1 bin2)\n    (if (string=? bin1 \"\
    \") bin2\n        (if (string=? bin2 \"\") bin1\n            (add (substring bin1\
    \ 1)\n                 (substring bin2 1)))))\n  (add (int_to_bin (bitwise-xor\
    \ (bin_to_int a) (bin_to_int b))) \"\"))\n</code>\nI want to optimize it. I use\
    \ <code>expt</code> and <code>bitwise-xor</code> for converting input numbers\
    \ to binary and back, and then I use <code>string-length</code> and <code>string-ref</code>\
    \ for XORing.\nHow can I optimize it? Is there any better way to convert from\
    \ binary to string?\n\n\nA:\n\nThe code is only correct for lengths that are even\
    \ powers of 2 (8, 16, 32, 64...), because the <code>bitwise-xor</code> relies\
    \ on its inputs being sufficiently wide.\nA straightforward conversion to strings\
    \ of 1s and 0s would use a sequence of these steps:\n\nSplit the input", "  (define\
    \ (xor-char ac bc)\n    (string\n     (if (equal? (string-&gt;number (string ac))\
    \ (string-&gt;number (string bc)))\n         #\\0\n         #\\1)))\n  (build-string\
    \ (min (string-length a) (string-length b))\n                (lambda (i) (xor-char\
    \ (string-ref a i) (string-ref b i)))))\n", "  (for/list ([i (in-range (string-length\
    \ a))])\n    (number->string (string-ref a i)\n                    (string-ref\
    \ b i))))\n</code>\nUsage:\n<code>&gt; (string_xor \"010\" \"110\")\n'(\"100\"\
    )\n</code>\nNote the <code>string_xor</code> returns a list of characters, not\
    \ a string.\n", "  (string-join\n   (map\n    (lambda (p)\n      (number->string\
    \ (bitwise-xor (string-&gt;number (string-ref p 0))\n                        \
    \           (string-&gt;number (string-ref p 1)))))\n    (partition a b))))\n",
  "  (let ((a (string->list a))\n        (b (string->list b)))\n    (if (null? a)\n\
    \        \"\"\n        (if (equal? (car a) (car b))\n            (string_xor (cdr\
    \ a) (cdr b))\n            (append (string (if (equal? (car a) #\\1) #\\0 #\\\
    1))\n                    (string_xor (cdr a) (cdr b)))))))\n", "  (cond\n    [(empty?\
    \ a) b]\n    [(empty? b) a]\n    [else (string_xor (rest a) (rest b))]))\n", " \
    \ (define (partials a b)\n    (let ((a-len (string-length a))\n          (b-len\
    \ (string-length b)))\n      (let loop ((a a) (b b) (a-len a-len) (b-len b-len)\
    \ (a-rev '()) (b-rev '()))\n        (if (or (zero? a-len) (zero? b-len))\n   \
    \         (values (reverse a-rev) (reverse b-rev))\n            (let-values (((a-rest\
    \ a-rest-len) (substring a 1 a-len))\n                         ((b-rest b-rest-len)\
    \ (substring b 1 b-len)))\n              (loop a-rest b-rest (- a-len 1) (- b-len\
    \ 1) (cons (string-ref a 0) a-rev) (cons (string-ref b 0) b-rev)))))))\n  (define\
    \ (compose a b)\n    (let ((a-len (string-length a))\n          (b-len (string-length\
    \ b)))\n      (cond ((zero? a-len) b)\n            ((zero? b-len) a)\n       \
    \     (else (string (string-ref a 0) (string-ref b 0)) (compose (substring a 1\
    \ a-len) (substring b 1 b-len))))))\n  (define (xor a b)\n    (let ((a-len (string-length\
    \ a))\n          (b-len (string-length b)))\n      (cond ((zero? a-len) b)\n \
    \           ((zero? b-len) a)\n            (else (xor (substring a 1 a-len) (substring\
    \ b 1 b-len)) (compose (substring a 0 1) (substring b 0 1))))))\n  (let-values\
    \ (((a-parts b-parts) (partials a b)))\n    (xor a-parts b-parts)))\n", "  (define\
    \ (inner x y)\n    (cond\n      ((zero? (string-length x)) y)\n      ((zero? (string-length\
    \ y)) x)\n      (else (string-append (string (bitwise-xor (string-ref x 0) (string-ref\
    \ y 0)))\n                           (inner (substring x 1) (substring y 1))))))\n\
    \  (define (pad s)\n    (cond\n      ((zero? (string-length s)) \"\")\n      ((not\
    \ (equal? (string-length s) (string-length b))) (pad (string-append \"0\" s)))\n\
    \      (else s)))\n  (inner (pad a) (pad b)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
