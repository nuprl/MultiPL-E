name: HumanEval_22_filter_integers
language: rkt
prompt: "#lang racket\n\n;; Filter given list of any rktthon values only for integers\n\
  ;; >>> (filter_integers (list \"a\" 3.14 5))\n;; (list 5)\n;; >>> (filter_integers\
  \ (list 1 2 3 \"abc\" #hash() (list )))\n;; (list 1 2 3)\n(define (filter_integers\
  \ values)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_integers))\n\
  \    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate (list\
  \ 4 #hash() (list ) 23.2 9 \"adasd\")) (list 4 9))\n    (check-equal? (candidate\
  \ (list 3 \"c\" 3 3 \"a\" \"b\")) (list 3 3 3))\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? values) empty]\n        [(integer? (first values))\
    \ (cons (first values) (filter_integers (rest values)))]\n        [else (filter_integers\
    \ (rest values))]))\n", "  (filter integer? values))\n```\n\n###### Python:\n\n\
    ```python\n#lang pyret\n\n# Filter given list of any rktthon values only for integers\n\
    # >>> (filter_integers (list \"a\" 3.14 5))\n# (list 5)\n# >>> (filter_integers\
    \ (list 1 2 3 \"abc\" #hash() (list )))\n# (list 1 2 3)\ndef filter_integers(values):\n\
    \  return filter(is_integer, values)\n```\n\n## Hints\n\nThe functions `flatten`,\
    \ `append`, `filter`, `foldr`, `foldl`, `foldl1`, `any`, `all`, `map`, `for-each`,\
    \ `or`, `and`, `not`, `cons`, `first`, `rest`, `empty`, `empty?`, `equal?`, `eq?`,\
    \ `equal-every?`, `=`, `>`, `<`, `>=`, `<=`, `add1`, `sub1`, `zero?`, `<=`, `>=`,\
    \ `zero?`, `even?`, `odd?`, `positive?`, `negative?`, `max`, `min`, `*`, `-`,\
    \ `/`, `abs`, `quotient`, `remainder`, `modulo`, `gcd`, `lcm`, `integer?`, `symbol?`,\
    \ `string?`, `char?`, `boolean?`, `list?`, `pair?`, `vector?`, `null?`, `procedure?`,\
    \ `function?`, `date?`, `rational?`, `number?`, `string->number`, `number->string`,\
    \ `list->vector`, `vector->list`, `list->string`, `string->list`, `symbol->string`,\
    \ `string->symbol`, `char->integer`, `integer->char`, `string->integer`, `integer->string`,\
    \ `string-length`, `string-ref`, `string-set!`, `string-append`, `string-append/shared`,\
    \ `string=?`, `string<?`, `string>?`, `string<=?`, `string>=?`, `make-string`,\
    \ `string-copy`, `string-copy!`, `string-fill!`, `string-append/shared`, `string-append`,",
  "  (filter (lambda (x) (integer? x)) values))\n", "  (filter (lambda (n) (integer?\
    \ n)) values))\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (cond\n\
    \    [(empty? values) '()]\n    [(integer? (first values)) (cons (first values)\
    \ (filter_integers (rest values)))]\n    [else (filter_integers (rest values))]))\n",
  "  (filter (lambda (item) (integer? item)) values))\n", "  (cond\n    [(empty? values)\
    \ (list)]\n    [(number? (first values))\n     (cons (first values) (filter_integers\
    \ (rest values)))]\n    [else (filter_integers (rest values))]))\n", "  (cond\n\
    \    [(empty? values) (list)]\n    [(integer? (first values))\n      (cons (first\
    \ values) (filter_integers (rest values)))]\n    [else (filter_integers (rest\
    \ values))]))\n", "  (filter (\u03BB (x) (integer? x)) values))\n", "    (if (null?\
    \ values)\n        '()\n        (let ([first (car values)]\n              [rest\
    \ (cdr values)])\n            (if (integer? first)\n                (cons first\
    \ (filter_integers rest))\n                (filter_integers rest)))))\n", "  (filter\
    \ number? values))\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (filter\
    \ number? values))\n", "  (cond\n    [(empty? values) '()]\n    [(integer? (first\
    \ values)) (cons (first values) (filter_integers (rest values)))]\n    [else (filter_integers\
    \ (rest values))]))\n", "  (cond\n    [(empty? values) empty]\n    [(integer?\
    \ (first values))\n     (cons (first values) (filter_integers (rest values)))]\n\
    \    [else (filter_integers (rest values))]))\n", "  (filter (\u03BB (x) (and\
    \ (integer? x) (not (zero? x)))) values))\n", "  (define (is_integer x)\n    (cond\
    \ ((integer? x) #t)\n          (else #f)))\n  (filter is_integer values))\n",
  "  (filter (lambda (x) (and (number? x) (not (inexact? x)))) values))\n", "  (filter\
    \ (lambda (x) (integer? x)) values))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
