name: HumanEval_22_filter_integers
language: rkt
prompt: "#lang racket\n\n;; Filter given list of any rktthon values only for integers\n\
  ;; >>> (filter_integers (list \"a\" 3.14 5))\n;; (list 5)\n;; >>> (filter_integers\
  \ (list 1 2 3 \"abc\" #hash() (list )))\n;; (list 1 2 3)\n(define (filter_integers\
  \ values)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_integers))\n\
  \    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate (list\
  \ 4 #hash() (list ) 23.2 9 \"adasd\")) (list 4 9))\n    (check-equal? (candidate\
  \ (list 3 \"c\" 3 3 \"a\" \"b\")) (list 3 3 3))\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? values) empty]\n        [(integer? (first values))\
    \ (cons (first values) (filter_integers (rest values)))]\n        [else (filter_integers\
    \ (rest values))]))\n", "  (filter integer? values))\n```\n\n###### Python:\n\n\
    ```python\n#lang pyret\n\n# Filter given list of any rktthon values only for integers\n\
    # >>> (filter_integers (list \"a\" 3.14 5))\n# (list 5)\n# >>> (filter_integers\
    \ (list 1 2 3 \"abc\" #hash() (list )))\n# (list 1 2 3)\ndef filter_integers(values):\n\
    \  return filter(is_integer, values)\n```\n\n## Hints\n\nThe functions `flatten`,\
    \ `append`, `filter`, `foldr`, `foldl`, `foldl1`, `any`, `all`, `map`, `for-each`,\
    \ `or`, `and`, `not`, `cons`, `first`, `rest`, `empty`, `empty?`, `equal?`, `eq?`,\
    \ `equal-every?`, `=`, `>`, `<`, `>=`, `<=`, `add1`, `sub1`, `zero?`, `<=`, `>=`,\
    \ `zero?`, `even?`, `odd?`, `positive?`, `negative?`, `max`, `min`, `*`, `-`,\
    \ `/`, `abs`, `quotient`, `remainder`, `modulo`, `gcd`, `lcm`, `integer?`, `symbol?`,\
    \ `string?`, `char?`, `boolean?`, `list?`, `pair?`, `vector?`, `null?`, `procedure?`,\
    \ `function?`, `date?`, `rational?`, `number?`, `string->number`, `number->string`,\
    \ `list->vector`, `vector->list`, `list->string`, `string->list`, `symbol->string`,\
    \ `string->symbol`, `char->integer`, `integer->char`, `string->integer`, `integer->string`,\
    \ `string-length`, `string-ref`, `string-set!`, `string-append`, `string-append/shared`,\
    \ `string=?`, `string<?`, `string>?`, `string<=?`, `string>=?`, `make-string`,\
    \ `string-copy`, `string-copy!`, `string-fill!`, `string-append/shared`, `string-append`,",
  "  (filter (lambda (x) (integer? x)) values))\n", "  (filter (lambda (n) (integer?\
    \ n)) values))\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (cond\n\
    \    [(empty? values) '()]\n    [(integer? (first values)) (cons (first values)\
    \ (filter_integers (rest values)))]\n    [else (filter_integers (rest values))]))\n",
  "  (filter (lambda (item) (integer? item)) values))\n", "  (cond\n    [(empty? values)\
    \ (list)]\n    [(number? (first values))\n     (cons (first values) (filter_integers\
    \ (rest values)))]\n    [else (filter_integers (rest values))]))\n", "  (cond\n\
    \    [(empty? values) (list)]\n    [(integer? (first values))\n      (cons (first\
    \ values) (filter_integers (rest values)))]\n    [else (filter_integers (rest\
    \ values))]))\n", "  (filter (\u03BB (x) (integer? x)) values))\n", "    (if (null?\
    \ values)\n        '()\n        (let ([first (car values)]\n              [rest\
    \ (cdr values)])\n            (if (integer? first)\n                (cons first\
    \ (filter_integers rest))\n                (filter_integers rest)))))\n", "  (filter\
    \ number? values))\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (filter\
    \ number? values))\n", "  (cond\n    [(empty? values) '()]\n    [(integer? (first\
    \ values)) (cons (first values) (filter_integers (rest values)))]\n    [else (filter_integers\
    \ (rest values))]))\n", "  (cond\n    [(empty? values) empty]\n    [(integer?\
    \ (first values))\n     (cons (first values) (filter_integers (rest values)))]\n\
    \    [else (filter_integers (rest values))]))\n", "  (filter (\u03BB (x) (and\
    \ (integer? x) (not (zero? x)))) values))\n", "  (define (is_integer x)\n    (cond\
    \ ((integer? x) #t)\n          (else #f)))\n  (filter is_integer values))\n",
  "  (filter (lambda (x) (and (number? x) (not (inexact? x)))) values))\n", "  (filter\
    \ (lambda (x) (integer? x)) values))\n", "  (cond\n    [(empty? values) '()]\n\
    \    [(integer? (first values)) (cons (first values) (filter_integers (rest values)))]\n\
    \    [else (filter_integers (rest values))]))\n", "    (filter (lambda (x) (integer?\
    \ x)) values))\n", "  (filter integer? values))\n", "  (define (accumulator value\
    \ acc)\n    (if (integer? value)\n        (cons value acc)\n        acc))\n  (foldr\
    \ accumulator (list) values))\n</code>\nNotice how <code>accumulator</code> is\
    \ used to filter out non-integer values.\n", "  (filter\n   (\u03BB (x) (and (integer?\
    \ x) (not (zero? x))))\n   values))\n", "  (filter number? values))\n", "  (if\
    \ (null? values)\n      (list)\n      (if (integer? (car values))\n          (cons\
    \ (car values) (filter_integers (cdr values)))\n          (filter_integers (cdr\
    \ values)))))\n", "  (cond\n    [(null? values) (list)]\n    [(integer? (car values))\
    \ (cons (car values) (filter_integers (cdr values)))]\n    [else (filter_integers\
    \ (cdr values))]))\n", "    (map (lambda (x)\n           (if (integer? x)\n  \
    \             x\n               #f))\n         values))\n", "  (filter integer?\
    \ values))\n", "  (define (internal values)\n    (if (null? values)\n        '()\n\
    \        (if (integer? (car values))\n            (cons (car values) (internal\
    \ (cdr values)))\n            (internal (cdr values)))))\n  (internal values))\n",
  "  (filter (lambda (v) (integer? v)) values))\n", "  (define (filter pred values)\n\
    \    (cond [(empty? values) (list)]\n          [(pred (first values)) (cons (first\
    \ values) (filter pred (rest values)))]\n          [else (filter pred (rest values))]))\n\
    \  (filter integer? values))\n```\n\nIn the example above we pass a `pred` predicate\
    \ to `filter` which we use to test every element in the `values` list.\n\n###\
    \ Map\n\nWe want to be able to apply a function to all the elements of a list.\
    \ For example, we want to make all the items in a list uppercase.\n\nWe need a\
    \ function that takes a function and a list. Then the function is applied to every\
    \ element in the list.\n\n```#lang racket\n", "    (for/list ([x values] #:when\
    \ (integer? x))\n        x))\n", "    (filter integer? values))\n", "  (cond ((empty?\
    \ values) '())\n        ((integer? (first values)) (cons (first values) (filter_integers\
    \ (rest values))))\n        (else (filter_integers (rest values)))))\n", "  (filter\
    \ (lambda (v) (integer? v)) values))\n", "  (filter (lambda (v) (integer? v))\
    \ values))\n", "  (filter (\u03BB (x) (integer? x)) values))\n", "  (filter integer?\
    \ values))\n", "    (filter number? values))\n", "  (filter integer? values))\n",
  "    (filter (lambda (x) (integer? x)) values))\n```\n\n## B3\n```racket\n#lang\
    \ racket\n", "  (define (iter items acc)\n    (if (empty? items)\n        acc\n\
    \        (let ((item (first items)))\n          (if (integer? item)\n        \
    \      (iter (rest items) (append acc (list item)))\n              (iter (rest\
    \ items) acc)))))\n  (iter values (list)))\n", "  (if (null? values)\n      '()\n\
    \      (if (integer? (car values))\n          (cons (car values) (filter_integers\
    \ (cdr values)))\n          (filter_integers (cdr values)))))\n", "  (filter integer?\
    \ values))\n", "  (filter number? values))\n", "    (filter integer? values))\n",
  "  (cond ((null? values) '())\n        ((integer? (car values)) (cons (car values)\
    \ (filter_integers (cdr values))))\n        (else (filter_integers (cdr values)))))\n",
  "  (filter (lambda (x) (integer? x)) values))\n", "  (define (is_integer? value)\n\
    \    (and (not (list? value))\n         (not (string? value))\n         (not (hash?\
    \ value))\n         (number? value)\n         (integer? value)))\n  (filter is_integer?\
    \ values))\n", "  (filter (\u03BB (item) (integer? item)) values))\n```\n\n```racket\n\
    #lang racket\n", "  (filter (lambda (v) (integer? v)) values))\n", "  (filter\
    \ (\u03BB (x) (integer? x)) values))\n", "  ;; \n  ;; add your code here\n  ;;\n\
    \  (filter number? values))\n", "  (filter (\u03BB (x) (integer? x)) values))",
  "  (filter (lambda (x) (integer? x)) values))\n", "  (filter integer? values))\n",
  "  (filter (\u03BB (x) (integer? x)) values))\n", "    (filter (\u03BB (v) (integer?\
    \ v)) values))\n", "  (filter integer? values))\n", "  (filter (lambda (x) (number?\
    \ x)) values))\n", "  (filter integer? values))\n", "  (filter (\u03BB (v) (integer?\
    \ v)) values))\n```\n\n```racket\n#lang racket\n", "  (filter (\u03BB (val) (integer?\
    \ val)) values))\n```\n\n> **NOTE:** See [here](https://docs.racket-lang.org/raco/raco.html)\
    \ for more information about using raco.\n\n## Available Commands\n\nThe following\
    \ commands are available:\n\n| Command | Description |\n| ------- | -----------\
    \ |\n| `load-check` | Loads code and validates it. |\n| `load-run` | Loads code\
    \ and runs it using [raco](https://docs.racket-lang.org/raco/raco.html) |\n| `show-report`\
    \ | Displays the stored report from the latest load-check. |\n| `clear-report`\
    \ | Clears the stored report. |\n| `show-code` | Displays the stored code from\
    \ the latest load-check. |\n| `clear-code` | Clears the stored code. |\n| `download-code`\
    \ | Downloads the stored code. |\n| `show-image` | Displays the stored image from\
    \ the latest load-check. |\n| `clear-image` | Clears the stored image. |\n| `download-image`\
    \ | Downloads the stored image. |\n| `exit` | Closes the connection to the kernel.\
    \ |\n\n## Images\n\nImages can be included in code through the `#lang image` language:\n\
    \n```\n#lang image\n", "  (filter integer? values))\n", "  (cond\n    [(empty?\
    \ values) empty]\n    [(integer? (first values))\n     (cons (first values) (filter_integers\
    \ (rest values)))]\n    [else (filter_integers (rest values))]))\n", "  (cond\n\
    \    [(empty? values) (list)]\n    [(integer? (first values))\n     (cons (first\
    \ values) (filter_integers (rest values)))]\n    [else (filter_integers (rest\
    \ values))]))\n", "  (define (filtered-list lst)\n    (if (null? lst)\n      '()\n\
    \      (if (integer? (car lst))\n        (cons (car lst) (filtered-list (cdr lst)))\n\
    \        (filtered-list (cdr lst)))))\n  (filtered-list values))\n", "    (cond\n\
    \        [(empty? values) null]\n        [(integer? (first values))\n        \
    \    (cons (first values) (filter_integers (rest values)))]\n        [else (filter_integers\
    \ (rest values))]))\n", "  (filter (lambda (val) (number? val)) values))\n", " \
    \ (filter number? values))\n", "  (if (empty? values)\n      (list)\n      (if\
    \ (integer? (first values))\n          (cons (first values) (filter_integers (rest\
    \ values)))\n          (filter_integers (rest values)))))\n", "  (filter\n   (\u03BB\
    \ (value) (integer? value))\n   values))\n", "  (filter number? values))\n", " \
    \ (cond\n    [(null? values) '()]\n    [(integer? (car values)) (cons (car values)\
    \ (filter_integers (cdr values)))]\n    [else (filter_integers (cdr values))]))\n",
  "    (cond\n        ((empty? values) (list))\n        ((integer? (first values))\n\
    \            (cons (first values) (filter_integers (rest values))))\n        (else\
    \ (filter_integers (rest values)))))\n", "  (filter (\u03BB (x) (integer? x))\
    \ values))\n```\n\n`filter_integers` and `filter_strings` functions are similar.\
    \ We can make a version that is less repetitive.\n\n```racket\n#lang racket\n",
  "  (filter (lambda (x) (integer? x)) values))\n", "  (cond\n    [(empty? values)\
    \ '()]\n    [(integer? (first values)) (cons (first values) (filter_integers (rest\
    \ values)))]\n    [else (filter_integers (rest values))]))\n", "  (cond\n    [(empty?\
    \ values) empty]\n    [(and (integer? (first values))\n          (filter_integers\
    \ (rest values)))\n     (cons (first values)\n           (filter_integers (rest\
    \ values)))]\n    [else (filter_integers (rest values))]))\n", "  (filter (lambda\
    \ (x) (integer? x)) values))\n", "  (filter integer? values))\n", "  (let loop\
    \ ((values values) (result '()))\n    (cond\n      [(empty? values) result]\n\
    \      [(integer? (first values)) (loop (rest values) (append result (list (first\
    \ values))))]\n      [else (loop (rest values) result)])))\n", "  (filter number?\
    \ values))\n", "  (filter (lambda (x) (integer? x)) values))\n```\n\n```#lang\
    \ racket\n", "  (filter (\u03BB (x) (and (number? x) (integer? x))) values))\n\
    ```\n\n```racket", "  (filter (lambda (value) (integer? value)) values))\n", " \
    \ (filter (lambda (x) (integer? x)) values))\n", "    (if (null? values)\n   \
    \     (list)\n        (if (integer? (car values))\n            (cons (car values)\
    \ (filter_integers (cdr values)))\n            (filter_integers (cdr values)))))\n",
  "  (if (null? values)\n      '()\n      (if (integer? (car values))\n          (cons\
    \ (car values) (filter_integers (cdr values)))\n          (filter_integers (cdr\
    \ values)))))\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (filter\
    \ (lambda (x) (integer? x)) values))\n", "  (filter (lambda (value) (integer?\
    \ value)) values))\n", "  (filter (lambda (v) (integer? v)) values))\n```\n\n\
    ```racket\n#lang racket\n", "    (filter (lambda (x) (integer? x)) values))\n\
    ```\n\n``` #lang racket\n", "  (cond\n    [(empty? values) empty]\n    [(integer?\
    \ (first values))\n     (cons (first values) (filter_integers (rest values)))]\n\
    \    [else (filter_integers (rest values))]))\n", "  (define (internal vals)\n\
    \    (if (null? vals)\n        (list)\n        (if (integer? (car vals))\n   \
    \         (cons (car vals) (internal (cdr vals)))\n            (internal (cdr\
    \ vals)))))\n  (internal values))\n", "  (filter (lambda (v) (integer? v)) values))\n\
    ```\n\n###rktthon\n```racket\n#lang rktthon\n", "  (filter (\u03BB (x) (integer?\
    \ x)) values))\n", "  (filter (lambda (v) (integer? v)) values))\n", "  (filter\
    \ integer? values))\n", "  (filter integer? values))\n", "  (filter (lambda (v)\
    \ (integer? v)) values))\n", "  (filter number? values))\n", "  (cond ((empty?\
    \ values) (list))\n        ((number? (first values))\n         (cons (first values)\
    \ (filter_integers (rest values))))\n        (else (filter_integers (rest values)))))\n",
  "  (filter integer? values))\n", "  (filter (\u03BB (a) (integer? a)) values))\n",
  "  ;; YOUR CODE GOES HERE\n  (filter integer? values))\n", "  (filter number? values))\n",
  "  (filter (lambda (v) (integer? v)) values))\n", "  (filter number? values))\n",
  "    (filter integer? values))\n", "  (filter (lambda (x) (integer? x)) values))\n",
  "    (filter number? values))\n```\n\n```racket\n#lang racket\n", "  (filter (\u03BB\
    \ (v) (integer? v)) values))\n", "  (filter (lambda (x) (integer? x)) values))\n",
  "  (filter (lambda (x) (and (integer? x) x)) values))\n", "  (filter integer? values))\n",
  "  (cond\n    [(empty? values) '()]\n    [(integer? (first values)) (cons (first\
    \ values) (filter_integers (rest values)))]\n    [else (filter_integers (rest\
    \ values))]))\n", "  (filter integer? values))\n", "  (apply list (filter integer?\
    \ values)))\n", "  (filter integer? values))\n", "  (filter (lambda (x) (integer?\
    \ x)) values))\n", "  (filter number? values))\n", "  (filter (\u03BB (x) (integer?\
    \ x)) values))\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (filter\
    \ (lambda (val) (and (integer? val) val)) values))\n", "    (filter (lambda (x)\
    \ (number? x)) values))\n", "  (filter (lambda (x) (integer? x)) values))\n",
  "  (filter (lambda (x) (integer? x)) values))\n", "  (cond [(null? values)\n   \
    \      '()]\n        [(not (integer? (car values)))\n         (filter_integers\
    \ (cdr values))]\n        [else\n         (cons (car values) (filter_integers\
    \ (cdr values)))]))\n", "  (filter (lambda (x) (and (not (symbol? x)) (integer?\
    \ x))) values))\n", "  (filter integer? values))\n```\n\n``` #lang racket\n",
  "  (cond\n    [(empty? values) (list)]\n    [(integer? (first values))\n     (cons\
    \ (first values) (filter_integers (rest values)))]\n    [else (filter_integers\
    \ (rest values))]))\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (filter\
    \ (lambda (x) (integer? x)) values))\n", "  (for/list ([val values]\n        \
    \     #:when (integer? val))\n    val))\n", "    (filter (\u03BB (x) (integer?\
    \ x)) values))\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (for/list\
    \ ([n values]\n             #:when (number? n))\n    n))\n", "  (filter (lambda\
    \ (value) (integer? value)) values))\n", "    (filter (lambda (x) (integer? x))\
    \ values))\n", "  (filter integer? values))\n", "  (filter (lambda (x) (integer?\
    \ x)) values))\n", "  (if (null? values)\n      '()\n      (if (integer? (car\
    \ values))\n          (cons (car values) (filter_integers (cdr values)))\n   \
    \       (filter_integers (cdr values)))))\n", "    (filter number? values))\n",
  "  (cond\n    [(null? values) '()]\n    [(integer? (car values)) (cons (car values)\
    \ (filter_integers (cdr values)))]\n    [else (filter_integers (cdr values))]))\n",
  "  (cond\n    [(empty? values) empty]\n    [(integer? (first values))\n     (cons\
    \ (first values) (filter_integers (rest values)))]\n    [else (filter_integers\
    \ (rest values))]))\n```\n<br>\n\n##### Transforming values with map\n\n- Say\
    \ you want to multiply every integer in a list by two.\n\n```racket\n#lang racket\n",
  "  (filter (lambda (x) (integer? x)) values))\n", "  (filter integer? values))\n\
    ```\n\n```racket\n#lang racket\n", "  (define (f x)\n    (if (integer? x)\n  \
    \      x\n        false))\n  (filter f values))\n", "  (filter (lambda (e) (integer?\
    \ e)) values))\n", "  (filter integer? values))\n", "  (filter (lambda (value)\
    \ (integer? value)) values))\n", "  (filter-map (lambda (value)\n            \
    \    (when (integer? value)\n                  value))\n              values))\n",
  "  (for/list ([i values]\n             #:when (integer? i))\n    i))\n", "  (filter\
    \ (lambda (value) (integer? value)) values))\n", "  (filter (\u03BB (x) (integer?\
    \ x)) values))\n", "    (filter (lambda (x) (integer? x)) values))\n", "  (filter\
    \ number? values))\n", "  (filter number? values))\n", "  (filter (\u03BB (x)\
    \ (integer? x)) values))\n", "  (filter (lambda (value) (is_integer? value)) values))\n",
  "  (filter integer? values))\n", "  (filter (lambda (x) (integer? x)) values))\n",
  "  (cond\n    [(empty? values) (list)]\n    [(integer? (first values))\n     (cons\
    \ (first values) (filter_integers (rest values)))]\n    [else (filter_integers\
    \ (rest values))]))\n", "  (foldl (lambda (acc v)\n           (if (integer? v)\n\
    \               (cons v acc)\n               acc))\n         '()\n         values))\n",
  "    (filter (lambda (x) (integer? x)) values))\n", "  (filter (lambda (x) (integer?\
    \ x)) values))\n", "  (filter-map number? values))\n", "  (filter (\u03BB (x)\
    \ (and (number? x) (integer? x))) values))\n", "  (filter (lambda (x) (integer?\
    \ x)) values))\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (filter\
    \ (lambda (x) (integer? x)) values))\n", "  (filter integer? values))\n", "  (filter\
    \ integer? values))\n", "  (if (null? values) '()\n      (if (integer? (car values))\n\
    \          (cons (car values) (filter_integers (cdr values)))\n          (filter_integers\
    \ (cdr values)))))\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (filter\
    \ (lambda (n) (integer? n)) values))\n", "  (filter (lambda (e) (integer? e))\
    \ values))\n", "  (filter (\u03BB (value) (integer? value)) values))\n", "  (filter\
    \ (lambda (value) (integer? value)) values))\n", "    (filter (lambda (x) (integer?\
    \ x)) values))\n", "  (filter number? values))\n", "  (cond [(empty? values) (list)]\n\
    \        [(integer? (first values))\n         (cons (first values) (filter_integers\
    \ (rest values)))]\n        [else (filter_integers (rest values))]))\n", "  (cond\n\
    \    [(empty? values) empty]\n    [(integer? (first values))\n     (cons (first\
    \ values) (filter_integers (rest values)))]\n    [else (filter_integers (rest\
    \ values))]))\n```\n* For n-ary function, you can do `(car (cdr (cdr (cdr values))))`\n\
    \n```racket\n#lang racket\n", "    (filter (lambda (x) (integer? x)) values))\n",
  "  (define (check-integer value)\n    (and (integer? value)\n         (not (hash?\
    \ value))\n         (not (list? value))))\n  (filter check-integer values))\n\
    ```\n\n### \u0414\u043E\u043F\u043E\u043B\u043D\u0438\u0442\u0435\u043B\u044C\u043D\
    \u044B\u0435 \u0437\u0430\u0434\u0430\u043D\u0438\u044F\n\n\u041E\u0441\u043D\u043E\
    \u0432\u043D\u044B\u0435 \u0437\u0430\u0434\u0430\u043D\u0438\u044F \u0440\u0435\
    \u0448\u0435\u043D\u044B \u0438 \u043F\u0440\u043E\u0442\u0435\u0441\u0442\u0438\
    \u0440\u043E\u0432\u0430\u043D\u044B, \u0432\u0441\u0435 \u0442\u0435\u0441\u0442\
    \u044B \u043F\u0440\u043E\u0445\u043E\u0434\u044F\u0442. \u041D\u043E \u0432\u043E\
    \u0437\u043C\u043E\u0436\u043D\u043E \u0432\u044B \u0437\u0430\u0445\u043E\u0442\
    \u0438\u0442\u0435 \u043F\u043E\u043F\u0440\u043E\u0431\u043E\u0432\u0430\u0442\
    \u044C \u0440\u0435\u0448\u0438\u0442\u044C \u0437\u0430\u0434\u0430\u0447\u0438\
    \ \u043F\u043E \u043F\u043E\u043B\u043D\u043E\u043C\u0443 \u043E\u043F\u0438\u0441\
    \u0430\u043D\u0438\u044E \u0432 \u043A\u043E\u043D\u0446\u0435 \u043C\u043E\u0434\
    \u0443\u043B\u044F, \u0438\u043B\u0438 \u043F\u0440\u0438\u0434\u0443\u043C\u0430\
    \u0442\u044C \u0441\u0432\u043E\u0438 \u0437\u0430\u0434\u0430\u0447\u0438 \u0434\
    \u043B\u044F \u0440\u0435\u0448\u0435\u043D\u0438\u044F. \u041D\u0430\u043F\u0440\
    \u0438\u043C\u0435\u0440, \u0432 \u043C\u043E\u0434\u0443\u043B\u0435 `rktthon.list`\
    \ \u0435\u0441\u0442\u044C \u0437\u0430\u0434\u0430\u0447\u0430 \u043D\u0430 \u0440\
    \u0435\u043A\u0443\u0440\u0441\u0438\u0432\u043D\u043E\u0435 \u0441\u043B\u043E\
    \u0436\u0435\u043D\u0438\u0435 \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\
    \u0432 \u0441\u043F\u0438\u0441\u043A\u0430. \u0410 \u0432\u043E\u0442 \u043D\u0435\
    \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u0434\u0440\u0443\u0433\u0438\u0435\
    \ \u0437\u0430\u0434\u0430\u0447\u0438 \u0434\u043B\u044F \u043C\u043E\u0434\u0443\
    \u043B\u044F `rktthon.list` \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043C\u043E\
    \u0436\u043D\u043E \u0440\u0435\u0448\u0438\u0442\u044C \u043F\u0440\u044F\u043C\
    \u043E \u0441\u0435\u0439\u0447\u0430\u0441:\n\n1. \u041E\u043F\u0440\u0435\u0434\
    \u0435\u043B\u0438\u0442\u0435 \u0444\u0443\u043D\u043A\u0446\u0438\u044E `(partition-by\
    \ f list)`, \u043A\u043E\u0442\u043E\u0440\u0430\u044F \u043F\u0440\u0438\u043D\
    \u0438\u043C\u0430\u0435\u0442 \u043D\u0430 \u0432\u0445\u043E\u0434", "  (define\
    \ (iter values filtered)\n    (if (null? values)\n      filtered\n      (let ((curr\
    \ (car values)))\n        (if (integer? curr)\n          (iter (cdr values) (append\
    \ filtered (list curr)))\n          (iter (cdr values) filtered)))))\n  (iter\
    \ values '()))\n", "  (filter\n   (lambda (v) (integer? v))\n   values))\n", " \
    \ (filter (\u03BB (value) (integer? value)) values))\n", "  (filter integer? values))\n",
  "  (let ([result (list)])\n    (for ([value values])\n      (when (integer? value)\n\
    \        (set! result (cons value result))))\n    (reverse result)))\n", "  (filter\
    \ integer? values))\n", "  (filter integer? values))\n", "  (filter (lambda (x)\
    \ (integer? x)) values))\n", "  (define (loop lst nlist)\n    (if (eq? lst '())\n\
    \        nlist\n        (if (integer? (car lst))\n            (loop (cdr lst)\
    \ (append nlist (list (car lst))))\n            (loop (cdr lst) nlist))))\n  (loop\
    \ values '()))\n", "  (filter (lambda (value) (integer? value)) values))\n", " \
    \ (filter (lambda (x) (integer? x)) values))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
