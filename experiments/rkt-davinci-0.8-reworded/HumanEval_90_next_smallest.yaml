name: HumanEval_90_next_smallest
language: rkt
prompt: "#lang racket\n\n;; You are given a list of integers.\n;; Write a function\
  \ next_smallest() that returns the 2nd smallest element of the list.\n;; Return\
  \ #f if there is no such element.\n;; >>> (next_smallest (list 1 2 3 4 5))\n;; 2\n\
  ;; >>> (next_smallest (list 5 1 4 3 2))\n;; 2\n;; >>> (next_smallest (list ))\n\
  ;; #f\n;; >>> (next_smallest (list 1 1))\n;; #f\n(define (next_smallest lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate next_smallest))\n\
  \    (check-equal? (candidate (list 1 2 3 4 5)) 2)\n    (check-equal? (candidate\
  \ (list 5 1 4 3 2)) 2)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
  \ (candidate (list 1 1)) #f)\n    (check-equal? (candidate (list 1 1 1 1 0)) 1)\n\
  \    (check-equal? (candidate (list 1 1)) #f)\n    (check-equal? (candidate (list\
  \ -35 34 12 -45)) -35)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(null? lst) #f]\n    [(null? (cdr lst)) #f]\n    [else\
    \ (apply min (cdr lst))]))", "  (cond\n    [(empty? lst) #f]\n    [(= (length\
    \ lst) 1) #f]\n    [else\n     (define sorted-lst (sort lst <))\n     (define\
    \ unique-lst (remove-duplicates sorted-lst))\n     (define unique-lst-but-first\
    \ (rest unique-lst))\n     (if (empty? unique-lst-but-first)\n         #f\n  \
    \       (car unique-lst-but-first))]))\n", "  (cond\n    [(empty? lst) #f]\n \
    \   [(equal? (length lst) 1) #f]\n    [else (define sorted (sort < lst))\n   \
    \       (define smallest (car sorted))\n          (define new-lst (remove-first\
    \ smallest sorted))\n          (define second-smallest (car new-lst))\n      \
    \    second-smallest]))", "  (if (= (length lst) 0)\n      #f\n      (if (= (length\
    \ lst) 1)\n          #f\n          (let* ([sorted (sort lst (lambda (a b) (< a\
    \ b)))]\n                 [smallest (car sorted)]\n                 [rest (cdr\
    \ sorted)])\n            (if (= (length rest) 0)\n                #f\n       \
    \         (let* ([sorted (sort rest (lambda (a b) (< a b)))]\n               \
    \        [smallest2 (car sorted)]\n                       [rest (cdr sorted)])\n\
    \                  (if (= (length rest) 0)\n                      #f\n       \
    \               smallest2)))))))", "  (cond [(empty? lst) #f]\n        [(null?\
    \ (cdr lst)) #f]\n        [else\n         (let loop\n               ([lst lst]\n\
    \                [min (car lst)]\n                [smin (cadr lst)])\n       \
    \    (cond [(and (null? (cdr lst)) (null? (cddr lst))) smin]\n               \
    \  [(< (car lst) min) (loop (cdr lst) (car lst) smin)]\n                 [(> (car\
    \ lst) min) (loop (cdr lst) min (car lst))]\n                 [else (loop (cdr\
    \ lst) min smin)]))]))", "  (define (next_smallest_iter lst result)\n    (if (null?\
    \ lst)\n        result\n        (let ((smallest (car lst)))\n          (next_smallest_iter\
    \ (cdr lst)\n                              (if (and (integer? result)\n      \
    \                                 (< result smallest))\n                     \
    \             result\n                                  smallest)))))\n  (define\
    \ (next_smallest_iter2 lst result)\n    (if (null? lst)\n        result\n    \
    \    (let ((smallest (car lst)))\n          (if (and (integer? result)\n     \
    \              (< result smallest))\n              (next_smallest_iter2 (cdr lst)\
    \ result)\n              (next_smallest_iter2 (cdr lst) smallest)))))\n  (next_smallest_iter2\
    \ lst #f))\n", "  (cond [(empty? lst) #f]\n        [(empty? (rest lst)) #f]\n\
    \        [else (second (sort lst))]))\n", "  (cond\n    [(empty? lst) #f]\n  \
    \  [(empty? (rest lst)) #f]\n    [else\n     (local\n       [; help procedure\n\
    \        (define (take-smaller x y)\n          (cond\n            [(< x y) x]\n\
    \            [else y]))]\n       (local\n         [; help procedure\n        \
    \  (define (drop-smaller lst)\n            (cond\n              [(empty? lst)\
    \ lst]\n              [(empty? (rest lst)) lst]\n              [else\n       \
    \        (local\n                 [; help procedure\n                  (define\
    \ (drop-smaller-intermediate x lst)\n                    (cond\n             \
    \         [(empty? lst) lst]\n                      [(empty? (rest lst)) lst]\n\
    \                      [else\n                       (if (= x (first lst))\n \
    \                          (rest lst)\n                           lst)]))]\n \
    \                (drop-smaller-intermediate (take-smaller (first lst) (second\
    \ lst)) lst))]))]\n         (cond\n           [(empty? (drop-smaller lst)) #f]\n\
    \           [(empty? (rest (drop-smaller lst))) #f]\n           [else\n      \
    \      (local\n              [; help procedure\n               (define (take-smaller-of-rest\
    \ x y)\n                 (cond\n                   [(< x y) x]\n             \
    \      [else y]))]\n              (take-smaller-of-rest (first (drop-smaller lst))\
    \ (second (drop-smaller lst))))])))]))\n", "  (let ([smls (list (apply min lst))]\n\
    \        [sml (apply min lst)])\n    (for ([el lst]\n          [i (in-range (length\
    \ lst))])\n      (if (and (not (member el smls))\n               (< el sml))\n\
    \          (set! sml el)))\n    sml))\n", "  (if (null? lst)\n      #f\n     \
    \ (cond ((and (member (first lst) (rest lst)) (and (null? (rest lst)))) #f)\n\
    \            ((and (member (first lst) (rest lst)) (not (null? (rest lst)))) (next_smallest\
    \ (rest lst)))\n            (else (first lst)))))", "  (for/fold ([smallest #f]\n\
    \             [next-smallest #f])\n      ([i lst])\n    (cond [(null? lst) next-smallest]\n\
    \          [(= i smallest) i]\n          [(or (null? smallest)\n             \
    \  (< i smallest))\n           (values i smallest)]\n          [(or (null? next-smallest)\n\
    \               (< i next-smallest))\n           (values smallest i)]\n      \
    \    [else\n           (values smallest next-smallest)])))\n", "  (if (empty?\
    \ lst)\n      #f\n      (let loop ((lst lst)\n                 (min (first lst))\n\
    \                 (nmin (first lst)))\n        (if (null? lst)\n            nmin\n\
    \            (let ((val (first lst)))\n              (cond ((< val min)\n    \
    \                 (loop (rest lst) val min))\n                    ((and (< val\
    \ nmin)\n                          (< val min))\n                     (loop (rest\
    \ lst) min val))\n                    (else\n                     (loop (rest\
    \ lst) min nmin))))))))\n", "  (local [(define (smallest lst)\n            (cond\
    \ [(empty? lst) #f]\n                  [(empty? (rest lst)) (first lst)]\n   \
    \               [else (if (< (first lst) (first (rest lst)))\n               \
    \             (smallest (cons (first lst) (rest (rest lst))))\n              \
    \              (smallest (rest lst)))]))\n          (define (smallest-without-lst\
    \ lst lst2)\n            (cond [(empty? lst) #f]\n                  [(empty? (rest\
    \ lst)) (first lst)]\n                  [else (if (member (first lst) lst2)\n\
    \                            (smallest-without-lst (rest lst) lst2)\n        \
    \                    (if (< (first lst) (first (rest lst)))\n                \
    \                (smallest-without-lst (cons (first lst) (rest (rest lst))) lst2)\n\
    \                                (smallest-without-lst (rest lst) lst2)))]))]\n\
    \    (if (not (member #f (list (smallest lst) (smallest-without-lst lst (list\
    \ (smallest lst))))))\n        (smallest-without-lst lst (list (smallest lst)))\n\
    \        #f)))", "  (list-ref lst 1))\n", "  (cond\n    [(empty? lst) #f]\n  \
    \  [(empty? (rest lst)) #f]\n    [else\n     (for/fold ([smallest (first lst)]\n\
    \                [smallest-found? #f])\n         ([current (in-list (rest lst))])\n\
    \       (cond\n         [(< current smallest) (values current #t)]\n         [(not\
    \ smallest-found?) (values smallest #f)]\n         [else (values smallest smallest-found?)]))]))\n",
  "  (let ((smallest (for/first ([x lst])\n\t\t    (let loop ([lst lst] [min x])\n\
    \t\t      (if (null? lst)\n\t\t\t  min\n\t\t\t  (loop (cdr lst) (min x (car lst))))))))\n\
    \    (if (null? lst)\n\t#f\n\t(let ([second-smallest (for/first ([x lst])\n\t\t\
    \t\t (if (= x smallest)\n\t\t\t\t     (let loop ([lst lst] [min (car lst)])\n\t\
    \t\t\t       (if (null? lst)\n\t\t\t\t\t   min\n\t\t\t\t\t   (loop (cdr lst) (min\
    \ (car lst) min))))))])\n\t  (if (= second-smallest smallest)\n\t      #f\n\t\
    \      second-smallest)))))\n", "  (define (next_smallest_iter lst min mincount)\n\
    \    (if (null? lst)\n        #f\n        (let ((num (car lst)))\n          (if\
    \ (= num min)\n              (next_smallest_iter (cdr lst) min (+ mincount 1))\n\
    \              (if (= mincount 1)\n                  min\n                  (next_smallest_iter\
    \ (cdr lst) min mincount))))))\n  (if (null? lst)\n      #f\n      (next_smallest_iter\
    \ (cdr lst) (car lst) 1)))\n", "  (cond\n    [(empty? lst) #f]\n    [(and (empty?\
    \ (rest lst)) (empty? (rest (rest lst)))) #f]\n    [(and (empty? (rest lst)) (not\
    \ (empty? (rest (rest lst)))))\n     (car (rest (rest lst)))]\n    [else\n   \
    \  (define (min-index lst i)\n       (cond\n         [(empty? (rest lst)) i]\n\
    \         [(< (car lst) (car (rest lst)))\n          (min-index (rest lst) (add1\
    \ i))]\n         [else\n          (min-index (rest lst) i)]))\n     (list-ref\
    \ lst (min-index (cdr (cdr lst)) 2))]))\n", "  (if (null? lst)\n      #f\n   \
    \   (let* ([smallest (apply min lst)]\n             [pos (position smallest lst)]\n\
    \             [rest (drop-right lst pos)])\n        (if (null? rest)\n       \
    \     #f\n            (apply min rest)))))\n</code>\n", "  (cond\n    [(null?\
    \ lst) #f]\n    [(null? (cdr lst)) #f]\n    [else\n     (let ([a (apply min lst)]\n\
    \           [b (apply min (remove a lst))])\n       (if (= a b)\n           #f\n\
    \           b))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
