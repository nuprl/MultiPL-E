name: HumanEval_80_is_happy
language: rkt
prompt: "#lang racket\n\n;; You are given a string s.\n;; Your task is to check if\
  \ the string is haprkt or not.\n;; A string is haprkt if its length is at least\
  \ 3 and every 3 consecutive letters are distinct\n;; For example:\n;; >>> (is_happy\
  \ a)\n;; #f\n;; >>> (is_happy aa)\n;; #f\n;; >>> (is_happy abcd)\n;; #t\n;; >>>\
  \ (is_happy aabb)\n;; #f\n;; >>> (is_happy adb)\n;; #t\n;; >>> (is_happy xyy)\n\
  ;; #f\n(define (is_happy s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_happy))\n\
  \    (check-equal? (candidate \"a\") #f)\n    (check-equal? (candidate \"aa\") #f)\n\
  \    (check-equal? (candidate \"abcd\") #t)\n    (check-equal? (candidate \"aabb\"\
  ) #f)\n    (check-equal? (candidate \"adb\") #t)\n    (check-equal? (candidate \"\
  xyy\") #f)\n    (check-equal? (candidate \"iopaxpoi\") #t)\n    (check-equal? (candidate\
  \ \"iopaxioi\") #f)\n))\n\n(test-humaneval)"
completions: ["  (cond ((not (>= (string-length s) 3)) #f)\n        ((check-if-distinct\
    \ (string-ref s 0) (string-ref s 1) (string-ref s 2)) #t)\n        (else #f)))\n",
  "  (and (&gt;= (string-length s) 3)\n       (for/and ([i (in-range (string-length\
    \ s) (- (string-length s) 2))])\n         (let* ([s1 (substring s i (+ i 1))]\n\
    \                [s2 (substring s (+ i 1) (+ i 2))]\n                [s3 (substring\
    \ s (+ i 2) (+ i 3))])\n           (not (equal? s1 s2))\n           (not (equal?\
    \ s2 s3))\n           (not (equal? s1 s3))))))\n", "  (equal? #t (and (not (empty?\
    \ s))\n                  (equal? (list-ref s 0) (list-ref s 1))\n            \
    \      (equal? (list-ref s 1) (list-ref s 2)))))", "  (if (and (>= (string-length\
    \ s) 3)\n           (is_happy_3 (list->string (list-ref (string->list s) 0))\n\
    \                     (list->string (list-ref (string->list s) 1))\n         \
    \            (list->string (list-ref (string->list s) 2))))\n      #t\n      #f))\n",
  "  (if (not (string&gt;= s 3))\n      #f\n      (let ([pos (string-ref s 2)])\n\
    \        (if (char=? (string-ref s 0) pos)\n            #f\n            (if (char=?\
    \ (string-ref s 1) pos)\n                #f\n                #t)))))\n", "  (cond\
    \ ((or (&lt; (string-length s) 3)\n             (let* ([s (string-&gt;list s)]\n\
    \                    [head (car s)]\n                    [tail (cdr s)])\n   \
    \            (or (equal? head (car tail))\n                   (equal? head (cadr\
    \ tail)))))\n         #f)\n        (else #t)))\n", "  (define (iter s i)\n   \
    \ (if (= i (- (string-length s) 2))\n        (string=? (substring s (- i 2) i)\
    \ (substring s i (+ i 2)))\n        (and (string=? (substring s (- i 2) i) (substring\
    \ s i (+ i 2)))\n             (iter s (+ i 1)))))\n  (and (>= (string-length s)\
    \ 3)\n       (iter s 0)))\n```\n\n### Task 2\n\n```#lang racket\n", "  (if (<\
    \ (string-length s) 3)\n      #f\n      (for/and ([a (in-string (substring s 0\
    \ (- (string-length s) 2)))])\n               (string-ci=? (substring s (- (string-length\
    \ s) 2))\n                            (substring s (- (string-length s) 3) (-\
    \ (string-length s) 1))))))", "  (and\n   (>= (string-length s) 3)\n   (not (string-contains\
    \ s #\\a #\\a #\\a))\n   (not (string-contains s #\\b #\\b #\\b))\n   (not (string-contains\
    \ s #\\c #\\c #\\c))\n   (not (string-contains s #\\d #\\d #\\d))\n   (not (string-contains\
    \ s #\\e #\\e #\\e))\n   (not (string-contains s #\\f #\\f #\\f))\n   (not (string-contains\
    \ s #\\g #\\g #\\g))\n   (not (string-contains s #\\h #\\h #\\h))\n   (not (string-contains\
    \ s #\\i #\\i #\\i))\n   (not (string-contains s #\\j #\\j #\\j))\n   (not (string-contains\
    \ s #\\k #\\k #\\k))\n   (not (string-contains s #\\l #\\l #\\l))\n   (not (string-contains\
    \ s #\\m #\\m #\\m))\n   (not (string-contains s #\\n #\\n #\\n))\n   (not (string-contains\
    \ s #\\o #\\o #\\o))\n   (not (string-contains s #\\p #\\p #\\p))\n   (not (string-contains\
    \ s #\\q #\\q #\\q))\n   (not (string-contains s #\\r #\\r #\\r))\n   (not (string-contains\
    \ s #\\s #\\s #\\s))\n   (not (string-contains s #\\t #\\t #\\t))\n   (not (string-contains\
    \ s #\\u #\\u #\\u))\n   (not (string-contains s #\\v #\\v #\\v))\n   (not (string-contains\
    \ s #\\w #\\w #\\w))\n   (not (string-contains s #\\x #\\x #\\x))\n   (not (string-contains\
    \ s #\\y #\\y", "  (if (>= (string-length s) 3)\n      (define (helper i)\n  \
    \      (if (>= i (- (string-length s) 2))\n            #t\n            (if (eq?\
    \ (string-ref s i) (string-ref s (+ i 1)) (string-ref s (+ i 2)))\n          \
    \      #f\n                (helper (+ i 1)))))\n      (helper 0))\n  #f)\n```\n\
    \n```Racket\n#lang racket\n", "  (let check-it ((s s) (found #f))\n    (if (empty?\
    \ s)\n        found\n        (let* ((front (substring s 0 3))\n              \
    \ (rest (substring s 3))\n               (found (or found (unique? front))))\n\
    \          (check-it rest found)))))\n", "  (and (&gt;= (string-length s) 3)\n\
    \       (not (has-duplicates (string-&gt;list s)))))\n", "  (let loop ([s s] [res\
    \ true])\n    (if (empty? s)\n        res\n        (let-values ([(c1 c2 c3 rest)\
    \ (string-take s 3)])\n          (cond\n            [(and (char=? c1 c2) (char=?\
    \ c2 c3)) (loop rest false)]\n            [(char=? c1 c2) (loop rest res)]\n \
    \           [(char=? c2 c3) (loop rest res)]\n            [else (loop rest res)])))))\n",
  "  (define (is_happy-helper s)\n    (and (not (char=? (string-ref s 0) (string-ref\
    \ s 1)))\n         (not (char=? (string-ref s 0) (string-ref s 2)))\n        \
    \ (not (char=? (string-ref s 1) (string-ref s 2)))))\n  (cond ((string=? s \"\"\
    ) #f)\n        ((string=? s \"a\") #f)\n        ((string=? s \"aa\") #f)\n   \
    \     ((>= (string-length s) 3) (is_happy-helper s))\n        (else #f)))", " \
    \ (local [(define (is_happy? s)\n            (cond [(equal? (string-length s)\
    \ 0) #t]\n                  [(equal? (string-length s) 1) #t]\n              \
    \    [(equal? (string-length s) 2) #t]\n                  [(equal? (string-length\
    \ s) 3) #t]\n                  [(equal? (string-length s) 4) #t]\n           \
    \       [(equal? (string-length s) 5) #t]\n                  [(equal? (string-length\
    \ s) 6) #t]\n                  [(equal? (string-length s) 7) #t]\n           \
    \       [(equal? (string-length s) 8) #t]\n                  [(equal? (string-length\
    \ s) 9) #t]\n                  [(equal? (string-length s) 10) #t]\n          \
    \        [(equal? (string-length s) 11) #t]\n                  [(equal? (string-length\
    \ s) 12) #t]\n                  [(equal? (string-length s) 13) #t]\n         \
    \         [(equal? (string-length s) 14) #t]\n                  [(equal? (string-length\
    \ s) 15) #t]\n                  [(equal? (string-length s) 16) #t]\n         \
    \         [(equal? (string-length s) 17) #t]\n                  [(equal? (string-length\
    \ s) 18) #t]\n                  [(equal? (string-length s) 19) #t]\n         \
    \         [(equal? (string-length s) 20) #t]\n                  [(equal? (string-length\
    \ s) 21) #t]\n                  [(equal? (string-length s) 22) #t]\n         \
    \         [(equal? (string-length s) 23) #t]\n                  [(equal? (string-length\
    \ s) 24) #t]\n                  [(equal? (string-length s) 25) #t]\n         \
    \         [(equal? (string-length s) 26) #t]\n                  [(equal? (string-length\
    \ s) 27) #t]\n                  [(equal? (string-length s) 28) #t]\n         \
    \         [(equal? (string-length s) 29) #t]\n                  [(equal? (string-length\
    \ s) 30) #t]\n", "  (and (&gt;= (string-length s) 3)\n       (for/and ([c1 (in-string\
    \ s)])\n         (let* ([c1 (string-&gt;symbol (string c1))]\n               \
    \ [c2 (string-&gt;symbol (string (char-next c1)))]\n                [c3 (string-&gt;symbol\
    \ (string (char-next c2)))])\n           (not (eq? c1 c2 c3))))))\n</code>\nNote\
    \ that I just came up with this in about five minutes, so there are probably more\
    \ efficient ways to do it, though probably not simpler.\nHow can I make this more\
    \ functional?\n\n\nA:\n\nA more functional approach would probably use recursion\
    \ more than iteration. I'd write the logic like this:\n<code>(define (is-happy\
    \ s)\n  (or (not (or (null? s)\n               (null? (cdr s))\n             \
    \  (null? (cddr s))))\n      (let ([a (car s)]\n            [b (cadr s)]\n   \
    \         [c (caddr s)])\n        (and (not (eq? a b))\n             (not (eq?\
    \ a c))\n             (not (eq? b c))\n             (is-happy (cddr s))))))\n\
    </code>\nI would also prefer lower-case identifiers, Racket style.\nIf you want\
    \ to stick with <code>for/and</code>, you might replace the <code>let</code> part\
    \ with something like this:\n<code>(for/and ([a (in-string s)]\n          [b (in-string\
    \ (cdr s))]\n          [c (in-string (cddr s))])\n  (not (eq? a b c)))\n</code>\n\
    If you want to stick with <code>for/and</code>, you'll need to replace the <code>let</code>\
    \ part with something like this:\n<code>(for/and ([a (in-string s)]\n        \
    \  [b (in-string (cdr s))]\n          [c (in-string (cddr s))])\n  (not (eq? a\
    \ b c)))\n</code>\n", "  (cond [(>= (string-length s) 3)\n         (if (= (string-ref\
    \ s 0) (string-ref s 1))\n             #f\n             (is_happy (substring s\
    \ 1)))]\n        [else #t]))\n", "  (let ([s (string->list s)])\n    (and (>=\
    \ (length s) 3)\n         (every (lambda (x) (distinct? x))\n                (build-list\
    \ (quotient (length s) 3)\n                            (lambda (n) (take s (*\
    \ n 3) (+ 3 (* n 3)))))))))\n", "  (local ((define (are-distinct? c1 c2 c3)\n\
    \            (and (distinct? c1 c2)\n                 (distinct? c1 c3)\n    \
    \             (distinct? c2 c3))))\n    (let ((len (string-length s)))\n     \
    \ (cond\n        ((>= len 3)\n         (are-distinct? (string-ref s 0)\n     \
    \                   (string-ref s 1)\n                        (string-ref s 2)))\n\
    \        (else #f)))))\n", "  (is_happy s 3 #t))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
