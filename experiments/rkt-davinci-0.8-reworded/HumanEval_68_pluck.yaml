name: HumanEval_68_pluck
language: rkt
prompt: "#lang racket\n\n;; \"Given a list representing a branch of a tree that has\
  \ non-negative integer nodes\n;; your task is to pluck one of the nodes and return\
  \ it.\n;; The plucked node should be the node with the smallest even value.\n;;\
  \ If multiple nodes with the same smallest even value are found return the node\
  \ that has smallest index.\n;; The plucked node should be returned in a list, [\
  \ smalest_value, its index ],\n;; If there are no even values or the given list\
  \ is empty, return [].\n;; Example 1:\n;; >>> (pluck (list 4 2 3))\n;; (list 2 1)\n\
  ;; Explanation: 2 has the smallest even value, and 2 has the smallest index.\n;;\
  \ Example 2:\n;; >>> (pluck (list 1 2 3))\n;; (list 2 1)\n;; Explanation: 2 has\
  \ the smallest even value, and 2 has the smallest index.\n;; Example 3:\n;; >>>\
  \ (pluck (list ))\n;; (list )\n;; Example 4:\n;; >>> (pluck (list 5 0 3 0 4 2))\n\
  ;; (list 0 1)\n;; Explanation: 0 is the smallest value, but  there are two zeros,\n\
  ;; so we will choose the first zero, which has the smallest index.\n;; Constraints:\n\
  ;; * 1 <= nodes.length <= 10000\n;; * 0 <= node.value\n(define (pluck arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pluck))\n\
  \    (check-equal? (candidate (list 4 2 3)) (list 2 1))\n    (check-equal? (candidate\
  \ (list 1 2 3)) (list 2 1))\n    (check-equal? (candidate (list )) (list ))\n  \
  \  (check-equal? (candidate (list 5 0 3 0 4 2)) (list 0 1))\n    (check-equal? (candidate\
  \ (list 1 2 3 0 5 3)) (list 0 3))\n    (check-equal? (candidate (list 5 4 8 4 8))\
  \ (list 4 1))\n    (check-equal? (candidate (list 7 6 7 1)) (list 6 1))\n    (check-equal?\
  \ (candidate (list 7 9 7 1)) (list ))\n))\n\n(test-humaneval)"
completions: ["  (if (null? arr)\n      empty\n      (cond [(even? (first arr)) (pluck\
    \ (cdr arr))]\n            [else (list (first arr) 0)])))\n", "  (local ((define\
    \ (pluck-evens evens)\n            (cond [(null? evens) empty]\n             \
    \     [(= 0 (modulo (car evens) 2)) (cons (car evens) (pluck-evens (cdr evens)))]\n\
    \                  [else (pluck-evens (cdr evens))])))\n    (if (null? arr) empty\n\
    \        (let* ([smallest-index 0]\n               [smallest-value (car arr)]\n\
    \               [evens (pluck-evens arr)])\n          (cond [(null? evens) empty]\n\
    \                [(<= smallest-value (car evens)) (cons smallest-value smallest-index)]\n\
    \                [else (pluck evens)])))))\n", "  (let* ([evens (filter even?\
    \ arr)]\n         [smallest-even (apply min evens)])\n    (cond\n      [(empty?\
    \ evens) '()]\n      [else (list smallest-even (index arr smallest-even))])))\n",
  "  (filter even? arr))\n", "  (cond [(empty? arr) (list)]\n        [(andmap even?\
    \ arr) (list (min arr) (index (min arr) arr))]\n        [else (list)]))\n", " \
    \ (let ([evens (filter (lambda (x) (even? x)) arr)])\n    (if (null? evens) '()\n\
    \        (let ([smallest (apply min evens)])\n          (list smallest\n     \
    \           (for/fold ([smallest-index '()])\n                          ([index\
    \ (in-naturals)])\n                          (cond\n                         \
    \   [(> index (length arr)) (error \"No index\")]\n                          \
    \  [(= (list-ref arr index) smallest) (if (null? smallest-index) index smallest-index)]\n\
    \                            [else smallest-index])))))))\n", "  (define (isEven?\
    \ n)\n    (= (remainder n 2) 0))\n  (define (f arr min-idx min-val)\n    (cond\n\
    \      [(empty? arr) (if (null? min-val) empty (list min-val min-idx))]\n    \
    \  [(isEven? (first arr))\n       (cond\n         [(null? min-val) (f (rest arr)\
    \ 0 (first arr))]\n         [(< (first arr) min-val) (f (rest arr) 0 (first arr))]\n\
    \         [else (f (rest arr) (+ min-idx 1) min-val)])]\n      [else (f (rest\
    \ arr) (+ min-idx 1) min-val)]))\n  (f arr 0 null))\n", "  (define (pluck-inner\
    \ arr smallestIndex smallestValue index)\n    (cond\n      [(empty? arr) (if (zero?\
    \ smallestValue)\n                        (list)\n                        (list\
    \ smallestValue smallestIndex))]\n      [(even? (first arr))\n       (if (= smallestValue\
    \ 0)\n           (pluck-inner (rest arr) (add1 index) (first arr) (add1 index))\n\
    \           (if (> (first arr) smallestValue)\n               (pluck-inner (rest\
    \ arr) (add1 index) (first arr) (add1 index))\n               (pluck-inner (rest\
    \ arr) smallestIndex smallestValue (add1 index))))]\n      [else (pluck-inner\
    \ (rest arr) smallestIndex smallestValue (add1 index))]))\n  (pluck-inner arr\
    \ 0 0 0))\n", "  (cond [(empty? arr)\n         (list)]\n        [(empty? (filter\
    \ even? arr))\n         (list)]\n        [else\n         (cons (min (filter even?\
    \ arr))\n                 (index (min (filter even? arr)) arr))]))\n", "  (if\
    \ (empty? arr)\n      (list)\n      (let* ([even? (lambda (x) (zero? (remainder\
    \ x 2)))]\n             [evens (filter even? arr)]\n             [evens-length\
    \ (length evens)]\n             [min-evens (and (not (zero? evens-length)) (apply\
    \ min evens))]\n             [min-evens-index (index arr min-evens)])\n      \
    \  (and (not (zero? evens-length)) (list min-evens min-evens-index)))))\n", " \
    \ (define (minEven arr)\n    (cond\n      [(empty? arr) '()]\n      [(even? (first\
    \ arr))\n       (if (not (empty? (minEven (rest arr))))\n           (if (< (first\
    \ arr) (first (minEven (rest arr))))\n               (cons (first arr) (minEven\
    \ (rest arr)))\n               (minEven (rest arr)))\n           (cons (first\
    \ arr) (minEven (rest arr))))]\n      [else (minEven (rest arr))]))\n  (if (empty?\
    \ (minEven arr)) '()\n      (list (first (minEven arr))\n            (for/fold\
    \ ([acc (set null)]) ([i (in-list arr)])\n              (cond\n              \
    \  [(equal? i (first (minEven arr))) (set i)]\n                [else acc])))))\n",
  "  (cond [(empty? arr) (list)]\n        [(empty? (evens arr)) (list)]\n        [else\
    \ (list (apply min (evens arr)) (index (apply min (evens arr)) arr))]))\n", " \
    \ (if (empty? arr)\n      (list)\n      (define evens (filter even? arr))\n  \
    \    (if (empty? evens)\n          (list)\n          (list (min evens) (position\
    \ (min evens) arr)))))\n", "  (define (isEven n)\n    (= (remainder n 2) 0))\n\
    \  (define (loop index min minIndex evens evInd)\n    (cond [(empty? arr) (if\
    \ evens (list min minIndex) (list))]\n          [(isEven (first arr)) (loop (add1\
    \ index)\n                                      (if (or (not evens) (< (first\
    \ arr) min))\n                                          (first arr)\n        \
    \                                  min)\n                                    \
    \  (if (or (not evens) (< (first arr) min))\n                                \
    \          index\n                                          minIndex)\n      \
    \                                (add1 evens)\n                              \
    \        (add1 evInd))]\n          [else (loop (add1 index) min minIndex evens\
    \ evInd)]))\n  (loop 0 0 0 0 0))", "  (let ([evens (filter even? arr)])\n    (cond\n\
    \      [(empty? evens) '()]\n      [(= 1 (length evens)) (list (first evens) (index-of\
    \ (first evens) arr))]\n      [else (index-of (min (first evens) (second evens))\
    \ arr)])))\n", "  (if (empty? arr)\n      '()\n      (let* ([evens (filter even?\
    \ arr)]\n             [smallest-even (if (empty? evens) '() (apply min evens))]\n\
    \             [smallest-even-indices (filter-indexes\n                       \
    \              (compose (curry = smallest-even) second)\n                    \
    \                 (iota (length arr)))])\n        (if (empty? smallest-even-indices)\n\
    \            '()\n            (list smallest-even (first smallest-even-indices))))))\n",
  "  (cond ((empty? arr) empty)\n        ((= 0 (modulo (first arr) 2))\n         (let\
    \ loop ((arr2 arr) (ind 2) (min (first arr)) (min-ind 1))\n           (cond ((empty?\
    \ arr2)\n                  (list min min-ind))\n                 ((= 0 (modulo\
    \ (first arr2) 2))\n                  (cond ((< (first arr2) min)\n          \
    \               (loop (rest arr2) (add1 ind) (first arr2) ind))\n            \
    \            (else\n                         (loop (rest arr2) (add1 ind) min\
    \ min-ind))))\n                 (else\n                  (loop (rest arr2) (add1\
    \ ind) min min-ind)))))\n        (else\n         (pluck (rest arr)))))\n</code>\n\
    Looks good to me, the worst case is O(n), but the majority of cases should be\
    \ a lot faster than that.\n", "  (if (empty? arr)\n      (list)\n      (let* ([evens\
    \ (filter even? arr)]\n             [min-even (apply min evens)]\n           \
    \  [index-of-min-even (find-index min-even arr)])\n        (list min-even index-of-min-even))))\n",
  "  (cond\n    [(empty? arr) empty]\n    [(even? (first arr))\n     (let\n      \
    \   ([f (lambda (y x)\n              (if (< (first y) (first x))\n           \
    \       y\n                  x))])\n       (reduce f arr))]\n    [else (pluck\
    \ (rest arr))]))", "  (let* ([min-even\n          (match (seq->list (filter (\u03BB\
    \ (x) (even? x)) arr))\n            [(list)\n             #f]\n            [(list\
    \ x1 x2 ...)\n             (min x1 x2 ...)])]\n         [min-even-pos\n      \
    \    (match min-even\n            [#f\n             #f]\n            [_\n    \
    \         (seq-index arr min-even)])])\n    (if (or (eq? min-even #f) (eq? min-even-pos\
    \ #f))\n        (list)\n        (list min-even min-even-pos))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
