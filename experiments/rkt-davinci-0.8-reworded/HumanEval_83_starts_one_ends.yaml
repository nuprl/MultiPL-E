name: HumanEval_83_starts_one_ends
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer n, return the count of the numbers\
  \ of n-digit\n;; positive integers that start or end with 1.\n(define (starts_one_ends\
  \ n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate starts_one_ends))\n\
  \    (check-equal? (candidate 1) 1)\n    (check-equal? (candidate 2) 18)\n    (check-equal?\
  \ (candidate 3) 180)\n    (check-equal? (candidate 4) 1800)\n    (check-equal? (candidate\
  \ 5) 18000)\n))\n\n(test-humaneval)"
completions: ["  (cond [(= 1 n) 1]\n        [(= 2 n) 11]\n        [else (+ (* 2 (expt\
    \ 10 (- n 2))) (starts_one_ends (- n 1)))]))\n", "  ;; the number of n-digit numbers\
    \ that start with one is 10^(n-1).\n  ;; The number of n-digit numbers that end\
    \ with one is 9.\n  ;; \n  (cond ((= n 1) 0)\n        ((= n 2) 9)\n        (else\
    \ (+ (expt 10 (- n 1)) (* 9 9 (- n 2))))))\n", "  (define (helper accum diff)\n\
    \    (cond [(= n 0) accum]\n          [(= n 1) (+ accum 1)]\n          [(= diff\
    \ 1) (+ accum 1)]\n          [else (helper (+ accum (expt 10 (- n 1))) (+ diff\
    \ 1))]))\n  (helper 1 0))\n", "  (local [(define (count n)\n            (cond\
    \ [(= n 1) 1]\n                  [(= n 2) 10]\n                  [else (+ (count\
    \ (- n 1)) (* 9 (expt 10 (- n 2))))]))]\n    (count n)))\n", "  (cond\n    [(=\
    \ n 1) 2]\n    [(even? n) (+ (starts_one_ends (- n 1)) (starts_one_ends (/ n 2)))]\n\
    \    [else (starts_one_ends (- n 1))]))\n", "  (cond\n    [(= n 1) 2]\n    [(>\
    \ n 1) (* (starts_one_ends (- n 1)) 2)]))\n", "  (cond [(= n 1) 2]\n        [(=\
    \ n 2) 3]\n        [else (+ (starts_one_ends (- n 1))\n                 (* 9 (expt\
    \ 10 (- n 2))))]))\n</code>\nI'm now trying to implement this as a recursive generator.\
    \ My first idea was to translate the above code into:\n<code>#lang racket\n",
  "  (let ((result 0))\n    (define (f x)\n      (let ((d (modulo x 10)))\n      \
    \  (if (= d 1) (set! result (+ result 1)))\n        (let ((x (quotient x 10)))\n\
    \          (if (&gt; x 0) (f x)))))\n    (for ([i (in-range 1 (expt 10 n))])\n\
    \      (f i))\n    result))\n", "  (cond\n    [(= n 1) 1]\n    [(= n 2) 2]\n \
    \   [else\n     (+\n      ;; start or end with 1 but not both\n      (- (* 2 (expt\
    \ 10 (- n 2))) (- (expt 10 (- n 1)) (expt 10 (- n 2))))\n      ;; starts and ends\
    \ with 1\n      (- (expt 10 (- n 1)) (expt 10 (- n 2))))]))\n", "  (cond\n   \
    \ [(= n 1)\n     2]\n    [(= n 2)\n     10]\n    [else\n     (for/sum ([i (in-range\
    \ 2 n)])\n       (expt (if (= i 1) 2 10) (- i 1)))\n     ]))\n", "  (let ((start-and-end\
    \ 1)\n        (start-and-not-end 9)\n        (not-start-and-end 9)\n        (not-start-and-not-end\
    \ 8))\n    (for ([i (in-range (- n 2))])\n      (set! start-and-end (* start-and-end\
    \ 10))\n      (set! start-and-not-end (* start-and-not-end 10))\n      (set! not-start-and-end\
    \ (* not-start-and-end 10))\n      (set! not-start-and-not-end (* not-start-and-not-end\
    \ 10)))\n    (+ start-and-end start-and-not-end not-start-and-end not-start-and-not-end)))\n",
  "  (if (= n 1)\n      2\n      (let ((ends_1 (starts_one_ends (- n 1))))\n     \
    \   (+ (* 10 (- (expt 10 (- n 1)) ends_1))\n           ends_1))))\n", "  (define\
    \ (starts_one_ends_iter d)\n    (if (= d 0)\n        1\n        (+ (starts_one_ends_iter\
    \ (- d 1))\n           (starts_one_ends_iter (- d 2)))))\n  (starts_one_ends_iter\
    \ n))\n", "  (if (< n 2)\n      1\n      (+ (expt 9 (- n 1))\n         (expt 10\
    \ (- n 1)))))\n", "  (cond\n    [(zero? n) 0]\n    [(positive? n) (add1 (starts_one_ends\
    \ (sub1 n)))]\n    [else 0]))\n", "  (define (count-digits i)\n    (if (= i 0)\n\
    \        0\n        (+ 1 (count-digits (quotient i 10)))))\n  (define (helper\
    \ i)\n    (if (= i n)\n        1\n        (+ (helper (+ i 1))\n           (* (+\
    \ 9 (expt 10 (+ (- n 1) i)))\n              (count-digits i)))))\n  (helper 1))\n",
  "  (cond\n    [(zero? n) 0]\n    [(one? n) 1]\n    [else (+ (starts_one_ends (-\
    \ n 1)) (starts_one_ends (- n 2)))]))\n", "  (define (number-tally s)\n    (cond\n\
    \      [(empty? s) 0]\n      [(char=? (string-ref s 0) #\\1)\n       (+ 1 (number-tally\
    \ (substring s 1)))]\n      [else (number-tally (substring s 1))]))\n  (define\
    \ (pad-string s n)\n    (cond\n      [(empty? s) s]\n      [(zero? n) s]\n   \
    \   [else (string-append (string #\\0) s)]))\n  (let ((s (number->string n)))\n\
    \    (+ (number-tally s)\n       (number-tally (pad-string s (sub1 (string-length\
    \ s)))))))\n", "  (if (eq? n 1)\n      2\n      (+ (expt 10 (- n 1)) (* 2 (expt\
    \ 10 (- n 2))))))\n", "  (expt 10 (- n 1)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
