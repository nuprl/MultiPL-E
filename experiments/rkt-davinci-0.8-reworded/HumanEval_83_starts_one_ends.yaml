name: HumanEval_83_starts_one_ends
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer n, return the count of the numbers\
  \ of n-digit\n;; positive integers that start or end with 1.\n(define (starts_one_ends\
  \ n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate starts_one_ends))\n\
  \    (check-equal? (candidate 1) 1)\n    (check-equal? (candidate 2) 18)\n    (check-equal?\
  \ (candidate 3) 180)\n    (check-equal? (candidate 4) 1800)\n    (check-equal? (candidate\
  \ 5) 18000)\n))\n\n(test-humaneval)"
completions: ["  (cond [(= 1 n) 1]\n        [(= 2 n) 11]\n        [else (+ (* 2 (expt\
    \ 10 (- n 2))) (starts_one_ends (- n 1)))]))\n", "  ;; the number of n-digit numbers\
    \ that start with one is 10^(n-1).\n  ;; The number of n-digit numbers that end\
    \ with one is 9.\n  ;; \n  (cond ((= n 1) 0)\n        ((= n 2) 9)\n        (else\
    \ (+ (expt 10 (- n 1)) (* 9 9 (- n 2))))))\n", "  (define (helper accum diff)\n\
    \    (cond [(= n 0) accum]\n          [(= n 1) (+ accum 1)]\n          [(= diff\
    \ 1) (+ accum 1)]\n          [else (helper (+ accum (expt 10 (- n 1))) (+ diff\
    \ 1))]))\n  (helper 1 0))\n", "  (local [(define (count n)\n            (cond\
    \ [(= n 1) 1]\n                  [(= n 2) 10]\n                  [else (+ (count\
    \ (- n 1)) (* 9 (expt 10 (- n 2))))]))]\n    (count n)))\n", "  (cond\n    [(=\
    \ n 1) 2]\n    [(even? n) (+ (starts_one_ends (- n 1)) (starts_one_ends (/ n 2)))]\n\
    \    [else (starts_one_ends (- n 1))]))\n", "  (cond\n    [(= n 1) 2]\n    [(>\
    \ n 1) (* (starts_one_ends (- n 1)) 2)]))\n", "  (cond [(= n 1) 2]\n        [(=\
    \ n 2) 3]\n        [else (+ (starts_one_ends (- n 1))\n                 (* 9 (expt\
    \ 10 (- n 2))))]))\n</code>\nI'm now trying to implement this as a recursive generator.\
    \ My first idea was to translate the above code into:\n<code>#lang racket\n",
  "  (let ((result 0))\n    (define (f x)\n      (let ((d (modulo x 10)))\n      \
    \  (if (= d 1) (set! result (+ result 1)))\n        (let ((x (quotient x 10)))\n\
    \          (if (&gt; x 0) (f x)))))\n    (for ([i (in-range 1 (expt 10 n))])\n\
    \      (f i))\n    result))\n", "  (cond\n    [(= n 1) 1]\n    [(= n 2) 2]\n \
    \   [else\n     (+\n      ;; start or end with 1 but not both\n      (- (* 2 (expt\
    \ 10 (- n 2))) (- (expt 10 (- n 1)) (expt 10 (- n 2))))\n      ;; starts and ends\
    \ with 1\n      (- (expt 10 (- n 1)) (expt 10 (- n 2))))]))\n", "  (cond\n   \
    \ [(= n 1)\n     2]\n    [(= n 2)\n     10]\n    [else\n     (for/sum ([i (in-range\
    \ 2 n)])\n       (expt (if (= i 1) 2 10) (- i 1)))\n     ]))\n", "  (let ((start-and-end\
    \ 1)\n        (start-and-not-end 9)\n        (not-start-and-end 9)\n        (not-start-and-not-end\
    \ 8))\n    (for ([i (in-range (- n 2))])\n      (set! start-and-end (* start-and-end\
    \ 10))\n      (set! start-and-not-end (* start-and-not-end 10))\n      (set! not-start-and-end\
    \ (* not-start-and-end 10))\n      (set! not-start-and-not-end (* not-start-and-not-end\
    \ 10)))\n    (+ start-and-end start-and-not-end not-start-and-end not-start-and-not-end)))\n",
  "  (if (= n 1)\n      2\n      (let ((ends_1 (starts_one_ends (- n 1))))\n     \
    \   (+ (* 10 (- (expt 10 (- n 1)) ends_1))\n           ends_1))))\n", "  (define\
    \ (starts_one_ends_iter d)\n    (if (= d 0)\n        1\n        (+ (starts_one_ends_iter\
    \ (- d 1))\n           (starts_one_ends_iter (- d 2)))))\n  (starts_one_ends_iter\
    \ n))\n", "  (if (< n 2)\n      1\n      (+ (expt 9 (- n 1))\n         (expt 10\
    \ (- n 1)))))\n", "  (cond\n    [(zero? n) 0]\n    [(positive? n) (add1 (starts_one_ends\
    \ (sub1 n)))]\n    [else 0]))\n", "  (define (count-digits i)\n    (if (= i 0)\n\
    \        0\n        (+ 1 (count-digits (quotient i 10)))))\n  (define (helper\
    \ i)\n    (if (= i n)\n        1\n        (+ (helper (+ i 1))\n           (* (+\
    \ 9 (expt 10 (+ (- n 1) i)))\n              (count-digits i)))))\n  (helper 1))\n",
  "  (cond\n    [(zero? n) 0]\n    [(one? n) 1]\n    [else (+ (starts_one_ends (-\
    \ n 1)) (starts_one_ends (- n 2)))]))\n", "  (define (number-tally s)\n    (cond\n\
    \      [(empty? s) 0]\n      [(char=? (string-ref s 0) #\\1)\n       (+ 1 (number-tally\
    \ (substring s 1)))]\n      [else (number-tally (substring s 1))]))\n  (define\
    \ (pad-string s n)\n    (cond\n      [(empty? s) s]\n      [(zero? n) s]\n   \
    \   [else (string-append (string #\\0) s)]))\n  (let ((s (number->string n)))\n\
    \    (+ (number-tally s)\n       (number-tally (pad-string s (sub1 (string-length\
    \ s)))))))\n", "  (if (eq? n 1)\n      2\n      (+ (expt 10 (- n 1)) (* 2 (expt\
    \ 10 (- n 2))))))\n", "  (expt 10 (- n 1)))\n", "  (if (zero? n) 1\n      (if\
    \ (zero? (remainder n 2))\n          (* (expt 10 (/ n 2)) (expt 9 (/ n 2)))\n\
    \          (* (expt 10 (/ n 2)) (+ (* 10 (expt 9 (/ n 2))) (expt 9 (/ n 2)))))))\n",
  "  (display (number->string (if (> n 1) (+ (expt 10 (- n 1)) 10) 1)))\n  (display\
    \ #\\space)\n  (display \"to\")\n  (display #\\space)\n  (display (number->string\
    \ (if (> n 1) (+ (* 10 (expt 10 (- n 1))) 2) 3)))\n  (display #\\newline))\n",
  "  (cond [(> n 9) (- n 2)] [else (- n 1)]))\n", "  (let loop ([rem (sub1 n)] [sum\
    \ 1])\n    (if (= rem 0)\n        sum\n        (loop (sub1 rem) (* 10 sum)))))\n",
  "  (define (starts_one_ends_help n)\n    (if (= n 1)\n      0\n      (+ (starts_one_ends_help\
    \ (- n 1)) (* 10 (starts_one_ends_help (- n 1))))))\n  (+ (starts_one_ends_help\
    \ n) (starts_one_ends_help (- n 1))))\n", "  (cond [(< n 0) 0]\n        [(= n\
    \ 0) 1]\n        [else (+ (starts_one_ends (- n 1)) (* 10 (starts_one_ends (-\
    \ n 1))))]))\n", "  (let ([a n])\n    (cond ((= a 1) 1)\n          ((= a 2) 10)\n\
    \          (else (+ (* 9 (expt 10 (- a 2))) (starts_one_ends (- a 1)))))))\n",
  "  (if (= 1 n) 1\n      (+ (expt 10 (- n 1)) (starts_one_ends (- n 1)))))\n", " \
    \ (local [(define (f n d s e)\n            (cond [(= n 1) (if (or (and (eq? d\
    \ 1) s)\n                                   (and (eq? d 1) e))\n             \
    \                  1\n                               0)]\n                  [(if\
    \ (and (eq? d 1) s)\n                       (+ (f (- n 1) 0 #t #f)\n         \
    \                 (f (- n 1) 1 #t #f))\n                       (+ (f (- n 1) 0\
    \ #f #t)\n                          (f (- n 1) 1 #f #t)))]))]\n    (f n 0 #t #t)))\n",
  "  (cond\n    [(= n 1) 2]\n    [(= n 2) 9]\n    [else (+ 2 (- (expt 10 (- n 1))\
    \ (expt 9 (- n 2))))]))\n", "  (cond\n    [(zero? n) 0]\n    [(or (= n 1) (= n\
    \ 2)) 1]\n    [else\n     (+ (expt 10 (- n 1)) (starts_one_ends (- n 1)))]))\n",
  "  (define (in n)\n    (let f ([i n] [a 1])\n      (if (= i 0)\n          a\n  \
    \        (f (- i 1) (* a 10)))))\n  (define (in-1 n)\n    (let f ([i n] [a 1])\n\
    \      (if (= i 0)\n          a\n          (f (- i 1) (* a 9)))))\n  (define (in-2\
    \ n)\n    (let f ([i n] [a 1])\n      (if (= i 0)\n          a\n          (f (-\
    \ i 1) (* a 8)))))\n  (define (starts n)\n    (define (ends a)\n      (let f ([i\
    \ (- n 1)] [b a])\n        (if (= i 0)\n            b\n            (f (- i 1)\
    \ (+ (* b 10) 1)))))\n    (ends (in-1 n)))\n  (+ (* (in-2 n) 2)\n     (* (starts\
    \ n) 2)\n     (in-1 n)))\n", "  (if (= n 1)\n      2\n      (for/sum ([i (in-range\
    \ 1 n)])\n        (starts_one_ends (- n i)))\n      )\n  )\n", "  (define a\n\
    \    (match n\n      [(= n 1) 1]\n      [(= n 2) 8]\n      [(= n 3) 64]\n    \
    \  [(= n 4) 512]\n      [(= n 5) 4096]\n      [(= n 6) 32768]\n      [(= n 7)\
    \ 262144]\n      [(= n 8) 2097152]\n      [(= n 9) 16777216]\n      [(= n 10)\
    \ 134217728]\n      [(= n 11) 1073741824]\n      [(= n 12) 8589934592]\n     \
    \ [(= n 13) 68719476736]\n      [(= n 14) 549755813888]\n      [(= n 15) 4398046511104]\n\
    \      [(= n 16) 35184372088832]\n      [(= n 17) 281474976710656]\n      [(=\
    \ n 18) 2251799813685248]\n      [(= n 19) 18014398509481984]\n      [(= n 20)\
    \ 144115188075855872]\n      [(= n 21) 1152921504606846976]\n      [(= n 22) 9223372036854775808]\n\
    \      [(= n 23) 73786976294838206464]\n      [(= n 24) 590295810358705651712]\n\
    \      [(= n 25) 4722366482869645213696]\n      [(= n 26) 37778931862957161709568]\n\
    \      [(= n 27) 302231454903657293676544]\n      [(= n 28) 2417851639229258349412352]\n\
    \      [(= n 29) 19371024424374904995716096]\n      [(= n 30) 154968195616476877540773376]\n\
    \      [(= n 31) 1239871006701319666449086336]\n      [(= n 32) 9903520314283042199192993792]\n\
    \      [(= n 33) 79228162514264337593543950336]\n      [(= n 34) 633825300114114700748351602688",
  "  (regexp-count (number->string n) #rx\"[1][0-9]*[1]\"))\n", "  (+ (* (- (expt\
    \ 10 (- n 1)) 2) (expt 10 (- n 1)))\n     (expt 10 (- n 1))))\n", "  (define (start?\
    \ n)\n    (let ((s (number->string n)))\n      (cond\n        [(< (string-length\
    \ s) n) 0]\n        [(equal? (substring s 0 1) \"1\") 1]\n        [else 0])))\n\
    \  (define (end? n)\n    (let ((s (number->string n)))\n      (cond\n        [(<\
    \ (string-length s) n) 0]\n        [(equal? (substring s (- (string-length s)\
    \ 1)) \"1\") 1]\n        [else 0])))\n  (let ((sum 0))\n    (for ([i (in-range\
    \ n (- n 0))])\n      (set! sum (+ sum (start? i) (end? i))))\n    sum))\n", " \
    \ (printf \"starts_one_ends ~a\" n)\n  (define (unary-of n)\n    (cond [(= n 0)\
    \ (list '*)]\n          [(= n 1) (list '* 1)]\n          [else (cons '* (unary-of\
    \ (- n 1)))])\n    )\n  (define (unary-of-n n)\n    (if (= n 1)\n        (list\
    \ (list '*))\n        (append (unary-of-n (- n 1)) (list (unary-of n)))))\n  (define\
    \ (count-one-ends ls)\n    (printf \"~a\\n\" ls)\n    (let ([ones (length (filter\
    \ (lambda (x) (memq 1 x)) ls))])\n      (printf \"ones ~a\\n\" ones)\n      ones))\n\
    \  (count-one-ends (unary-of-n n)))\n", "  (sum-ints (range 10 (- (expt 10 n)\
    \ 1))\n            (lambda (x)\n              (if (odd? (digit-sum x))\n     \
    \             1\n                  0))))\n", "  (let ((start (expt 10 (- n 1)))\n\
    \        (end (expt 10 n)))\n    (+ (- end start) start)))\n", "  (define (helper\
    \ n)\n    (let ([ones (+ 1 n)])\n      (+ ones ones (- 2 n))))\n  (helper (- n\
    \ 1)))\n", "  (let loop ([i 1] [counter 0])\n    (cond [(= i n) counter]\n   \
    \       [(= (modulo i 10) 1) (loop (+ i 1) (+ counter 1))]\n          [else (loop\
    \ (+ i 1) counter)])))\n", "  (letrec ([cnt (integer-sqrt n)]\n           [start-or-end-one?\
    \ (for/and ([i (in-range cnt)])\n                                     (let-values\
    \ ([(s e) (divmod n i)])\n                                       (and (number-&gt;string\
    \ (number-&gt;string s) e) 1)))]\n           [start-one? (for/and ([i (in-range\
    \ cnt)])\n                                (let-values ([(s e) (divmod n i)])\n\
    \                                  (and (number-&gt;string (number-&gt;string\
    \ i) s) 1)))]\n           [end-one? (for/and ([i (in-range cnt)])\n          \
    \                    (let-values ([(s e) (divmod n i)])\n                    \
    \            (and (number-&gt;string (number-&gt;string e) i) 1)))])\n    (if\
    \ (zero? n) 0\n        (+ (list-&gt;set start-or-end-one?)\n           (list-&gt;set\
    \ start-one?)\n           (list-&gt;set end-one?)))))\n</code>\n", "  (cond [(=\
    \ n 1) (add1 (starts_one_ends 1))]\n        [(= n 2) (add1 (starts_one_ends 2))]\n\
    \        [else (add1 (starts_one_ends n))]))\n", "  (cond\n    [(= n 1) 2]\n \
    \   [(= n 2) 4]\n    [else (+ (starts_one_ends (- n 1)) (starts_one_ends (- n\
    \ 2)))]))\n", "  (if (= n 1)\n      2\n      (+ (* n (expt 10 (- n 1))) (starts_one_ends\
    \ (- n 1)))))\n", "  ;; One digit integers\n  (if (= n 1) 1\n      ;; More digits\n\
    \      (+ (expt 10 (- n 1))\n         (expt 10 (- n 2)))))\n", "  (let* ([one-counts\
    \ (count-n-digit-one-numbers n)]\n         [count (+ (first one-counts) (second\
    \ one-counts))])\n    count))\n", "  (expt 10 (sub1 n)))\n", "  (define n-1 (-\
    \ n 1))\n  (define ending 1)\n  (define starting 1)\n  (for ([i (in-range 1 n-1)])\n\
    \    (set! ending (+ ending (* 10 ending)))\n    (set! starting (+ starting (*\
    \ 10 starting))))\n  (+ ending starting))\n</code>\nThe intuition is the following.\
    \ <code>ending</code> will represent the number of n-digit positive integers that\
    \ end with 1. For instance, if n = 5, then <code>ending</code> will be 1 + 10\
    \ + 100 + 1000 + 10000 = 11111. For n = 3, <code>ending</code> will be 1 + 10\
    \ + 100 = 111.\nSimilarly, <code>starting</code> will be the number of n-digit\
    \ positive integers that start with 1. For n = 5, it will be 1 + 10 + 100 + 1000\
    \ + 10000 = 11111. For n = 3, it will be 1 + 10 = 11.\nThe complexity of the function\
    \ is linear.\n", "  (if (= n 1)\n      2\n      (+ (* 2 (expt 10 (- n 1)))\n \
    \        (if (> n 2)\n             (* (- (expt 10 (- n 2)) 1) (expt 10 (- n 1)))\n\
    \             0))))\n", "  (cond\n    [(= n 1) 2]\n    [(= n 2) 4]\n    [else\
    \ (+ (starts_one_ends (- n 1))\n             (starts_one_ends (- n 2)))]))\n",
  "  (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [else (+ (* 2 (expt 10 (- n 1)))\
    \ (* 9 (expt 10 (- n 2))))]))\n", "  (cond [(= n 1) 2]\n        [(= n 2) 2]\n\
    \        [else (+ (starts_one_ends (- n 1))\n                 (starts_one_ends\
    \ (- n 2)))]))\n", "  (define (ones n)\n    (+ 1 (floor (/ n 10))))\n  (define\
    \ (tens n)\n    (if (zero? (modulo n 10))\n        0\n        (+ 1 (floor (/ n\
    \ 100)))))\n  (+ (ones n) (tens n)))\n", "  (cond\n    [(= n 1) 2]\n    [(< n\
    \ 1) 0]\n    [else (+ (starts_one_ends (- n 1))\n             (starts_one_ends\
    \ (- n 2)))]))\n", "  (starts_one_ends1 n))\n", "  (cond\n    [(= n 1) 2]\n  \
    \  [(= n 2) 3]\n    [else (+ (starts_one_ends (- n 1)) (starts_one_ends (- n 2)))]))\n",
  "  (cond\n    [(zero? n) 0]\n    [(equal? n 1) 1]\n    [else (+ (expt 10 (- n 1))\
    \ (* 9 (* 9 (expt 10 (- n 2)))))]))\n", "  (cond\n    [(zero? n) 0]\n    [(equal?\
    \ n 1) 1]\n    [else (add1 (* (expt 10 (- n 1)) n))]))\n</code>\nI solved this\
    \ and the other problems by writing a recursive function;\nHowever I can't help\
    \ think that there must be a way to do it using\nan iteration, I think.\nIs there\
    \ a way to solve this problem using iteration rather than recursion?", "  (define\
    \ (helper n m total)\n    (if (= n 0)\n        total\n        (if (= n 1)\n  \
    \          (+ total 1)\n            (if (= n m)\n                (helper (- n\
    \ 1) m (+ total (* n (* 10 (- n 1)))))\n                (helper (- n 1) m (+ total\
    \ (* 10 (- n 1))))))))\n  (if (= n 1)\n      1\n      (helper n n 0)))\n", " \
    \ (let loop ([n n] [count 0])\n    (cond [(= n 1) (add1 count)]\n          [(=\
    \ n 2) (add1 (add1 count))]\n          [else (loop (sub1 n) (+ count (expt 10\
    \ (- n 2))))])))\n", "  (define (count-starts-one-ends n start)\n    (if (= n\
    \ 1)\n        1\n        (+ start\n           (count-starts-one-ends (- n 1) start)\n\
    \           (count-starts-one-ends (- n 1) (- start 1)))))\n  (count-starts-one-ends\
    \ n 1))\n", "  (cond [(= n 1) 1]\n        [(= n 2) 21]\n        [else (* 21\n\
    \                 (expt 10 (- n 2))\n                 (add1 (- n 2)))]) ; (+ -1)\
    \ == (+ (- 1) (+ 0))\n  )\n</code>\n", "  (cond [(zero? n) 1]\n        [(or (=\
    \ n 1) (= n 2)) 2]\n        [else (+ (starts_one_ends (- n 1)) (* 2 (starts_one_ends\
    \ (- n 2))))]))\n", "  (if (= n 1)\n      (+ 1 (starts_one_ends (sub1 n)))\n \
    \     (let ([num (expt 10 (- n 1))])\n        (+ num (starts_one_ends (sub1 n))))))\n",
  "  (cond\n    [(zero? n) 0]\n    [(positive? n) (+ (starts_one_ends (- n 1))\n \
    \                     (expt 10 (- n 1)))]))\n", "  (cond [(= n 1) 1]\n       \
    \ [(< n 1) 0]\n        [else (+ (starts_one_ends (- n 1)) (starts_one_ends (-\
    \ n 2)))]))\n", "  (cond\n    [(= n 1) 2]\n    [(= n 2) (let ([start-one-stop-one\
    \ (+ (* 2 9) 2)]\n                 [start-one-stop-zero (+ (* 2 9) 1)]\n     \
    \            [start-zero-stop-one (* (* 2 9) 9)])\n               (+ start-one-stop-one\
    \ start-one-stop-zero start-zero-stop-one))]\n    [else (- (expt 10 n) (expt 10\
    \ (- n 1)))]))\n", "  (define (f n)\n    (cond [(= n 1) 2]\n          [(= n 2)\
    \ 9]\n          [else (+ (* 9 (f (- n 1))) (f (- n 2)))]))\n  (f n))\n", "  (if\
    \ (< n 2)\n      1\n      (+ (expt 10 (- n 1)) 1)))", "  (if (= n 1)\n      2\n\
    \      (+ (expt 10 (- n 1)) (expt 10 (- n 2)))))\n", "  (if (= n 1) 1\n      (apply\
    \ + (build-list (inc n)\n                (lambda (i)\n                  (apply\
    \ + (build-list (dec n)\n                          (lambda (j)\n             \
    \               (* (expt 10 j) (expt (- 10 (expt 10 (- i 1))) j)))))))))\n", " \
    \ (cond [(= n 1) 1]\n        [(= n 2) 2]\n        [else (+ (starts_one_ends (-\
    \ n 1))\n                 (starts_one_ends (- n 2)))]))\n</code>\nHowever, I only\
    \ get the answer for a given input <code>n</code>, which is not what's expected.\
    \ \nAny ideas?\n\n\nA:\n\nTry:\n<code>(define (starts_one_ends n)\n  (if (= n\
    \ 1)\n      1\n      (+ (starts_one_ends (- n 1))\n         (starts_one_ends (-\
    \ n 2)))))\n</code>\nOr better still:\n<code>(define (starts_one_ends n)\n  (if\
    \ (= n 1)\n      1\n      (+ (starts_one_ends (- n 1))\n         (starts_one_ends\
    \ (- n 2)))))\n", "  (let* ([digit-count (expt 10 n)]\n         [start-ends (expt\
    \ 10 (- n 1))]\n         [start-ends-1 (expt 10 (- n 2))])\n    (- (* start-ends\
    \ 10) (* start-ends-1 9))))\n", "  (let loop ([n (number->string n)]\n       \
    \      [total 0])\n    (if (zero? (string-length n))\n        total\n        (let*\
    \ ([last (string-ref n (sub1 (string-length n)))])\n          (if (char=? last\
    \ #\\1)\n              (loop (substring n 0 (sub1 (string-length n))) (+ total\
    \ 1))\n              (loop (substring n 0 (sub1 (string-length n))) total))))))\n",
  "  (define (starts_one_ends_helper num-digits)\n    (if (= num-digits 1) 1\n   \
    \     (let* ([power-ten (expt 10 (- num-digits 1))]\n               [first-digit\
    \ (quotient n power-ten)]\n               [last-digit (modulo n 10)])\n      \
    \    (if (or (= first-digit 1) (= last-digit 1))\n              (+ 1 (starts_one_ends_helper\
    \ (- num-digits 1)))\n              (starts_one_ends_helper (- num-digits 1))))))\n\
    \  (starts_one_ends_helper n))\n", "  (for/sum ([i (in-range 1 n)])\n    (if (equal?\
    \ 1 i) 1\n        (expt (integer-length (expt 10 i))\n              (if (= 1 (modulo\
    \ i 2))\n                  (- i 1)\n                  i)))))\n", "  (cond\n  \
    \  [(= n 1)\n     1]\n    [(= n 2)\n     11]\n    [else\n     (let ([first (starts_one_ends\
    \ (- n 1))]\n           [second (starts_one_ends (- n 2))])\n       (+ (* (expt\
    \ 10 (- n 1)) (+ 1 first))\n          (* first second))])))\n</code>\nHere's a\
    \ test harness:\n<code>#lang racket\n", "  (let ((f (make-for-syntax 0)))\n  \
    \  (define (once-recur n m)\n      (syntax-case n ()\n        [(_ n)\n       \
    \  (cond\n           [(zero? n) (syntax->datum #'m)]\n           [(= 1 n) (syntax-case\
    \ #'m ()\n                      [(_ m) (once-recur #'(- n 1) #'(+ m 1))])]\n \
    \          [else (syntax-case #'m ()\n                  [(_ m) (once-recur #'(-\
    \ n 1) #'(+ m 2))])])]))\n    (define (recur n m)\n      (syntax-case n ()\n \
    \       [(_ n)\n         (cond\n           [(zero? n) (syntax->datum #'m)]\n \
    \          [(= 1 n) (syntax-case #'m ()\n                      [(_ m) (once-recur\
    \ #'(- n 1) #'(+ m 1))])]\n           [else (syntax-case #'m ()\n            \
    \      [(_ m) (recur #'(- n 1) #'(+ m (once-recur #'n #'0)))])])]))\n    (recur\
    \ #'n #'0)))\n", "  (define (ends n)\n    (cond\n      [(zero? n) 0]\n      [(=\
    \ n 1) 1]\n      [else (+ (ends (- n 1))\n               (ends (- n 2)))]))\n\
    \  (cond\n    [(zero? n) 0]\n    [(= n 1) 1]\n    [else (+ (ends (- n 1))\n  \
    \           (ends (- n 2)))]))\n", "  ; We need to figure out the range of numbers\
    \ that fit the constraints\n  ; of the question.\n  ;\n  ; The last digit of any\
    \ number x that is n digits long must be less than\n  ; x / 10^(n-1). e.g., for\
    \ a number that is 3 digits long, the last digit\n  ; must be less than x / 100.\n\
    \  ;\n  ; The same logic shows that the first digit must be greater than x /\n\
    \  ; 10^n.\n  ;\n  ; So the range of numbers that fit the constraints of the question\
    \ is\n  ; 10^(n-1) < x < 10^n.\n  ;\n  ; Furthermore, we know that any n-digit\
    \ number must have n-1 zeros and\n  ; one 1, so there are n-1 places that the\
    \ 1 can go. This means there are\n  ; n-1 numbers of n digits that start or end\
    \ with 1.\n  (- (* n 10) (* n 9)))\n", "  (let loop ([i n] [acc 0])\n    (cond\
    \ [(zero? i) acc]\n          [(zero? (modulo i 10)) (loop (quotient i 10) acc)]\n\
    \          [(= 1 (modulo i 10)) (loop (quotient i 10) (+ acc 1))]\n          [else\
    \ (loop (quotient i 10) (+ (* (+ 1 n) (expt 10 (- n 1))) acc))])))\n</code>\n",
  "  (if (eq? n 1)\n      1\n      (+ (expt 10 (- n 1))\n         (expt 9 (- n 1)))))\n",
  "  ;; It's useful to define a helper function that does the main work.\n  ;; The\
    \ example from the question shows that we need 10^(n-1) for the\n  ;; last digits,\
    \ and another 10^(n-1) for the first digits, and then\n  ;; subtract 9 because\
    \ 010 is a repeat.\n  (define (starts_one_ends-helper n)\n    (* 2 (expt 10 (-\
    \ n 1)))\n    (- (expt 10 n) 9))\n  ;; We need to handle the empty case differently,\
    \ because we want to count\n  ;; the empty string, but we don't want to count\
    \ 000, 010, 020, etc.\n  (if (= n 0)\n      1\n      (starts_one_ends-helper n)))\n",
  "  (let ((sums 1))\n    (do ((digits n (- digits 1)))\n        ((zero? digits) sums)\n\
    \      (set! sums (+ sums (* sums 10))))))\n", "  (cond\n    [(zero? n) 0]\n \
    \   [(one? n) (expt 10 (- n 1))]\n    [else (+ (expt 10 (- n 1)) (starts_one_ends\
    \ (- n 1)))]))\n", "  (define (starts_1_ends_1 k)\n    (cond [(= k n) 0]\n   \
    \       [(= k (+ n 1)) 1]\n          [else (+ (expt 10 k) (starts_1_ends_1 (+\
    \ k 1)))]))\n  (cond [(= n 1) 2]\n        [else (+ (* 2 (expt 10 (- n 1))) (starts_1_ends_1\
    \ 2))]))\n", "  (letrec ((next-digit (lambda (num) (modulo (add1 (floor (/ num\
    \ 10))) 10)))\n           (digit-counts (lambda (num)\n                      \
    \     (cond\n                             [(zero? num) 0]\n                  \
    \           [(= (next-digit num) 1) (add1 (digit-counts (quotient num 10)))]\n\
    \                             [else (digit-counts (quotient num 10))]))))\n  \
    \  (digit-counts (expt 10 n))))\n</code>\nIt turns out that this is an endless\
    \ loop, returning <code>#&lt;promise:&gt;</code>.\nMy thinking is that the recursive\
    \ call to <code>digit-counts</code> at the end of the function is unnecessary,\
    \ because the <code>digit-counts</code> function always returns 1. I'd like to\
    \ understand why that is not the case.", "  (let loop ([n n] [res n])\n    (cond\
    \ [(zero? n) res]\n          [else (loop (- n 1) (* n res))])))\n", "  (define\
    \ (one_digit n)\n    (if (= n 1) 1 0))\n  (define (two_digit n)\n    (if (= n\
    \ 2) 10 (+ (one_digit (sub1 n))\n                      (two_digit (sub1 n)))))\n\
    \  (cond [(= n 1) 1]\n        [(= n 2) 11]\n        [else (two_digit n)]))\n",
  "  (define (in-range? x)\n    (and (>= x (expt 10 (- n 1)))\n         (< x (expt\
    \ 10 n))))\n  (define (starts-with-one? x)\n    (integer? (string-find \"1\" (number->string\
    \ x))))\n  (define (ends-with-one? x)\n    (string-suffix? \"1\" (number->string\
    \ x)))\n  (let loop ([i (expt 10 (- n 1))]\n             [count 0])\n    (if (&gt;\
    \ i (expt 10 n))\n        count\n        (if (in-range? i)\n            (cond\n\
    \              [(starts-with-one? i)\n               (loop (+ i 1) (+ count 1))]\n\
    \              [(ends-with-one? i)\n               (loop (+ i 1) (+ count 1))]\n\
    \              [else\n               (loop (+ i 1) count)])\n            (loop\
    \ (+ i 1) count)))))\n</code>\nIt works:\n<code>&gt; (for/list ([i (in-range 10)])\
    \ (starts_one_ends i))\n'(9 99 999 9999 99999 999999 9999999 99999999 999999999)\n\
    </code>\n", "  (if (< n 1)\n      0\n      (cond\n        [(= n 1) 2]\n      \
    \  [(= n 2) (add1 (expt 2 (sub1 n)))]\n        [else (+ (add1 (expt 2 (sub1 n)))\n\
    \                 (starts_one_ends (sub1 n)))])))\n", "  (+ (expt 10 (- n 1))\
    \ (expt 9 (- n 1))))\n</code>\n<code>expt</code> is the power function, which\
    \ can take integers as parameters.\nEDIT:\nThe problem I think the question is\
    \ trying to ask is the following:\n<blockquote>\n<p>Given a positive integer n,\
    \ return the count of the n-digit positive integers that start or end with 1.</p>\n\
    </blockquote>\nWith that in mind, here is a more appropriate answer:\n<code>#lang\
    \ racket\n", "  ;; Generate all the n-digit numbers\n  (for/list ([n (in-range\
    \ 1 n)])\n    (build-list n (lambda (x) (random 9)))))\n</code>\nI don't know\
    \ how to filter the numbers that start or end with 1 or how to print the result.\n\
    \n\nA:\n\nHint:\n<code>(define (starts-with-one? n)\n  (and (positive? n)\n  \
    \     (equal? 1 (quotient n 100000))))\n", "  (cond [(< n 1) 0]\n        [(= n\
    \ 1) 1]\n        [else (add1 (add1 (starts_one_ends (sub1 n))))]))\n", "  (cond\n\
    \    [(= n 1) 1]\n    [(= n 2) 10]\n    [else (+ (* n 10) (- n 1))]))\n", "  (if\
    \ (= n 1)\n      2\n      (+ (expt 10 (- n 1))\n         (expt 10 (- n 2)))))\n\
    </code>\nNote the above code is simply my intuition translated into a routine.\
    \ I hope it is correct.\n\n\nA:\n\nThere is a simple solution to this. Essentially,\
    \ all you are doing is calculating the number of integers of length <code>n</code>\
    \ (excluding leading and trailing zeros). The sum of the number of integers of\
    \ length <code>1</code> to length <code>n</code> should give you the number of\
    \ integers of length <code>n</code> that end with a <code>1</code> or start with\
    \ a <code>1</code>.\n<code>(define (start-end-1 n)\n  (let loop ((i 1) (total\
    \ 0))\n    (if (&gt; i n)\n        total\n        (loop (+ i 1) (+ total (expt\
    \ 10 (- i 1)))))))\n</code>\n", "  (cond [(= n 1) 2]\n        [(= n 2) 4]\n  \
    \      [else (add1 (* (sub1 n) 2))]))\n", "  (cond\n    [(= n 1) 2]\n    [(= n\
    \ 2) 9]\n    [else\n     (+ (starts_one_ends (- n 1)) (starts_one_ends (- n 2)))]))\n",
  "  (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [else\n     (+ (* (- n 1) (- n 2))\
    \ (* n 2))]))\n", "  (let ([range (in-range 1 (expt 10 n))])\n    (define (iter\
    \ range sum)\n      (cond\n        [(zero? (length range)) sum]\n        [(string-contains\
    \ (number->string (first range)) \"1\")\n         (iter (rest range) (+ sum 1))]\n\
    \        [else (iter (rest range) sum)]))\n    (iter range 0)))\n```\n\n```\n\
    > (starts_one_ends 5)\n49\n```\n\n```racket\n#lang racket\n", "  (cond\n    [(=\
    \ 1 n) 2]\n    [(= 2 n) 6]\n    [else (+ (* 2 (expt 10 (- n 1))) (* 5 (expt 10\
    \ (- n 2))))]))\n", "  (if (= n 1)\n      1\n      (+ (* n (expt 10 (- n 1)))\n\
    \         (expt 10 (- n 1)))))\n", "  (match n\n    [(list x) (starts_one_ends\
    \ x)]\n    [(number? n)\n     (cond [(> n 0)\n            (+ 1\n             \
    \  (expt 10 (- n 1))\n               (expt 10 (- n 1)))]\n           [else 0])]))\n",
  "  (cond\n    ((= n 1) 2)\n    ((= n 2) 5)\n    (else\n     (let ([left  (+ 1 (starts_one_ends\
    \ (- n 1)))])\n       (+ left (starts_one_ends (- n 2)))))))\n", "  (define (starts-and-ends\
    \ s e)\n    (for/fold ([c 1]) ([d (in-range 1 (+ s e))])\n      (if (= 1 d)\n\
    \          (add1 c)\n          c)))\n  (define (starts-with s)\n    (for/fold\
    \ ([c 0]) ([e (in-range (- n s) n)])\n      (add1 c (starts-and-ends s e))))\n\
    \  (for/fold ([c 0]) ([s (in-range 1 n)])\n    (add1 c (starts-with s))))\n</code>\n\
    \n<code>#lang racket\n", "  (cond\n    [(= n 1) 2]\n    [(= n 2) 9]\n    [else\n\
    \     (+ 9 (+ (starts_one_ends (- n 1))\n             (starts_one_ends (- n 2))))]))\n\
    </code>\n", "  (count-if (lambda (x) (member (number->string x) '(\"1\" \"11\"\
    )))\n            (build-list (expt 10 n) (lambda (x) x))))", "  (let loop ([i\
    \ 1] [j 0])\n    (if (= i n)\n        j\n        (loop (+ i 1) (+ j (- 9 n))))))\n",
  "  (cond\n    [(< n 0) (error \"starts_one_ends: argument must be non-negative\"\
    )]\n    [(zero? n) 0]\n    [(zero? (modulo n 10)) (starts_one_ends (quotient n\
    \ 10))]\n    [else (+ 1 (starts_one_ends (quotient n 10)))]))\n", "  (cond\n \
    \   [(equal? n 1) 2]\n    [else\n     (+\n      (expt 10 (- n 1))\n      (expt\
    \ 10 (- n 2)))]))\n", "  (cond [(= n 1) 2]\n        [(= n 2) 3]\n        [else\
    \ (+ (number->string (* 9 (expt 10 (- n 1))))\n                 (number->string\
    \ (* 9 (expt 10 (- n 2)))))]))\n", "  (if (= n 1)\n      (+ 1 10)\n      (+ (*\
    \ 10 (- 1 (starts_one_ends (- n 1)))) (* 9 (expt 10 (- n 1))))))\n</code>\nBut,\
    \ if I do this, I get a stack overflow.\nIs there a better way to do this?\n\n\
    \nA:\n\nA simple, recursive (non-tail) solution is:\n<code>(define (starts-one-ends\
    \ n)\n  (if (zero? n)\n      0\n      (+ (expt 10 (- n 1))\n         (starts-one-ends\
    \ (- n 1)))))\n</code>\nThe intuition here is that, for any digit length <code>n</code>,\
    \ there are <code>9 * 10^(n-1)</code> numbers that neither start nor end with\
    \ <code>1</code>, <code>10^(n-1)</code> numbers that start with <code>1</code>,\
    \ and <code>10^(n-1)</code> numbers that end with <code>1</code>.  And this takes\
    \ care of itself recursively.\nFor a tail-recursive solution, we can use the following\
    \ observation:\n<code>(starts-one-ends n)\n= (+ (expt 10 (- n 1)) (starts-one-ends\
    \ (- n 1)))\n= (+ (expt 10 (- n 1)) (+ (expt 10 (- (- n 1) 1)) (starts-one-ends\
    \ (- (- n 1) 1))))\n= (+ (expt 10 (- n 1)) (+ (expt 10 (- (- n 1) 1)) (+ (expt\
    \ 10 (- (- (- n 1) 1) 1)) (starts-one-ends (- (- (- n 1) 1) 1)))))\n...\n= (+\
    \ (expt 10 (- n 1)) (+ (expt 10 (- (- n 1) 1)) (+ (expt 10 (- (- (- n 1) 1) 1))\
    \ ... + (expt 10 (- (- n 1) 1)) (+ (expt 10 (- (- n 1) 1)) (+ (expt 10 (- (- (-\
    \ n 1) 1) 1)) ... (expt 10 (- (- n 1) 1))))) ... )))\n</code>\nThe only thing\
    \ that is growing on the stack is the chain of <code>+</code", "  (cond [(= n\
    \ 1) 1]\n        [(= n 2) 10]\n        [else (+ (* 9 (expt 10 (- n 2))) (starts_one_ends\
    \ (- n 1)))]))\n</code>\nPlease consider to use <code>let</code> or <code>let*</code>\
    \ instead of <code>cond</code> if you want to use multiple conditions.\n", " \
    \ (if (= n 1)\n      1\n      (let* ([powers-of-10 (list 1 10 100 1000 10000 100000\
    \ 1000000)]\n             [first-place-ones (list 1 10 100 1000 10000 100000 1000000)]\n\
    \             [last-place-ones (list 1 11 111 1111 11111 111111 1111111)]\n  \
    \           [rest-of-digits (- (length powers-of-10) n)])\n        (cond\n   \
    \       [(= n 2)\n           (+ (car first-place-ones)\n              (car last-place-ones))]\n\
    \          [(= n 3)\n           (+ (car first-place-ones)\n              (car\
    \ last-place-ones)\n              (* 2 (car (cdr first-place-ones))))]\n     \
    \     [else\n           (+ (car first-place-ones)\n              (car last-place-ones)\n\
    \              (* (car (cdr first-place-ones))\n                 (car (cdr rest-of-digits)))\n\
    \              (* 9 (- (car (cdr powers-of-10)) (car (cdr last-place-ones)))))])))\n\
    \  )\n</code>\nFor example:\n<code>&gt; (starts_one_ends 3)\n21\n&gt; (starts_one_ends\
    \ 4)\n121\n&gt; (starts_one_ends 5)\n721\n&gt; (starts_one_ends 6)\n4521\n&gt;\
    \ (starts_one_ends 7)\n28721\n&gt; (starts_one_ends 8)\n20021\n&gt; (starts_one_ends\
    \ 9)\n20021\n&gt; (starts_one_ends 10)\n20021\n</code>\nI have a solution for\
    \ <code>n = 2</code> which is:\n<code>&gt; (starts_one_ends 2)\n11\n</code>\n\
    And a solution for <code>n = 3</code> which is:\n<code>&gt; (starts_one_ends 3)\n\
    21\n</code>\nI am trying to extend my solution to <code>n &gt; 3</code>; however,\
    \ I am not sure how to account for the digits", "  (cond\n    [(= 1 n) 1]\n  \
    \  [(> n 1) (+ (expt 10 (- n 1)) 1)]))\n", "  (if (< n 1)\n      0\n      (add1\
    \ (expt 2 (- n 1)))))\n", "  (cond [(equal? n 1) (exact-integer->inexact 1)]\n\
    \        [(equal? n 2) (exact-integer->inexact 10)]\n        [else (+ (exact-integer->inexact\
    \ (expt 10 (- n 2)))\n                 (starts_one_ends (- n 1))\n           \
    \      (starts_one_ends (- n 2)))]))\n", "  (if (zero? n)\n      (error \"n cannot\
    \ be zero\"))\n  (define (start_one_end i)\n    (cond\n      [(zero? i)\n    \
    \   (cond\n         [(zero? (modulo n 2)) (+ 1 (* (factorial (- n 2)) (factorial\
    \ (- n 2))))]\n         [else (* (factorial (- n 2)) (factorial (- n 2)))])]\n\
    \      [(zero? (modulo i 2)) (+ 1 (start_one_end (- i 1)))]\n      [else (start_one_end\
    \ (- i 1))]))\n  (start_one_end n))\n</code>\n", "  (if (= n 1)\n      1\n   \
    \   (+ (starts_one_ends (- n 1))\n         (* 2 (expt 10 (- n 1)))\n         (expt\
    \ 10 (- n 1)))))\n", "  (cond\n    [(= n 1) 2]\n    [(or (= n 2) (= n 3)) 3]\n\
    \    [else (if (= (remainder n 2) 0)\n             (+ 1 (starts_one_ends (- n\
    \ 1)))\n             (* 3 (starts_one_ends (- n 1))))]))\n```\n\n## Ugly Sequence\n\
    \n```racket\n#lang racket\n", "  (if (= n 1) 1\n      (+ (digit-sum n) (- (starts_one_ends\
    \ (- n 1))))))\n", "  (add1 (expt (sub1 n) n)))\n", "  (let ([m (expt 10 (- n\
    \ 1))])\n    (+ (* 2 (- (expt 10 n) m)) (* 8 (- (expt 10 (- n 2)) m)))))\n", " \
    \ (define (pow x n)\n    (cond ((= n 0) 1)\n          ((even? n) (pow (* x x)\
    \ (/ n 2)))\n          (else (* x (pow (* x x) (- n 1))))))\n  (- (pow 10 n) (pow\
    \ 9 n)))\n", "  (expt 10 (- n 1)))\n", "  (if (= n 1)\n      2\n      (starts_one_ends\
    \ (- n 1))))\n", "  (define (inner n)\n    (cond [(= n 0) 1]\n          [(= n\
    \ 1) 1]\n          [else (+ (inner (- n 1))\n                   (inner (- n 2)))]))\n\
    \  (inner (- n 1)))\n", "  (cond\n    [(zero? n) 1]\n    [else\n     (+ (expt\
    \ 10 (- n 1))\n        (expt 10 (- n 2)))]))\n", "  (expt 2 n))\n", "  (if (=\
    \ n 1) 1\n      (+ (if (odd? n) 1 0)\n         (* (expt 10 (/ (- n 1) 2))\n  \
    \          (if (odd? n) 10 1)))))\n</code>\nI don't think I'm getting it quite\
    \ right, though. I've tried to explain my thinking in the comments, but something\
    \ isn't adding up.\n\n\nA:\n\nHere's a guide to help you find your solution. \n\
    Let's suppose you want to find the number of n-digit numbers that start with 1.\n\
    <code>n = 1: 1\nn = 2: 10\nn = 3: 100\nn = 4: 1000\nn = 5: 10000\nn = 6: 100000\n\
    </code>\nDo you see a pattern? What is it?\nLet's suppose you want to find the\
    \ number of n-digit numbers that end with 1.\n<code>n = 1: 1\nn = 2: 10\nn = 3:\
    \ 100\nn = 4: 1000\nn = 5: 10000\nn = 6: 100000\n</code>\nDo you see a pattern?\
    \ What is it?\n", "  (let ([n-digits-not-one (expt 10 (- n 1))])\n    (+ (expt\
    \ n-digits-not-one n) (* (- n 1) (expt n-digits-not-one (+ n 1))))))\n", "  (cond\n\
    \    ((zero? n) 0)\n    ((equal? n 1) 2)\n    (else\n     (let ([n (exact->inexact\
    \ n)])\n       (+ 1 ;; n-digit numbers with 1 at the beginning\n          (exact->inexact\
    \ (expt (- n 1) 9)) ;; n-digit numbers with 1 at the end\n          (* 2 ;; n-digit\
    \ numbers with 1 at the beginning and end\n             (exact->inexact (expt\
    \ (- n 2) 9)))))))) ;; n-digit numbers with 1 at the beginning and end\n", " \
    \ (letrec ([count (\u03BB (i)\n                    (cond [(< i 1) 0]\n       \
    \                   [(= i 1) 1]\n                          [else (+ (count (-\
    \ i 1)) (count (- i 2)))]))])\n    (count n)))\n", "  (local [(define (range-count\
    \ n)\n            (define (range-count-iter n lo hi)\n              (cond [(=\
    \ n lo) hi]\n                    [else (range-count-iter (- n 1) (+ lo 1) (* hi\
    \ 10))]))\n            (if (= n 1)\n                1\n                (range-count-iter\
    \ n 1 9)))\n          (define (pos-count n)\n            (+ (range-count n)\n\
    \               (range-count n)))]\n    (pos-count n)))\n", "  (if (= 1 n)\n \
    \     (exact-floor (expt 10 n) 9)\n      (+ (starts_one_ends (- n 1)) (exact-floor\
    \ (expt 10 (- n 1)) 9))))\n", "  (let* ([n-minus-1 (- n 1)]\n         [values-n-minus-1\
    \ (count-to n-minus-1)]\n         [values-n (* values-n-minus-1 n)])\n    (+ values-n-minus-1\
    \ values-n)))\n", "  (define (digit_count i)\n    (cond [(< i 10) 1]\n       \
    \   [else (+ 1 (digit_count (/ i 10)))]))\n  (define (starts_one? i)\n    (and\
    \ (< i (expt 10 n))\n         (= 1 (modulo i 10))))\n  (define (ends_one? i)\n\
    \    (and (< i (expt 10 n))\n         (= 1 (modulo (/ i (expt 10 (- n 1))) 10))))\n\
    \  (define (count_starts_ends_one i)\n    (cond [(= n (digit_count i)) 0]\n  \
    \        [(or (starts_one? i) (ends_one? i))\n           (+ 1 (count_starts_ends_one\
    \ (+ i 1)))]\n          [else (count_starts_ends_one (+ i 1))]))\n  (count_starts_ends_one\
    \ 1))\n", "  (define (count n)\n    (cond [(= n 1) 2]\n          [(= n 2) 3]\n\
    \          [else (+ (count (- n 1)) (count (- n 2)))]))\n  (count n))\n</code>\n\
    I haven't found a closed form expression for this.\n", "  (let loop ([x 1] [i\
    \ n] [count 0])\n    (cond [(= i 1) (+ count (if (member (modulo x 10) '(1 9))\
    \ 1 0))]\n          [(< i 1) count]\n          [else (loop (+ (* 10 x) 1) (- i\
    \ 1)\n                      (+ count (if (member (modulo x 10) '(1 9)) 1 0)))])))\n",
  "  (cond [(> n 0) (+ (integer-expt 10 (- n 1)) 1)]\n        [else 1]))\n", "  (let\
    \ ((bound (expt 10 n)))\n    (for/sum ([i (in-range 1 bound)] #:when (or (= (remainder\
    \ i 10) 1)\n                                               (= (quotient i bound)\
    \ 1)))\n      1)))\n", "  (cond [(= n 1) 2]\n        [(= n 2) 3]\n        [else\
    \ (+ (starts_one_ends (- n 1))\n                 (starts_one_ends (- n 2)))]))\n",
  "  (letrec ((counts (lambda (n)\n                     (cond ((= n 1) 1)\n      \
    \                     ((= n 2) 11)\n                           (else (+ (counts\
    \ (- n 1))\n                                    (counts (- n 2))))))))\n    (counts\
    \ n)))\n</code>\nThis uses the same logic as your first solution, but with a tail-recursive\
    \ helper procedure. It has <code>O(n)</code> time and space complexity.\n", " \
    \ (let ([range (in-range 1 (expt 10 n))])\n    (count\n     (lambda (x)\n    \
    \   (or (regexp-match #rx\"^1\" (number->string x))\n           (regexp-match\
    \ #rx\"1$\" (number->string x))))\n     range)))\n", "  (if (< n 2)\n      1\n\
    \      (+ (expt 10 (- n 1))\n         (* (- n 1) (expt 10 (- n 2))))))\n", " \
    \ (cond\n    [(equal? n 1) (add1 (square 9))]\n    [else (add1 (* (square 10)\
    \ (expt 10 (- n 2))))]))\n", "  (define (sends i)\n    (cond\n      [(zero? i)\
    \ 1]\n      [(= i 1) 0]\n      [else (+ (sends (- i 1)) (sends (- i 2)))]))\n\
    \  (sends n))\n", "  ;; for 2-digit numbers, count the number of numbers with\
    \ 1's as the second digit\n  (cond\n    [(= n 2) 9]\n    [(= n 1) 1]\n    [else\
    \ (+ (starts_one_ends (- n 1)) (starts_one_ends (- n 2)))]))\n", "  (add1\n  \
    \ (for/sum ([i (in-range 1 (add1 n))])\n     (power 10 (sub1 i)))))\n", "  (if\
    \ (< n 1)\n      0\n      (let ((power-of-ten (expt 10 n)))\n        (+ (- power-of-ten\
    \ (expt 10 (- n 1)))\n           (- power-of-ten (expt 10 (- n 1)))))))\n", " \
    \ (expt 10 (- n 1)))\n", "  (integer->string n)\n  (substring (integer->string\
    \ n) 0 1)\n  (substring (integer->string n) -1)\n  (cond\n    [(string=? (substring\
    \ (integer->string n) 0 1) \"1\")\n     (add1 (starts_one_ends (sub1 n)))]\n \
    \   [(string=? (substring (integer->string n) -1) \"1\")\n     (add1 (starts_one_ends\
    \ (sub1 n)))]\n    [else\n     (starts_one_ends (sub1 n))]))\n", "  (cond\n  \
    \  [(= n 1) 2]\n    [(= n 2) 3]\n    [else\n     (+ (starts_one_ends (- n 1))\n\
    \        (starts_one_ends (- n 2)))]))\n", "  (expt (expt 10 (- n 1)) 2))\n",
  "  (define (count-help n)\n    (cond [(= n 0) 1]\n          [(= n 1) 2]\n      \
    \    [else (+ (count-help (- n 1)) (count-help (- n 2)))]))\n  (count-help (-\
    \ n 1)))\n</code>\nHowever, I need to use apply and map.\nThe following code compiles,\
    \ but I get an error:\n<code>;; Given a positive integer n, return the count of\
    \ the numbers of n-digit", "  (let loop ([i (expt 10 (- n 1))] [count 0])\n  \
    \  (cond [(< i (expt 10 n))\n           (if (or (member (quotient i 10) '(1 2\
    \ 3 4 5 6 7 8 9))\n                   (member (modulo i 10) '(1 2 3 4 5 6 7 8\
    \ 9)))\n               (loop (+ i 1) (+ count 1))\n               (loop (+ i 1)\
    \ count))]\n          [else count])))\n", "  (define (digit_count n)\n    (cond\
    \ [(zero? n) 1]\n          [else (+ 1 (digit_count (quotient n 10)))]))\n  (define\
    \ (starts_one_ends-aux n i)\n    (cond [(>= i n) 1]\n          [else (+ (starts_one_ends-aux\
    \ n (+ i 1)) (starts_one_ends-aux n (- i 1)))]))\n  (starts_one_ends-aux n (digit_count\
    \ n)))\n", "  (cond [(equal? n 1) 1]\n        [(equal? n 2) 2]\n        [else\
    \ (+ 1 (starts_one_ends (- n 1))\n                 (starts_one_ends (- n 2)))]))\n",
  "  (define (helper r n)\n    (cond\n      [(zero? n) 1]\n      [(zero? r) (+ (helper\
    \ 1 (- n 1)) (helper 2 (- n 1)))]\n      [(equal? r 1) (+ (helper 1 (- n 1)) (helper\
    \ 2 (- n 1)))]\n      [(equal? r 2) (+ (helper 1 (- n 1)) (helper 2 (- n 1)))]))\n\
    \  (helper 0 n))\n</code>\n", "  (expt 10 (- n 1)))\n", "  (if (= n 1) 1\n   \
    \   (let loop ((n (- n 1)) (count 0))\n        (if (&lt; n 1) count\n        \
    \    (loop (- n 1) (+ count (starts_one_ends n)))))))\n", "  (count\n   (range\
    \ 1 (* 10 n))\n   (lambda (x) (regexp-match? #rx\"^1.*$|^.*1$\" (number->string\
    \ x)))))", "  (match n\n    ['0 0]\n    ['1 10]\n    ['2 9 * 10]\n    ['3 9 *\
    \ 100]\n    ['4 9 * 1000]\n    ['5 9 * 10000]\n    ['6 9 * 100000]\n    ['7 9\
    \ * 1000000]\n    ['8 9 * 10000000]\n    ['9 9 * 100000000]\n    ['10 9 * 1000000000]\n\
    \    [_ (starts_one_ends (sub1 n))]))\n", "  (let loop ([curr 0] [next 1] [count\
    \ 0])\n    (cond\n      [(= curr n) count]\n      [(= next 10) (loop (+ curr 1)\
    \ 1 (+ count curr))]\n      [else (loop curr (+ next 1) (+ count (* curr next)))])))\n\
    </code>\nThere's probably a cleaner solution using <code>for</code>, but the main\
    \ idea is that we can separate the solution into two cases:\n\nThere are <code>n</code>\
    \ -digit numbers that start with 1 and end with 0, 1, ..., 9.\nThere are <code>n</code>\
    \ -digit numbers that end with 1 and start with 0, 1, ..., 9.\n\nThe case when\
    \ the number starts and ends with 1 is counted in both ways, so we need to subtract\
    \ that case.\nUsing the infinite numeric tower, you could add the cases together,\
    \ but I don't think that's necessary here.\n", "  (cond [(= n 1) 2]\n        [(=\
    \ n 2) 9]\n        [else (+ (expt 10 (- n 2)) (* 9 (expt 10 (- n 1))))]))\n",
  "  (count n 1 n))\n", "  (for/sum ([i (- (expt 10 n) 1)])\n    (let ([s (number->string\
    \ i)])\n      (if (or (string=? (substring s 0 1) \"1\")\n              (string=?\
    \ (substring s (- (string-length s) 1)) \"1\"))\n          1\n          0))))\n",
  "  (define (make_digit lst)\n    (let ([n (length lst)])\n      (if (zero? n)\n\
    \          0\n          (let* ([first (first lst)]\n                 [n-1 (sub1\
    \ n)])\n            (if (zero? n-1)\n                first\n                (if\
    \ (zero? first)\n                    (* first (expt 10 n-1))\n               \
    \     (* (- first 1) (expt 10 n-1)))))\n          )))\n  (let ([n (number->string\
    \ n)])\n    (+ (make_digit (string->list n))\n       (make_digit (reverse (string->list\
    \ n))))))\n", "  (cond [(= 1 n) 3]\n        [(= 2 n) 9]\n        [else (+ (starts_one_ends\
    \ (- n 1))\n                 (* 10 (starts_one_ends (- n 2))))]))\n", "  (for/sum\
    \ ([i (in-range 10 (expt 10 n))])\n    (let* ([s (number->string i)]\n       \
    \    [starts-with-one? (equal? (string-ref s 0) #\\1)]\n           [ends-with-one?\
    \ (equal? (string-ref s (- (string-length s) 1)) #\\1)])\n      (if (or starts-with-one?\
    \ ends-with-one?) 1 0))))\n", "  (cond\n    [(= n 1) 1]\n    [(= n 2) 10]\n  \
    \  [else (+ (for/sum ([i (in-range n 1)])\n                 (expt 10 i))\n   \
    \          1\n             (for/sum ([i (in-range 1 n)])\n               (expt\
    \ 10 i)))]))\n", "  (let ([a (for/fold ([res 0]) ([x (in-range 1 (+ 1 (expt 10\
    \ (- n 1))))])\n               (if (and (and (and (<= x (expt 10 (- n 1))) (<=\
    \ x (expt 10 (- n 1))))\n                             (and (>= x (expt 10 (- n\
    \ 1))) (>= x (expt 10 (- n 1)))))\n                        (and (and (and (<=\
    \ x (expt 10 (- n 1))) (<= x (expt 10 (- n 1))))\n                           \
    \       (and (>= x (expt 10 (- n 1))) (>= x (expt 10 (- n 1))))))\n          \
    \         (add1 res)\n                   res))\n         b (for/fold ([res 0])\
    \ ([x (in-range 1 (+ 1 (expt 10 (- n 1))))])\n               (if (and (and (and\
    \ (<= x (expt 10 (- n 1))) (<= x (expt 10 (- n 1))))\n                       \
    \      (and (>= x (expt 10 (- n 1))) (>= x (expt 10 (- n 1)))))\n            \
    \            (and (and (and (<= x (expt 10 (- n 1))) (<= x (expt 10 (- n 1))))\n\
    \                                  (and (>= x (expt 10 (- n 1))) (>= x (expt 10\
    \ (- n 1))))))\n                   (add1 res)\n                   res))\n    \
    \     c (+ a b))\n    (if (= n 1)\n        1\n        (- (* 10 c) (* 9 (expt 10\
    \ (- n 1)))))))", "  (if (= n 1) 1\n      (+ 1 (* 2 (- (expt 10 (- n 1)) (expt\
    \ 9 (- n 1)))))))\n", "  (display n)\n  (display \" \")\n  (display (count-n-digit-starts-or-ends\
    \ n))\n  (newline))\n", "  (define n-1 (sub1 n))\n  (define n-2 (sub1 n-1))\n\
    \  (define n-3 (sub1 n-2))\n  (define (pow x y)\n    (if (= y 0)\n        1\n\
    \        (* x (pow x (- y 1)))))\n  (+ (* n-1 (pow 10 n-1))\n     (* n-2 (pow\
    \ 10 n-3))\n     (* n-3 (pow 10 n-3))))\n", "  (define (num_ones n)\n    (if (zero?\
    \ n)\n        1\n        (+ (num_ones (- n 1))\n           (num_ones (- n 2)))))\n\
    \  (define (s1e n)\n    (if (zero? n)\n        0\n        (+ (* 10 (s1e (- n 1)))\n\
    \           (num_ones (- n 1)))))\n  (+ (s1e n)\n     (s1e (- n 1))))\n", "  (define\
    \ (ones x)\n    (cond [(= x 0) 0]\n          [(= x 1) 1]\n          [(&lt; x 10)\
    \ 1]\n          [else (+ (ones (quotient x 10))\n                   (ones (remainder\
    \ x 10)))]))\n  (cond [(= n 1) 10]\n        [(= n 2) 9]\n        [(&lt; n 10)\
    \ (+ (ones (expt 10 (- n 1)))\n                     (ones (expt 10 (- n 2)))\n\
    \                     (ones (expt 10 (- n 3)))\n                     (ones (expt\
    \ 10 (- n 4)))\n                     (ones (expt 10 (- n 5)))\n              \
    \       (ones (expt 10 (- n 6)))\n                     (ones (expt 10 (- n 7)))\n\
    \                     (ones (expt 10 (- n 8)))\n                     (ones (expt\
    \ 10 (- n 9)))\n                     (ones (expt 10 (- n 10))))]))\n</code>\n\
    As suggested by the homework, I solved it recursively. It works fine with\n<code>(starts_one_ends\
    \ 6)\n</code>\nBut when I tried\n<code>(starts_one_ends 20)\n</code>\nIt didn't\
    \ show any answer.\nSo I wonder if this program is correct and if it is, how do\
    \ I make it return\nthe result for big n? Thanks!\n\n\nA:\n\nYou are accidentally\
    \ overwriting the function <code>ones</code> in your code. Try this:\n<code>(define\
    \ (starts_one_ends n)\n  (define (ones x)\n    (cond [(= x 0) 0]\n          [(=\
    \ x 1) 1]\n          [(&lt; x 10) 1]\n          [else (+ (ones (quotient x 10))\n\
    \                   (ones (remainder x 10)))]))\n  (cond [(= n 1) 10]\n      \
    \  [(= n 2) 9]\n        [(&lt; n 10) (+ (ones (expt 10 (- n 1)))\n           \
    \          (ones (expt 10 (- n 2)))\n                     (ones (expt 10 (- n\
    \ 3)))\n                     (ones (expt 10 (- n 4)))\n                     (ones\
    \ (expt 10 (- n 5)))\n                     (ones", "  (cond\n    [(= 1 n) (add1\
    \ (count-ones (count-numbers n 1)))]\n    [else (count-ones (count-numbers n 1))]))\n",
  "  (if (= n 1)\n      2\n      (+ (expt 10 (- n 1)) 2 (* (expt 10 (- n 2)) 9))))\n",
  "  (letrec ([non-1-digits (integer->digits (expt 10 (- n 1)))])\n    (define (recur\
    \ init acc)\n      (let ([next-acc (+ acc init)])\n        (if (zero? (remainder\
    \ init 10))\n            (recur (quotient init 10) next-acc)\n            next-acc)))\n\
    \    (recur (expt 10 (- n 1)) 0)))\n", "  (cond [(= n 1) (+ 1 (count-from-to 1\
    \ 9))]\n        [(or (= n 2) (= n 3)) (+ 1 (count-from-to 10 99))]\n        [(=\
    \ n 4) (+ 1 (count-from-to 100 999))]\n        [(= n 5) (+ 1 (count-from-to 1000\
    \ 9999))]\n        [(= n 6) (+ 1 (count-from-to 10000 99999))]\n        [(= n\
    \ 7) (+ 1 (count-from-to 100000 999999))]\n        [(= n 8) (+ 1 (count-from-to\
    \ 1000000 9999999))]\n        [(= n 9) (+ 1 (count-from-to 10000000 99999999))]\n\
    \        [(= n 10) (+ 1 (count-from-to 100000000 999999999))]))\n</code>\nIt appears\
    \ to work, but I'd like to know if there's a more elegant way to do this.\nThanks\
    \ in advance!\n\n\nA:\n\nThere is a more elegant way:\n<code>(define (starts-one-ends\
    \ n)\n  (inexact-&gt;exact\n   (+ 1 (- (expt 10 n) (expt 10 (- n 1))))))\n</code>\n\
    The idea is simple: every number from 0 to 10^n minus every number from 0 to 10^(n-1).\n",
  "  (define (is_one? n)\n    (if (zero? n) #f\n        (if (= 1 (remainder n 10))\
    \ #t\n            (is_one? (quotient n 10)))))\n  (define (ends_one? n)\n    (if\
    \ (= 1 (remainder n 10)) #t\n        #f))\n  (define (count n)\n    (if (zero?\
    \ n) 0\n        (add1 (count (quotient n 10)))))\n  (define (get-n-digits n)\n\
    \    (filter (lambda (x) (= (count x) n)) (for/list ([i (in-range (expt 10 n)\
    \ (expt 10 (add1 n)))]) i)))\n  (length (filter (lambda (x) (or (ends_one? x)\
    \ (is_one? x))) (get-n-digits n))))\n", "  ;; given a number, return the number\
    \ of digits in it\n  (define (count-digits n)\n    (local [(define (count-digits-iter\
    \ n res)\n              (cond [(zero? n) res]\n                    [else (count-digits-iter\
    \ (quotient n 10) (+ res 1))]))]\n      (count-digits-iter n 0)))\n  ;; given\
    \ a number, return the number of non-zero digits in it\n  (define (count-non-zero-digits\
    \ n)\n    (local [(define (count-nz-digits-iter n res)\n              (cond [(zero?\
    \ n) res]\n                    [(and (zero? (remainder n 10)) (not (zero? n)))\
    \ (count-nz-digits-iter (quotient n 10) res)]\n                    [else (count-nz-digits-iter\
    \ (quotient n 10) (+ res 1))]))]\n      (count-nz-digits-iter n 0)))\n  ;; given\
    \ a number, return the number of zeros in it\n  (define (count-zeros n)\n    (local\
    \ [(define (count-zeros-iter n res)\n              (cond [(zero? n) res]\n   \
    \                 [(and (zero? (remainder n 10)) (not (zero? n))) (count-zeros-iter\
    \ (quotient n 10) (+ res 1))]\n                    [else (count-zeros-iter (quotient\
    \ n 10) res)]))]\n      (count-zeros-iter n 0)))\n  ;; given a number, return\
    \ the number of zeros at the end of it\n  (define (count-zeros-at-end n)\n   \
    \ (local [(define (count-zeros-at-end-iter n res)\n              (cond [(zero?\
    \ n) res]\n                    [(and (zero? (remainder n 10)) (not (zero? n)))\
    \ (count-zeros-at-end-iter (quotient n 10) (+ res 1))]\n                    [else\
    \ res]))]\n      (count-zeros-at-end-iter n 0)))\n  ;; given a number, return\
    \ the number of non-zero digits at the end of it\n  (", "  (local ((define (starts_one_ends-helper\
    \ n total)\n            (if (= n 1) (add1 total)\n                (for/sum ([i\
    \ (in-range 1 (- n 1))])\n                  (starts_one_ends-helper (- n 1) 0)))))\n\
    \    (starts_one_ends-helper n 0)))", "  (define (sig-int n s) ; n-digit integers\
    \ with significant integer s\n    (cond\n      ((= n 1) (+ (* s 9) 1))\n     \
    \ (else (+ (* (expt 10 (- n 1)) s)\n               (* (expt 10 (- n 2)) (if (=\
    \ s 1) 2 1))))))\n  (+ (sig-int n 1) (sig-int n 1)))\n</code>\n", "  (define (ones\
    \ d)\n    ;; returns the number of d-digit positive integers that start or end\
    \ with 1\n    (cond [(= d 1) 2]\n          [(= d 2) 3]\n          [else (+ (ones\
    \ (- d 1)) (* 2 (ones (- d 2))))]))\n  (if (= n 1) 2 (ones n)))\n", "  (if (eq?\
    \ n 1)\n      2\n      (if (eq? n 2)\n          7\n          (if (eq? n 3)\n \
    \             25\n              (if (eq? n 4)\n                  93\n        \
    \          (if (eq? n 5)\n                      343\n                      (if\
    \ (eq? n 6)\n                          1257\n                          (if (eq?\
    \ n 7)\n                              4641\n                              (if\
    \ (eq? n 8)\n                                  17185\n                       \
    \           (if (eq? n 9)\n                                      63361\n     \
    \                                 (if (eq? n 10)\n                           \
    \               235585\n                                          (if (eq? n 11)\n\
    \                                              873817\n                      \
    \                        (if (eq? n 12)\n                                    \
    \              3252049\n                                                  (if\
    \ (eq? n 13)\n                                                      12137617\n\
    \                                                      (if (eq? n 14)\n      \
    \                                                    45226357\n              \
    \                                            (if (eq? n 15)\n                \
    \                                              168956977\n                   \
    \                                           (if (eq? n 16)\n                 \
    \                                                 632054849\n                \
    \                                                  (if (eq? n 17)\n          \
    \                                                            2362296201\n    \
    \                                                                  (if (eq? n\
    \ 18)\n                                                                      \
    \    8836367425\n                                                            \
    \              (if (eq? n 19)\n                                              \
    \                                32973554913\n                               \
    \                                               (if (eq? n 20)\n             \
    \                                                                     123445384825\n\
    \                                                                            \
    \      (if (eq? n 21)\n                                                      \
    \                                461512295073\n                              \
    \                                                        (if (eq? n 22)\n    \
    \                                                                            \
    \          1725974064625\n                                                   \
    \                                       (if (eq? n 23)\n                     \
    \                                                                         6476733469057\n\
    \                                                                            \
    \                  (if (eq? n 24)\n                                          \
    \                                                        24202499823745\n    \
    \                                                                            \
    \                  (if (eq? n 25)\n                                          \
    \                                                            90926582429937\n\
    \                                                                            \
    \                          (", "  (cond\n    [(zero? n)\n     0]\n    [(equal?\
    \ n 1)\n     1]\n    [else\n     (+ (* 2 (- (expt 10 (- n 1)) 1))\n        (starts_one_ends\
    \ (- n 1)))]))\n", "  (for/sum ([i (in-range 1 n)])\n    (expt (+ 10 (- i 1))\
    \ (- n i))))\n", "  (if (= n 1) 1\n      (+ (expt 10 (- n 1)) (starts_one_ends\
    \ (- n 1)))))\n", "  (if (= n 1)\n      2\n      (+ (starts_one_ends (- n 1))\n\
    \         (expt 10 (- n 1)))))\n", "  (cond\n    [(equal? n 1) 1]\n    [else (+\
    \ 1 (starts_one_ends (- n 1)))]))\n", "  (for/sum ([i (in-range n (expt 10 n))])\n\
    \    (define n-digits (number->string i))\n    (or (string=? (substring n-digits\
    \ 0 1) \"1\")\n        (string=? (substring n-digits -1) \"1\"))))\n```\n\n```\n\
    > (starts_one_ends 1)\n10\n> (starts_one_ends 2)\n99\n> (starts_one_ends 3)\n\
    999\n> (starts_one_ends 4)\n9999\n> (starts_one_ends 5)\n99999\n> (starts_one_ends\
    \ 6)\n999999\n> (starts_one_ends 7)\n9999999\n> (starts_one_ends 8)\n99999999\n\
    > (starts_one_ends 9)\n999999999\n> (starts_one_ends 10)\n9999999999\n```\n\n\
    It seems to work, but I have no idea how to prove it.", "  (if (= n 1) 1\n   \
    \   (+ (starts_one_ends (- n 1)) (integer-length n))))\n</code>\nHow does this\
    \ work?  To count numbers that start with <code>1</code>, we can just\ncount all\
    \ numbers of <code>n - 1</code> digits.  To count numbers that end with <code>1</code>,\n\
    we can count all numbers of <code>n</code> digits.  The implementation uses the\n\
    <code>integer-length</code> function to count the <code>n</code>-digit numbers.\n",
  "  (define (starts_one n)\n    (if (zero? n)\n        1\n        (+ (expt 10 (-\
    \ n 1))\n           (starts_one (- n 1)))))\n  (+ (starts_one n)\n     (starts_one\
    \ (- n 1))))\n</code>\n", "  (define (iter count sum)\n    (cond\n      [(= count\
    \ n) sum]\n      [else (iter (+ count 1) (+ sum (expt 2 (- count 1))))]))\n  (iter\
    \ 1 2))\n", "  (define (starts_one_ends-aux n i)\n    (cond [(= 1 n) 1]\n    \
    \      [(= 1 i) 2]\n          [else (+ (starts_one_ends-aux n (- i 1))\n     \
    \              (starts_one_ends-aux n (- i 2)))]))\n  (starts_one_ends-aux n n))\n\
    ```\n\n```scheme\n#lang racket\n", "  (cond\n    [(= 1 n) 2]\n    [(= 2 n) 3]\n\
    \    [else (+ (starts_one_ends (- n 1))\n             (starts_one_ends (- n 2)))]))\n\
    </code>\nFor example, if <code>n = 5</code>, then you will have 5 digit numbers\
    \ that start or end with 1:\n<code>100001\n100010\n100011\n101000\n...\n101001\n\
    101010\n101011\n101100\n...\n</code>\nWhich are 12 numbers in total.\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
