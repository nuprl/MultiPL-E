name: HumanEval_39_prime_fib
language: rkt
prompt: "#lang racket\n\n;; prime_fib returns n-th number that is a Fibonacci number\
  \ and it's also prime.\n;; >>> (prime_fib 1)\n;; 2\n;; >>> (prime_fib 2)\n;; 3\n\
  ;; >>> (prime_fib 3)\n;; 5\n;; >>> (prime_fib 4)\n;; 13\n;; >>> (prime_fib 5)\n\
  ;; 89\n(define (prime_fib n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_fib))\n\
  \    (check-equal? (candidate 1) 2)\n    (check-equal? (candidate 2) 3)\n    (check-equal?\
  \ (candidate 3) 5)\n    (check-equal? (candidate 4) 13)\n    (check-equal? (candidate\
  \ 5) 89)\n    (check-equal? (candidate 6) 233)\n    (check-equal? (candidate 7)\
  \ 1597)\n    (check-equal? (candidate 8) 28657)\n    (check-equal? (candidate 9)\
  \ 514229)\n    (check-equal? (candidate 10) 433494437)\n))\n\n(test-humaneval)"
completions: ["  (if (= n 1)\n      2\n      (fib-prime (+ 1 (prime_fib (- n 1))))))\n",
  "  (let fib ([n n] [curr 0] [next 1])\n    (if (= n 0) curr\n        (if (and (prime?\
    \ curr) (= n 1)) curr\n            (fib (- n 1) next (+ curr next))))))\n", " \
    \ (define (fib n)\n    (if (< n 2)\n        n\n        (+ (fib (- n 1)) (fib (-\
    \ n 2)))))\n  (define (fib-prime-mapper fib)\n    (if (prime? fib)\n        fib\n\
    \        (fib-prime-mapper (+ fib 1))))\n  (fib-prime-mapper (fib n)))\n", " \
    \ (let loop ((i 1) (j 2) (n n))\n    (cond\n      ((= n 0) i)\n      ((and (=\
    \ n 1) (prime? j)) j)\n      ((and (prime? j) (prime? (+ i j))) (loop j (+ i j)\
    \ (- n 1)))\n      (else (loop i (+ i j) n)))))\n", "  (fib (prime-fib-index n)))\n",
  "  (if (= n 1)\n      2\n      (if (= n 2)\n          3\n          (if (= n 3)\n\
    \              5\n              (if (= n 4)\n                  13\n          \
    \        89)))))", "  (let loop ((n n) (i 1) (j 1) (k 0) (count 0))\n    (cond\
    \ ((= count n) k)\n          ((is_prime j) (loop n i (+ i j) j (+ count 1)))\n\
    \          (else (loop n i (+ i j) j count)))))\n", "  (define fibs (make-list\
    \ 10000 0))\n  (set! fibs (list 1 1))\n  (define (prime? x)\n    (if (< x 2)\n\
    \        #f\n        (define (prime? x acc)\n          (if (= acc (* acc acc))\n\
    \              (if (= x (* acc acc))\n                  #f\n                 \
    \ #t)\n              (if (= (% x acc) 0)\n                  #f\n             \
    \     (prime? x (+ acc 1)))))\n        (prime? x 2)))\n  (define (fibs x)\n  \
    \  (if (= (list-ref fibs x) 0)\n        (begin\n          (set! fibs (append fibs\
    \ (list (+ (list-ref fibs (- x 1)) (list-ref fibs (- x 2))))))\n          (fibs\
    \ x))\n        (list-ref fibs x)))\n  (define (prime_fib n acc x)\n    (if (=\
    \ n acc)\n        (list-ref fibs x)\n        (if (prime? (fibs x))\n         \
    \   (prime_fib n (+ acc 1) (+ x 1))\n            (prime_fib n acc (+ x 1)))))\n\
    \  (prime_fib n 0 1))\n", "  (define (fib n)\n    (if (< n 3) 1\n        (+ (fib\
    \ (- n 1)) (fib (- n 2)))))\n  (define (next-prime-fib n i)\n    (if (= n 0) (fib\
    \ i)\n        (if (is-prime? (fib i)) (next-prime-fib (- n 1) (+ i 1))\n     \
    \       (next-prime-fib n (+ i 1)))))\n  (next-prime-fib n 1))\n", "  (cond ((=\
    \ n 1) 2)\n        ((= n 2) 3)\n        (else\n         (nth n (filter is-prime\
    \ (fibonacci-sequence-generator))))))\n", "  (if (is_prime? n) n (prime_fib (+\
    \ n 1))))\n", "  (define fn (fibonacci n))\n  (if (prime? fn)\n      fn\n    \
    \  (prime_fib (+ n 1))))\n", "  (if (zero? n)\n      0\n      (if (= n 1)\n  \
    \        2\n          (if (= n 2)\n              3\n              (if (= n 3)\n\
    \                  5\n                  (if (= n 4)\n                      13\n\
    \                      (if (= n 5)\n                          89\n           \
    \               (fibonacci_and_prime (add1 n) 0 0))))))))\n", "  (let loop ((fibs\
    \ (list 2 3 5)))\n    (if (<= (length fibs) n)\n        (loop (cons (fib (length\
    \ fibs)) fibs))\n        (car (for/fold ([prime_fibs '()]) ([fib (in-list fibs)])\n\
    \                (if (prime? fib)\n                    (cons fib prime_fibs)\n\
    \                    prime_fibs)))\n        )))\n", "  (define (is_prime? n)\n\
    \    (let ((factors (filter (lambda (x) (= (remainder n x) 0)) (range 2 n))))\n\
    \      (= (length factors) 0)))\n  (define (prime_fib_helper n fib1 fib2 fib_index)\n\
    \    (if (= n fib_index)\n        fib1\n        (if (and (is_prime? fib2) (= (modulo\
    \ fib_index 2) 0))\n            (prime_fib_helper n fib2 (+ fib1 fib2) (+ fib_index\
    \ 1))\n            (prime_fib_helper n fib1 (+ fib1 fib2) (+ fib_index 1)))))\n\
    \  (if (= n 1)\n      2\n      (prime_fib_helper n 1 2 2)))\n", "  (prime_fib_iter\
    \ 1 2 3 n))\n", "  (define (helper k f1 f2)\n    (if (zero? n) f1\n        (if\
    \ (equal? k n) f2\n            (if (prime? f2) (helper (+ k 1) f2 (+ f1 f2))\n\
    \                (helper k f2 (+ f1 f2))))))\n  (helper 0 0 1))\n", "  (cond\n\
    \    [(= n 1)\n     2]\n    [(= n 2)\n     3]\n    [else\n     (let loop ([a 2]\
    \ [b 3] [x 3])\n       (if (= x n)\n           b\n           (loop b (+ a b) (+\
    \ x 1))))]))\n", "  (define (is-prime n)\n    (not (or\n          (= n 1)\n  \
    \        (or\n           (zero? (modulo n 2))\n           (or\n            (zero?\
    \ (modulo n 3))\n            (or\n             (zero? (modulo n 5))\n        \
    \     (or\n              (zero? (modulo n 7))\n              (or\n           \
    \    (zero? (modulo n 11))\n               (zero? (modulo n 13))))))))))\n  (define\
    \ (fib n)\n    (if (< n 2)\n        n\n        (+ (fib (- n 1)) (fib (- n 2)))))\n\
    \  (define (prime-fib n i)\n    (if (= n i)\n        0\n        (if (is-prime\
    \ (fib i))\n            (prime-fib n (add1 i))\n            (fib i))))\n  (prime-fib\
    \ n 1))\n", "  (cond ((= n 1) 2)\n        ((= n 2) 3)\n        (else (let loop\
    \ ([i 3] [counter 2] [cur_num 5] [cur_num_1 3] [cur_num_2 2])\n              \
    \  (cond ((= counter n) cur_num)\n                      ((or (zero? (modulo cur_num\
    \ 2)) (zero? (modulo cur_num 3)) (zero? (modulo cur_num 5))) (loop (+ i 1) counter\
    \ (+ cur_num cur_num_1) cur_num cur_num_1))\n                      (else (loop\
    \ (+ i 1) (+ counter 1) (+ cur_num cur_num_1) cur_num cur_num_1)))))))\n", " \
    \ (let ((fibs (list 1 1)))\n    (let loop ([i 1] [j 0])\n      (let ([f (+ (list-ref\
    \ fibs j) (list-ref fibs (+ j 1)))])\n        (cond\n          [(= i n) f]\n \
    \         [(prime? f) (begin\n                        (set! fibs (append fibs\
    \ (list f)))\n                        (loop (+ i 1) (+ j 1)))]\n          [else\
    \ (loop i (+ j 1))])))))\n", "  (prime_fib_iter 0 0 1 n))\n", "  (let ([counter\
    \ (fib 1 1 0 0)])\n    (define (iter a b i)\n      (if (= i n) b\n          (if\
    \ (prime? (+ a b)) (iter b (+ a b) (+ i 1)) (iter b (+ a b) i))))\n    (iter 0\
    \ 1 0)))\n", "  (define fibs\n    (cons 1 (cons 1 (map + fibs (cdr fibs)))))\n\
    \  (define primes\n    (let ([s (stream-filter prime? (in-naturals 2))])\n   \
    \   (stream-take n s)))\n  (define (fibonacci i)\n    (stream-ref fibs i))\n \
    \ (define (prime i)\n    (stream-ref primes i))\n  (define (prime_fibonacci i)\n\
    \    (if (equal? i 0)\n        (prime i)\n        (if (equal? (fibonacci i) (prime\
    \ i))\n            (prime_fibonacci (sub1 i))\n            (prime_fibonacci i))))\n\
    \  (prime_fibonacci n))\n", "  (if (eq? n 1)\n      2\n      (prime_fib_helper\
    \ n 1 1 2)))\n", "  (fib (find-1st-nth-prime n)))\n", "  (let ([f (fib n)])\n\
    \    (cond [(= f 2)\n           2]\n          [(prime? f)\n           f]\n   \
    \       [else\n           (prime_fib (- n 1))])))\n", "  (list-ref (filter prime?\
    \ fibs) (sub1 n)))\n", "  (prime_fib-recur n 2 1 0 0))\n", "  (cond ((= n 1) 2)\n\
    \        ((= n 2) 3)\n        (else (let fib_help ([i 3] [x 1] [y 1] [z 0] [cnt\
    \ 2])\n                (cond ((= cnt n) z)\n                      ((is_prime z)\
    \ (fib_help (+ i 1) y z (+ x y) (+ cnt 1)))\n                      (else (fib_help\
    \ (+ i 1) y z (+ x y) cnt)))))))\n", "  (let loop ((n n) (fib (list 1 1)) (i 0))\n\
    \    (cond ((= n 0) (error \"n can't be 0.\"))\n          ((= n 1) (car fib))\n\
    \          ((= n 2) (cadr fib))\n          ((= n (+ i 2)) (car fib))\n       \
    \   (else (loop n (n-th-prime-fib (+ n 2) fib i) (+ i 1))))))\n", "  (if (= n\
    \ 1)\n      2\n      (cond\n        [(= n 2) 3]\n        [(= n 3) 5]\n       \
    \ [(= n 4) 13]\n        [(= n 5) 89]\n        [else (prime_fib_helper n 5 2 (+\
    \ 1 (* 5 5)) 0)])))\n", "  (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [else\n\
    \     (let ([counter 2]\n           [current-fib 0]\n           [next-fib 1])\n\
    \       (let loop ([i 3])\n         (set! current-fib next-fib)\n         (set!\
    \ next-fib (+ current-fib (loop (add1 i))))\n         (cond\n           [(= i\
    \ n) next-fib]\n           [(prime? next-fib)\n            (set! counter (add1\
    \ counter))\n            (cond\n              [(= counter n) next-fib]\n     \
    \         [else (loop (add1 i))])]\n           [else (loop (add1 i))])))]))\n",
  "  (if (zero? n)\n      0\n      (do ([prime-fibs (in-naturals)\n           (filter\
    \ is-prime prime-fibs)])\n          ((>= n (length prime-fibs))\n           (list-ref\
    \ prime-fibs (sub1 n)))\n        (define (is-prime n)\n          (is-prime? n))\n\
    \        (define (in-naturals)\n          (letrec ([in-naturals (lambda ()\n \
    \                                 (cons 0 (cons 1 (map + (in-naturals) (rest (in-naturals))))))])\n\
    \            (in-naturals)))\n        (define (is-prime? n)\n          (letrec\
    \ ([is-prime? (lambda (n nums)\n                                (if (zero? (modulo\
    \ n (first nums)))\n                                    #f\n                 \
    \                   (if (< (sqr (first nums)) n)\n                           \
    \             (is-prime? n (rest nums))\n                                    \
    \    #t)))])\n            (is-prime? n (in-range 2 n))))\n        (define (in-range\
    \ n m)\n          (if (> n m)\n              '()\n              (cons n (in-range\
    \ (add1 n) m)))))))\n", "  (if (zero? n)\n      2\n      (let loop ([a 2] [b 3]\
    \ [i 2])\n        (cond\n          [(= i n) a]\n          [(and (prime? b) (fib?\
    \ b)) (loop b (+ a b) (+ i 1))]\n          [else (loop a (+ a b) i)]))))\n", " \
    \ (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [else (prime_fib_helper n 3 2 1\
    \ 0)]))\n", "  (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [else (prime_fib-h\
    \ 3 2 3 5 0 n)]))\n", "  (define (prime-fib-iter current_n current_prime_fib)\n\
    \    (cond ((> current_n n) current_prime_fib)\n          ((and (is-prime? current_prime_fib)\n\
    \                (is-fib? current_prime_fib))\n           (prime-fib-iter (+ current_n\
    \ 1) (+ current_prime_fib 1)))\n          (else (prime-fib-iter current_n (+ current_prime_fib\
    \ 1)))))\n  (prime-fib-iter 1 1))\n", "  (define (prime? n)\n    (define (iter\
    \ k)\n      (cond ((< n (* k k)) #t)\n            ((= (remainder n k) 0) #f)\n\
    \            (else (iter (+ k 1)))))\n    (cond ((= n 2) #t)\n          ((even?\
    \ n) #f)\n          (else (iter 3))))\n  (define (fib n)\n    (cond ((= n 1) 1)\n\
    \          ((= n 2) 1)\n          (else (+ (fib (- n 1)) (fib (- n 2))))))\n \
    \ (define (iter k n)\n    (cond ((= k n) (fib k))\n          ((prime? (fib k))\
    \ (iter (+ k 1) n))\n          (else (iter (+ k 1) n))))\n  (iter 1 n))\n", " \
    \ (define (prime_fib-iter n i fn fn2)\n    (cond\n      ((= n 1) (if (prime? fn)\
    \ fn (prime_fib-iter n (- i 1) fn2 (- fn fn2))))\n      ((= n 2) (if (prime? fn2)\
    \ fn2 (prime_fib-iter n (- i 1) fn2 (- fn fn2))))\n      ((<= n i) (if (prime?\
    \ fn) fn (prime_fib-iter n (- i 1) fn2 (- fn fn2))))\n      (else (prime_fib-iter\
    \ n (+ i 2) (+ (* 2 fn) fn2) fn))))\n  (prime_fib-iter n 3 2 1))\n", "  (cond\
    \ [(= n 1) 2]\n        [(= n 2) 3]\n        [else (fib-prime-rec 1 2 3 1 2) ]))\n",
  "  (fib_number (nth-prime n)))\n", "  (if (= n 1)\n      2\n      (let loop ([a\
    \ 1] [b 2] [c 3] [n (- n 2)])\n        (if (= n 0)\n            c\n          \
    \  (if (prime? c)\n                (loop b c (+ b c) (- n 1))\n              \
    \  (loop b c (+ b c) n))))))\n", "  (cond\n    [(<= n 0) (error \"invalid n\"\
    )]\n    [(<= n 3) 2]\n    [else (let loop ((i 1) (fn-2 1) (fn-1 2) (fn 2))\n \
    \            (cond\n               [(= i n) fn]\n               [(and (integer?\
    \ fn)\n                     (integer? fn-1)\n                     (integer? fn-2)\n\
    \                     (or (integer? (/ (+ fn-2 fn-1) fn)))\n                 \
    \    (prime? fn))\n                (loop (+ i 1) fn-1 fn fn)]\n              \
    \ [else (loop (+ i 1) fn-1 fn (+ fn-2 fn-1))]))]))\n", "  (list-ref\n   (filter\
    \ prime? (take n fib))\n   (- n 1)))\n", "  (list-ref (filter prime? (fib_seq))\
    \ (- n 1)))\n", "  (cond ((= n 1) 2)\n        ((= n 2) 3)\n        (else (first\
    \ (filter (\u03BB (f) (prime? f)) (fibonacci n))))))\n", "  (define (prime_p n)\n\
    \    (define (prime-iter n x)\n      (cond ((= x 1) true)\n            ((= (%\
    \ n x) 0) false)\n            (else (prime-iter n (- x 1)))))\n    (prime-iter\
    \ n (- n 1)))\n  (define (fibonacci n)\n    (cond ((= n 1) 1)\n          ((= n\
    \ 2) 1)\n          (else (+ (fibonacci (- n 1)) (fibonacci (- n 2))))))\n  (define\
    \ (fib-iter x fib)\n    (cond ((= x n) fib)\n          ((= (prime_p fib) true)\
    \ (fib-iter (+ x 1) (fibonacci (+ x 1))))\n          (else (fib-iter (+ x 1) (fibonacci\
    \ (+ x 1))))))\n  (fib-iter 1 1))\n", "  (define (prime? x)\n    (define (prime?-helper\
    \ x d)\n      (cond\n        [(= d 1) #t]\n        [(= (modulo x d) 0) #f]\n \
    \       [else (prime?-helper x (- d 1))]))\n    (prime?-helper x (floor (/ x 2))))\n\
    \  (define (fibonacci n)\n    (define (helper a b n)\n      (cond\n        [(=\
    \ n 0) a]\n        [else (helper b (+ a b) (- n 1))]))\n    (helper 0 1 n))\n\
    \  (define (fibonacci-prime n a)\n    (cond\n      [(= n 0) a]\n      [(prime?\
    \ a) (fibonacci-prime (- n 1) (fibonacci (+ n 1)))]\n      [else (fibonacci-prime\
    \ n (fibonacci (+ n 1)))]))\n  (fibonacci-prime n (fibonacci 0)))\n```\n\n###\
    \ 17.2\n\n```racket\n#lang racket\n", "  (define (prime-fib-aux n k a b)\n   \
    \ (if (= n k) b\n      (let ((next-fib (+ a b)))\n        (if (and (prime? next-fib)\
    \ (= n k)) next-fib\n          (prime-fib-aux n (+ k 1) b next-fib)))))\n  (prime-fib-aux\
    \ n 0 2 1))\n", "  (define (prime-fib-iter a b count)\n    (cond\n      ((and\
    \ (<= count n) (prime? b))\n       (prime-fib-iter b (+ a b) (+ count 1)))\n \
    \     ((<= count n)\n       (prime-fib-iter b (+ a b) count))\n      (else\n \
    \      b)))\n  (prime-fib-iter 0 1 1))\n", "  (define (stream-fib s)\n    (let\
    \ ((fib-tail (rest s)))\n      (cons (stream-add (first s) (first fib-tail))\n\
    \            (stream-fib fib-tail))))\n  (define (stream-add a b)\n    (+ a b))\n\
    \  (define fib-stream\n    (cons 1 (cons 1 (stream-fib fib-stream))))\n  (define\
    \ (prime? n)\n    (define (divisible? a b)\n      (= (modulo a b) 0))\n    (define\
    \ (find-divisor n test-divisor)\n      (cond ((> (square test-divisor) n) n)\n\
    \            ((divisible? n test-divisor) test-divisor)\n            (else (find-divisor\
    \ n (+ test-divisor 1)))))\n    (= (find-divisor n 2) n))\n  (define (nth-prime-fib\
    \ n s)\n    (if (prime? (first s))\n        (if (= 1 n)\n            (first s)\n\
    \            (nth-prime-fib (- n 1) (rest s)))\n        (nth-prime-fib n (rest\
    \ s))))\n  (nth-prime-fib n fib-stream))\n", "  (define (is-prime? n)\n    (let\
    \ loop ((divisor n))\n      (if (= 1 divisor)\n          #t\n          (if (zero?\
    \ (modulo n divisor))\n              #f\n              (loop (- divisor 1))))))\n\
    \  (define (prime-fib n)\n    (define (fib n)\n      (if (= n 0)\n          0\n\
    \          (if (= n 1)\n              1\n              (+ (fib (- n 1)) (fib (-\
    \ n 2))))))\n    (define (fib-seq n)\n      (cond ((= n 0) (list))\n         \
    \   ((= n 1) (list 0))\n            ((= n 2) (list 0 1))\n            (else (append\
    \ (fib-seq (- n 1)) (list (fib (- n 1)))))))\n    (define (prime-fib-seq n)\n\
    \      (let loop ((n n) (seq (fib-seq n)))\n        (if (= n 0)\n            seq\n\
    \            (if (is-prime? (first seq))\n                (loop (- n 1) seq)\n\
    \                (loop (- n 1) (rest seq))))))\n    (list-ref (prime-fib-seq n)\
    \ (- n 1)))\n  (prime-fib n))\n```\n\n## 8. Tests\n\n![](https://github.com/kostik23rus/prolog-examples/blob/master/images/tests.png)",
  "  (if (< n 1)\n      (error \"input must be a positive integer.\")\n      (prime_fib_helper\
    \ n 1 0 1 1)))\n", "  (let loop ((i 1) (k 0) (a 1) (b 1))\n    (if (= i n) b\n\
    \        (if (and (prime? b) (= k 1))\n            (loop (+ i 1) 0 b (+ a b))\n\
    \            (loop i (add1 k) b (+ a b))))))\n", "  (let f ([i n] [a 1] [b 1])\n\
    \    (cond [(= i 1) b]\n          [(and (fib? a) (prime? a)) (f (- i 1) b a)]\n\
    \          [else (f (- i 1) b a)])))\n", "  (define prime-fibs (build-list (lambda\
    \ (x) (is-prime (fib x))) 1000))\n  (first (keep prime-fibs (lambda (x) (= n (count\
    \ x prime-fibs))))))\n", "  (define (fib n)\n    (cond ((= n 1) 1)\n         \
    \ ((= n 2) 1)\n          (else (+ (fib (- n 1)) (fib (- n 2))))))\n  (define (is_prime\
    \ n)\n    (define (iter d)\n      (cond ((= d 1) #t)\n            ((integer? (/\
    \ n d)) #f)\n            (else (iter (- d 1)))))\n    (iter (- n 1)))\n  (define\
    \ (iter i)\n    (cond ((= i n) #f)\n          ((is_prime (fib i)) (fib i))\n \
    \         (else (iter (+ i 1)))))\n  (iter 1))\n", "  (first (list-ref (filter\
    \ (lambda (f) (prime? f))\n                            (map fibonacci (build-list\
    \ (add1 n)\n                                                       (lambda (i)\
    \ i))))\n                  (- n 1))))\n", "  (define (prime? x)\n    (define (helper\
    \ n)\n      (cond ((= n 1) #t)\n            ((= (remainder x n) 0) #f)\n     \
    \       (else (helper (- n 1)))))\n    (if (= x 1) #f (helper (- x 1))))\n  (define\
    \ (fib i)\n    (if (= i 1) 1\n        (if (= i 2) 1\n            (+ (fib (- i\
    \ 1)) (fib (- i 2))))))\n  (define (helper2 i)\n    (if (= i n) (fib i)\n    \
    \    (if (prime? (fib i)) (helper2 (+ i 1))\n            (helper2 (+ i 1)))))\n\
    \  (helper2 1))\n```\n\n#### Problem 15.\n\n```#lang racket\n", "  (cond ((= n\
    \ 1) 2)\n        ((= n 2) 3)\n        (else (loop [next_fib 1\n              \
    \       a 2\n                     b 3\n                     c (+ a b)\n      \
    \               count 3]\n                 (cond ((and (prime? c) (= count n))\
    \ c)\n                       (else (recur (+ next_fib c) b c (+ a b) (+ count\
    \ 1))))))))\n", "  (define (my-fib-iter a b counter)\n    (if (= counter 0) a\n\
    \        (if (is_prime b) (my-fib-iter b (+ a b) (- counter 1))\n            (my-fib-iter\
    \ a (+ a b) counter))))\n  (my-fib-iter 1 1 n))\n```\n\n# Exercise 6\n```", " \
    \ (define (fib-helper a b count)\n    (if (= count n)\n        b\n        (if\
    \ (and (prime? b) (= count (+ n 1)))\n            b\n            (fib-helper b\
    \ (+ a b) (+ count 1)))))\n  (fib-helper 0 1 1))\n", "  (let loop ((a 0) (b 1)\
    \ (i 1))\n    (if (= i n)\n        b\n        (if (and (prime? (+ a b)) (prime?\
    \ b))\n            (loop b (+ a b) (+ i 1))\n            (loop b (+ a b) i)))))\n",
  "  (let loop ((i 1) (index 0) (fib1 0) (fib2 1))\n    (cond\n      ((> index n)\
    \ fib1)\n      ((and (is_prime i) (eq? fib1 i)) (loop (+ i 1) (+ index 1) fib2\
    \ i))\n      (else (loop (+ i 1) index fib2 fib1)))))\n", "  (cond\n    ((= n\
    \ 1) 2)\n    ((= n 2) 3)\n    (else (let* ([n1 (prime_fib (- n 1))]\n        \
    \        [n2 (prime_fib (- n 2))])\n            (let recur ([k 0])\n         \
    \     (if (and (prime? (+ n1 n2)) (fib? (+ n1 n2)))\n                  (+ n1 n2)\n\
    \                  (recur (+ k 1))))))))\n", "  (define (fib-iter a b count)\n\
    \    (if (and (> count 0) (= count n)) b\n        (if (and (not (even? b)) (is_prime\
    \ b))\n            (fib-iter b (+ a b) (+ count 1))\n            (fib-iter b (+\
    \ a b) count))))\n  (fib-iter 1 2 1))\n", "  (cond ((< n 1) 0)\n        ((= n\
    \ 1) 2)\n        ((= n 2) 3)\n        (else\n         (let ((fib1 2)\n       \
    \        (fib2 3)\n               (count 3)\n               (curr 0))\n      \
    \     (begin\n             (while (< count n)\n               (set! curr (+ fib1\
    \ fib2))\n               (set! fib1 fib2)\n               (set! fib2 curr)\n \
    \              (set! count (+ count 1)))\n             (cond ((= (mod fib2 2)\
    \ 0) (prime_fib (- n 1)))\n                   (else fib2)))))))\n", "  (letrec\
    \ ([fib-rec (lambda (num acc)\n                      (if (= num n)\n         \
    \                 acc\n                          (if (prime? (car acc))\n    \
    \                          (fib-rec (+ num 1) (cons (+ (car acc) (cadr acc)) acc))\n\
    \                              (fib-rec num (cons (+ (car acc) (cadr acc)) acc)))))])\n\
    \    (fib-rec 0 '(0 1))))\n\n", "  (cond ((= n 1) 2)\n        ((= n 2) 3)\n  \
    \      (else (helper 3 2 3 1 2 3 n))))\n", "  (check-expect (prime_fib 1) 2)\n\
    \  (check-expect (prime_fib 2) 3)\n  (check-expect (prime_fib 3) 5)\n  (check-expect\
    \ (prime_fib 4) 13)\n  (check-expect (prime_fib 5) 89)\n  (if (= n 1)\n      2\n\
    \      (if (= n 2)\n          3\n          (for/first ((x (in-range 2 (+ 1 (+\
    \ 1 (fib n))) 1))\n                     #:when (prime? x))\n            (cond\
    \ ((fib? x) x)) ))))\n", "  (require math/number-theory)\n  (cond\n    [(= n 1)\n\
    \     2]\n    [(= n 2)\n     3]\n    [else\n     (define (fib-iter a b p n)\n\
    \       (cond\n         [(prime? p)\n          (if (= n 1)\n              p\n\
    \              (fib-iter b (+ a b) (+ a b) (- n 1)))]\n         [else\n      \
    \    (fib-iter b (+ a b) (+ a b) n)]))\n     (fib-iter 1 2 3 (- n 2))]))\n", " \
    \ (if (= n 1)\n      2\n      (next-prime-fib (cons 1 1) 0 (+ n 1))))\n", "  (fib\
    \ (prime_fib_index n)))\n", "  (cond\n    ((= n 1) 2)\n    ((= n 2) 3)\n    (else\
    \ (letrec ([fib-numbers (list 0 1)]\n                   [prime_fib (lambda (n\
    \ fib-numbers)\n                                (if (= n 1)\n                \
    \                    (list-ref fib-numbers 1)\n                              \
    \      (let ([fib-number (fib (n -1) fib-numbers)])\n                        \
    \              (if (prime? fib-number)\n                                     \
    \     fib-number\n                                          (prime_fib (n -1)\
    \ (append fib-numbers (list fib-number)))))))]\n                   [fib (lambda\
    \ (n fib-numbers)\n                          (if (= n 0)\n                   \
    \           (list-ref fib-numbers 0)\n                              (let ([fib-number\
    \ (fib (n -1) fib-numbers)])\n                                (+ (list-ref fib-numbers\
    \ (- n 1)) fib-number))))])\n             (prime_fib n fib-numbers))))))\n", " \
    \ (define (fib n)\n    (cond ((< n 1) 0)\n          ((= n 1) 1)\n          (else\
    \ (+ (fib (- n 1)) (fib (- n 2))))))\n  (define (is_prime n)\n    (define (divisible?\
    \ n d)\n      (= (remainder n d) 0))\n    (define (find-divisor n test-divisor)\n\
    \      (cond ((> (* test-divisor test-divisor) n) n)\n            ((divisible?\
    \ n test-divisor) test-divisor)\n            (else (find-divisor n (+ test-divisor\
    \ 1)))))\n    (= (find-divisor n 2) n))\n  (define (prime_fib_iter n fib_number)\n\
    \    (cond ((= n 1) fib_number)\n          ((is_prime fib_number) (prime_fib_iter\
    \ (- n 1) (+ fib_number (fib (- n 2)))))\n          (else (prime_fib_iter n (+\
    \ fib_number (fib (- n 2)))))))\n  (prime_fib_iter n (fib (- n 2))))\n", "  (let\
    \ loop ((count 1) (last 0) (last2 1))\n    (cond\n      ((= count n) last)\n \
    \     ((= count 1) (loop (+ count 1) 1 0))\n      ((= count 2) (loop (+ count\
    \ 1) 1 1))\n      (else\n       (let ((fib (+ last last2)))\n         (if (prime?\
    \ fib)\n             (loop (+ count 1) fib last)\n             (loop count fib\
    \ last)))))))\n", "  (let loop ((a 1) (b 1) (counter 1))\n    (if (= counter n)\n\
    \        b\n        (if (and (is_prime? b) (is_fib? b))\n            (loop b (+\
    \ a b) (+ counter 1))\n            (loop b (+ a b) counter)))))\n", "  (define\
    \ (helper acc count)\n    (cond ((= count n) (car acc))\n          ((and (fib?\
    \ (car acc)) (prime? (car acc))) (helper (cdr acc) (+ count 1)))\n          (else\
    \ (helper (cdr acc) count))))\n  (helper (fibs) 1))\n", "  (define (is_prime x)\n\
    \    (cond\n      [(< x 2) #f]\n      [(= x 2) #t]\n      [(= (remainder x 2)\
    \ 0) #f]\n      [else\n       (define (iter y)\n         (cond\n           [(>\
    \ y (sqrt x)) #t]\n           [(= (remainder x y) 0) #f]\n           [else (iter\
    \ (+ y 1))]))\n       (iter 3)]))\n  (define (iter x fib1 fib2 count)\n    (cond\n\
    \      [(= count n) fib2]\n      [(is_prime fib2) (iter (+ x 1) fib2 (+ fib1 fib2)\
    \ (+ count 1))]\n      [else (iter (+ x 1) fib2 (+ fib1 fib2) count)]))\n  (iter\
    \ 2 2 1 1))", "  (define (pf_helper k)\n    (if (= k n)\n        (list-ref fibonacci-seq\
    \ (dec (length fibonacci-seq)))\n        (if (and (prime? (list-ref fibonacci-seq\
    \ k)) (prime? (list-ref fibonacci-seq (inc k))))\n            (pf_helper (inc\
    \ k))\n            (pf_helper (inc k)))))\n  (pf_helper 0))\n```\n\n```racket\n\
    #lang racket\n", "  (let loop ((i 1) (j 2) (k 1) (count 1))\n    (cond ((= n count)\
    \ k)\n          ((prime? j) (loop j (+ i j) i (+ count 1)))\n          (else (loop\
    \ j (+ i j) k count)))))\n", "  (define (is-prime? n)\n    (define (iter m)\n\
    \      (cond ((< m n) (and (not (zero? (modulo n m))) (iter (+ m 1))))\n     \
    \       (else #t)))\n    (iter 2))\n  (define (iter m f1 f2)\n    (cond ((= m\
    \ n) (if (is-prime? f1) f1 (iter m f2 f1)))\n          (else (iter (+ m 1) f2\
    \ (+ f1 f2)))))\n  (cond ((= n 1) 2)\n        (else (iter 2 1 2))))", "  (cond\
    \ [(eq? n 1) 2]\n        [(eq? n 2) 3]\n        [else (let ([a (prime_fib (- n\
    \ 1))]\n                     [b (prime_fib (- n 2))])\n                (if (and\
    \ (is-prime? (+ a b)) (is-prime? (+ (* 2 a) b)))\n                    (+ a b)\n\
    \                    (+ (* 2 a) b)))]))\n", "  (define (pfib n fib1 fib2 count)\n\
    \    (if (= n count)\n      fib2\n      (if (and (= (mod fib2 10) 3) (= (mod fib2\
    \ 10) 7))\n        (pfib n fib2 (+ fib1 fib2) (+ count 1))\n        (pfib n fib2\
    \ (+ fib1 fib2) count))))\n  (pfib n 1 1 1))\n", "  (define (fib-helper (a b p))\n\
    \    (if (= p n)\n        a\n        (if (prime? b)\n            (fib-helper b\
    \ (+ a b) (+ p 1))\n            (fib-helper a (+ a b) p))))\n  (fib-helper 2 3\
    \ 1))\n", "  (letrec ((prime_fibs (stream-filter\n                        (lambda\
    \ (s)\n                          (and (is-prime? s)\n                        \
    \       (fib-number? s)))\n                        (integers-starting-from 2))))\n\
    \    (stream-ref prime_fibs (- n 1))))\n", "  (define (prime? n)\n    (define\
    \ (helper divisor)\n      (cond ((<= divisor 1) #t)\n            ((zero? (modulo\
    \ n divisor)) #f)\n            (else (helper (- divisor 1)))))\n    (helper (-\
    \ n 1)))\n  (define (fib_helper n fib1 fib2)\n    (cond ((= n 1) fib1)\n     \
    \     ((= n 2) fib2)\n          (else (fib_helper (- n 1) fib2 (+ fib1 fib2)))))\n\
    \  (define (fib n)\n    (fib_helper n 1 1))\n  (define (find n count)\n    (cond\
    \ ((= n count) (find n (+ count 1)))\n          ((prime? (fib n)) (fib n))\n \
    \         (else (find n (+ count 1)))))\n  (find n 1))\n", "  (let* ((fibs (fibonacci-numbers\
    \ 1000000))\n         (primes (take fibs (primes 1000000)))\n         (prime-fibs\
    \ (filter (lambda (x)\n                               (member x primes))\n   \
    \                          fibs)))\n    (list-ref prime-fibs (- n 1))))\n", " \
    \ (define (fib n fib1 fib2)\n    (if (= n 1) fib1\n        (fib (- n 1) fib2 (+\
    \ fib1 fib2))))\n  (define (is_prime? n)\n    (cond ((= n 1) #f)\n          ((=\
    \ n 2) #t)\n          ((= n 3) #t)\n          ((= n 5) #t)\n          ((= n 7)\
    \ #t)\n          ((even? n) #f)\n          (else (define (sqrt-iter guess x)\n\
    \                   (if (good-enough? guess x)\n                       guess\n\
    \                       (sqrt-iter (improve guess x) x)))\n               (define\
    \ (improve guess x)\n                 (average guess (/ x guess)))\n         \
    \      (define (average x y)\n                 (/ (+ x y) 2))\n              \
    \ (define (good-enough? guess x)\n                 (< (abs (- (square guess) x))\
    \ 0.001))\n               (define (square x) (* x x))\n               (define\
    \ sqrt (lambda (x) (sqrt-iter 1.0 x)))\n               (let loop ((d (+ n 1))\
    \ (t #t))\n                 (if (or (= n 2) (= n 3) (= n 5) (= n 7))\n       \
    \              #t\n                     (if (zero? (modulo n d))\n           \
    \              #f\n                         (if (> (sqrt n) d)\n             \
    \                #t\n                             (loop (+ d 2) t))))))))\n  (define\
    \ (prime_fib-iter n i fib1 fib2)\n    (if (= n i)\n        fib1\n        (if (and\
    \ (is_prime? fib1) (is_prime? fib2))\n            (prime_fib-iter n (+ i 1) fib2\
    \ (+ fib1 fib2))\n            (prime_fib-iter n (+ i 1) fib2 (+ fib1 fib2)))))\n\
    \  (prime_fib-iter n 1 2 3))\n", "  (define fibs (list 0 1))\n  (define nth-prime-fib\
    \ 0)\n  (for ([i (in-range n)])\n    (set! fibs (list (list-ref fibs 1) (+ (list-ref\
    \ fibs 0) (list-ref fibs 1))))\n    (define nth-fib (list-ref fibs 1))\n    (when\
    \ (prime? nth-fib)\n      (set! nth-prime-fib nth-fib)))\n  nth-prime-fib)\n",
  "  (nth n\n       (filter prime?\n               (fibs))))\n", "  (if (= n 1)\n\
    \      2\n      (if (= n 2)\n          3\n          (let loop ([n n] [i 0] [fib1\
    \ 2] [fib2 3])\n            (if (= i n)\n                fib2\n              \
    \  (if (is_prime fib2)\n                    (loop (- n 1) (+ i 1) fib2 (+ fib1\
    \ fib2))\n                    (loop n (+ i 1) fib2 (+ fib1 fib2))))))))\n", " \
    \ (define (fib n)\n    (if (< n 2) n\n      (+ (fib (- n 1)) (fib (- n 2)))))\n\
    \  (define (prime? n)\n    (define (prime? n i)\n      (cond ((= i 1) #t)\n  \
    \          ((= (modulo n i) 0) #f)\n            (else (prime? n (- i 1)))))\n\
    \    (prime? n (floor (sqrt n))))\n  (define (prime_fib n i)\n    (if (> i n)\
    \ (prime_fib n 0)\n      (if (prime? (fib i)) (fib i) (prime_fib n (+ i 1)))))\n\
    \  (prime_fib n 0))\n", "  (local [(define (from i)\n            (if (zero? (remainder\
    \ i n)) i (from (+ i 1))))]\n    (from n)))\n", "  (cond\n    ((= n 1) 2)\n  \
    \  ((= n 2) 3)\n    (else\n      (let loop ([i 3] [j 2] [k 1] [cnt 2])\n     \
    \   (cond\n          ((= cnt n) i)\n          (else\n            (loop (+ i j)\
    \ i (- k j) (+ cnt 1))))))))\n", "  (define (helper next n)\n    (if (= n 1)\n\
    \        next\n        (if (and (= (remainder next 2) 1) (prime? next))\n    \
    \        (helper (fib (+ n 1)) n)\n            (helper (fib (+ n 1)) n))))\n \
    \ (if (= n 1)\n      2\n      (helper 3 n)))\n", "  (cond\n    [(zero? n) 0]\n\
    \    [(= n 1) 2]\n    [(= n 2) 3]\n    [else\n     (let loop ((i 1) (j 2) (k 3)\
    \ (count 3))\n       (if (= count n) k\n           (loop (+ i j) i (- k j) (+\
    \ count 1))))]))\n", "  (define (is-prime n)\n    (cond ((= n 1) #f)\n       \
    \   ((= n 2) #t)\n          ((even? n) #f)\n          (else\n           (let loop\
    \ ((i 3))\n             (cond ((= (remainder n i) 0) #f)\n                   ((=\
    \ i (floor (sqrt n))) #t)\n                   (else (loop (+ i 2))))))))\n  (define\
    \ (fib n)\n    (cond ((= n 1) 1)\n          ((= n 2) 1)\n          (else (+ (fib\
    \ (- n 1)) (fib (- n 2))))))\n  (let loop ((i 0) (n 1))\n    (cond ((> i n) n)\n\
    \          ((is-prime (fib n)) (loop i n))\n          (else (loop (+ i 1) (+ n\
    \ 1))))))", "  (define fib_pairs (list (cons 1 1) (cons 2 1)))\n  (define (find_prime_fib\
    \ j k)\n    (define (next)\n      (if (and (prime? j) (= (% k 2) 0))\n       \
    \   (cons j k)\n          (cons 0 0)))\n    (if (= n k)\n        j\n        (find_prime_fib\
    \ (car (next)) (+ k (cdr (next))))))\n  (if (= n 1)\n      2\n      (find_prime_fib\
    \ 1 2)))", "  (letrec ([fibs (for/list ([i (in-range (add1 n))])\n           \
    \            (if (< 1 i 2)\n                           1\n                   \
    \        (add (list-ref fibs (- i 1))\n                                (list-ref\
    \ fibs (- i 2)))))]\n           [prime-fibs (for/list ([fib (in-list fibs)])\n\
    \                             (if (prime? fib)\n                             \
    \    fib\n                                 '()))])\n    (list-ref prime-fibs (-\
    \ n 1))))", "  (define (fibs)\n    (let loop ((n1 1) (n2 2))\n      (cons n1 (loop\
    \ n2 (+ n1 n2)))))\n  (define (prime_fib_helper f fs m)\n    (cond ((= m 0)\n\
    \           (if (prime? f)\n               f\n               (prime_fib_helper\
    \ (car fs) (cdr fs) m)))\n          (else\n           (prime_fib_helper (car fs)\
    \ (cdr fs) (- m 1)))))\n  (prime_fib_helper (car (fibs)) (cdr (fibs)) (- n 1)))\n",
  "  (define (prime? n)\n    (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n     \
    \ [(even? n) #f]\n      [else\n       (for/or ([i (in-range 3 (/ n 2) 2)])\n \
    \        (= (modulo n i) 0))]))\n  (define (fib n)\n    (cond\n      [(= n 1)\
    \ 0]\n      [(= n 2) 1]\n      [else\n       (+ (fib (- n 1)) (fib (- n 2)))]))\n\
    \  (define (prime_fib_helper n i)\n    (if (= n 1)\n        (if (prime? i)\n \
    \           i\n            (prime_fib_helper (- n 1) (+ i 1)))\n        (if (prime?\
    \ i)\n            (prime_fib_helper (- n 1) (+ i 1))\n            (prime_fib_helper\
    \ n (+ i 1)))))\n  (prime_fib_helper n (fib (1+ n))))\n", "  (define (get-fibs\
    \ num)\n    (cond ((= num 0) (list 0))\n          ((= num 1) (list 0 1))\n   \
    \       (else (let* ((last-fibs (get-fibs (- num 1)))\n                      (last-last-fib\
    \ (list-ref last-fibs (- (length last-fibs) 2)))\n                      (last-fib\
    \ (list-ref last-fibs (- (length last-fibs) 1))))\n                 (append last-fibs\
    \ (list (+ last-last-fib last-fib)))))))\n  (define (prime? num)\n    (let loop\
    \ ((i 2))\n      (cond ((> (* i i) num) #t)\n            ((zero? (modulo num i))\
    \ #f)\n            (else (loop (+ i 1))))))\n  (for/first ((num (in-list (get-fibs\
    \ n)))\n              #:when (prime? num))\n    num))", "  (define (fib n)\n \
    \   (cond ((= n 1) 1)\n          ((= n 2) 1)\n          (else (+ (fib (- n 1))\
    \ (fib (- n 2))))))\n  (define (prime_fib_iter n cnt)\n    (cond ((= n cnt) n)\n\
    \          ((not (prime? (fib n))) (prime_fib_iter (+ n 1) cnt))\n          (else\
    \ (prime_fib_iter (+ n 1) (+ cnt 1)))))\n  (fib (prime_fib_iter 1 1)))\n```\n\n\
    ```python\n#lang python\n\n# prime_fib returns n-th number that is a Fibonacci\
    \ number and it's also prime.\n# >>> prime_fib(1)\n# 2\n# >>> prime_fib(2)\n#\
    \ 3\n# >>> prime_fib(3)\n# 5\n# >>> prime_fib(4)\n# 13\n# >>> prime_fib(5)\n#\
    \ 89\ndef prime_fib(n):\n    def fib(n):\n        if n == 1:\n            return\
    \ 1\n        elif n == 2:\n            return 1\n        else:\n            return\
    \ fib(n - 1) + fib(n - 2)\n    def prime_fib_iter(n, cnt):\n        if n == cnt:\n\
    \            return n\n        elif not prime(fib(n)):\n            return prime_fib_iter(n\
    \ + 1, cnt)\n        else:\n            return prime_fib_iter(n + 1, cnt + 1)\n\
    \    return fib(prime_fib_iter(1, 1))\n```\n\n```ruby\n#lang racket\n\n# prime_fib\
    \ returns n-th number that is a Fibonacci number and it's also prime.\n# >>> prime_fib(1)\n\
    # 2\n# >>> prime_fib(2)\n# 3\n# >>> prime_fib(3)\n# 5\n# >>> prime_fib(4)\n# 13\n\
    # >>> prime_fib(5)\n# 89\ndef prime_fib(n)\n  def fib(n", "  (define (prime? n)\n\
    \    (let* ([s (sqrt n)]\n           [res (build-list (inexact->exact s) (lambda\
    \ (x) (not (zero? (remainder n x)))))]\n           [res-len (length res)])\n \
    \     (and (= 0 (remainder res-len 2)) (not (zero? (remainder n s)) res))))\n\
    \  (define (fibonacci-seq n)\n    (if (<= n 1)\n        (list n)\n        (let*\
    \ ([f (fibonacci-seq (- n 1))]\n               [last (list-ref f (- (length f)\
    \ 1))]\n               [last-but-one (list-ref f (- (length f) 2))])\n       \
    \   (append f (list (+ last last-but-one))))))\n  (let loop ([fibs (fibonacci-seq\
    \ n)]\n             [i 0])\n    (if (or (not (prime? (list-ref fibs i))) (< i\
    \ n))\n        (loop fibs (+ i 1))\n        (list-ref fibs i))))\n", "  (prime_fib_iter\
    \ 2 0 n))\n", "  (cond\n    [(eq? n 1) 2]\n    [(eq? n 2) 3]\n    [else\n    \
    \ (let loop ([count 2] [m 2] [fib 0])\n       (if (<= count n)\n           (let\
    \ ([fib (+ m fib)])\n             (if (prime? fib)\n                 (if (= (+\
    \ count 1) n)\n                     fib\n                     (loop (+ count 1)\
    \ fib m))\n                 (loop count m fib))\n             )\n           \"\
    n is too big.\"))]))\n", "  (define (gen x y)\n    (if (= n 1)\n        x\n  \
    \      (gen y (+ x y))))\n  (define (helper n)\n    (cond ((= n 1) 1)\n      \
    \    ((= n 2) 2)\n          ((= n 3) 2)\n          ((= n 4) 3)\n          ((=\
    \ n 5) 5)\n          ((= n 6) 13)\n          ((= n 7) 89)\n          (else (helper\
    \ (- n 1)))))\n  (helper n))\n", "  (let loop ((nth_fib 0) (nth_prime 0) (a 0)\
    \ (b 1))\n    (cond ((and (= nth_fib n) (= nth_prime n)) a)\n          ((= nth_fib\
    \ n) (loop nth_fib (+ nth_prime 1) (+ a b) a))\n          ((= nth_prime n) (loop\
    \ (+ nth_fib 1) nth_prime (+ a b) a))\n          (else (loop (+ nth_fib 1) (+\
    \ nth_prime 1) (+ a b) a)))))", "  (if (= n 1)\n      2\n      (let ([fib (fib\
    \ n)])\n        (if (prime? fib)\n            fib\n            (prime_fib (+ n\
    \ 1))))))\n", "  (let loop ((i 1) (j 2) (k 3) (count 1))\n    (cond\n      ((=\
    \ count n) j)\n      ((= i 2) (loop j k (+ i j) (+ count 1)))\n      ((odd? i)\
    \ (loop j k (+ i j) count))\n      (else (loop j k (+ i j) count)))))\n", "  (cond\
    \ ((= n 1) 2)\n        ((= n 2) 3)\n        (else (let loop ([i 2] [n 2] [a 2]\
    \ [b 3])\n                 (cond ((= i n) b)\n                       ((and (fib?\
    \ (+ a b)) (prime? (+ a b)))\n                        (loop (+ i 1) n (+ a b)\
    \ a))\n                       (else (loop (+ i 1) n (+ a b) a)))))))\n", "  (let\
    \ ([fibs (in-naturals fib)])\n    (first (drop (nth (for/fold ([i n]) ([n 1])\n\
    \                          (if (prime? n) (add1 i) i))\n                     \
    \ fibs)))))\n", "  (let loop ((fibonacci 0) (cnt 0))\n    (cond ((= cnt n) fibonacci)\n\
    \          ((and (is_prime fibonacci) (= 1 (+ cnt 1)))\n           (loop (+ fibonacci\
    \ (fibonacci (- cnt 1))) (+ cnt 1)))\n          (else (loop (+ fibonacci (fibonacci\
    \ (- cnt 1))) cnt)))))\n", "  (define (prime? x)\n    (define (divisible? a b)\n\
    \      (= (remainder a b) 0))\n    (define (find-divisor n test-divisor)\n   \
    \   (cond ((> (square test-divisor) n) n)\n            ((divisible? n test-divisor)\
    \ test-divisor)\n            (else (find-divisor n (+ test-divisor 1)))))\n  \
    \  (= (find-divisor x 2) x))\n  (define (fib n)\n    (if (< n 2)\n        n\n\
    \        (+ (fib (- n 1)) (fib (- n 2)))))\n  (define (iter counter)\n    (if\
    \ (= counter n)\n        (fib counter)\n        (if (prime? (fib counter))\n \
    \           (iter (+ counter 1))\n            (iter counter))))\n  (iter 0))\n",
  "  (cond ((= n 1) 2)\n        ((= n 2) 3)\n        (else (let loop ([a 2] [b 3]\
    \ [c 5] [k 3])\n                 (cond ((= k n) c)\n                       (else\
    \ (loop b c (+ b c) (+ k 1))))))))\n", "  (define (fib_iter a b i)\n    (if (=\
    \ i n)\n        b\n        (if (and (fib? b) (prime? b))\n            (fib_iter\
    \ b (+ a b) (+ i 1))\n            (fib_iter b (+ a b) i))))\n  (fib_iter 1 1 1))\n",
  "  (let ((i 1) (j 0) (k 1) (count 0))\n    (while (< count n)\n      (set! i (+\
    \ j k))\n      (set! j k)\n      (set! k i)\n      (if (and (prime? i) (fib? i))\n\
    \          (set! count (+ count 1))))\n    i))\n", "  (cond\n    [(= n 1) 2]\n\
    \    [(= n 2) 3]\n    [else\n     (let loop ([a 1] [b 2] [c 3] [i 3])\n      \
    \ (cond\n         [(and (= i n) (prime? c)) c]\n         [else (loop b c (+ b\
    \ c) (+ i 1))]))]))\n", "  (letloop ((fibs (in-naturals))\n            (counter\
    \ 1))\n    (if (and (is-prime (first fibs))\n             (= counter n))\n   \
    \     (first fibs)\n        (letloop ((fibs (rest fibs))\n                  (counter\
    \ (+ counter 1)))))))\n", "  (define (prime_fib_iter count p1 p2)\n    (if (=\
    \ count n)\n        p1\n        (if (and (is_prime p1) (is_prime p2))\n      \
    \      (prime_fib_iter (+ count 1) p2 (+ p1 p2))\n            (prime_fib_iter\
    \ count p2 (+ p1 p2)))))\n  (prime_fib_iter 1 1 1))\n\n", "  (define (fib n)\n\
    \    (cond ((= n 1) 0)\n          ((= n 2) 1)\n          (else (+ (fib (- n 1))\
    \ (fib (- n 2))))))\n  (define (prime? n)\n    (cond ((= n 1) false)\n       \
    \   ((= n 2) true)\n          (else\n           (define (check k)\n          \
    \   (cond ((= k n) true)\n                   ((= (modulo n k) 0) false)\n    \
    \               (else (check (+ k 1)))))\n           (check 2))))\n  (define (prime_fib_iter\
    \ counter x)\n    (cond ((= counter n) x)\n          ((and (prime? x) (prime?\
    \ (+ x (fib counter))))\n           (prime_fib_iter (+ counter 1) (+ x (fib counter))))\n\
    \          (else (prime_fib_iter (+ counter 1) (+ x (fib counter))))))\n  (prime_fib_iter\
    \ 2 1))\n```\n\n## \u0417\u0430\u0434\u0430\u0447\u0430 12 (2 \u0442.)\n\n\u041D\
    \u0430\u043F\u0438\u0448\u0435\u0442\u0435 \u0444\u0443\u043D\u043A\u0446\u0438\
    \u044F, \u043A\u043E\u044F\u0442\u043E \u0432\u0440\u044A\u0449\u0430 \u0432\u0441\
    \u0438\u0447\u043A\u0438 \u043F\u0440\u043E\u0441\u0442\u0438 \u0447\u0438\u0441\
    \u043B\u0430 \u043E\u0442 `(from, to]`.\n\n\u041F\u0440\u0438\u043C\u0435\u0440\
    :\n\n```racket", "  (define (help k index)\n    (cond\n      [(= k n) index]\n\
    \      [(and (prime? index) (fib? index)) (help (+ k 1) (+ index 1))]\n      [else\
    \ (help k (+ index 1))]))\n  (help 1 2))\n", "  (if (= n 1)\n      2\n      (fibonacci-and-prime\
    \ (add1 n) 2 1 0)))\n", "  (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [else\
    \ (list-ref\n            (filter prime? (fibonacci-numbers n))\n            (-\
    \ n 1))]))\n", "  (define (fib-stream a b)\n    (cons-stream a (fib-stream b (+\
    \ a b))))\n  (define (fib-iter n fib-stream)\n    (if (= n 1)\n        (car fib-stream)\n\
    \        (if (prime? (car fib-stream))\n            (fib-iter (- n 1) (cdr fib-stream))\n\
    \            (fib-iter n (cdr fib-stream)))))\n  (fib-iter n (fib-stream 1 1)))\n",
  "  (define (fib k)\n    (cond\n      [(= k 1) 1]\n      [(= k 2) 1]\n      [else\
    \ (+ (fib (- k 1)) (fib (- k 2)))]))\n  (define (is_prime x)\n    (cond\n    \
    \  [(= x 1) false]\n      [(= x 2) true]\n      [(= x 3) true]\n      [(= x 4)\
    \ false]\n      [(= x 5) true]\n      [(= x 6) false]\n      [(= x 7) true]\n\
    \      [(= x 8) false]\n      [(= x 9) false]\n      [(= x 10) false]\n      [(=\
    \ x 11) true]\n      [(= x 12) false]\n      [(= x 13) true]\n      [(= x 14)\
    \ false]\n      [(= x 15) false]\n      [(= x 16) false]\n      [(= x 17) true]\n\
    \      [(= x 18) false]\n      [(= x 19) true]\n      [(= x 20) false]\n     \
    \ [(= x 21) false]\n      [(= x 22) false]\n      [(= x 23) true]\n      [(= x\
    \ 24) false]\n      [(= x 25) false]\n      [(= x 26) false]\n      [(= x 27)\
    \ false]\n      [(= x 28) false]\n      [(= x 29) true]\n      [(= x 30) false]\n\
    \      [(= x 31) true]\n      [(= x 32) false]\n      [(= x 33) false]\n     \
    \ [(= x 34) false]\n      [(= x 35) false]\n      [(= x 36) false]\n      [(=\
    \ x 37) true]\n      [(= x 38) false]\n      [(= x 39) false]\n      [(= x 40)\
    \ false]\n      [(= x 41) true]\n      [(= x 42) false]\n      [(= x 43) true]\n\
    \      [(= x 44) false]\n      [(= x 45) false]\n      [(= x 46) false]\n    \
    \  [(= x 47) true]\n      [(= x 48) false]\n      [(= x 49) false]\n      [(=\
    \ x", "  (for/first ([fib (in-range 0 1000)\n              :when (and (is-prime?\
    \ fib) (is-fib? fib))]\n              #:count n)\n    fib))\n", "  (define (fib_term\
    \ x)\n    (if (< x 2)\n        x\n        (+ (fib_term (- x 1)) (fib_term (- x\
    \ 2)))))\n  (define (prime? x)\n    (define (divisible? a b)\n      (= (remainder\
    \ a b) 0))\n    (define (find-divisor n test-divisor)\n      (cond ((> (square\
    \ test-divisor) n) n)\n            ((divisible? n test-divisor) test-divisor)\n\
    \            (else (find-divisor n (+ test-divisor 1)))))\n    (define (smallest-divisor\
    \ n)\n      (find-divisor n 2))\n    (define (prime-number? n)\n      (= n (smallest-divisor\
    \ n)))\n    (prime-number? x))\n  (define (fib-prime n i)\n    (if (and (prime?\
    \ (fib_term i)) (= n 1))\n        (fib_term i)\n        (if (prime? (fib_term\
    \ i))\n            (fib-prime (- n 1) (+ i 1))\n            (fib-prime n (+ i\
    \ 1)))))\n  (fib-prime n 0))\n", "  (if (< n 2)\n      2\n      (prime_fib2 (prime_fib\
    \ (- n 1)) 1 0 0 (+ n 1))))\n", "  (let loop ((n n) (fib (list 0 1)) (numbers\
    \ (list 2)))\n    (if (= n 1)\n        (car fib)\n        (loop (- n 1) (list\
    \ (add1 (car fib)) (car (cdr fib))) numbers))))\n", "  (define (helper i k)\n\
    \    (if (= k n)\n        (fib i)\n        (if (prime? (fib i))\n            (helper\
    \ (+ i 1) (+ k 1))\n            (helper (+ i 1) k))))\n  (helper 1 1))\n", " \
    \ (define (prime_fib_h n k th)\n    (cond ((= n k) th)\n          (((and (fib?\
    \ th) (prime? th)) (= k (+ 1 k))) (prime_fib_h n k (+ th th)))\n          (else\
    \ (prime_fib_h n (+ 1 k) (+ th th)))))\n  (prime_fib_h n 1 2))\n```\n\n```\n>\
    \ (prime_fib 10)\n533\n```\n\n```racket", "  (define-values (fib_prime fib_prime_count)\n\
    \    (let f ([n 0] [a 0] [b 1] [c 0] [count 0])\n      (cond [(= n 0) (values\
    \ a count)]\n            [(= n 1) (values b count)]\n            [(prime? b) (f\
    \ (- n 1) b (+ a b) a (+ count 1))]\n            [else (f (- n 1) b (+ a b) a\
    \ count)])))\n  (if (= n fib_prime_count)\n      fib_prime\n      \"The \" n \"\
    -th Fibonacci number that is also prime does not exist\"))\n", "  (define (prime?\
    \ x)\n    (define (helper x d)\n      (cond ((< d x) #t)\n            ((= (remainder\
    \ x d) 0) #f)\n            (else (helper x (+ d 1)))))\n    (helper x 2))\n  (define\
    \ (fib n m i)\n    (cond ((= n i) m)\n          (else (fib n (+ n m) (+ i 1)))))\n\
    \  (define (loop n i)\n    (cond ((= n i) #f)\n          ((prime? (fib 0 1 i))\
    \ i)\n          (else (loop n (+ i 1)))))\n  (loop n 1))\n", "  (define (iter\
    \ i a b fibs)\n    (cond ((zero? i) (first fibs))\n          ((prime? b) (iter\
    \ (- i 1) b (+ a b) (cons b fibs)))\n          (else (iter i a b fibs))))\n  (iter\
    \ n 1 1 (list 2)))\n", "  (define (fibonacci x)\n    (if (= x 1)\n        1\n\
    \        (if (= x 2)\n            2\n            (+ (fibonacci (- x 1)) (fibonacci\
    \ (- x 2))))))\n  (define (prime? x)\n    (define (prime?-iter x r)\n      (if\
    \ (= r 1)\n          #t\n          (if (= (remainder x r) 0)\n              #f\n\
    \              (prime?-iter x (- r 1)))))\n    (prime?-iter x (floor (/ x 2))))\n\
    \  (define (prime_fib-iter x counter)\n    (if (= x n)\n        (fibonacci counter)\n\
    \        (if (prime? (fibonacci counter))\n            (prime_fib-iter (+ x 1)\
    \ (+ counter 1))\n            (prime_fib-iter x (+ counter 1)))))\n  (prime_fib-iter\
    \ 1 1))\n", "  (let loop ([i n] [a 1] [b 1])\n    (cond ((= i 1) b)\n        \
    \  ((and (prime? (+ a b)) (= i n)) (+ a b))\n          (else (loop (- i 1) (+\
    \ a b) a)))))\n", "  (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [else\n    \
    \ (let ((n1 (prime_fib (- n 1)))\n           (n2 (prime_fib (- n 2))))\n     \
    \  (define (fib n)\n         (if (= n 0)\n             1\n             (+ (fib\
    \ (- n 1)) (fib (- n 2)))))\n       (define (prime? n)\n         (if (= n 1)\n\
    \             #f\n             (not (zero? (remainder n 2)))))\n       (define\
    \ (p n1 n2 n)\n         (if (and (prime? n) (= n n1))\n             n\n      \
    \       (p n1 n (- n1 n2))))\n       (p (fib (+ n 2)) n1 n2))]))\n", "  (let ([i\
    \ 1]\n        [k 1]\n        [p 0])\n    (while (< i n)\n      (set! p (fib k))\n\
    \      (if (prime? p)\n          (set! i (+ i 1)))\n      (set! k (+ k 1)))\n\
    \    p))\n", "  (define (is-prime n)\n    (define (loop m)\n      (cond\n    \
    \    ((<= m 1) #t)\n        ((= (remainder n m) 0) #f)\n        (else (loop (-\
    \ m 1)))))\n    (loop (floor (/ n 2))))\n  (define (fib n)\n    (define (loop\
    \ a b counter)\n      (cond\n        ((= counter n) b)\n        (else (loop b\
    \ (+ a b) (+ counter 1)))))\n    (loop 0 1 1))\n  (define (loop current counter)\n\
    \    (cond\n      ((= counter n) current)\n      ((and (= (is-prime current) #t)\
    \ (= (remainder current 2) 1)) (loop (fib (+ counter 1)) (+ counter 1)))\n   \
    \   (else (loop (fib (+ counter 1)) (+ counter 1)))))\n  (loop (fib 1) 1))\n",
  "  (prime_fib_iter 1 2 3 n))\n", "  (define (fib-until-prime n)\n    (if (prime?\
    \ (fib n))\n        (fib n)\n        (fib-until-prime (+ n 1))))\n  (fib-until-prime\
    \ n))\n", "  (letrec ([fib (lambda (x)\n                  (if (or (equal? x 1)\
    \ (equal? x 2))\n                      1\n                      (+ (fib (- x 1))\
    \ (fib (- x 2)))))])\n    (define (iterator x acc)\n      (cond [(= n 1) acc]\n\
    \            [(prime? (fib x)) (iterator (+ x 1) (fib x))]\n            [else\
    \ (iterator (+ x 1) acc)]))\n    (iterator 3 2)))\n", "  (define (is_prime num)\n\
    \    (define (aux num i)\n      (cond\n        [(= i 0)  false]\n        [(= i\
    \ 1)  true]\n        [(= (modulo num i) 0) false]\n        [else (aux num (- i\
    \ 1))]))\n    (aux num (- num 1)))\n  (define (aux cur n)\n    (cond\n      [(=\
    \ n 1)  1]\n      [(= n 2)  2]\n      [(is_prime cur) (aux (+ (aux (- cur 1) (-\
    \ n 1))\n                               (aux (- cur 2) (- n 2)))\n           \
    \              (- n 1))]\n      [else (aux (+ (aux (- cur 1) (- n 1))\n      \
    \              (aux (- cur 2) (- n 2)))\n                (- n 1))]))\n  (aux (aux\
    \ 0 n) n))", "  (let*\n      ((fib (lambda (n) (if (< n 2) n (+ (fib (- n 1))\
    \ (fib (- n 2))))))\n       (nth-prime (lambda (n) (if (and (<= n 2) (= n 1))\
    \ 2 (nth-prime-aux n 3 2))))\n       (nth-prime-aux (lambda (n index ctr)\n  \
    \                      (cond\n                          ((= ctr n) index)\n  \
    \                        ((prime? index) (nth-prime-aux n (+ index 2) (+ ctr 1)))\n\
    \                          (else (nth-prime-aux n (+ index 2) ctr))))))\n    (let\
    \ loop ((n n) (cur-val 1) (ctr 1))\n      (cond\n        ((= ctr n) cur-val)\n\
    \        ((prime? cur-val) (loop n (+ cur-val 1) (+ ctr 1)))\n        (else (loop\
    \ n (+ cur-val 1) ctr))))))\n", "  (local [(define (prime_fib-iter n-iter f1 f2\
    \ p1 p2 count)\n            (cond [(= n-iter count) p2]\n                  [(and\
    \ (fib? f2) (prime? p2))\n                   (prime_fib-iter n-iter f2 (+ f1 f2)\
    \ p2 (+ p1 p2) (+ count 1))]\n                  [else (prime_fib-iter n-iter f2\
    \ (+ f1 f2) p2 (+ p1 p2) count)]))]\n    (prime_fib-iter n 1 1 2 3 1)))\n", " \
    \ (nth n (filter prime? (map fib (range n)))))\n", "  (let loop ([fibs '(2 3)])\n\
    \    (if (= n 1)\n        (car fibs)\n        (let ([next (apply + fibs)])\n \
    \         (if (prime? next)\n              (if (= 1 (sub1 n))\n              \
    \    next\n                  (loop (cons next (cdr fibs))))\n              (loop\
    \ (cons next (cdr fibs))))))))\n", "  (define (prime_fib_iter i acc1 acc2)\n \
    \   (if (= i n)\n        acc1\n        (if (and (fib? acc2) (prime? acc2))\n \
    \           (prime_fib_iter (+ i 1) acc2 (+ acc1 acc2))\n            (prime_fib_iter\
    \ i acc1 (+ acc1 acc2)))))\n  (prime_fib_iter 1 2 1))\n", "  (define (prime? n)\n\
    \    (define (divisible? a b)\n      (= (remainder a b) 0))\n    (define (find-divisor\
    \ n test-divisor)\n      (cond ((> (square test-divisor) n) n)\n            ((divisible?\
    \ n test-divisor) test-divisor)\n            (else (find-divisor n (+ test-divisor\
    \ 1)))))\n    (= (find-divisor n 2) n))\n  (define (fib n)\n    (cond ((= n 0)\
    \ 0)\n          ((= n 1) 1)\n          (else (+ (fib (- n 1)) (fib (- n 2))))))\n\
    \  (define (fib-prime n)\n    (if (prime? (fib n))\n        (fib n)\n        (fib-prime\
    \ (+ n 1))))\n  (fib-prime n))\n", "  (cond ((< n 1) (error \"invalid input\"\
    ))\n        ((= n 1) 2)\n        ((= n 2) 3)\n        (else\n         (local [(define\
    \ (fib i v1 v2)\n                   (if (= i n)\n                       v2\n \
    \                      (fib (+ i 1) v2 (+ v1 v2))))]\n           (fib 3 2 3)))))\n\
    ```\n\n```\n#lang racket\n", "  (cond [(= n 1) 2]\n        [(= n 2) 3]\n     \
    \   [else\n         (letrec ([prime-fib-iter (lambda (i p1 p2)\n             \
    \                       (if (= i n)\n                                        p2\n\
    \                                        (if (and (fib? (+ p1 p2))\n         \
    \                                        (prime? (+ p1 p2)))\n               \
    \                             (prime-fib-iter (+ i 1) p2 (+ p1 p2))\n        \
    \                                    (prime-fib-iter (+ i 1) p2 (+ p1 p2)))))])\n\
    \           (prime-fib-iter 3 2 3))]))\n", "  (let loop ([i 1] [fibs '(1 1)] [k\
    \ 2])\n    (if (= i n)\n        (car fibs)\n        (if (is_prime? k)\n      \
    \      (loop (+ i 1) (cons k fibs) (+ k (car fibs)))\n            (loop i fibs\
    \ (+ k (car fibs)))))))\n", "  (define (fib m)\n    (cond ((= m 0) 0)\n      \
    \    ((= m 1) 1)\n          (else (+ (fib (- m 1)) (fib (- m 2))))))\n  (define\
    \ (is-prime? n)\n    (cond ((= n 1) #f)\n          ((= n 2) #t)\n          ((even?\
    \ n) #f)\n          (else\n           (let loop ((p 3))\n             (cond ((=\
    \ (modulo n p) 0) #f)\n                   ((= p (sqrt n)) #t)\n              \
    \     (else (loop (+ p 2))))))))\n  (define (prime-fib-loop x c)\n    (cond ((is-prime?\
    \ x) (if (= c n) x (prime-fib-loop (+ x 1) (+ c 1))))\n          (else (prime-fib-loop\
    \ (+ x 1) c))))\n  (prime-fib-loop (fib 0) 0))\n```\n\n### [py/prime-fib.py](py/prime-fib.py)\n\
    \n```py\n#!/usr/bin/env python3\n\n# >>> main(1)\n# 2\n# >>> main(2)\n# 3\n# >>>\
    \ main(3)\n# 5\n# >>> main(4)\n# 13\n# >>> main(5)\n# 89\ndef main(n):\n    def\
    \ fib(m):\n        if m == 0:\n            return 0\n        elif m == 1:\n  \
    \          return 1\n        else:\n            return fib(m - 1) + fib(m - 2)\n\
    \n    def is_prime(n):\n        if n == 1:\n            return False\n       \
    \ elif n == 2:\n            return True\n        elif n % 2 == 0:\n          \
    \  return False\n        else:\n            p = 3\n            while p <= n **\
    \ 0.5:\n                if n % p == 0:\n                    return False\n   \
    \             p += 2\n            return True\n\n    def prime_fib_loop(x, c):\n\
    \        if is_prime(x):\n            if c == n:\n                return x\n \
    \           else:\n                return prime_fib_loop(x + 1", "  (cond\n  \
    \  [(= n 1) 2]\n    [(= n 2) 3]\n    [else\n     (let ([count 0]\n           [previous\
    \ 1]\n           [current 2])\n       (cond\n         [(= n 3) 5]\n         [else\n\
    \          (begin\n            (set! count 3)\n            (while (< count n)\n\
    \              (let ([tmp (+ previous current)])\n                (if (prime?\
    \ tmp)\n                    (begin\n                      (set! count (+ count\
    \ 1))\n                      (set! previous current)\n                      (set!\
    \ current tmp))\n                    (set! previous current)\n               \
    \     (set! current tmp))))\n            current)]))]))\n", "  (prime_fib-iter\
    \ 1 2 3 n))\n", "  (let loop ([n n] [i 1] [j 1] [p 1])\n    (cond [(= n p) j]\n\
    \          [(= (gcd i j) 1) (loop n (+ i j) i (+ p 1))]\n          [else (loop\
    \ n (+ i j) i p)])))\n</code>\n", "  (if (= n 1)\n      2\n      (prime_fib-iter\
    \ 1 2 3 n)))\n", "  (define (fib n)\n    (if (< n 2) n\n        (+ (fib (- n 1))\
    \ (fib (- n 2)))))\n  (define (prime? n)\n    (let ((sqrt-n (sqrt n)))\n     \
    \ (and (integer? sqrt-n)\n           (not (exists (lambda (x) (= 0 (modulo n x)))\n\
    \                        (range 2 (add1 sqrt-n)))))))\n  (define (prime-fib n\
    \ i)\n    (if (= n i)\n        (fib n)\n        (if (prime? (fib n))\n       \
    \     (prime-fib n (add1 n))\n            (prime-fib (add1 n) i))))\n  (prime-fib\
    \ 0 n))\n", "  (cond [(= n 1) 2]\n        [(= n 2) 3]\n        [else (letrec ([A\
    \ (list 2 3)]\n                       [B (list 3 5)]\n                       [i\
    \ 3])\n                (let loop ([c (car (fib A B))])\n                  (cond\
    \ [(and (= i n) (prime? c)) c]\n                        [else (loop (car (fib\
    \ A B)))])))]))\n", "  (define (prime_fib-iter count a b)\n    (cond ((= count\
    \ n) a)\n          ((prime? b) (prime_fib-iter (+ count 1) b (+ a b)))\n     \
    \     (else (prime_fib-iter count a (+ a b)))))\n  (prime_fib-iter 1 1 1))\n",
  "  (let loop ((i 0) (n 1) (fib_1 1) (fib_2 0))\n    (cond ((= i n) fib_1)\n    \
    \      ((prime? fib_1) (loop (+ i 1) n (+ fib_1 fib_2) fib_1))\n          (else\
    \ (loop i n (+ fib_1 fib_2) fib_1)))))\n", "  (define (fibs p q k)\n    (if (=\
    \ k 0) p\n        (fibs q (+ p q) (- k 1))))\n  (define (prime-fibs n p k)\n \
    \   (cond\n      ((= k 0) (fibs p (+ p 1) n))\n      ((prime? p) (prime-fibs n\
    \ (+ p 1) (- k 1)))\n      (else (prime-fibs n (+ p 1) k))))\n  (prime-fibs n\
    \ 2 n))\n", "  (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [else (fib-prime 1\
    \ 1 2 n)]))\n", "  (define (is_prime? x)\n    (or (= x 2)\n        (and (> x 1)\n\
    \             (not (for/or ((i (in-range 2 (/ x 2))))\n                     (zero?\
    \ (modulo x i)))))))\n  (define (prime_fib-iter counter current next)\n    (cond\
    \ ((= counter n) current)\n          ((and (is_prime? current) (is_prime? next))\n\
    \           (prime_fib-iter (+ counter 1) next (+ current next)))\n          (else\
    \ (prime_fib-iter counter next (+ current next)))))\n  (prime_fib-iter 1 1 1))\n",
  "  (define (count)\n    (let loop ([i 0] [count 0])\n      (cond [(= count n) i]\n\
    \            [(and (fibonacci i) (prime? i)) (loop (+ i 1) (+ count 1))]\n   \
    \         [else (loop (+ i 1) count)])))\n  (count))\n", "  (if (= n 1)\n    \
    \  2\n      (if (= n 2)\n          3\n          (if (= n 3)\n              5\n\
    \              (let loop ([i 4] [a 2] [b 3] [c 5])\n                (if (= i n)\n\
    \                    c\n                    (if (and (prime? c)\n            \
    \                 (fib? c))\n                        (loop (+ i 1) b c (+ a b\
    \ c))\n                        (loop (+ i 1) b c (+ a b c)))))))))\n", "  (if\
    \ (= n 1)\n      2\n      (prime_fib_worker n 1 0 1 1)))\n", "  (nth-fib-prime\
    \ n))\n", "  (if (< n 1)\n      0\n      (prime_fib_iter 1 1 2 n 1)))\n", "  (let\
    \ ((pfibs '()))\n    (for ((i 1) (< i n))\n      (begin (set! pfibs (append pfibs\
    \ (fibonacci n)))\n      (set! pfibs (filter prime? pfibs))))\n    (car (reverse\
    \ pfibs))))\n", "  (local ((define (fib k)\n            (if (< k 2)\n        \
    \        k\n                (+ (fib (- k 1)) (fib (- k 2)))))\n           (define\
    \ (prime? x)\n             (local ((define (helper i)\n                      \
    \ (if (= i x)\n                           #t\n                           (if (=\
    \ (remainder x i) 0)\n                               #f\n                    \
    \           (helper (+ i 1))))))\n               (helper 2))))\n    (local ((define\
    \ (helper x i)\n              (if (= i n)\n                  x\n             \
    \     (if (and (prime? x) (prime? (+ x (fib (+ i 1)))))\n                    \
    \  (helper (+ x (fib (+ i 1))) (+ i 1))\n                      (helper (+ x (fib\
    \ (+ i 1))) i)))))\n      (helper (fib 1) 1))))\n", "  (define (helper n fib-num\
    \ fib-prime fib-num-prime nth-prime)\n    (if (= nth-prime n)\n        fib-prime\n\
    \        (helper n (+ fib-num fib-prime) fib-num fib-prime (+ nth-prime 1))))\n\
    \  (helper n 1 2 3 1))\n```\n\n```scheme\n#lang racket\n", "  (car (drop (- n\
    \ 1) (filter prime? (fib)))))\n", "  (define (fib n)\n    (define a 1)\n    (define\
    \ b 1)\n    (define (fib-iter counter n)\n      (if (= counter n)\n          b\n\
    \          (begin\n            (set! a (+ a b))\n            (set! b a)\n    \
    \        (fib-iter (+ counter 1) n))))\n    (fib-iter 2 n))\n  (define (prime_fib-iter\
    \ counter n)\n    (if (= counter n)\n        (fib counter)\n        (if (and (prime?\
    \ (fib counter))\n                 (not (prime? (fib (+ counter 1)))))\n     \
    \       (prime_fib-iter (+ counter 1) n)\n            (prime_fib-iter (+ counter\
    \ 1) n))))\n  (prime_fib-iter 1 n))\n", "  (define (fib-sequence)\n    (define\
    \ (fib n)\n      (cond ((= n 0) 0)\n            ((= n 1) 1)\n            (else\
    \ (+ (fib (- n 1)) (fib (- n 2))))))\n    (for/list ([i (in-range n)])\n     \
    \ (fib i)))\n  (define (prime? n)\n    (define (helper n i)\n      (cond ((> i\
    \ n) #t)\n            ((= (modulo n i) 0) #f)\n            (else (helper n (+\
    \ i 1)))))\n    (if (= n 0) #f\n        (helper n 2)))\n  (define (prime-sequence)\n\
    \    (for/list ([i (in-range n)])\n      (cond ((prime? i) i)\n            (else\
    \ (- i 1)))))\n  (define (prime-fib-sequence)\n    (for/list ([i (in-range n)])\n\
    \      (define (get-value lst i)\n        (list-ref lst i))\n      (cond ((prime?\
    \ (get-value (fib-sequence) i))\n             (get-value (fib-sequence) i))\n\
    \            (else (get-value (prime-sequence) i)))))\n  (list-ref (prime-fib-sequence)\
    \ (- n 1)))\n```\n\n## Task 4\n\n```scheme\n#lang racket\n", "  (let loop ((i\
    \ n) (result 1) (fib-num 1) (fib-prev 0))\n    (if (= i 1)\n      result\n   \
    \   (if (and (= (gcd fib-num result) 1) (prime? fib-num))\n        (loop (- i\
    \ 1) fib-num (+ fib-num fib-prev) fib-num)\n        (loop i result (+ fib-num\
    \ fib-prev) fib-num)))))\n", "  (let loop ((n n) (fib (stream-range 0)) (prime\
    \ (stream-prime)))\n    (if (= n 1)\n        (stream-first fib)\n        (if (and\
    \ (member? (stream-first fib) prime)\n                 (member? (stream-first\
    \ prime) fib))\n            (loop (- n 1) (stream-rest fib) (stream-rest prime))\n\
    \            (loop n (stream-rest fib) prime)))))\n", "  (define (prime-fib-iter\
    \ n a b count)\n    (if (= count n)\n        b\n        (let ((new-b (+ a b)))\n\
    \          (if (prime? new-b)\n              (prime-fib-iter n b new-b (+ count\
    \ 1))\n              (prime-fib-iter n b new-b count)))))\n  (prime-fib-iter n\
    \ 0 1 1))\n", "  (define (prime? n)\n    (or (= n 2)\n        (and (> n 1)\n \
    \            (define (prime?-iter x)\n               (if (= x 1)\n           \
    \        #t\n                   (if (zero? (modulo n x))\n                   \
    \    #f\n                       (prime?-iter (- x 1)))))\n             (prime?-iter\
    \ (truncate (sqrt n))))))\n  (define (fib n)\n    (define (fib-iter a b count)\n\
    \      (if (= count 0)\n          b\n          (fib-iter (+ a b) a (- count 1))))\n\
    \    (fib-iter 1 0 n))\n  (define (prime_fib-iter x c)\n    (if (= c n)\n    \
    \    x\n        (if (prime? x)\n            (prime_fib-iter (fib (+ c 1)) (+ c\
    \ 1))\n            (prime_fib-iter (fib (+ c 1)) (+ c 1)))))\n  (prime_fib-iter\
    \ (fib 0) 0))\n", "  (letrec\n    ([fib\n      (lambda (n1 n2)\n        (if (zero?\
    \ n) n1\n          (fib n2 (+ n1 n2))))]\n     [is-prime\n      (lambda (n)\n\
    \        (if (= n 1) #f\n          (if (= n 2) #t\n            (is-prime? n 2))))]\n\
    \     [is-prime?\n      (lambda (n k)\n        (if (= n k) #t\n          (if (=\
    \ 0 (modulo n k)) #f\n            (is-prime? n (+ k 1)))))]\n     [prime-fib\n\
    \      (lambda (n)\n        (if (is-prime (fib 1 1))\n          (if (= n 1) (fib\
    \ 1 1)\n            (prime-fib (- n 1)))\n          (prime-fib n)))])\n    (prime-fib\
    \ n)))\n", "  (define (fib n)\n    (if (< n 2) n\n        (+ (fib (- n 1)) (fib\
    \ (- n 2)))))\n  (define (is_prime n)\n    (cond ((= n 1) #f)\n          ((= n\
    \ 2) #t)\n          ((= (remainder n 2) 0) #f)\n          (else (is_prime-helper\
    \ n 3))))\n  (define (is_prime-helper n i)\n    (cond ((= i n) #t)\n         \
    \ ((= (remainder n i) 0) #f)\n          (else (is_prime-helper n (+ i 2)))))\n\
    \  (define (prime_fib-helper n i)\n    (if (and (is_prime (fib i)) (= i n)) (fib\
    \ i)\n        (prime_fib-helper n (+ i 1))))\n  (prime_fib-helper n 0))\n\n```\n\
    \n```\n\n```\n\n```\n\n```\n\n```\n\n```", "  (define (is-prime? n)\n    (cond\
    \ ((< n 2) #f)\n          ((= n 2) #t)\n          ((= (remainder n 2) 0) #f)\n\
    \          (else (define (iter i)\n                  (cond ((= (* i i) n) #f)\n\
    \                        ((> (* i i) n) #t)\n                        ((= (remainder\
    \ n i) 0) #f)\n                        (else (iter (+ i 1)))))\n             \
    \   (iter 3))))\n  (define (prime-fibs x y z n)\n    (cond ((= n 1) x)\n     \
    \     ((is-prime? z) (prime-fibs y z (+ x y) (- n 1)))\n          (else (prime-fibs\
    \ y z (+ x y) n))))\n  (prime-fibs 2 3 5 n))\n", "  (cond\n    [(equal? n 1) 2]\n\
    \    [(equal? n 2) 3]\n    [else\n     (let ([p 0] [f 1] [count 0])\n       (while\
    \ (< count n)\n         (let ([sum (+ p f)])\n           (if (is-prime? sum)\n\
    \               (begin\n                 (set! p f)\n                 (set! f\
    \ sum)\n                 (set! count (+ count 1))))\n           (set! f (+ p f))\n\
    \           (set! p f)\n           (set! f sum)))\n       f)]))\n", "  (filter\
    \ fib-prime? (map fib (build-list n (lambda (x) (+ x 1))))))\n", "  (define (fib\
    \ k)\n    (cond\n      [(= k 1) 0]\n      [(= k 2) 1]\n      [else (+ (fib (-\
    \ k 1)) (fib (- k 2)))]))\n  (define (prime? n)\n    (cond\n      [(= n 2) #t]\n\
    \      [(< n 2) #f]\n      [(even? n) #f]\n      [else (for-all (lambda (x) (<\
    \ (remainder n x) 2)) (range 2 n))]))\n  (define (fib_prime i)\n    (if (prime?\
    \ (fib i))\n        (if (= i n)\n            (fib i)\n            (fib_prime (+\
    \ i 1)))\n        (fib_prime (+ i 1))))\n  (fib_prime 1))\n```\n\n### 6.2.2 \u518D\
    \u5E30\u69CB\u9020\u3092\u4F7F\u3046\n\n```racket\n#lang racket\n", "  (define\
    \ (prime_fib-iter x c)\n    (cond ((= c n) x)\n          ((and (fib? x) (prime?\
    \ x)) (prime_fib-iter (+ x 1) (+ c 1)))\n          (else (prime_fib-iter (+ x\
    \ 1) c))))\n  (prime_fib-iter 1 0))\n", "  (if (< n 1)\n      (error \"n must\
    \ be larger than 0!\")\n      (let ([nth (fib n)])\n        (if (is-prime nth)\n\
    \            nth\n            (prime_fib (- n 1))))))\n", "  (define (fib-seq\
    \ a b count)\n    (if (= count n)\n        b\n        (fib-seq b (+ a b) (+ count\
    \ 1))))\n  (define (helper a b count n)\n    (if (= count n)\n        a\n    \
    \    (if (prime? b)\n            (helper b (+ a b) (+ count 1) n)\n          \
    \  (helper a (+ a b) (+ count 1) n))))\n  (helper 0 1 1 n))\n", "  (define (fib\
    \ n)\n    (if (< n 3)\n        n\n        (+ (fib (- n 1)) (fib (- n 2)))))\n\
    \  (define (prime n)\n    (let ([n2 (sqrt n)])\n      (define (divisor d)\n  \
    \      (if (= 0 (modulo n d))\n            #f\n            (if (> d n2)\n    \
    \            #t\n                (divisor (+ d 1)))))\n      (divisor 2)))\n \
    \ (define (prime_fib-iter i counter)\n    (if (= i counter)\n        i\n     \
    \   (if (and (prime (fib i)) (= 0 (modulo (fib i) 5)))\n            (prime_fib-iter\
    \ (+ i 1) (+ counter 1))\n            (prime_fib-iter (+ i 1) counter))))\n  (fib\
    \ (prime_fib-iter 0 0)))", "  (define (helper a b count)\n    (if (= count n)\n\
    \        b\n        (if (and (prime? b) (prime? a))\n            (helper b (+\
    \ a b) (+ count 1))\n            (helper b (+ a b) count))))\n  (helper 1 1 1))\n",
  "  (define (loop c i f1 f2)\n    (if (= c n)\n        f2\n        (if (and (prime?\
    \ f2) (= f2 (fib i)))\n            (loop (+ c 1) (+ i 1) f2 (+ f1 f2))\n     \
    \       (loop c (+ i 1) f2 (+ f1 f2)))))\n  (loop 1 2 1 1))\n", "  (let loop ([n\
    \ n] [i 1] [j 1] [c 0])\n    (if (= n c)\n        i\n        (if (and (= j i)\
    \ (prime? i))\n            (loop n (+ i j) i (+ c 1))\n            (loop n (+\
    \ i j) i c)))))\n```\n\n### Problem 120\n```#lang racket\n", "  (define fib_list\
    \ (list 0 1))\n  (define prime_list (list 2))\n  (define (fib x)\n    (if (<=\
    \ (length fib_list) x)\n        (set! fib_list (append fib_list (list (+ (fib\
    \ (- x 1)) (fib (- x 2)))))))\n    (list-ref fib_list x))\n  (define (sieve x)\n\
    \    (if (<= (length prime_list) x)\n        (set! prime_list (append prime_list\
    \ (list (sieve (+ 1 (length prime_list)))))))\n    (define num (list-ref prime_list\
    \ x))\n    (if (= 0 (remainder num x))\n        (sieve (+ 1 x))\n        num))\n\
    \  (define (prime_fib n)\n    (define nth_fib (fib n))\n    (define nth_prime\
    \ (sieve n))\n    (define nth_prime_fib (let loop ((fib-list (list 0 1)) (prime-list\
    \ (list 2)) (i 1))\n                            (if (= i n)\n                \
    \                (list-ref fib-list (- n 1))\n                               \
    \ (loop (append fib-list (list (+ (list-ref fib-list (- i 1)) (list-ref fib-list\
    \ (- i 2)))))\n                                      (append prime-list (list\
    \ (let loop2 ((i 2) (prime-list prime-list))\n                               \
    \                                 (if (= 0 (remainder (list-ref prime-list (-\
    \ i 1)) i))\n                                                                \
    \    (loop2 (+ 1 i) prime-list)\n                                            \
    \                        (list-ref prime-list (- i 1))))))\n                 \
    \                     (+ 1 i)))))\n    nth_prime_fib)\n  (prime_fib n))\n", " \
    \ (let* ([a 1] [b 1] [c 0] [i 1])\n    (while (< i n)\n      (set! c (+ a b))\n\
    \      (set! a b)\n      (set! b c)\n      (set! i (add1 i))\n      (if (and (fib?\
    \ c) (prime? c))\n          (set! i n))\n      )\n    c))\n", "  (cond ((= n 1)\
    \ 2)\n        ((= n 2) 3)\n        (else (let loop ([fib1 2] [fib2 3] [counter\
    \ 3])\n                 (if (= counter n)\n                     fib2\n       \
    \              (let ([fib3 (+ fib1 fib2)])\n                       (if (prime?\
    \ fib3)\n                           (loop fib2 fib3 (+ counter 1))\n         \
    \                  (loop fib2 fib3 counter))))))))\n</code>\n<code>;; Is number\
    \ prime?", "  (define (prime_fib_iter counter nth fib1 fib2)\n    (if (= counter\
    \ n)\n        fib2\n        (if (and (prime? fib2)\n                 (= (length\
    \ (factorize fib2)) 1))\n            (prime_fib_iter (+ counter 1) nth fib2 (+\
    \ fib1 fib2))\n            (prime_fib_iter counter nth fib2 (+ fib1 fib2)))))\n\
    \  (if (= n 1)\n      2\n      (prime_fib_iter 2 n 1 2)))\n", "  (let loop ([m\
    \ 0] [f1 1] [f2 1])\n    (cond\n      [(zero? m) (loop (+ m 1) f1 f2)]\n     \
    \ [(and (fib? m) (prime? m)) (loop (+ m 1) f1 f2)]\n      [(fib? m) (loop (+ m\
    \ 1) f1 f2)]\n      [(prime? m) (loop (+ m 1) f1 f2)]\n      [else (loop (+ m\
    \ 1) f1 f2)])))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
