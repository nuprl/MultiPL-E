name: HumanEval_128_prod_signs
language: rkt
prompt: "#lang racket\n\n;; You are given a list arr of integers and you need to return\n\
  ;; sum of magnitudes of integers multiplied by product of all signs\n;; of each\
  \ number in the list, represented by 1, -1 or 0.\n;; Note: return #f for empty arr.\n\
  ;; Example:\n;; >>> (prod_signs (list 1 2 2 -4))\n;; 9\n;; >>> (prod_signs (list\
  \ 0 1))\n;; 0\n;; >>> (prod_signs (list ))\n;; #f\n(define (prod_signs arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
  \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
  \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n   \
  \ (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list 2 4\
  \ 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal?\
  \ (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0))\
  \ 0)\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? arr) #f]\n        [else (apply * (map magnitude arr))]))\n\
    </code>\n", "  (if (null? arr)\n      #f\n      (* (reduce * (map (lambda (x)\
    \ (if (negative? x) -1 1)) arr))\n         (reduce + (map abs arr)))))\n", " \
    \ (if (null? arr)\n      #f\n      (let ([prod (foldl * 1 (map sign arr))])\n\
    \        (if (= prod 0)\n            0\n            (foldl + 0 (map abs arr)))))\n\
    \  )\n", "  (if (null? arr)\n      #f\n      (* (foldr * 1 (map (lambda (x)\n\
    \                           (cond ((> x 0) 1)\n                              \
    \   ((< x 0) -1)\n                                 (else 0)))\n              \
    \           arr))\n         (foldr + 0 (map abs arr)))))", "  (define (mult_signs\
    \ lst)\n    (cond [(null? lst) 1]\n          [(< (car lst) 0) (* -1 (mult_signs\
    \ (cdr lst)))]\n          [(> (car lst) 0) (* 1 (mult_signs (cdr lst)))]\n   \
    \       [else (* 0 (mult_signs (cdr lst)))]))\n  (cond [(null? arr) #f]\n    \
    \    [else (+ (* (abs (car arr)) (mult_signs (cdr arr)))\n                 (prod_signs\
    \ (cdr arr)))]))\n", "  (cond [(empty? arr) #f]\n        [else (prod_signs_aux\
    \ (map abs arr)\n                              (map (\u03BB (x) (if (zero? x)\
    \ 0 (if (positive? x) 1 -1))) arr))]))\n", "  (define (sign x)\n    (cond ((<\
    \ x 0) -1)\n          ((= x 0) 0)\n          (else 1)))\n  (cond ((empty? arr)\
    \ #f)\n        (else (apply * (map sign arr)))))\n", "  (if (empty? arr)\n   \
    \   #f\n      (foldl * 1 (map (lambda (x) (if (equal? x 0) 0 (sign x))) arr))))\n",
  "  (match arr\n    (() #f)\n    ((lst . rest)\n     (let ((a (cond\n           \
    \    ((negative? lst) -1)\n               ((positive? lst) 1)\n              \
    \ (else 0))))\n       (if (null? rest)\n           (* (abs lst) a)\n         \
    \  (* (abs lst) a (prod_signs rest)))))))\n", "  (if (null? arr) #f\n      (let\
    \ loop ([arr (cdr arr)] [acc (if (zero? (car arr)) 0 (abs (car arr)))])\n    \
    \    (if (null? arr) acc\n            (loop (cdr arr) (* acc (if (zero? (car arr))\
    \ 0 (sign (car arr)))))))))\n", "  (match arr\n    [(list) (error \"arr cannot\
    \ be empty\")]\n    [(list hd@ (in-list rest ...))\n     (+ (* (signum hd) (abs\
    \ hd))\n        (* (prod_signs rest) (signum hd)))]))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [else\n     (let ([signs (map abs arr)])\n       (* (product (map\
    \ sign arr))\n          (product signs)))]))", "  (cond\n    [(empty? arr) #f]\n\
    \    [else (f * (sign (fst arr)) (sign (snd arr)))]))", "  (if (null? arr)\n \
    \     #f\n      (* (sign-magnitude (car arr))\n         (prod_signs (cdr arr)))))\n",
  "  (cond [(empty? arr)\n         #f]\n        [else\n         (* (prod_signs (rest\
    \ arr))\n            (check_sign (first arr)))]))\n", "  (if (empty? arr) #f\n\
    \      (apply * (map abs arr))))\n", "  (cond\n    [(empty? arr) #f]\n    [else\n\
    \     (foldl\n      (lambda (num acc)\n        (let ([sign (* num (/ num (abs\
    \ num)))])\n          (+ (* (abs num) acc) (* sign acc))))\n      1\n      arr)]))",
  "  (cond\n    ((null? arr) #f)\n    ((zero? (prod_signs_iter arr)) 0)\n    (else\n\
    \     (prod_signs_iter arr))))\n", "  (cond\n    [(empty? arr) #f]\n    [else\
    \ (apply * (map abs arr))]))\n", "  (local [(define (sign n)\n            (cond\n\
    \              [(negative? n) -1]\n              [(zero? n) 0]\n             \
    \ [else 1]))\n          (define (prod l)\n            (if (null? l)\n        \
    \        1\n                (* (sign (car l)) (prod (cdr l)))))\n          (define\
    \ (mag n)\n            (if (zero? n)\n                0\n                (abs\
    \ n)))]\n    (if (null? arr)\n        #f\n        (+ (* (car arr) (prod (cdr arr)))\n\
    \           (* (mag (car arr)) (prod (cdr arr)))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
