name: HumanEval_115_max_fill
language: rkt
prompt: "#lang racket\n\n;; You are given a rectangular grid of wells. Each row represents\
  \ a single well,\n;; and each 1 in a row represents a single unit of water.\n;;\
  \ Each well has a corresponding bucket that can be used to extract water from it,\
  \ \n;; and all buckets have the same capacity.\n;; Your task is to use the buckets\
  \ to empty the wells.\n;; Output the number of times you need to lower the buckets.\n\
  ;; Example 1:\n;; >>> (max_fill (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1\
  \ 1)) 1)\n;; 6\n;; Example 2:\n;; >>> (max_fill (list (list 0 0 1 1) (list 0 0 0\
  \ 0) (list 1 1 1 1) (list 0 1 1 1)) 2)\n;; 5\n;; Example 3:\n;; >>> (max_fill (list\
  \ (list 0 0 0) (list 0 0 0)) 5)\n;; 0\n;; Constraints:\n;; * all wells have the\
  \ same length\n;; * 1 <= grid.length <= 10^2\n;; * 1 <= grid[:,1].length <= 10^2\n\
  ;; * grid[i][j] -> 0 | 1\n;; * 1 <= capacity <= 10\n(define (max_fill grid capacity)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_fill))\n\
  \    (check-equal? (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1))\
  \ 1) 6)\n    (check-equal? (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list\
  \ 1 1 1 1) (list 0 1 1 1)) 2) 5)\n    (check-equal? (candidate (list (list 0 0 0)\
  \ (list 0 0 0)) 5) 0)\n    (check-equal? (candidate (list (list 1 1 1 1) (list 1\
  \ 1 1 1)) 2) 4)\n    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1))\
  \ 9) 2)\n))\n\n(test-humaneval)"
completions: ["  (define width (length (car grid)))\n  (define height (length grid))\n\
    \  (define wells (for/list ([y (in-range height)])\n                  (for/list\
    \ ([x (in-range width)])\n                    (if (list-ref (list-ref grid y)\
    \ x)\n                        x\n                        -1))))\n  (define (fill\
    \ wells total-fills)\n    (let ([worst-depth (reduce max (flatten wells))])\n\
    \      (if (negative? worst-depth)\n          total-fills\n          (let* ([worst-well\
    \ (for/first ([y (in-range height)])\n                                (when (positive?\
    \ (list-ref wells y worst-depth))\n                                  y))]\n  \
    \               [water-to-fill (- width (list-ref wells worst-well worst-depth))])\n\
    \            (for ([y (in-range height)])\n              (if (or (= y worst-well)\n\
    \                      (positive? (list-ref wells y (- worst-depth 1))))\n   \
    \               (set! (list-ref wells y worst-depth) (- (list-ref wells y worst-depth)\
    \ capacity))\n                  (set! (list-ref wells y worst-depth) (list-ref\
    \ wells y worst-depth))))\n            (let ([fill-times (ceiling (/ water-to-fill\
    \ capacity))])\n              (fill wells (+ total-fills fill-times)))))))\n \
    \ (fill wells 0))", "  (define (wells-to-cps grid)\n    (for/list ([line grid])\n\
    \      (for/list ([item line])\n        (if (= item 1)\n            capacity\n\
    \            0))))\n  (define (get-max-height row)\n    (apply max row))\n  (define\
    \ (get-total-water cps)\n    (apply + cps))\n  (define (get-total-water-in-rows\
    \ cps)\n    (map get-total-water cps))\n  (define (get-max-water-per-row cps)\n\
    \    (map get-max-height cps))\n  (define (get-max-water cps)\n    (apply max\
    \ (get-max-water-per-row cps)))\n  (define (reduce-rows cps)\n    (for/list ([row\
    \ cps])\n      (for/list ([item row])\n        (- item (get-max-water cps)))))\n\
    \  (define (sum-of-non-negatives lst)\n    (apply + (filter positive? lst)))\n\
    \  (define (sum-of-heighted-water cps)\n    (sum-of-non-negatives (get-total-water-in-rows\
    \ cps)))\n  (define (reduce-water-level cps)\n    (if (zero? (sum-of-heighted-water\
    \ cps))\n        0\n        (+ 1 (reduce-water-level (reduce-rows cps)))))\n \
    \ (reduce-water-level (wells-to-cps grid)))\n", "  (cond\n    [(empty? grid) 0]\n\
    \    [else\n     (let* ([buckets (build-buckets grid capacity)]\n            [next-well\
    \ (first grid)]\n            [next-buckets buckets]\n            [next-fill (fill-row\
    \ next-well capacity)])\n       (+ (count-fill next-fill)\n          (max_fill\
    \ (rest grid) capacity)))]))\n", '  (max-fill-aux grid capacity 0))', "    ; your\
    \ code goes here\n    0)", "  (let ((final-result 0))\n    (let loop ((water (make-list\
    \ (length grid) 0))\n               (i 0))\n      (cond [(= i (length grid)) (apply\
    \ + final-result)]\n            [else (let* ((res (+ (apply + (map (lambda (x)\
    \ (* x capacity)) (list-ref grid i))) (list-ref water i)))\n                 \
    \       (water-left (- res capacity)))\n                    (set! final-result\
    \ (append final-result (list capacity)))\n                    (set! water (vector-set!\
    \ water i water-left))\n                    (loop water (+ i 1)))])))))\n", " \
    \ (max-fill/iter grid capacity 0))\n", "  (letrec ((max_fill-row (lambda (row)\n\
    \                           (if (empty? row)\n                               0\n\
    \                               (max\n                                (apply max\
    \ (filter positive? row))\n                                (max_fill-row (cdr\
    \ row)))))))\n    (* capacity (max_fill-row grid))))\n", "    (max-fill-grid (convert-1d-2d\
    \ grid) capacity))\n", "    (cond\n        [(null? grid) 0]\n        [else\n \
    \           (let ([drops\n                    (+ capacity\n                  \
    \      (- (apply min (map number->string grid))\n                           (apply\
    \ max (map number->string grid))))])\n                (+ drops (max_fill (cdr\
    \ grid) capacity)))]))\n", "  (foldl (\u03BB (x y) (max y (raise capacity x)))\
    \ 0 grid))\n", "  (if (= capacity 0)\n      0\n      (max_fill (water grid capacity)\
    \ (- capacity 1))))\n", "  (define (get_bucket grid row)\n    (length (filter\
    \ (lambda (x) (= x 1)) row)))\n  (define (fill_bucket grid capacity)\n    (map\
    \ (lambda (row) (max 0 (- capacity (get_bucket grid row)))) grid))\n  (define\
    \ (add_bucket grid bucket)\n    (map (lambda (row) (map (lambda (x) (if (= x 0)\
    \ 0 (+ x bucket))) row)) grid))\n  (define (lower_bucket grid capacity)\n    (foldl\
    \ (lambda (grid bucket) (add_bucket grid bucket)) grid (fill_bucket grid capacity)))\n\
    \  (length (take-while (lambda (grid) (not= grid '())) (iterate (lambda (grid)\
    \ (lower_bucket grid capacity)) grid))))\n", "  (let ((extracted (find-and-extract\
    \ grid capacity)))\n    (cond\n      [(and (empty? extracted) (empty? grid)) 0]\n\
    \      [(empty? extracted)\n       (+ capacity (max_fill grid capacity))]\n  \
    \    [else (+ capacity (max_fill grid capacity))])))\n", "  (let loop ([grid grid]\
    \ [count 0])\n    (if (empty? grid)\n        count\n        (loop (remove-water\
    \ capacity grid)\n              (+ count (count-water grid))))))\n", "  (displayln\
    \ (format \"grid: ~a\" grid))\n  (define (aux grid capacity ans)\n    (if (null?\
    \ grid)\n        ans\n        (let ((current-row (car grid))\n              (leftover-capacity\
    \ capacity)\n              (row-ans 0))\n          (displayln (format \"current-row:\
    \ ~a\" current-row))\n          (displayln (format \"leftover-capacity: ~a\" leftover-capacity))\n\
    \          (define (aux2 current-row leftover-capacity row-ans)\n            (if\
    \ (null? current-row)\n                row-ans\n                (define first-val\
    \ (car current-row))\n                (displayln (format \"first-val: ~a\" first-val))\n\
    \                (if (zero? first-val)\n                    (aux2 (cdr current-row)\
    \ leftover-capacity row-ans)\n                    (if (<= leftover-capacity first-val)\n\
    \                        (aux2 (cdr current-row) (- leftover-capacity first-val)\
    \ (+ row-ans 1))\n                        (aux2 (cdr current-row) capacity (+\
    \ row-ans 1))))))\n          (aux (cdr grid) capacity (+ ans (aux2 current-row\
    \ leftover-capacity row-ans))))))\n  (aux grid capacity 0))", "  (cond [(empty?\
    \ grid) 0]\n        [else\n         (let ([water_cells (number-of-water-cells\
    \ grid capacity)])\n           (+ capacity water_cells (max_fill (rest grid) capacity)))]))\n",
  "  (define (max_fill_helper grid capacity i result)\n    (cond ((or (zero? capacity)\
    \ (null? grid)) result)\n          ((< capacity (length (car grid))) result)\n\
    \          ((< capacity (length (foldl + 0 (car grid)))) result)\n          (else\
    \ (max_fill_helper (cdr grid)\n                                 capacity\n   \
    \                              (+ i 1)\n                                 (+ (min\
    \ capacity (length (car grid))) result)))))\n  (max_fill_helper grid capacity\
    \ 0 0))\n```\n\n#### Write a function that takes a string in input and returns\
    \ how many times each alphabetic character is present in it.\n```#lang racket\n",
  "  (define (fill grid)\n    (define (create-row)\n      (let loop ((n (length (car\
    \ grid))))\n        (if (zero? n)\n            '()\n            (cons 0 (loop\
    \ (- n 1))))))\n    (define (fill-column y z capacity)\n      (cond ((empty? z)\
    \ capacity)\n            ((zero? capacity) z)\n            ((<= capacity (first\
    \ z))\n             (cons (- (first z) capacity) (rest z)))\n            ((> capacity\
    \ (first z))\n             (let ((subtract-capacity (- capacity (first z))))\n\
    \               (cons 0 (fill-column y (rest z) subtract-capacity))))))\n    (define\
    \ (fill-row y x)\n      (let ((row (nth y grid)))\n        (cond ((empty? row)\
    \ 0)\n              ((zero? (first row)) (fill-row y (rest row)))\n          \
    \    ((= 1 (first row)) (fill-row y (rest row)))\n              ((= 2 (first row))\
    \ (+ 1 (fill-row y (rest row)))))))\n    (define (empty-wells y)\n      (cond\
    \ ((empty? y) 0)\n            ((= 1 (first y)) (+ 1 (empty-wells (rest y))))\n\
    \            ((>= 2 (first y)) (+ 1 (empty-wells (rest y))))\n            (else\
    \ (empty-wells (rest y)))))\n    (define (max_fill-helper grid capacity)\n   \
    \   (cond ((empty? grid) 0)\n            ((= 0 capacity) (max_fill-helper (rest\
    \ grid) capacity))\n            ((= (length (car grid)) (empty-wells (car grid)))\n\
    \             (+ (max_fill-helper (rest grid) capacity) 1))\n            (else\n\
    \             (max_fill-helper (cons (fill-column (car grid) (car grid) capacity)\n\
    \                                    (rest grid))\n                          \
    \   capacity))))\n    (let loop ((grid grid)\n               (capacity capacity))\n\
    \      (cond ((empty? grid) 0)\n            ((= 0 capacity) 0)\n            ((=\
    \ (length (car grid)) (empty-wells (car grid)))\n             (+ (max_fill-helper\
    \ (", "  (define (max_fill-helper acc grid)\n    (cond\n      [(empty? grid) acc]\n\
    \      [(empty? (car grid)) (max_fill-helper acc (cdr grid))]\n      [(= 0 (car\
    \ (car grid))) (max_fill-helper acc (cdr grid))]\n      [else\n       (let ([col-max\
    \ (max-col-well grid capacity)])\n         (define (max-col-well grid capacity)\n\
    \           (cond\n             [(= 0 capacity) 0]\n             [(empty? grid)\
    \ 0]\n             [(empty? (car grid)) (max-col-well (cdr grid) capacity)]\n\
    \             [(= 0 (car (car grid))) (max-col-well (cdr grid) capacity)]\n  \
    \           [else\n              (let ([col-val (+ (car (car grid)) (max-col-well\
    \ (cdr grid) (- capacity 1)))])\n                (cons col-val (max-col-well (cdr\
    \ grid) capacity)))]))\n         (max-fill-helper (+ acc 1) (map (lambda (col-val)\
    \ (if (> col-val 0) (- col-val 1) 0)) col-max)))]))\n  (max-fill-helper 0 grid))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
