name: HumanEval_63_fibfib
language: rkt
prompt: "#lang racket\n\n;; The FibFib number sequence is a sequence similar to the\
  \ Fibbonacci sequnece that's defined as follows:\n;; fibfib(0) == 0\n;; fibfib(1)\
  \ == 0\n;; fibfib(2) == 1\n;; fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n\
  ;; Please write a function to efficiently compute the n-th element of the fibfib\
  \ number sequence.\n;; >>> (fibfib 1)\n;; 0\n;; >>> (fibfib 5)\n;; 4\n;; >>> (fibfib\
  \ 8)\n;; 24\n(define (fibfib n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fibfib))\n\
  \    (check-equal? (candidate 2) 1)\n    (check-equal? (candidate 1) 0)\n    (check-equal?\
  \ (candidate 5) 4)\n    (check-equal? (candidate 8) 24)\n    (check-equal? (candidate\
  \ 10) 81)\n    (check-equal? (candidate 12) 274)\n    (check-equal? (candidate 14)\
  \ 927)\n))\n\n(test-humaneval)"
completions: ["  (define (fibfib-t n-1 n-2 n-3 acc)\n    (if (= n 0)\n        acc\n\
    \        (fibfib-t n-2 n-3 (+ acc n-1 n-2 n-3) (+ acc n-1 n-2 n-3))))\n  (fibfib-t\
    \ 0 0 1 0))\n", "    (define (loop n a b c)\n        (if (= n 0)\n           \
    \ a\n            (loop (- n 1) b c (+ b c a))))\n    (loop n 0 0 1))\n", "  (define\
    \ fibfib-first-three (list 0 0 1))\n  (define (iter n lst)\n    (if (= n 0)\n\
    \        (list-ref lst 0)\n        (iter (- n 1) (append lst (list (+ (list-ref\
    \ lst (- (length lst) 1)) (list-ref lst (- (length lst) 2)) (list-ref lst (- (length\
    \ lst) 3))))))))\n  (iter n fibfib-first-three))", "  (if (< n 3)\n      (if (=\
    \ n 0)\n          0\n          1)\n      (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(=\
    \ n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (cond\n    [(equal? n 0) 0]\n    [(equal? n 1) 0]\n    [(equal? n 2) 1]\n   \
    \ [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))", "  (cond\n\
    \    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else\n     (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n\
    \    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3)))]))", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(=\
    \ n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (define (fibfib-iter a b c n)\n    (if (= n 0)\n        a\n        (fibfib-iter\
    \ b c (+ c (+ a b)) (- n 1))))\n  (fibfib-iter 0 0 1 n))\n", "  (cond\n    [(=\
    \ n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (define (inner n x y z)\n    (if (= n 0)\n\
    \        x\n        (inner (- n 1) y z (+ x y z))))\n  (inner n 0 0 1))\n", " \
    \ (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (let loop ([n n] [p 0]\
    \ [pp 0] [ppp 0])\n    (cond\n      [(= n 0) p]\n      [(= n 1) pp]\n      [(=\
    \ n 2) ppp]\n      [else (loop (- n 1)\n                  (+ p pp ppp)\n     \
    \             p\n                  pp)])))\n", "  (define (fibfib-nth-tail n first\
    \ second third)\n    (cond\n      [(= n 0) first]\n      [(= n 1) second]\n  \
    \    [(= n 2) third]\n      [else (fibfib-nth-tail (- n 1) second third (+ first\
    \ second third))]))\n  (fibfib-nth-tail n 0 0 1))\n", "  (define (helper n acc1\
    \ acc2 acc3)\n    (cond [(= n 0) acc1]\n          [(= n 1) acc2]\n          [(=\
    \ n 2) acc3]\n          [else (helper (- n 1) acc2 acc3 (+ acc1 acc2 acc3))]))\n\
    \  (helper n 0 0 1))\n", "  (define (fibfib-iter a b c n)\n    (if (zero? n)\n\
    \        a\n        (fibfib-iter b c (+ a b c) (- n 1))))\n  (fibfib-iter 0 0\
    \ 1 n))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n \
    \       (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", " \
    \ (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond\n    [(=\
    \ n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n\
    \    [(= n 2) 1]\n    [else\n     (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\
    \ ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (define (fibfib-iter curr\
    \ prev1 prev2 prev3)\n    (if (= curr n)\n        prev1\n        (fibfib-iter\
    \ (+ curr 1) (+ prev1 prev2 prev3) prev1 prev2)))\n  (fibfib-iter 0 0 0 1))\n",
  "  (if (< n 3)\n      (if (= n 0)\n          0\n          1)\n      (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (cond\n    [(= n 0) 0]\n \
    \   [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))]))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n       \
    \ ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n\
    \ 3))))))\n", "  (define (fibfib-helper n prev-prev-num prev-num cur-num)\n  \
    \  (if (= n 1)\n        0\n        (if (= n 2)\n            1\n            (if\
    \ (= n 3)\n                cur-num\n                (fibfib-helper (- n 1) prev-num\
    \ cur-num (+ prev-prev-num prev-num cur-num))))))\n  (fibfib-helper n 0 0 1))",
  "  (fibfib-helper n 0 1 0))\n", "  (if (= n 0)\n      0\n      (if (= n 1)\n   \
    \       0\n          (if (= n 2)\n              1\n              (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n", "  (define (fibfib-helper a\
    \ b c n)\n    (cond\n      [(zero? n) a]\n      [(= n 1) b]\n      [(= n 2) c]\n\
    \      [else (fibfib-helper b c (+ a b c) (- n 1))]))\n  (fibfib-helper 0 0 1\
    \ n))\n", "  (define (aux a b c n)\n    (if (&lt;= n 2) \n        c\n        (aux\
    \ b c (+ b c a) (- n 1))))\n  (aux 0 0 1 n))\n</code>\nI know that there are many\
    \ ways to write the auxiliary function. Some of them are more elegant and efficient.\
    \ But I am interested in the <code>define</code> part. \nIs there any way to write\
    \ the <code>define</code> part in a way that it has only one parameter to make\
    \ the function call simpler?\n\n\nA:\n\nSince the <code>fibfib</code> sequence\
    \ is fixed and finite, you can pre-compute it and later just reference the correct\
    \ position from a list. This is a common optimization:\n<code>(define fibfib-list\
    \ (list 0 0 1 2 4 7 13 24 44 80 149 274 504 927 1705 3136 5885 10946 20341 37442\
    \ 69883 131328 243359 452889 842248 1579643 2924894 5419351 10019588 18539871\
    \ 34336871 63726128 118134213 218655064 407397032 757987637 1410989879 2633906815\
    \ 4882656503 9071339654 16896017027 31594517670 58732713941 108839116072 202361728113\
    \ 376894756465 698878275548 1292129752013 2395007035461 4429574089180 8181548534661\
    \ 15158847024741 28114427904872 52295966353613 96914102702425 180151270742028\
    \ 331854558486585 614779819437080 1134254739368805 2104756532836905 3919243265770790\
    \ 7272401418637875 13544958824364850 25189434645002575 46523371728368420 86576705374291095\
    \ 161529372652659670 299594047056950345 557548623952629220 1037100286909299745\
    \ 1934254256865898070 3595722941424885845 66922955809497717", "  (define (fibfib-iter\
    \ n prev1 prev2 prev3)\n    (cond [(= n 0) 0]\n          [(= n 1) 0]\n       \
    \   [(= n 2) 1]\n          [else (+ prev1 (+ prev2 prev3))]))\n  (fibfib-iter\
    \ n 0 0 1))\n", "  (define (fibfib-helper x y z counter max)\n    (if (= counter\
    \ max)\n        x\n        (fibfib-helper y z (+ x y z) (+ counter 1) max)))\n\
    \  (fibfib-helper 0 0 1 0 n))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n\
    \        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (if (< n 2)\n      n\n      (+ 1 (fibfib (- n 1))\n    \
    \     (fibfib (- n 2))\n         (fibfib (- n 3)))))\n\n", "  (define (fibfib-helper\
    \ n0 n1 n2 acc)\n    (if (equal? n acc)\n      n2\n      (fibfib-helper n1 n2\
    \ (+ n0 n1 n2) (+ acc 1))))\n  (fibfib-helper 0 0 1 0))\n", "  (letrec ([n-1 (lambda\
    \ (n) (fibfib (- n 1)))]\n           [n-2 (lambda (n) (fibfib (- n 2)))]\n   \
    \        [n-3 (lambda (n) (fibfib (- n 3)))])\n    (cond [(zero? n) 0]\n     \
    \     [(= n 1) 0]\n          [(= n 2) 1]\n          [else (+ (n-1 n) (n-2 n) (n-3\
    \ n))])))\n", "  (define (fibfib-iter n prev-prev-val prev-val cur-val)\n    (if\
    \ (zero? n)\n        cur-val\n        (fibfib-iter (- n 1) prev-val cur-val (+\
    \ prev-prev-val prev-val cur-val))))\n  (fibfib-iter n 0 0 1))\n", "  (if (= n\
    \ 0)\n      0\n      (if (= n 1)\n          0\n          (if (= n 2)\n       \
    \       1\n              (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n",
  "  (if (or (equal? n 0) (equal? n 1))\n      0\n      (if (equal? n 2)\n       \
    \   1\n          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n",
  "  (letrec ([fibfib-rec (lambda (n a b c)\n                         (cond [(= n\
    \ 0) a]\n                               [(= n 1) b]\n                        \
    \       [(= n 2) c]\n                               [else (fibfib-rec (- n 1)\
    \ b c (+ a b c))]))])\n    (fibfib-rec n 0 0 1)))\n", "  (if (< n 3)\n      (if\
    \ (= n 0)\n          0\n          1)\n      (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))))\n", "    (cond\n        [(< n 0) 0]\n        [(= n 0) 0]\n\
    \        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (define (fibfib-inner counter prev-prev\
    \ prev curr)\n    (if (= counter n)\n        curr\n        (fibfib-inner (+ counter\
    \ 1) prev curr (+ prev-prev prev curr))))\n  (fibfib-inner 0 0 0 1))\n", "  (cond\
    \ ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond [(= n 0) 0]\n  \
    \      [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (define (helper current next next-next\
    \ count)\n    (if (= count n)\n        current\n        (helper next (+ current\
    \ next next-next) current (+ count 1))))\n  (helper 0 0 1 0))\n</code>\nWhat I\
    \ have done so far:\n<code>#lang racket\n", "  (define (fibfib-iter n a b c)\n\
    \    (cond ((= n 0) a)\n          ((= n 1) b)\n          ((= n 2) c)\n       \
    \   (else (fibfib-iter (- n 1) b c (+ a b c)))))\n  (fibfib-iter n 0 0 1))\n</code>\n\
    I would like to know whether this is a good way to solve this problem.\nThanks.\n\
    \n\nA:\n\nYou can use a list of three variables instead of three distinct variables\
    \ and reduce your code to one line, plus a local definition:\n<code>(define (fibfib\
    \ n)\n  (define (fibfib-iter n prev)\n    (cond ((&lt; n 3) (list-ref prev (-\
    \ n 1)))\n          (else (fibfib-iter (- n 1) (list (+ (list-ref prev 0)\n  \
    \                                            (list-ref prev 1)\n             \
    \                                 (list-ref prev 2))\n                       \
    \                    (list-ref prev 0)\n                                     \
    \      (list-ref prev 1))))))\n  (fibfib-iter n '(0 0 1)))\n</code>\n", "  (define\
    \ (lookup n cache)\n    (if (not (zero? n))\n        (let ([n-1 (sub1 n)])\n \
    \         (if (not (zero? n-1))\n              (if (not (zero? (sub1 n-1)))\n\
    \                  (if (not (zero? (sub1 (sub1 n-1))))\n                     \
    \ (let ([value (add1 (add1 (add1 (lookup (sub1 n-1) cache) (lookup (sub1 (sub1\
    \ n-1)) cache) (lookup (sub1 (sub1 (sub1 n-1))) cache))))])\n                \
    \        (hash-set! cache n value)\n                        value)\n         \
    \             1)\n                  1)\n              0)\n            0))\n  \
    \      (hash-set! cache n 0)\n        0))\n  (lookup n (make-hash)))\n", "  (if\
    \ (< n 2)\n      0\n      (if (= n 2)\n          1\n          (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (if (= n 0)\n      0\n    \
    \  (if (= n 1)\n          0\n          (if (= n 2)\n              1\n        \
    \      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n", "    (fibfibh\
    \ n 0 1 0))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n\
    \        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", " \
    \ (if (< n 3)\n      (if (zero? n) 0 1)\n      (+ (fibfib (- n 1)) (fibfib (-\
    \ n 2)) (fibfib (- n 3)))))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n \
    \   [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (if (< n 3)\n      (if (= n 0)\n          0\n          1)\n      (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (cond [(= n 0) 0]\n      \
    \  [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))", "  (define (helper a b c n)\n    (if (= n 0)\n\
    \        a\n        (helper b c (+ a b c) (- n 1))))\n  (helper 0 0 1 n))\n",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if (< n 2)\n      0\n\
    \      (if (= n 2)\n          1\n          (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3))))))\n", "  (define (internal fibfib-minus-2 fibfib-minus-1\
    \ fibfib-minus-0 n)\n    (if (= n 0) fibfib-minus-2\n        (internal fibfib-minus-1\
    \ fibfib-minus-0 (+ fibfib-minus-2 fibfib-minus-1 fibfib-minus-0) (- n 1))))\n\
    \  (internal 0 0 1 n))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n       \
    \ [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n\
    \ 3)))]))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n\
    \        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))", " \
    \ (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (if (&lt; n 3)\n\
    \      (if (= n 2) 1 0)\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (-\
    \ n 3)))))\n</code>\nThere are two problems with this:\n\nIt's terribly inefficient.\
    \ The function <code>fibfib</code> is recursively called many times with the same\
    \ argument. Hence, it's inefficient to keep on repeating the same calculation\
    \ multiple times.\nThe function <code>fibfib</code> is not tail-recursive. In\
    \ Racket, it is possible to write recursive functions with a constant amount of\
    \ stack space, which makes a big difference in performance.\n\nThe first problem\
    \ can be resolved by keeping an association list of already computed values. This\
    \ list is updated each time a new value is computed.\n<code>#lang racket\n", " \
    \ (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond ((= n 0) 0)\n  \
    \      ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n```", "  (let ([get-fib (lambda (n)\n       \
    \            (if (< n 2)\n                       0\n                       (let\
    \ ([get-fib (lambda (n)\n                                        (if (< n 2)\n\
    \                                            1\n                             \
    \               (+ (get-fib (- n 1)) (get-fib (- n 2)))))]\n                 \
    \            (get-fib n))))])\n    (if (< n 3)\n        (get-fib n)\n        (+\
    \ (get-fib (- n 1)) (get-fib (- n 2)) (get-fib (- n 3))))))\n", "  (if (< n 3)\n\
    \      (if (= n 1)\n          0\n          1)\n      (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))))\n", "  (cond [(equal? n 0) 0]\n        [(equal?\
    \ n 1) 0]\n        [(equal? n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n\
    \        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3))))))\n```\n\n## Challenge #10 : Sum of a lot of numbers\n\n```#lang\
    \ racket\n", "  (cond\n    [(zero? n) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n \
    \   [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n</code>\n\
    My question is, what is the big-O of fibfib?\n\n\nA:\n\nBig-O notation is the\
    \ way to describe the upper bound of your algorithm, i.e. the worst case. Big-O\
    \ notation ignores constants.\nYou can say that your algorithm is O(3^n) because\
    \ it is a product of three recursive calls in the worst case (this is a little\
    \ bit wrong, but I'll explain it later). The 3^n also ignores constants.\nIn this\
    \ problem, the branching is the same on all levels. As the number of recursive\
    \ calls increases, the branching factor increases as well.\nNow, let's return\
    \ to the little bit wrong thing about 3^n bound. Actually, when the number of\
    \ calls is less than 3, branching factor is less than 3. So, it's more like O(n*3^n)\n",
  "  (cond [(zero? n) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else\n\
    \         (+ (fibfib (- n 1))\n            (fibfib (- n 2))\n            (fibfib\
    \ (- n 3)))]))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2)\
    \ 1]\n        [else\n         (+ (fibfib (- n 1))\n            (fibfib (- n 2))\n\
    \            (fibfib (- n 3)))]))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n\
    \        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (if (equal? n 0)\n      0\n      (if (equal? n 1)\n    \
    \      0\n          (if (equal? n 2)\n              1\n              (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n", "  (cond [(= n 0) 0]\n \
    \       [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n\
    \        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2)\
    \ 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n\
    </code>\nThe first problem is that I tried to convert it to Python and I got stuck.\
    \ This is what I have so far:\n<code>&gt;&gt;&gt; def fibfib(n):\n...     if n\
    \ == 0:\n...         return 0\n...     elif n == 1:\n...         return 0\n...\
    \     elif n == 2:\n...         return 1\n...     else:\n...         return fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3)\n... \n&gt;&gt;&gt; fibfib(1)\n0\n&gt;&gt;&gt; fibfib(5)\n\
    4\n&gt;&gt;&gt; fibfib(8)\n24\n</code>\nThe second problem is that the Python\
    \ code take a long time to execute. For example: <code>fibfib(25)</code> takes\
    \ about 8 seconds to execute. I did a little research and found that Fibonacci\
    \ numbers are normally calculated with memoization which basically remembers values\
    \ that were previously calculated and reuses them, thus making the calculation\
    \ much faster. The problem is that I don't know how to implement memoization in\
    \ Python.\n\n\nA:\n\n<code>def fibfib(n):\n    if n == 0:\n        return 0\n\
    \    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    n, n1,\
    \ n2 = n-1, 0, 1\n    while n:\n        n, n1, n2 = n-1, n2, n1+n2+n2\n    return\
    \ n2\n</code>\nThis is a bit long-winded, but the <code>fibfib(1)</code> call\
    \ can be eliminated, and the <code>fibfib(2)</code> call can be reduced to a single\
    \ branch.\n<code>def fibfib(n):\n   ", "  (cond\n    [(= n 0) 0]\n    [(= n 1)\
    \ 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2)\
    \ 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))",
  "  (define (fibfib-helper n a b c)\n    (if (= n 0)\n        a\n        (fibfib-helper\
    \ (- n 1) b c (+ a b c))))\n  (fibfib-helper n 0 0 1))\n", "  (cond\n    [(= n\
    \ 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (define (f n)\n    (cond [(= n 0) 0]\n\
    \          [(= n 1) 0]\n          [(= n 2) 1]\n          [else (+ (f (- n 1))\
    \ (f (- n 2)) (f (- n 3)))]))\n  (f n))\n", "  (cond ((= n 0) 0)\n        ((=\
    \ n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3))))))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n  \
    \  [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (define (helper n a b c)\n    (if (= n 0) a\n        (if (= n 1) b\n        \
    \    (if (= n 2) c\n                (helper (- n 1) b c (+ a b c))))))\n  (helper\
    \ n 0 0 1))\n", "  (if (< n 3)\n      n\n      (+ (fibfib (- n 1)) (fibfib (-\
    \ n 2)) (fibfib (- n 3)))))\n", "  (define (helper n1 n2 n3)\n    (cond ((= n\
    \ 0) n1)\n          ((= n 1) n2)\n          ((= n 2) n3)\n          (else (helper\
    \ n2 n3 (+ n1 n2 n3)))))\n  (helper 0 0 1))", "  (cond [(= n 0) 0]\n        [(=\
    \ n 1) 0]\n        [(= n 2) 1]\n        [else\n         (+ (fibfib (- n 1))\n\
    \            (fibfib (- n 2))\n            (fibfib (- n 3)))]))\n", "  (define\
    \ (fibfib-iter a b c count)\n    (if (= count n)\n        a\n        (fibfib-iter\
    \ b c (+ a b c) (+ count 1))))\n  (if (< n 3)\n      (if (= n 1)\n          0\n\
    \          1)\n      (fibfib-iter 0 0 1 3)))\n", "  (define (fibfib-helper a b\
    \ c n)\n    (cond ((zero? n) a)\n          ((zero? (- n 1)) b)\n          ((zero?\
    \ (- n 2)) c)\n          (else (fibfib-helper b c (+ a b c) (- n 1)))))\n  (fibfib-helper\
    \ 0 0 1 n))\n```\n\n## Binary Search Trees\n\n### In-order traversal:\n```racket",
  "  (if (or (equal? n 0) (equal? n 1))\n      0\n      (if (equal? n 2)\n       \
    \   1\n          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else\n     (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n\n", "  (letrec ([fibfib0\
    \ (lambda (n)\n                      (cond\n                        [(= n 0) 0]\n\
    \                        [(= n 1) 0]\n                        [(= n 2) 1]\n  \
    \                      [else (+ (fibfib0 (- n 1)) (fibfib0 (- n 2)) (fibfib0 (-\
    \ n 3)))]))])\n    (fibfib0 n)))\n", "  (define (fib-iter a b c count)\n    (if\
    \ (= count 0)\n        a\n        (fib-iter b c (+ a b c) (- count 1))))\n  (fib-iter\
    \ 0 0 1 n))\n", "  (let f\n      ((i 1)\n       (x 0)\n       (y 0)\n       (z\
    \ 1))\n    (if (= i n)\n        z\n        (f (+ i 1) z y z))))\n", "  (if (<\
    \ n 3)\n      (if (zero? n)\n          0\n          1)\n      (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (let ([a 0] [b 0] [c 1])\n \
    \   (for ([i (in-range n)])\n      (set! a b)\n      (set! b c)\n      (set! c\
    \ (+ a b c)))\n    a))\n", "  (cond [(zero? n) 0]\n        [(= n 1) 0]\n     \
    \   [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (-\
    \ n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))", "  (define\
    \ (f n)\n    (cond ((= n 0) 0)\n          ((= n 1) 0)\n          ((= n 2) 1)\n\
    \          (else (+ (f (- n 1)) (f (- n 2)) (f (- n 3))))))\n  (f n))", "  (define\
    \ (f n)\n    (cond\n      [(= n 0) 0]\n      [(= n 1) 0]\n      [(= n 2) 1]\n\
    \      [else (+ (f (- n 1)) (f (- n 2)) (f (- n 3)))]))\n  (f n))\n", "  (define\
    \ a 1)\n  (define b 1)\n  (define c 0)\n  (for ([i (in-range (- n 3))])\n    (define\
    \ c (add1 (add a b)))\n    (set! a b)\n    (set! b c))\n  c)\n", "  (if (= n 0)\n\
    \      0\n      (if (= n 1)\n          0\n          (if (= n 2)\n            \
    \  1\n              (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n",
  "  (if (< n 3)\n      (if (= n 0)\n          0\n          1)\n      (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (if (= n 0)\n      0\n   \
    \   (if (= n 1)\n          0\n          (if (= n 2)\n              1\n       \
    \       (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n", "  (cond\n\
    \    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond ((= n 0) 0)\n       \
    \ ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))", "  (define (fibfib-helper a b c n)\n    (if\
    \ (= n 0) 0\n        (if (= n 1) a\n            (if (= n 2) b\n              \
    \  (fibfib-helper b c (+ a b c) (- n 1))))))\n  (fibfib-helper 0 0 1 n))\n", " \
    \ (if (or (= n 0) (= n 1))\n      0\n      (if (= n 2)\n          1\n        \
    \  (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond [(=\
    \ n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (define (fibfib-iter a\
    \ b c n)\n    (if (= n 1)\n        a\n        (fibfib-iter b c (+ a b c) (- n\
    \ 1))))\n  (fibfib-iter 0 0 1 n))\n", "  (define (fibfib-iter n a b c)\n    (cond\n\
    \      [(= n 0) a]\n      [(= n 1) b]\n      [(= n 2) c]\n      [else (fibfib-iter\
    \ (- n 1) b c (+ a b c))]))\n  (fibfib-iter n 0 0 1))\n", "  (cond ((< n 2) n)\n\
    \        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3))))))\n", "  (if (< n 3)\n      (if (= n 0)\n          0\n          1)\n\
    \      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (define\
    \ (fibfib-iter fp fn fprev i)\n    (if (= i n) fn\n        (fibfib-iter fn (+\
    \ fp fn fprev) fp (+ i 1))))\n  (fibfib-iter 0 0 1 0))\n", "  (cond\n    [(= n\
    \ 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else\n     (+ (fibfib (- n 1))\
    \ (fibfib (- n 2)) (fibfib (- n 3)))]))\n</code>\nCan someone point out what am\
    \ I doing wrong? I just want to know why this isn't working. I am new to Scheme\
    \ and Racket, so I am sorry if I am missing something obvious.\n\n\nA:\n\nI think\
    \ you want something like this (using a <code>for/fold</code> to keep track of\
    \ the previous values, this is inefficient and not as 'functional' but it works):\n\
    <code>(define (fibfib n)\n  (for/fold ([a 0] [b 0] [c 1]) ([i (in-range n)])\n\
    \    (set! a b)\n    (set! b c)\n    (set! c (+ a b c))\n    c))\n</code>\n",
  "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (if (or (equal?\
    \ n 0) (equal? n 1))\n      0\n      (if (equal? n 2)\n          1\n         \
    \ (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond [(zero?\
    \ n) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (define (fibfib-impl n acc1\
    \ acc2 acc3)\n    (if (= n 0)\n        acc1\n        (fibfib-impl (- n 1) acc2\
    \ acc3 (+ acc1 acc2 acc3))))\n  (fibfib-impl n 0 0 1))\n", "  (if (< n 3)\n  \
    \    (if (= n 1) 0\n          1)\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))))\n", "  (cond\n    [(zero? n) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if\
    \ (< n 3)\n      (if (= n 1) 0\n        1)\n      (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))))\n", "  (define (helper n curr prev1 prev2)\n  \
    \  (cond ((= n 0) prev2)\n          ((= n 1) prev1)\n          ((= n 2) curr)\n\
    \          (else (helper (- n 1) (+ curr prev1 prev2) curr prev1))))\n  (helper\
    \ n 1 0 0))\n", "  (if (&lt; n 3)\n      (if (= n 0)\n          0\n          1)\n\
    \      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n</code>\n", " \
    \ (if (eq? n 0)\n      0\n      (if (eq? n 1)\n          0\n          (if (eq?\
    \ n 2)\n              1\n              (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))))))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if\
    \ (< n 3)\n      (if (= n 0)\n          0\n          1)\n      (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (cond\n    [(= n 0) 0]\n   \
    \ [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))]))\n</code>\nI guess my main complaint here is that this code\
    \ actually performs the computation - it doesn't just return a lazy stream, which\
    \ seems the natural way to do this sort of thing in Racket.\nHere's my attempt\
    \ at a solution:\n<code>#lang racket\n", "  (if (and (positive? n) (<= n 2))\n\
    \      (sub1 n)\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n\
    ```\n\n#### 10.5\n\n``` #lang racket\n", "  (if (< n 3)\n      (if (zero? n)\n\
    \          0\n          1)\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))))\n", "  (define (fib-fib-helper n1 n2 n3 n)\n    (cond ((= n 0) n1)\n\
    \          ((= n 1) n2)\n          ((= n 2) n3)\n          (else (fib-fib-helper\
    \ n2 n3 (+ n1 n2 n3) (- n 1)))))\n  (fib-fib-helper 0 0 1 n))\n", "  (define (seq\
    \ n)\n    (cond ((= n 0) 0)\n          ((= n 1) 0)\n          ((= n 2) 1)\n  \
    \        (else (+ (seq (- n 1)) (seq (- n 2)) (seq (- n 3))))))\n  (seq n))\n",
  "  (let loop ([n n] [prev0 0] [prev1 0] [prev2 1])\n    (cond\n      [(= n 0) prev0]\n\
    \      [(= n 1) prev1]\n      [(= n 2) prev2]\n      [else (loop (- n 1)\n   \
    \               (+ prev0 prev1 prev2)\n                  prev0\n             \
    \     prev1)])))\n", "  (cond [(equal? n 0) 0]\n        [(equal? n 1) 0]\n   \
    \     [(equal? n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if\
    \ (< n 2)\n      n\n      (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n   \
    \      (fibfib (- n 3)))))", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n     \
    \   [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (-\
    \ n 3)))]))\n", "  (define (fibfib-helper n prev1 prev2 prev3)\n    (cond\n  \
    \    [(< n 0) (error \"n cannot be negative\")]\n      [(< n 3) 0]\n      [(=\
    \ n 3) 1]\n      [else (+ prev1 prev2 prev3)]))\n  (fibfib-helper n 0 0 1))",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond ((= n 0) 0)\n  \
    \      ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n\
    \        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2)\
    \ 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n\
    \n", "  (cond [(zero? n) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n      \
    \  [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if\
    \ (< n 3)\n      n\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n",
  "  (define (fibiter a b c count)\n    (if (= count n)\n        a\n        (fibiter\
    \ b c (+ b c a) (+ count 1))))\n  (fibiter 0 0 1 1))", "  (define (fibfib-iter\
    \ a b c n)\n    (if (= n 0)\n        a\n        (fibfib-iter b c (+ c a b) (-\
    \ n 1))))\n  (fibfib-iter 0 0 1 n))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1)\
    \ 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n\n", "  (define (fibfib-iter n-1 n-2 n-3 count)\n    (if (= count\
    \ n)\n        (+ n-1 n-2 n-3)\n        (fibfib-iter (+ n-1 n-2 n-3) n-1 n-2 (+\
    \ count 1))))\n  (fibfib-iter 0 0 1 0))\n", "  (match n\n    [(0) 0]\n    [(1)\
    \ 0]\n    [(2) 1]\n    [(number?) (add3 (fibfib (sub1 n)) (fibfib (sub2 n)) (fibfib\
    \ (sub3 n)))]))\n", "  (let loop ([n n] [a 0] [b 0] [c 1])\n    (cond [(zero?\
    \ n) a]\n          [(positive? n) (loop (- n 1) c (+ a b c) b)])))\n", "  (if\
    \ (= n 0)\n      0\n      (if (= n 1)\n          0\n          (if (= n 2)\n  \
    \            1\n              (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (-\
    \ n 3)))))))\n", "  (if (< n 2) 0\n      (if (< n 3) 1\n          (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond\n    [(= n 0) 0]\n\
    \    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3)))]))\n", "  (cond\n    [(equal? n 0) 0]\n    [(equal? n\
    \ 1) 0]\n    [(equal? n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))]))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n       \
    \ ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n\
    \ 3))))))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n  \
    \  [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "    (cond\
    \ ((= n 0) 0)\n          ((= n 1) 0)\n          ((= n 2) 1)\n          (else (+\
    \ (fibfib (- n 1))\n                   (fibfib (- n 2))\n                   (fibfib\
    \ (- n 3))))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2)\
    \ 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))",
  "  (if (< n 3)\n      (if (zero? n) 0 1)\n      (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3)))))\n", "  (define (aux a b c n)\n    (if (= n 0) 0\n  \
    \      (if (= n 1) 0\n            (if (= n 2) 1\n                (aux (+ a b c)\
    \ a b (- n 1))))))\n  (aux 1 0 0 n))\n", "  (cond\n    [(= n 0) 0]\n    [(= n\
    \ 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))", "  (if (or (= n 0) (= n 1))\n      0\n      (if (= n 2)\n   \
    \       1\n          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n",
  "  (if (< n 3)\n      (if (= n 0)\n          0\n          1)\n      (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))", "  (fibfib-helper 0 1 1 0 n))\n",
  "  (define (iter a b c n)\n    (if (zero? n)\n        a\n        (iter b c (+ a\
    \ b c) (- n 1))))\n  (iter 0 0 1 n))\n", "  (cond\n    [(= n 0) 0]\n    [(= n\
    \ 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n</code>\nThis seems to work for small values of n, but it is too\
    \ inefficient for larger values of n. I get the following message:\n<code>In c:\\\
    Users\\...\\Documents\\Racket\\Racket\\fibfib.rkt\n  [running body]\n  c:\\Users\\\
    ...\\Documents\\Racket\\Racket\\fibfib.rkt:11:12: call: out of memory\n</code>\n\
    How can I rewrite the recursive definition of the function to make it work for\
    \ larger values of n?\n\n\nA:\n\nRecursive calls work well for small n, but for\
    \ large n, you end up making a lot of calls to <code>fibfib</code> and a lot of\
    \ intermediate results get made. Memoization is a useful technique for doing this.\
    \ \nYour recursive calls can be rewritten by a function that takes a list of the\
    \ previous three results. \n<code>(define (fibfib-tracker lst)\n  (if (equal?\
    \ (length lst) 3)\n      (apply + lst)\n      (fibfib-tracker (cons (fibfib-tracker\
    \ (rest lst)) lst))))\n</code>\nThis seems to work up to n = 40, but goes out\
    \ of memory after that. The issue is that it re-makes <code>fibfib-tracker</code>\
    \ calls as it goes, the same way that your original recursive <code>fibfib</code>\
    \ call did. We can fix this by making a memoized version of fibfib-tracker. You\
    \ can do this by:\n<code>(define (memo f)\n  (let ([memo (make-hash)])\n    (lambda\
    \ args\n      (let ([old-result (hash-ref memo args #f)])\n        (if old-result\n\
    \            old-result\n            (let ([new-result (apply f args)])\n    \
    \          (hash-set! memo args new-result)", "  (if (or (= n 0) (= n 1))\n  \
    \    0\n      (if (= n 2)\n          1\n          (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n", "  (if (< n 3)\n      (if (= n 0)\n      \
    \    0\n          1)\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n\
    \ 3)))))", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n  \
    \      (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))", "  (cond\n\
    \    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else\n     (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n\n", "  (if (= n 0)\n      0\n\
    \      (if (= n 1)\n          0\n          (if (= n 2)\n              1\n    \
    \          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n", "  (cond\
    \ ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (define (fibfib-iter s0\
    \ s1 s2 n)\n    (cond ((= n 0) s0)\n          ((= n 1) s1)\n          ((= n 2)\
    \ s2)\n          (else (fibfib-iter s1 s2 (+ s0 s1 s2) (- n 1)))))\n  (fibfib-iter\
    \ 0 0 1 n))\n</code>\nMy question is if there is a better way to implement this.\
    \ I'm not fond of the repeated conditions.\n\n\nA:\n\nIf it is a sequence, you\
    \ should use a sequence.\n<code>(define (fibfib n)\n  (define fibfibs\n    (let\
    \ loop ([i 0] [current '(0 0 1)])\n      (cons current\n            (if (= i n)\n\
    \                null\n                (loop (add1 i)\n                      (cons\
    \ (apply + current)\n                            (rest current)))))))\n  (car\
    \ (nth fibfibs n)))\n</code>", "  (define (fib-iter a b c n)\n    (if (= n 1)\n\
    \        a\n        (fib-iter b c (+ a b c) (- n 1))))\n  (if (&lt; n 3)\n   \
    \   (if (= n 0)\n          0\n          1)\n      (fib-iter 0 1 1 (- n 2))))\n\
    </code>\nTest Case:\n<code>#lang racket\n", "  (cond [(= n 0) 0]\n        [(=\
    \ n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3)))]))", "  (define (fibfib-helper n a b c)\n    (if (= n\
    \ 1)\n        a\n        (fibfib-helper (- n 1) b c (+ c a b))))\n  (fibfib-helper\
    \ n 0 0 1))\n", "  (cond\n    [(< n 2) 0]\n    [(= n 2) 1]\n    [else\n     (+\
    \ (fibfib (- n 1))\n        (fibfib (- n 2))\n        (fibfib (- n 3)))]))\n",
  "  (cond\n    [(zero? n) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n\n", "  (if (< n 3)\n      (if\
    \ (= n 1) 0 n)\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))",
  "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (if (= n 0)\n\
    \      0\n      (if (= n 1)\n          0\n          (if (= n 2)\n            \
    \  1\n              (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n\
    </code>\nI've tested it with the examples given in the description and it seems\
    \ to work fine.  As you can see though, I don't find this very elegant.  I'm curious\
    \ if there is a better way to write it in Scheme.\n\n\nA:\n\nI agree with @phils'\
    \ answer (and I like the comment, too), but if you want a slightly more elegant\
    \ solution in the traditional style:\n<code>(define (fibfib n)\n  (if (or (= n\
    \ 0) (= n 1))\n      0\n      (if (= n 2)\n          1\n          (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n</code>\n", "  (if (or (= n 0)\
    \ (= n 1))\n      0\n      (if (= n 2)\n          1\n          (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (define (fibfib-iter a b c\
    \ n)\n    (if (= n 1) a\n        (fibfib-iter b c (+ c b a) (- n 1))))\n  (fibfib-iter\
    \ 0 0 1 n))\n", "  (if (< n 3)\n      (if (zerop n) 0 1)\n      (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (define (fibfib-helper a b\
    \ c n)\n    (if (= n 0)\n        a\n        (fibfib-helper b c (+ a b c) (- n\
    \ 1))))\n  (fibfib-helper 0 0 1 n))\n", "  (cond\n    [(zero? n) 0]\n    [(one?\
    \ n) 0]\n    [(two? n) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2)\
    \ 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n",
  "  (letrec ([fibfib-inner (lambda (n-1 n-2 n-3 count)\n                        \
    \   (if (= count n)\n                               n-1\n                    \
    \           (fibfib-inner (+ n-1 n-2 n-3) n-1 n-2 (+ count 1))))])\n    (fibfib-inner\
    \ 0 0 1 0)))\n", "  (define (fibfib-iter n a b c)\n    (cond [(= n 0) a]\n   \
    \       [(= n 1) b]\n          [(= n 2) c]\n          [else (fibfib-iter (- n\
    \ 1) b c (+ a b c))]))\n  (fibfib-iter n 0 0 1))\n", "    (define (fibfib-iter\
    \ n a b c)\n        (cond\n            [(= n 0) a]\n            [(= n 1) b]\n\
    \            [(= n 2) c]\n            [else (fibfib-iter (- n 1) b c (+ a b c))]))\n\
    \    (fibfib-iter n 0 0 1))", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n   \
    \ [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if (= n 0)\n      0\n\
    \      (let loop ([n n] [a 0] [b 0] [c 1])\n        (if (= n 1)\n            c\n\
    \            (loop (- n 1) c (+ a b c) b)))))\n", "  (define (aux n)\n    (cond\
    \ [(= n 0) 0]\n          [(= n 1) 0]\n          [(= n 2) 1]\n          [else (+\
    \ (aux (- n 1)) (aux (- n 2)) (aux (- n 3)))]))\n  (aux n))\n", "  (fibfib-helper\
    \ n 0 1 2))\n", "  (define (fibfib-recur a b c n)\n    (if (= n 0)\n        a\n\
    \        (fibfib-recur b c (+ a b c) (- n 1))))\n  (fibfib-recur 0 0 1 n))\n```\n\
    \n```javascript\n// The fibfib function returns the nth element of a sequence\
    \ that's like the Fibonacci sequence but with a starting sequence of 0, 0, 1 instead\
    \ of 0, 1. The 0th element is 0, the 1st element is 0, the 2nd element is 1, and\
    \ subsequent elements are the sum of the three elements before them.\n\n// Examples\n\
    \n// fibfib(0) \u279E 0\n\n// fibfib(1) \u279E 0\n\n// fibfib(2) \u279E 1\n\n\
    // fibfib(8) \u279E 24\n// Notes\n\n// You can assume n will be a positive integer.\n\
    ```\n\n```javascript\nfunction fibfib(n) {\n\treturn n < 2 ? 0 : (n === 2 ? 1\
    \ : fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3));\n}\n```\n\n```coffeescript\n\
    # The fibfib function returns the nth element of a sequence that's like the Fibonacci\
    \ sequence but with a starting sequence of 0, 0, 1 instead of 0, 1. The 0th element\
    \ is 0, the 1st element is 0, the 2nd element is 1, and subsequent elements are\
    \ the sum of the three elements before them.\n\n# Examples\n\n# fibfib(0) \u279E\
    \ 0\n\n# fibfib(1) \u279E 0\n\n# fibfib(2) \u279E 1\n\n# fibfib(8) \u279E 24\n\
    # Notes\n\n# You can assume n will be a positive integer.\n```\n\n```fsharp\n\
    let fibfib n =\n  let rec recur a b c n =\n    if n = 0 then a\n    else recur\
    \ b c (a + b + c) (n - 1)\n  recur 0 0 1 n\n```\n\n```kotlin\n// The fib"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
