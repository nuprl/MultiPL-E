name: HumanEval_85_add
language: rkt
prompt: "#lang racket\n\n;; Given a non-empty list of integers lst. add the even elements\
  \ that are at odd indices..\n;; Examples:\n;; >>> (add (list 4 2 6 7))\n;; 2\n(define\
  \ (add lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add))\n\
  \    (check-equal? (candidate (list 4 88)) 88)\n    (check-equal? (candidate (list\
  \ 4 5 6 7 2 122)) 122)\n    (check-equal? (candidate (list 4 0 6 7)) 0)\n    (check-equal?\
  \ (candidate (list 4 4 6 8)) 12)\n))\n\n(test-humaneval)"
completions: ["  (sum-only-by\n   (\u03BB (x) (even? x))\n   (\u03BB (x) (odd? x))\n\
    \   lst))\n", "  ;; body\n  (let ([lst (filter odd? (range 1 (add1 (length lst))))])\n\
    \    (for/sum ([i lst])\n      (list-ref lst i))))\n", "  (cond [(empty? lst)\
    \ 0]\n        [(even? (first lst)) (+ (first lst) (add (rest lst)))]\n       \
    \ [else (add (rest lst))]))\n", "  (define (helper cur-index sum)\n    (cond\n\
    \      [(empty? lst) sum]\n      [(= 1 (remainder cur-index 2))\n       (helper\
    \ (+ cur-index 1) (+ sum (first lst)))]\n      [else (helper (+ cur-index 1) sum)]))\n\
    \  (helper 1 0))\n", "  (let go ([lst lst] [acc 0])\n    (if (null? lst)\n   \
    \     acc\n        (go (cdr lst) (+ (car lst) acc)))))\n", "  ;;\n  (cond\n  \
    \  [(empty? lst) 0]\n    [(even? (first lst)) (+ (first lst) (add (rest lst)))]\n\
    \    [else (add (rest lst))]))\n", "  (cond\n    [(= (length lst) 1) (car lst)]\n\
    \    [(= (modulo (modulo (add-1 (length lst)) 2) 2) 0) (add-even-odds (cdr lst))]\n\
    \    [else (+ (car lst) (add-even-odds (cdr lst)))]))\n", "  (if (= 0 (length\
    \ lst))\n      0\n      (cond\n        [(= 0 (remainder (car lst) 2))\n      \
    \   (car lst)]\n        [else\n         0])\n      (+ (add (cdr lst)) (car lst))))\n\
    </code>\n", "  (cond [(empty? lst) 0]\n        [(even? (car lst)) (+ (car lst)\
    \ (add (cdr lst)))]\n        [else (add (cdr lst))]))\n", "  (if (null? lst)\n\
    \      0\n      (if (null? (cdr lst))\n          (car lst)\n          (if (odd?\
    \ (car lst))\n              (car lst)\n              0))))\n", "  (define (go\
    \ lst sum)\n    (cond\n      [(empty? lst) sum]\n      [(and (even? (car lst))\
    \ (odd? (length lst))) (go (cdr lst) (+ sum (car lst)))]\n      [else (go (cdr\
    \ lst) sum)]))\n  (go lst 0))\n", "  (cond\n    [(= 1 (length lst)) (car lst)]\n\
    \    [(even? (car lst)) (+ (car lst) (add (cdr lst)))]\n    [else (add (cdr lst))]))\n\
    \n```\n\n```racket\n#lang racket\n", "  (if (empty? lst)\n      0\n      (if (odd?\
    \ (remainder (length lst) 2))\n          (+ (car lst) (add (cdr lst)))\n     \
    \     (add (cdr lst)))))\n", "  (define (adder accum i lst)\n    (if (null? lst)\n\
    \        accum\n        (if (odd? i)\n            (adder (+ accum (car lst)) (+\
    \ i 1) (cdr lst))\n            (adder accum (+ i 1) (cdr lst)))))\n  (adder 0\
    \ 0 lst))\n", "  (define (helper lst accumulator count)\n    (cond ((null? lst)\
    \ accumulator)\n          ((even? count) (helper (cdr lst) (+ (car lst) accumulator)\
    \ (+ count 1)))\n          (else (helper (cdr lst) accumulator (+ count 1)))))\n\
    \  (helper lst 0 0))\n", "  (cond [(null? lst) 0]\n        [(odd? (car lst))\n\
    \         (add (cdr lst))]\n        [else (+ (car lst) (add (cdr lst)))]))\n",
  "  (if (null? lst)\n      0\n      (if (even? (list-ref lst 0))\n          (+ (list-ref\
    \ lst 0) (add (rest lst)))\n          (add (rest lst)))))\n```\n\n4. Consider\
    \ the function `(define (fact n) (if (= n 0) 1 (* n (fact (- n 1)))))` which computes\
    \ the factorial of `n`. When `n` becomes large, the evaluation of `(fact n)` causes\
    \ a stack overflow. Rewrite `fact` to use tail recursion.\n\n```racket", "  (foldl\
    \ (lambda (x acc)\n           (if (and (even? x) (odd? (length acc)))\n      \
    \         (cons x acc)\n               acc))\n         (list)\n         lst))\n",
  "  (define (loop lst count sum)\n    (cond [(empty? lst) sum]\n          [(even?\
    \ count) (loop (rest lst) (+ count 1) (+ sum (first lst)))]\n          [else (loop\
    \ (rest lst) (+ count 1) sum)]))\n  (loop lst 0 0))\n</code>\n", "  (define (add-iter\
    \ tlst cur-ind sum)\n    (cond [(empty? tlst) sum]\n          [(even? cur-ind)\
    \ (add-iter (rest tlst) (add1 cur-ind) (+ sum (first tlst)))]\n          [else\
    \ (add-iter (rest tlst) (add1 cur-ind) sum)]))\n  (add-iter lst 0 0))\n</code>\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
