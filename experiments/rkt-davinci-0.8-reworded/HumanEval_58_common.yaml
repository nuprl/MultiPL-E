name: HumanEval_58_common
language: rkt
prompt: "#lang racket\n\n;; Return sorted unique common elements for two lists.\n\
  ;; >>> (common (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121))\n;; (list 1 5 653)\n\
  ;; >>> (common (list 5 3 2 8) (list 3 2))\n;; (list 2 3)\n(define (common l1 l2)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate common))\n\
  \    (check-equal? (candidate (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121))\
  \ (list 1 5 653))\n    (check-equal? (candidate (list 5 3 2 8) (list 3 2)) (list\
  \ 2 3))\n    (check-equal? (candidate (list 4 3 2 8) (list 3 2 4)) (list 2 3 4))\n\
  \    (check-equal? (candidate (list 4 3 2 8) (list )) (list ))\n))\n\n(test-humaneval)"
completions: ["  (sort (remove-duplicates (append l1 l2)) <))\n", "  (sort (foldr\
    \ intersetiort null l1) (\u03BB (a b) (&lt; a b))))\n", "  (sort (remove-duplicates\
    \ (intersection l1 l2)) <))\n", "  (sort (list-set (append l1 l2)) &lt;))\n",
  "  (sort (unique (append l1 l2)) <))\n", "  (define result (list))\n  (for ([x l1])\n\
    \    (for ([y l2])\n      (if (equal? x y)\n          (if (not (memq x result))\n\
    \              (set! result (cons x result))))))\n  (sort result <))\n", "  (sort\
    \ (list-set (list-intersect l1 l2)) #&lt;))\n", "  (sort (uniq (filter (lambda\
    \ (x) (member x l2)) l1)) <))\n", "  (if (null? l1) '()\n      (let ((rest (common\
    \ (cdr l1) l2)))\n        (if (member (car l1) l2)\n            (cons (car l1)\
    \ rest)\n            rest))))\n", "  (define all (append l1 l2))\n  (define uniq\
    \ (set all))\n  (sort uniq <))\n", "  (let ([l3 (append l1 l2)])\n    (define\
    \ (inner acc curr)\n      (cond\n        [(empty? acc)\n         (if (empty? l3)\n\
    \             acc\n             (inner (cons curr (list)) (car l3)))]\n      \
    \  [(eq? curr (car acc))\n         (inner acc (car l3))]\n        [(eq? curr (car\
    \ l3))\n         (inner (cons curr acc) (car l3))]\n        [else\n         (inner\
    \ acc (car l3))]))\n    (inner (list) (car l3))))\n", "  (sort (uniq (filter (\u03BB\
    \ (el) (member el l2)) l1)) <))\n", "  (sort (unique (append l1 l2)) <))\n", " \
    \ (sort (filter (\u03BB (x) (member x l2)) l1) <))\n", "  (sort (remove-duplicates\
    \ (append l1 l2)) <))\n", "  (let ((l1-set (list->set l1))\n        (l2-set (list->set\
    \ l2)))\n    (set-sort (set-intersect l1-set l2-set))))\n", "  (cond [(empty?\
    \ l1) empty]\n        [(empty? l2) empty]\n        [(empty? (filter (lambda (e)\
    \ (eq? e (first l1))) l2))\n         (common (rest l1) l2)]\n        [else (cons\
    \ (first l1) (common (rest l1) l2))]))\n", "  (sort (remove-duplicates (append\
    \ l1 l2)) <))\n", "  (sort (remq '() (map (lambda (x) (if (member x l2) x '()))\
    \ l1)) <))\n</code>\nWhich uses <code>sort</code> of <code>racket/list</code>\
    \ to sort the list by the <code>&lt;</code> comparator, or <code>quack</code>'s\
    \ own <code>list-sort</code> to do the same.\n", "  (set! l1 (sort l1 <))\n  (set!\
    \ l2 (sort l2 <))\n  (define (unique l)\n    (cond\n      [(null? l) '()]\n  \
    \    [(null? (cdr l)) l]\n      [(equal? (car l) (cadr l)) (unique (cdr l))]\n\
    \      [else (cons (car l) (unique (cdr l)))]))\n  (define (intersection l1 l2)\n\
    \    (cond\n      [(null? l1) '()]\n      [(null? l2) '()]\n      [(< (car l1)\
    \ (car l2)) (intersection (cdr l1) l2)]\n      [(> (car l1) (car l2)) (intersection\
    \ l1 (cdr l2))]\n      [else (cons (car l1) (intersection (cdr l1) (cdr l2)))]))\n\
    \  (unique (intersection l1 l2)))\n", "  (sort (remove-duplicates (append l1 l2))\
    \ <))\n", "  (sort (remove-duplicates (append l1 l2)) #&lt;))\n", "  (sort\n \
    \  (set-intersection\n    (list->set l1)\n    (list->set l2))\n   <))\n```\n\n\
    ```racket\n#lang racket\n", "  (cond [(empty? l1) (list)]\n        [(member (first\
    \ l1) l2) (cons (first l1) (common (rest l1) l2))]\n        [else (common (rest\
    \ l1) l2)]))\n", "  (sort (remove-duplicates (append l1 l2)) <))\n", "  (sort\
    \ (filter\n          (lambda (x) (memq x l2))\n          (remove-duplicates l1))\n\
    \        <))\n", "  (cond\n    ((and (null? l1) (null? l2)) (list))\n    ((null?\
    \ l1) (list))\n    ((null? l2) (list))\n    ((not (member (car l1) l2)) (common\
    \ (cdr l1) l2))\n    (else (cons (car l1) (common (cdr l1) l2)))))\n```", "  (let\
    \ ([u1 (remove-duplicates (sort l1 <))]\n        [u2 (remove-duplicates (sort\
    \ l2 <))])\n    (cond [(null? u1) (list)]\n          [(null? u2) (list)]\n   \
    \       [(= (car u1) (car u2)) (cons (car u1) (common (cdr u1) (cdr u2)))]\n \
    \         [(< (car u1) (car u2)) (common (cdr u1) u2)]\n          [else (common\
    \ u1 (cdr u2))])))\n", "  (sort (unique (append l1 l2)) <))\n", "  (sort (remove-duplicates\
    \ (intersection l1 l2)) &lt;))\n", "  (define (union l1 l2)\n    (if (null? l1)\
    \ l2\n        (if (null? l2) l1\n            (if (member (car l1) l2) (union (cdr\
    \ l1) l2)\n                (cons (car l1) (union (cdr l1) l2))))))\n  (define\
    \ (intersection l1 l2)\n    (if (null? l1) '()\n        (if (null? l2) '()\n \
    \           (if (member (car l1) l2) (cons (car l1) (intersection (cdr l1) l2))\n\
    \                (intersection (cdr l1) l2)))))\n  (sort (intersection l1 l2)\
    \ (lambda (x y) (< x y))))\n", "  (sort (uniq (intersect l1 l2)) <))\n", "  (define\
    \ x (set-intersection (list->set l1) (list->set l2)))\n  (sort x <))\n```\n\n\
    ```\n#lang racket\n", "  (sort (remove-duplicates (append l1 l2)) #&lt;))\n",
  "  (let* ([s1 (sort l1 (\u03BB (a b) (< a b)))]\n         [s2 (sort l2 (\u03BB (a\
    \ b) (< a b)))]\n         [l3 (list)]\n         [b (\u03BB (c) (member c l3))])\n\
    \    (for/list ([i s1]\n               [j s2])\n      (when (and (equal? i j)\
    \ (not (b i)))\n        (set! l3 (cons i l3))))\n    l3))\n", "  (define (common_aux\
    \ l1 l2)\n    (cond\n      [(empty? l1) '()]\n      [(member (first l1) l2) (cons\
    \ (first l1) (common_aux (rest l1) l2))]\n      [else (common_aux (rest l1) l2)]))\n\
    \  (sort < (common_aux l1 l2)))\n", "  (sort (remove-duplicates (filter (lambda\
    \ (x) (member x l2)) l1)) <))\n", "  (cond [(null? l1) '()]\n        [(null? l2)\
    \ '()]\n        [(member (car l1) l2) (cons (car l1) (common (cdr l1) l2))]\n\
    \        [else (common (cdr l1) l2)]))\n", "  (sort (unique (append l1 l2)) #<?))\n",
  "  (sort (for/set ([i (in-list l1)] [j (in-list l2)])\n          (if (member i l2)\n\
    \              i))\n        <))\n", "  (sort\n   (hash-set-map (lambda (e1 e2)\
    \ (if (member e1 l2) e1 '())) l1)\n   <))\n", "  (if (null? l1)\n      (list)\n\
    \      (if (null? l2)\n          (list)\n          (if (member (car l1) l2)\n\
    \              (cons (car l1) (common (cdr l1) l2))\n              (common (cdr\
    \ l1) l2)))))\n", "  (sort (unique (append l1 l2)) <))\n", "  (define (helper\
    \ l1 l2 acc)\n    (if (null? l1)\n        acc\n        (if (member (car l1) l2)\n\
    \            (helper (cdr l1) l2 (cons (car l1) acc))\n            (helper (cdr\
    \ l1) l2 acc))))\n  (sort (helper l1 l2 '()) <))\n```\n\n```scheme\n#lang racket\n",
  "  (sort\n   (list-set (list-union l1 l2))\n   <))\n", "  (cond [(empty? l1) empty]\n\
    \        [(member (first l1) l2) (cons (first l1) (common (rest l1) l2))]\n  \
    \      [else (common (rest l1) l2)]))\n</code>\n", "  (let ([u1 (remove-duplicates\
    \ (sort < l1))]\n        [u2 (remove-duplicates (sort < l2))])\n    (filter\n\
    \     (lambda (x) (member x u2))\n     u1)))\n", "  (remove-duplicates\n   (remove-duplicates\
    \ (append l1 l2) equal?) equal?))\n", "  (cond\n    [(empty? l1) '()]\n    [(empty?\
    \ l2) '()]\n    [(member (first l1) l2)\n     (cons (first l1) (common (rest l1)\
    \ l2))]\n    [else (common (rest l1) l2)]))\n", "  (define (inner l1 l2 o)\n \
    \   (cond [(empty? l1) o]\n          [(empty? l2) o]\n          [(member (first\
    \ l1) l2) (inner (rest l1) l2 (cons (first l1) o))]\n          [else (inner (rest\
    \ l1) l2 o)]))\n  (sort (inner l1 l2 (list)) <))\n", "  (cond\n    [(empty? l1)\
    \ empty]\n    [(member (first l1) l2) (cons (first l1) (common (rest l1) l2))]\n\
    \    [else (common (rest l1) l2)]))\n", "  (sort (unique (append l1 l2)) &lt;))\n",
  "  (sort\n   (remove-duplicates\n    (append l1 l2))\n   <))\n", "  (define (common-helper\
    \ l1 l2 common-list)\n    (cond\n      ((empty? l1) (sort (remove-duplicates common-list)\
    \ <))\n      ((empty? l2) (sort (remove-duplicates common-list) <))\n      ((member\
    \ (first l1) l2) (common-helper (rest l1) l2 (cons (first l1) common-list)))\n\
    \      (else (common-helper (rest l1) l2 common-list))))\n  (common-helper l1\
    \ l2 empty))\n", "  (cond [(empty? l1) empty]\n        [(member (first l1) l2)\
    \ (cons (first l1) (common (rest l1) l2))]\n        [else (common (rest l1) l2)]))\n",
  "  (cond ((null? l1) '())\n        ((member (car l1) l2) (cons (car l1) (common\
    \ (cdr l1) l2)))\n        (else (common (cdr l1) l2))))\n", "  (sort (remove-duplicates\
    \ (append l1 l2)) <))\n", "  (sort (remove-duplicates (append l1 l2)) #&lt;))\n",
  "  (cond\n    [(empty? l1) empty]\n    [(member (first l1) l2) (cons (first l1)\
    \ (common (rest l1) l2))]\n    [else (common (rest l1) l2)]))\n", "  (sort (remove-duplicates\
    \ (append l1 l2)) <))\n", "  (sort (cond\n         [(empty? l1) '()]\n       \
    \  [(empty? l2) '()]\n         [(member (first l1) l2) (cons (first l1) (common\
    \ (rest l1) l2))]\n         [else (common (rest l1) l2)])\n        <))\n", " \
    \ (sort (remove-duplicates (set-intersection l1 l2)) <))\n", "  (sort (remove-duplicates\
    \ (append l1 l2)) #&lt;))\n", "  (sort (uniq (append l1 l2)) <))\n", "  (define\
    \ (helper l1 l2)\n    (cond\n      [(empty? l1) '()]\n      [(member (first l1)\
    \ l2) (cons (first l1) (helper (rest l1) l2))]\n      [else (helper (rest l1)\
    \ l2)]))\n  (sort (helper l1 l2) <))\n", "  (if (null? l1) '()\n      (if (null?\
    \ l2) '()\n          (if (member (car l1) l2)\n              (cons (car l1) (common\
    \ (cdr l1) l2))\n              (common (cdr l1) l2)))))\n", "  (if (null? l1)\n\
    \      l2\n      (if (null? l2)\n          l1\n          (if (equal? (car l1)\
    \ (car l2))\n              (cons (car l1) (common (cdr l1) (cdr l2)))\n      \
    \        (if (< (car l1) (car l2))\n                  (common (cdr l1) l2)\n \
    \                 (common l1 (cdr l2)))))))\n", "  (sort (remv-dups (append l1\
    \ l2)) &lt;))\n", "  (sort (for/set ([e1 l1] [e2 l2])\n          (if (member e1\
    \ l2) e1))\n        <))\n</code>\nI would like to know if I could have avoided\
    \ using the <code>member</code> function or whether there is a more idiomatic\
    \ way of doing this.  Also, if I wanted to make it more \"efficient\" I could\
    \ build a hashtable with the second list and do a lookup on the first list:\n\
    <code>#lang racket\n", "  (define (insert-one element lst)\n    (cond ((null?\
    \ lst) (list element))\n          ((< element (car lst)) (cons element lst))\n\
    \          ((> element (car lst)) (cons (car lst) (insert-one element (cdr lst))))\n\
    \          (else lst)))\n  (define (insert-all lst1 lst2)\n    (cond ((null? lst1)\
    \ lst2)\n          (else (insert-one (car lst1) (insert-all (cdr lst1) lst2)))))\n\
    \  (define (extract element lst)\n    (cond ((null? lst) '())\n          ((equal?\
    \ element (car lst)) (cdr lst))\n          (else (cons (car lst) (extract element\
    \ (cdr lst))))))\n  (define (extract-all lst1 lst2)\n    (cond ((null? lst1) lst2)\n\
    \          (else (extract-all (cdr lst1) (extract (car lst1) lst2)))))\n  (extract-all\n\
    \   (insert-all (list-sort < l1) (list-sort < l2))\n   (list-sort < (insert-all\
    \ l1 l2))))\n", "  (define (common-helper l1 l2)\n    (cond\n      [(or (empty?\
    \ l1) (empty? l2)) '()]\n      [(member (first l1) l2) (cons (first l1) (common-helper\
    \ (rest l1) l2))]\n      [else (common-helper (rest l1) l2)]))\n  (remove-duplicates\
    \ (common-helper l1 l2)))\n", "  (sort (list-intersection l1 l2) <))\n", "  (sort\
    \ (set-intersection (set l1) (set l2)) <))\n", "  (sort (removedup (append l1\
    \ l2)) <))\n", "  (define (unique-in-order s l)\n    (if (empty? l)\n        s\n\
    \        (if (member (first l) s)\n            (unique-in-order s (rest l))\n\
    \            (unique-in-order (append s (list (first l))) (rest l)))))\n  (unique-in-order\
    \ '() (sort (append l1 l2) <)))\n", "  (sort (hash-remove (hash-remove (hash-copy\
    \ (hash-copy empty-hash l1))\n                                  (hash-copy empty-hash\
    \ l2))\n                    '())\n        <))\n", "  (sort (delete-duplicates\
    \ (append l1 l2)) #&lt;))\n", "  (sort (remove-duplicates (remove l1 (remove l2\
    \ (append l1 l2)))) #&lt;))\n", "  (define (eql? e1 e2) (= e1 e2))\n  (sort (unique\
    \ (append l1 l2)) #:key cdr eql?)\n  (filter (\u03BB (x) (member x l1)) l2))\n",
  "  (define (common-mem? e)\n    (and (member e l1) (member e l2)))\n  (sort (remove-duplicates\
    \ (filter common-mem? (append l1 l2))) <))\n\n", "  (define s1 (set l1))\n  (define\
    \ s2 (set l2))\n  (define common (set-intersection s1 s2))\n  (set->list common))\n",
  "  (removedup\n   (intersection (sort l1) (sort l2))))\n", "  (define (unique l)\n\
    \    (cond\n      [(null? l) l]\n      [(member (car l) (cdr l)) (unique (cdr\
    \ l))]\n      [else (cons (car l) (unique (cdr l)))]))\n  (sort (unique (filter\
    \ (lambda (x) (member x l2)) l1)) <))\n", "  (filter (\u03BB (x) (member x l2))\
    \ (distinct (append l1 l2))))\n```\n\n### [easy-4.rkt](https://github.com/MisterDidi/99-Racket-Problems/blob/master/easy-4.rkt)\n\
    \n```#lang racket\n", "  (sort (remove-duplicates (append l1 l2)) #&lt;))\n",
  "  (sort (remdup (intersection l1 l2)) <))\n", "  (sort (unique (append l1 l2))\
    \ #&lt;))\n", "  (define (insert x l)\n    (cond ((null? l) (list x))\n      \
    \    ((&lt; x (car l)) (cons x l))\n          (else (cons (car l) (insert x (cdr\
    \ l))))))\n  (let loop ((l1 l1) (l2 l2) (acc '()))\n    (cond ((null? l1) acc)\n\
    \          ((null? l2) acc)\n          ((= (car l1) (car l2)) (loop (cdr l1) (cdr\
    \ l2) (insert (car l1) acc)))\n          ((&lt; (car l1) (car l2)) (loop (cdr\
    \ l1) l2 acc))\n          (else (loop l1 (cdr l2) acc)))))\n</code>\n", "  (sort\
    \ (remove-duplicates (list-intersection l1 l2)) <))\n```\n\n```racket\n#lang racket\n",
  "  (sort (unique (append l1 l2)) #&lt;))\n", "  (let loop ([l1 l1] [l2 l2] [uniq\
    \ '()])\n    (cond [(or (null? l1) (null? l2)) (sort uniq <)]\n          [(eq?\
    \ (car l1) (car l2))\n           (if (not (member (car l1) uniq))\n          \
    \     (loop (cdr l1) (cdr l2) (cons (car l1) uniq))\n               (loop (cdr\
    \ l1) (cdr l2) uniq))]\n          [(> (car l1) (car l2)) (loop l1 (cdr l2) uniq)]\n\
    \          [else (loop (cdr l1) l2 uniq)])))\n", "  (remove-duplicates (sort (append\
    \ l1 l2))))\n", "  (sort (unique (intersect l1 l2)) <))\n", "  (sort (list-set\
    \ (list-set l1) (list-set l2)) <))\n", "  (filter (curry set-member? l2) (sort\
    \ l1 <)))\n", "  (sort\n   (set-intersection\n    (set l1)\n    (set l2))\n  \
    \ <))\n\n", "  (sort (unique (append l1 l2)) <))\n", "  (let loop ([l1 l1] [l2\
    \ l2] [res '()])\n    (cond [(empty? l1) res]\n          [(empty? l2) res]\n \
    \         [(memq (first l1) l2) (loop (rest l1) l2 (cons (first l1) res))]\n \
    \         [else (loop (rest l1) l2 res)])))\n```\n\n### \u0417\u0430\u0434\u0430\
    \u0447\u0430 1.2\n\n\u041D\u0430\u043F\u0438\u0448\u0435\u0442\u0435 \u0444\u0443\
    \u043D\u043A\u0446\u0438\u044F `count-elements`, \u043A\u043E\u044F\u0442\u043E\
    \ \u043F\u0440\u0438\u0435\u043C\u0430 \u043A\u0430\u0442\u043E \u0430\u0440\u0433\
    \u0443\u043C\u0435\u043D\u0442\u0438 \u0434\u0432\u0430 \u0441\u043F\u0438\u0441\
    \u044A\u043A\u0430 \u0438 \u0432\u0440\u044A\u0449\u0430 \u0430\u0441\u043E\u0446\
    \u0438\u0430\u0442\u0438\u0432\u0435\u043D \u0441\u043F\u0438\u0441\u044A\u043A\
    , \u043A\u043E\u0439\u0442\u043E \u043F\u043E\u043A\u0430\u0437\u0432\u0430 \u043A\
    \u043E\u043B\u043A\u043E \u043F\u044A\u0442\u0438 \u0435\u043B\u0435\u043C\u0435\
    \u043D\u0442\u0438\u0442\u0435 \u043D\u0430 \u043F\u044A\u0440\u0432\u0438\u044F\
    \ \u0441\u043F\u0438\u0441\u044A\u043A \u0441\u0435 \u0441\u0440\u0435\u0449\u0430\
    \u0442 \u0432\u044A\u0432 \u0432\u0442\u043E\u0440\u0438\u044F.\n\n```racket\n\
    #lang racket\n", "  (let ([l1 (sort l1 <)]\n        [l2 (sort l2 <)])\n    (cond\n\
    \      [(empty? l1) '()]\n      [(empty? l2) '()]\n      [(= (first l1) (first\
    \ l2))\n       (cons (first l1) (common (rest l1) (rest l2)))]\n      [(< (first\
    \ l1) (first l2)) (common (rest l1) l2)]\n      [else (common l1 (rest l2))])))\n",
  "  (sort (unique (append l1 l2)) <))\n", "  (define (s-common l1 l2)\n    (cond\n\
    \      [(null? l1) empty]\n      [(null? l2) empty]\n      [(member (car l1) l2)\
    \ (cons (car l1) (s-common (cdr l1) l2))]\n      [else (s-common (cdr l1) l2)]))\n\
    \  (sort (s-common l1 l2) <))\n", "  (set! l1 (list-remove-duplicates (sort l1\
    \ #&lt;)))\n  (set! l2 (list-remove-duplicates (sort l2 #&lt;)))\n  (cond\n  \
    \  [(equal? l1 l2) l1]\n    [(or (null? l1) (null? l2)) '()]\n    [(and (equal?\
    \ (car l1) (car l2)) (car l1))\n     (cons (car l1) (common (cdr l1) (cdr l2)))]\n\
    \    [else (cond\n            [(and (not (equal? (car l1) (car l2))) (&lt; (car\
    \ l1) (car l2)))\n             (common (cdr l1) l2)]\n            [else (common\
    \ l1 (cdr l2))])]))\n</code>\nI was particularly surprised by its performance.\
    \ It is not only faster than other solutions on the other answers but also faster\
    \ than the naive Racket implementation. The <code>set!</code>s are not to change\
    \ the lists but to make sure that the lists are sorted and have unique elements\
    \ for the sake of comparing them with <code>equal?</code>. It is thus in fact\
    \ O(n*logn)\n<code>      +-------------------+-------------------+\n      |  Common\
    \ elements  |  Common elements  |\n      |     (unsorted)    |      (sorted) \
    \    |\n      +-------------------+-------------------+\n      |        Racket\
    \     |    fast algorithm |\n      +-------------------+-------------------+\n\
    \      |     1.2.2 \xB5s      |      0.0 \xB5s        |\n      |     0.8.1 \xB5\
    s      |      0.0 \xB5s        |\n      |     1.1.3 \xB5s      |      0.0 \xB5\
    s        |\n      |     1.0.6 \xB5s      |      0.0 \xB5s        |\n      |  \
    \   1.1.1 \xB5s      |      0.0 \xB5s        |\n      |     1.2.0 \xB5s      |\
    \      0.0 \xB5s        |\n      |     1.0.3 \xB5s      |      0.0 \xB5s     \
    \   |\n      |    ", "  (cond\n    [(empty? l1) (list)]\n    [(in? (first l1)\
    \ l2) (cons (first l1) (common (bf l1) l2))]\n    [else (common (bf l1) l2)]))\n",
  "  (sort (removes-dups (append l1 l2)) <))\n", "  (cond\n    [(null? l1) '()]\n\
    \    [(in? (car l1) l2) (cons (car l1) (common (cdr l1) l2))]\n    [else (common\
    \ (cdr l1) l2)]))\n", "  (cond ((null? l1) '())\n        ((member (car l1) l2)\
    \ (cons (car l1) (common (cdr l1) l2)))\n        (else (common (cdr l1) l2))))\n",
  "  (sort (set-intersection (list->set l1) (list->set l2)) #:key car))\n", "  (define\
    \ (comlist res l1 l2)\n    (if (empty? l1) res\n        (if (member (first l1)\
    \ l2)\n            (comlist (append res (list (first l1))) (rest l1) l2)\n   \
    \         (comlist res (rest l1) l2))))\n  (sort (comlist '() l1 l2) <))\n", " \
    \ (define (member? x l)\n    (cond ((null? l) #f)\n          ((equal? x (car l))\
    \ #t)\n          (else (member? x (cdr l)))))\n  (cond ((or (null? l1) (null?\
    \ l2)) '())\n        ((member? (car l1) l2) (cons (car l1) (common (cdr l1) l2)))\n\
    \        (else (common (cdr l1) l2))))\n", '  (sort (remov', "  (sort (delete-duplicates\
    \ (intersection l1 l2)) <))\n\n", "  (list-set (append l1 l2)))\n", "  (sort (removes\
    \ (remove-duplicates l1) l2) <))\n", "  (cond\n    [(null? l1) '()]\n    [(member\
    \ (car l1) l2) (cons (car l1) (common (cdr l1) l2))]\n    [else (common (cdr l1)\
    \ l2)]))\n", "  (sort (remove-duplicates (append l1 l2)) &lt;))\n", "  (define\
    \ s1 (set l1))\n  (define s2 (set l2))\n  (sort (remq-duplicates (append (intersection\
    \ s1 s2) (intersection s2 s1))) <))\n", "  (sort\n   (list-set (intersect l1 l2))\n\
    \   (lambda (x y) (&lt; x y))))\n", "  (sort (list-set (list-intersect l1 l2))\
    \ &lt;))\n", "  (cond\n    [(empty? l1) '()]\n    [(member (first l1) l2) (cons\
    \ (first l1) (common (rest l1) l2))]\n    [else (common (rest l1) l2)]))\n", " \
    \ (set! l1 (sort l1))\n  (set! l2 (sort l2))\n  (cond ((or (null? l1) (null? l2))\
    \ '())\n        ((= (car l1) (car l2)) (cons (car l1) (common (cdr l1) (cdr l2))))\n\
    \        ((< (car l1) (car l2)) (common (cdr l1) l2))\n        ((> (car l1) (car\
    \ l2)) (common l1 (cdr l2)))))\n", "  (sort (remove-duplicates (append l1 l2))\
    \ &lt;))\n", "  (sort (unique (append l1 l2)) &lt;))\n", "  (cond [(empty? l1)\
    \ '()]\n        [(member (first l1) l2) (append (list (first l1)) (common (rest\
    \ l1) l2))]\n        [else (common (rest l1) l2)]))\n", "  (sort (uniq (intersect\
    \ l1 l2)) <))\n", "  (cond ((null? l1) '())\n        ((member (car l1) l2) (cons\
    \ (car l1) (common (cdr l1) l2)))\n        (else (common (cdr l1) l2))))\n", " \
    \ (cond\n    [(or (null? l1) (null? l2)) '()]\n    [(member (car l1) l2) (cons\
    \ (car l1) (common (cdr l1) l2))]\n    [else (common (cdr l1) l2)]))\n", "  (sort\
    \ (set-intersection (set l1) (set l2)) <))\n", "  (sort (list-set (list-set l1\
    \ l2)) <))\n", "  (sort (list-uniq (filter (lambda (x) (memq x l2)) l1)) <))\n",
  "  (define (common-helper l1 l2 common-list)\n    (if (null? l1)\n        common-list\n\
    \        (if (member (car l1) l2)\n            (common-helper (cdr l1) l2 (cons\
    \ (car l1) common-list))\n            (common-helper (cdr l1) l2 common-list))))\n\
    \  (common-helper l1 l2 '()))\n", "  (cond\n    [(empty? l1) empty]\n    [(contains?\
    \ l2 (first l1))\n     (cons (first l1) (common (remove (first l1) l1) l2))]\n\
    \    [else (common (rest l1) l2)]))\n", "  (sort (remove-duplicates (append l1\
    \ l2)) #&lt;))\n", "  (sort (remv-dups (intersection l1 l2)) #&lt;))\n", "  (define\
    \ (common2 acc l1 l2)\n    (cond\n      [(null? l1) acc]\n      [(null? l2) acc]\n\
    \      [(eq? (car l1) (car l2)) (common2 (cons (car l1) acc) (cdr l1) (cdr l2))]\n\
    \      [(= (car l1) (car l2)) (common2 (cons (car l1) acc) (cdr l1) (cdr l2))]\n\
    \      [(< (car l1) (car l2)) (common2 acc (cdr l1) l2)]\n      [else (common2\
    \ acc l1 (cdr l2))]))\n  (sort (common2 '() l1 l2) <))\n", "  (define (sub x l)\n\
    \    (cond ((null? l) '())\n          ((equal? x (car l)) (sub x (cdr l)))\n \
    \         (else (cons (car l) (sub x (cdr l))))))\n  (define (common-helper l1\
    \ l2)\n    (cond ((null? l1) '())\n          ((equal? #t (member (car l1) l2))\
    \ (cons (car l1) (common-helper (sub (car l1) l1) (sub (car l1) l2))))\n     \
    \     (else (common-helper (cdr l1) l2))))\n  (sort (common-helper l1 l2) <))\n",
  "  (define (common-inner l1 l2 result)\n    (cond\n      [(empty? l1) (reverse result)]\n\
    \      [(empty? l2) (reverse result)]\n      [(= (first l1) (first l2))\n    \
    \   (common-inner (rest l1) (rest l2) (cons (first l1) result))]\n      [(> (first\
    \ l1) (first l2))\n       (common-inner l1 (rest l2) result)]\n      [else (common-inner\
    \ (rest l1) l2 result)]))\n  (common-inner l1 l2 (list)))\n```\n\n```racket\n\
    #lang racket\n", "  (let loop ([l1 l1] [l2 l2] [result '()])\n    (cond [(null?\
    \ l1) result]\n          [(null? l2) result]\n          [(member (car l1) l2)\
    \ (loop (cdr l1) l2 (cons (car l1) result))]\n          [else (loop (cdr l1) l2\
    \ result)])))\n```\n\n- [CodingBat - List-2 commonEnd](http://codingbat.com/prob/p183962)\n\
    \n```java\npublic boolean commonEnd(int[] a, int[] b) {\n  return a[0] == b[0]\
    \ || a[a.length - 1] == b[b.length - 1];\n}\n```\n\n- [CodingBat - List-2 commonTwo](http://codingbat.com/prob/p108997)\n\
    \n```java\npublic int commonTwo(String[] a, String[] b) {\n  int num = 0;\n  for\
    \ (int i = 0; i < a.length; i++) {\n    for (int j = 0; j < b.length; j++) {\n\
    \      if (a[i].equals(b[j])) {\n        num++;\n        b[j] = \"\";\n      \
    \  break;\n      }\n    }\n  }\n  return num;\n}\n```\n\n- [CodingBat - List-2\
    \ countEvens](http://codingbat.com/prob/p163932)\n\n```java\npublic int countEvens(int[]\
    \ nums) {\n  int num = 0;\n  for (int i = 0; i < nums.length; i++) {\n    if (nums[i]\
    \ % 2 == 0) {\n      num++;\n    }\n  }\n  return num;\n}\n```\n\n- [CodingBat\
    \ - List-2 countEvensAlternate](http://codingbat.com/prob/p170786)\n\n```java\n\
    public int countEvensAlternate(int[] nums) {\n  int num = 0;\n  for (int i = 0;\
    \ i < nums.length;", "  (remove-duplicates (sort (append l1 l2))))\n", "  (define\
    \ (intersect l1 l2)\n    (cond\n      [(empty? l1) empty]\n      [(member (first\
    \ l1) l2) (cons (first l1) (intersect (rest l1) l2))]\n      [else (intersect\
    \ (rest l1) l2)]))\n  (sort (intersect l1 l2) <))\n", "  (sort (uniq (append l1\
    \ l2)) <))\n", "  (cond [(or (null? l1) (null? l2)) empty]\n        [else (apply\
    \ (lambda (x y) (common y (remove x l2)))\n                     (uniq-sort (append\
    \ l1 l2)))]))\n", "  (let* ([len1 (length l1)]\n         [len2 (length l2)]\n\
    \         [new-lst (flatten (list->vector (map (lambda (x) (list x (member x l2)))\
    \ l1)))]\n         [final-lst (filter (lambda (x) (equal? 1 (length x))) new-lst)])\n\
    \    (sort final-lst (lambda (x y) (< (length x) (length y))))))\n", "  (cond\n\
    \    [(null? l1) '()]\n    [(member (car l1) l2) (cons (car l1) (common (cdr l1)\
    \ l2))]\n    [else (common (cdr l1) l2)]))\n", "  (let loop ((l1 l1) (l2 l2) (res\
    \ '()))\n    (cond ((null? l1) '())\n          ((null? l2) '())\n          ((member\
    \ (car l1) l2) (loop (cdr l1) l2 (cons (car l1) res)))\n          (else (loop\
    \ (cdr l1) l2 res)))))\n", "  (let loop ((l1 l1) (l2 l2) (c '()))\n    (cond\n\
    \      [(or (empty? l1) (empty? l2)) (sort (remove-duplicates c) <)]\n      [(member\
    \ (first l1) l2) (loop (rest l1) l2 (cons (first l1) c))]\n      [else (loop (rest\
    \ l1) l2 c)])))\n", "  (sort (set-intersection (sort l1 #<) (sort l2 #<)) #<))\n",
  "  (letrec ([uniq (lambda (xs) (cond [(empty? xs) '()]\n                       \
    \            [(empty? (rest xs)) xs]\n                                   [(= (first\
    \ xs) (first (rest xs))) (uniq (rest xs))]\n                                 \
    \  [else (cons (first xs) (uniq (rest xs)))]))]\n            [srt (lambda (xs)\
    \ (cond [(empty? xs) '()]\n                                    [(empty? (rest\
    \ xs)) xs]\n                                    [(< (first xs) (first (rest xs)))\
    \ (cons (first xs) (srt (rest xs)))]\n                                    [else\
    \ (cons (first (rest xs)) (srt (cons (first xs) (rest (rest xs)))))]))])\n   \
    \ (srt (uniq (list-intersect l1 l2)))))\n", "  (sort (remove-duplicates (append\
    \ l1 l2)) <))\n", "  (sort (list-intersection l1 l2) <))\n", "  (sort (foldr (lambda\
    \ (l res)\n                 (if (member l l2)\n                     (append res\
    \ (list l))\n                     res))\n               '()\n               l1)\n\
    \        &lt;))\n</code>\nI was wondering if there is a better way of doing this.\n\
    \n\nA:\n\nMy solution is below,\n<code>#lang racket\n", "  (cond\n    [(or (empty?\
    \ l1) (empty? l2)) '()]\n    [(member (first l1) l2) (cons (first l1) (common\
    \ (rest l1) l2))]\n    [else (common (rest l1) l2)]))\n", "  (filter (\u03BB (el)\
    \ (member el l2)) l1))\n```\n\n```scheme\n#lang racket\n", "  (for/list ([x (in-list\
    \ l1)]\n             #:when (member x l2))\n    x))\n", "  (remove-duplicates\
    \ (intersection (uniq-sort l1) (uniq-sort l2))))\n", "  (cond ((or (empty? l1)\
    \ (empty? l2)) empty)\n        ((member (first l1) l2) (cons (first l1) (common\
    \ (rest l1) l2)))\n        (else (common (rest l1) l2))))\n", "  (sort (remove-duplicates\
    \ (intersection l1 l2)) <))\n```\n\n### Solution 2\n\n```racket\n#lang racket\n",
  "  (sort (set-intersection l1 l2) <))\n", "  (sort (remove-duplicates (intersection\
    \ l1 l2)) <))\n", "  (cond\n    [(empty? l1) empty]\n    [(empty? l2) empty]\n\
    \    [(not (member (first l1) l2)) (common (rest l1) l2)]\n    [else (sort < (cons\
    \ (first l1) (common (rest l1) l2)))]))\n", "  (sort (remove-duplicates (append\
    \ l1 l2)) (lambda (x y) (&lt; x y))))\n</code>\n", "  (define (mem? l n)\n   \
    \ (cond\n      [(null? l) #f]\n      [(= (car l) n) #t]\n      [else (mem? (cdr\
    \ l) n)]))\n  (define (unique l)\n    (cond\n      [(null? l) null]\n      [(mem?\
    \ (cdr l) (car l)) (unique (cdr l))]\n      [else (cons (car l) (unique (cdr l)))]))\n\
    \  (sort (unique (append l1 l2)) &lt;))\n</code>\nMaybe there is a simpler solution\
    \ in racket.\n\n\nA:\n\nThere is no need to make a <code>mem?</code> function.\
    \ Instead, use <code>member</code> which returns the first matching element.\n\
    <code>(define (common l1 l2)\n  (define (unique l)\n    (cond\n      [(null? l)\
    \ null]\n      [(member (cdr l) (car l)) (unique (cdr l))]\n      [else (cons\
    \ (car l) (unique (cdr l)))]))\n  (sort (unique (append l1 l2)) &lt;))\n</code>\n\
    Example:\n<code>(common (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121))\n=&gt;\
    \ '(1 5 653)\n</code>\nNote that Racket comes with a function <code>intersection</code>\
    \ that does almost the same thing.\n<code>(define (common l1 l2)\n  (sort (intersection\
    \ l1 l2) &lt;))\n</code>\n", "  (let ([r (sort (append l1 l2))])\n    (unique\
    \ r)))\n", "  (sort (uniq (list-intersect l1 l2)) <))\n", "  (let ([l1-set (set\
    \ l1)]\n        [l2-set (set l2)])\n    (remove-duplicates\n     (append (list->set\
    \ (set-intersection l1-set l2-set)) (list->set (set-intersection l2-set l1-set)))\n\
    \     =)))\n```\n\n### lcs.rkt\n\nReturn the longest common subsequence of two\
    \ strings.\n\n```racket\n#lang racket\n", "  (sort (uniq (append l1 l2)) <))\n",
  "  (let ([common-elements (find-common-elements l1 l2)])\n    (if (null? common-elements)\n\
    \        '()\n        (sort common-elements #:key (lambda (x) x)))))\n", "  (sort\
    \ l1 (lambda (a b) (&lt; a b)))\n  (sort l2 (lambda (a b) (&lt; a b)))\n  (define\
    \ setl1 (list-&gt;set l1))\n  (define setl2 (list-&gt;set l2))\n  (set-intersection\
    \ setl1 setl2))\n</code>\nI would appreciate any tips or advice.\n\n\nA:\n\nThe\
    \ error is because the function <code>sort</code> returns the sorted list, so\
    \ you need to assign that to a variable, because you can't assign the result of\
    \ a function to a function's argument.\nTry this:\n<code>(define (common l1 l2)\n\
    \  (define sorted-l1 (sort l1 (lambda (a b) (&lt; a b))))\n  (define sorted-l2\
    \ (sort l2 (lambda (a b) (&lt; a b))))\n  (define setl1 (list-&gt;set sorted-l1))\n\
    \  (define setl2 (list-&gt;set sorted-l2))\n  (set-intersection setl1 setl2))\n\
    </code>\n\nAnyway, your function can be simplified to this:\n<code>(define (common\
    \ l1 l2)\n  (list-&gt;set (intersect (sort l1 &lt;) (sort l2 &lt;))))\n</code>\n",
  "  (remove-duplicates (sort (intersect l1 l2) <)))\n", "  (remove-duplicates (sort\
    \ (append l1 l2))))\n", "  (sort (remove-duplicates (filter (\u03BB (x) (member\
    \ x l2)) l1)) <))\n```\n\n```racket\n#lang racket\n", "  (sort (remove-duplicates\
    \ (append l1 l2)) <))\n", "  (set! l1 (sort l1 <))\n  (set! l2 (sort l2 <))\n\
    \  (let loop ((l1 l1) (l2 l2) (result '()))\n    (cond\n      [(empty? l1) result]\n\
    \      [(empty? l2) result]\n      [(= (first l1) (first l2))\n       (loop (rest\
    \ l1) (rest l2) (cons (first l1) result))]\n      [else\n       (if (< (first\
    \ l1) (first l2))\n           (loop (rest l1) l2 result)\n           (loop l1\
    \ (rest l2) result))])))\n```\n\n**7** Count common elements between two lists.\n\
    \n```racket\n#lang racket\n", "  (sort (remove-duplicates (append l1 l2)) <))\n",
  "  (remove-duplicates\n   (sort (append l1 l2))\n   (lambda (x y)\n     (= x y))))\n",
  "  (sort (remove-duplicates (set-intersection (list->set l1) (list->set l2))) <))\n",
  "  (cond ((null? l1) '())\n        ((member (car l1) l2) (cons (car l1) (common\
    \ (cdr l1) l2)))\n        (else (common (cdr l1) l2))))\n", "  (let ([l1 (sort\
    \ (unique l1))]\n        [l2 (sort (unique l2))])\n    (cond [(null? l1) '()]\n\
    \          [(null? l2) '()]\n          [(= (car l1) (car l2)) (cons (car l1) (common\
    \ (cdr l1) (cdr l2)))]\n          [(< (car l1) (car l2)) (common (cdr l1) l2)]\n\
    \          [else (common l1 (cdr l2))])))\n", "  (remove-duplicates (intersection\
    \ (set l1) (set l2)) #:equal? equal?))\n", "  (define (to-set l)\n    (if (null?\
    \ l)\n        null\n        (cons (car l) (to-set (cdr l)))))\n  (define (intersect\
    \ l1 l2)\n    (if (null? l1)\n        null\n        (if (member (car l1) l2)\n\
    \            (cons (car l1) (intersect (cdr l1) l2))\n            (intersect (cdr\
    \ l1) l2))))\n  (sort (intersect (to-set l1) (to-set l2)) &lt;))\n</code>\nBut\
    \ I don't understand why this solution is wrong:\n<code>#lang racket\n", "  (sort\
    \ (filter (compose (curry member l2) car)\n\t\t(set l1))\n\t&lt;))\n", "  (define\
    \ (clean l)\n    (cond ((null? l) '())\n          ((member (car l) (cdr l)) (clean\
    \ (cdr l)))\n          (else (cons (car l) (clean (cdr l))))))\n  (clean (sort\
    \ (intersect l1 l2) <)))\n", "  (cond\n    [(empty? l1) empty]\n    [(member (first\
    \ l1) l2) (cons (first l1) (common (rest l1) l2))]\n    [else (common (rest l1)\
    \ l2)]))\n", "  (cond\n    [(or (null? l1) (null? l2)) '()]\n    [(member (car\
    \ l1) l2) (cons (car l1) (common (cdr l1) l2))]\n    [else (common (cdr l1) l2)]))\n",
  "  (sort\n   (set-intersection\n    (set l1)\n    (set l2))\n   <))\n", "  (cond\n\
    \    [(empty? l1) empty]\n    [(empty? l2) empty]\n    [(and (member (first l1)\
    \ l2) (not (member (first l1) (rest l1))))\n     (cons (first l1) (common (rest\
    \ l1) l2))]\n    [else (common (rest l1) l2)]))\n```\n## Tests\n```racket\n#lang\
    \ racket\n", "  (cond\n    [(empty? l1) empty]\n    [(empty? l2) empty]\n    [(member\
    \ (first l1) l2) (cons (first l1) (common (rest l1) l2))]\n    [else (common (rest\
    \ l1) l2)]))\n", "  (define (take-uniq l)\n    (cond\n      [(empty? l) empty]\n\
    \      [(and (list? l) (equal? (cdr l) empty)) (list (car l))]\n      [(and (list?\
    \ l) (equal? (cdr l) (cddr l))) (cons (car l) (take-uniq (cdr l)))]\n      [else\
    \ (cons (car l) (take-uniq (cdr l)))]))\n  (define (sorted-l l)\n    (sort (take-uniq\
    \ l) <))\n  (cond\n    [(and (list? l1) (list? l2)) (sorted-l (unique-common-elements\
    \ l1 l2))]\n    [else (error 'common \"arguments must be lists\")]))", "  (define\
    \ (add-to-set elem set)\n    (cond\n      [(empty? set)\n       (list elem)]\n\
    \      [(equal? elem (first set))\n       set]\n      [else\n       (cons (first\
    \ set) (add-to-set elem (rest set)))]))\n  (define (common-helper l1 l2 set)\n\
    \    (cond\n      [(empty? l1)\n       set]\n      [(empty? l2)\n       set]\n\
    \      [(equal? (first l1) (first l2))\n       (common-helper (rest l1) (rest\
    \ l2) (add-to-set (first l1) set))]\n      [(< (first l1) (first l2))\n      \
    \ (common-helper (rest l1) l2 set)]\n      [else\n       (common-helper l1 (rest\
    \ l2) set)]))\n  (sort (common-helper (sort l1) (sort l2) (list)) <))\n```\n\n\
    ```racket\n#lang racket\n", "  (sort (set-intersection eq? l1 l2) <))\n", "  (sort\
    \ (remove-duplicates (filter (lambda (x) (member x l2)) l1)) <))\n", "  (sort\
    \ (remdup (append l1 l2)) <))\n", "  (sort (uniq (append l1 l2)) <))\n", "  (sort\
    \ (uniq (intersect l1 l2)) <))\n", "  (let ((result (intersection (sort l1 <)\
    \ (sort l2 <))))\n    (unique result)))\n", "  (sort (remq* '() (sort (remq* '()\
    \ (append l1 l2)) <) <) <))\n", "  (sort (unique (append l1 l2)) <))\n", "  (cond\n\
    \    [(empty? l1) '()]\n    [(member (first l1) l2) (cons (first l1) (common (rest\
    \ l1) l2))]\n    [else (common (rest l1) l2)]))\n", "  (sort (delete-duplicates\
    \ (intersection l1 l2)) (lambda (a b) (&lt; a b))))\n</code>\nOf course, this\
    \ could be implemented without <code>intersection</code> by just using <code>cond</code>\
    \ to check if an element is in the other list. \n", "  (cond\n    [(empty? l1)\
    \ '()]\n    [(empty? l2) '()]\n    [(member (first l1) l2)\n     (cons (first\
    \ l1) (common (rest l1) l2))]\n    [else (common (rest l1) l2)]))\n", "  (if (null?\
    \ l1)\n      '()\n      (if (member (car l1) l2)\n          (cons (car l1) (common\
    \ (cdr l1) l2))\n          (common (cdr l1) l2))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
