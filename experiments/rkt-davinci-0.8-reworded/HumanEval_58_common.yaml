name: HumanEval_58_common
language: rkt
prompt: "#lang racket\n\n;; Return sorted unique common elements for two lists.\n\
  ;; >>> (common (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121))\n;; (list 1 5 653)\n\
  ;; >>> (common (list 5 3 2 8) (list 3 2))\n;; (list 2 3)\n(define (common l1 l2)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate common))\n\
  \    (check-equal? (candidate (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121))\
  \ (list 1 5 653))\n    (check-equal? (candidate (list 5 3 2 8) (list 3 2)) (list\
  \ 2 3))\n    (check-equal? (candidate (list 4 3 2 8) (list 3 2 4)) (list 2 3 4))\n\
  \    (check-equal? (candidate (list 4 3 2 8) (list )) (list ))\n))\n\n(test-humaneval)"
completions: ["  (sort (remove-duplicates (append l1 l2)) <))\n", "  (sort (foldr\
    \ intersetiort null l1) (\u03BB (a b) (&lt; a b))))\n", "  (sort (remove-duplicates\
    \ (intersection l1 l2)) <))\n", "  (sort (list-set (append l1 l2)) &lt;))\n",
  "  (sort (unique (append l1 l2)) <))\n", "  (define result (list))\n  (for ([x l1])\n\
    \    (for ([y l2])\n      (if (equal? x y)\n          (if (not (memq x result))\n\
    \              (set! result (cons x result))))))\n  (sort result <))\n", "  (sort\
    \ (list-set (list-intersect l1 l2)) #&lt;))\n", "  (sort (uniq (filter (lambda\
    \ (x) (member x l2)) l1)) <))\n", "  (if (null? l1) '()\n      (let ((rest (common\
    \ (cdr l1) l2)))\n        (if (member (car l1) l2)\n            (cons (car l1)\
    \ rest)\n            rest))))\n", "  (define all (append l1 l2))\n  (define uniq\
    \ (set all))\n  (sort uniq <))\n", "  (let ([l3 (append l1 l2)])\n    (define\
    \ (inner acc curr)\n      (cond\n        [(empty? acc)\n         (if (empty? l3)\n\
    \             acc\n             (inner (cons curr (list)) (car l3)))]\n      \
    \  [(eq? curr (car acc))\n         (inner acc (car l3))]\n        [(eq? curr (car\
    \ l3))\n         (inner (cons curr acc) (car l3))]\n        [else\n         (inner\
    \ acc (car l3))]))\n    (inner (list) (car l3))))\n", "  (sort (uniq (filter (\u03BB\
    \ (el) (member el l2)) l1)) <))\n", "  (sort (unique (append l1 l2)) <))\n", " \
    \ (sort (filter (\u03BB (x) (member x l2)) l1) <))\n", "  (sort (remove-duplicates\
    \ (append l1 l2)) <))\n", "  (let ((l1-set (list->set l1))\n        (l2-set (list->set\
    \ l2)))\n    (set-sort (set-intersect l1-set l2-set))))\n", "  (cond [(empty?\
    \ l1) empty]\n        [(empty? l2) empty]\n        [(empty? (filter (lambda (e)\
    \ (eq? e (first l1))) l2))\n         (common (rest l1) l2)]\n        [else (cons\
    \ (first l1) (common (rest l1) l2))]))\n", "  (sort (remove-duplicates (append\
    \ l1 l2)) <))\n", "  (sort (remq '() (map (lambda (x) (if (member x l2) x '()))\
    \ l1)) <))\n</code>\nWhich uses <code>sort</code> of <code>racket/list</code>\
    \ to sort the list by the <code>&lt;</code> comparator, or <code>quack</code>'s\
    \ own <code>list-sort</code> to do the same.\n", "  (set! l1 (sort l1 <))\n  (set!\
    \ l2 (sort l2 <))\n  (define (unique l)\n    (cond\n      [(null? l) '()]\n  \
    \    [(null? (cdr l)) l]\n      [(equal? (car l) (cadr l)) (unique (cdr l))]\n\
    \      [else (cons (car l) (unique (cdr l)))]))\n  (define (intersection l1 l2)\n\
    \    (cond\n      [(null? l1) '()]\n      [(null? l2) '()]\n      [(< (car l1)\
    \ (car l2)) (intersection (cdr l1) l2)]\n      [(> (car l1) (car l2)) (intersection\
    \ l1 (cdr l2))]\n      [else (cons (car l1) (intersection (cdr l1) (cdr l2)))]))\n\
    \  (unique (intersection l1 l2)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
