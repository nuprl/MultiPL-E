name: HumanEval_94_skjkasdkd
language: rkt
prompt: "#lang racket\n\n;; You are given a list of integers.\n;; You need to find\
  \ the largest prime value and return the sum of its digits.\n;; Examples:\n;; >>>\
  \ (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))\n;; 10\n\
  ;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))\n;; 25\n;; >>>\
  \ (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))\n;; 13\n\
  ;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))\n;; 11\n;; >>> (skjkasdkd\
  \ (list 0 81 12 3 1 21))\n;; 3\n;; >>> (skjkasdkd (list 0 8 1 2 1 7))\n;; 7\n(define\
  \ (skjkasdkd lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate skjkasdkd))\n\
  \    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324\
  \ 4 3)) 10)\n    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2\
  \ 4 2 5 1)) 25)\n    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163\
  \ 23 2323 32 30 1 9 3)) 13)\n    (check-equal? (candidate (list 0 724 32 71 99 32\
  \ 6 0 5 91 83 0 5 6)) 11)\n    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)\n\
  \    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)\n    (check-equal? (candidate\
  \ (list 8191)) 19)\n    (check-equal? (candidate (list 8191 123456 127 7)) 19)\n\
  \    (check-equal? (candidate (list 127 97 8192)) 10)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? lst) 0]\n    [(prime? (first lst)) (skjkasdkd\
    \ (rest lst))]\n    [else (max\n            (skjkasdkd (rest lst))\n         \
    \   (num->string (first lst)))]))\n", "  (let ((n (foldr max 0 lst)))\n    (if\
    \ (not (prime? n))\n        (skjkasdkd (remove n lst))\n        (apply + (integer->list\
    \ n)))))\n```\n\n```scheme\n#lang racket", "  (define (iter lst max-prime)\n \
    \   (if (null? lst)\n        (if (= max-prime 0)\n            0\n            (sum-digits\
    \ max-prime))\n        (if (= (modulo (car lst) 2) 0)\n            (iter (cdr\
    \ lst) max-prime)\n            (let ((new-max-prime (find-largest-prime (car lst)\
    \ max-prime)))\n              (iter (cdr lst) new-max-prime)))))\n  (iter lst\
    \ 0))\n", "  (cond\n    [(empty? lst) 0]\n    [(prime? (car lst))\n     (apply\
    \ + (string->list (number->string (car lst))))]\n    [else (skjkasdkd (cdr lst))]))\n",
  "  (local [(define (minp n)\n            (if (or (= n 1) (= n 0)) #f (local [(define\
    \ (iter i)\n                                                (if (= i 1) #t (if\
    \ (= (modulo n i) 0) #f (iter (- i 1)))))\n                                  \
    \        ]\n                                          (iter n))))\n          \
    \ (define (maxp x)\n             (if (minp x) x (maxp (- x 1))))\n           (define\
    \ (sum x)\n             (if (= x 0) 0 (+ (modulo x 10) (sum (quotient x 10)))))\n\
    \          ]\n          (sum (maxp (apply max lst)))))", "  (define (sum-of-digits\
    \ n)\n    (cond\n      [(zero? n) 0]\n      [else (+ (modulo n 10) (sum-of-digits\
    \ (quotient n 10)))]))\n  (let loop ([lst lst] [sum 0])\n    (cond\n      [(null?\
    \ lst) sum]\n      [(and (integer? (car lst)) (not (zero? (car lst))))\n     \
    \  (loop (cdr lst) (max sum (sum-of-digits (car lst))))]\n      [else (loop (cdr\
    \ lst) sum)])))\n", "  (define (find-max-prime lst max)\n    (if (null? lst)\n\
    \        max\n        (if (prime? (car lst))\n            (if (&gt; (car lst)\
    \ max)\n                (find-max-prime (cdr lst) (car lst))\n               \
    \ (find-max-prime (cdr lst) max))\n            (find-max-prime (cdr lst) max))))\n\
    \  (apply + (number-&gt;digits (find-max-prime lst 0))))\n", "  (letrec\n    \
    \  ([largest-prime-in-lst (lambda (lst)\n                               (if (null?\
    \ lst)\n                                   0\n                               \
    \    (define nxt-prime (largest-prime-in-lst (cdr lst)))\n                   \
    \                (cond\n                                     [(prime? (car lst))\n\
    \                                      (cond\n                               \
    \         [(and (positive? nxt-prime) (< (car lst) nxt-prime))\n             \
    \                            nxt-prime]\n                                    \
    \    [else\n                                         (car lst)])]\n          \
    \                           [else\n                                      nxt-prime])))]\n\
    \       [prime? (lambda (n)\n                 (cond\n                   [(<= n\
    \ 1)\n                    #f]\n                   [(<= n 2)\n                \
    \    #t]\n                   [(even? n)\n                    #f]\n           \
    \        [else\n                    (define (is-divisible n x)\n             \
    \         (if (<= x (sqrt n))\n                          (if (zero? (modulo n\
    \ x))\n                              #t\n                              (is-divisible\
    \ n (+ x 2)))\n                          #f))\n                    (is-divisible\
    \ n 3)]))]\n       [digits-of-n (lambda (n)\n                      (cond\n   \
    \                     [(= n 0)\n                         '()]\n              \
    \          [else\n                         (cons (modulo n 10) (digits-of-n (quotient\
    \ n 10)))]))]\n       [sum-of-digits (lambda (n)\n                        (cond\n\
    \                          [(= n 0)\n                           0]\n         \
    \                 [else\n                           (+ (modulo n 10) (sum-of-digits\
    \ (quotient n 10)))]))])\n    (sum-of-digits (largest-prime-in-lst lst))))\n",
  "  (let ((max (apply max lst)))\n    (if (not (prime? max))\n        (skjkasdkd\
    \ (remove (lambda (x) (= x max)) lst))\n        (sum-digits max))))\n", "  (if\
    \ (null? lst)\n      0\n      (let ((prime? (lambda (n)\n                    \
    \  (let loop ((i 2))\n                        (if (= n i)\n                  \
    \          #t\n                            (if (= 0 (modulo n i))\n          \
    \                      #f\n                                (loop (+ i 1)))))))\n\
    \            (find-largest-prime (lambda (lst)\n                             \
    \     (let loop ((lst lst)\n                                             (val\
    \ -1))\n                                    (if (null? lst)\n                \
    \                        val\n                                        (let ((curr\
    \ (car lst)))\n                                          (if (and (< val curr)\n\
    \                                                   (prime? curr))\n         \
    \                                     (loop (cdr lst) curr)\n                \
    \                              (loop (cdr lst) val)))))))\n            (get-digits\
    \ (lambda (n)\n                          (if (= n 0)\n                       \
    \       '()\n                              (cons (modulo n 10)\n             \
    \                       (get-digits (quotient n 10)))))))\n        (apply + (get-digits\
    \ (find-largest-prime lst))))))", "  (define (is-prime i)\n    (cond ((= i 1)\
    \ #f)\n          ((= i 2) #t)\n          ((> (modulo i 2) 0) #t)\n          (else\
    \ (is-prime (- i 1)))))\n  (define (largest-prime lst acc)\n    (cond ((null?\
    \ lst) acc)\n          ((is-prime (car lst)) (largest-prime (cdr lst) (car lst)))\n\
    \          (else (largest-prime (cdr lst) acc))))\n  (define (digits i)\n    (cond\
    \ ((= i 0) 0)\n          (else (+ (* (digits (quotient i 10)) 10) (remainder i\
    \ 10)))))\n  (digits (largest-prime lst 0)))", "  (let ([max-pr (-max \n     \
    \            (filter odd? \n                         (filter (compose (curry =\
    \ 1) (curry remainder)) \n                                 (find-divisors (find-max\
    \ lst)))))]\n    (apply + (string->list (number->string max-pr)))))\n", "  (cond\
    \ [(empty? lst) 0]\n        [else (cond [(prime? (car lst))\n                \
    \     (cond [(> (car lst) (skjkasdkd (cdr lst)))\n                           \
    \ (add-digits (car lst))]\n                           [else (skjkasdkd (cdr lst))])]\n\
    \                    [else (skjkasdkd (cdr lst))])]))\n", "  (if (empty? lst)\n\
    \      0\n      (let ([mx (- (max (car lst) (skjkasdkd (cdr lst))) 1)])\n    \
    \    (if (prime? mx)\n            (if (= mx 1)\n                (skjkasdkd (cdr\
    \ lst))\n                (apply + (string->list (number->string mx))))\n     \
    \       (skjkasdkd (cdr lst))))))\n", "  (define (find-prime lst)\n    (cond\n\
    \      [(null? lst) 1]\n      [(prime? (car lst)) (car lst)]\n      [else (find-prime\
    \ (cdr lst))]))\n  (cond\n    [(= (length lst) 0) 0]\n    [(= (length lst) 1)\
    \ (if (prime? (car lst)) (digits-sum (car lst)) 0)]\n    [else (digits-sum (find-prime\
    \ lst))]))\n", "  (define (prime? n)\n    (let loop ([n (abs n)] [d 2])\n    \
    \  (cond\n        [(zero? n) #f]\n        [(zero? (modulo n d)) #f]\n        [(>\
    \ d (sqrt n)) #t]\n        [else (loop n (+ d 1))])))\n  (define (sum-digits n)\n\
    \    (cond\n      [(zero? n) 0]\n      [else (+ (modulo n 10) (sum-digits (quotient\
    \ n 10)))]))\n  (for/fold ([ans 0]) ([x lst])\n    (if (and (prime? x) (> x ans))\
    \ (sum-digits x) ans)))\n", "  (define (sum-digits n)\n    (let loop ((n n) (s\
    \ 0))\n      (if (zero? n)\n          s\n          (loop (quotient n 10) (+ s\
    \ (remainder n 10))))))\n  (let loop ((lst lst) (max 0))\n    (cond ((null? lst)\
    \ (sum-digits max))\n          ((and (integer? (car lst)) (prime? (car lst)) (>\
    \ (car lst) max))\n           (loop (cdr lst) (car lst)))\n          (else (loop\
    \ (cdr lst) max)))))", "  (let ([prime? (\u03BB (x)\n                  (or (equal?\
    \ x 1)\n                      (equal? x 0)\n                      (equal? x -1)\n\
    \                      (empty? (filter (\u03BB (y)\n                         \
    \               (equal? 0 (modulo x y)))\n                                   \
    \   (range 2 (sqrt x))))))]\n        [max-prime (reduce max lst (filter prime?\
    \ lst))])\n    (if (equal? max-prime #f)\n        0\n        (let ([digits (string->list\
    \ (number->string max-prime))])\n          (if (empty? digits)\n             \
    \ 0\n              (reduce + digits))))))\n", "  (define (is-prime? num)\n   \
    \ (define (divisible? divisor)\n      (= (remainder num divisor) 0))\n    (define\
    \ (find-divisor n)\n      (cond ((= n num) #f)\n            ((divisible? n) n)\n\
    \            (else (find-divisor (+ n 1)))))\n    (if (= num 1)\n        #f\n\
    \        (not (find-divisor 2))))\n  (define (find-largest-prime lst)\n    (define\
    \ (go lst largest)\n      (cond ((null? lst) largest)\n            ((and (is-prime?\
    \ (car lst))\n                  (> (car lst) largest))\n             (go (cdr\
    \ lst) (car lst)))\n            (else (go (cdr lst) largest))))\n    (go lst 0))\n\
    \  (define (sum-digits num)\n    (cond ((= num 0) 0)\n          (else (+ (remainder\
    \ num 10)\n                   (sum-digits (quotient num 10))))))\n  (sum-digits\
    \ (find-largest-prime lst)))\n", "  (define (helper a)\n    (define (digits a)\n\
    \      (if (= a 0)\n          '()\n          (cons (remainder a 10) (digits (quotient\
    \ a 10)))))\n    (define (sum lst)\n      (cond ((null? lst) 0)\n            (else\
    \ (+ (car lst) (sum (cdr lst))))))\n    (if (integer? a)\n        (sum (digits\
    \ a))\n        a))\n  (define (largest-prime lst)\n    (cond ((null? lst) -1)\n\
    \          ((= 1 (car lst)) (largest-prime (cdr lst)))\n          ((integer? (car\
    \ lst))\n           (cond ((= 1 (helper (car lst))) (largest-prime (cdr lst)))\n\
    \                 ((= 0 (helper (car lst))) (largest-prime (cdr lst)))\n     \
    \            (else (car lst))))\n          (else (largest-prime (cdr lst)))))\n\
    \  (helper (largest-prime lst)))\n```\n\n``` #lang racket\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
