name: HumanEval_94_skjkasdkd
language: rkt
prompt: "#lang racket\n\n;; You are given a list of integers.\n;; You need to find\
  \ the largest prime value and return the sum of its digits.\n;; Examples:\n;; >>>\
  \ (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))\n;; 10\n\
  ;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))\n;; 25\n;; >>>\
  \ (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))\n;; 13\n\
  ;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))\n;; 11\n;; >>> (skjkasdkd\
  \ (list 0 81 12 3 1 21))\n;; 3\n;; >>> (skjkasdkd (list 0 8 1 2 1 7))\n;; 7\n(define\
  \ (skjkasdkd lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate skjkasdkd))\n\
  \    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324\
  \ 4 3)) 10)\n    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2\
  \ 4 2 5 1)) 25)\n    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163\
  \ 23 2323 32 30 1 9 3)) 13)\n    (check-equal? (candidate (list 0 724 32 71 99 32\
  \ 6 0 5 91 83 0 5 6)) 11)\n    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)\n\
  \    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)\n    (check-equal? (candidate\
  \ (list 8191)) 19)\n    (check-equal? (candidate (list 8191 123456 127 7)) 19)\n\
  \    (check-equal? (candidate (list 127 97 8192)) 10)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? lst) 0]\n    [(prime? (first lst)) (skjkasdkd\
    \ (rest lst))]\n    [else (max\n            (skjkasdkd (rest lst))\n         \
    \   (num->string (first lst)))]))\n", "  (let ((n (foldr max 0 lst)))\n    (if\
    \ (not (prime? n))\n        (skjkasdkd (remove n lst))\n        (apply + (integer->list\
    \ n)))))\n```\n\n```scheme\n#lang racket", "  (define (iter lst max-prime)\n \
    \   (if (null? lst)\n        (if (= max-prime 0)\n            0\n            (sum-digits\
    \ max-prime))\n        (if (= (modulo (car lst) 2) 0)\n            (iter (cdr\
    \ lst) max-prime)\n            (let ((new-max-prime (find-largest-prime (car lst)\
    \ max-prime)))\n              (iter (cdr lst) new-max-prime)))))\n  (iter lst\
    \ 0))\n", "  (cond\n    [(empty? lst) 0]\n    [(prime? (car lst))\n     (apply\
    \ + (string->list (number->string (car lst))))]\n    [else (skjkasdkd (cdr lst))]))\n",
  "  (local [(define (minp n)\n            (if (or (= n 1) (= n 0)) #f (local [(define\
    \ (iter i)\n                                                (if (= i 1) #t (if\
    \ (= (modulo n i) 0) #f (iter (- i 1)))))\n                                  \
    \        ]\n                                          (iter n))))\n          \
    \ (define (maxp x)\n             (if (minp x) x (maxp (- x 1))))\n           (define\
    \ (sum x)\n             (if (= x 0) 0 (+ (modulo x 10) (sum (quotient x 10)))))\n\
    \          ]\n          (sum (maxp (apply max lst)))))", "  (define (sum-of-digits\
    \ n)\n    (cond\n      [(zero? n) 0]\n      [else (+ (modulo n 10) (sum-of-digits\
    \ (quotient n 10)))]))\n  (let loop ([lst lst] [sum 0])\n    (cond\n      [(null?\
    \ lst) sum]\n      [(and (integer? (car lst)) (not (zero? (car lst))))\n     \
    \  (loop (cdr lst) (max sum (sum-of-digits (car lst))))]\n      [else (loop (cdr\
    \ lst) sum)])))\n", "  (define (find-max-prime lst max)\n    (if (null? lst)\n\
    \        max\n        (if (prime? (car lst))\n            (if (&gt; (car lst)\
    \ max)\n                (find-max-prime (cdr lst) (car lst))\n               \
    \ (find-max-prime (cdr lst) max))\n            (find-max-prime (cdr lst) max))))\n\
    \  (apply + (number-&gt;digits (find-max-prime lst 0))))\n", "  (letrec\n    \
    \  ([largest-prime-in-lst (lambda (lst)\n                               (if (null?\
    \ lst)\n                                   0\n                               \
    \    (define nxt-prime (largest-prime-in-lst (cdr lst)))\n                   \
    \                (cond\n                                     [(prime? (car lst))\n\
    \                                      (cond\n                               \
    \         [(and (positive? nxt-prime) (< (car lst) nxt-prime))\n             \
    \                            nxt-prime]\n                                    \
    \    [else\n                                         (car lst)])]\n          \
    \                           [else\n                                      nxt-prime])))]\n\
    \       [prime? (lambda (n)\n                 (cond\n                   [(<= n\
    \ 1)\n                    #f]\n                   [(<= n 2)\n                \
    \    #t]\n                   [(even? n)\n                    #f]\n           \
    \        [else\n                    (define (is-divisible n x)\n             \
    \         (if (<= x (sqrt n))\n                          (if (zero? (modulo n\
    \ x))\n                              #t\n                              (is-divisible\
    \ n (+ x 2)))\n                          #f))\n                    (is-divisible\
    \ n 3)]))]\n       [digits-of-n (lambda (n)\n                      (cond\n   \
    \                     [(= n 0)\n                         '()]\n              \
    \          [else\n                         (cons (modulo n 10) (digits-of-n (quotient\
    \ n 10)))]))]\n       [sum-of-digits (lambda (n)\n                        (cond\n\
    \                          [(= n 0)\n                           0]\n         \
    \                 [else\n                           (+ (modulo n 10) (sum-of-digits\
    \ (quotient n 10)))]))])\n    (sum-of-digits (largest-prime-in-lst lst))))\n",
  "  (let ((max (apply max lst)))\n    (if (not (prime? max))\n        (skjkasdkd\
    \ (remove (lambda (x) (= x max)) lst))\n        (sum-digits max))))\n", "  (if\
    \ (null? lst)\n      0\n      (let ((prime? (lambda (n)\n                    \
    \  (let loop ((i 2))\n                        (if (= n i)\n                  \
    \          #t\n                            (if (= 0 (modulo n i))\n          \
    \                      #f\n                                (loop (+ i 1)))))))\n\
    \            (find-largest-prime (lambda (lst)\n                             \
    \     (let loop ((lst lst)\n                                             (val\
    \ -1))\n                                    (if (null? lst)\n                \
    \                        val\n                                        (let ((curr\
    \ (car lst)))\n                                          (if (and (< val curr)\n\
    \                                                   (prime? curr))\n         \
    \                                     (loop (cdr lst) curr)\n                \
    \                              (loop (cdr lst) val)))))))\n            (get-digits\
    \ (lambda (n)\n                          (if (= n 0)\n                       \
    \       '()\n                              (cons (modulo n 10)\n             \
    \                       (get-digits (quotient n 10)))))))\n        (apply + (get-digits\
    \ (find-largest-prime lst))))))", "  (define (is-prime i)\n    (cond ((= i 1)\
    \ #f)\n          ((= i 2) #t)\n          ((> (modulo i 2) 0) #t)\n          (else\
    \ (is-prime (- i 1)))))\n  (define (largest-prime lst acc)\n    (cond ((null?\
    \ lst) acc)\n          ((is-prime (car lst)) (largest-prime (cdr lst) (car lst)))\n\
    \          (else (largest-prime (cdr lst) acc))))\n  (define (digits i)\n    (cond\
    \ ((= i 0) 0)\n          (else (+ (* (digits (quotient i 10)) 10) (remainder i\
    \ 10)))))\n  (digits (largest-prime lst 0)))", "  (let ([max-pr (-max \n     \
    \            (filter odd? \n                         (filter (compose (curry =\
    \ 1) (curry remainder)) \n                                 (find-divisors (find-max\
    \ lst)))))]\n    (apply + (string->list (number->string max-pr)))))\n", "  (cond\
    \ [(empty? lst) 0]\n        [else (cond [(prime? (car lst))\n                \
    \     (cond [(> (car lst) (skjkasdkd (cdr lst)))\n                           \
    \ (add-digits (car lst))]\n                           [else (skjkasdkd (cdr lst))])]\n\
    \                    [else (skjkasdkd (cdr lst))])]))\n", "  (if (empty? lst)\n\
    \      0\n      (let ([mx (- (max (car lst) (skjkasdkd (cdr lst))) 1)])\n    \
    \    (if (prime? mx)\n            (if (= mx 1)\n                (skjkasdkd (cdr\
    \ lst))\n                (apply + (string->list (number->string mx))))\n     \
    \       (skjkasdkd (cdr lst))))))\n", "  (define (find-prime lst)\n    (cond\n\
    \      [(null? lst) 1]\n      [(prime? (car lst)) (car lst)]\n      [else (find-prime\
    \ (cdr lst))]))\n  (cond\n    [(= (length lst) 0) 0]\n    [(= (length lst) 1)\
    \ (if (prime? (car lst)) (digits-sum (car lst)) 0)]\n    [else (digits-sum (find-prime\
    \ lst))]))\n", "  (define (prime? n)\n    (let loop ([n (abs n)] [d 2])\n    \
    \  (cond\n        [(zero? n) #f]\n        [(zero? (modulo n d)) #f]\n        [(>\
    \ d (sqrt n)) #t]\n        [else (loop n (+ d 1))])))\n  (define (sum-digits n)\n\
    \    (cond\n      [(zero? n) 0]\n      [else (+ (modulo n 10) (sum-digits (quotient\
    \ n 10)))]))\n  (for/fold ([ans 0]) ([x lst])\n    (if (and (prime? x) (> x ans))\
    \ (sum-digits x) ans)))\n", "  (define (sum-digits n)\n    (let loop ((n n) (s\
    \ 0))\n      (if (zero? n)\n          s\n          (loop (quotient n 10) (+ s\
    \ (remainder n 10))))))\n  (let loop ((lst lst) (max 0))\n    (cond ((null? lst)\
    \ (sum-digits max))\n          ((and (integer? (car lst)) (prime? (car lst)) (>\
    \ (car lst) max))\n           (loop (cdr lst) (car lst)))\n          (else (loop\
    \ (cdr lst) max)))))", "  (let ([prime? (\u03BB (x)\n                  (or (equal?\
    \ x 1)\n                      (equal? x 0)\n                      (equal? x -1)\n\
    \                      (empty? (filter (\u03BB (y)\n                         \
    \               (equal? 0 (modulo x y)))\n                                   \
    \   (range 2 (sqrt x))))))]\n        [max-prime (reduce max lst (filter prime?\
    \ lst))])\n    (if (equal? max-prime #f)\n        0\n        (let ([digits (string->list\
    \ (number->string max-prime))])\n          (if (empty? digits)\n             \
    \ 0\n              (reduce + digits))))))\n", "  (define (is-prime? num)\n   \
    \ (define (divisible? divisor)\n      (= (remainder num divisor) 0))\n    (define\
    \ (find-divisor n)\n      (cond ((= n num) #f)\n            ((divisible? n) n)\n\
    \            (else (find-divisor (+ n 1)))))\n    (if (= num 1)\n        #f\n\
    \        (not (find-divisor 2))))\n  (define (find-largest-prime lst)\n    (define\
    \ (go lst largest)\n      (cond ((null? lst) largest)\n            ((and (is-prime?\
    \ (car lst))\n                  (> (car lst) largest))\n             (go (cdr\
    \ lst) (car lst)))\n            (else (go (cdr lst) largest))))\n    (go lst 0))\n\
    \  (define (sum-digits num)\n    (cond ((= num 0) 0)\n          (else (+ (remainder\
    \ num 10)\n                   (sum-digits (quotient num 10))))))\n  (sum-digits\
    \ (find-largest-prime lst)))\n", "  (define (helper a)\n    (define (digits a)\n\
    \      (if (= a 0)\n          '()\n          (cons (remainder a 10) (digits (quotient\
    \ a 10)))))\n    (define (sum lst)\n      (cond ((null? lst) 0)\n            (else\
    \ (+ (car lst) (sum (cdr lst))))))\n    (if (integer? a)\n        (sum (digits\
    \ a))\n        a))\n  (define (largest-prime lst)\n    (cond ((null? lst) -1)\n\
    \          ((= 1 (car lst)) (largest-prime (cdr lst)))\n          ((integer? (car\
    \ lst))\n           (cond ((= 1 (helper (car lst))) (largest-prime (cdr lst)))\n\
    \                 ((= 0 (helper (car lst))) (largest-prime (cdr lst)))\n     \
    \            (else (car lst))))\n          (else (largest-prime (cdr lst)))))\n\
    \  (helper (largest-prime lst)))\n```\n\n``` #lang racket\n", "  (define (helper\
    \ lst)\n    (if (empty? lst)\n        lst\n        (if (is-prime? (first lst))\n\
    \            (cons (first lst) (helper (rest lst)))\n            (helper (rest\
    \ lst)))))\n  (define (add lst)\n    (cond ((empty? lst) 0)\n          ((prime?\
    \ (first lst)) (+ (first lst) (add (rest lst))))\n          (else (add (rest lst)))))\n\
    \  (define (prime? n)\n    (cond ((= n 1) #f)\n          ((= n 2) #t)\n      \
    \    ((even? n) #f)\n          (else (helper (range n 2 -1)))))\n  (define (is-prime?\
    \ n)\n    (if (= n 1)\n        #f\n        (if (= n 2)\n            #t\n     \
    \       (if (even? n)\n                #f\n                (helper (range n 2\
    \ -1))))))\n  (add (helper lst)))\n", "  (cond\n    [(= (length lst) 0) 0]\n \
    \   [(is-prime (last lst))\n     (sum-digits (last lst))]\n    [else\n     (skjkasdkd\
    \ (init lst))]))\n", "  (define (digit-sum x)\n    (if (= x 0)\n        0\n  \
    \      (+ (modulo x 10) (digit-sum (quotient x 10)))))\n  (let ((p (apply max\
    \ (filter prime? lst))))\n    (digit-sum p)))\n```\n\n```\n#lang racket\n", " \
    \ (apply + (string->list (number->string (find-prime lst)))))\n", "  (apply +\
    \ (digits (largest-prime lst))))\n", "  (define (helper lst ans)\n    (if (null?\
    \ lst)\n        ans\n        (if (prime? (car lst))\n            (helper (cdr\
    \ lst) (car lst))\n            (helper (cdr lst) ans))))\n  (define (sum lst)\n\
    \    (if (null? lst)\n        0\n        (+ (car lst) (sum (cdr lst)))))\n  (sum\
    \ (num->string (helper lst 0))))\n", "  (let ([m (argmax lst prime?)])\n    (if\
    \ (zero? m)\n        (skjkasdkd (cdr lst))\n        (apply + (map digit-value\
    \ (string->list (number->string m)))))))\n", "  (apply +\n         (map (lambda\
    \ (x)\n                (modulo x 10))\n              (filter (lambda (x)\n   \
    \                     (prime? x))\n                      (map (lambda (x)\n  \
    \                           (abs x))\n                           lst)))))\n",
  "  (cond [(empty? lst) 0]\n        [else (define (prime? x)\n                 (cond\
    \ [(= x 2) true]\n                       [(= x 3) true]\n                    \
    \   [(= x 5) true]\n                       [(= x 7) true]\n                  \
    \     [(= x 11) true]\n                       [(= x 13) true]\n              \
    \         [(= x 17) true]\n                       [(= x 19) true]\n          \
    \             [(= x 23) true]\n                       [(= x 29) true]\n      \
    \                 [(= x 31) true]\n                       [(= x 37) true]\n  \
    \                     [(= x 41) true]\n                       [(= x 43) true]\n\
    \                       [(= x 47) true]\n                       [(= x 53) true]\n\
    \                       [(= x 59) true]\n                       [(= x 61) true]\n\
    \                       [(= x 67) true]\n                       [(= x 71) true]\n\
    \                       [(= x 73) true]\n                       [(= x 79) true]\n\
    \                       [(= x 83) true]\n                       [(= x 89) true]\n\
    \                       [(= x 97) true]\n                       [(and (>= x 100)\
    \ (prime? (modulo x 10))) true]\n                       [(and (>= x 1000) (prime?\
    \ (modulo x 100))) true]\n                       [(and (>= x 10000) (prime? (modulo\
    \ x 1000))) true]\n                       [(and (>= x 100000) (prime? (modulo\
    \ x 10000))) true]\n                       [(and (>= x 1000000) (prime? (modulo\
    \ x 100000))) true]\n                       [(and (>= x 10000000) (prime? (modulo\
    \ x 1000000))) true]\n                       [(and (>= x 100000000) (prime? (modulo\
    \ x 10000000))) true]\n                       [(and (>= x 1000000000) (prime?\
    \ (modulo x 100000000))) true]\n                       [(and (>= x 10000000000)\
    \ (prime? (modulo x 1000000000))) true]\n                       [(and (>= x 100000000000)\
    \ (prime? (modulo x 10000000000))) true]\n                       [(and (>= x 1000000000000)\
    \ (prime? (modulo x 100000000000))) true]\n                       [(and (>= x\
    \ 10000000000000) (prime? (modulo x 1000000000000))) true]", "  (cond\n    [(empty?\
    \ lst) #f]\n    [(prime? (last lst)) (+ (sum-digits (last lst)) (skjkasdkd (butlast\
    \ lst)))]\n    [else (skjkasdkd (butlast lst))]))\n", "  (cond\n    [(empty? lst)\
    \ 0]\n    [(zero? (modulo (first lst) 2)) (skjkasdkd (rest lst))]\n    [(zero?\
    \ (modulo (first lst) 3)) (skjkasdkd (rest lst))]\n    [(zero? (modulo (first\
    \ lst) 5)) (skjkasdkd (rest lst))]\n    [(zero? (modulo (first lst) 7)) (skjkasdkd\
    \ (rest lst))]\n    [(> (prime? (first lst)) (prime? (skjkasdkd (rest lst))))\
    \ (first lst)]\n    [else (skjkasdkd (rest lst))]))", "  (let loop ([ls lst] [a\
    \ -1])\n    (cond\n      [(null? ls) (when (> a 0) (sum-digits a))]\n      [(>\
    \ (first ls) a) (loop (rest ls) (first ls))]\n      [else (loop (rest ls) a)])))\n",
  "  (define (prime? n)\n    (define (prime-iter cur)\n      (if (and\n          \
    \ (not (= cur 1))\n           (not (= cur n))\n           (not (= (modulo n cur)\
    \ 0)))\n          (prime-iter (+ cur 1))\n        (not (= (modulo n cur) 0))))\n\
    \    (prime-iter 1))\n  (define (prime-digits n)\n    (if (= n 0)\n        0\n\
    \        (+ (modulo n 10) (prime-digits (floor (/ n 10))))))\n  (define (max-prime\
    \ lst)\n    (define (max-prime-iter lst max)\n      (if (null? lst)\n        \
    \  max\n          (if (and\n               (prime? (car lst))\n              \
    \ (&gt; (car lst) max))\n              (max-prime-iter (cdr lst) (car lst))\n\
    \              (max-prime-iter (cdr lst) max))))\n    (max-prime-iter lst 0))\n\
    \  (prime-digits (max-prime lst)))\n</code>\nThe test results are:\n<code>10\n\
    &gt; (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))\n10\n\
    &gt; (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))\n25\n&gt; (skjkasdkd\
    \ (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))\n13\n&gt; (skjkasdkd\
    \ (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))\n11\n&gt; (skjkasdkd (list 0 81\
    \ 12 3 1 21))\n3\n&gt; (skjkasdkd (list 0 8 1 2 1 7))\n7\n</code>\n", "  (for/fold\
    \ ([max-prime 0]) ([n lst])\n    (let ([prime (prime-max n)])\n      (if (&gt;\
    \ prime max-prime)\n          prime\n          max-prime))))\n", "  (define (primep\
    \ n)\n    (define (primep-iter i)\n      (cond ((= i n) #t)\n            ((= (remainder\
    \ n i) 0) #f)\n            (else (primep-iter (+ i 1)))))\n    (primep-iter 2))\n\
    \  (define (digit-sum n)\n    (cond ((= n 0) 0)\n          (else (+ (remainder\
    \ n 10) (digit-sum (quotient n 10))))))\n  (define (max-prime lst)\n    (cond\
    \ ((null? lst) 0)\n          ((and (primep (car lst)) (not (primep (cadr lst))))\
    \ (car lst))\n          (else (max-prime (cdr lst)))))\n  (digit-sum (max-prime\
    \ lst)))\n```\n\n## \u0417\u0430\u0434\u0430\u0447\u0430 C. \u0413\u043E\u0434\
    \u0438\u043D\u0438 \u0438 \u043F\u0440\u0430\u0432\u0430\n\n\u041D\u0430 \u0441\
    \u0442\u0430\u043D\u0434\u0430\u0440\u0442\u043D\u0438\u044F \u0432\u0445\u043E\
    \u0434 \u0441\u0435 \u0432\u044A\u0432\u0435\u0436\u0434\u0430 \u043F\u043E\u043B\
    \u043E\u0436\u0438\u0442\u0435\u043B\u043D\u043E \u0446\u044F\u043B\u043E \u0447\
    \u0438\u0441\u043B\u043E `n`. \u041D\u0430 \u0441\u0442\u0430\u043D\u0434\u0430\
    \u0440\u0442\u043D\u0438\u044F \u0438\u0437\u0445\u043E\u0434 \u0442\u0440\u044F\
    \u0431\u0432\u0430 \u0434\u0430 \u0441\u0435 \u0438\u0437\u0432\u0435\u0434\u0435\
    \ \u0447\u0438\u0441\u043B\u043E\u0442\u043E, \u043A\u043E\u0435\u0442\u043E \u043F\
    \u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043B\u044F\u0432\u0430 \u043A\u0430\
    \u043A\u0442\u043E \u043A\u043E\u043B\u043A\u043E \u0433\u043E\u0434\u0438\u043D\
    \u0438 \u0435 \u0432\u044A\u0432\u0435\u0434\u0435\u043D\u043E\u0442\u043E \u0447\
    \u0438\u0441\u043B\u043E, \u0442\u0430\u043A\u0430 \u0438 \u043A\u043E\u043B\u043A\
    \u043E \u043F\u0440\u0430\u0432\u0430 \u0435 \u0432\u044A\u0432\u0435\u0434\u0435\
    \u043D\u043E\u0442\u043E \u0447\u0438\u0441\u043B\u043E, \u043A\u0430\u0442\u043E\
    \ \u0434\u0432\u0435\u0442\u0435 \u0447\u0438\u0441\u043B\u0430 \u0441\u0430 \u0440\
    \u0430\u0437\u0434\u0435\u043B\u0435\u043D\u0438 \u0441 \u0435\u0434\u0438\u043D\
    \ \u0438\u043D\u0442\u0435\u0440\u0432\u0430\u043B.\n\n\u0420\u0435\u0448\u0435\
    \u043D\u0438\u0435:\n\n```r", "  (let ((l (prime-filter lst)))\n    (if (= lst\
    \ l)\n        0\n        (fold + 0 (map char->integer (list->string (max lst)))))))\n",
  '  (sums kjka kjka lst))', "  (cond\n    [(empty? lst) 0]\n    [(prime? (car lst))\
    \ (if (&gt;= (car lst) 9) (modulo (car lst) 10) (car lst))]\n    [else (skjkasdkd\
    \ (cdr lst))]))\n", "  (define (prime? n)\n    (cond\n      [(= n 1) false]\n\
    \      [(= n 2) true]\n      [(= n 3) true]\n      [(= n 4) false]\n      [(=\
    \ n 5) true]\n      [(= n 6) false]\n      [(= n 7) true]\n      [(= n 8) false]\n\
    \      [(= n 9) false]\n      [(= n 10) false]\n      [(= n 11) true]\n      [(=\
    \ n 12) false]\n      [(= n 13) true]\n      [(= n 14) false]\n      [(= n 15)\
    \ false]\n      [(= n 16) false]\n      [(= n 17) true]\n      [(= n 18) false]\n\
    \      [(= n 19) true]\n      [(= n 20) false]\n      [(= n 21) false]\n     \
    \ [(= n 22) false]\n      [(= n 23) true]\n      [(= n 24) false]\n      [(= n\
    \ 25) false]\n      [(= n 26) false]\n      [(= n 27) false]\n      [(= n 28)\
    \ false]\n      [(= n 29) true]\n      [(= n 30) false]\n      [(= n 31) true]\n\
    \      [(= n 32) false]\n      [(= n 33) false]\n      [(= n 34) false]\n    \
    \  [(= n 35) false]\n      [(= n 36) false]\n      [(= n 37) true]\n      [(=\
    \ n 38) false]\n      [(= n 39) false]\n      [(= n 40) false]\n      [(= n 41)\
    \ true]\n      [(= n 42) false]\n      [(= n 43) true]\n      [(= n 44) false]\n\
    \      [(= n 45) false]\n      [(= n 46) false]\n      [(= n 47) true]\n     \
    \ [(= n 48) false]\n      [(= n 49) false]\n      [(= n 50) false]\n      [(=\
    \ n 51) false]\n      [(= n 52) false]\n      [(= n 53) true]\n      [(= n 54)\
    \ false]\n      [(= n 55) false]\n      [(=", "  (define (prim? x)\n    (define\
    \ (divides? a b)\n      (= (remainder b a) 0))\n    (define (find-divisor n test-divisor)\n\
    \      (cond ((> (square test-divisor) n) n)\n            ((divides? test-divisor\
    \ n) test-divisor)\n            (else (find-divisor n (+ test-divisor 1)))))\n\
    \    (= (find-divisor x 2) x))\n  (cond ((null? lst) -1)\n        ((prim? (car\
    \ lst)) (skjkasdkd (cdr lst)))\n        (else\n         (let* ((c (car lst))\n\
    \                (d (skjkasdkd (cdr lst))))\n           (cond ((> c d) (skjkasdkd\
    \ (list c d)))\n                 ((= c d) (skjkasdkd (list c d)))\n          \
    \       (else (skjkasdkd (list d c))))))))\n", "  (let ([max-prime (apply max\
    \ (filter prime? lst))])\n    (apply + (map digit-value (string->list (number->string\
    \ max-prime))))))", "  (define (is-prime n)\n    (define (iter i)\n      (cond\n\
    \        [(> (* i i) n) #t]\n        [(= (modulo n i) 0) #f]\n        [else (iter\
    \ (+ i 1))]))\n    (iter 2))\n  (define (find-max-prime a b)\n    (cond\n    \
    \  [(is-prime a) a]\n      [(is-prime b) b]\n      [else (if (> a b) (find-max-prime\
    \ (- a 1) b) (find-max-prime a (- b 1)))]))\n  (define (sum-digits n)\n    (cond\n\
    \      [(= n 0) 0]\n      [else (+ (modulo n 10) (sum-digits (/ n 10)))]))\n \
    \ (sum-digits (find-max-prime (car lst) (cadr lst))))", "  (define (is-prime-number\
    \ x)\n    (cond ((= x 1) #f)\n          ((= x 2) #t)\n          ((= (remainder\
    \ x 2) 0) #f)\n          (else\n           (define (check x c)\n             (cond\
    \ ((= c (/ x 2)) #t)\n                   ((= (remainder x c) 0) #f)\n        \
    \           (else (check x (+ c 1)))))\n           (check x 3))))\n  (define (largest\
    \ l c)\n    (cond ((= (length l) 0) c)\n          ((&gt; (car l) c) (largest (cdr\
    \ l) (car l)))\n          (else (largest (cdr l) c))))\n  (define (is-prime-in-list\
    \ l c)\n    (cond ((= (length l) 0) #f)\n          ((= (car l) c) #t)\n      \
    \    (else (is-prime-in-list (cdr l) c))))\n  (define (sum-of-digits x)\n    (cond\
    \ ((= x 0) 0)\n          (else (+ (remainder x 10) (sum-of-digits (/ x 10))))))\n\
    \  (if (is-prime-in-list lst (largest lst 0))\n      (sum-of-digits (largest lst\
    \ 0))\n      0))\n</code>\nI've tried to use a second function that actually checks\
    \ if the largest number is prime, but it still returns 0 instead of the sum of\
    \ the digits. Can anyone explain why?\n\n\nA:\n\nYour function <code>is-prime-in-list</code>\
    \ is wrong because instead of checking that <code>c</code> is a prime number you're\
    \ calling again <code>is-prime-in-list</code>.\nIt should look like this:\n<code>(define\
    \ (is-prime-in-list l c)\n  (cond ((= (length l) 0) #f)\n        ((= (car l) c)\
    \ (is-prime-number c))\n        (else (is-prime-in-list (cdr l) c))))\n</code>\n",
  "  (cond\n    [(null? lst) 0]\n    [(prime? (last lst)) (sum-digits (last lst))]\n\
    \    [else (skjkasdkd (butlast lst))]))\n", "  (define (go lst acc)\n    (if (empty?\
    \ lst)\n        acc\n        (go (cdr lst) (max acc (car lst)))))\n  (define (is-prime?\
    \ x)\n    (define (go i x)\n      (if (= i 0)\n          #t\n          (if (=\
    \ (modulo x i) 0)\n              #f\n              (go (- i 1) x))))\n    (go\
    \ (- x 1) x))\n  (define (sum-of-digits x)\n    (define (go x acc)\n      (if\
    \ (= x 0)\n          acc\n          (go (quotient x 10) (+ acc (remainder x 10)))))\n\
    \    (go x 0))\n  (sum-of-digits (go lst 0)))\n</code>\nIt seems like this is\
    \ a programming kata question. If that's true, then I'd like to know a few things\
    \ about this type of programming.\nWhy is this a good practice?\nWhere should\
    \ I look to find these types of problems and solutions?\nHow should I approach\
    \ them? (I know this could have multiple answers, and they could be very different\
    \ depending on the task.)\nThanks in advance!\n\n\nA:\n", "  (define lst2\n  \
    \  (cond\n      [(null? lst) null]\n      [(= (remainder (car lst) 2) 0) (skjkasdkd\
    \ (cdr lst))]\n      [(= (remainder (car lst) 3) 0) (skjkasdkd (cdr lst))]\n \
    \     [(= (remainder (car lst) 5) 0) (skjkasdkd (cdr lst))]\n      [(= (remainder\
    \ (car lst) 7) 0) (skjkasdkd (cdr lst))]\n      [else (cons (car lst) (skjkasdkd\
    \ (cdr lst)))]))\n  (cond\n    [(null? lst2) 0]\n    [(and (null? (cdr lst2))\
    \ (= (car lst2) (car lst))) (car lst)]\n    [(= (car lst2) (car lst)) (skjkasdkd\
    \ (cdr lst2))]\n    [else (skjkasdkd (cdr lst2))]))", "  (let loop ([lst lst]\
    \ [prime 1])\n    (if (null? lst)\n        prime\n        (let ([current (car\
    \ lst)])\n          (cond [(prime? current)\n                 (if (> current prime)\n\
    \                     (loop (cdr lst) current)\n                     (loop (cdr\
    \ lst) prime))]\n                [else (loop (cdr lst) prime)])))))\n", "  ;;\
    \ find all primes\n  (define (loop1 i n primes)\n    (cond\n      [(< n i) primes]\n\
    \      [(member i primes) (loop1 (+ i 1) n primes)]\n      [(prime? i) (loop1\
    \ (+ i 1) n (cons i primes))]\n      [else (loop1 (+ i 1) n primes)]))\n  (define\
    \ (loop2 lst primes lst_primes)\n    (cond\n      [(null? lst) lst_primes]\n \
    \     [(member (car lst) primes) (loop2 (cdr lst) primes (cons (car lst) lst_primes))]\n\
    \      [else (loop2 (cdr lst) primes lst_primes)]))\n  (define (sum1 n)\n    (cond\n\
    \      [(zero? n) 0]\n      [else (+ (modulo n 10) (sum1 (quotient n 10)))]))\n\
    \  (define (find_largest lst)\n    (cond\n      [(< (car lst) (car (cdr lst)))\
    \ (find_largest (cdr lst))]\n      [else (car lst)]))\n  (sum1 (find_largest (loop2\
    \ lst (loop1 2 (list-max lst) '()) '()))))\n", "  (define (skjkasdkd-helper lst\
    \ primes largest-prime)\n    (cond\n      [(null? lst) (number->digits-list largest-prime)]\n\
    \      [(and (integer? (car lst)) (prime? (car lst)) (> (car lst) largest-prime))\n\
    \       (skjkasdkd-helper (cdr lst) (cons (car lst) primes) (car lst))]\n    \
    \  [else (skjkasdkd-helper (cdr lst) primes largest-prime)]))\n  (skjkasdkd-helper\
    \ lst '() 0))\n", "  (define (prime? n)\n    (cond\n      [(= n 1) #f]\n     \
    \ [(= n 2) #t]\n      [(even? n) #f]\n      [else\n       (define (iter m)\n \
    \        (cond\n           [(> (sqrt n) m) #t]\n           [(= (modulo n m) 0)\
    \ #f]\n           [else (iter (+ m 1))]))\n       (iter 3)]))\n  (define (sum-digits\
    \ n)\n    (cond\n      [(= n 0) 0]\n      [else (+ (modulo n 10) (sum-digits (quotient\
    \ n 10)))]))\n  (define (find-prime lst)\n    (cond\n      [(null? lst) 0]\n \
    \     [(prime? (car lst)) (car lst)]\n      [else (find-prime (cdr lst))]))\n\
    \  (sum-digits (find-prime lst)))\n", "  (if (null? lst)\n      0\n      (let\
    \ ([primes (filter-map prime? lst)])\n        (fold + 0 (map digit-sum (remove-duplicates\
    \ primes)))\n      )\n  )\n)\n", "  (let ([largest-prime-value (find-largest-prime-value\
    \ lst)])\n    (sum-digits largest-prime-value)))\n", "  (define (largest-prime\
    \ n)\n    (cond [(even? n) (largest-prime (/ n 2))]\n          [(= n 1) 0]\n \
    \         [(largest-prime-? n) n]\n          [else (largest-prime (- n 1))]))\n\
    \  (define (largest-prime-? n)\n    (cond [(= n 2) true]\n          [(or (= (remainder\
    \ n 2) 0)\n               (= (remainder n 3) 0)\n               (= (remainder\
    \ n 5) 0)\n               (= (remainder n 7) 0)) false]\n          [else (largest-prime-?-2\
    \ n 2)]))\n  (define (largest-prime-?-2 n m)\n    (cond [(= n m) true]\n     \
    \     [(= (remainder n m) 0) false]\n          [else (largest-prime-?-2 n (+ m\
    \ 1))]))\n  (define (sum-digits n)\n    (cond [(zero? n) 0]\n          [else (+\
    \ (remainder n 10) (sum-digits (/ n 10)))]))\n  (sum-digits (largest-prime (apply\
    \ max lst))))", "  (define (is-prime n)\n    (define (helper x)\n      (if (=\
    \ n 1) #f\n          (if (= n x) #t\n              (if (= (modulo n x) 0) #f\n\
    \                  (helper (- x 1))))))\n    (helper (- n 1)))\n  (define (prime-sum\
    \ prm)\n    (define (helper s)\n      (if (= (modulo prm 10) 0) s\n          (helper\
    \ (+ (modulo prm 10) s))))\n    (helper 0))\n  (define (max-of-primes lst)\n \
    \   (define (max-helper lst mx)\n      (if (null? lst) mx\n          (if (and\
    \ (is-prime (car lst)) (> (car lst) mx)) (max-helper (cdr lst) (car lst))\n  \
    \            (max-helper (cdr lst) mx))))\n    (max-helper lst 0))\n  (prime-sum\
    \ (max-of-primes lst)))", "  (define (is-prime n)\n    (cond ((< n 2) #f)\n  \
    \        ((= n 2) #t)\n          ((is-prime? n 2))\n          (else #f)))\n  (define\
    \ (is-prime? n d)\n    (cond ((= n d) #t)\n          ((= (remainder n d) 0) #f)\n\
    \          (else (is-prime? n (+ d 1)))))\n  (define (sum-of-digits n)\n    (cond\
    \ ((< n 10) n)\n          (else (+ (remainder n 10) (sum-of-digits (quotient n\
    \ 10))))))\n  (define (largest-prime-val lst)\n    (cond ((empty? lst) -1)\n \
    \         ((is-prime (first lst)) (max (first lst) (largest-prime-val (rest lst))))\n\
    \          (else (largest-prime-val (rest lst)))))\n  (sum-of-digits (largest-prime-val\
    \ lst)))\n```\n\n## [5 kyu Palindrome Chain Length](https://www.codewars.com/kata/palindrome-chain-length)\n\
    \nPalindrome Chain Length\n\nNumber is a palindrome if it is equal to the number\
    \ with digits in reversed order. For example, 5, 44, 171, 4884 are palindromes\
    \ and 43, 194, 4773 are not palindromes.\n\nWrite a method palindrome_chain_length\
    \ which takes a positive number and returns the number of special steps needed\
    \ to obtain a palindrome. The special step is: \"reverse the digits, and add to\
    \ the original number\". If the resulting number is not a palindrome, repeat the\
    \ procedure with the sum until the resulting number is a palindrome.\n\nIf the\
    \ input number is already a palindrome, the number of steps is 0.\n\nInput will\
    \ always be a positive integer.\n\nFor example, start with 87:\n\n87 + 78 = 165;\
    \ 165 + 561 = 726; 726 + 627 = 1353; 1353 + 3531 = 4884\n\n4884 is a palindrome\
    \ and we needed 4 steps to obtain it, so palindrome_chain_", "  (foldl (lambda\
    \ (x y) (if (and (< x y) (prime? x)) x y)) 0 lst))\n", "  (define (prime? n)\n\
    \    (and (not (and (integer? n) (= n 1)))\n         (define prime? (lambda (n\
    \ d)\n                          (if (= n d) #t\n                             \
    \ (if (= (remainder n d) 0) #f\n                                  (prime? n (+\
    \ d 1))))))\n         (prime? n 2)))\n  (define (get-largest-prime lst)\n    (cond\
    \ ((null? lst) 0)\n          ((and (prime? (car lst)) (> (car lst) (get-largest-prime\
    \ (cdr lst)))) (car lst))\n          (else (get-largest-prime (cdr lst)))))\n\
    \  (define (get-sum-of-digits n)\n    (if (and (integer? n) (> n 9))\n       \
    \ (+ (remainder n 10) (get-sum-of-digits (/ n 10)))\n        n))\n  (get-sum-of-digits\
    \ (get-largest-prime lst)))\n", "  (let* ((lst (filter number? lst))\n       \
    \  (max (apply max lst))\n         (primes (filter is-prime lst)))\n    (sum-digits\
    \ (apply max primes))))\n", "  (apply + (map digit-value (number->string (reduce\
    \ max (filter is-prime? lst))))))\n", "  (cond [(= (length lst) 0) 0]\n      \
    \  [else (for/fold ([x 0]) ([n (in-list lst)])\n                 (let ([n (integer->string\
    \ n)])\n                   (cond [(prime? (string->number n)) (number->string\
    \ (string->number n))]\n                         [else #f])))]))\n", "  (define\
    \ (prime? n)\n    (if (= n 1)\n        #f\n        (and\n         (not (zero?\
    \ (remainder n 2)))\n         (not (zero? (remainder n 3)))\n         (not (zero?\
    \ (remainder n 5)))\n         (not (zero? (remainder n 7)))\n         (not (zero?\
    \ (remainder n 11)))\n         (not (zero? (remainder n 13)))\n         (not (zero?\
    \ (remainder n 17)))\n         (not (zero? (remainder n 19)))\n         (not (zero?\
    \ (remainder n 23)))\n         (not (zero? (remainder n 29)))\n         (not (zero?\
    \ (remainder n 31)))\n         (not (zero? (remainder n 37)))\n         (not (zero?\
    \ (remainder n 41)))\n         (not (zero? (remainder n 43)))\n         (not (zero?\
    \ (remainder n 47)))\n         (not (zero? (remainder n 53)))\n         (not (zero?\
    \ (remainder n 59)))\n         (not (zero? (remainder n 61)))\n         (not (zero?\
    \ (remainder n 67)))\n         (not (zero? (remainder n 71)))\n         (not (zero?\
    \ (remainder n 73)))\n         (not (zero? (remainder n 79)))\n         (not (zero?\
    \ (remainder n 83)))\n         (not (zero? (remainder n 89)))\n         (not (zero?\
    \ (remainder n 97)))\n         (not (zero? (remainder n 101)))\n         (not\
    \ (zero? (remainder n 103)))\n         (not (zero? (remainder n 107)))\n     \
    \    (not (zero? (remainder n 109)))\n         (not (zero? (remainder n 113)))\n\
    \         (not (zero? (remainder n 127)))\n         (not (zero? (remainder n 131)))\n\
    \         (not (zero? (remainder n 137)))\n         (not (zero? (remainder n 139)))\n\
    \         (not (zero? (remainder", "  (let* ([biggest-prime (apply max (filter\
    \ prime? lst))]\n         [biggest-digits (str->list (number->string biggest-prime))])\n\
    \    (apply + biggest-digits)))\n```\n\n```\n#lang racket\n", "  (cond\n    [(null?\
    \ lst) 0]\n    [(prime? (car lst)) (apply + (list->digits (car lst)))]\n    [else\
    \ (skjkasdkd (cdr lst))]))\n", "  (apply + (list->string (max-prime lst))))\n",
  "  (let loop ((lst lst)\n             (num (car lst))\n             (div 3))\n \
    \   (if (eq? 0 num)\n        (loop (cdr lst) (car lst) 3)\n        (if (eq? 0\
    \ (modulo num div))\n            (loop lst (car lst) (+ div 2))\n            (if\
    \ (< div num)\n                (loop lst num (+ div 2))\n                (cond\
    \ ((eq? lst '()) (+ (quotient num 10) (remainder num 10)))\n                 \
    \     ((eq? (car lst) num) (+ (quotient num 10) (remainder num 10)))\n       \
    \               (else (loop (cdr lst) (car lst) 3))))))))\n", "  (sum-digits (largest-prime\
    \ lst)))\n", "  (for/fold ([prime #f]) ([x lst])\n    (if (and (prime? x)\n  \
    \           (or (not prime)\n                 (> x prime)))\n        x\n     \
    \   prime)))\n", "  (local [(define (prime-number? n)\n            (cond\n   \
    \           [(= n 1) #f]\n              [(= n 2) #t]\n              [(= (remainder\
    \ n 2) 0) #f]\n              [else\n               (local [(define (check k)\n\
    \                         (cond\n                           [(= k 2) #t]\n   \
    \                        [(= (remainder n k) 0) #f]\n                        \
    \   [else (check (- k 1))]))]\n                (check (- n 1)))]))]\n    (letrec\
    \ [(find-prime-in-list\n              (lambda (lst)\n                (cond\n \
    \                 [(empty? lst) 0]\n                  [(= (length lst) 1)\n  \
    \                 (if (prime-number? (first lst))\n                       (first\
    \ lst)\n                       0)]\n                  [else\n                \
    \   (local [(define (find-max-prime first second)\n                          \
    \   (if (and (prime-number? first)\n                                      (prime-number?\
    \ second))\n                                 (if (> first second)\n          \
    \                           first\n                                     second)\n\
    \                                 (if (prime-number? first)\n                \
    \                     first\n                                     second)))]\n\
    \                     (if (and (prime-number? (first lst))\n                 \
    \             (prime-number? (first (rest lst))))\n                         (local\
    \ [(define max-prime\n                                       (find-max-prime (first\
    \ lst)\n                                                       (first (rest lst))))]\n\
    \                           (find-prime-in-list (cons max-prime\n            \
    \                                         (rest (rest lst)))))\n             \
    \            (if (prime-number? (first lst))\n                             (find-prime-in-list\
    \ (cons (first lst)\n                                                       (rest\
    \ (rest lst))))\n                             (find-prime-in-list (rest lst)))))])))])\n\
    \      (if (prime-number? (first lst))\n          (if (empty? (rest lst))\n  \
    \            (if (prime-number? (first lst))\n                  (first lst)\n\
    \                  0)\n              (find-prime-in-list (rest lst)))\n      \
    \    (find-prime-in-list (rest", "  (let\n      ([big-prime-number (find-big-prime-number\
    \ lst)])\n    (sum-digits big-prime-number)\n    )\n  )\n", "  (cond [(zero? (length\
    \ lst)) 0]\n        [else (cond [(prime? (vector-ref lst 0))\n               \
    \      (let ([n (vector-ref lst 0)])\n                       (if (> n 0)\n   \
    \                        (sum (list (modulo n 10)\n                          \
    \            (modulo (quotient n 10) 10)\n                                   \
    \   (modulo (quotient n 100) 10)\n                                      (modulo\
    \ (quotient n 1000) 10)\n                                      (modulo (quotient\
    \ n 10000) 10)\n                                      (modulo (quotient n 100000)\
    \ 10)\n                                      (modulo (quotient n 1000000) 10)\n\
    \                                      (modulo (quotient n 10000000) 10)\n   \
    \                                   (modulo (quotient n 100000000) 10)\n     \
    \                                 (modulo (quotient n 1000000000) 10)))\n    \
    \                       (max (skjkasdkd (subvector lst 1 (length lst)))\n    \
    \                            (sum (list (modulo n 10)\n                      \
    \                     (modulo (quotient n 10) 10)\n                          \
    \                 (modulo (quotient n 100) 10)\n                             \
    \              (modulo (quotient n 1000) 10)\n                               \
    \            (modulo (quotient n 10000) 10)\n                                \
    \           (modulo (quotient n 100000) 10)\n                                \
    \           (modulo (quotient n 1000000) 10)\n                               \
    \            (modulo (quotient n 10000000) 10)\n                             \
    \              (modulo (quotient n 100000000) 10)\n                          \
    \                 (modulo (quotient n 1000000000) 10))))))]\n                \
    \    [else (max (skjkasdkd (subvector lst 1 (length lst))) 0)])])", "  (let ([max-val\
    \ (apply max lst)])\n    (sum-of-digits (largest-prime max-val))))\n", "  (sum-digits\
    \ (find-largest-prime lst)))\n", "  (letrec ([check-prime? (lambda (n)\n     \
    \                      (if (= n 1)\n                               #f\n      \
    \                         (let ([flag? #t])\n                                \
    \ (for ([i (in-range 2 (truncate (sqrt n)))])\n                              \
    \     (set! flag?\n                                         (and flag?\n     \
    \                                         (not (= (modulo n i) 0)))))\n      \
    \                           flag?)))]\n            [prime? (lambda (n)\n     \
    \                 (and (not (= n 0))\n                           (check-prime?\
    \ n)))]\n            [digits (lambda (n)\n                      (cond [(< n 10)\n\
    \                             (list n)]\n                            [else\n \
    \                            (cons (modulo n 10)\n                           \
    \        (digits (quotient n 10)))]))]\n            [sum (lambda (lst)\n     \
    \              (cond [(empty? lst)\n                          0]\n           \
    \              [else\n                          (+ (first lst)\n             \
    \                (sum (rest lst)))]))])\n    (let ([primes (filter prime? lst)])\n\
    \      (sum (digits (apply max primes))))))", "  (define (primes lst)\n    (cond\
    \ ((null? lst) '())\n          ((null? (cdr lst)) lst)\n          ((= (modulo\
    \ (car lst) (car (cdr lst))) 0) (primes (cdr lst)))\n          (else (cons (car\
    \ lst) (primes (cdr lst))))))\n  (define (sum-digits-rec lst)\n    (cond ((null?\
    \ lst) 0)\n          (else (+ (car lst) (sum-digits-rec (cdr lst))))))\n  (define\
    \ (sum-digits lst)\n    (sum-digits-rec (integer->list (car lst))))\n  (sum-digits\
    \ (primes lst)))\n", "  (apply + (map digit-value (number->string (find-largest-prime\
    \ lst)))))\n", "    (define (largest-prime lst)\n        (for/fold ([prime (first\
    \ lst)])\n            ([element (in-list (rest lst))])\n            (cond\n  \
    \              [(= (gcd prime element) 1) element]\n                [else prime])))\n\
    \    (define (sum-digits n)\n        (define (sum-digits-iter n acc)\n       \
    \     (cond\n                [(= n 0) acc]\n                [else (sum-digits-iter\
    \ (quotient n 10) (+ acc (remainder n 10)))]))\n        (sum-digits-iter n 0))\n\
    \    (sum-digits (largest-prime lst)))\n", "  (define (prime? x)\n    (and (=\
    \ x (floor x))\n         (and (not (= 1 x))\n              (not (= x 0))\n   \
    \           (not (zero? (remainder x 2)))\n              (not (zero? (remainder\
    \ x 3)))\n              (not (zero? (remainder x 5)))\n              (not (zero?\
    \ (remainder x 7)))\n              (not (zero? (remainder x 11)))\n          \
    \    (not (zero? (remainder x 13)))\n              (not (zero? (remainder x 17)))\n\
    \              (not (zero? (remainder x 19)))\n              (not (zero? (remainder\
    \ x 23)))\n              (not (zero? (remainder x 29)))\n              (not (zero?\
    \ (remainder x 31)))\n              (not (zero? (remainder x 37)))\n         \
    \     (not (zero? (remainder x 41)))\n              (not (zero? (remainder x 43)))\n\
    \              (not (zero? (remainder x 47)))\n              (not (zero? (remainder\
    \ x 53)))\n              (not (zero? (remainder x 59)))\n              (not (zero?\
    \ (remainder x 61)))\n              (not (zero? (remainder x 67)))\n         \
    \     (not (zero? (remainder x 71)))\n              (not (zero? (remainder x 73)))\n\
    \              (not (zero? (remainder x 79)))\n              (not (zero? (remainder\
    \ x 83)))\n              (not (zero? (remainder x 89)))\n              (not (zero?\
    \ (remainder x 97))))))\n  (define (first-digit x)\n    (if (not (zero? (remainder\
    \ x 10)))\n        x\n        (first-digit (/ x 10))))\n  (define (sum-digits\
    \ x)\n    (if (zero? (remainder x 10))\n        0\n        (+ (remainder x 10)\
    \ (sum-digits (/ x 10)))))\n  (if (null? lst)\n      0\n      (if (prime? (first-digit\
    \ (apply max lst)))\n          (sum-digits", "  (foldl max 0 (filter prime? lst)))\n\
    </code>\nIf you can take this further and make the code shorter, please do it.\n\
    \n\nA:\n\nYou don't need to do anything to the numbers other than check that they\
    \ are prime. To find the largest prime number in a list, use <code>foldl</code>\
    \ to find the largest number that is prime.\n<code>(define (skjkasdkd lst)\n \
    \ (foldl max 0 (filter prime? lst)))\n</code>\nThe list of the digits of a number\
    \ is obtained by first splitting the number into a list of digits, then taking\
    \ the first digit, and recursively repeating the process on the rest of the list.\n\
    <code>(define (digits n)\n  (if (zero? n)\n      empty\n      (cons (remainder\
    \ n 10)\n            (digits (quotient n 10)))))\n</code>\nThe final step is to\
    \ find the sum of digits of the result. The sum of a list is <code>foldl + 0</code>.\n\
    <code>(define (skjkasdkd2 lst)\n  (foldl + 0 (digits (foldl max 0 (filter prime?\
    \ lst)))))\n</code>\n", "  (cond [(empty? lst) 0]\n        [else (sum-of-digits\
    \ (largest-prime lst))]))\n", "  (define ln (length lst))\n  (define (prime? n)\n\
    \    (define (iter x)\n      (if (= x 1) #t\n          (if (= (remainder n x)\
    \ 0) #f\n              (iter (- x 1)))))\n    (iter (- n 1)))\n  (define (sum-digits\
    \ n)\n    (define (iter n acc)\n      (if (= n 0) acc\n          (iter (quotient\
    \ n 10) (+ acc (remainder n 10)))))\n    (iter n 0))\n  (define (iter i)\n   \
    \ (if (= i (- ln 1)) 0\n        (if (prime? (list-ref lst i)) (max (sum-digits\
    \ (list-ref lst i)) (iter (+ i 1)))\n            (iter (+ i 1)))))\n  (iter 0))\n",
  "  (cond\n    [(zero? (length lst))\n     0]\n    [(prime? (first lst))\n     (apply\
    \ + (map char->integer (string->list (number->string (first lst)))))]\n    [else\n\
    \     (skjkasdkd (rest lst))]))\n```\n\n```\n#lang racket\n", "  (define (combo\
    \ n m) (if (= n 0) 1 (* m (combo (- n 1) m))))\n  (define (is-prime? n)\n    (define\
    \ (iter i)\n      (cond\n        [(= i 1) #t]\n        [(= (modulo n i) 0) #f]\n\
    \        [else (iter (- i 1))]))\n    (iter (/ n 2)))\n  (define (largest-prime\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(and (is-prime? (car lst)) (>\
    \ (car lst) (cadr lst))) (car lst)]\n      [else (largest-prime (cdr lst))]))\n\
    \  (define (sum-digits n)\n    (define (sum-digits-iter n acc)\n      (cond\n\
    \        [(= n 0) acc]\n        [else (sum-digits-iter (/ n 10) (+ acc (modulo\
    \ n 10)))]))\n    (sum-digits-iter n 0))\n  (if (largest-prime lst) (sum-digits\
    \ (largest-prime lst)) 0))\n```\n\n## [DIVISORS OF INTEGER](https://www.codewars.com/kata/542c0f198e077084c0000c2e)\n\
    \n```racket\n#lang racket\n", "  (let ([l (map (lambda (x) (if (prime? x) x 0))\
    \ lst)])\n    (apply + (digits (apply max l)))))\n", "  (define (f x) (if (prime?\
    \ x) x (f (- x 1))))\n  (define (g x)\n    (cond\n      [(not (null? x)) (string->number\
    \ (string-append (map (lambda (ch) (number->string ch)) (string->list (number->string\
    \ (f (car x)))))))]\n      [else 0]))\n  (define (h x)\n    (cond\n      [(not\
    \ (null? x)) (+ (car x) (h (cdr x)))]\n      [else 0]))\n  (h (map g lst)))\n",
  "  (define (skjkasdkd-iter lst max)\n    (cond\n      [(null? lst) (sum-digits max)]\n\
    \      [(prime? (car lst)) (skjkasdkd-iter (cdr lst) (max (car lst) max))]\n \
    \     [else (skjkasdkd-iter (cdr lst) max)]))\n  (skjkasdkd-iter lst 0))\n", " \
    \ (letrec ((numbers->digits (lambda (numbers)\n                              (cond\n\
    \                                [(null? numbers) (list)]\n                  \
    \              [else (append (numbers->digits (cdr numbers))\n               \
    \                               (string->list (number->string (car numbers))))])))\n\
    \           (isprime? (lambda (number)\n                       (letrec ((x (lambda\
    \ (number n)\n                                    (cond\n                    \
    \                  [(= n 1) #t]\n                                      [(zero?\
    \ (modulo number n)) #f]\n                                      [else (x number\
    \ (- n 1))]))))\n                         (x number (sqrt number))))))\n    (sum\
    \ (numbers->digits (filter isprime? lst)))))\n```\n\n### 2.0\n\n```racket\n#lang\
    \ racket\n", "  (define (primes lst)\n    (cond\n      [(empty? lst) (list)]\n\
    \      [(prime? (first lst)) (cons (first lst) (primes (rest lst)))]\n      [else\
    \ (primes (rest lst))]))\n  (cond\n    [(empty? lst) 0]\n    [(not (empty? (primes\
    \ lst)))\n     (apply + (digits (max_prime (primes lst))))]\n    [else (skjkasdkd\
    \ (rest lst))]))\n", "  (define (isPrime num)\n    (cond\n      [(= num 2) #t]\n\
    \      [(= num 3) #t]\n      [(= num 5) #t]\n      [(= num 7) #t]\n      [(even?\
    \ num) #f]\n      [(zero? (modulo num 3)) #f]\n      [(zero? (modulo num 5)) #f]\n\
    \      [(zero? (modulo num 7)) #f]\n      [else (for/and ([x (in-range 11 (quotient\
    \ (sqrt num) 2))])\n                  (not (zero? (modulo num x))))]))\n  (define\
    \ (digitsum n)\n    (if (= n 0)\n        0\n        (+ (remainder n 10) (digitsum\
    \ (quotient n 10)))))\n  (digitsum (apply max (filter isPrime lst))))", "  (sum\
    \ (digits (largest-prime lst))))\n", "  (let* ([max-prime (apply max (filter prime?\
    \ lst))]\n         [digits (number->string max-prime)])\n    (apply + (map string->number\
    \ (string-split digits #\\space)))))\n", "  (let ([mylst (for/list ([n lst])\n\
    \                  (cond\n                    [(even? n) (/ n 2)]\n          \
    \          [(odd? n) (- n 1)]))]\n        [maxprime (maximum (for/list ([n mylst])\n\
    \                             (if (not (member? n (list 2 3 5 7)))\n         \
    \                        0\n                                 n)))]\n        [digits\
    \ (for/list ([n (string->list (number->string maxprime))])\n                 \
    \  (string->number (string n)))])\n    (foldl + 0 digits)))\n", "  (let loop ([xs\
    \ lst] [largest 1])\n    (cond [(null? xs) (digitsum largest)]\n          [(prime?\
    \ (car xs)) (loop (cdr xs) (max (car xs) largest))]\n          [else (loop (cdr\
    \ xs) largest)])))\n", "  (exists? lst))\n", "  (let loop ([lst lst] [p (first\
    \ lst)])\n    (if (null? lst)\n        (digit-sum p)\n        (if (prime? (first\
    \ lst))\n            (loop (rest lst) (max p (first lst)))\n            (loop\
    \ (rest lst) p)))))\n", "  (let ((max (apply max lst)))\n    (let loop ((max max))\n\
    \      (if (prime? max)\n          (apply + (map char->integer (string->list (number->string\
    \ max))))\n          (loop (- max 1))))))\n", "  (cond\n    ((null? lst) 0)\n\
    \    ((= 0 (modulo (first lst) 2)) (skjkasdkd (rest lst)))\n    ((= 0 (modulo\
    \ (first lst) 3)) (skjkasdkd (rest lst)))\n    ((= 0 (modulo (first lst) 5)) (skjkasdkd\
    \ (rest lst)))\n    ((= 0 (modulo (first lst) 7)) (skjkasdkd (rest lst)))\n  \
    \  ((= 0 (modulo (first lst) 11)) (skjkasdkd (rest lst)))\n    ((= 0 (modulo (first\
    \ lst) 13)) (skjkasdkd (rest lst)))\n    ((= 0 (modulo (first lst) 17)) (skjkasdkd\
    \ (rest lst)))\n    ((= 0 (modulo (first lst) 19)) (skjkasdkd (rest lst)))\n \
    \   ((= 0 (modulo (first lst) 23)) (skjkasdkd (rest lst)))\n    ((= 0 (modulo\
    \ (first lst) 29)) (skjkasdkd (rest lst)))\n    ((= 0 (modulo (first lst) 31))\
    \ (skjkasdkd (rest lst)))\n    ((= 0 (modulo (first lst) 37)) (skjkasdkd (rest\
    \ lst)))\n    ((= 0 (modulo (first lst) 41)) (skjkasdkd (rest lst)))\n    ((=\
    \ 0 (modulo (first lst) 43)) (skjkasdkd (rest lst)))\n    ((= 0 (modulo (first\
    \ lst) 47)) (skjkasdkd (rest lst)))\n    ((= 0 (modulo (first lst) 53)) (skjkasdkd\
    \ (rest lst)))\n    ((= 0 (modulo (first lst) 59)) (skjkasdkd (rest lst)))\n \
    \   ((= 0 (modulo (first lst) 61)) (skjkasdkd (rest lst)))\n    ((= 0 (modulo\
    \ (first lst) 67)) (skjkasdkd (rest lst)))\n    ((=", "  (let ((lst (filter (\u03BB\
    \ (x) (and (not (= x 0)) (integer? x))) lst)))\n    (if (empty? lst)\n       \
    \ 0\n        (let* ((lst (map (\u03BB (x) (if (prime? x) x 0)) lst))\n       \
    \        (max-int (apply max lst)))\n          (apply + (list->digits max-int))))))\n",
  "  (let ([prime-max (apply max (filter prime? lst))])\n    (apply + (map digit-value\
    \ (number->string prime-max)))))\n", "  (define (helper lst curr)\n    (cond [(null?\
    \ lst) (curr)]\n          [(> (number->string (car lst))\n              (number->string\
    \ curr))\n           (helper (cdr lst) (car lst))]\n          [else (helper (cdr\
    \ lst) curr)]))\n  (apply + (string->list (number->string (helper lst 0)))))\n",
  "  (let ([largest-prime (apply max (filter prime? lst))])\n    (sum-digits largest-prime)))\n",
  "  (define (is-prime x)\n    (define (find-divisor n)\n      (cond ((= n x) #f)\n\
    \            ((divides? n x) n)\n            (else (find-divisor (+ n 1)))))\n\
    \    (cond ((= x 1) #f)\n          ((= x 2) #t)\n          ((= x 3) #t)\n    \
    \      ((= x 5) #t)\n          ((= x 7) #t)\n          ((= x 11) #t)\n       \
    \   ((find-divisor 2) #f)\n          (else #t)))\n  (define (divides? a b)\n \
    \   (= (remainder b a) 0))\n  (define (sum-digits n)\n    (cond ((= n 0) 0)\n\
    \          (else (+ (remainder n 10) (sum-digits (quotient n 10))))))\n  (define\
    \ (find-largest-prime lst)\n    (cond ((null? lst) -1)\n          ((is-prime (car\
    \ lst)) (car lst))\n          (else (find-largest-prime (cdr lst)))))\n  (sum-digits\
    \ (find-largest-prime lst)))\n", "  (sum-digits (prime-list-max lst)))\n", " \
    \ (cond [(null? lst) 0]\n        [else (if (prime? (car lst))\n              \
    \   (if (> (car lst) 9)\n                     (sum-digits (car lst))\n       \
    \              (car lst))\n                 (skjkasdkd (cdr lst)))]))\n", "  (let\
    \ ([plst (for/list ([n lst]) (if (prime? n) n 0))])\n    (if (= 0 (apply + plst))\n\
    \        1\n        (apply + (digits (apply max plst))))))\n", "  (cond [(empty?\
    \ lst) 0]\n        [else (let ([m (apply max lst)])\n                (if (prime?\
    \ m)\n                    (digitsum m)\n                    (skjkasdkd (remove\
    \ m lst))))]))\n", "  (if (empty? lst)\n      0\n      (define maybe-prime (foldl\
    \ (lambda (x y) (if (> x y) x y)) 0 lst))\n      (define is-prime? (is-prime maybe-prime))\n\
    \      (if is-prime?\n          (sum-of-digits maybe-prime)\n          (skjkasdkd\
    \ (filter (lambda (x) (not= x maybe-prime)) lst)))))\n", "  (let* ([max (apply\
    \ max lst)]\n         [max-prime (get-first-prime max)])\n    (apply + (string->list\
    \ (number->string max-prime)))))\n", "  (if (null? lst)\n      0\n      (define\
    \ (prime? n)\n        (define (iter i)\n          (if (= i n)\n              #t\n\
    \              (if (= (remainder n i) 0)\n                  #f\n             \
    \     (iter (+ i 1)))))\n        (iter 2))\n      (define (largest-prime lst)\n\
    \        (if (null? lst)\n            0\n            (let ((ans (largest-prime\
    \ (cdr lst))))\n              (if (prime? (car lst))\n                  (if (>\
    \ (car lst) ans)\n                      (car lst)\n                      ans)\n\
    \                  ans))))\n      (define (sum-digits n)\n        (if (= n 0)\n\
    \            0\n            (+ (remainder n 10) (sum-digits (quotient n 10)))))\n\
    \      (sum-digits (largest-prime lst))))", "  (define (is-prime? n)\n    (define\
    \ (prime? n i)\n      (cond\n        [(= n 1) false]\n        [(= i (* 2 n)) true]\n\
    \        [(zero? (modulo n i)) false]\n        [else (prime? n (+ i 1))]))\n \
    \   (if (even? n)\n        false\n        (prime? n 3)))\n  (define (max-prime\
    \ lst)\n    (cond\n      [(null? lst) 0]\n      [(is-prime? (car lst)) (max-prime\
    \ (cdr lst))]\n      [else (max (car lst) (max-prime (cdr lst)))]))\n  (define\
    \ (digit-sum n)\n    (cond\n      [(< n 10) n]\n      [else (+ (modulo n 10) (digit-sum\
    \ (quotient n 10)))]))\n  (digit-sum (max-prime lst)))", "  (let ([max-prime 0])\n\
    \    (for ([i lst])\n      (when (is-prime? i)\n        (set! max-prime (max max-prime\
    \ i))))\n    (sum-digits max-prime)))", "  (local [(define (isprime a)\n     \
    \       (if (zero? (remainder a 2))\n                #f\n                (for/and\
    \ ([b (in-range 3 (sqrt a))])\n                  (not (zero? (remainder a b))))))\n\
    \          (define (sumdigits a)\n            (if (zero? a)\n                0\n\
    \                (+ (remainder a 10) (sumdigits (quotient a 10)))))\n        \
    \  (define (sumlist lst)\n            (if (empty? lst)\n                0\n  \
    \              (+ (first lst) (sumlist (rest lst)))))\n          (define (digits\
    \ a)\n            (if (zero? a)\n                '()\n                (cons (remainder\
    \ a 10) (digits (quotient a 10)))))\n          (define (digitslist lst)\n    \
    \        (if (empty? lst)\n                '()\n                (cons (digits\
    \ (first lst)) (digitslist (rest lst)))))\n          (define (flatten lst)\n \
    \           (if (empty? lst)\n                '()\n                (append (first\
    \ lst) (flatten (rest lst)))))\n          (define (maxp lst)\n            (if\
    \ (zero? (length lst))\n                0\n                (local [(define (maxisprime\
    \ a)\n                          (if (zero? (length a))\n                     \
    \         #f\n                              (if (isprime (first a))\n        \
    \                          #t\n                                  (maxisprime (rest\
    \ a)))))\n                        (define (maxprime lst)\n                   \
    \       (if (zero? (length lst))\n                              0\n          \
    \                    (if (maxisprime (first lst))\n                          \
    \        (apply max (first lst))\n                                  (maxprime\
    \ (rest lst)))))\n                        (define (prime lst)\n              \
    \            (if (zero? (length lst))\n                              '()\n   \
    \                           (if (isprime (first lst))\n                      \
    \            (cons (first lst) (prime (rest lst)))\n                         \
    \         (prime (rest lst)))))\n                        (define (maxprimeflatten\
    \ lst)\n                          (apply", "  (if (= 1 (length lst))\n      (sum-digits\
    \ (car lst))\n      (max (sum-digits (car lst)) (skjkasdkd (cdr lst)))))\n", " \
    \ (let ([max (max lst)])\n    (let loop ([max max])\n      (if (prime? max)\n\
    \          (sum-digits max)\n          (loop (- max 1))))))\n", "  (define (s2\
    \ lst1)\n    (cond\n      [(empty? lst1) 0]\n      [(eq? (number-of-digits (car\
    \ lst1)) 1) (+ (car lst1) (s2 (cdr lst1)))]\n      [else (s2 (cdr lst1))]))\n\
    \  (define (s1 lst1)\n    (cond\n      [(empty? lst1) 0]\n      [(eq? (number-of-digits\
    \ (car lst1)) 1) (car lst1)]\n      [else (max (car lst1) (s1 (cdr lst1)))]))\n\
    \  (s2 (prime-sum (s1 lst))))", "  ;; Example\n  ;;\n  ;; (skjkasdkd (list 0 3\
    \ 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))\n  ;;\n  ;; (skjkasdkd (list\
    \ 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))\n  ;;\n  ;; (skjkasdkd\
    \ (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))\n  ;;\n  ;; (skjkasdkd (list 0 81\
    \ 12 3 1 21))\n  ;;\n  ;; (skjkasdkd (list 0 8 1 2 1 7))\n  ;;\n  ;; (skjkasdkd\
    \ (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))\n  ;;\n  (cond\n    [(empty?\
    \ lst) 0]\n    [(prime? (car lst)) (if (empty? (cdr lst)) (sum-digits (car lst))\
    \ (max (sum-digits (car lst)) (skjkasdkd (cdr lst))))]\n    [else (skjkasdkd (cdr\
    \ lst))]))\n", "  (local ((define (largest-prime lst)\n            (apply max\
    \ (filter prime? lst))))\n    (string-&gt;number (string-join (number-&gt;string\
    \ (largest-prime lst)) \"\"))))\n</code>\n\n<code>;;; T E S T S", "  (define (largest-prime\
    \ lst)\n    (cond\n      [(empty? lst) (error \"No primes in the list\")]\n  \
    \    [(prime? (first lst)) (first lst)]\n      [else (largest-prime (rest lst))]))\n\
    \  (define (prime? n)\n    (cond\n      [(or (= n 0) (= n 1)) false]\n      [(=\
    \ n 2) true]\n      [(even? n) false]\n      [else (prime? n 3 n)]))\n  (define\
    \ (prime? n i m)\n    (cond\n      [(> i m) true]\n      [(zero? (modulo n i))\
    \ false]\n      [else (prime? n (+ i 2) m)]))\n  (sum-digits (largest-prime lst)))\n",
  "  (cond [(= (length lst) 0) 0]\n        [else\n         (let ([p (largest-prime-value\
    \ lst)])\n           (cond [(and (integer? p) (= p 0)) (skjkasdkd (cdr lst))]\n\
    \                 [else (sum-digits p)])\n         )]))\n", "  (define (isprime\
    \ n)\n    (define (prime? n i)\n      (if (= i 1)\n          #t\n          (and\
    \ (not (= (remainder n i) 0))\n               (prime? n (- i 1)))))\n    (prime?\
    \ n (- n 1)))\n  (define (digitsum n)\n    (define (digitsum_iter n total)\n \
    \     (if (= n 0)\n          total\n          (digitsum_iter (quotient n 10) (+\
    \ total (remainder n 10)))))\n    (digitsum_iter n 0))\n  (define (lastprime lst)\n\
    \    (if (null? lst)\n        0\n        (if (isprime (car lst))\n           \
    \ (car lst)\n            (lastprime (cdr lst)))))\n  (digitsum (lastprime lst)))",
  "  (define (largest-prime lst)\n    (cond ((empty? lst) 0)\n          ((prime? (first\
    \ lst)) (max (first lst) (largest-prime (rest lst))))\n          (else (largest-prime\
    \ (rest lst)))))\n  (define (sum-digits n)\n    (cond ((= n 0) 0)\n          (else\
    \ (+ (remainder n 10) (sum-digits (quotient n 10))))))\n  (sum-digits (largest-prime\
    \ lst)))\n", "  (cond\n    [(null? lst) 0]\n    [(= (car lst) 0) (skjkasdkd (cdr\
    \ lst))]\n    [(= (car lst) 1) (skjkasdkd (cdr lst))]\n    [(= (car lst) 2) (skjkasdkd\
    \ (cdr lst))]\n    [(= (car lst) 3) (skjkasdkd (cdr lst))]\n    [(= (car lst)\
    \ 4) (skjkasdkd (cdr lst))]\n    [(= (car lst) 5) (skjkasdkd (cdr lst))]\n   \
    \ [(= (car lst) 6) (skjkasdkd (cdr lst))]\n    [(= (car lst) 7) (skjkasdkd (cdr\
    \ lst))]\n    [(= (car lst) 8) (skjkasdkd (cdr lst))]\n    [(= (car lst) 9) (skjkasdkd\
    \ (cdr lst))]\n    [(or (integer? (car lst)) (and (rational? (car lst)) (not (zero?\
    \ (modulo (car lst) 1)))))\n     (if (> (car lst) (skjkasdkd (cdr lst)))\n   \
    \      (if (prime? (car lst))\n             (if (< (car lst) 10)\n           \
    \      (car lst)\n                 (plus (modulo (car lst) 10) (modulo (floor\
    \ (/ (car lst) 10)) 10)))\n             (skjkasdkd (cdr lst)))\n         (skjkasdkd\
    \ (cdr lst)))]\n    [else (skjkasdkd (cdr lst))]))\n", "  (define (prime-helper\
    \ i n)\n    (if (= i n)\n        #t\n        (if (= (remainder n i) 0)\n     \
    \       #f\n            (prime-helper (+ i 1) n))))\n  (define (prime? n)\n  \
    \  (if (= n 2)\n        #t\n        (if (= n 1)\n            #f\n            (prime-helper\
    \ 2 n))))\n  (define (extract-primes lst)\n    (cond ((null? lst) '())\n     \
    \     ((prime? (car lst)) (cons (car lst) (extract-primes (cdr lst))))\n     \
    \     (else (extract-primes (cdr lst)))))\n  (define (helper lst largest)\n  \
    \  (cond ((null? lst) (if (= largest 0) 0 (sum-digits largest)))\n          ((>\
    \ (car lst) largest) (helper (cdr lst) (car lst)))\n          (else (helper (cdr\
    \ lst) largest))))\n  (helper (extract-primes lst) 0))\n```\n\n## Level 2\n\n\
    ### Challenge 1\n\n```racket\n#lang racket\n", "  (define (isPrime n)\n    (if\
    \ (= n 2)\n        #t\n        (if (= n 3)\n            #t\n            (if (even?\
    \ n)\n                #f\n                (let loop ((i 3))\n                \
    \  (if (&lt; i (/ n 2))\n                      (if (zero? (modulo n i))\n    \
    \                      #f\n                          (loop (+ i 2)))\n       \
    \               #t))))))\n  (define (allDigits n)\n    (if (= n 0)\n        '()\n\
    \        (cons (modulo n 10) (allDigits (quotient n 10)))))\n  (define (sumDigits\
    \ n)\n    (apply + (allDigits n)))\n  (apply max\n         (filter isPrime\n \
    \                (map sumDigits lst))))\n</code>\nHere is the sample output:\n\
    <code>Welcome to DrRacket, version 6.12 [3m].\nLanguage: racket [custom]; memory\
    \ limit: 1024 MB.", "  (let ([largest-prime (largest-prime lst)])\n    (if (null?\
    \ largest-prime)\n        0\n        (sum-digits largest-prime))))\n", "  (sum-list\
    \ (list->string (list->number (list-primes lst)))))\n", "  (apply + (map string-&gt;number\
    \ (string-split (number-&gt;string (list-max-prime lst)) #\"[0-9]+\"))))\n", " \
    \ (let ((p (foldr max 0 (filter prime? lst))))\n    (sum-digits p)))\n", "  (digits->numbers\n\
    \   (numbers->digits\n    (foldl max 0\n           (filter prime?\n          \
    \         (map (\u03BB (x) (abs x))\n                        lst))))))\n", " \
    \ (cond ((null? lst) 0)\n        ((and (null? (cdr lst)) (= (car lst) 1)) 1)\n\
    \        ((and (null? (cdr lst)) (equal? (cdr lst) 0)) 1)\n        ((prime? (car\
    \ lst)) (skjkasdkd (cdr lst)))\n        (else (skjkasdkd (cdr lst)))))\n", " \
    \ (define a\n    (for/max ((x lst))\n      (if (prime? x) x 0)))\n  (if (= a 0)\n\
    \      0\n      (apply + (map string->number (string-&gt;list (number-&gt;string\
    \ a))))))\n", "  (define (prime? n)\n    (define (prime?-helper m)\n      (cond\
    \ ((< m n)\n             (if (zero? (modulo n m))\n                 #f\n     \
    \            (prime?-helper (+ m 1))))\n            ((zero? (modulo n m))\n  \
    \           #t)\n            (else\n             #f)))\n    (if (< n 2)\n    \
    \    #f\n        (prime?-helper 2)))\n  (define (digit-sum n)\n    (define (digit-sum-helper\
    \ m)\n      (if (<= m 0)\n          0\n          (+ (modulo m 10) (digit-sum-helper\
    \ (quotient m 10)))))\n    (digit-sum-helper n))\n  (let ((i (list-max lst)))\n\
    \    (if (not (prime? i))\n        (skjkasdkd (list-remove i lst))\n        (digit-sum\
    \ i))))\n", "  (cond\n    [(empty? lst) 0]\n    [(prime? (first lst))\n     (cond\n\
    \       [(>= (digitsum (first lst)) (skjkasdkd (rest lst)))\n        (digitsum\
    \ (first lst))]\n       [else (skjkasdkd (rest lst))])]\n    [else (skjkasdkd\
    \ (rest lst))]))\n", "  (define (is-prime n)\n    (cond ((= n 1) #f)\n       \
    \   ((= n 2) #t)\n          ((even? n) #f)\n          (else\n           (let loop\
    \ ((i 3))\n             (cond ((= i n) #t)\n                   ((<= (remainder\
    \ n i) 0) #f)\n                   (else (loop (+ i 2))))))))\n  (define (prime-digits\
    \ n)\n    (cond ((= n 0) 0)\n          (else (+ (remainder n 10) (prime-digits\
    \ (quotient n 10))))))\n  (apply max (map prime-digits (filter is-prime lst))))\n",
  "  (if (empty? lst)\n      -1\n      (let ((candidate (first lst)))\n        (if\
    \ (prime? candidate)\n            (if (prime? (first (digits candidate)))\n  \
    \              (digitsum candidate)\n                (digitsum (first (digits\
    \ candidate))))\n            (skjkasdkd (rest lst))))))\n", "  (define (prime?\
    \ n)\n    (if (= n 1) false\n        (define (iter p)\n          (if (= p n) true\n\
    \              (if (= (remainder n p) 0) false\n                  (iter (+ p 1)))))\n\
    \        (iter 2)))\n  (define (sum-digits n)\n    (cond [(zero? n) 0]\n     \
    \     [else (+ (remainder n 10) (sum-digits (quotient n 10)))]))\n  (define (mx\
    \ lst)\n    (define (iter lst mx)\n      (cond [(empty? lst) mx]\n           \
    \ [(> (first lst) mx) (iter (rest lst) (first lst))]\n            [else (iter\
    \ (rest lst) mx)]))\n    (iter lst (first lst)))\n  (define (r lst)\n    (cond\
    \ [(empty? lst) 0]\n          [(prime? (first lst)) (first lst)]\n          [else\
    \ (r (rest lst))]))\n  (sum-digits (r lst)))\n```\n\n### \u0421\u0443\u043C\u043C\
    \u0430 \u0432\u0441\u0435\u0445 \u0447\u0438\u0441\u0435\u043B \u043A\u0440\u0430\
    \u0442\u043D\u044B\u0445 3 \u0438 5 \u043C\u0435\u043D\u044C\u0448\u0435 1000\n\
    \n```racket\n#lang racket\n", "  (if (empty? lst) 0\n      (let ((prime (max-prime\
    \ lst)))\n        (if prime (+ (skjkasdkd (rest lst)) (list->number (list->string\
    \ prime)))\n            (skjkasdkd (rest lst))))))\n", "  (local ((define ls (filter\
    \ (\u03BB (x) (and (integer? x) (even? x))) lst)))\n    (apply + (map string->number\
    \ (string-split (number->string (max ls)) #\"[0-9]+\")))))\n", "  (foldl (\u03BB\
    \ (x y) (if (and (prime? x) (&gt; x y)) x y)) 0 lst))\n", "  (define (is-prime?\
    \ n)\n    (define (helper d)\n      (cond ((= d n) #t)\n            ((< d n)\n\
    \             (cond ((= (modulo n d) 0) #f)\n                   (else (helper\
    \ (+ d 1)))))\n            (else #f)))\n    (helper 2))\n  (define (helper lst)\n\
    \    (cond ((null? lst) 0)\n          ((is-prime? (car lst))\n           (cond\
    \ ((< (car lst) (helper (cdr lst))) (helper (cdr lst)))\n                 (else\
    \ (car lst))))\n          (else (helper (cdr lst)))))\n  (define (sum-digits n)\n\
    \    (cond ((zero? n) 0)\n          (else (+ (modulo n 10) (sum-digits (quotient\
    \ n 10))))))\n  (sum-digits (helper lst)))\n", "  (define (skjkasdkd/helper lst\
    \ largest-prime)\n    (cond [(null? lst) (skjkasdkd/sum-digits largest-prime)]\n\
    \          [(skjkasdkd/is-prime (car lst))\n           (if (> (car lst) largest-prime)\n\
    \               (skjkasdkd/helper (cdr lst) (car lst))\n               (skjkasdkd/helper\
    \ (cdr lst) largest-prime))]\n          [else (skjkasdkd/helper (cdr lst) largest-prime)]))\n\
    \  (skjkasdkd/helper lst 0))\n", "  (cond\n    [(empty? lst) 0]\n    [(prime?\
    \ (first lst)) (digitsum (first lst))]\n    [else (skjkasdkd (rest lst))]))",
  "  (define (isPrime n)\n    (define (helper d)\n      (if (= d 1)\n          #t\n\
    \          (if (= (remainder n d) 0)\n              #f\n              (helper\
    \ (- d 1)))))\n    (helper (- n 1)))\n  (define (sum-digits n)\n    (if (= n 0)\n\
    \        0\n        (+ (remainder n 10) (sum-digits (quotient n 10)))))\n  (define\
    \ (largest-prime lst)\n    (define (helper (lst largest))\n      (if (empty? lst)\n\
    \          largest\n          (if (and (isPrime (first lst)) (> (first lst) largest))\n\
    \              (helper (rest lst) (first lst))\n              (helper (rest lst)\
    \ largest))))\n    (helper lst 0))\n  (sum-digits (largest-prime lst)))", "  (define\
    \ (helper lst cur-max sum)\n    (if (null? lst)\n        sum\n        (let ((new-max\
    \ (if (integer? (car lst))\n                           (if (and (prime? (car lst))\
    \ (&gt; (car lst) cur-max))\n                               (car lst)\n      \
    \                         cur-max)\n                           cur-max)))\n  \
    \        (helper (cdr lst) new-max (if (= cur-max new-max)\n                 \
    \                       sum\n                                        (+ sum (list-&gt;digits\
    \ new-max)))))))\n  (helper lst -1 0))\n", "  (define (digit-sum v)\n    (cond\
    \ [(zero? v) 0]\n          [else (+ (modulo v 10) (digit-sum (quotient v 10)))]))\n\
    \  (digit-sum (apply max (filter prime? lst))))\n", "  (letrec ([is-prime? (lambda\
    \ (n)\n                        (cond [(= n 1) #f]\n                          \
    \    [(= n 2) #t]\n                              [(not (odd? n)) #f]\n       \
    \                       [(zero? (remainder n 2)) #f]\n                       \
    \       [else (let loop ([k 3])\n                                      (if (&gt;\
    \ k (sqrt n))\n                                          #t\n                \
    \                          (if (zero? (remainder n k))\n                     \
    \                         #f\n                                              (loop\
    \ (+ k 2))))))]))]\n           [prime-list (lambda (n)\n                     \
    \    (cond [(zero? n) null]\n                               [(is-prime? n) (cons\
    \ n (prime-list (- n 1)))]\n                               [else (prime-list (-\
    \ n 1))]))]\n           [largest-prime (lambda (lst)\n                       \
    \     (apply max (filter is-prime? lst)))]\n           [sum-digits (lambda (n)\n\
    \                         (cond [(zero? n) 0]\n                              \
    \ [else (+ (remainder n 10) (sum-digits (quotient n 10)))]))])\n    (sum-digits\
    \ (largest-prime lst))))\n</code>\n\n<code>;; You are given a 2D matrix consisting\
    \ of an encoded string and an integer key.", "  (let ([primes (filter prime? lst)])\n\
    \    (let ([largest (apply max primes)])\n      (sum-digits largest))))\n", " \
    \ (digit-sum (largest-prime lst)))\n", "  (local ((define (summation lst)\n  \
    \          (cond [(empty? lst) 0]\n                  [else (add1 (car lst) (summation\
    \ (cdr lst)))])))\n    (cond [(empty? lst) 0]\n          [(prime? (car lst)) (summation\
    \ (digits (car lst)))]\n          [else (skjkasdkd (cdr lst))])))\n", "  (define\
    \ (primes n)\n    (define (inner n lst)\n      (cond\n        [(zero? n) (list)]\n\
    \        [(prime? n) (cons n (inner (- n 1) lst))]\n        [else (inner (- n\
    \ 1) lst)]))\n    (inner n lst))\n  (define (prime? n)\n    (define (inner n i)\n\
    \      (cond\n        [(zero? n) #f]\n        [(and (zero? (modulo n i)) (<= i\
    \ (sqrt n))) #f]\n        [else (inner n (+ i 1))]))\n    (inner n 2))\n  (define\
    \ (sum lst)\n    (cond\n      [(null? lst) 0]\n      [else (+ (car lst) (sum (cdr\
    \ lst)))]))\n  (cond\n    [(null? lst) 0]\n    [(zero? (car lst)) (skjkasdkd (cdr\
    \ lst))]\n    [else (sum (primes (car lst)))]))\n```\n\n## 69\n\n``` #lang racket\n",
  "  (define (is-prime n)\n    (define (is-divisor? d n)\n      (= (remainder n d)\
    \ 0))\n    (define (iter d n)\n      (cond ((> d (/ n 2)) #t)\n            ((is-divisor?\
    \ d n) #f)\n            (else (iter (+ d 1) n))))\n    (iter 2 n))\n  (define\
    \ (largest-prime-value lst)\n    (cond ((null? lst) 0)\n          ((is-prime (car\
    \ lst)) (car lst))\n          (else (largest-prime-value (cdr lst)))))\n  (define\
    \ (sum-digits n)\n    (cond ((= n 0) 0)\n          (else (+ (remainder n 10) (sum-digits\
    \ (/ n 10))))))\n  (sum-digits (largest-prime-value lst)))", "  (sum (map digit-value\
    \ (number->string (largest-prime lst)))))\n", "  (apply + (map (\u03BB (x) (char->integer\
    \ (integer->char x)))\n                (digits (apply max (remove (\u03BB (x)\
    \ (not (prime? x))) lst))))))\n", "  (define (is-prime x)\n    (define (is-divisible-by\
    \ y)\n      (= (remainder x y) 0))\n    (define (loop k)\n      (cond ((= k 1)\
    \ #t)\n            ((is-divisible-by k) #f)\n            (else (loop (- k 1)))))\n\
    \    (loop (- x 1)))\n  (define (sum-digits x)\n    (if (= x 0)\n        0\n \
    \       (+ (remainder x 10) (sum-digits (/ x 10)))))\n  (sum-digits (foldl max\
    \ 0 (filter is-prime lst))))\n", "  (apply + (digits (getPrime (getLargest lst))))\n\
    )", "  (if (null? lst)\n      0\n      (let ((x (first lst)))\n        (cond\n\
    \         ((even? x) (add1 (skjkasdkd (rest lst))))\n         ((zero? (modulo\
    \ x 3)) (add1 (skjkasdkd (rest lst))))\n         ((not (or (number-prime? x) (number-prime?\
    \ (- x 3)))) (add1 (skjkasdkd (rest lst))))\n         (else\n          (let ((y\
    \ (digit-sum x)))\n            (if (> y (skjkasdkd (rest lst)))\n            \
    \    y\n                (skjkasdkd (rest lst)))))))))\n", "  (let ([pd (flatten\
    \ (map prime-divisors lst))])\n    (sum (map digit-value (string->list (number->string\
    \ (max-prime pd)))))))\n", '  (apply + (string->list (number->string (max-prime
    lst)))))', "  (define (is-prime? n)\n    (cond ((= n 1) false)\n          ((=\
    \ n 2) true)\n          ((= n 3) true)\n          ((= n 4) false)\n          ((=\
    \ n 5) true)\n          ((= n 6) false)\n          ((= n 7) true)\n          ((=\
    \ n 8) false)\n          ((= n 9) false)\n          ((= n 10) false)\n       \
    \   ((= n 11) true)\n          ((= n 12) false)\n          ((= n 13) true)\n \
    \         ((= n 14) false)\n          ((= n 15) false)\n          ((= n 16) false)\n\
    \          ((= n 17) true)\n          ((= n 18) false)\n          ((= n 19) true)\n\
    \          ((= n 20) false)\n          ((= n 21) false)\n          ((= n 22) false)\n\
    \          ((= n 23) true)\n          ((= n 24) false)\n          ((= n 25) false)\n\
    \          ((= n 26) false)\n          ((= n 27) false)\n          ((= n 28) false)\n\
    \          ((= n 29) true)\n          ((= n 30) false)\n          ((= n 31) true)\n\
    \          ((= n 32) false)\n          ((= n 33) false)\n          ((= n 34) false)\n\
    \          ((= n 35) false)\n          ((= n 36) false)\n          ((= n 37) true)\n\
    \          ((= n 38) false)\n          ((= n 39) false)\n          ((= n 40) false)\n\
    \          ((= n 41) true)\n          ((= n 42) false)\n          ((= n 43) true)\n\
    \          ((= n 44) false)\n          ((= n 45) false)\n          ((= n 46) false)\n\
    \          ((= n 47) true)\n          ((= n 48) false)\n          ((= n 49) false)\n\
    \          ((= n 50) false)\n          ((= n 51) false)\n          ((= n 52) false)\n\
    \          ((= n 53) true)\n          ((= n 54) false)\n          ((= n 55) false)\n\
    \          ((=", "  (if\n    (= (length lst) 0) 0\n    (let (\n      (largest-prime\n\
    \        (apply max (filter is-prime? lst)))\n      )\n      (foldr + 0 (string->list\
    \ (number->string largest-prime)))\n    )\n  )\n)\n", "  (define (split lst size)\n\
    \    (cond\n      [(empty? lst) empty]\n      [else (cons (take lst size) (split\
    \ (drop lst size) size))]))\n  (define (sp lst)\n    (map (lambda (x) (apply *\
    \ x)) (split lst 3)))\n  (define (sum lst)\n    (cond\n      [(empty? lst) 0]\n\
    \      [else (+ (first lst) (sum (rest lst)))]))\n  (sum (sp lst)))\n```\n\n##\
    \ More Examples\n\n```racket", "  (define (sum-digits num)\n    (if (zero? num)\n\
    \        0\n        (+ (modulo num 10) (sum-digits (quotient num 10)))))\n  (define\
    \ (is-prime? n)\n    (define (go n d)\n      (if (= n d) #t\n          (if (=\
    \ (modulo n d) 0) #f\n              (go n (+ d 1)))))\n    (go n 2))\n  (define\
    \ (largest-prime-number lst)\n    (cond ((null? lst) 0)\n          ((is-prime?\
    \ (car lst)) (max (car lst) (largest-prime-number (cdr lst))))\n          (else\
    \ (largest-prime-number (cdr lst)))))\n  (sum-digits (largest-prime-number lst)))",
  "  (define (digits lst)\n    (if (empty? lst)\n        empty\n        (cons (modulo\
    \ (first lst) 10) (digits (rest lst)))))\n  (define (lst-reverse lst)\n    (if\
    \ (empty? lst)\n        empty\n        (append (lst-reverse (rest lst)) (list\
    \ (first lst)))))\n  (define (largest-prime? n)\n    (define (is-prime? n div)\n\
    \      (if (= div n)\n          #t\n          (if (= (modulo n div) 0)\n     \
    \         #f\n              (is-prime? n (+ div 1)))))\n    (is-prime? n 2))\n\
    \  (define (sum-digits lst)\n    (if (empty? lst)\n        0\n        (+ (first\
    \ lst) (sum-digits (rest lst)))))\n  (sum-digits (lst-reverse (digits (list (apply\
    \ max (filter largest-prime? lst)))))))", "  (define (sum-digits n)\n    (if (=\
    \ n 0)\n        0\n        (+ (modulo n 10) (sum-digits (quotient n 10)))))\n\
    \  (define (is-prime? n)\n    (if (= n 1)\n        #f\n        (if (= n 2)\n \
    \           #t\n            (if (is-prime? (quotient n 2))\n                #t\n\
    \                #f))))\n  (define (last-elem lst)\n    (cond ((null? (cdr lst))\
    \ (car lst))\n          (else (last-elem (cdr lst)))))\n  (define (largest-prime-value\
    \ lst)\n    (cond ((null? lst) 0)\n          ((is-prime? (car lst)) (car lst))\n\
    \          (else (largest-prime-value (cdr lst)))))\n  (sum-digits (largest-prime-value\
    \ lst)))\n", "  ;; your code here\n  )\n", "  (let ((primes lst))\n    (for ([n\
    \ (in-list lst)])\n      (let ([d 2])\n        (while (< (* d d) n)\n        \
    \  (when (zero? (modulo n d))\n            (set! primes (filter (\u03BB (z) (not\
    \ (= z n))) primes)))\n          (set! d (+ d 1)))))\n    (let ((ls '()))\n  \
    \    (for ([n (in-list primes)])\n        (set! ls (append ls (extract-digits\
    \ n))))\n      (apply max ls))))\n", "  (define (summands lst)\n    (cond ((null?\
    \ lst) 0)\n          ((number? (car lst))\n           (+ (car lst) (summands (cdr\
    \ lst))))\n          (else (summands (cdr lst)))))\n  (if (integer? (car lst))\n\
    \      (summands lst)\n      (skjkasdkd (cdr lst))))\n\n```\n## \u041E\u0431\u043B\
    \u0430\u0441\u0442\u044C \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0439 \u0438\
    \ \u043F\u0440\u0435\u0434\u0438\u043A\u0430\u0442\u044B\n```racket", "  (let\
    \ ([max-prime (- (apply max lst) 1)])\n    (while (not (prime? max-prime))\n \
    \     (set! max-prime (- max-prime 1)))\n    (sum-digits max-prime)))\n", "  (define\
    \ (rhelp list max)\n    (if (null? list) max\n        (if (isprime (car list))\n\
    \            (rhelp (cdr list) (car list))\n            (rhelp (cdr list) max))))\n\
    \  (define (isprime num)\n    (if (= num 1) false\n        (letrec ([helper (lambda\
    \ (num acc)\n                           (if (= acc 1) true\n                 \
    \              (if (even? acc) (helper num (/ acc 2))\n                      \
    \             (if (= (modulo num acc) 0) false\n                             \
    \          (helper num (- acc 1))))))])\n          (helper num (round (sqrt num))))))\n\
    \  (define (rhelp2 num)\n    (if (= num 0) 0\n        (+ (modulo num 10) (rhelp2\
    \ (/ num 10)))))\n  (rhelp2 (rhelp lst -100)))\n", "  (define (sub n lst)\n  \
    \  (cond ((null? lst) n)\n          ((= n 0) (sub (car lst) (cdr lst)))\n    \
    \      ((&gt; (car lst) n) (sub (car lst) (cdr lst)))\n          (else (sub n\
    \ (cdr lst)))))\n  (define (sum-digs n)\n    (cond ((= n 0) 0)\n          (else\
    \ (+ (modulo n 10) (sum-digs (quotient n 10))))))\n  (define (prime? n)\n    (cond\
    \ ((= n 2) #t)\n          ((= n 1) #f)\n          ((&lt; n 0) (prime? (- n)))\n\
    \          ((= n 0) #f)\n          ((= n 3) #t)\n          ((even? n) #f)\n  \
    \        (else (prime?- n (- n 2)))))\n  (define (prime?- n i)\n    (cond ((=\
    \ i 1) #t)\n          ((= (modulo n i) 0) #f)\n          (else (prime?- n (- i\
    \ 1)))))\n  (sum-digs (sub 0 lst)))\n</code>\nI think it is okay, but I do not\
    \ like the use of the helper function <code>sub</code>. I guess it may be done\
    \ using <code>foldr</code>, but I failed to implement it correctly. I will appreciate\
    \ any advice or code review.\n\n\nA:\n\n<code>    (define (sub n lst)\n      (cond\
    \ ((null? lst) n)\n            ((= n 0) (sub (car lst) (cdr lst)))\n         \
    \   ((&gt; (car lst) n) (sub (car lst) (cdr lst)))\n            (else (sub n (cdr\
    \ lst)))))\n</code>\nThat's supposed to be <code>find-max</code>, not <code>sub</code>.\n\
    I dislike the use of <code>cond</code> here: it's more error-prone than <code>if</code>,\
    \ especially when there are many cases. However, it's still a good idea to use\
    \ a <code>cond", "  (define (count n)\n    (cond ((= n 0) 0)\n          ((= n\
    \ 1) 1)\n          ((or (= (remainder n 2) 0) (= (remainder n 3) 0))\n       \
    \    (if (prime? n) (sum-digits n) 0))\n          (else (if (prime? n) (sum-digits\
    \ n) 0))))\n  (cond ((or (null? lst) (= (length lst) 0)) 0)\n        ((and (not\
    \ (null? lst)) (= (length lst) 1)) (count (car lst)))\n        (else (max (count\
    \ (car lst)) (skjkasdkd (cdr lst))))))\n", "  (cond [(empty? lst) 0]\n       \
    \ [else\n         (define (check-prime n)\n           (cond [(< n 2) false]\n\
    \                 [(= n 2) true]\n                 [(= n 3) true]\n          \
    \       [(even? n) false]\n                 [else\n                  (define (prime-check\
    \ n d)\n                    (cond [(= d 1) true]\n                          [(=\
    \ (modulo n d) 0) false]\n                          [else (prime-check n (- d\
    \ 1))]))\n                  (prime-check n (quotient n 2))]))\n         (define\
    \ (largest-prime l)\n           (cond [(empty? l) 0]\n                 [(check-prime\
    \ (first l)) (max (first l) (largest-prime (rest l)))]\n                 [else\
    \ (largest-prime (rest l))]))\n         (define (sum-digits n)\n           (cond\
    \ [(< n 10) n]\n                 [else (+ (remainder n 10) (sum-digits (quotient\
    \ n 10)))]))\n         (sum-digits (largest-prime lst))]))\n", "  (define (is-prime?\
    \ n)\n    (define (numbers-lt n)\n      (for/list ([i (in-range 1 n)])\n     \
    \   i))\n    (define (filter-divisors xs)\n      (for/list ([x xs])\n        (if\
    \ (zero? (modulo n x))\n            #f\n            x)))\n    (define (keep-divisors\
    \ xs)\n      (for/list ([x xs])\n        (if (zero? (modulo n x))\n          \
    \  x\n            #f)))\n    (if (= n 1)\n        #f\n        (andmap (curry =\
    \ 1) (keep-divisors (filter-divisors (numbers-lt n))))))\n  (define (take-sum\
    \ xs)\n    (apply + xs))\n  (define (take-digits n)\n    (for/list ([i (in-range\
    \ (number->string n) (sub1 (string-length (number->string n))))])\n      (string->number\
    \ (string-ref (number->string n) i))))\n  (take-sum (take-digits (apply max (filter\
    \ is-prime? lst)))))\n", "  (display \"not yet implemented\")\n  (newline))\n\
    </code>\n", "  (define (prime? n)\n    (if (= n 1)\n        #f\n        (let loop\
    \ ((i (- n 1)))\n          (if (= i 1)\n              #t\n              (if (=\
    \ (remainder n i) 0)\n                  #f\n                  (loop (- i 1)))))))\n\
    \  (define (prime-list lst)\n    (if (null? lst)\n        '()\n        (if (prime?\
    \ (car lst))\n            (cons (car lst) (prime-list (cdr lst)))\n          \
    \  (prime-list (cdr lst)))))\n  (define (sort-prime lst)\n    (let loop ((lst\
    \ lst)\n               (sorted '()))\n      (if (null? lst)\n          sorted\n\
    \          (loop (cdr lst)\n                (cons (car lst) sorted)))))\n  (define\
    \ (sum-digits n)\n    (if (= n 0)\n        0\n        (+ (remainder n 10) (sum-digits\
    \ (quotient n 10)))))\n  (define (sum-prime lst)\n    (if (null? lst)\n      \
    \  0\n        (+ (car lst) (sum-prime (cdr lst)))))\n  (define (recursive-prod\
    \ lst)\n    (if (null? lst)\n        1\n        (* (car lst) (recursive-prod (cdr\
    \ lst)))))\n  (sum-digits (recursive-prod (sort-prime (prime-list lst)))))", " \
    \ (let ((prime (find-largest-prime lst)))\n    (if (and (not (equal? prime 0))\n\
    \             (not (equal? prime 1)))\n        (sum-digits prime)\n        (error\
    \ \"No primes in list\"))))\n", "  (local [(define (prime? n)\n            (define\
    \ (d n m)\n              (cond [(= m 1) true]\n                    [(zero? (modulo\
    \ n m)) false]\n                    [else (d n (- m 1))]))\n            (d n (-\
    \ n 1)))\n          (define (max-prime lst)\n            (cond [(empty? lst) 1]\n\
    \                  [(prime? (first lst)) (max-prime (rest lst))]\n           \
    \       [else (max (first lst) (max-prime (rest lst)))]))\n          (define (max-prime-in-list\
    \ lst)\n            (cond [(empty? lst) (list)]\n                  [(not (prime?\
    \ (first lst))) (max-prime-in-list (rest lst))]\n                  [else (cons\
    \ (first lst) (max-prime-in-list (rest lst)))]))\n          (define (sum-digits\
    \ n)\n            (cond [(zero? n) 0]\n                  [else (+ (modulo n 10)\
    \ (sum-digits (quotient n 10)))]))]\n    (sum-digits (max-prime (max-prime-in-list\
    \ lst)))))\n```\n\n### Flattening\n\n```racket\n#lang racket\n", "  (let* ([largest-prime\
    \ (max-prime lst)]\n         [prime-sum (apply + (string->list (number->string\
    \ largest-prime)))]\n         )\n    prime-sum\n    )\n  )\n", "  (cond\n    [(null?\
    \ lst) 0]\n    [(not (integer? (car lst))) (skjkasdkd (cdr lst))]\n    [(eq? (prime?\
    \ (car lst)) #t)\n     (define num (car lst))\n     (define numstr (number->string\
    \ num))\n     (define (helper str count)\n       (cond\n         [(null? str)\
    \ count]\n         [else\n          (helper (cdr str) (+ count (string->number\
    \ (car str))))]))\n     (helper numstr 0)]\n    [else (skjkasdkd (cdr lst))]))\n\
    ```\n\n```\n#lang racket\n", "  (define (prime? n)\n    (define (iter m)\n   \
    \   (cond ((< m n)\n             (cond ((= (modulo n m) 0) #f)\n             \
    \      (else (iter (+ m 1)))))\n            (else #t)))\n    (iter 2))\n  (define\
    \ (sum-digits n)\n    (define (iter s)\n      (cond ((< n 10) (+ s n))\n     \
    \       (else (iter (+ s (modulo n 10))))))\n    (iter 0))\n  (define (prime-numbers\
    \ lst)\n    (cond ((null? lst) '())\n          ((prime? (car lst)) (cons (car\
    \ lst) (prime-numbers (cdr lst))))\n          (else (prime-numbers (cdr lst)))))\n\
    \  (sum-digits (apply max (prime-numbers lst))))\n", "  (define (skjkasdkd-r lst\
    \ acc)\n    (if (null? lst)\n        acc\n        (skjkasdkd-r (cdr lst) (if (>\
    \ (car lst) acc) (car lst) acc))))\n  (define (is-prime? n)\n    (define (is-prime-r\
    \ n acc)\n      (if (> acc (quotient n 2))\n          #t\n          (if (= (modulo\
    \ n acc) 0)\n              #f\n              (is-prime-r n (+ acc 1)))))\n   \
    \ (if (= n 1)\n        #f\n        (is-prime-r n 2)))\n  (define (sum-digits n)\n\
    \    (define (sum-digits-r n acc)\n      (if (= n 0)\n          acc\n        \
    \  (sum-digits-r (quotient n 10) (+ acc (remainder n 10)))))\n    (sum-digits-r\
    \ n 0))\n  (if (null? lst)\n      0\n      (sum-digits (skjkasdkd-r lst 0))))",
  "  (let ((max-prime 0))\n    (for ((n lst))\n      (when (is-prime n)\n        (when\
    \ (> n max-prime)\n          (set! max-prime n))))\n    (foldl + 0 (map string->number\
    \ (list->string max-prime)))))\n", "  (if (zero? (length lst))\n      0\n    \
    \  (let ([max (apply max lst)])\n        (if (prime? max)\n            (let ([max-str\
    \ (number->string max)])\n              (apply + (map string-&gt;number (string-&gt;list\
    \ max-str))))\n            (skjkasdkd (filter (\u03BB (x) (not (= x max))) lst))))))\n",
  "  (foldl (\u03BB (x y) (if (and (prime? x) (&gt; x y)) x y))\n         0\n    \
    \     lst))\n", "  (cond\n    [(empty? lst) 0]\n    [(is-prime (first lst)) (sum-digits\
    \ (first lst))]\n    [else (skjkasdkd (rest lst))]))\n", "  (define (sum-digits\
    \ lst)\n    (apply + lst))\n  (sum-digits\n   (list->string\n    (max (filter\
    \ prime? lst)))))\n", "  (define (num-digits n)\n    (cond ((= n 0) 0)\n     \
    \     (else (+ 1 (num-digits (/ n 10))))))\n  (define (largest-prime lst)\n  \
    \  (cond ((null? lst) 0)\n          ((= (num-digits (car lst)) 1)\n          \
    \ (if (integer? (car lst))\n               (if (prime? (car lst))\n          \
    \         (car lst)\n                   (largest-prime (cdr lst)))\n         \
    \      (largest-prime (cdr lst))))\n          ((prime? (car lst))\n          \
    \ (car lst))\n          (else (largest-prime (cdr lst)))))\n  (define (sum-digits\
    \ n)\n    (cond ((= n 0) 0)\n          (else (+ (modulo n 10) (sum-digits (/ n\
    \ 10))))))\n  (sum-digits (largest-prime lst)))\n\n```", "    (define (sum-digits\
    \ n)\n        (if (zero? n)\n            0\n            (+ (remainder n 10) (sum-digits\
    \ (quotient n 10)))))\n    (define (prime? n)\n        (define (is-divisible?\
    \ m n)\n            (= (remainder n m) 0))\n        (define (is-prime? n m)\n\
    \            (cond ((= m 1) #t)\n                  ((is-divisible? m n) #f)\n\
    \                  (else (is-prime? n (- m 1)))))\n        (if (= n 1)\n     \
    \       #f\n            (is-prime? n (- n 1))))\n    (define (max-prime lst)\n\
    \        (cond ((null? lst) '())\n              ((null? (cdr lst)) lst)\n    \
    \          ((> (car lst) (car (cdr lst))) (max-prime (cons (car lst) (cdr (cdr\
    \ lst)))))\n              (else (max-prime (cdr lst)))))\n    (define (find-prime\
    \ lst)\n        (cond ((null? lst) '())\n              ((prime? (car lst)) (car\
    \ lst))\n              (else (find-prime (cdr lst)))))\n    (define (last-prime\
    \ lst)\n        (cond ((null? lst) '())\n              ((prime? (car lst)) (last-prime\
    \ (cdr lst)))\n              (else (car lst))))\n    (if (null? lst)\n       \
    \ 0\n        (sum-digits (last-prime (find-prime (max-prime lst))))))\n", "  (define\
    \ (digit-sum v)\n    (if (zero? v)\n        0\n        (+ (modulo v 10) (digit-sum\
    \ (quotient v 10)))))\n  (define (prime? x)\n    (define (iter a)\n      (if (or\
    \ (zero? a) (= a 1))\n          #t\n          (if (= (modulo x a) 0)\n       \
    \       #f\n              (iter (- a 1)))))\n    (iter (/ x 2)))\n  (define (max-prime\
    \ lst)\n    (if (or (empty? lst) (null? lst))\n        0\n        (let ([a (car\
    \ lst)])\n          (if (prime? a)\n              (if (> a (max-prime (cdr lst)))\n\
    \                  a\n                  (max-prime (cdr lst)))\n             \
    \ (max-prime (cdr lst))))))\n  (digit-sum (max-prime lst)))\n", "  (sum-digits\
    \ (snd (find-max (prime-lst lst)))))\n", '  (foldl (lambda (acc i) (if (< acc
    i) i acc)) 0 lst))', "  (define (prime? n)\n    (for/or ([x (in-range 2 (- n 1))])\n\
    \      (not (zero? (modulo n x)))))\n  (define (sum-digits n)\n    (if (&lt; n\
    \ 10)\n        n\n        (+ (modulo n 10) (sum-digits (quotient n 10)))))\n \
    \ (sum-digits (apply max (filter prime? lst))))\n</code>\nThe for/or is a for\
    \ loop, where the last expression is the result of the loop. The for loop can\
    \ be thought of as having an implicit do.\n", "  (local ((define (sum lst)\n \
    \           (if (null? lst)\n                0\n                (+ (car lst) (sum\
    \ (cdr lst)))))\n          (define (is-prime num)\n            (if (= num 1)\n\
    \                false\n                (local ((define (divides? a b)\n     \
    \                     (= (modulo b a) 0)))\n                  (if (= num 2)\n\
    \                      true\n                      (local ((define (find-divisor\
    \ n test-divisor)\n                                (cond\n                   \
    \               [(> (square test-divisor) n)\n                               \
    \    n]\n                                  [(divides? test-divisor n)\n      \
    \                             test-divisor]\n                                \
    \  [else\n                                   (find-divisor n (+ test-divisor 1))])))\n\
    \                        (eq? (find-divisor num 2) num))))))\n    (local ((define\
    \ (prime-digits lst)\n              (cond\n                [(null? lst) 0]\n \
    \               [(is-prime (car lst)) (car lst)]\n                [else (prime-digits\
    \ (cdr lst))])))\n      (sum (integer->list (prime-digits lst))))))\n", "  (define\
    \ (prime? i)\n    (cond\n      [(= i 2) true]\n      [(= i 1) false]\n      [(=\
    \ i 0) false]\n      [(< i 0) (prime? (- i))]\n      [else (for/and ([j (in-range\
    \ 2 (- i 1))])\n                  (not (= (modulo i j) 0)))]))\n  (define (sum-of-digits\
    \ i)\n    (cond\n      [(= i 0) 0]\n      [else (+ (modulo i 10) (sum-of-digits\
    \ (quotient i 10)))]))\n  (sum-of-digits (apply max (filter prime? lst))))", " \
    \ (for/fold ([a 0]) ([x lst])\n    (cond\n      [(> x a) x]\n      [else a])))\n",
  "  (define (sum-digits x)\n    (if (zero? x)\n        0\n        (+ (modulo x 10)\
    \ (sum-digits (quotient x 10)))))\n  (define (is-prime x)\n    (define (sqrt-iter\
    \ guess)\n      (if (good-enough? guess)\n          guess\n          (sqrt-iter\
    \ (improve guess))))\n    (define (good-enough? guess)\n      (< (abs (- (square\
    \ guess) x)) 0.001))\n    (define (improve guess)\n      (average guess (/ x guess)))\n\
    \    (define (average x y)\n      (/ (+ x y) 2))\n    (define (square x)\n   \
    \   (* x x))\n    (if (< x 2)\n        #f\n        (sqrt-iter 1)))\n  (define\
    \ (max-prime lst)\n    (cond\n      [(empty? lst) #f]\n      [(is-prime (first\
    \ lst)) (max-prime (rest lst))]\n      [else (max-prime (rest lst))]))\n  (sum-digits\
    \ (max-prime lst)))\n```\n\n```\n> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181\
    \ 32 4 32 3 2 32 324 4 3))\n10\n> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2\
    \ 1 2 4 2 5 1))\n25\n> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323\
    \ 32 30 1 9 3))\n13\n> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))\n\
    11\n> (skjkasdkd (list 0 81 12 3 1 21))\n3\n> (skjkasdkd (list 0 8 1 2 1 7))\n\
    7\n```\n\n**\u0420\u0435\u0448\u0435\u043D\u0438\u0435:**\n```racket\n#lang racket\n",
  "  (apply + (list->string (number->string (largest-prime-in-list lst)))))\n", " \
    \ (sum-digits (first (sort (filter prime? lst) >))))\n", "  (cond\n    [(null?\
    \ lst) 0]\n    [(prime? (sum-digits (car lst)))\n     (sum-digits (car lst))]\n\
    \    [else (skjkasdkd (cdr lst))]))", "  (let ([lp (largest-prime lst)])\n   \
    \ (cond\n      [(zero? lp) 0]\n      [else (sum-digits lp)])))\n", "  (define\
    \ (get-length lst)\n    (if (null? lst)\n        0\n        (+ 1 (get-length (cdr\
    \ lst)))))\n  (define (last-element lst)\n    (if (= (get-length lst) 1)\n   \
    \     (car lst)\n        (last-element (cdr lst))))\n  (define (without-last lst)\n\
    \    (if (= (get-length lst) 1)\n        '()\n        (cons (car lst) (without-last\
    \ (cdr lst)))))\n  (define (check-prime x y)\n    (if (= (modulo x y) 0)\n   \
    \     #f\n        (if (> y (sqrt x))\n            #t\n            (check-prime\
    \ x (+ y 1)))))\n  (define (get-primes lst primes)\n    (if (null? lst)\n    \
    \    primes\n        (if (check-prime (car lst) 2)\n            (get-primes (cdr\
    \ lst) (cons (car lst) primes))\n            (get-primes (cdr lst) primes))))\n\
    \  (define (get-max x y)\n    (if (> x y)\n        x\n        y))\n  (define (get-max-prime\
    \ lst)\n    (get-max (last-element lst) (get-max-prime (without-last lst))))\n\
    \  (define (sum-digits x)\n    (if (= x 0)\n        0\n        (+ (modulo x 10)\
    \ (sum-digits (/ x 10)))))\n  (sum-digits (get-max-prime (get-primes lst '()))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
