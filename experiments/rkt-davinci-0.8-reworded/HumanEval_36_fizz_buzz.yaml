name: HumanEval_36_fizz_buzz
language: rkt
prompt: "#lang racket\n\n;; Return the number of times the digit 7 appears in integers\
  \ less than n which are divisible by 11 or 13.\n;; >>> (fizz_buzz 50)\n;; 0\n;;\
  \ >>> (fizz_buzz 78)\n;; 2\n;; >>> (fizz_buzz 79)\n;; 3\n(define (fizz_buzz n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fizz_buzz))\n\
  \    (check-equal? (candidate 50) 0)\n    (check-equal? (candidate 78) 2)\n    (check-equal?\
  \ (candidate 79) 3)\n    (check-equal? (candidate 100) 3)\n    (check-equal? (candidate\
  \ 200) 6)\n    (check-equal? (candidate 4000) 192)\n    (check-equal? (candidate\
  \ 10000) 639)\n    (check-equal? (candidate 100000) 8026)\n))\n\n(test-humaneval)"
completions: ["  (let loop ([n n] [divs '(11 13)] [count 0])\n    (if (< n (car divs))\n\
    \        count\n        (let [div (car divs)]\n          (loop (- n 1) divs (+\
    \ count (length (string-match \"7\" (number->string (remainder n div))))))\n \
    \         )\n        )\n    )\n  )\n\n```\n\n### \u041F\u043E\u0434\u0441\u0447\
    \u0435\u0442 \u043D\u0435\u043F\u0440\u0435\u0440\u044B\u0432\u043D\u044B\u0445\
    \ \u0434\u0432\u043E\u0435\u043A \u0432 \u0447\u0438\u0441\u043B\u0435\n\n\u0417\
    \u0430\u0434\u0430\u0447\u0430 \u043F\u043E\u0434\u0441\u0447\u0435\u0442\u0430\
    \ \u043D\u0435\u043F\u0440\u0435\u0440\u044B\u0432\u043D\u044B\u0445 \u0434\u0432\
    \u043E\u0435\u043A \u0432 \u0447\u0438\u0441\u043B\u0435. \u0420\u0435\u0430\u043B\
    \u0438\u0437\u0430\u0446\u0438\u044F \u0441\u043B\u0435\u0434\u0443\u044E\u0449\
    \u0430\u044F:\n\n```#lang racket\n", "  (let loop ([n (- n 1)] [sum 0])\n    (cond\
    \ [(= n 0) sum]\n          [(or (zero? (modulo n 11)) (zero? (modulo n 13))) (loop\
    \ (- n 1) (+ sum (number-of-7 n)))]\n          [else (loop (- n 1) sum)])))",
  "  (define (count-seven m)\n    (if (= m 0)\n        0\n        (+ (if (= 7 (modulo\
    \ m 10)) 1 0)\n           (count-seven (quotient m 10)))))\n  (cond ((= n 0) 0)\n\
    \        ((and (= (modulo n 11) 0) (= (modulo n 13) 0))\n         (+ (count-seven\
    \ n) (fizz_buzz (- n 1))))\n        ((or (= (modulo n 11) 0) (= (modulo n 13)\
    \ 0))\n         (fizz_buzz (- n 1)))\n        (else 0)))\n", "  (if (= n 7)\n\
    \      1\n      (if (&lt; n 11)\n          0\n          (+ (fizz_buzz (- n 1))\n\
    \             (if (or (= (modulo n 11) 0) (= (modulo n 13) 0))\n             \
    \    (count-occurrences 7 n)\n                 0)))))\n", "  (cond\n    [(< n\
    \ 0) (error \"n must be positive\")]\n    [(< n 8) 0]\n    [(= (modulo n 11) 0)\
    \ (fizz_buzz (- n 1))]\n    [(= (modulo n 13) 0) (fizz_buzz (- n 1))]\n    [(and\
    \ (= (modulo n 10) 7) (< (quotient n 10) 10)) (+ 1 (fizz_buzz (- n 1)))]\n   \
    \ [else (fizz_buzz (- n 1))]))\n", "  (for/sum ([i (in-range n)] #:when (or (zero?\
    \ (modulo i 11)) (zero? (modulo i 13))))\n    (count (string-contains (number->string\
    \ i) \"7\"))))\n", "  (define (count-7s n)\n    (define (helper n count)\n   \
    \   (cond ((< n 1) count)\n            ((and (= (modulo n 10) 7)\n           \
    \       (or (zero? (modulo n 11))\n                      (zero? (modulo n 13))))\
    \ (helper (quotient n 10) (+ count 1)))\n            (else (helper (quotient n\
    \ 10) count))))\n    (helper n 0))\n  (count-7s n))\n", "  (define (fizz? n)\n\
    \    (or (zero? (modulo n 11))\n        (zero? (modulo n 13))))\n  (define (count-sevens\
    \ n acc)\n    (cond ((> n 0)\n           (count-sevens (quotient n 10)\n     \
    \                    (if (zero? (modulo n 10))\n                             acc\n\
    \                             (+ acc (equal? 7 (modulo n 10))))))\n          (else\
    \ acc)))\n  (cond ((not (fizz? n)) 0)\n        (else (count-sevens n 0))))\n",
  "  (define (check_divisibility7 i)\n    (cond ((<= i 0) 0)\n          ((and (= (modulo\
    \ i 11) 0) (= (modulo i 13) 0)) (check_divisibility7 (- i 1)))\n          ((=\
    \ (modulo i 11) 0) (check_divisibility7 (- i 1)))\n          ((= (modulo i 13)\
    \ 0) (check_divisibility7 (- i 1)))\n          ((= (modulo i 10) 7) (+ 1 (check_divisibility7\
    \ (- i 1))))\n          (else (check_divisibility7 (- i 1)))))\n  (check_divisibility7\
    \ n))\n```\n\n</details>\n\n<details>\n\n<summary>Click to show answer for Problem\
    \ 41</summary>\n\n```racket\n#lang racket\n", "  (if (or (= n 0) (= n 7)) 0 (+\
    \ (if (and (= (modulo n 11) 0) (= (modulo n 13) 0)) 1 0) (fizz_buzz (- n 1)))))\n",
  "  (if (< n 11)\n      0\n      (+ (if (or (zero? (modulo n 11)) (zero? (modulo\
    \ n 13)))\n             (if (or (equal? (modulo n 11) 7) (equal? (modulo n 13)\
    \ 7))\n                 1\n                 0)\n             0)\n         (fizz_buzz\
    \ (- n 1)))))\n```\n\n## Non-trivial commands\n\nThe following snippets are more\
    \ complex than a single `define` line.\n\n### `let`\n\n```racket\n#lang racket\n",
  "  (if (< n 0) -1\n      (if (< n 10) (if (= n 7) 1 0)\n          (+ (fizz_buzz\
    \ (- n 10))\n             (if (or (and (= (modulo n 11) 0) (= (modulo n 13) 0))\n\
    \                     (and (= (modulo n 13) 0) (= (modulo n 11) 0)))\n       \
    \          (fizz_buzz (quotient n 10))\n                 0)))))\n", "  (cond [(=\
    \ n 0) 0]\n        [(or (= (modulo n 11) 0) (= (modulo n 13) 0)) (+ (sevens n)\
    \ (fizz_buzz (- n 1)))]\n        [else (fizz_buzz (- n 1))]))\n", "  (define (loop\
    \ cur k)\n    (cond\n      [(>= cur n) k]\n      [(and (or (zero? (modulo cur\
    \ 11)) (zero? (modulo cur 13)))\n             (number-contains-digit? cur 7))\
    \ (loop (+ cur 1) (+ k 1))]\n      [else (loop (+ cur 1) k)]))\n  (loop 0 0))\n",
  "  (define (count_7_helper n)\n    (cond ((&lt; n 10) 0)\n          ((= (modulo\
    \ n 10) 7) 1)\n          (else 0)))\n  (define (count_7 n)\n    (if (= n 0) 0\n\
    \        (+ (count_7_helper n) (count_7 (quotient n 10)))))\n  (define (fb_helper\
    \ i)\n    (cond ((= (modulo i 11) 0) (+ (count_7 i) (fb_helper (+ i 1))))\n  \
    \        ((= (modulo i 13) 0) (+ (count_7 i) (fb_helper (+ i 1))))\n         \
    \ ((&lt; i n) (fb_helper (+ i 1)))\n          (else 0)))\n  (fb_helper 1))\n</code>\n\
    Did I go about this the wrong way? I wonder if there is a more readable or efficient\
    \ approach.\n\n\nA:\n\nI would first use <code>range</code> from <code>srfi/1</code>\
    \ (or <code>for/list</code> from <code>for</code>), and then write a helper procedure\
    \ that returns the <code>count</code> of 7s:\n<code>(define (digit-count nums)\n\
    \  (apply + (map (lambda (num)\n                  (count 7 (digits num)))\n  \
    \              nums)))\n</code>\nYou could use a similar approach to <code>count</code>\
    \ above:\n<code>(define (count-7-helper num)\n  (cond ((&lt; num 10) 0)\n    \
    \    ((= (modulo num 10) 7) 1)\n        (else 0)))\n", "  (let ([a 0])\n    (for\
    \ ([i (in-range 0 n)])\n      (when (or (divides? i 11) (divides? i 13))\n   \
    \     (when (divides? i 7)\n          (set! a (+ a 1)))))\n    a))\n", "  (cond\
    \ ((= n 1) 0)\n        ((= n 2) 0)\n        ((= n 3) 0)\n        ((= n 4) 0)\n\
    \        ((= n 5) 0)\n        ((= n 6) 0)\n        ((= n 7) 0)\n        ((= n\
    \ 8) 0)\n        ((= n 9) 0)\n        ((= n 10) 0)\n        ((= n 11) 0)\n   \
    \     ((= n 12) 0)\n        ((= n 13) 0)\n        ((= n 14) 0)\n        ((= n\
    \ 15) 0)\n        ((= n 16) 0)\n        ((= n 17) 0)\n        ((= n 18) 0)\n \
    \       ((= n 19) 0)\n        ((= n 20) 0)\n        ((= n 21) 0)\n        ((=\
    \ n 22) 0)\n        ((= n 23) 0)\n        ((= n 24) 0)\n        ((= n 25) 0)\n\
    \        ((= n 26) 0)\n        ((= n 27) 0)\n        ((= n 28) 0)\n        ((=\
    \ n 29) 0)\n        ((= n 30) 0)\n        ((= n 31) 0)\n        ((= n 32) 0)\n\
    \        ((= n 33) 0)\n        ((= n 34) 0)\n        ((= n 35) 0)\n        ((=\
    \ n 36) 0)\n        ((= n 37) 0)\n        ((= n 38) 0)\n        ((= n 39) 0)\n\
    \        ((= n 40) 0)\n        ((= n 41) 0)\n        ((= n 42) 0)\n        ((=\
    \ n 43) 0)\n        ((= n 44) 0)\n        ((= n 45) 0)\n        ((= n 46) 0)\n\
    \        ((= n 47) 0)\n        ((= n 48) 0)\n        ((= n 49) 0)\n        ((=\
    \ n 50) 0)\n        ((= n 51) 0)\n        ((= n 52) 0)\n        ((= n 53) 0)\n\
    \        ((= n 54) 0)\n        ((= n 55) 0)\n        ((= n 56) 0)\n        ((=\
    \ n 57", "  (cond\n    [(zero? n) 0]\n    [(or (zero? (modulo n 11)) (zero? (modulo\
    \ n 13))) (+ (contains-seven? n) (fizz_buzz (- n 1)))]\n    [else (fizz_buzz (-\
    \ n 1))]))\n", "  (let* ([nums (in-range n)]\n         [divided-nums (filter (\u03BB\
    \ (x) (or (divisible? x 11) (divisible? x 13))) nums)])\n    (count-if (\u03BB\
    \ (x) (contains? (string-&gt;list (number-&gt;string x)) #\\7)) divided-nums)))\n\
    </code>\nLet's evaluate the first step in <code>fizz_buzz</code>, <code>(in-range\
    \ n)</code>:\n<code>&gt; (in-range 4)", "  (cond\n    [(= n 0) 0]\n    [(and (zero?\
    \ (modulo n 11)) (zero? (modulo n 13)))\n     (+ (count 7 (number->string n))\
    \ (fizz_buzz (- n 1)))]\n    [else (fizz_buzz (- n 1))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
