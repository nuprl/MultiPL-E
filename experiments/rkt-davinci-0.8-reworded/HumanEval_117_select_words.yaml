name: HumanEval_117_select_words
language: rkt
prompt: "#lang racket\n\n;; Given a string s and a natural number n, you have been\
  \ tasked to implement \n;; a function that returns a list of all words from string\
  \ s that contain exactly \n;; n consonants, in order these words appear in the string\
  \ s.\n;; If the string s is empty then the function should return an empty list.\n\
  ;; Note: you may assume the input string contains only letters and spaces.\n;; Examples:\n\
  ;; >>> (select_words \"Mary had a little lamb\" 4)\n;; (list \"little\")\n;; >>>\
  \ (select_words \"Mary had a little lamb\" 3)\n;; (list \"Mary\" \"lamb\")\n;; >>>\
  \ (select_words \"simple white space\" 2)\n;; (list )\n;; >>> (select_words \"Hello\
  \ world\" 4)\n;; (list \"world\")\n;; >>> (select_words \"Uncle sam\" 3)\n;; (list\
  \ \"Uncle\")\n(define (select_words s n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate select_words))\n\
  \    (check-equal? (candidate \"Mary had a little lamb\" 4) (list \"little\"))\n\
  \    (check-equal? (candidate \"Mary had a little lamb\" 3) (list \"Mary\" \"lamb\"\
  ))\n    (check-equal? (candidate \"simple white space\" 2) (list ))\n    (check-equal?\
  \ (candidate \"Hello world\" 4) (list \"world\"))\n    (check-equal? (candidate\
  \ \"Uncle sam\" 3) (list \"Uncle\"))\n    (check-equal? (candidate \"\" 4) (list\
  \ ))\n    (check-equal? (candidate \"a b c d e f\" 1) (list \"b\" \"c\" \"d\" \"\
  f\"))\n))\n\n(test-humaneval)"
completions: ["  (define (select_words-impl s n lst)\n    (cond [(empty? s) lst]\n\
    \          [(= (count-consonants (first s)) n) (select_words-impl (rest s) n (append\
    \ lst (list (first s))))]\n          [else (select_words-impl (rest s) n lst)]))\n\
    \  (select_words-impl (string-split s #\\space) n (list)))\n", "  (map (lambda\
    \ (word)\n          (if (= (count_consonants word) n)\n              word\n  \
    \            null))\n         (split s)))\n", "  (define (select_words-help s\
    \ n acc)\n    (if (string-empty? s)\n        acc\n        (let ([w (car (string-split\
    \ s #\\space))]\n              [s (cdr (string-split s #\\space))])\n        \
    \  (select_words-help s n\n            (if (= n (count-consonants w))\n      \
    \          (cons w acc)\n                acc)))))\n  (reverse (select_words-help\
    \ s n '())))\n", "  (define (is_vowel c)\n    (member c '(#\\a #\\e #\\i #\\o\
    \ #\\u)))\n  (define (is_consonant c)\n    (and (not (is_vowel c))\n         (char-alphabetic?\
    \ c)))\n  (define (count-consonants str)\n    (if (null? str)\n        0\n   \
    \     (+ (if (is_consonant (car str)) 1 0)\n           (count-consonants (cdr\
    \ str)))))\n  (define (select-words-iter s acc)\n    (if (null? s)\n        acc\n\
    \        (let ((word (first s)))\n          (select-words-iter (rest s)\n    \
    \                         (if (= n (count-consonants word))\n                \
    \                 (cons word acc)\n                                 acc)))))\n\
    \  (select-words-iter (string-split s #\\space) null))", "    (map (lambda (w)\
    \ (car w)) (filter (lambda (w) (= n (cdr w))) (map (lambda (word) (cons word (consonants\
    \ word))) (split s)))))\n", "  (cond\n    [(empty? s) empty]\n    [else (define\
    \ (is-consonant? c)\n            (cond\n              [(char-ci=? c #\\a) #f]\n\
    \              [(char-ci=? c #\\e) #f]\n              [(char-ci=? c #\\i) #f]\n\
    \              [(char-ci=? c #\\o) #f]\n              [(char-ci=? c #\\u) #f]\n\
    \              [else #t]))\n          (define (count-consonants w)\n         \
    \   (foldl (lambda (c acc)\n                     (if (is-consonant? c)\n     \
    \                    (+ acc 1)\n                         acc))\n             \
    \      0\n                   w))\n          (define (check-word w)\n         \
    \   (if (= (count-consonants w) n)\n                (list w)\n               \
    \ empty))\n          (append (check-word (first (string-split s #\\space)))\n\
    \                  (select_words (string-join (rest (string-split s #\\space)))\
    \ n))]))\n", "  (define (consonant? c)\n    (let ([uc (string-upcase c)])\n  \
    \    (or (equal? uc \"B\") (equal? uc \"C\") (equal? uc \"D\") (equal? uc \"F\"\
    ) (equal? uc \"G\")\n          (equal? uc \"H\") (equal? uc \"J\") (equal? uc\
    \ \"K\") (equal? uc \"L\") (equal? uc \"M\")\n          (equal? uc \"N\") (equal?\
    \ uc \"P\") (equal? uc \"Q\") (equal? uc \"R\") (equal? uc \"S\")\n          (equal?\
    \ uc \"T\") (equal? uc \"V\") (equal? uc \"W\") (equal? uc \"X\") (equal? uc \"\
    Y\")\n          (equal? uc \"Z\"))))\n  (define (count c cs)\n    (if (null? cs)\n\
    \        0\n        (+ (if (consonant? (string-ref c 0)) 1 0) (count c (cdr cs)))))\n\
    \  (define (process word words)\n    (if (null? words)\n        (list word)\n\
    \        (if (= (count word (string->list word)) n)\n            (cons word (process\
    \ word (cdr words)))\n            (process word (cdr words)))))\n  (if (string=?\
    \ s \"\")\n      '()\n      (process (car (string-split s #\\space)) (cdr (string-split\
    \ s #\\space)))))", "  (cond\n    [(empty? s) empty]\n    [else\n     (let ([word\
    \ (regexp-match #rx\"\\S+\" s)])\n       (if (and (not (empty? word)) (= n (count-consonants\
    \ (car word))))\n           (cons (car word) (select_words (regexp-replace #rx\"\
    \\S+\" s \"\")))\n           (select_words (regexp-replace #rx\"\\S+\" s \"\"\
    ))))]))\n", "  (apply list (filter (lambda (x) (equal? n (count-vowels x))) (string-split\
    \ s #\\space))))\n", "  (if (empty? s)\n      '()\n      (let ([w (first (string-split\
    \ s \" \"))])\n        (if (= n (count-consonants w))\n            (cons w (select_words\
    \ (string-join (rest (string-split s \" \")) \" \") n))\n            (select_words\
    \ (string-join (rest (string-split s \" \")) \" \") n)))))\n", "  (let* ([lst\
    \ (string-split s)]\n         [i (cons '() lst)]\n         [f (lambda (i)\n  \
    \            (if (empty? i)\n                  '()\n                  (let* ([word\
    \ (car i)]\n                         [word-consonants (number-of-consonants word)])\n\
    \                    (if (= word-consonants n)\n                        (cons\
    \ word (f (cdr i)))\n                        (f (cdr i))))))])\n    (f i)))\n",
  "  (define vowels '(a e i o u))\n  (define (is_consonant c)\n    (if (member c vowels)\
    \ #f #t))\n  (define (count_consonants x)\n    (if (char-alphabetic? x) (is_consonant\
    \ x) #f))\n  (define (count_word s)\n    (cond\n      [(eq? 0 (string-length s))\
    \ 0]\n      [else (+ (count_consonants (string-ref s 0)) (count_word (substring\
    \ s 1)))]))\n  (cond\n    [(eq? 0 (string-length s)) (list)]\n    [(eq? n (count_word\
    \ (first (string-split s)))) (cons (first (string-split s)) (select_words (string-trim\
    \ (string-join (rest (string-split s)))) n))]\n    [else (select_words (string-trim\
    \ (string-join (rest (string-split s)))) n)]))\n", "  (match (string-split s)\n\
    \    [(\"\") '()]\n    [(list s ...)\n     (filter (lambda (w)\n             \
    \  (= n (count_consonants w)))\n             (string-split s))]))\n", "  (if (empty?\
    \ s) empty (if (== n (count-consonants (string-head s)))\n                   \
    \        (cons (string-head s) (select_words (string-tail s) n))\n           \
    \                (select_words (string-tail s) n))))\n", "  (define (is_vowel?\
    \ c)\n    (member c '(#\\a #\\e #\\i #\\o #\\u)))\n  (define (helper lst selected)\n\
    \    (cond ((null? lst) selected)\n          ((eq? (length (filter is_vowel? (car\
    \ lst))) (- (length (car lst)) n))\n           (helper (cdr lst) (append selected\
    \ (list (car lst)))))\n          (else (helper (cdr lst) selected))))\n  (helper\
    \ (regexp-split #rx\" +\" s) '()))", "    (map car\n         (filter (lambda (x)\
    \ (= n (cdr x)))\n                 (map (lambda (w) (cons w (count_consonants\
    \ w)))\n                      (string-tokenize s)))))\n</code>\nSo, I get the\
    \ feeling that what I am doing is not particularly efficient, but I am not sure\
    \ how to proceed.\nWhat are the other ways of accomplishing the same result?",
  "  (match s\n    (\"\" '())\n    (s (let-values ([(word rest) (regexp-match #rx\"\
    ^[a-zA-Z]+\" s)])\n         (cond\n           [(empty? word) '()]\n          \
    \ [(= n (consonants word)) (cons word (select_words rest n))]\n           [else\
    \ (select_words rest n)])))))\n", "  (filter (\u03BB (x) (= n (consonants x)))\
    \ (string-split s)))\n", "  (cond [(= n 0) (list \"\")]\n        [(empty? s) (list)]\n\
    \        [else\n         (append\n          (select_words (string-tail s) n)\n\
    \          (map\n           (lambda (w) (string-append (string-head s) w))\n \
    \          (select_words (string-tail s) (- n 1))))]))\n```\n\n```#lang racket",
  "  (define cons \"bcdfghjklmnpqrstvwxyz\")\n  (map list\n       (filter (lambda\
    \ (word)\n                 (= n (length (filter (lambda (c) (member c cons)) word))))\n\
    \               (string-split s))))"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
