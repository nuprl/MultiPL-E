name: HumanEval_82_prime_length
language: rkt
prompt: "#lang racket\n\n;; Write a function that takes a string and returns #t if\
  \ the string\n;; length is a prime number or #f otherwise\n;; Examples\n;; >>> (prime_length\
  \ \"Hello\")\n;; #t\n;; >>> (prime_length \"abcdcba\")\n;; #t\n;; >>> (prime_length\
  \ \"kittens\")\n;; #t\n;; >>> (prime_length \"orange\")\n;; #f\n(define (prime_length\
  \ string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_length))\n\
  \    (check-equal? (candidate \"Hello\") #t)\n    (check-equal? (candidate \"abcdcba\"\
  ) #t)\n    (check-equal? (candidate \"kittens\") #t)\n    (check-equal? (candidate\
  \ \"orange\") #f)\n    (check-equal? (candidate \"wow\") #t)\n    (check-equal?\
  \ (candidate \"world\") #t)\n    (check-equal? (candidate \"MadaM\") #t)\n    (check-equal?\
  \ (candidate \"Wow\") #t)\n    (check-equal? (candidate \"\") #f)\n    (check-equal?\
  \ (candidate \"HI\") #t)\n    (check-equal? (candidate \"go\") #t)\n    (check-equal?\
  \ (candidate \"gogo\") #f)\n    (check-equal? (candidate \"aaaaaaaaaaaaaaa\") #f)\n\
  \    (check-equal? (candidate \"Madam\") #t)\n    (check-equal? (candidate \"M\"\
  ) #f)\n    (check-equal? (candidate \"0\") #f)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(prime? (string-length string)) #t]\n    [else #f]))\n",
  "  (if (prime? (string-length string))\n      #t\n      #f))\n", "  (define (prime?\
    \ n)\n    (define (helper divisor)\n      (if (> divisor n) #t\n          (if\
    \ (= (modulo n divisor) 0) #f\n              (helper (+ divisor 1)))))\n    (helper\
    \ 2))\n  (prime? (string-length string)))", "  (define (prime n)\n    (cond ((=\
    \ n 1) #f)\n          ((= n 2) #t)\n          ((even? n) #f)\n          (else\
    \ (prime_test n 3))))\n  (prime (string-length string)))\n", "  (if (= 1 (remainder\
    \ (string-length string) 2))\n      #t\n      #f))\n", "  (cond [(prime? (string-length\
    \ string)) #t]\n        [else #f]))\n", "  (and\n   (prime? (string-length string))\n\
    \   #t))\n", "  (let ((length (string-length string)))\n    (cond ((= length 2)\
    \ #t)\n          ((= length 3) #t)\n          ((= length 5) #t)\n          ((=\
    \ length 7) #t)\n          ((= length 11) #t)\n          ((= length 13) #t)\n\
    \          ((= length 17) #t)\n          ((= length 19) #t)\n          ((= length\
    \ 23) #t)\n          ((= length 29) #t)\n          ((= length 31) #t)\n      \
    \    ((= length 37) #t)\n          ((= length 41) #t)\n          ((= length 43)\
    \ #t)\n          ((= length 47) #t)\n          ((= length 53) #t)\n          ((=\
    \ length 59) #t)\n          ((= length 61) #t)\n          ((= length 67) #t)\n\
    \          ((= length 71) #t)\n          ((= length 73) #t)\n          ((= length\
    \ 79) #t)\n          ((= length 83) #t)\n          ((= length 89) #t)\n      \
    \    ((= length 97) #t)\n          ((= length 101) #t)\n          ((= length 103)\
    \ #t)\n          ((= length 107) #t)\n          ((= length 109) #t)\n        \
    \  ((= length 113) #t)\n          ((= length 127) #t)\n          ((= length 131)\
    \ #t)\n          ((= length 137) #t)\n          ((= length 139) #t)\n        \
    \  ((= length 149) #t)\n          ((= length 151) #t)\n          ((= length 157)\
    \ #t)\n          ((= length 163) #t)\n          ((= length 167) #t)\n        \
    \  ((= length 173) #t)\n          ((= length 179) #t)\n          ((= length 181)\
    \ #t)\n          ((= length 191) #t)\n          ((= length 193) #t)\n        \
    \  ((= length 197) #t)\n          ((= length 199) #t)\n          ((= length 211)\
    \ #t)\n          ((= length 223) #t)\n          ((= length 227) #t)\n        \
    \  ((= length 229) #", "  (local [(define (is-prime? n)\n            (cond [(=\
    \ n 1) #f]\n                  [(= n 2) #t]\n                  [(= n 3) #t]\n \
    \                 [(= n 4) #f]\n                  [(= n 5) #t]\n             \
    \     [(= n 6) #f]\n                  [(= n 7) #t]\n                  [(= n 8)\
    \ #f]\n                  [(= n 9) #f]\n                  [(= n 10) #f]\n     \
    \             [(is-prime? (integer-sqrt n)) #t]\n                  [else #f]))]\n\
    \    (is-prime? (string-length string))))\n", "  (letrec ([prime? (lambda (n)\n\
    \                     (define (odd n)\n                       (or (= 1 n)\n  \
    \                         (and (odd? n)\n                                (not\
    \ (zero? (remainder n 2))))))\n                     (define (prime? n)\n     \
    \                  (if (odd n)\n                           (letrec ([loop (lambda\
    \ (x)\n                                            (or (= x n)\n             \
    \                                   (and (not (zero? (remainder n x)))\n     \
    \                                                (loop (+ x 2)))))])\n       \
    \                      (loop 3))\n                           #f))\n          \
    \           (prime? n))]\n            [length_is_prime? (lambda (string)\n   \
    \                             (prime? (string-length string)))])\n    (length_is_prime?\
    \ string)))\n", '  (prime? (string-length string)))', "  (define (is-prime num)\n\
    \    (if (= num 1)\n        #f\n        (if (= num 2)\n            #t\n      \
    \      (let loop ((x 2))\n              (if (= x num)\n                  #t\n\
    \                  (if (= (modulo num x) 0)\n                      #f\n      \
    \                (loop (+ x 1))))))))\n  (is-prime (string-length string)))\n",
  "  (prime? (string-length string)))\n", "  (prime? (string-length string)))\n",
  "  (define (divisible? x y)\n    (= (remainder x y) 0))\n  (define (find-divisor\
    \ n test-divisor)\n    (cond ((> (square test-divisor) n) n)\n          ((divisible?\
    \ n test-divisor) test-divisor)\n          (else (find-divisor n (+ test-divisor\
    \ 1)))))\n  (define (prime? n)\n    (= n (find-divisor n 2)))\n  (prime? (string-length\
    \ string)))", "  (prime? (string-length string)))\n", "  ;; Your solution here\n\
    \  )\n", "  (or (prime? (string-length string)) #f))\n", "  (define (len str)\n\
    \    (if (eq? str \"\")\n        0\n        (+ 1 (len (substring str 1)))))\n\
    \  (define (is_prime? num)\n    (if (eq? num 2)\n        #t\n        (and (not\
    \ (zero? (modulo num 2)))\n             (not (zero? (modulo num 3)))\n       \
    \      (not (zero? (modulo num 5)))\n             (not (zero? (modulo num 7)))\n\
    \             (not (zero? (modulo num 11)))\n             (not (zero? (modulo\
    \ num 13)))\n             (not (zero? (modulo num 17)))\n             (not (zero?\
    \ (modulo num 19)))\n             (not (zero? (modulo num 23)))\n            \
    \ (not (zero? (modulo num 29)))\n             (not (zero? (modulo num 31)))\n\
    \             (not (zero? (modulo num 37)))\n             (not (zero? (modulo\
    \ num 41)))\n             (not (zero? (modulo num 43)))\n             (not (zero?\
    \ (modulo num 47)))\n             (not (zero? (modulo num 53)))\n            \
    \ (not (zero? (modulo num 59)))\n             (not (zero? (modulo num 61)))\n\
    \             (not (zero? (modulo num 67)))\n             (not (zero? (modulo\
    \ num 71)))\n             (not (zero? (modulo num 73)))\n             (not (zero?\
    \ (modulo num 79)))\n             (not (zero? (modulo num 83)))\n            \
    \ (not (zero? (modulo num 89)))\n             (not (zero? (modulo num 97)))\n\
    \             (not (zero? (modulo num 101)))\n             (not (zero? (modulo\
    \ num 103)))\n             (not (zero? (modulo num 107)))\n             (not (zero?\
    \ (modulo num 109)))\n             (not (zero? (modulo num 113)))\n          \
    \   (not (zero? (modulo num 127)))\n             (not (zero? (modulo num 131)))\n\
    \             (not (zero? (modulo num 137)))\n             (not (zero? (modulo\
    \ num 139)))\n             (not (zero? (mod", "  (define (prime? n)\n    (cond\
    \ ((= n 2) #t)\n          ((even? n) #f)\n          (else\n           (define\
    \ (helper i)\n             (cond ((> (* i i) n) #t)\n                   ((divides?\
    \ i n) #f)\n                   (else (helper (+ i 1)))))\n           (helper 3))))\n\
    \  (prime? (string-length string)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
