name: HumanEval_5_intersperse
language: rkt
prompt: "#lang racket\n\n;; Insert a number 'delimeter' between every two consecutive\
  \ elements of input list `numbers'\n;; >>> (intersperse (list ) 4)\n;; (list )\n\
  ;; >>> (intersperse (list 1 2 3) 4)\n;; (list 1 4 2 4 3)\n(define (intersperse numbers\
  \ delimeter)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate intersperse))\n\
  \    (check-equal? (candidate (list ) 7) (list ))\n    (check-equal? (candidate\
  \ (list 5 6 3 2) 8) (list 5 8 6 8 3 8 2))\n    (check-equal? (candidate (list 2\
  \ 2 2) 2) (list 2 2 2 2 2))\n))\n\n(test-humaneval)"
completions: ["  (if (null? numbers)\n      (list)\n      (cond ((null? (cdr numbers))\
    \ numbers)\n            (else (cons (car numbers) (cons delimeter (intersperse\
    \ (cdr numbers) delimeter)))))))\n", "  (cond [(empty? numbers) '()]\n       \
    \ [(empty? (rest numbers)) (list (first numbers))]\n        [else (list (first\
    \ numbers) delimeter (intersperse (rest numbers) delimeter))]))\n", "  (cond [(empty?\
    \ numbers) empty]\n        [(equal? (second numbers) empty) (list (first numbers))]\n\
    \        [else (cons (first numbers) (cons delimeter (intersperse (rest numbers)\
    \ delimeter)))]))\n", "  (cond [(empty? numbers) empty]\n        [(empty? (rest\
    \ numbers)) numbers]\n        [else (cons (first numbers) (cons delimeter (intersperse\
    \ (rest numbers) delimeter)))]))\n```\n\n```racket\n#lang racket\n", "  (cond\n\
    \    [(empty? numbers) empty]\n    [(empty? (rest numbers)) numbers]\n    [else\
    \ (cons (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n",
  "  (if (null? numbers)\n      '()\n      (append (list (car numbers))\n        \
    \      (list delimeter)\n              (intersperse (cdr numbers) delimeter))))\n",
  "  (cond\n    [(empty? numbers) (list)]\n    [(rest numbers)\n     (cons (first\
    \ numbers)\n           (cons delimeter\n                 (intersperse (rest numbers)\
    \ delimeter)))]\n    [else numbers]))", "  (cond\n    [(null? numbers) (list)]\n\
    \    [(empty? (rest numbers)) numbers]\n    [else (cons (first numbers) (cons\
    \ delimeter (intersperse (rest numbers) delimeter)))]))\n", "  (if (null? numbers)\n\
    \      numbers\n      (list (car numbers)\n            delimeter\n           \
    \ (intersperse (cdr numbers) delimeter))))\n", "  (cond [(empty? numbers) (list)]\n\
    \        [(empty? (rest numbers)) (list (first numbers))]\n        [else (cons\
    \ (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n",
  "  (cond\n    [(null? numbers)\n     (list)]\n    [(null? (cdr numbers))\n     numbers]\n\
    \    [else\n     (append (list (car numbers) delimeter) (intersperse (cdr numbers)\
    \ delimeter))]))\n", "  (let loop ((numbers numbers) (acc '()))\n    (if (null?\
    \ numbers)\n        (reverse acc)\n        (let ((next (cdr numbers)))\n     \
    \     (if (null? next)\n              (reverse (cons (car numbers) acc))\n   \
    \           (loop next (cons (car numbers) (cons delimeter acc))))))))\n", " \
    \ (cond\n    [(empty? numbers) empty]\n    [(empty? (rest numbers)) numbers]\n\
    \    [else (cons (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n",
  "  (cond\n    [(null? numbers)\n     (list)]\n    [(null? (cdr numbers))\n     numbers]\n\
    \    [else\n     (cons (car numbers)\n           (cons delimeter\n           \
    \      (intersperse (cdr numbers) delimeter)))]))\n", "  (define (insert-numbers-delimeter\
    \ lst)\n    (if (null? lst)\n        lst\n        (append (list (car lst)) (list\
    \ delimeter) (insert-numbers-delimeter (cdr lst)))))\n  (define (condense numbers-with-delimeters)\n\
    \    (if (null? numbers-with-delimeters)\n        (list)\n        (if (equal?\
    \ (car numbers-with-delimeters) delimeter)\n            (condense (cdr numbers-with-delimeters))\n\
    \            (cons (car numbers-with-delimeters) (condense (cdr numbers-with-delimeters))))))\n\
    \  (condense (insert-numbers-delimeter numbers)))\n", "  (if (null? numbers)\n\
    \      numbers\n      (list-append (list (car numbers))\n                   (list\
    \ delimeter)\n                   (intersperse (cdr numbers) delimeter))))\n",
  "  (match numbers\n    [(list) (list)]\n    [(list (? number? next) ...)\n     (match\
    \ (intersperse (list next ...) delimeter)\n       [(list) (list next)]\n     \
    \  [(list n ...) (list next delimeter n ...)])]))\n", "  (if (null? numbers)\n\
    \      '()\n      (append (list (car numbers))\n              (list delimeter)\n\
    \              (intersperse (cdr numbers) delimeter))))\n", "  (cond\n    [(empty?\
    \ numbers) empty]\n    [(empty? (rest numbers)) numbers]\n    [else (cons (first\
    \ numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n", " \
    \ (cond [(empty? numbers) empty]\n        [(rest numbers) (cons (first numbers)\
    \ (cons delimeter (intersperse (rest numbers) delimeter)))]\n        [else numbers]))\n\
    \n", "  (cond [(empty? numbers) empty]\n        [(rest numbers) (cons (first numbers)\n\
    \                              (cons delimeter\n                             \
    \       (intersperse (rest numbers) delimeter)))]\n        [else numbers]))\n",
  "  (define (insert-delimeter sequence)\n    (if (empty? sequence)\n        sequence\n\
    \        (cons (first sequence)\n              (cons delimeter\n             \
    \       (insert-delimeter (rest sequence))))))\n  (if (empty? numbers)\n     \
    \ numbers\n      (insert-delimeter numbers)))\n", "  (match numbers\n    [(list)\
    \ empty]\n    [(list head ...tail) (cons head (cons delimeter (intersperse tail\
    \ delimeter)))]))\n", "  (if (null? numbers)\n      (list)\n      (if (null? (cdr\
    \ numbers))\n          (list (car numbers))\n          (append (list (car numbers)\
    \ delimeter) (intersperse (cdr numbers) delimeter)))))\n", "  (cond\n    [(null?\
    \ numbers) (list )]\n    [(null? (cdr numbers)) numbers]\n    [else\n     (append\
    \ (list (car numbers) delimeter)\n             (intersperse (cdr numbers) delimeter))]))\n",
  "  (cond\n    [(null? numbers) empty]\n    [(null? (cdr numbers)) numbers]\n   \
    \ [else (cons (car numbers) (cons delimeter (intersperse (cdr numbers) delimeter)))]))\n",
  "  (if (null? numbers)\n      (list)\n      (cons (car numbers) (cons delimeter\
    \ (intersperse (cdr numbers) delimeter)))))\n", "  (cond [(empty? numbers) '()]\n\
    \        [(empty? (rest numbers)) (list (first numbers))]\n        [else (cons\
    \ (first numbers)\n                    (cons delimeter\n                     \
    \     (intersperse (rest numbers) delimeter)))]))\n", "  (let loop ((numbers numbers)\
    \ (acc '()))\n    (cond ((empty? numbers) (reverse acc))\n          ((empty? (rest\
    \ numbers)) (reverse (cons (first numbers) acc)))\n          (else (loop (rest\
    \ numbers) (cons (first numbers) (cons delimeter acc)))))))\n", "  (if (null?\
    \ numbers)\n      '()\n      (list (car numbers)\n            (if (null? (cdr\
    \ numbers))\n                '()\n                (list delimeter))\n        \
    \    (intersperse (cdr numbers) delimeter))))\n", "  (cond\n    [(empty? numbers)\
    \ (list)]\n    [(= (length numbers) 1) numbers]\n    [else (cons (first numbers)\
    \ (cons delimeter (intersperse (rest numbers) delimeter)))]))\n", "  (define (intersperse-iter\
    \ numbers acc)\n    (if (null? numbers)\n        acc\n        (if (pair? numbers)\n\
    \            (intersperse-iter (cdr numbers) (append acc (list (car numbers) delimeter)))\n\
    \            (intersperse-iter (cdr numbers) (append acc (list (car numbers)))))))\n\
    \  (if (null? numbers)\n      (list)\n      (intersperse-iter numbers (list (car\
    \ numbers)))))\n", "    (if (null? numbers)\n        '()\n        (if (null? (cdr\
    \ numbers))\n            numbers\n            (cons (car numbers)\n          \
    \        (cons delimeter\n                        (intersperse (cdr numbers) delimeter)))\n\
    \        )\n    )\n)\n", "  (cond [(empty? numbers) '()]\n        [(= (length\
    \ numbers) 1) numbers]\n        [else (cons (first numbers)\n                \
    \    (cons delimeter\n                          (intersperse (rest numbers) delimeter)))]))\n",
  "  (cond [(null? numbers) '()]\n        [(null? (cdr numbers)) '()]\n        [else\
    \ (cons (car numbers) (cons delimeter (intersperse (cdr numbers) delimeter)))]))\n",
  "  (local [(define (helper nl n)\n            (cond [(empty? nl) '()]\n        \
    \          [(empty? (rest nl)) (list n)]\n                  [else (cons n (cons\
    \ delimeter (helper (rest nl) (second nl))))]))]\n    (helper numbers (first numbers))))\n",
  "  (if (empty? numbers)\n      (list)\n      (if (empty? (rest numbers))\n     \
    \     (list (first numbers))\n          (cons (first numbers) (cons delimeter\
    \ (intersperse (rest numbers) delimeter))))))\n", "  (if (null? numbers)\n   \
    \   numbers\n      (if (equal? (length numbers) 1)\n          numbers\n      \
    \    (cons (car numbers) (cons delimeter (intersperse (cdr numbers) delimeter))))))\n\
    ```\n\n```racket\n#lang racket\n", "  (cond\n    [(empty? numbers) empty]\n  \
    \  [(rest numbers)\n     (list (first numbers) delimeter (intersperse (rest numbers)\
    \ delimeter))]\n    [else\n     (list (first numbers))]))\n```\n\n```racket\n\
    #lang racket\n", "  (if (null? numbers)\n      '()\n      (if (null? (cdr numbers))\n\
    \          (list (car numbers))\n          (cons (car numbers)\n             \
    \   (cons delimeter\n                      (intersperse (cdr numbers) delimeter))))))\n",
  "  (if (null? numbers)\n      numbers\n      (append (list (car numbers))\n    \
    \          (list delimeter)\n              (intersperse (cdr numbers) delimeter))))\n",
  "  (cond\n    [(null? numbers) '()]\n    [(null? (cdr numbers)) numbers]\n    [else\
    \ (cons (car numbers) (cons delimeter (intersperse (cdr numbers) delimeter)))]))\n",
  "  (cond\n    [(empty? numbers) empty]\n    [(rest numbers)\n     (cons (first numbers)\n\
    \           (cons delimeter\n                 (intersperse (rest numbers) delimeter)))]\n\
    \    [else\n     (cons (first numbers) empty)]))\n", "  (if (null? numbers)\n\
    \      (list)\n      (cons (car numbers)\n            (cons delimeter\n      \
    \            (intersperse (cdr numbers) delimeter)))))\n", "  (cond [(null? numbers)\
    \ '()]\n        [(null? (cdr numbers)) numbers]\n        [else (cons (car numbers)\n\
    \                    (cons delimeter\n                          (intersperse (cdr\
    \ numbers) delimeter)))]))\n", "  (cond\n    [(empty? numbers) (list)]\n    [(empty?\
    \ (rest numbers)) (list (first numbers))]\n    [else (cons (first numbers) (cons\
    \ delimeter (intersperse (rest numbers) delimeter)))]))\n", "  (cond [(empty?\
    \ numbers) '()]\n        [(cons? numbers) (cons (first numbers) (cons delimeter\
    \ (intersperse (rest numbers) delimeter)))]))\n", "  (cond [(empty? numbers) empty]\n\
    \        [(rest numbers) (cons (first numbers)\n                             \
    \ (cons delimeter\n                                    (intersperse (rest numbers)\
    \ delimeter)))]\n        [else numbers]))\n", "  (if (null? numbers)\n      (list)\n\
    \      (if (null? (cdr numbers))\n          (list (car numbers))\n          (append\
    \ (list (car numbers) delimeter) (intersperse (cdr numbers) delimeter)))))\n",
  "  (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        \
    \  (list (car numbers))\n          (cons (car numbers)\n                (cons\
    \ delimeter\n                      (intersperse (cdr numbers) delimeter))))))\n",
  "  (cond\n    [(empty? numbers) '()]\n    [(empty? (rest numbers)) numbers]\n  \
    \  [else (cons (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n",
  "  (match numbers\n    [(cons a rest) (cons a (cons delimeter (intersperse rest\
    \ delimeter)))]\n    [(list) '()]))\n", "  (let loop ((numbers numbers) (delimeter\
    \ delimeter) (result null))\n    (cond ((null? numbers) (reverse result))\n  \
    \        (else\n           (loop (cdr numbers) delimeter (cons (car numbers) (cons\
    \ delimeter result)))))))\n", "  (if (empty? numbers)\n      (list)\n      (cons\
    \ (first numbers)\n            (cons delimeter\n                  (intersperse\
    \ (rest numbers) delimeter)))))\n", "  (cond\n    [(empty? numbers) '()]\n   \
    \ [(empty? (rest numbers)) (list (first numbers))]\n    [else (list (first numbers)\
    \ delimeter (apply intersperse (rest numbers) delimeter))]))\n", "  (cond\n  \
    \  [(null? numbers) (list)]\n    [(null? (cdr numbers)) numbers]\n    [else (cons\
    \ (car numbers) (cons delimeter (intersperse (cdr numbers) delimeter)))]))", " \
    \ (cond\n    [(empty? numbers) (list)]\n    [(empty? (rest numbers)) (list (first\
    \ numbers))]\n    [else (cons (first numbers) (cons delimeter (intersperse (rest\
    \ numbers) delimeter)))]))\n", "  (if (null? numbers)\n      '()\n      (if (null?\
    \ (cdr numbers))\n          numbers\n          (append (list (car numbers) delimeter)\
    \ (intersperse (cdr numbers) delimeter)))))\n", "  (match numbers\n    [`(,head\
    \ ,rest ...)\n     (cons head (append (list delimeter) (intersperse rest delimeter)))]\n\
    \    [`()\n     '()]))\n", "  (cond\n    [(null? numbers) (list)]\n    [(null?\
    \ (cdr numbers)) numbers]\n    [else (cons (car numbers) (cons delimeter (intersperse\
    \ (cdr numbers) delimeter)))]))\n", "  (if (null? numbers)\n      '()\n      (cons\
    \ (car numbers)\n            (cons delimeter\n                  (intersperse (cdr\
    \ numbers) delimeter)))))\n", "  (if (null? numbers)\n      '()\n      (cons (car\
    \ numbers) (cons delimeter (intersperse (cdr numbers) delimeter)))))\n```\n\n\
    ``` #lang racket\n", "  (define (aux acc numbers delimeter)\n    (if (null? numbers)\n\
    \        acc\n        (aux (append acc (list (car numbers) delimeter)) (cdr numbers)\
    \ delimeter)))\n  (let ((result (aux '() numbers delimeter)))\n    (reverse (cdr\
    \ result))))\n\n", "  (cond\n    [(empty? numbers) empty]\n    [(empty? (rest\
    \ numbers)) numbers]\n    [else (cons (first numbers) (cons delimeter (intersperse\
    \ (rest numbers) delimeter)))]))\n", "  (cond\n    [(null? numbers)\n     (list)]\n\
    \    [(null? (cdr numbers))\n     numbers]\n    [else\n     (cons (car numbers)\n\
    \           (cons delimeter\n                 (intersperse (cdr numbers) delimeter)))]))",
  "  (cond [(empty? numbers) '()]\n        [(rest numbers) (cons (first numbers)\n\
    \                              (cons delimeter\n                             \
    \       (intersperse (rest numbers) delimeter)))]\n        [else numbers]))\n",
  "  (if (null? numbers)\n      (list)\n      (append (list (car numbers))\n     \
    \         (list delimeter)\n              (intersperse (cdr numbers) delimeter))))\n",
  "  (match numbers\n    [(list ) null]\n    [(list first second . rest) (list first\
    \ delimeter second . (intersperse rest delimeter))]))\n```\n\n```racket\n#lang\
    \ racket\n", "  (define (intersperse-helper numbers acc)\n    (cond [(empty? numbers)\
    \ acc]\n          [(empty? (rest numbers)) (append acc (list (first numbers)))]\n\
    \          [else (intersperse-helper (rest numbers) (append acc (list (first numbers)\
    \ delimeter)))]))\n  (intersperse-helper numbers '()))\n", "  (cond [(empty? numbers)\
    \ numbers]\n        [else (cons (first numbers) (cons delimeter (intersperse (rest\
    \ numbers) delimeter)))]))\n", "  (cond ((null? numbers) (list))\n        ((null?\
    \ (cdr numbers)) numbers)\n        (else (cons (car numbers) (cons delimeter (intersperse\
    \ (cdr numbers) delimeter))))))\n", "  (if (null? numbers)\n      (list)\n   \
    \   (if (null? (cdr numbers))\n          (list (car numbers))\n          (cons\
    \ (car numbers) (cons delimeter (intersperse (cdr numbers) delimeter))))))\n",
  "  (if (empty? numbers)\n      (list)\n      (if (empty? (rest numbers))\n     \
    \     (list (first numbers))\n          (cons (first numbers) (cons delimeter\
    \ (intersperse (rest numbers) delimeter))))))\n", "  (cond [(empty? numbers) '()]\n\
    \        [(empty? (rest numbers)) numbers]\n        [else (append (list (first\
    \ numbers) delimeter) (intersperse (rest numbers) delimeter))]))\n", "  (cond\n\
    \    [(empty? numbers) empty]\n    [(empty? (rest numbers)) numbers]\n    [else\
    \ (cons (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n",
  "  (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        \
    \  (list (car numbers))\n          (cons (car numbers) (cons delimeter (intersperse\
    \ (cdr numbers) delimeter))))))\n", "  (cond\n    [(empty? numbers) (list)]\n\
    \    [(rest numbers)\n     (list (first numbers) delimeter (intersperse (rest\
    \ numbers) delimeter))]\n    [else numbers]))\n", "  (cond [(empty? numbers) empty]\n\
    \        [(empty? (rest numbers)) numbers]\n        [else (cons (first numbers)\
    \ (cons delimeter (intersperse (rest numbers) delimeter)))]))\n", "  (if (null?\
    \ numbers)\n      '()\n      (list (car numbers) delimeter (intersperse (cdr numbers)\
    \ delimeter))))\n", "  (cond\n    ((empty? numbers) (list))\n    ((empty? (rest\
    \ numbers)) (list (first numbers)))\n    (else (cons (first numbers) (cons delimeter\
    \ (intersperse (rest numbers) delimeter))))))\n", "  (cond [(empty? numbers) '()]\n\
    \        [(null? (rest numbers)) numbers]\n        [else (cons (first numbers)\n\
    \                    (cons delimeter\n                          (intersperse (rest\
    \ numbers) delimeter)))]))\n", "  (if (null? numbers)\n      numbers\n      (cons\
    \ (car numbers)\n            (cons delimeter\n                  (intersperse (cdr\
    \ numbers) delimeter)))))\n", "  (define (inner-intersperse numbers acc)\n   \
    \ (if (not (or (null? numbers)\n                 (null? (cdr numbers))))\n   \
    \     (inner-intersperse (cdr numbers) (append acc (list (car numbers) delimeter)))\n\
    \        (append acc numbers)))\n  (inner-intersperse numbers (list)))\n", " \
    \ (cond\n    [(empty? numbers) (list)]\n    [(not (empty? (rest numbers)))\n \
    \    (cons (first numbers)\n           (cons delimeter\n                 (intersperse\
    \ (rest numbers) delimeter)))]\n    [else numbers]))\n", "  (define (recursive\
    \ numbers delimeter result)\n    (cond\n      [(null? numbers) result]\n     \
    \ [(null? (cdr numbers)) (append result (list (car numbers)))]\n      [else (recursive\
    \ (cdr numbers) delimeter (append result (list (car numbers) delimeter)))]))\n\
    \  (recursive numbers delimeter (list)))\n```\n\n```#lang racket\n", "  (match\
    \ numbers\n    [(list) '()]\n    [(list x xs)\n     (append (list x delimeter)\n\
    \             (intersperse xs delimeter))]))\n", "  (cond\n    [(empty? numbers)\
    \ (list)]\n    [(empty? (rest numbers)) (list (first numbers))]\n    [else (cons\
    \ (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n",
  "  (if (null? numbers)\n      (list)\n      (append (list (car numbers))\n     \
    \         (list delimeter)\n              (intersperse (cdr numbers) delimeter))))",
  "  (let loop ([first (first numbers)]\n             [rest (rest numbers)])\n   \
    \ (if (null? rest)\n        (list first)\n        (cons first (cons delimeter\
    \ (loop (first rest) (rest rest)))))))\n", "  (if (empty? numbers)\n      (list)\n\
    \      (cons (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))))\n",
  "  (if (empty? numbers)\n      numbers\n      (if (rest numbers)\n          (append\
    \ (list (first numbers) delimeter) (intersperse (rest numbers) delimeter))\n \
    \         numbers)\n      )\n  )\n</code>\n", "  (define (inner accu first)\n\
    \    (cond\n      [(null? first) (reverse accu)]\n      [(null? (cdr first)) (inner\
    \ (cons (car first) accu) (cdr first))]\n      [else (inner (cons (car first)\
    \ (cons delimeter accu)) (cdr first))]))\n  (inner (list) numbers))\n", "  (if\
    \ (null? numbers)\n      (list)\n      (cons (car numbers) (cons delimeter (intersperse\
    \ (cdr numbers) delimeter)))))", "  (cond\n    [(empty? numbers) empty]\n    [(rest\
    \ numbers) (cons (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]\n\
    \    [else numbers]))\n", "  (letrec\n      ;; go: Takes a list of numbers, a\
    \ list for intermediate results and a delimeter.\n      ;; Insert the delimeter\
    \ after every element of input list and return the result.\n      [(define (go\
    \ numbers partial-result delimeter)\n         (cond\n           [(empty? numbers)\
    \ reverse partial-result]\n           [else (go (rest numbers) (cons delimeter\
    \ (cons (first numbers) partial-result)) delimeter)]))]\n    (go numbers empty\
    \ delimeter)))\n", "  (cond [(null? numbers) null]\n        [(null? (cdr numbers))\
    \ numbers]\n        [else (cons (car numbers) (cons delimeter (intersperse (cdr\
    \ numbers) delimeter)))]))\n", "  (let recur ((numbers numbers)\n\t      (acc\
    \ '()))\n    (cond ((null? numbers) (reverse acc))\n\t  (else (recur (cdr numbers)\
    \ (cons (car numbers) (cons delimeter acc)))))))\n", "  (match numbers\n    [(list)\
    \ (list)]\n    [(list hd tl) (cons hd (cons delimeter (intersperse tl delimeter)))]))\n",
  "  (define (inter inters numbers)\n    (if (null? numbers)\n        inters\n   \
    \     (inter (append inters (list delimeter (car numbers))) (cdr numbers))))\n\
    \  (if (null? numbers)\n      (list)\n      (inter (list (car numbers)) (cdr numbers))))\n",
  "    (define (n-d n d)\n        (if (null? (cdr n))\n            (list n)\n    \
    \        (append (list n d) (n-d (cadr n) d))))\n    (append (n-d (car numbers)\
    \ delimeter) (intersperse (cdr numbers) delimeter)))\n", "  (if (null? numbers)\n\
    \      '()\n      (cons (car numbers)\n            (cons delimeter\n         \
    \         (intersperse (cdr numbers) delimeter)))))\n", "  (if (null? numbers)\n\
    \      (list)\n      (if (null? (cdr numbers))\n          (list (car numbers))\n\
    \          (cons (car numbers)\n                (cons delimeter\n            \
    \          (intersperse (cdr numbers) delimeter))))))\n", "  (if (empty? numbers)\n\
    \      (list)\n      (if (empty? (rest numbers))\n          (list (first numbers))\n\
    \          (cons (first numbers)\n                (cons delimeter\n          \
    \            (intersperse (rest numbers) delimeter))))))\n```\n\n```racket\n#lang\
    \ racket\n", "  (define (aux ns res)\n    (if (null? ns)\n        res\n      \
    \  (aux (cdr ns) (append res (list (car ns) delimeter)))))\n  (if (null? numbers)\n\
    \      numbers\n      (let ([n (car numbers)])\n        (append (aux (cdr numbers)\
    \ (list n)) (list)))))\n", "  (if (null? numbers)\n      '()\n      (if (null?\
    \ (cdr numbers))\n          numbers\n          (append (list (car numbers) delimeter)\
    \ (intersperse (cdr numbers) delimeter)))))\n", "  (if (null? numbers)\n     \
    \ (list)\n      (cons (car numbers)\n            (cons delimeter\n           \
    \       (intersperse (cdr numbers) delimeter)))))\n```\n\n### Zipping and unzipping\n\
    ```racket\n#lang racket\n", "  (cond [(empty? numbers) empty]\n        [(empty?\
    \ (rest numbers)) numbers]\n        [else (cons (first numbers)\n            \
    \        (cons delimeter\n                          (intersperse (rest numbers)\
    \ delimeter)))]))\n", "  (define (intersperse-inner acc lst)\n    (cond ((empty?\
    \ lst) (reverse acc))\n          ((empty? (rest lst)) (intersperse-inner (cons\
    \ (first lst) acc) (rest lst)))\n          (else (intersperse-inner (cons (first\
    \ lst) (cons delimeter acc)) (rest lst)))))\n  (intersperse-inner '() numbers))\n",
  "  (let ([first (car numbers)]\n        [rest (cdr numbers)])\n    (cond [(empty?\
    \ numbers) empty]\n          [(empty? rest) numbers]\n          [else (append\
    \ (list first delimeter) (intersperse rest delimeter))])))\n", "  (cond [(empty?\
    \ numbers) empty]\n        [(rest numbers)\n         (cons (first numbers)\n \
    \              (cons delimeter\n                     (intersperse (rest numbers)\
    \ delimeter)))]\n        [else numbers]))\n", "  (cond\n    [(null? numbers) (list)]\n\
    \    [(not (null? (cdr numbers)))\n     (cons (car numbers) (cons delimeter (intersperse\
    \ (cdr numbers) delimeter)))]\n    [else numbers]))\n", "  (apply (lambda (n .\
    \ ns)\n           (cond [(empty? ns) (list n)]\n                 [else (cons n\
    \ (cons delimeter (intersperse ns delimeter)))]))\n         numbers))\n", "  (cond\
    \ [(empty? numbers) (list)]\n        [(empty? (rest numbers)) (list (first numbers))]\n\
    \        [else (cons (first numbers) (cons delimeter (intersperse (rest numbers)\
    \ delimeter)))]))\n", "  (cond [(empty? numbers) empty]\n        [(rest numbers)\
    \ (append (list (first numbers) delimeter)\n                                (intersperse\
    \ (rest numbers) delimeter))]\n        [else numbers]))\n", "  (cond\n    [(empty?\
    \ numbers) empty]\n    [(empty? (rest numbers)) (list (first numbers))]\n    [else\
    \ (cons (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n",
  "  (match numbers\n    [() '()]\n    [(cons first (cons second rest)) (cons first\
    \ (cons delimeter (cons second (intersperse rest delimeter))))]\n    [_ '()]))\n",
  "  (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        \
    \  (list (car numbers))\n          (cons (car numbers) (cons delimeter (intersperse\
    \ (cdr numbers) delimeter))))))\n", "  (match numbers\n    [(list) '()]\n    [(list\
    \ x xs)\n     (cons x (cons delimeter (intersperse xs delimeter)))]))\n```\n\n\
    ---\n\n### Quicksort\n\n[Quicksort](https://en.wikipedia.org/wiki/Quicksort) is\
    \ a **divide and conquer** algorithm used for sorting.\nIt can sort in **_O(n\
    \ log n)_** time in the average case and **_O(n^2)_** time in the worst case.\
    \ The performance depends\non the choice of the pivot element.\n\nThe algorithm\
    \ works by partitioning the array into two sub-arrays around a pivot element,\
    \ where\nall elements of the left sub-array are less than or equal to the pivot\
    \ and all elements of the right sub-array are\ngreater than or equal to the pivot.\
    \ Then the algorithm partitions the left and right sub-arrays recursively until\n\
    there are no more sub-arrays to partition.\n\n\n---\n\n**The quicksort algorithm\
    \ (recursive) in Racket**\n\n```#lang racket\n", "  (cond [(empty? numbers) '()]\n\
    \        [(empty? (rest numbers)) numbers]\n        [else (cons (first numbers)\n\
    \                    (cons delimeter\n                          (intersperse (rest\
    \ numbers) delimeter)))]))\n", "  (if (null? numbers)\n      '()\n      (cond\n\
    \        ((null? (cdr numbers)) (list (car numbers)))\n        (else (cons (car\
    \ numbers) (cons delimeter (intersperse (cdr numbers) delimeter)))))))\n", " \
    \ (cond ((null? numbers) (list ))\n        ((null? (cdr numbers)) numbers)\n \
    \       (else (cons (car numbers) (cons delimeter (intersperse (cdr numbers) delimeter))))))\n",
  "  (cond [(null? numbers) '()]\n        [(null? (cdr numbers)) numbers]\n      \
    \  [else (cons (car numbers)\n                    (cons delimeter\n          \
    \                (intersperse (cdr numbers) delimeter)))]))\n", "  (define (rec\
    \ numbers result)\n    (if (empty? numbers)\n      result\n      (rec (rest numbers)\
    \ (append result (list (first numbers) delimeter)))))\n  (rec numbers (list)))\n",
  "    (define (f numbers result)\n        (cond [(empty? numbers) (reverse result)]\n\
    \              [else (f (rest numbers) (cons (first numbers) (cons delimeter result)))]))\n\
    \    (reverse (cdr (f numbers '()))))\n\n", "  (if (empty? numbers)\n      (list)\n\
    \      (match (cons (first numbers) (cons delimeter (intersperse (rest numbers)\
    \ delimeter)))\n             [(list a b c)\n              (if (empty? c)\n   \
    \               (list a)\n                  (list a b c))])))\n", "  (let loop\
    \ ([numbers numbers]\n             [result null])\n    (cond\n      [(empty? numbers)\
    \ (reverse result)]\n      [(empty? (rest numbers))\n       (reverse (cons (first\
    \ numbers) result))]\n      [else\n       (loop (rest numbers)\n             (cons\
    \ (first numbers)\n                   (cons delimeter result)))])))\n", "  (let\
    \ loop ((numbers numbers) (accumulator '()))\n    (if (null? numbers)\n      \
    \  accumulator\n        (loop (cdr numbers)\n              (cons (car numbers)\n\
    \                    (cons delimeter\n                          accumulator))))))\n",
  "  (cond\n    [(empty? numbers) empty]\n    [(rest numbers) (cons (first numbers)\
    \ (cons delimeter (intersperse (rest numbers) delimeter)))]\n    [else numbers]))\n",
  "  (cond\n    [(null? numbers) '()]\n    [(empty? (rest numbers)) numbers]\n   \
    \ [else (cons (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n",
  "  (apply append\n         (map (\u03BB (x) (list x delimeter))\n              (butlast\
    \ numbers))))\n", "  (if (null? numbers)\n      (list)\n      (if (null? (cdr\
    \ numbers))\n          (list (car numbers))\n          (cons (car numbers)\n \
    \               (cons delimeter\n                      (intersperse (cdr numbers)\
    \ delimeter))))))", "  (define (inter xs d acc)\n    (cond\n      [(empty? xs)\
    \ (reverse acc)]\n      [(empty? (rest xs)) (reverse (cons d (cons (first xs)\
    \ acc)))]\n      [else (inter (rest xs) d (cons d (cons (first xs) acc)))]))\n\
    \  (inter numbers delimeter empty))\n", "  (local [(define (accumulate numbers\
    \ delimeter result)\n            (cond [(empty? numbers) result]\n           \
    \       [else (accumulate (rest numbers) delimeter (append result (list (first\
    \ numbers) delimeter)))]))]\n    (accumulate numbers delimeter (list))))\n", " \
    \ (cond\n    [(empty? numbers) empty]\n    [(empty? (rest numbers)) numbers]\n\
    \    [else (cons (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n",
  "  (cond\n    [(null? numbers) '()]\n    [(null? (cdr numbers)) numbers]\n    [else\
    \ (append (list (car numbers) delimeter) (intersperse (cdr numbers) delimeter))]))\n",
  "  (cond [(empty? numbers) (list)]\n        [(= (length numbers) 1) numbers]\n \
    \       [else (append (list (first numbers) delimeter) (intersperse (rest numbers)\
    \ delimeter))]))\n", "  (if (null? numbers)\n      (list)\n      (if (null? (cdr\
    \ numbers))\n          (list (car numbers))\n          (cons (car numbers) (cons\
    \ delimeter (intersperse (cdr numbers) delimeter))))))\n", "    (cond ((null?\
    \ numbers) (list))\n          ((= (length numbers) 1) numbers)\n          (else\
    \ (cons (car numbers) (cons delimeter (intersperse (cdr numbers) delimeter))))))\n",
  "  (if (null? numbers)\n      '()\n      (cons (car numbers) (cons delimeter (intersperse\
    \ (cdr numbers) delimeter)))))\n", "  (cond ((null? numbers) (list ))\n      \
    \  ((null? (cdr numbers)) numbers)\n        (else (cons (car numbers) (cons delimeter\
    \ (intersperse (cdr numbers) delimeter))))))\n```\n\n#### merge\n\n```#lang racket\n",
  "  (match numbers\n    [(list) (list)]\n    [(list first-number rest-numbers)\n\
    \     (cons first-number\n           (cons delimeter\n                 (intersperse\
    \ rest-numbers delimeter)))]))\n", "  (cond [(empty? numbers) empty]\n       \
    \ [(empty? (rest numbers)) numbers]\n        [else (cons (first numbers)\n   \
    \                 (cons delimeter\n                          (intersperse (rest\
    \ numbers) delimeter)))]))\n", "  (cond ((null? numbers) '())\n        ((null?\
    \ (cdr numbers)) numbers)\n        (else (cons (car numbers)\n               \
    \     (cons delimeter\n                          (intersperse (cdr numbers) delimeter))))))\n",
  "  (if (empty? numbers)\n      (list)\n      (if (empty? (rest numbers))\n     \
    \     (list (first numbers))\n          (append (list (first numbers) delimeter)\
    \ (intersperse (rest numbers) delimeter)))))\n", "  (define (intersperse-list\
    \ n d)\n    (if (null? n)\n      (list)\n      (if (null? (cdr n))\n        (list\
    \ (car n))\n        (cons (car n) (cons d (intersperse-list (cdr n) d))))))\n\
    \  (intersperse-list numbers delimeter))\n```\n\n13.13: intersperse\n\n```racket\n\
    #lang racket\n", "  (cond\n    [(empty? numbers) (list)]\n    [(rest numbers)\n\
    \     (cons (first numbers)\n           (cons delimeter\n                 (intersperse\
    \ (rest numbers) delimeter)))]\n    [else numbers]))\n```\n\n```racket\n#lang\
    \ racket\n", "  (cond ((empty? numbers) empty)\n        ((empty? (rest numbers))\
    \ numbers)\n        (else (cons (first numbers) (cons delimeter (intersperse (rest\
    \ numbers) delimeter))))))\n", "  (cond [(empty? numbers) empty]\n        [(empty?\
    \ (rest numbers)) numbers]\n        [else (cons (first numbers) (cons delimeter\
    \ (intersperse (rest numbers) delimeter)))]))\n", "  (cond\n    [(empty? numbers)\
    \ empty]\n    [(empty? (rest numbers)) numbers]\n    [else (cons (first numbers)\
    \ (cons delimeter (intersperse (rest numbers) delimeter)))]))\n", "  (if (null?\
    \ numbers)\n      (list)\n      (if (null? (cdr numbers))\n          (list (car\
    \ numbers))\n          (cons (car numbers) (cons delimeter (intersperse (cdr numbers)\
    \ delimeter))))))\n", "  (if (empty? numbers)\n      (list)\n      (let* ((n (first\
    \ numbers))\n             (nn (rest numbers)))\n        (cons n (if (empty? nn)\n\
    \                    (list)\n                    (cons delimeter (intersperse\
    \ nn delimeter)))))))\n", "  (if (null? numbers)\n      numbers\n      (if (null?\
    \ (cdr numbers))\n          numbers\n          (cons (car numbers)\n         \
    \       (cons delimeter\n                      (intersperse (cdr numbers) delimeter))))))\n",
  "  (if (null? numbers)\n      (list)\n      (let ((inits (butlast numbers))\n  \
    \          (last (last numbers)))\n        (if (null? inits)\n            (list\
    \ last)\n            (append inits (list delimeter last))))))\n", "  (match numbers\
    \ [(list) (list)]\n                [(list first second . rest)\n             \
    \    (cons first (cons delimeter (intersperse (cons second rest) delimeter)))]))\n",
  "  (if (empty? numbers)\n      '()\n      (cons (first numbers)\n            (cons\
    \ delimeter\n                  (intersperse (rest numbers) delimeter)))))\n",
  "  (cond ((null? numbers) null)\n        ((null? (cdr numbers)) numbers)\n     \
    \   (else (cons (car numbers) (cons delimeter (intersperse (cdr numbers) delimeter))))))\n",
  "  (if (null? numbers)\n      (list)\n      (cons (car numbers)\n            (cons\
    \ delimeter\n                  (intersperse (cdr numbers) delimeter)))))\n", " \
    \ (cond\n    [(empty? numbers) empty]\n    [(equal? (length numbers) 1) numbers]\n\
    \    [else (append (list (first numbers) delimeter) (intersperse (rest numbers)\
    \ delimeter))]))\n", "  (cond [(empty? numbers) empty]\n        [(rest numbers)\
    \ (cons (first numbers)\n                              (cons delimeter\n     \
    \                               (intersperse (rest numbers) delimeter)))]\n  \
    \      [else numbers]))\n", "  (cond\n    [(empty? numbers) empty]\n    [(empty?\
    \ (rest numbers)) numbers]\n    [else (cons (first numbers) (cons delimeter (intersperse\
    \ (rest numbers) delimeter)))]))\n", "  (if (null? numbers)\n      (list)\n  \
    \    (if (null? (cdr numbers))\n          (list (car numbers))\n          (cons\
    \ (car numbers) (cons delimeter (intersperse (cdr numbers) delimeter))))))\n```\n\
    \n```#lang racket\n", "  (cond\n    [(empty? numbers) (list)]\n    [(empty? (rest\
    \ numbers)) (list (first numbers))]\n    [else (cons (first numbers) (cons delimeter\
    \ (intersperse (rest numbers) delimeter)))]))\n", "  (cond [(empty? numbers) (list)]\n\
    \        [(empty? (rest numbers)) (list (first numbers))]\n        [else (cons\
    \ (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n",
  "  (cond\n    [(empty? numbers) empty]\n    [(empty? (rest numbers)) numbers]\n\
    \    [else (cons (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n",
  "  (match numbers\n    ['() '()]\n    [(cons a '()) (list a)]\n    [(cons a (cons\
    \ b rest)) (list a delimeter (intersperse (cons b rest) delimeter))]))\n", " \
    \ (cond [(empty? numbers) empty]\n        [(empty? (rest numbers)) numbers]\n\
    \        [else (cons (first numbers) (cons delimeter (intersperse (rest numbers)\
    \ delimeter)))]))\n", "  (cond\n    [(empty? numbers) empty]\n    [(empty? (rest\
    \ numbers)) numbers]\n    [else (cons (first numbers) (cons delimeter (intersperse\
    \ (rest numbers) delimeter)))]))\n```\n\n```racket\n#lang racket\n", "  (if (empty?\
    \ numbers)\n      (list)\n      (if (empty? (rest numbers))\n          (list (first\
    \ numbers))\n          (cons (first numbers)\n                (cons delimeter\n\
    \                      (intersperse (rest numbers) delimeter))))))\n", "  (if\
    \ (null? numbers) '()\n    (cons (car numbers) (append (list delimeter) (intersperse\
    \ (cdr numbers) delimeter)))))\n", "  (cond\n    [(empty? numbers) '()]\n    [(empty?\
    \ (rest numbers)) (list (first numbers))]\n    [else (list (first numbers) delimeter\
    \ (intersperse (rest numbers) delimeter))]))\n", "  (match numbers\n    [() ()]\n\
    \    [(cons head tail) (cons head (cons delimeter (intersperse tail delimeter)))]))\n",
  "    (if (null? numbers)\n        '()\n        (cons (car numbers) (cons delimeter\
    \ (intersperse (cdr numbers) delimeter)))))\n", "  (if (or (null? numbers) (null?\
    \ (cdr numbers)))\n      numbers\n      (cons (car numbers) (cons delimeter (intersperse\
    \ (cdr numbers) delimeter)))))\n", "  (cond ((null? numbers) '())\n        ((null?\
    \ (cdr numbers)) numbers)\n        (else (cons (car numbers) (cons delimeter (intersperse\
    \ (cdr numbers) delimeter))))))\n", "  (cond [(empty? numbers) (list)]\n     \
    \   [(= (length numbers) 1) numbers]\n        [else (append (list (first numbers)\
    \ delimeter) (intersperse (rest numbers) delimeter))]))\n", "  (if (empty? numbers)\n\
    \      (list)\n      (cons (first numbers)\n            (cons delimeter\n    \
    \              (intersperse (rest numbers) delimeter)))))\n", "  (cond\n    [(empty?\
    \ numbers) (list)]\n    [(empty? (rest numbers)) (list (first numbers))]\n   \
    \ [else (cons (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n",
  "  (apply append\n         (map (lambda (a b) (list a delimeter b)) numbers (rest\
    \ numbers))))\n", "  (if (null? numbers)\n      '()\n      (cons (car numbers)\n\
    \            (cons delimeter\n                  (intersperse (cdr numbers) delimeter)))))\n",
  "  (cond [(empty? numbers) (list)]\n        [(empty? (rest numbers)) (list (first\
    \ numbers))]\n        [else (cons (first numbers)\n                    (cons delimeter\n\
    \                          (intersperse (rest numbers) delimeter)))]))\n```\n\n\
    #### `map`\n\n```#lang racket\n", "  (cond\n    [(null? numbers) '()]\n    [(cons?\
    \ numbers)\n     (cond\n       [(null? (cdr numbers)) numbers]\n       [else (cons\
    \ (car numbers) (cons delimeter (intersperse (cdr numbers) delimeter)))]\n   \
    \    )]\n    [else '()]\n    )\n  )\n", "  (cond ((null? numbers) '())\n     \
    \   ((null? (cdr numbers)) numbers)\n        (else (append (list (car numbers)\
    \ delimeter)\n                      (intersperse (cdr numbers) delimeter)))))\n",
  "  (define helper (lambda (numbers delimeter)\n    (cond\n      [(empty? numbers)\
    \ '()]\n      [(empty? (rest numbers)) numbers]\n      [else (cons (first numbers)\
    \ (cons delimeter (helper (rest numbers) delimeter)))])))\n  (if (empty? numbers)\n\
    \    '()\n    (helper numbers delimeter)))\n", "  (cond\n    [(null? numbers)\
    \ '()]\n    [(null? (cdr numbers)) (list (car numbers))]\n    [else (cons (car\
    \ numbers) (cons delimeter (intersperse (cdr numbers) delimeter)))]))\n", "  (cond\n\
    \    [(empty? numbers) empty]\n    [(empty? (rest numbers)) numbers]\n    [else\
    \ (cons (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n",
  "  (cond [(empty? numbers) empty]\n        [(empty? (rest numbers)) (list (first\
    \ numbers))]\n        [else (cons (first numbers) (cons delimeter (intersperse\
    \ (rest numbers) delimeter)))]))\n", "  (cond\n    [(empty? numbers) '()]\n  \
    \  [(empty? (rest numbers)) (list (first numbers))]\n    [else (cons (first numbers)\
    \ (cons delimeter (intersperse (rest numbers) delimeter)))]))\n", "  (cond [(empty?\
    \ numbers) '()]\n        [(empty? (rest numbers)) numbers]\n        [else (cons\
    \ (first numbers)\n                    (cons delimeter\n                     \
    \     (intersperse (rest numbers) delimeter)))]))\n", "  (if (empty? numbers)\n\
    \      numbers\n      (cons (first numbers)\n            (append (list delimeter)\n\
    \                    (intersperse (rest numbers) delimeter)))))\n", "  (cond [(null?\
    \ numbers) '()]\n        [(null? (cdr numbers)) numbers]\n        [else (list\
    \ (car numbers) delimeter (intersperse (cdr numbers) delimeter))]))\n", "  (cond\n\
    \    [(empty? numbers) '()]\n    [(empty? (rest numbers)) '()]\n    [else (cons\
    \ (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n",
  "  (foldl (lambda (el acc) (append acc (list delimeter el))) (list) numbers))\n",
  "  (define (interpair l)\n    (if (null? l)\n        l\n        (if (null? (cdr\
    \ l))\n            l\n            (cons (car l) (cons delimeter (interpair (cdr\
    \ l)))))))\n  (interpair numbers))\n", "  (if (null? numbers)\n      (list)\n\
    \      (if (null? (cdr numbers))\n          (list (car numbers))\n          (cons\
    \ (car numbers) (cons delimeter (intersperse (cdr numbers) delimeter))))))\n",
  "  (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        \
    \  (list (car numbers))\n          (append (list (car numbers) delimeter)\n  \
    \                (intersperse (cdr numbers) delimeter)))))\n", "  (define (helper\
    \ lst acc)\n    (if (empty? lst)\n        acc\n        (helper (rest lst) (append\
    \ acc (list (first lst) delimeter)))))\n  (take (sub1 (length (helper numbers\
    \ empty))) (helper numbers empty)))\n", "  (match numbers\n    [(cons a (cons\
    \ b xs)) (cons a (cons delimeter (intersperse (cons b xs) delimeter)))]\n    [(cons\
    \ a '()) (list a)]\n    [_ (list )]))\n", "  (cond ((empty? numbers) '())\n  \
    \      ((singleton? numbers) numbers)\n        (else (list (first numbers)\n \
    \                   delimeter\n                    (intersperse (rest numbers)\
    \ delimeter)))))\n", "  (if (empty? numbers)\n      '()\n      (cons (first numbers)\n\
    \            (cons delimeter\n                  (intersperse (rest numbers) delimeter)))))\n",
  "  (cond\n    [(empty? numbers) '()]\n    [(empty? (rest numbers)) numbers]\n  \
    \  [else (cons (first numbers) (cons delimeter (intersperse (rest numbers) delimeter)))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
