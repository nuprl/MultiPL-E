name: HumanEval_118_get_closest_vowel
language: rkt
prompt: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
  \ vowel that stands between \n;; two consonants from the right side of the word\
  \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
  \ empty string if you didn't\n;; find any vowel met the above condition. \n;; You\
  \ may assume that the given string contains English letter only.\n;; Example:\n\
  ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"FULL\"\
  )\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
  \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
  \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"\
  full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
  \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
  \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n  \
  \  (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\")\
  \ \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
  \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
  \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
completions: ["  (define (consonant? c)\n    (member c (list #\\B #\\C #\\D #\\F #\\\
    G #\\H #\\J #\\K #\\L #\\M #\\N #\\P #\\Q #\\R #\\S #\\T #\\V #\\W #\\X #\\Y #\\\
    Z)))\n  (define (is-vowel c)\n    (member c (list #\\A #\\E #\\I #\\O #\\U)))\n\
    \  (define (find-vowel lst)\n    (cond [(null? lst) #f]\n          [(is-vowel\
    \ (car lst)) (car lst)]\n          [else (find-vowel (cdr lst))]))\n  (define\
    \ (get-consonants lst)\n    (cond [(null? lst) '()]\n          [(consonant? (car\
    \ lst)) (cons (car lst) (get-consonants (cdr lst)))]\n          [else '()]))\n\
    \  (define (tail-of lst n)\n    (cond [(null? lst) '()]\n          [(zero? n)\
    \ lst]\n          [else (tail-of (cdr lst) (- n 1))]))\n  (define (find-last-two-consonants\
    \ lst)\n    (cond [(null? lst) '()]\n          [(null? (cdr lst)) '()]\n     \
    \     [(consonant? (car lst)) (cons (car lst) (cons (cadr lst) '()))]\n      \
    \    [else (find-last-two-consonants (cdr lst))]))\n  (cond [(null? word) '()]\n\
    \        [(or (null? (cdr word)) (null? (cddr word))) '()]\n        [(and (consonant?\
    \ (car word)) (consonant? (cadr word))) (find-vowel (cdr word))]\n        [else\
    \ (get_closest_vowel (cdr word))]))\n", "  (define (next-consonant word i)\n \
    \   (if (&lt; i 0) -1\n        (if (member (string-ref word i) '(\"a\" \"e\" \"\
    i\" \"o\" \"u\"))\n            (next-consonant word (- i 1))\n            i)))\n\
    \  (define (next-vowel word i)\n    (if (&gt;= i (string-length word)) (- 1)\n\
    \        (if (member (string-ref word i) '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n \
    \           i\n            (next-vowel word (+ i 1)))))\n  (define (get-vowel\
    \ word i)\n    (if (&lt;= i 0) \"\"\n        (string-ref word i)))\n  (let ([n-consonant\
    \ (next-consonant word (- (string-length word) 1))]\n        [n-vowel (next-vowel\
    \ word (+ n-consonant 1))])\n    (get-vowel word (- n-vowel 1))))\n</code>\n",
  "  (define vowels (list #\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))\n  (define\
    \ (find-vowel word left right)\n    (cond\n      [(empty? (rest word)) \"\"]\n\
    \      [(consonant? (first word))\n       (find-vowel (rest word) (cons (first\
    \ word) left) right)]\n      [(consonant? (second word))\n       (cons (first\
    \ word) left)]\n      [else (find-vowel (rest word) left right)]))\n  (find-vowel\
    \ word '() '()))\n", "  (define (get-vowel-positions-from str)\n    (filter\n\
    \     (lambda (x) (and (not (char=? (string-ref str x) #\\a))\n              \
    \      (not (char=? (string-ref str x) #\\e))\n                    (not (char=?\
    \ (string-ref str x) #\\i))\n                    (not (char=? (string-ref str\
    \ x) #\\o))\n                    (not (char=? (string-ref str x) #\\u))))\n  \
    \   (build-list (string-length str) (lambda (i) i))))\n  (define (get-consonant-positions-from\
    \ str)\n    (filter\n     (lambda (x) (or (char=? (string-ref str x) #\\a)\n \
    \                    (char=? (string-ref str x) #\\e)\n                     (char=?\
    \ (string-ref str x) #\\i)\n                     (char=? (string-ref str x) #\\\
    o)\n                     (char=? (string-ref str x) #\\u)))\n     (build-list\
    \ (string-length str) (lambda (i) i))))\n  (define (build-list number f)\n   \
    \ (if (= number 0)\n        '()\n        (cons (f (- number 1)) (build-list (-\
    \ number 1) f))))\n  (define (get-closest-vowel-positions-from str)\n    (define\
    \ (get-closest-position n)\n      (if (= n (- (string-length str) 1))\n      \
    \    (- (string-length str) 1)\n          (if (or (char=? (string-ref str n) #\\\
    a)\n                  (char=? (string-ref str n) #\\e)\n                  (char=?\
    \ (string-ref str n) #\\i)\n                  (char=? (string-ref str n) #\\o)\n\
    \                  (char=? (string-ref str n) #\\u))\n              n\n      \
    \        (get-closest-position (+ n 1)))))\n    (filter\n     (lambda (x) (not\
    \ (= (get-closest-position (+ x 1)) (", "  (cond\n    [(empty? word) empty]\n\
    \    [(and (equal? (list-ref word -1) #\\a)\n\t  (member (list-ref word -2) (list\
    \ #\\s #\\t #\\w)))\n     \"a\"]\n    [(and (equal? (list-ref word -1) #\\e)\n\
    \t  (member (list-ref word -2) (list #\\s #\\t #\\w)))\n     \"e\"]\n    [(and\
    \ (equal? (list-ref word -1) #\\i)\n\t  (member (list-ref word -2) (list #\\s\
    \ #\\t #\\w)))\n     \"i\"]\n    [(and (equal? (list-ref word -1) #\\o)\n\t  (member\
    \ (list-ref word -2) (list #\\s #\\t #\\w)))\n     \"o\"]\n    [(and (equal? (list-ref\
    \ word -1) #\\u)\n\t  (member (list-ref word -2) (list #\\s #\\t #\\w)))\n   \
    \  \"u\"]\n    [else (get_closest_vowel (substring word 0 -1))]))\n", "  (cond\
    \ [(empty? word) '()]\n        [(member (first word) '(\"a\" \"e\" \"i\" \"o\"\
    \ \"u\"))\n         (list (first word))]\n        [else (get_closest_vowel (rest\
    \ word))]))\n", "  (if (not (or (member \"a\" word) (member \"e\" word) (member\
    \ \"i\" word) (member \"o\" word) (member \"u\" word)))\n      \"\"\n      (cond\
    \ ((member \"a\" word) (find-pos word \"a\"))\n            ((member \"e\" word)\
    \ (find-pos word \"e\"))\n            ((member \"i\" word) (find-pos word \"i\"\
    ))\n            ((member \"o\" word) (find-pos word \"o\"))\n            ((member\
    \ \"u\" word) (find-pos word \"u\")))))\n  )\n", "  (define (get-vowel word len)\n\
    \    (if (or (<= len 1) (= len (string-length word)))\n        \"\"\n        (let*\
    \ ([prev (string-ref word (- len 1))]\n               [next (string-ref word len)])\n\
    \          (if (and (consonant? prev) (consonant? next))\n              (let*\
    \ ([curr (string-ref word (- len 2))])\n                (if (vowel? curr) curr\
    \ (get-vowel word (- len 1))))\n              (get-vowel word (- len 1))))))\n\
    \  (get-vowel word (string-length word)))\n", "  (if (or (empty? word) (string=?\
    \ \"\" word))\n      \"\"\n      (if (string-contains-char? (last-word word) \"\
    aeiouAEIOU\")\n          (last-word word)\n          (if (string-contains-char?\
    \ (second-to-last-word word) \"aeiouAEIOU\")\n              (second-to-last-word\
    \ word)\n              (get_closest_vowel (trim word))))))\n", "  (define vowel?\n\
    \    (lambda (c)\n      (member c '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\"\
    \ \"I\" \"O\" \"U\"))))\n  (define pos\n    (lambda (word)\n      (let lp ((i\
    \ (string-length word)) (flag 0))\n        (cond\n          ((zero? i) (if (zero?\
    \ flag) -1 (sub1 i)))\n          ((and (= flag 0) (vowel? (string-ref word (sub1\
    \ i)))) (lp (sub1 i) 1))\n          ((and (= flag 1) (not (vowel? (string-ref\
    \ word (sub1 i))))) (sub1 i))\n          (else (lp (sub1 i) flag))))))\n  (let\
    \ ((x (pos word)))\n    (if (< x 0) \"\" (string-ref word x))))\n", "  (define\
    \ (is_vowel? letter)\n    (member letter '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E\
    \ #\\I #\\O #\\U)))\n  (define (consonant? l1 l2)\n    (and (not (is_vowel? l1))\
    \ (not (is_vowel? l2))))\n  (define (distance-from-consonant s)\n    (cond [(empty?\
    \ s) +inf.0]\n          [(consonant? (first s) (second s)) 0]\n          [else\
    \ (+ 1 (distance-from-consonant (rest s)))]))\n  (define (select-closest-vowel\
    \ candidates)\n    (cond [(empty? candidates) #f]\n          [(consonant? (first\
    \ candidates) (second candidates)) (first candidates)]\n          [else (select-closest-vowel\
    \ (rest candidates))]))\n  (define vowels (filter is-vowel? word))\n  (let ([closest-vowel\
    \ (select-closest-vowel (sort (map distance-from-consonant vowels) <))])\n   \
    \ (if closest-vowel (string closest-vowel) \"\")))\n```\n#### Challenging\n#####\
    \ 1. Extracting a sequence from a text file\n##### 1.1. Using the `string-lines`\
    \ function\n```#lang racket\n", "  (if (or (empty? word) (empty? (rest word)))\n\
    \      \"\"\n      (cond [(or (= (last word) #\\a) (= (last word) #\\e) (= (last\
    \ word) #\\i) (= (last word) #\\o) (= (last word) #\\u))\n             (last word)]\n\
    \            [(and (not (is_vowel? (first word))) (is_vowel? (last word)))\n \
    \            (last word)]\n            [else\n             (get_closest_vowel\
    \ (rest word))])))\n", "  (if (= 0 (string-length word))\n      (display \"\"\
    )\n      (if (or (string=? \"a\" (substring word (- (string-length word) 1) (string-length\
    \ word)))\n              (string=? \"e\" (substring word (- (string-length word)\
    \ 1) (string-length word)))\n              (string=? \"i\" (substring word (-\
    \ (string-length word) 1) (string-length word)))\n              (string=? \"o\"\
    \ (substring word (- (string-length word) 1) (string-length word)))\n        \
    \      (string=? \"u\" (substring word (- (string-length word) 1) (string-length\
    \ word))))\n          (get_closest_vowel (substring word 0 (- (string-length word)\
    \ 1)))\n          (if (or (string=? \"a\" (substring word (- (string-length word)\
    \ 2) (- (string-length word) 1)))\n                  (string=? \"e\" (substring\
    \ word (- (string-length word) 2) (- (string-length word) 1)))\n             \
    \     (string=? \"i\" (substring word (- (string-length word) 2) (- (string-length\
    \ word) 1)))\n                  (string=? \"o\" (substring word (- (string-length\
    \ word) 2) (- (string-length word) 1)))\n                  (string=? \"u\" (substring\
    \ word (- (string-length word) 2) (- (string-length word) 1))))\n            \
    \  (substring word (- (string-length word) 2) (- (string-length word) 1))\n  \
    \            (display \"\")))))", "  (if (string-empty? word)\n      \"\"\n  \
    \    (if (string-contains word \"aeiouAEIOU\")\n          (get_closest_vowel_helper\
    \ word)\n          \"\")))\n", "  (cond\n    [(empty? word) \"\"]\n    [(or (char=?\
    \ (last word) #\\o)\n         (char=? (last word) #\\a)\n         (char=? (last\
    \ word) #\\i)\n         (char=? (last word) #\\e)\n         (char=? (last word)\
    \ #\\u))\n     (string (last word))]\n    [else (get_closest_vowel (substring\
    \ word 0 (- (string-length word) 1)))]))\n", "  (local ((define (backward word)\n\
    \            (if (or (string=? word \"\")\n                    (string=? (substring\
    \ word 0 1) \"\"))\n                word\n                (backward (substring\
    \ word 1)))))\n    (local ((define (forward word)\n              (if (or (string=?\
    \ word \"\")\n                      (string=? (substring word (sub1 (string-length\
    \ word))) \"\"))\n                  word\n                  (forward (substring\
    \ word 0 (sub1 (string-length word)))))))\n      (cond\n        [(string=? word\
    \ \"\") \"\" ]\n        [(string=? (string-append (backward word) (forward word))\
    \ \"\") \"\" ]\n        [(string=? (backward word) (forward word)) \"\" ]\n  \
    \      [else\n         (cond\n           [(string=? (string-ref (backward word)\
    \ 0) (string-ref (forward word) 0))\n            (backward word)]\n          \
    \ [else (forward word)])]))))\n", "  (define (right-closest word)\n    (if (empty?\
    \ word)\n      '()\n      (cond ((or (char=? (first word) #\\a)\n            \
    \     (char=? (first word) #\\e)\n                 (char=? (first word) #\\i)\n\
    \                 (char=? (first word) #\\o)\n                 (char=? (first\
    \ word) #\\u))\n             (first word))\n            (else (right-closest (rest\
    \ word))))))\n  (let ([closest (right-closest (reverse word))])\n    (if (char?\
    \ closest)\n      (list closest)\n      closest)))\n", "  (define (next-vowel\
    \ w)\n    (local ((define (next-vowel-helper w i)\n              (if (= i (string-length\
    \ w))\n                  \"\"\n                  (if (char-vowel? (string-ref\
    \ w i))\n                      (string-ref w i)\n                      (next-vowel-helper\
    \ w (+ i 1))))))\n      (next-vowel-helper w (string-length w))))\n  (define (char-vowel?\
    \ c)\n    (local ((define (is-vowel? v)\n              (cond [(char=? v #\\A)\
    \ true]\n                    [(char=? v #\\E) true]\n                    [(char=?\
    \ v #\\I) true]\n                    [(char=? v #\\O) true]\n                \
    \    [(char=? v #\\U) true]\n                    [(char=? v #\\a) true]\n    \
    \                [(char=? v #\\e) true]\n                    [(char=? v #\\i)\
    \ true]\n                    [(char=? v #\\o) true]\n                    [(char=?\
    \ v #\\u) true]\n                    [else false])))\n      (is-vowel? c)))\n\
    \  (define (char-consonant? c)\n    (not (char-vowel? c)))\n  (define (char-end?\
    \ c)\n    (or (char-vowel? c)\n        (char-consonant? c)))\n  (define (find-consonant\
    \ word)\n    (define (find-consonant-helper word)\n      (if (and (not (char-end?\
    \ (string-ref word (string-length word))))\n               (char-consonant? (string-ref\
    \ word (string-length word))))\n          (string-append (string-take word (string-length\
    \ word))\n                         (find-consonant-helper (string-drop word (string-length\
    \ word))))\n          word))\n    (find-consonant-helper word))\n  (define (find-vowel\
    \ word)\n    (define (find-vowel-helper word)\n      (if (and (not (char-end",
  "  (let loop ([word word]\n             [i (- (string-length word) 1)])\n    (if\
    \ (&lt; i 0)\n        \"\"\n        (if (char-ci=? (string-ref word i) #\\a)\n\
    \            (string (string-ref word i))\n            (if (char-ci=? (string-ref\
    \ word i) #\\e)\n                (string (string-ref word i))\n              \
    \  (if (char-ci=? (string-ref word i) #\\i)\n                    (string (string-ref\
    \ word i))\n                    (if (char-ci=? (string-ref word i) #\\o)\n   \
    \                     (string (string-ref word i))\n                        (if\
    \ (char-ci=? (string-ref word i) #\\u)\n                            (string (string-ref\
    \ word i))\n                            (loop word (- i 1)))))))))))\n</code>\n\
    and the output of a sample run:\n<code>Welcome to DrRacket, version 6.0.1 [3m].\n\
    Language: racket; memory limit: 256 MB.\n\n&gt; (get_closest_vowel \"yogurt\"\
    )\n\"u\"\n&gt; (get_closest_vowel \"FULL\")\n\"U\"\n&gt; (get_closest_vowel \"\
    quick\")\n\"\"\n&gt; (get_closest_vowel \"ab\")\n\"\"\n&gt; \n</code>\nI have\
    \ also added a part to this answer where I have tried to write my code in a functional\
    \ programming manner. But it doesn't work, so I am not sure if I am actually doing\
    \ it in a functional programming manner.\n<code>#lang racket\n", "  (define (closest-vowel-internal\
    \ word)\n    (let ([next-char (first word)])\n      (cond [(empty? word) \"\"\
    ]\n            [(or (string=? next-char \"A\")\n                 (string=? next-char\
    \ \"E\")\n                 (string=? next-char \"I\")\n                 (string=?\
    \ next-char \"O\")\n                 (string=? next-char \"U\")) next-char]\n\
    \            [else (closest-vowel-internal (rest word))])))\n  (closest-vowel-internal\
    \ (string-reverse word)))\n\n", "  (local [(define (g-c-v-helper word)\n     \
    \       (if (not (pair? word))\n                '()\n                (if (and\
    \ (member (car word) '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"\
    U\"))\n                         (not (member (cdr word) '(\"a\" \"e\" \"i\" \"\
    o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")))\n                         (not (member\
    \ (cadr word) '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\"))))\n\
    \                    (cons (car word) (g-c-v-helper (cdr word)))\n           \
    \         (g-c-v-helper (cdr word))))]\n           (if (not (null? (g-c-v-helper\
    \ word)))\n               (list-ref (g-c-v-helper word) (- (length (g-c-v-helper\
    \ word)) 1))\n               \"\")))\n</code>\n", "  (define (is_vowel ch)\n \
    \   (member ch '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n  (define\
    \ (is_consonant ch)\n    (is_vowel ch))\n  (define (get-closest-vowel word)\n\
    \    (cond [(empty? word) '()]\n          [(is_vowel (first word)) (cons (first\
    \ word) (get-closest-vowel (rest word)))]\n          [(is_consonant (first word))\
    \ (get-closest-vowel (rest word))]))\n  (define (get-closest-consonant word)\n\
    \    (cond [(empty? word) '()]\n          [(is_consonant (first word)) (cons (first\
    \ word) (get-closest-consonant (rest word)))]\n          [(is_vowel (first word))\
    \ (get-closest-consonant (rest word))]))\n  (define (get-last-closest-consonant\
    \ word)\n    (reverse (get-closest-consonant (reverse word))))\n  (define (get-last-closest-vowel\
    \ word)\n    (reverse (get-closest-vowel (reverse word))))\n  (define (get-vowel-from-r-to-l\
    \ word)\n    (string-join (append (get-last-closest-consonant word) (get-last-closest-vowel\
    \ word))))\n  (cond [(empty? word) \"\"]\n        [(empty? (get-vowel-from-r-to-l\
    \ word)) \"\"]\n        [else (string (first (get-vowel-from-r-to-l word)))]))\n",
  "\t(cond\n\t\t((string=? word \"\") \"\")\n\t\t((string=? word \"a\") \"\")\n\t\t\
    ((string=? word \"e\") \"\")\n\t\t((string=? word \"i\") \"\")\n\t\t((string=?\
    \ word \"o\") \"\")\n\t\t((string=? word \"u\") \"\")\n\t\t((string=? word \"\
    A\") \"\")\n\t\t((string=? word \"E\") \"\")\n\t\t((string=? word \"I\") \"\"\
    )\n\t\t((string=? word \"O\") \"\")\n\t\t((string=? word \"U\") \"\")\n\t\t((string=?\
    \ (substring word -1) \"a\") \"\")\n\t\t((string=? (substring word -1) \"e\")\
    \ \"\")\n\t\t((string=? (substring word -1) \"i\") \"\")\n\t\t((string=? (substring\
    \ word -1) \"o\") \"\")\n\t\t((string=? (substring word -1) \"u\") \"\")\n\t\t\
    ((string=? (substring word -1) \"A\") \"\")\n\t\t((string=? (substring word -1)\
    \ \"E\") \"\")\n\t\t((string=? (substring word -1) \"I\") \"\")\n\t\t((string=?\
    \ (substring word -1) \"O\") \"\")\n\t\t((string=? (substring word -1) \"U\")\
    \ \"\")\n\t\t((string=? (substring word 0 1) \"a\") (get_closest_vowel (substring\
    \ word 1)))\n\t\t((string=? (substring word 0 1) \"e\") (get_closest_vowel (substring\
    \ word 1)))\n\t\t((string=? (substring word 0 1) \"i\") (get_closest_vowel (substring\
    \ word 1)))\n\t\t((string=? (substring word 0 1) \"o\") (get_closest_vowel (substring\
    \ word 1)))\n\t\t((string=? (substring word 0 1) \"u\") (get_closest_vowel (substring\
    \ word 1)))\n\t\t((string=? (substring word", "  (define (find-vowel ls)\n   \
    \ (if (empty? ls) #f\n        (if (member (first ls) '(\"a\" \"e\" \"i\" \"o\"\
    \ \"u\" \"A\" \"E\" \"I\" \"O\" \"U\"))\n            (first ls)\n            (find-vowel\
    \ (rest ls)))))\n  (find-vowel (reverse (string->list word))))\n", "  (let ((vowels\
    \ (list #\\a #\\e #\\i #\\o #\\u))\n        (result (list)))\n    (if (or (empty?\
    \ word) (= (count word) 1))\n        \"\"\n        (for ([i (in-range (count word))])\n\
    \          (let ((curr-char (list-ref word i)))\n            (if (member curr-char\
    \ vowels)\n                (append result (list i)))))\n        (if (empty? result)\n\
    \            \"\"\n            (let ((first-index (car result))\n            \
    \      (rest-index (cdr result)))\n              (let ([i (for/first ([idx rest-index])\n\
    \                                 (if (and (= (+ 1 idx) (car rest-index))\n  \
    \                                        (= 1 (- (car rest-index) first-index)))\n\
    \                                     idx))])\n                (string (list-ref\
    \ word i))))))))\n", "  (let loop ([word word]\n             [pos word]\n    \
    \         [vowels \"\"])\n    (cond [(empty? word) (if (= 0 (string-length vowels))\n\
    \                             \"\"\n                             (string-ref vowels\
    \ 0))]\n          [(or (or (string=? (string-ref word 0) \"a\")\n            \
    \       (string=? (string-ref word 0) \"e\")\n                   (string=? (string-ref\
    \ word 0) \"i\")\n                   (string=? (string-ref word 0) \"o\")\n  \
    \                 (string=? (string-ref word 0) \"u\"))\n               (and (or\
    \ (string=? (string-ref word 1) \"a\")\n                        (string=? (string-ref\
    \ word 1) \"e\")\n                        (string=? (string-ref word 1) \"i\"\
    )\n                        (string=? (string-ref word 1) \"o\")\n            \
    \            (string=? (string-ref word 1) \"u\")))\n               (not (string=?\
    \ (string-ref word 0) \"A\"))\n               (not (string=? (string-ref word\
    \ 0) \"E\"))\n               (not (string=? (string-ref word 0) \"I\"))\n    \
    \           (not (string=? (string-ref word 0) \"O\"))\n               (not (string=?\
    \ (string-ref word 0) \"U\")))\n           (loop (substring word 1) pos (string-append\
    \ vowels (string-ref word 0)))]\n          [else (loop (substring word 1) pos\
    \ vowels)])))\n", "  (define (vowel? c)\n    (member c '(#\\a #\\e #\\i #\\o #\\\
    u #\\A #\\E #\\I #\\O #\\U)))\n  (define (find-end-consonant-run word)\n    (let\
    \ loop ([word word] [prev-vowel #f])\n      (if (null? word)\n          (if prev-vowel\n\
    \              (list #f prev-vowel)\n              (list #f #f))\n          (if\
    \ (not (vowel? (car word)))\n              (loop (cdr word) prev-vowel)\n    \
    \          (list (car word) prev-vowel)))))\n  (let-values ([(end prev-vowel)\
    \ (find-end-consonant-run word)])\n    (if (not end)\n        \"\"\n        (let\
    \ loop ([word (cdr word)] [prev-vowel prev-vowel])\n          (if (or (not (vowel?\
    \ (car word))) (not prev-vowel))\n              \"\"\n              (if (not (vowel?\
    \ prev-vowel))\n                  (loop (cdr word) (car word))\n             \
    \     (car word)))))))", "  (get-closest-vowel word #f #f))\n", "  (define (vowel?\
    \ c)\n    (member c '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n \
    \ (define (consonant? c)\n    (not (vowel? c)))\n  (define (get-closest-vowel\
    \ word)\n    (if (string-empty? word)\n        #f\n        (let ([c (string-ref\
    \ word 0)])\n          (if (vowel? c)\n              (cons #f word)\n        \
    \      (let ([rest (get-closest-vowel (substring word 1))])\n                (if\
    \ (car rest)\n                    (cons (consonant? c) rest)\n               \
    \     (cons #f rest)))))))\n  (if (string-empty? word)\n      \"\"\n      (let\
    \ ([r (get-closest-vowel (substring word 1))])\n        (if (car r)\n        \
    \    (string-ref (cdr r) 0)\n            \"\"))))\n", "  (let ([vowels (list #\\\
    a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)])\n    (apply string \n      (loop\
    \ ([pos (sub1 (string-length word))]\n             [vowel #f])\n        (if (=\
    \ pos 0)\n            (if vowel (list vowel) '())\n            (let ([ch (string-ref\
    \ word pos)])\n              (if (memq ch vowels)\n                  (if vowel\n\
    \                      (if (= vowel ch) (cons vowel (get_closest_vowel (substring\
    \ word 0 pos)))\n                          (cons vowel '()))\n               \
    \       (loop (- pos 1) ch))\n                  (loop (- pos 1) vowel))))))))\n",
  "  (let loop ([cur 0] [last_cons -1] [last_vowel (string-length word)])\n    (cond\n\
    \      [(= cur (string-length word))\n       (if (= last_cons last_vowel)\n  \
    \         \"\"\n           (string-ref word (- last_vowel 1)))]\n      [(regexp-match\
    \ #rx\"[aeiou]\" (string-ref word cur))\n       (loop (+ cur 1) last_cons (- last_vowel\
    \ 1))]\n      [else\n       (loop (+ cur 1) cur last_vowel)])))\n", "  (if (<\
    \ 1 (string-length word))\n      (let* ((vowels '(\"a\" \"e\" \"i\" \"o\" \"u\"\
    \ \"A\" \"E\" \"I\" \"O\" \"U\"))\n             (last-letter (string-ref word\
    \ (- (string-length word) 1)))\n             (letters-after-last-consonant\n \
    \             (if (member (string-ref word (- (string-length word) 2)) vowels)\n\
    \                  (drop-right word 2)\n                  (drop-right word 1)))\n\
    \             (all-vowels (filter (lambda (c) (member c vowels)) letters-after-last-consonant))\n\
    \             (first-vowel (first all-vowels)))\n        (cond [(and (member last-letter\
    \ vowels) (member first-vowel vowels))\n               first-vowel]\n        \
    \      [(member last-letter vowels) \"\"]\n              [else \"\"]))\n     \
    \ \"\"))\n", "  (define (find_vowel word)\n    (cond\n      [(equal? (empty? word)\
    \ #t) '()]\n      [(equal? (cdr word) '()) '()]\n      [(member (car word) '(a\
    \ e i o u A E I O U))\n       (cons (car word) (find_vowel (cdr word)))]\n   \
    \   [else (find_vowel (cdr word))]))\n  (define (find_closest_vowel word)\n  \
    \  (cond\n      [(equal? (cdr word) '()) \"\" ]\n      [(member (car word) '(a\
    \ e i o u A E I O U)) (string (car word))]\n      [else (find_closest_vowel (cdr\
    \ word))]))\n  (find_closest_vowel (find_vowel word)))\n", "  (define vowels \"\
    aeiou\")\n  (define (is_consonant? letter)\n    (if (member letter vowels)\n \
    \       #f\n        #t))\n  (define (iter word pos closest-vowel)\n    (cond\n\
    \      [(empty? word) (if (or (= closest-vowel (substring word 0 pos))\n     \
    \                        (= closest-vowel (substring word 1 pos)))\n         \
    \                (substring word 0 pos)\n                         \"\")]\n   \
    \   [(is_consonant? (car word)) (iter (cdr word) (add1 pos) closest-vowel)]\n\
    \      [(> (substring pos 0) (substring pos 1)) (iter (cdr word) (add1 pos) (car\
    \ word))]\n      [else (iter (cdr word) (add1 pos) closest-vowel)]))\n  (iter\
    \ word 0 \"\"))\n", "  (define vowels \"aeiouAEIOU\")\n  (define (is-vowel c)\n\
    \    (string-contains? vowels c))\n  (define (is-consonant c)\n    (not (is-vowel\
    \ c)))\n  (define (is-first-letter c)\n    (string=? c (substring word 0 1)))\n\
    \  (define (is-last-letter c)\n    (string=? c (substring word (- (string-length\
    \ word) 1))))\n  (define (same-side-vowel? idx1 idx2)\n    (and (< idx1 idx2)\n\
    \         (< (sub1 (sub1 (string-length word))) idx2)))\n  (define (get-closest-vowel-rec\
    \ word i)\n    (cond\n      [(= 0 i) \"\"]\n      [(and (is-vowel (substring word\
    \ i 1))\n            (not (is-last-letter (substring word i 1)))\n           \
    \ (not (is-first-letter (substring word i 1)))\n            (not (is-vowel (substring\
    \ word (- i 1) 1)))\n            (not (is-vowel (substring word (+ i 1) 1))))\n\
    \       (substring word i 1)]\n      [else (get-closest-vowel-rec word (- i 1))]))\n\
    \  (get-closest-vowel-rec word (- (string-length word) 1)))\n", "  (let ( (consonants\
    \ (filter\n\t\t      (lambda (c)\n\t\t\t(or (equal? c \"b\")\n\t\t\t    (equal?\
    \ c \"c\")\n\t\t\t    (equal? c \"d\")\n\t\t\t    (equal? c \"f\")\n\t\t\t   \
    \ (equal? c \"g\")\n\t\t\t    (equal? c \"h\")\n\t\t\t    (equal? c \"j\")\n\t\
    \t\t    (equal? c \"k\")\n\t\t\t    (equal? c \"l\")\n\t\t\t    (equal? c \"m\"\
    )\n\t\t\t    (equal? c \"n\")\n\t\t\t    (equal? c \"p\")\n\t\t\t    (equal? c\
    \ \"q\")\n\t\t\t    (equal? c \"r\")\n\t\t\t    (equal? c \"s\")\n\t\t\t    (equal?\
    \ c \"t\")\n\t\t\t    (equal? c \"v\")\n\t\t\t    (equal? c \"w\")\n\t\t\t   \
    \ (equal? c \"x\")\n\t\t\t    (equal? c \"y\")\n\t\t\t    (equal? c \"z\")\n\t\
    \t\t    (equal? c \"B\")\n\t\t\t    (equal? c \"C\")\n\t\t\t    (equal? c \"D\"\
    )\n\t\t\t    (equal? c \"F\")\n\t\t\t    (equal? c \"G\")\n\t\t\t    (equal? c\
    \ \"H\")\n\t\t\t    (equal? c \"J\")\n\t\t\t    (equal? c \"K\")\n\t\t\t    (equal?\
    \ c \"L\")\n\t\t\t    (equal? c \"M\")\n\t\t\t    (equal? c \"N\")\n\t\t\t   \
    \ (equal? c \"P\")\n\t\t\t    (equal? c \"Q\")\n\t\t\t    (equal? c \"R\")\n\t\
    \t\t    (equal? c \"S\")\n\t\t\t    (equal? c \"T\")\n\t\t\t    (equal? c \"V\"\
    )\n\t\t\t    (equal? c \"W\")\n\t\t\t    (equal? c \"X\")\n\t\t\t    (equal? c\
    \ \"Y", "  (let loop ([word word]\n             [i (- (string-length word) 1)])\n\
    \    (cond\n      [(zero? i) \"\"]\n      [(consonant? (string-ref word i))\n\
    \       (loop word (- i 1))]\n      [(vowel? (string-ref word i))\n       (let\
    \ ([j (+ i 1)])\n         (while (and (vowel? (string-ref word j))\n         \
    \            (&lt; j (string-length word)))\n           (set! j (+ j 1)))\n  \
    \       (if (&lt; j (string-length word))\n             (string-ref word i)\n\
    \             (loop word (- i 1))))])))\n", "  (define vowels '(#\\a #\\e #\\\
    i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))\n  (local [(define (is-vowel? c) (member\
    \ c vowels))]\n    (for/last ([lst (in-list (string->list word))])\n      (if\
    \ (and (not (is-vowel? lst)) (is-vowel? (first lst)) (is-vowel? (second lst)))\n\
    \          (list->string lst)))))\n```\n### 2. Consider a nested list representing\
    \ the structure of a file system.\n```racket", "  (cond\n    [(empty? word) \"\
    \"]\n    [(consonant? (second word))\n     (get_closest_vowel (rest word))]\n\
    \    [(vowel? (first word))\n     (first word)]\n    [else \"\"]))\n", "  (let\
    \ loop ([word word]\n             [prev #f]\n             [index 1])\n    (cond\
    \ [(null? word) #f]\n          [(vowel? (car word)) (if prev (string-ref word\
    \ index)\n                                  (loop (cdr word) #t index))]\n   \
    \       [else (loop (cdr word) #f (add1 index))])))\n", "  (let loop ([wrd word]\
    \ [pos (string-length word)])\n    (cond [(or (string-empty? wrd)\n          \
    \     (= pos 0))\n           \"\"]\n          [(char-vowel? (string-ref wrd (-\
    \ pos 1)))\n           (if (char-vowel? (string-ref wrd (- pos 2)))\n        \
    \       (loop (substring wrd 0 (- pos 1)) (- pos 1))\n               (string-ref\
    \ wrd (- pos 1)))]\n          [else\n           (loop (substring wrd 0 (- pos\
    \ 1)) (- pos 1))])))\n", "  (define (helper word)\n    (cond [(null? word) '()]\n\
    \          [(consonant? (car word)) (helper (cdr word))]\n          [(vowel? (car\
    \ word)) word]\n          [else (helper (cdr word))]))\n  (define (consonant?\
    \ char)\n    (not (vowel? char)))\n  (define (vowel? char)\n    (or (equal? char\
    \ #\\a) (equal? char #\\e) (equal? char #\\i) (equal? char #\\o) (equal? char\
    \ #\\u)))\n  (define (closest-vowel? word)\n    (and (consonant? (car word))\n\
    \         (or (vowel? (cadr word)) (equal? (cadr word) #\\y))))\n  (define (str-from-char\
    \ char)\n    (string-append (list char)))\n  (cond [(empty? word) \"\"]\n    \
    \    [(vowel? (first word)) \"\"]\n        [(closest-vowel? (helper word)) (str-from-char\
    \ (cadr (helper word)))]\n        [else (get_closest_vowel (rest word))]))\n",
  "  (let ([vowels (list #\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)])\n  \
    \  (let loop ([i (sub1 (string-length word))])\n      (cond [(equal? 0 i) \"\"\
    ]\n            [(member (string-ref word i) vowels)\n             (if (and (not\
    \ (member (string-ref word (sub1 i)) vowels))\n                      (not (member\
    \ (string-ref word (+ i 1)) vowels)))\n                 (string (string-ref word\
    \ i))\n                 (loop (sub1 i)))]\n            [else (loop (sub1 i))]))))\n\
    </code>\n", "  (define (is_consonant? c)\n    (member c '(#\\f #\\F #\\c #\\C\
    \ #\\k #\\K #\\r #\\R #\\t #\\T #\\p #\\P #\\s #\\S #\\v #\\V #\\z #\\Z)))\n \
    \ (define (get-closest-vowel-iter w right-vowel right-consonant)\n    (cond ((string-empty?\
    \ w) (if (and right-vowel right-consonant) right-vowel \"\"))\n          ((is_consonant?\
    \ (string-ref w 0)) (get-closest-vowel-iter (substring w 1)\n                \
    \                                                    right-vowel\n           \
    \                                                         (string-ref w 0)))\n\
    \          ((and right-vowel right-consonant) (string-ref w 0))\n          (else\
    \ (get-closest-vowel-iter (substring w 1) (string-ref w 0) right-consonant))))\n\
    \  (get-closest-vowel-iter word #f #f))\n", "  (if (not (has-vowel? word))\n \
    \     \"\"\n      (if (string=? (substring word 0 1) \"a\")\n          \"a\"\n\
    \          (get-sub-vowel word)\n      )\n  )\n)\n", "  (define (get-all-vowels\
    \ word)\n    (let ([consonants (string-&gt;list word)])\n      (foldl (lambda\
    \ (acc x)\n               (if (member x '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\"\
    \ \"E\" \"I\" \"O\" \"U\"))\n                   (cons x acc)\n               \
    \    acc))\n             '()\n             consonants)))\n  (define (find-closest-vowel\
    \ vowels)\n    (cond [(null? vowels) \"\"]\n          [(empty? (cdr vowels)) (car\
    \ vowels)]\n          [else\n           (let ([vowel (car vowels)]\n         \
    \        [other (cdr vowels)])\n             (if (and (not (empty? other))\n \
    \                     (consonant? (second other)))\n                 vowel\n \
    \                (find-closest-vowel other)))]))\n  (find-closest-vowel (get-all-vowels\
    \ word)))\n", "  (define (get-vowel-positions word)\n    (define (get-vowel-positions-helper\
    \ word result)\n      (if (eq? 0 (string-length word))\n          result\n   \
    \       (if (char-vowel? (string-ref word 0))\n              (get-vowel-positions-helper\
    \ (substring word 1) (append result (list 0)))\n              (get-vowel-positions-helper\
    \ (substring word 1) (append result (list (add1 (string-length word))))))))\n\
    \    (get-vowel-positions-helper word '()))\n  (define (get-consonant-positions\
    \ word)\n    (define (get-consonant-positions-helper word result)\n      (if (eq?\
    \ 0 (string-length word))\n          result\n          (if (char-consonant? (string-ref\
    \ word 0))\n              (get-consonant-positions-helper (substring word 1) (append\
    \ result (list 0)))\n              (get-consonant-positions-helper (substring\
    \ word 1) (append result (list (add1 (string-length word))))))))\n    (get-consonant-positions-helper\
    \ word '()))\n  (define (find-closest-vowel-positions v c)\n    (define (find-closest-vowel-positions-helper\
    \ v c result)\n      (if (null? v)\n          result\n          (let ([v_pos (car\
    \ v)]\n                [c_pos (car c)])\n            (if (eq? (sub1 (add1 (string-length\
    \ word))) c_pos)\n                (find-closest-vowel-positions-helper (cdr v)\
    \ (cdr c) result)\n                (if (eq? (car (cdr c)) (+ v_pos 1))\n     \
    \               (find-closest-vowel-positions-helper (cdr v) (cdr c) result)\n\
    \                    (find-closest-vowel-positions-helper (cdr v) (cdr c) (append\
    \ result (", "  (cond\n    [(empty? word) \"\"]\n    [(regexp-match #rx\"a\" word)\
    \ \"a\"]\n    [(regexp-match #rx\"e\" word) \"e\"]\n    [(regexp-match #rx\"i\"\
    \ word) \"i\"]\n    [(regexp-match #rx\"o\" word) \"o\"]\n    [(regexp-match #rx\"\
    u\" word) \"u\"]\n    [else \"\" ]))\n", "  (for/first ([i (in-range (sub1 (string-length\
    \ word)) 1 -1)]\n              [v (in-list '(\"a\" \"e\" \"i\" \"o\" \"u\" \"\
    A\" \"E\" \"I\" \"O\" \"U\"))]\n              #:when (and (not (string=? (string-ref\
    \ word (sub1 i)) v))\n                          (string=? (string-ref word i)\
    \ v)\n                          (not (string=? (string-ref word (add1 i)) v))))\n\
    \    v))", "  (cond\n    [(not (string? word))\n     (error 'get_closest_vowel\
    \ \"argument must be a string\")]\n    [(empty? word)\n     \"\"]\n    [(not (char-alphabetic?\
    \ (string-ref word 0)))\n     (get_closest_vowel (substring word 1))]\n    [(and\
    \ (char-alphabetic? (string-ref word 0)) (char-vowel? (string-ref word 0)))\n\
    \     \"\"]\n    [(not (char-alphabetic? (string-ref word 1)))\n     (get_closest_vowel\
    \ (substring word 1))]\n    [(and (char-alphabetic? (string-ref word 1)) (char-vowel?\
    \ (string-ref word 1)))\n     (string-ref word 1)]\n    [else (get_closest_vowel\
    \ (substring word 1))]))\n", "  (let ([vowels \"aeiouAEIOU\"])\n    (cond\n  \
    \    [(empty? word) empty]\n      [(member? (string-ref word 0) vowels) (get_closest_vowel\
    \ (string-drop word 1))]\n      [(empty? (get_closest_vowel (string-drop word\
    \ 1))) empty]\n      [else (get_closest_vowel (string-drop word 1))])))\n```\n\
    \nThis is my first solution. I \"steal\" the get_closest_vowel function from some\
    \ of my\nfriends. Their solution are more elegant than mine. I don't \"get\" this\
    \ problem yet.\nI will write my own solution some day.", "  (define vowels '(#\\\
    a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))\n  (define (is-vowel-between?\
    \ left right)\n    (string-contains? word left right))\n  (match word [('() #f)\n\
    \               (or (string-contains? word #\\a #\\e #\\i #\\o #\\u)\n       \
    \            (string-contains? word #\\A #\\E #\\I #\\O #\\U))]\n        [_ (let\
    \ ([len (string-length word)])\n             (let loop ([idx len])\n         \
    \      (cond\n                 [(= idx (- len 2)) #f]\n                 [(is-vowel-between?\
    \ (- idx 2) (- idx 1))\n                  (string-ref word (- idx 2))]\n     \
    \            [else (loop (- idx 1))])))]))\n", "  (cond\n    [(empty? word)\n\
    \     \"\"]\n    [(empty? (cdr word))\n     \"\"]\n    [(consonant? (car word))\n\
    \     (get_closest_vowel (cdr word))]\n    [(vowel? (car word))\n     (if (consonant?\
    \ (cadr word))\n         (string (car word))\n         (get_closest_vowel (cdr\
    \ word)))]))\n", "  (if (string-empty? word)\n      \"\"\n      (get_closest_vowel-helper\
    \ word \"\")))", "  (let loop ([word word]\n             [start #f]\n        \
    \     [idx (string-length word)])\n    (cond\n      [(or (eq? start #f) (> idx\
    \ start))\n       (cond\n         [(string-contains-ci? \"aeiou\" (string-ref\
    \ word idx))\n          (if (eq? start #f)\n              (loop word (sub1 idx)\
    \ (sub1 idx))\n              (string-ref word idx))]\n         [else (loop word\
    \ start (sub1 idx))])]\n      [else #f])))\n", "  ;; word: string\n  ;; return:\
    \ string\n  (local [(define (get-vowel? c)\n            (member c '(\"a\" \"e\"\
    \ \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")))\n          (define (get-consonant?\
    \ c)\n            (not (get-vowel? c)))\n          (define (get-closest-vowel?\
    \ c lst)\n            (cond [(empty? lst) #f]\n                  [(and (get-vowel?\
    \ c) (get-consonant? (car lst))) #t]\n                  [else (get-closest-vowel?\
    \ c (cdr lst))]))]\n    (cond [(empty? word) \"\"]\n          [(get-vowel? (car\
    \ word)) (get_closest_vowel (cdr word))]\n          [(get-consonant? (car word))\
    \ (if (get-closest-vowel? (car word) (cdr word)) (car word) \"\")]\n         \
    \ [else (get_closest_vowel (cdr word))])))\n", "  (define (is-vowel? ch)\n   \
    \ (or (equal? ch \"a\") (equal? ch \"e\") (equal? ch \"i\") (equal? ch \"o\")\
    \ (equal? ch \"u\") (equal? ch \"A\") (equal? ch \"E\") (equal? ch \"I\") (equal?\
    \ ch \"O\") (equal? ch \"U\")))\n  (define (find-vowel word)\n    (cond\n    \
    \  [(null? word) empty]\n      [(is-vowel? (car word)) (car word)]\n      [else\
    \ (find-vowel (cdr word))]))\n  (define (find-consonant word)\n    (cond\n   \
    \   [(null? word) empty]\n      [(not (is-vowel? (car word))) (car word)]\n  \
    \    [else (find-consonant (cdr word))]))\n  (define (closest word)\n    (define\
    \ (helper word1 word2)\n      (cond\n        [(null? word1) empty]\n        [(is-vowel?\
    \ (car word1)) (car word1)]\n        [(is-vowel? (car word2)) (car word2)]\n \
    \       [else (helper (cdr word1) (cdr word2))]))\n    (helper (reverse word)\
    \ word))\n  (closest word))\n```\n\n```racket\n#lang racket\n", "  (cond\n   \
    \ [(empty? word) \"\"]\n    [(empty? (rest word)) \"\"]\n    [(not (char-in-string?\
    \ (last word) (string-&gt;list \"aAeEiIoOuU\")))\n     (get_closest_vowel (substring\
    \ word 0 (- (string-length word) 1)))]\n    [(char-in-string? (last word) (string-&gt;list\
    \ \"aAeEiIoOuU\"))\n     (get_closest_vowel (substring word 0 (- (string-length\
    \ word) 1)))]\n    [else (last word)]))\n", "  (if\n      (null? word)\n     \
    \ \"\"\n      (if\n          (and\n           (char-alphabetic? (string-ref word\
    \ 0))\n           (string-contains? \"aeiouAEIOU\" (string-ref word 0)))\n   \
    \       (string-ref word 0)\n          (get_closest_vowel (substring word 1)))))\n",
  "  (define (range k n)\n    (for/list ([i (in-range n)]) i))\n  (define (substring-reversed\
    \ s idx-end)\n    (substring s 0 (sub1 idx-end)))\n  (define (vowel? ch)\n   \
    \ (member ch '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n  (define\
    \ (vowel-after-consonant? word idx)\n    (and\n     (not (vowel? (string-ref word\
    \ idx)))\n     (or\n      (eq? idx 0)\n      (vowel? (string-ref word (sub1 idx))))))\n\
    \  (define (first-vowel-after-consonant word idx)\n    (cond\n      [(eq? idx\
    \ (string-length word)) #f]\n      [(vowel-after-consonant? word idx) (substring-reversed\
    \ word idx)]\n      [else (first-vowel-after-consonant word (add1 idx))]))\n \
    \ (first-vowel-after-consonant word 0))\n", "  (define vowels '(\"a\" \"e\" \"\
    i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\"))\n  (define (is_vowel? ch)\n  \
    \  (member ch vowels))\n  (define (helper lst)\n    (cond ((null? lst) \"\")\n\
    \          ((and (is_vowel? (car lst)) (not (is_vowel? (cadr lst)))) (car lst))\n\
    \          (else (helper (cdr lst)))))\n  (helper (reverse (string->list word))))\n",
  "  (cond [(empty? word) \"\"]\n        [(or (empty? (cdr word)) (char-ci=? (cadr\
    \ word) #\\h)) (get_closest_vowel (cdr word))]\n        [(char-vowel? (car word))\
    \ (car word)]\n        [else (get_closest_vowel (cdr word))]))\n", "  (cond\n\
    \    [(empty? word) \"\"]\n    [(vowel? (last word)) (get_closest_vowel (butlast\
    \ word))]\n    [(vowel? (last (butlast word))) (string (last (butlast word)))]\n\
    \    [else (get_closest_vowel (butlast word))]))\n", "  (local [(define (consonant?\
    \ x)\n            (not (member x '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"\
    I\" \"O\" \"U\"))))\n          (define (get-consonant-indices w)\n           \
    \ (map (lambda (i) (if (consonant? (string-ref w i)) i -1))\n                \
    \ (range (sub1 (string-length w)) -1 -1)))\n          (define (get-closest-vowel-indices\
    \ w)\n            (map (lambda (i) (if (and (>= i 0) (consonant? (string-ref w\
    \ i))) (add1 i) -1))\n                 (range (string-length w) -1 -1)))\n   \
    \       (define (find-indices xs ys)\n            (map (lambda (i) (if (member\
    \ i xs) i -1)) ys))\n          (define (get-next-non-negative-index xs)\n    \
    \        (cond [(empty? xs) -1]\n                  [(>= (first xs) 0) (first xs)]\n\
    \                  [else (get-next-non-negative-index (rest xs))]))\n        \
    \  (define (get-closest-vowel w)\n            (let* ([consonant-indices (get-consonant-indices\
    \ w)]\n                   [vowel-indices (get-closest-vowel-indices w)]\n    \
    \               [indices (find-indices consonant-indices vowel-indices)]\n   \
    \                [index (get-next-non-negative-index indices)])\n            \
    \  (if (and (>= index 0) (< index (string-length w)))\n                  (string-ref\
    \ w index)\n                  \"\")))\n          ]\n    (get-closest-vowel word)))\n",
  "  (define (is_consonant? c)\n    (not (elem? c '(\"a\" \"e\" \"i\" \"o\" \"u\"\
    \ \"A\" \"E\" \"I\" \"O\" \"U\"))))\n  (define (first-non-vowel word)\n    (if\
    \ (is_consonant? (string-take word 1))\n        word\n        (first-non-vowel\
    \ (string-drop word 1))))\n  (define (get-closest-vowel word)\n    (if (not (&gt;\
    \ (string-length word) 2))\n        \"\"\n        (if (is_consonant? (string-take\
    \ word 1))\n            (if (is_consonant? (string-take (string-drop word 1) 1))\n\
    \                (string-take (string-drop word 1) 1)\n                (get-closest-vowel\
    \ (string-drop word 1)))\n            (get-closest-vowel (string-drop word 1)))))\n\
    \  (get-closest-vowel (first-non-vowel word)))\n</code>\nI want to know if there\
    \ is a shorter and more elegant way to implement this in Racket.\n\n\nA:\n\nRegular\
    \ expressions can be used to solve this problem.\n<code>(require racket/regexp)\n",
  "  (define (sublist word idx)\n    (substring word idx))\n  (define (check-sublist\
    \ word)\n    (define (loop word idx)\n      (if (= idx -1) \"\"\n        (let\
    \ ((sub (sublist word idx)))\n          (cond ((string-contains sub #\\a) #\\\
    a)\n                ((string-contains sub #\\e) #\\e)\n                ((string-contains\
    \ sub #\\i) #\\i)\n                ((string-contains sub #\\o) #\\o)\n       \
    \         ((string-contains sub #\\u) #\\u)\n                (else (loop word\
    \ (- idx 1)))))))\n    (loop word (- (string-length word) 1)))\n  (if (string-contains\
    \ word #\\a) #\\a\n    (check-sublist word)))", "  (let ([lst (string->list word)])\n\
    \    (cond [(or (empty? lst)\n               (and (char-vowel? (car lst))\n  \
    \                  (empty? (cdr lst))))\n           \"\"]\n          [(char-vowel?\
    \ (car lst))\n           (get_closest_vowel (list->string (cdr lst)))]\n     \
    \     [else\n           (let loop ([vowel #\\u]\n                      [lst (cdr\
    \ lst)])\n             (cond [(char-vowel? (car lst))\n                    (loop\
    \ (car lst) (cdr lst))]\n                   [(empty? lst) vowel]\n           \
    \        [else (loop vowel (cdr lst))]))])))\n", "  (if (string-empty? word)\n\
    \      \"\"\n      (if (or (string=? word \"y\")\n              (string=? word\
    \ \"Y\"))\n          \"\"\n          (define (is_vowel? c)\n            (and (string-ci=?\
    \ c \"a\")\n                 (string-ci=? c \"e\")\n                 (string-ci=?\
    \ c \"i\")\n                 (string-ci=? c \"o\")\n                 (string-ci=?\
    \ c \"u\")))\n          (define (is_consonant? c)\n            (not (is_vowel?\
    \ c)))\n          (define (first_vowel word)\n            (if (is_vowel? (string-ref\
    \ word 0))\n                (string-ref word 0)\n                (first_vowel\
    \ (substring word 1))))\n          (define (last_vowel word)\n            (if\
    \ (is_vowel? (string-ref word (- (string-length word) 1)))\n                (string-ref\
    \ word (- (string-length word) 1))\n                (last_vowel (substring word\
    \ 0 (- (string-length word) 1)))))\n          (define (from_left word)\n     \
    \       (cond ((is_vowel? (string-ref word (- (string-length word) 1)))\n    \
    \               (string-ref word (- (string-length word) 1)))\n              \
    \    ((is_consonant? (string-ref word (- (string-length word) 1)))\n         \
    \          (from_left (substring word 0 (- (string-length word) 1))))\n      \
    \            (else \"\")))\n          (define (from_right word)\n            (cond\
    \ ((is_vowel? (string-ref word 0))\n                   (string-ref word 0))\n\
    \                  ((is_consonant? (string-ref word 0))\n                   (from_right\
    \ (substring word 1)))\n                  (else \"\")))\n          (define (is_alternating\
    \ word)\n            (if (string-empty? word)\n                #t\n          \
    \      (and (is_consonant? (string-ref word 0))\n                     (is_vowel?\
    \ (string-ref word 1))\n                     (is_alternating (sub", "  (cond [(empty?\
    \ word) \"\"]\n        [(string-contains-ci? \"aeiou\" (string-ref word 0))\n\
    \         (get_closest_vowel (string-drop word 1))]\n        [(string-contains-ci?\
    \ \"aeiou\" (string-ref word -1))\n         (get_closest_vowel (string-drop word\
    \ -1))]\n        [else\n         (string-contains-ci? \"aeiou\" (string-ref word\
    \ -2))\n         (string-ref word -2)]))\n", "  (let ([length (string-length word)])\n\
    \    (reverse (car (filter (lambda (w) (regexp-match? #rx\"^[^AEIOUaeiou].*[AEIOUaeiou][^AEIOUaeiou]$\"\
    \ w))\n                          (map string-trim (build-list length (lambda (i)\
    \ (substring word i length)))))))))", "  (define (get-closest-vowel-helper word\
    \ closest-vowel)\n    (cond\n      [(empty? word) closest-vowel]\n      [(string-contains?\
    \ \"aeiou\" (string-ref word 0))\n       (get-closest-vowel-helper (rest word)\
    \ (string-ref word 0))]\n      [else (get-closest-vowel-helper (rest word) closest-vowel)]))\n\
    \  (get-closest-vowel-helper word \"\"))\n", "  (define vowel\n    (string-&gt;list\
    \ \"aeiouAEIOU\"))\n  (define consonant\n    (string-&gt;list \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ))\n  (if (or (string-contains? word vowel) (string-contains? word consonant))\n\
    \      (list-ref vowel (random (length vowel)))\n      (list-ref consonant (random\
    \ (length consonant)))))\n</code>\nyou can see the errors here. (picture below)\n\
    The first error says:\n<code>string-contains?: contract violation\n  expected:\
    \ string?\n  given: #&lt;procedure:word&gt;\n  argument position: 1st\n  other\
    \ arguments...:\n</code>\nand the second one says:\n<code>list-ref: contract violation\n\
    \  expected: non-negative exact integer?\n  given: #&lt;procedure:word&gt;\n \
    \ argument position: 1st\n  other arguments...:\n</code>\nHow can I fix these\
    \ errors?\nI want the list to be printed once, but I can't get it to work.\n\n\
    \nA:\n\nWhat you've written is a procedure that takes a word as input and prints\
    \ out a random letter from the list <code>vowel</code> or the list <code>consonant</code>.\
    \ That's a far cry from what you're trying to do. \nFirst of all, for the purposes\
    \ of this exercise, it's fine to assume that the input is a string. You can use\
    \ <code>string?</code> to check. \nNext, you're going to need to iterate through\
    \ the characters in the string using <code>for/list</code> or <code>for/fold</code>\
    \ and keep track of the position of each consonant and the position of each vowel.\
    \ \nFor example, suppose you have the input <code>\"yogurt\"</code>. You'd expect\
    \ to get <code>\"u\"</code> back as the output. That's because <code>\"u\"</code>\
    \ is the closest vowel to the right of a consonant. So your process here is basically:\n\
    \nFind <code>\"g\"</", "  (define cons\n    '(\"B\" \"C\" \"D\" \"F\" \"G\" \"\
    H\" \"J\" \"K\" \"L\" \"M\" \"N\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"V\" \"W\" \"\
    X\" \"Y\" \"Z\"))\n  (define vow\n    '(\"A\" \"E\" \"I\" \"O\" \"U\"))\n  (cond\n\
    \    [(string=? (substring word 0 1) \"A\") \"\"]\n    [(string=? (substring word\
    \ 0 1) \"E\") \"\"]\n    [(string=? (substring word 0 1) \"I\") \"\"]\n    [(string=?\
    \ (substring word 0 1) \"O\") \"\"]\n    [(string=? (substring word 0 1) \"U\"\
    ) \"\"]\n    [(string=? (substring word (- (string-length word) 1) (string-length\
    \ word)) \"A\") \"\"]\n    [(string=? (substring word (- (string-length word)\
    \ 1) (string-length word)) \"E\") \"\"]\n    [(string=? (substring word (- (string-length\
    \ word) 1) (string-length word)) \"I\") \"\"]\n    [(string=? (substring word\
    \ (- (string-length word) 1) (string-length word)) \"O\") \"\"]\n    [(string=?\
    \ (substring word (- (string-length word) 1) (string-length word)) \"U\") \"\"\
    ]\n    [(string=? (substring word (- (string-length word) 1) (string-length word))\
    \ \"Y\") \"\"]\n    [(and\n      (not (member (substring word (- (string-length\
    \ word) 1) (string-length word)) cons))\n      (not (member (substring word (-\
    \ (string-length word) 2) (- (string-length word) 1)) cons)))\n      (get_closest_vowel\
    \ (substring word 0 (- (string-length word) 1)))]\n    [(and\n      (not (member\
    \ (substring word (- (string-length word) 1) (string-length word)) cons))\n  \
    \    (member (substring word (- (string-length word) 2) (- (string-length word)\
    \ 1", "  (define (get-vowel-count word)\n    (define vowels \"aeiou\")\n    (define\
    \ (helper word count)\n      (if (string-null? word)\n          count\n      \
    \    (if (string-contains vowels (string-ref word 0))\n              (helper (substring\
    \ word 1) (+ count 1))\n              (helper (substring word 1) count))))\n \
    \   (helper word 0))\n  (define (is-vowel? ch)\n    (string-contains \"aeiou\"\
    \ ch))\n  (define (find-closest-vowel word)\n    (if (or (null? word) (not (is-vowel?\
    \ (string-ref word 0))))\n        (find-closest-vowel (substring word 1))\n  \
    \      (string-ref word 0)))\n  (if (= (get-vowel-count word) 0)\n      \"\"\n\
    \      (find-closest-vowel (substring word 1))))\n", "  (let ([vowels \"aeiou\"\
    ])\n    (cond\n      [(empty? word) empty]\n      [(member (first word) vowels)\
    \ empty]\n      [(member (last word) vowels) empty]\n      [else\n       (let\
    \ ([result (find-closest-vowel word)]\n             [w-length (length word)])\n\
    \         (cond\n           [(or (= 1 (length result)) (= w-length (length result)))\
    \ empty]\n           [else (char-upcase (second result))]))])))\n", "  (define\
    \ (helper word i)\n    (if (&lt; i 0)\n        \"\"\n        (if (member (string-ref\
    \ word i) '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))\n            (if\
    \ (and (member (string-ref word (- i 1)) '(#\\b #\\c #\\d #\\f #\\g #\\h #\\j\
    \ #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y #\\z #\\B #\\\
    C #\\D #\\F #\\G #\\H #\\J #\\K #\\L #\\M #\\N #\\P #\\Q #\\R #\\S #\\T #\\V #\\\
    W #\\X #\\Y #\\Z))\n                     (member (string-ref word (+ i 1)) '(#\\\
    b #\\c #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\\
    v #\\w #\\x #\\y #\\z #\\B #\\C #\\D #\\F #\\G #\\H #\\J #\\K #\\L #\\M #\\N #\\\
    P #\\Q #\\R #\\S #\\T #\\V #\\W #\\X #\\Y #\\Z)))\n                (string (string-ref\
    \ word i))\n                (helper word (- i 1))\n                )\n       \
    \     (helper word (- i 1))\n            )\n        )\n    )\n  (helper word (-\
    \ (string-length word) 1))\n  )\n</code>\nI want to make my code more concise\
    \ and elegant. Please let me know what you think. \n\n\nA:\n\nI had the same problem\
    \ as you in my first months in Racket. There are some good points in your code,\
    \ but also some very obvious ones to improve (using <code>string</code> to construct\
    \ a string is unnecessary, <code>string-&gt;list</code> can be useful to avoid\
    \ writing", "  (define (get-vowel word)\n    (cond [(string=? word \"\") \"\"\
    ]\n          [(member (string-ref word 0) '(\"a\" \"e\" \"i\" \"o\" \"u\")) (string-ref\
    \ word 0)]\n          [else (get-vowel (substring word 1))]))\n  (define (test-consonant\
    \ word)\n    (cond [(string=? word \"\") #f]\n          [(member (string-ref word\
    \ 0) '(\"a\" \"e\" \"i\" \"o\" \"u\")) #f]\n          [else (test-consonant (substring\
    \ word 1))]))\n  (define (get-next-vowel word)\n    (cond [(string=? word \"\"\
    ) \"\"]\n          [(member (string-ref word 0) '(\"a\" \"e\" \"i\" \"o\" \"u\"\
    )) (string-ref word 0)]\n          [else (get-next-vowel (substring word 1))]))\n\
    \  (define (get-prev-consonant word)\n    (cond [(string=? word \"\") \"\"]\n\
    \          [(member (string-ref word 0) '(\"a\" \"e\" \"i\" \"o\" \"u\")) (get-prev-consonant\
    \ (substring word 1))]\n          [else (string-ref word 0)]))\n  (define (get-prev-vowel\
    \ word)\n    (cond [(string=? word \"\") \"\"]\n          [(member (string-ref\
    \ word 0) '(\"a\" \"e\" \"i\" \"o\" \"u\")) (string-ref word 0)]\n          [else\
    \ (get-prev-vowel (substring word 1))]))\n  (define (get-next-consonant word)\n\
    \    (cond [(string=? word \"\") \"\"]\n          [(member (string-ref word 0)\
    \ '(\"a\" \"e\" \"i\" \"o\" \"u\")) (get-next-consonant (substring word 1))]\n\
    \          [else (string-ref word 0)]))\n  (cond [(test-consonant word) (get-vowel\
    \ (substring word 1))]\n        [(or (string=? (get-prev", "  (for/or ([idx (in-range\
    \ (add1 (string-length word)))] #:when (and (not (member (string-ref word idx)\
    \ '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))) (member (string-ref word\
    \ (sub1 idx)) '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))))\n    (string-ref\
    \ word idx)))", "  (for/first ([i (in-range (sub1 (string-length word)) (sub1\
    \ (string-length word)) -1)]\n              [c (in-list word)])\n    (cond\n \
    \     [(not (eq? (string-upcase c) c)) (displayln \"not an uppercase letter\"\
    )]\n      [(equal? c \"\") (displayln \"empty string\")]\n      [(equal? c \"\
    a\") (displayln \"a\")]\n      [(equal? c \"e\") (displayln \"e\")]\n      [(equal?\
    \ c \"i\") (displayln \"i\")]\n      [(equal? c \"o\") (displayln \"o\")]\n  \
    \    [(equal? c \"u\") (displayln \"u\")])))\n", "  (define vowel?\n    (lambda\
    \ (x)\n      (or (equal? x \"a\")\n          (equal? x \"e\")\n          (equal?\
    \ x \"i\")\n          (equal? x \"o\")\n          (equal? x \"u\"))))\n  (define\
    \ (helper word)\n    (cond\n      [(equal? word \"\") \"\"]\n      [(equal? (length\
    \ word) 1) \"\"]\n      [(vowel? (string-ref word 1)) (string-ref word 1)]\n \
    \     [else (helper (substring word 1))]))\n  (helper word))", "  (let loop ([left\
    \ '()] [right (string->list word)])\n    (cond [(empty? right) \"\"]\n       \
    \   [(vowel? (car right))\n           (if (consonant? (car left))\n          \
    \     (list->string (cons (car right) '()))\n               (loop (cdr right)\
    \ (cdr right)))]\n          [else (loop (cons (car right) left) (cdr right))])))\n",
  "  (if (empty? word)\n      \"\"\n      (if (or (= (string-length word) 1)\n   \
    \           (not (string-ci=? #\\a (string-ref word (- (string-length word) 1))))\n\
    \              (string-ci=? #\\a (string-ref word 0)))\n          \"\"\n     \
    \     (let ([vowels (list #\\a #\\e #\\i #\\o #\\u)])\n            (for ([c (in-list\
    \ (string->list word))])\n              (when (and (not (in-list vowels c))\n\
    \                         (member c vowels))\n                (return c)))))))\n",
  "  (local [(define (nextword word)\n            (if (or (= (string-length word)\
    \ 0) (= (string-length word) 1))\n                word\n                (nextword\
    \ (substring word 1 (- (string-length word) 1)))))\n           (define (is_vowel?\
    \ letter)\n             (or (char=? #\\a letter) (char=? #\\e letter) (char=?\
    \ #\\i letter) (char=? #\\o letter) (char=? #\\u letter)))\n           (define\
    \ (first_and_last_letter word)\n             (string-append (string (string-ref\
    \ word 0)) (string (string-ref word (- (string-length word) 1)))))\n         \
    \  (define (first_and_last_is_vowel? word)\n             (or (is_vowel? (string-ref\
    \ word 0)) (is_vowel? (string-ref word (- (string-length word) 1)))))\n      \
    \     (define (is_consonant? letter)\n             (not (is_vowel? letter)))\n\
    \           (define (number-of-vowels-in-between word)\n             (if (not\
    \ (is_consonant? (string-ref word 0)))\n                 0\n                 (if\
    \ (not (is_consonant? (string-ref word (- (string-length word) 1))))\n       \
    \              0\n                     (if (not (is_vowel? (string-ref word 1)))\n\
    \                         (+ (number-of-vowels-in-between (nextword word)) 0)\n\
    \                         (+ (number-of-vowels-in-between (nextword word)) 1)))))\n\
    \           (define (find-vowel word)\n             (if (or (= (string-length\
    \ word) 0) (= (string-length word) 1))\n                 word\n              \
    \   (if (is_vowel? (string-ref word 1))\n                     (find-vowel (nextword\
    \ word))\n                     (find-vowel (nextword word)))))\n           (define\
    \ (vowel-position word)\n             (if (not (is_vowel? (string-ref word 1)))\n\
    \                 (vowel-position (", "  (define vowels '(#\\a #\\e #\\i #\\o\
    \ #\\u #\\A #\\E #\\I #\\O #\\U))\n  (define (find-vowel-index word prev-index)\n\
    \    (if (eq? (- (string-length word) prev-index) 2)\n        (- (string-length\
    \ word) 1)\n        (find-vowel-index word (+ prev-index 1))))\n  (define (get-vowel\
    \ word prev-index)\n    (define current-index (find-vowel-index word prev-index))\n\
    \    (cond ((char-vowel? (string-ref word current-index))\n           (string-ref\
    \ word current-index))\n          ((> current-index (string-length word))\n  \
    \         \"\")\n          (else (get-vowel word current-index))))\n  (get-vowel\
    \ word 0))\n", "  (let ([vowels (string-&gt;list \"aeiouAEIOU\")]\n        [word-chars\
    \ (string-&gt;list word)])\n    (let ([right-vowels-positions (reverse (for/list\
    \ ([c word-chars]\n                                                      #:when\
    \ (member c vowels))\n                                           c))])\n     \
    \ (let ([words-after-vowels (for/list ([pos right-vowels-positions])\n       \
    \                           (substring word (string-index pos word) (string-length\
    \ word)))]\n            [words-with-consonants (for/list ([w words-after-vowels])\n\
    \                                     (for/list ([c (string-&gt;list w)]\n   \
    \                                             #:when (not (member c vowels)))\n\
    \                                      c))])\n        (let ([consonants-positions\
    \ (for/list ([w words-with-consonants])\n                                    \
    \  (if (empty? w) '() (string-index (string (car w)) (car words-after-vowels))))])\n\
    \          (if (null? consonants-positions) \"\"\n              (list-ref (car\
    \ (list-ref consonants-positions (index-of (max (car consonants-positions)) consonants-positions)))\
    \ 0)))))))\n</code>\nI feel like this one is really difficult to read, and there\
    \ are too many lets, but it works.\nPlease help me make this code shorter and\
    \ neater. Thanks!\n\n\nA:\n\nI've written a simpler answer than my original one.\
    \ It's not as fast, but it's easier to read:\n<code>(define (get-closest-vowel\
    \ s)\n  (define vowels \"aeiouAEIOU\")\n  (let ([vowel-positions (for/list ([i\
    \ (in-range (string-length s))])\n                                   (string-index\
    \ (substring s i (+ i 1)) vowels))])\n    (if (null? vowel-positions) \"\"\n \
    \       (substring s (list-ref vowel-positions\n                             \
    \  (index-of (max (car vowel-positions)) vowel-positions))\n                 \
    \   (+ 1", "  (cond [(empty? word) '()]\n        [(vowel? (first word))\n    \
    \     (cond [(empty? (rest word))\n                (last word)]\n            \
    \   [(consonant? (second word))\n                (first word)]\n             \
    \  [else (get_closest_vowel (rest word))])]\n        [else (get_closest_vowel\
    \ (rest word))]))\n", "  (define (find-closest-vowel word i)\n    (cond [(>= i\
    \ (string-length word)) \"\"]\n          [(vowel? (string-ref word i))\n     \
    \      (if (= i (+ (string-length word) 1)) \n               \"\" \n         \
    \      (string-ref word i))]\n          [else (find-closest-vowel word (+ i 1))]))\n\
    \  (if (empty? word) \"\"\n      (find-closest-vowel word (- (string-length word)\
    \ 1))))\n", "  (let loop ([word (string->list word)]\n             [left '()]\n\
    \             [right '()])\n    (cond\n      [(empty? word) (list->string (append\
    \ left right))]\n      [(or (or (member (car word) '(#\\a #\\e #\\i #\\o #\\u))\n\
    \               (member (car word) '(#\\A #\\E #\\I #\\O #\\U)))\n       (and\
    \ (or (null? right) (not (member (car right) '(#\\a #\\e #\\i #\\o #\\u #\\A #\\\
    E #\\I #\\O #\\U))))\n            (not (or (null? left) (member (car left) '(#\\\
    a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))))\n       (list->string (cons\
    \ (car word) right))]\n      [else (loop (cdr word)\n                  (append\
    \ left (list (car word)))\n                  right)])))", "  (if (string-empty?\
    \ word)\n      \"\"\n      (if (string-ref word 0)\n          (get_closest_vowel\
    \ (substring word 1))\n          (get_closest_vowel (substring word 1)))))\n</code>\n\
    My question is:\n1. How can I get the value of the closest vowel?\n2. How can\
    \ I test if a vowel is between 2 consonants?\nThank you\n\n\nA:\n\nFirst, your\
    \ base case is incorrect; <code>string-empty?</code> does not take any parameters.\
    \  Also, it is not clear to me why you are passing the result of <code>string-ref</code>\
    \ to it - the result of <code>string-ref</code> is not a boolean value; it is\
    \ just the character at the index you pass to it.\nI think you want to call <code>string-empty?</code>\
    \ on the word itself, and use <code>&gt;=</code> to compare the length of the\
    \ word to 3.  That will tell you whether the word is short enough to contain a\
    \ vowel between two consonants.\nNext, you need to compare each character of the\
    \ word to each member of a list of vowels.  If the current character is a vowel,\
    \ and it is preceded by a consonant and followed by a consonant, then you have\
    \ found the closest vowel.  Otherwise, you call the procedure recursively on the\
    \ rest of the word.\n", "  (cond [(empty? word) \"\"]\n        [(member? (car\
    \ word) '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n         (if (and (member? (cdr word)\
    \ '(\"b\" \"c\" \"d\" \"f\" \"g\" \"h\" \"j\" \"k\" \"l\" \"m\" \"n\" \"p\" \"\
    q\" \"r\" \"s\" \"t\" \"v\" \"w\" \"x\" \"y\" \"z\"))\n                  (member?\
    \ (car (cdr (cdr word))) '(\"b\" \"c\" \"d\" \"f\" \"g\" \"h\" \"j\" \"k\" \"\
    l\" \"m\" \"n\" \"p\" \"q\" \"r\" \"s\" \"t\" \"v\" \"w\" \"x\" \"y\" \"z\")))\n\
    \             (string (car word))\n             (get_closest_vowel (cdr word)))]\n\
    \        [else (get_closest_vowel (cdr word))]))\n", "  (define (all-but-last\
    \ lst)\n    (if (null? (cdr lst))\n        '()\n        (cons (car lst) (all-but-last\
    \ (cdr lst)))))\n  (define (all-but-first lst)\n    (if (null? (cdr lst))\n  \
    \      '()\n        (cdr lst)))\n  (define (is-vowel? c)\n    (memq c '(#\\a #\\\
    e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n  (if (or (null? word) (null? (cdr\
    \ word)))\n      \"\"\n      (if (and (not (is-vowel? (car word))) (is-vowel?\
    \ (cadr word)))\n          (string (cadr word))\n          (get_closest_vowel\
    \ (cdr word)))))\n</code>\nNote that this snippet uses <code>memq</code> to test\
    \ for a vowel, but the solution could be made more efficient if you define a list\
    \ of vowels and use <code>memv</code> instead (the <code>v</code> in <code>memv</code>\
    \ stands for \"value equality\" and means it does a deep comparison of items in\
    \ the list instead of comparing the list structure).\n", "  ;; your code here\n\
    \  (local ((define (check-word word)\n            (cond\n              [(or (empty?\
    \ word) (empty? (rest word))) \"\"]\n              [(consonant? (first word))\n\
    \               (if (vowel? (first (rest word)))\n                   (string (first\
    \ (rest word)))\n                   (check-word (rest word)))]\n             \
    \ [else (check-word (rest word))])))\n    (check-word word)))\n", "  (let* ([vowels\
    \ (list \"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")]\n      \
    \   [n (string-length word)]\n         [i (for/fold ([acc 0]) ([j (- n 1)])\n\
    \              (cond [(in-list? (string-ref word j) vowels) j]\n             \
    \       [else acc]))])\n    (if (not (= i 0))\n        (string-ref word i)\n \
    \       \"\")))\n", "  (define (is_vowel? char)\n    (or (equal? char #\\a)\n\
    \        (equal? char #\\e)\n        (equal? char #\\i)\n        (equal? char\
    \ #\\o)\n        (equal? char #\\u)))\n  (define (find-consonant word)\n    (cond\
    \ [(empty? word) empty]\n          [(is_vowel? (first word)) empty]\n        \
    \  [else (cons (first word) (find-consonant (rest word)))]))\n  (define (after-consonant\
    \ word)\n    (cond [(empty? word) empty]\n          [(is_vowel? (first word))\
    \ word]\n          [else (after-consonant (rest word))]))\n  (define (find-vowel\
    \ word)\n    (cond [(empty? word) empty]\n          [(is_vowel? (first word))\
    \ (cons (first word) empty)]\n          [else (find-vowel (rest word))]))\n  (define\
    \ (before-vowel word)\n    (cond [(empty? word) empty]\n          [(is_vowel?\
    \ (first word)) empty]\n          [else (cons (first word) (before-vowel (rest\
    \ word)))]))\n  (define (get-closest w1 w2)\n    (cond [(empty? w1) w2]\n    \
    \      [(empty? w2) w1]\n          [(< (length w1) (length w2)) w1]\n        \
    \  [else w2]))\n  (get-closest (after-consonant (find-vowel (after-consonant word)))\n\
    \               (before-vowel (find-consonant (before-vowel word)))))\n```\n\n\
    2. [Pig Latin](https://www.codewars.com/kata/simple-pig-latin/train/racket)\n\
    ```racket\n#lang racket\n", "    (cond ((and (string-contains? word #\\a) (string-contains?\
    \ word #\\b)) (string-append \"a\" \"b\"))\n            ((and (string-contains?\
    \ word #\\e) (string-contains? word #\\o)) (string-append \"e\" \"o\"))\n    \
    \        (else \"\")))\n", "  (cond\n    [(string=? word \"\") \"\"]\n    [(vowel?\
    \ (string-ref word 0)) \"\"]\n    [(vowel? (string-ref word (sub1 (string-length\
    \ word)))) \"\"]\n    [(and (consonant? (string-ref word 0))\n          (consonant?\
    \ (string-ref word (sub1 (string-length word)))))\n     (get_closest_vowel (substring\
    \ word 1 (- (string-length word) 1)))]\n    [else (get_closest_vowel (substring\
    \ word 1 (- (string-length word) 1)))]))\n", "  (let ([start (find-between word)])\n\
    \    (if (and (= start false)\n             (= (find-between (string-reverse word))\
    \ false))\n        \"\"\n        (if (string=? (substring word (add1 start) (add1\
    \ start)) \"a\")\n            \"a\"\n            (if (string=? (substring word\
    \ (add1 start) (add1 start)) \"e\")\n                \"e\"\n                (if\
    \ (string=? (substring word (add1 start) (add1 start)) \"i\")\n              \
    \      \"i\"\n                    (if (string=? (substring word (add1 start) (add1\
    \ start)) \"o\")\n                        \"o\"\n                        (if (string=?\
    \ (substring word (add1 start) (add1 start)) \"u\")\n                        \
    \    \"u\"\n                            \"A\"))))))))\n", "  (let ([vowels (list\
    \ \"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")]\n        [length\
    \ (length word)])\n    (cond [(< length 2) \"\"]\n          [(member (string-ref\
    \ word 0) vowels) \"\"]\n          [(member (string-ref word (- length 1)) vowels)\
    \ \"\"]\n          [else\n           (let ([right-consonants (build-right-consonants\
    \ word)])\n             (if (null? right-consonants)\n                 \"\"\n\
    \                 (let ([closest-vowel-so-far #f])\n                   (for/or\
    \ ([pair right-consonants])\n                     (let ([second-char (second pair)])\n\
    \                       (if (member second-char vowels)\n                    \
    \       (begin\n                             (set! closest-vowel-so-far second-char)\n\
    \                             #t))))\n                   closest-vowel-so-far)))])))\n",
  "  (define vowels \"aeiou\")\n  (let loop ([i (sub1 (string-length word))])\n  \
    \  (cond [(negative? i) \"\"]\n          [(or (char-vowel? (string-ref word i))\n\
    \               (char-vowel? (string-ref word (sub1 i))))\n           (string-ref\
    \ word i)]\n          [else (loop (sub1 i))])))\n", "  (define (vowel? c)\n  \
    \  (member c '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")))\n\
    \  (define (check? c)\n    (and (not (vowel? c))\n         (eq? c (string-ref\
    \ word 0))))\n  (define (iter i)\n    (if (and (not (vowel? (string-ref word i)))\n\
    \             (not (vowel? (string-ref word (- i 1)))))\n        (iter (- i 1))\n\
    \        (if (check? (string-ref word i))\n            \"\"\n            (string-ref\
    \ word i))))\n  (if (<= (string-length word) 2)\n      \"\"\n      (iter (- (string-length\
    \ word) 1))))\n", "  (cond\n    [(empty? word) empty]\n    [(regexp-match #rx\"\
    ^[aeiouyAEIOUY]\" word) empty]\n    [(regexp-match #rx\"[aeiouyAEIOUY]\" word)\
    \ (get_closest_vowel (regexp-replace #rx\"^[^aeiouyAEIOUY]+\" \"\" word))]\n \
    \   [else empty]))\n", "  (let ([vowels (string-&gt;list \"aeiouAEIOU\")]\n  \
    \      [word-ls (string-&gt;list word)])\n    (for/first ([v (in-list vowels)])\n\
    \      (or (and (char=? v (vector-ref word-ls (add1 (vector-length word-ls))))\n\
    \               (char=? v (vector-ref word-ls (- (vector-length word-ls) 2))))\n\
    \          (and (char=? v (vector-ref word-ls (- (vector-length word-ls) 1)))\n\
    \               (char=? v (vector-ref word-ls (- (vector-length word-ls) 3))))))))\n\
    </code>\nThis code seems to run the part of the first and clause and returns false\
    \ if the char is not a vowel (v). How do I iterate the next one?\n\n\nA:\n\n<code>vector-ref</code>\
    \ throws an exception if the index is out of bounds, so it can't be used to check\
    \ \"empty\". You should use <code>vector-ref*</code> instead:\n<code>(define (get-closest-vowel\
    \ word)\n  (let ([vowels (string-&gt;list \"aeiouAEIOU\")]\n        [word-ls (string-&gt;list\
    \ word)])\n    (for/first ([v (in-list vowels)])\n      (or (and (char=? v (vector-ref*\
    \ word-ls (add1 (vector-length word-ls))))\n               (char=? v (vector-ref*\
    \ word-ls (- (vector-length word-ls) 2))))\n          (and (char=? v (vector-ref*\
    \ word-ls (- (vector-length word-ls) 1)))\n               (char=? v (vector-ref*\
    \ word-ls (- (vector-length word-ls) 3))))))))\n</code>\nI'm still not sure what\
    \ this is supposed to do, but maybe this fixes it?\n", "  (define (find-closest-vowel\
    \ w)\n    (cond ((null? w) \"\")\n          ((memq (car w) '(#\\a #\\e #\\i #\\\
    o #\\u #\\A #\\E #\\I #\\O #\\U))\n           (car w))\n          (else (find-closest-vowel\
    \ (cdr w)))))\n  (if (memq (car (reverse word)) '(#\\a #\\e #\\i #\\o #\\u #\\\
    A #\\E #\\I #\\O #\\U))\n      \"\"\n      (find-closest-vowel (reverse word))))\n\
    </code>\n", "  (for/first ([letter (in-string word)])\n    (when (and (consonant?\
    \ letter) (not (equal? (char-downcase letter) (char-upcase letter))))\n      (let*\
    \ ([word (string-append \" \" word)]\n             [vowel? (char-set-contains?\
    \ #(#\\a #\\e #\\i #\\o #\\u) (char-downcase letter))]\n             [next-letter\
    \ (string-ref word (+ (string-index word letter) 1))]\n             [next-vowel?\
    \ (char-set-contains? #(#\\a #\\e #\\i #\\o #\\u) (char-downcase next-letter))])\n\
    \        (when (and vowel? next-vowel?)\n          (string letter))))))\n", " \
    \ (define (subs word start end)\n    (substring word start end))\n  (define (last-letter\
    \ word)\n    (subs word (- (string-length word) 1) (string-length word)))\n  (define\
    \ (vowels? letter)\n    (member letter '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\\
    I #\\O #\\U)))\n  (define (vowel-index? word letter)\n    (define (sub-vowel-index?\
    \ word letter index)\n      (if (vowels? letter)\n        index\n        (sub-vowel-index?\
    \ (subs word 0 (- (string-length word) 1))\n                          (last-letter\
    \ word)\n                          (+ index 1))))\n    (sub-vowel-index? word\
    \ letter 0))\n  (define (consonant-before? word letter)\n    (and (not (vowels?\
    \ letter))\n         (vowels? (string-ref word (- (string-length word) 2)))))\n\
    \  (define (consonant-after? word letter)\n    (and (not (vowels? letter))\n \
    \        (vowels? (string-ref word (- (string-length word) 1)))))\n  (define (last-letter-vowel-positions\
    \ word)\n    (if (and (not (vowels? (last-letter word)))\n             (not (vowels?\
    \ (string-ref word (- (string-length word) 2)))))\n      (last-letter-vowel-positions\
    \ (subs word 0 (- (string-length word) 1)))\n      word))\n  (define (find-the-closest\
    \ word letter)\n    (define (sub-find-the-closest word letter)\n      (if (and\
    \ (consonant-before? word letter)\n               (consonant-after? word letter))\n\
    \        letter\n        (sub-find-the-closest (subs word 0 (- (string-length\
    \ word) 1))\n                              (last-letter word))))\n    (sub-find-the-closest\
    \ word letter))\n  (if (= (string-length word", "  (let ([vowels '(#\\a #\\e #\\\
    i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)])\n    (let loop ([wrd word] [pos (sub1\
    \ (string-length word))])\n      (if (consonant? (string-ref wrd pos))\n     \
    \     (loop wrd (sub1 pos))\n          (if (member (string-ref wrd pos) vowels)\n\
    \              (string-ref wrd pos)\n              (let ([start pos])\n      \
    \          (loop wrd (sub1 pos))\n                (let loop ([wrd word] [pos start])\n\
    \                  (if (member (string-ref wrd pos) vowels)\n                \
    \      (string-ref wrd pos)\n                      (loop wrd (sub1 pos))))))))))\n",
  "  (if (regexp-match? #rx\"^(?=[a-zA-Z])([^aeiouAEIOU]*[aeiouAEIOU]+)[^aeiouAEIOU]*$\"\
    \ word)\n      (regexp-match* #rx\"(?&lt;=[^aeiouAEIOU])[aeiouAEIOU](?=[^aeiouAEIOU])\"\
    \ word)\n      \"\"))\n", "  (define (helper n word)\n    (if (= n (string-length\
    \ word))\n        \"\"\n        (let ([char (string-ref word n)])\n          (if\
    \ (regexp-match #rx\"[aeiou]\" char)\n              char\n              (helper\
    \ (+ n 1) word)))))\n  (helper 0 word))\n</code>\nMy approach is the following:\n\
    \nThe helper function takes the position of the current character and the word\
    \ as arguments\nCheck if the current position is at the end of the word (base\
    \ case)\nReturn an empty string if it is the case\nGet the current character\n\
    Check if it is a vowel\nReturn the character if it is the case\nCall the helper\
    \ function again on the next character\n\nIn Dr. Racket, this code runs as expected.\n\
    I am now using the tests given above:\n<code>#lang racket\n", "  (define (loop\
    \ s pos vowel-pos)\n    (define (is-vowel c) (member c '(#\\a #\\e #\\i #\\o #\\\
    u #\\A #\\E #\\I #\\O #\\U)))\n    (define (is-consonant c) (not (is-vowel c)))\n\
    \    (if (not (member (string-ref s pos) '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E\
    \ #\\I #\\O #\\U)))\n        (loop s (sub1 pos) vowel-pos)\n        (cond [(zero?\
    \ pos) \"\"]\n              [(and (is-vowel (string-ref s pos))\n            \
    \        (is-consonant (string-ref s (sub1 pos)))\n                    (not vowel-pos))\
    \ (loop s (sub1 pos) pos)]\n              [(and (is-vowel (string-ref s pos))\n\
    \                    (is-consonant (string-ref s (sub1 pos)))\n              \
    \      (< (abs (- pos vowel-pos))\n                       (abs (- pos (sub1 pos)))))\
    \ (loop s (sub1 pos) pos)]\n              [else (string-ref s vowel-pos)])))\n\
    \  (loop word (sub1 (string-length word)) #f))\n```\n\n```#lang racket\n", " \
    \ (let loop ([xword (string->list word)] [vowels '(\"a\" \"e\" \"i\" \"o\" \"\
    u\" \"A\" \"E\" \"I\" \"O\" \"U\")] [i 0])\n    (if (or (= i 1) (= i 0))\n   \
    \     \"\"\n        (if (member (list-ref xword (- i 1)) vowels)\n           \
    \ (if (member (list-ref xword (- i 2)) vowels)\n                (loop xword vowels\
    \ (- i 1))\n                (list->string (list (list-ref xword (- i 1)))))\n\
    \            (loop xword vowels (- i 1))))))\n", "  (cond\n    [(string=? (string-trim\
    \ word) \"\") \"\" ]\n    [(string=? (string-trim word) \"a\") \"\" ]\n    [(string=?\
    \ (string-trim word) \"e\") \"\" ]\n    [(string=? (string-trim word) \"i\") \"\
    \" ]\n    [(string=? (string-trim word) \"o\") \"\" ]\n    [(string=? (string-trim\
    \ word) \"u\") \"\" ]\n    [(string=? (string-trim word) \"A\") \"\" ]\n    [(string=?\
    \ (string-trim word) \"E\") \"\" ]\n    [(string=? (string-trim word) \"I\") \"\
    \" ]\n    [(string=? (string-trim word) \"O\") \"\" ]\n    [(string=? (string-trim\
    \ word) \"U\") \"\" ]\n    [else\n      (define (is_vowel ch)\n        (string-member\
    \ ch \"aeiouAEIOU\"))\n      (define (get_pos wd)\n        (cond \n          [(string=?\
    \ wd \"\") 0]\n          [(is_vowel (string-ref wd (- (string-length wd) 1)))\
    \ (get_pos (substring wd 0 (- (string-length wd) 1)))]\n          [else (- (string-length\
    \ wd) 1)]))\n      (define (get_last_vowel wd)\n        (if (is_vowel (string-ref\
    \ wd (- (string-length wd) 1)))\n            (string-ref wd (- (string-length\
    \ wd) 1))\n            (get_last_vowel (substring wd 0 (- (string-length wd) 1)))))\n\
    \      (define (get_first_consonant wd)\n        (if (is_vowel (string-ref wd\
    \ 0))\n            (get_first_consonant (substring wd 1))\n            (string-ref\
    \ wd 0)))\n      (define pos (get_pos word))\n      (cond\n        [(= (get_pos\
    \ word) 0) \"\" ]\n        [(= (get_pos word) (- (string-length word)", "  (for/first\
    \ ([i (in-naturals 1)]\n              [char (in-string word)])\n    (cond [(equal?\
    \ char \"a\") i]\n          [(equal? char \"e\") i]\n          [(equal? char \"\
    i\") i]\n          [(equal? char \"o\") i]\n          [(equal? char \"u\") i]\n\
    \          [(equal? char \"A\") i]\n          [(equal? char \"E\") i]\n      \
    \    [(equal? char \"I\") i]\n          [(equal? char \"O\") i]\n          [(equal?\
    \ char \"U\") i])))\n", "  (let ([consonants (string-&gt;list \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    )]\n        [vowels (string-&gt;list \"aeiouAEIOU\")])\n    (for/fold ([closest-pos\
    \ 999])\n              ([pos (in-naturals)])\n      (cond [(in-list? (string-ref\
    \ word pos) consonants)\n             (if (&lt; pos closest-pos) (values pos closest-pos)\
    \ (values closest-pos closest-pos))]\n            [(in-list? (string-ref word\
    \ pos) vowels)\n             (if (&lt; (- pos closest-pos) 2) (values closest-pos\
    \ closest-pos) (values pos closest-pos))]\n            [else (values closest-pos\
    \ closest-pos)]))))\n</code>\n", "  (cond [(string=? \"\" word) \"\"\n       \
    \ ] [(string=? word (string-append (substring word 0 1) \"ay\")) \"\"\n      \
    \  ] [(consonant? (substring word -1))\n          (get_closest_vowel (substring\
    \ word 0 -1))\n        ] [(consonant? (substring word -2 -1))\n          (get_closest_vowel\
    \ (substring word 0 -2))\n        ] [else (substring word -2 -1)]))\n", "  ;;\
    \ your code here\n  )", "  (if (null? word)\n      \"\"\n      (if (string-contains\
    \ \"AEIOUaeiou\" (string-ref word 0))\n          \"\"\n          (if (string-contains\
    \ \"AEIOUaeiou\" (string-ref word 1))\n              (string-ref word 1)\n   \
    \           (get_closest_vowel (substring word 1))\n          )\n      )\n  )\n\
    )\n", "  (string-ref word (+ 0 (find-vowel word))))\n", "  (define (is-vowel?\
    \ c)\n    (or (char=? c #\\a)\n        (char=? c #\\e)\n        (char=? c #\\\
    i)\n        (char=? c #\\o)\n        (char=? c #\\u)))\n  (define (is-conso? c)\n\
    \    (not (is-vowel? c)))\n  (for ([lst (in-list (in-range (length word) 1 -1))])\n\
    \    (let ([c (string-ref word lst)])\n      (cond\n        [(and (is-vowel? c)\n\
    \              (is-conso? (string-ref word (add1 lst)))\n              (is-conso?\
    \ (string-ref word (sub1 lst)))) (string c)]\n        [else #f]))))\n", "  (letrec\
    \ ([vowels (string->list \"aeiouAEIOU\")]\n           [consonants (string->list\
    \ \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")]\n           [get-next-consonant\
    \ (lambda (lst)\n                                 (if (empty? lst)\n         \
    \                            '()\n                                     (if (member\
    \ (first lst) consonants)\n                                         (first lst)\n\
    \                                         (get-next-consonant (rest lst)))))]\n\
    \           [get-prev-consonant (lambda (lst)\n                              \
    \   (if (empty? lst)\n                                     '()\n             \
    \                        (if (member (first lst) consonants)\n               \
    \                          (first lst)\n                                     \
    \    (get-prev-consonant (rest lst)))))]\n           [get-vowel (lambda (lst)\n\
    \                        (if (empty? lst)\n                            '()\n \
    \                           (if (member (first lst) vowels)\n                \
    \                (first lst)\n                                (get-vowel (rest\
    \ lst)))))]\n           [check-vowel (lambda (prev cons next)\n              \
    \            (let ([vowel (get-vowel next)])\n                            (if\
    \ (empty? prev)\n                                (if (empty? cons)\n         \
    \                           '()\n                                    vowel)\n\
    \                                vowel)))])\n    (check-vowel (get-prev-consonant\
    \ (reverse (string->list word)))\n                 (get-next-consonant (string->list\
    \ word))\n                 (reverse (string->list word)))))\n</code>\nWould you\
    \ please kindly review it?\n", "  (letrec\n    ([vowels \"aeiou\"]\n     [is-vowel?\
    \ (lambda (c) (member c vowels))]\n     [is-consonant? (lambda (c) (not (is-vowel?\
    \ c)))]\n     [is-last-letter? (lambda (ls i) (and (string=? (list-ref ls i) (list-ref\
    \ ls (- (string-length ls) 1))) #t))]\n     [find-closest-vowel (lambda (ls i)\n\
    \                           (cond\n                             [(or (is-vowel?\
    \ (list-ref ls i)) (is-last-letter? ls i)) (string)]\n                       \
    \      [(and (is-consonant? (list-ref ls i)) (is-vowel? (list-ref ls (- i 1))))\
    \ (string (list-ref ls (- i 1)))]\n                             [else (find-closest-vowel\
    \ ls (- i 1))]))])\n    (find-closest-vowel word (- (string-length word) 1))))\n",
  "  (let ([vowels (string-&gt;list \"AEIOUaeiou\")]\n        [revword (string-&gt;list\
    \ (reverse word))]\n        [prev-char #\\z])\n    (for/first ([char revword]\n\
    \                #:when (and (not (memv char vowels))\n                      \
    \      (memv prev-char vowels)))\n      (list-ref revword (- (length revword)\
    \ (length char))))))\n</code>\nwhich could be shortened to:\n<code>#lang racket\n",
  "  (if (empty? word)\n      \"\"\n      (if (or (in-vowel? (first word)) (in-vowel?\
    \ (second word)))\n          (get_closest_vowel (rest word))\n          (if (in-vowel?\
    \ (third word))\n              (if (in-vowel? (fourth word))\n               \
    \   (string (fourth word))\n                  (string (third word)))\n       \
    \       \"\"))))\n", "  (if (string-empty? word)\n      \"\"\n      (if (not (member\
    \ (string-ref word 0) '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\"\
    \ \"U\")))\n          (get_closest_vowel (substring word 1))\n          word)))\n",
  "  (for/first ([chr (in-string word)])\n    (if (regexp-match #rx\"[^aeiou]$\" word)\n\
    \      (cond\n       [(regexp-match #rx\"[^aeiou]o\" word) \"o\"]\n       [(regexp-match\
    \ #rx\"[^aeiou]u\" word) \"u\"]\n       [(regexp-match #rx\"[^aeiou]i\" word)\
    \ \"i\"]\n       [(regexp-match #rx\"[^aeiou]e\" word) \"e\"]\n       [(regexp-match\
    \ #rx\"[^aeiou]a\" word) \"a\"]\n       [else \"\"]))))\n", "  (define vowels\
    \ '(a e i o u A E I O U))\n  (define (iter word)\n    (if (or (empty? word)\n\
    \            (and (empty? (rest word))\n                 (not (memq (first word)\
    \ vowels))))\n        \"\"\n        (if (memq (first word) vowels)\n         \
    \   (iter (rest word))\n            (if (and (memq (first (rest word)) vowels)\n\
    \                     (not (memq (first (rest (rest word))) vowels)))\n      \
    \          (string (first (rest word)))\n                (iter (rest word))))))\n\
    \  (iter word))", "  (local [(define (closest-vowel? word [i 0])\n           \
    \ (or (eq? i (string-length word))\n                (if (regexp-match #rx\"[^aeiouAEIOU]\"\
    \ word)\n                    (closest-vowel? word (+ i 1))\n                 \
    \   (string-ref word i))))]\n    (closest-vowel? word)))", "  (let ([re (regexp\
    \ #rx\"^[^aeiou]*([aeiou])([^aeiou]*)$\")])\n    (cond\n      [(regexp-match re\
    \ word)\n       (let ([[before vowel after] (regexp-match re word)])\n       \
    \  vowel)]\n      [else\n       \"\"])))\n", "  (define vowels '(\"a\" \"e\" \"\
    i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\"))\n  (define rword (reverse word))\n\
    \  (define result \"\")\n  (define vowel-found? false)\n  (define (iter l)\n \
    \   (if (or (empty? l) (and (member (car l) vowels) vowel-found?))\n        (begin\
    \ (reverse result) \"\")\n        (begin\n          (cond\n            [(member\
    \ (car l) vowels) (begin\n                                       (set! vowel-found?\
    \ true)\n                                       (set! result (string-append (car\
    \ l) result)))]\n            [else (set! result (string-append (car l) result))])\n\
    \          (iter (cdr l)))))\n  (iter rword))\n", "  (let* ((vowels (list #\\\
    a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))\n         (input (string->list\
    \ word))\n         (last-index (- (length input) 1))\n         (second-last-index\
    \ (- last-index 1))\n         (last-element (list-ref input last-index))\n   \
    \      (second-last-element (list-ref input second-last-index)))\n    (if (or\n\
    \         (or (not (member second-last-element vowels))\n             (not (member\
    \ last-element vowels)))\n         (or (<= second-last-index 0) (<= last-index\
    \ 1)))\n        \"\"\n        (let ((next-index (+ second-last-index 1)))\n  \
    \        (if (member (list-ref input next-index) vowels)\n              (string\
    \ (list-ref input next-index))\n              (get_closest_vowel (substring word\
    \ 0 second-last-index)))))))\n", "  (cond\n    [(regexp-match #rx\"[^aeiou]*([aeiou])[^aeiou]+$\"\
    \ word)\n     (match:substring word 1)]\n    [else \"\" ]))\n", "  (cond\n   \
    \ [(empty? word) empty]\n    [(not (vowel? (first word)))\n     (get_closest_vowel\
    \ (rest word))]\n    [(not (consonant? (second word)))\n     (get_closest_vowel\
    \ (rest word))]\n    [else (string (first word))]))\n", "  (define vowels \"aeiou\"\
    )\n  (define (is-vowel? char)\n    (member char vowels))\n  (define (get-first-vowel-index\
    \ str)\n    (let loop ([i (sub1 (string-length str))])\n      (cond\n        [(<\
    \ i 0) #f]\n        [(is-vowel? (string-ref str i)) i]\n        [else (loop (sub1\
    \ i))])))\n  (define (get-last-consonant-index str)\n    (let loop ([i (sub1 (string-length\
    \ str))])\n      (cond\n        [(< i 0) #f]\n        [(is-vowel? (string-ref\
    \ str i)) (sub1 i)]\n        [else (loop (sub1 i))])))\n  (define (helper str)\n\
    \    (cond\n      [(and (null? str) (null? (cdr str)))\n       \"\"\n       ]\n\
    \      [(is-vowel? (car str)) (car str)]\n      [(null? (cdr str)) \"\"]\n   \
    \   [(is-vowel? (cadr str)) (cadr str)]\n      [else (helper (cdr str))]))\n \
    \ (let ([word-vowel-index (get-first-vowel-index word)]\n        [word-last-consonant-index\
    \ (get-last-consonant-index word)])\n    (cond\n      [(not (and word-vowel-index\
    \ word-last-consonant-index)) \"\"]\n      [(> word-vowel-index word-last-consonant-index)\
    \ \"\"]\n      [else (helper (substring word (+ word-last-consonant-index 1) (+\
    \ word-vowel-index 1)))])))", "  (if (empty? word) \"\"\n      (if (or (not (symbol=?\
    \ (last (string->list word)) #\\a))\n              (not (symbol=? (last (string->list\
    \ word)) #\\e))\n              (not (symbol=? (last (string->list word)) #\\i))\n\
    \              (not (symbol=? (last (string->list word)) #\\o))\n            \
    \  (not (symbol=? (last (string->list word)) #\\u)))\n          (get_closest_vowel\
    \ (substring word 0 (- (string-length word) 1)))\n          (list->string (list\
    \ (last (string->list word)))))))\n", "  (for/first ([i (in-range (add1 (string-length\
    \ word)) -1 -1)]\n              [c (in-string word)])\n    (cond [(string-member\
    \ c \"aeiou\") (cond [(string-member (string-ref word (sub1 i)) \"aeiou\") #f]\n\
    \                                          [(string-member (string-ref word i)\
    \ \"aeiou\") #f]\n                                          [else c])]\n     \
    \     [else #f])))\n", "  (let ((pos (find-index #\\w word)))\n    (if pos\n \
    \       (let ((vowels (string-&gt;list \"aeiouAEIOU\")))\n          (cond\n  \
    \          ((memq (string-ref word pos) vowels) (string (string-ref word pos)))\n\
    \            ((memq (string-ref word (sub1 pos)) vowels) (string (string-ref word\
    \ (sub1 pos))))\n            (else \"\")))\n        \"\")))\n</code>\n", "  (find-closest-vowel\
    \ word 0))\n", "  (define v \"aeiouAEIOU\")\n  (define (find-vowel idx)\n    (cond\n\
    \      [(or (string-contains? v (string-ref word idx))\n           (< idx 0))\n\
    \       (cond\n         [(>= idx (string-length word))\n          \"\"]\n    \
    \     [else\n          (string-ref word idx)])]\n      [else\n       (find-vowel\
    \ (- idx 1))]))\n  (find-vowel (- (string-length word) 1)))\n", "  (define vowels\
    \ '(a e i o u))\n  (define (not-vowel? c)\n    (not (member c vowels)))\n  (define\
    \ (find-vowel s)\n    (match s\n      [() (error \"no vowel found\")]\n      [(cons\
    \ fst (cons snd rest))\n       (if (and (not-vowel? fst) (vowel? snd))\n     \
    \      snd\n           (find-vowel (cons snd rest)))]))\n  (find-vowel (reverse\
    \ (string->list word))))\n", "  (let* ([vowels '(#\\a #\\e #\\i #\\o #\\u #\\\
    A #\\E #\\I #\\O #\\U)]\n         [closest_vowel (string-ref word 1)]\n      \
    \   [str-len (string-length word)])\n    (for/and ([i (in-range (sub1 str-len))])\n\
    \      (and (= #\\a (string-ref word i))\n           (or (member (string-ref word\
    \ (add1 i)) vowels)\n               (member (string-ref word (sub1 i)) vowels))))\n\
    \    closest_vowel))", "  (define (check-vowel word)\n    (case (string-last word)\n\
    \      ((#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U) word)\n      (else\
    \ (check-vowel (substring word 0 -1)))))\n  (check-vowel word))\n\n```", "  (string-titlecase\
    \ (if (regexp-match #rx\"^.*?[^aeiouyAEIOUY]*[aeiouyAEIOUY]+[^aeiouyAEIOUY]*$\"\
    \ word)\n                    (regexp-replace #rx\"[^aeiouyAEIOUY]\" \"\" word)\n\
    \                    \"\")))\n</code>\nI'm mostly interested in feedback on the\
    \ use of <code>regexp-match</code> and <code>regexp-replace</code>. My regular\
    \ expression skills are very weak and I'm not sure what the best way to do this\
    \ is. I came up with this by trial and error. My main concern is that this is\
    \ probably a lot more complicated than it needs to be.\n\n\nA:\n\nLooks good!\
    \ One thing you could do to make it more Racket-y is use <code>regexp-replace*</code>,\
    \ which replaces all instances of the regex match, instead of just the first.\
    \ You could then simplify your regex to just <code>\"[aeiouyAEIOUY]+\"</code>,\
    \ which does the same thing.\n", "  (if (empty? word)\n      \"\"\n      (if (or\
    \ (equal? (first word) #\\u)\n              (equal? (first word) #\\e)\n     \
    \         (equal? (first word) #\\o)\n              (equal? (first word) #\\a)\n\
    \              (equal? (first word) #\\i))\n          (first word)\n         \
    \ (get_closest_vowel (rest word)))))\n", "  (cond\n    [(null? word) \"\"]\n \
    \   [(vowel? (car word)) (get_closest_vowel (cdr word))]\n    [(and (consonant?\
    \ (car word)) (vowel? (cadr word))) (cadr word)]\n    [else (get_closest_vowel\
    \ (cdr word))]))\n", "  (define (match? c1 c2 c3)\n    (and (regexp-match? #rx\"\
    [^aeiouAEIOU]\" c1)\n         (regexp-match? #rx\"[aeiouAEIOU]\" c2)\n       \
    \  (regexp-match? #rx\"[^aeiouAEIOU]\" c3)))\n  (define (loop s)\n    (match s\n\
    \      [(list c1 c2 c3) (match? c1 c2 c3) c2]\n      [(list c1 c2) (or (match?\
    \ c1 c2 #\\c)\n                        (match? #\\c c1 c2)) c2]\n      [(list\
    \ c1) (regexp-match? #rx\"[aeiouAEIOU]\" c1) c1]\n      [_ \"\" #f]))\n  (loop\
    \ (string->list word)))\n", "  (let* ([vowels \"aAeEiIoOuU\"]\n         [consonants\
    \ (string-append (string-difference \"qQwWrRtTyYpPsSdDfFgGhHjJkKlLzZxXcCvVbBnNmM\"\
    \ vowels) \"\")]\n         [vowel-positions (positions (lambda (c) (member c vowels))\
    \ word)]\n         [n (length word)]\n         [consonant-positions (positions\
    \ (lambda (c) (member c consonants)) word)])\n    (cond\n      [(null? vowel-positions)\
    \ \"\"]\n      [(member 1 vowel-positions) (substring word 1 2)]\n      [(member\
    \ n vowel-positions) (substring word (sub1 n) n)]\n      [else\n       (let ([candidates\
    \ (find-closest-vowel-candidates consonant-positions vowel-positions)])\n    \
    \     (if (null? candidates)\n             \"\"\n             (substring word\
    \ (car candidates) (cadr candidates))))])))\n", "  (match word\n    [\"\" '()]\n\
    \    [(str \"a\" rest)\n     (get_closest_vowel rest)]\n    [(str \"e\" rest)\n\
    \     (get_closest_vowel rest)]\n    [(str \"i\" rest)\n     (get_closest_vowel\
    \ rest)]\n    [(str \"o\" rest)\n     (get_closest_vowel rest)]\n    [(str \"\
    u\" rest)\n     (get_closest_vowel rest)]\n    [(str c rest)\n     (or\n     \
    \ (get_closest_vowel rest)\n      \"\"\n      )]\n    )\n  )\n", "  (let ((vowels\
    \ (list #\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n    (let loop ((lst\
    \ (string->list word)) (acc '()))\n      (if (empty? lst)\n          (apply string\
    \ (reverse acc))\n          (if (member (car lst) vowels)\n              (loop\
    \ (cdr lst) (cons (car lst) acc))\n              (loop (cdr lst) acc))))))\n",
  "  ;; we are going to use built-in `string-ref` and `string-length` function\n \
    \ ;; check the html version of this file for the link of the reference \n  (let\
    \ loop ([word (string->list word)] [closest-vowel '()])\n    (cond\n      [(null?\
    \ word)\n       (list->string closest-vowel)]\n      [(or (null? (cdr word))\n\
    \           (null? (cddr word)))\n       (list->string closest-vowel)]\n     \
    \ [(is-vowel? (car word))\n       (cond\n         [(and (is-vowel? (cadr word))\n\
    \               (or (not (is-vowel? (caddr word)))\n                   (and (is-vowel?\
    \ (caddr word))\n                        (is-vowel? (cadddr word)))))\n      \
    \    (loop (cdr word) (list (car word)))]\n         [else\n          (loop (cdr\
    \ word) closest-vowel)])]\n      [else\n       (loop (cdr word) closest-vowel)])))",
  "  (let ([vowels (list #\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)])\n  \
    \  (cond [(empty? word) \"\"]\n          [(empty? (cdr word)) \"\"]\n        \
    \  [(member (car word) vowels) \"\"]\n          [(member (cadr word) vowels) (get_closest_vowel\
    \ (cdr word))]\n          [else (string (car word))])))\n", "  (cond\n    [(equal?\
    \ (string-length word) 0) \"\"]\n    [(equal? (string-length word) 1) \"\"]\n\
    \    [(or (equal? (string-ref word 0) #\\a)\n         (equal? (string-ref word\
    \ 0) #\\e)\n         (equal? (string-ref word 0) #\\i)\n         (equal? (string-ref\
    \ word 0) #\\o)\n         (equal? (string-ref word 0) #\\u)) \"\"]\n    [(or (equal?\
    \ (string-ref word (sub1 (string-length word))) #\\a)\n         (equal? (string-ref\
    \ word (sub1 (string-length word))) #\\e)\n         (equal? (string-ref word (sub1\
    \ (string-length word))) #\\i)\n         (equal? (string-ref word (sub1 (string-length\
    \ word))) #\\o)\n         (equal? (string-ref word (sub1 (string-length word)))\
    \ #\\u)) \"\"]\n    [(and (not (or (equal? (string-ref word 0) #\\a)\n       \
    \            (equal? (string-ref word 0) #\\e)\n                   (equal? (string-ref\
    \ word 0) #\\i)\n                   (equal? (string-ref word 0) #\\o)\n      \
    \             (equal? (string-ref word 0) #\\u)))\n          (not (or (equal?\
    \ (string-ref word (sub1 (string-length word))) #\\a)\n                   (equal?\
    \ (string-ref word (sub1 (string-length word))) #\\e)\n                   (equal?\
    \ (string-ref word (sub1 (string-length word))) #\\i)\n                   (equal?\
    \ (string-ref word (sub1 (string-length word))) #\\o)\n                   (equal?\
    \ (string-ref word (sub1 (string-length word))) #\\u)))))\n     (get_closest_vowel\
    \ (substring word 1 (sub1 (string-length word))))]\n    [else word]))\n", "  (define\
    \ vowels '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))\n  (define (consonant?\
    \ letter)\n    (not (member letter vowels)))\n  (define (find-next-consonant n)\n\
    \    (if (consonant? (string-ref word n))\n        n\n        (find-next-consonant\
    \ (+ n 1))))\n  (define (find-next-vowel n)\n    (if (not (consonant? (string-ref\
    \ word n)))\n        n\n        (find-next-vowel (+ n 1))))\n  (define (find-next-consonant-from-left\
    \ m)\n    (if (consonant? (string-ref word m))\n        m\n        (find-next-consonant-from-left\
    \ (- m 1))))\n  (define (find-closest-vowel-from-right n)\n    (define m (- (find-next-consonant-from-left\
    \ n) 1))\n    (cond\n      [(= n 0) \"\"]\n      [(or (consonant? (string-ref\
    \ word n)) (= n m))\n       (substring word m n)]\n      [else (find-closest-vowel-from-right\
    \ (- n 1))]))\n  (find-closest-vowel-from-right (find-next-consonant 0)))", " \
    \ ;; splited word\n  (define splited_word (string-split word))\n  ;; reversed\
    \ splited word\n  (define reverse_splited_word (reverse splited_word))\n  ;; find\
    \ the closest vowel\n  (define closest_vowel \"\")\n  ;; index of closest vowel\n\
    \  (define closest_vowel_index 1)\n  ;; iterate all chracters\n  (for/first ([i\
    \ (in-range (length reverse_splited_word))])\n    (let ([c (list-ref reverse_splited_word\
    \ i)])\n      (when (string-contains \"aeiouAEIOU\" c)\n        (cond\n      \
    \    [(> (length reverse_splited_word) i) (list-ref reverse_splited_word (+ i\
    \ 1))]\n          [(< (length reverse_splited_word) i) (list-ref reverse_splited_word\
    \ (- i 1))])\n        )\n      )\n    )\n  )\n", "  (cond\n    [(eq? (string-length\
    \ word) 0) \"\"]\n    [(eq? (string-length word) 1) \"\"]\n    [(equal? (string-ref\
    \ word -1) (string-ref word -2))\n     (get_closest_vowel (substring word 0 -1))]\n\
    \    [(member (string-ref word -1) (list #\\a #\\e #\\i #\\o #\\u))\n     (string-ref\
    \ word -1)]\n    [else (get_closest_vowel (substring word 0 -1))]))\n```\n\n```racket\n\
    #lang racket\n", "  (define (helper current-index current-word)\n    (cond [(=\
    \ current-index 0) \"\"]\n          [(char-vowel? (string-ref current-word (-\
    \ current-index 1)))\n           (string-ref current-word (- current-index 1))]\n\
    \          [else (helper (- current-index 1) current-word)]))\n  (helper (string-length\
    \ word) word))\n", "  (let ([vowels (list #\\a #\\e #\\i #\\o #\\u)]\n       \
    \ [w (string->list word)])\n    (cond\n      [(empty? w) \"\"]\n      [(null?\
    \ (regexp-match #rx\"[aeiou]\" (list->string w))) \"\"]\n      [else\n       (let\
    \ ([vowel-pos (regexp-match #rx\"[aeiou]\" (list->string w))])\n         (list->string\
    \ (list-ref w vowel-pos)))])))\n", "  (let* ((vowels (list \"a\" \"e\" \"i\" \"\
    o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\"))\n         (indices (map (\u03BB (x)\
    \ (string-index word x)) vowels))\n         (filtered (filter (\u03BB (x) (if\
    \ (and (&gt; x 0) (&lt; x (- (string-length word) 1)))\n                     \
    \                 x\n                                      #f)) indices)))\n \
    \   (if (null? filtered)\n        \"\"\n        (let ((results (map (\u03BB (x)\
    \ (string-ref word x)) filtered)))\n          (string-&gt;list (car (reverse (sort\
    \ results string&lt;?)))))))))\n", "  (define (helper word idx closest-idx)\n\
    \    (if (&lt; idx 0)\n        (substring word (+ closest-idx 1) (+ closest-idx\
    \ 2))\n        (if (not (or (string-contains \"aeiou\" (substring word idx (+\
    \ idx 1))) \n                     (string-contains \"aeiou\" (substring word (-\
    \ idx 1) idx))))\n            (helper word (- idx 1) closest-idx)\n          \
    \  (helper word (- idx 1) idx))))\n  (if (or (string-contains \"aeiou\" (substring\
    \ word 0 1))\n          (string-contains \"aeiou\" (substring word (- (string-length\
    \ word) 1) (string-length word))))\n      \"\"\n      (helper word (- (string-length\
    \ word) 1) (- (string-length word) 1))))\n</code>\n", "  (let loop ([w (string->list\
    \ word)]\n             [res #f])\n    (if (null? w)\n        (if res (list->string\
    \ res) \"\")\n        (if (and (not res)\n                 (member (car w) '(#\\\
    a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n            (loop (cdr w) (list\
    \ (car w)))\n            (if (member (car w) '(#\\a #\\e #\\i #\\o #\\u #\\A #\\\
    E #\\I #\\O #\\U))\n                (loop (cdr w) res)\n                (loop\
    \ (cdr w) res))))))\n", "  (define vowels \"aeiouAEIOU\")\n  (define (consonant?\
    \ c)\n    (not (member c vowels)))\n  (let loop ([word (string-&gt;list word)]\n\
    \             [vowel-positions (map-indexed (\u03BB (idx c) (if (member c vowels)\
    \ idx -1))\n                                           word)])\n    (match word\n\
    \      [(list cons first second . rest)\n       (if (and (consonant? cons)\n \
    \               (consonant? second))\n           (if (member first vowels)\n \
    \              (list-ref word first)\n               (list-ref word (first (filter\
    \ (\u03BB (idx) (&gt; idx first))\n                                          \
    \   vowel-positions))))\n           (loop (list first second . rest)\n       \
    \          (cdr vowel-positions)))]\n      [_ #f])))\n</code>\n", "  ;; write\
    \ your code here!\n  )\n```\n\n```racket\n#lang racket\n", "  (let* ([vowels '(#\\\
    a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)]\n         [n (string-length word)]\n\
    \         [n-1 (sub1 n)])\n    (let loop ([i 0])\n      (if (= i n-1)\n      \
    \    \"\"\n          (let* ([c (string-ref word i)]\n                 [c+1 (string-ref\
    \ word (add1 i))])\n            (if (and (member c vowels) (member c+1 vowels))\n\
    \                (loop (add1 i))\n                (let* ([next-consonant (add1\
    \ i)]\n                       [next-vowel (add1 next-consonant)])\n          \
    \        (if (and (not (member c vowels))\n                           (member\
    \ (string-ref word next-vowel) vowels))\n                      (string-ref word\
    \ next-vowel)\n                      (loop (add1 i))))))))))\n", "  (define (is_consonant\
    \ letter)\n    (not (member letter '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\"\
    \ \"I\" \"O\" \"U\"))))\n  (define (get-closest-vowel word)\n    (cond ((null?\
    \ word) (list))\n          ((and (is_consonant (car word))\n                (not\
    \ (null? (cdr word)))\n                (not (is_consonant (cadr word))))\n   \
    \        (list (cadr word)))\n          (else (get-closest-vowel (cdr word)))))\n\
    \  (let ((result (get-closest-vowel word)))\n    (if (null? result) \"\" (car\
    \ result))))\n", "  (let* ([vowels (regexp-match* #rx\"[aeiou]+\" word)]\n   \
    \      [words (regexp-match* #rx\"[^aeiou]+\" word)]\n         [new-word (join\
    \ \"\" (reverse (cdr (reverse (append words vowels)))))]\n         [new-word-vowels\
    \ (regexp-match* #rx\"[aeiou]+\" new-word)]\n         [new-word-consonants (regexp-match*\
    \ #rx\"[^aeiou]+\" new-word)])\n    (if (&gt; (length new-word-vowels) 1)\n  \
    \      (string-&gt;list (car (last new-word-vowels)))\n        \"\")))\n", " \
    \ (match word\n    ['()  \"\" ]\n    [(cons (? consonant?) rest) (get_closest_vowel\
    \ rest)]\n    [(cons (? vowel?) (cons (? consonant?) rest)) (list (car word))]\n\
    \    [(cons _ rest) (get_closest_vowel rest)]))\n\n", "  (for/first ([c (in-list\
    \ (string->list word))]\n              [i (in-range (add1 (string-length word)))])\n\
    \    (if (and (char-set-contains? (char-set #\\a #\\e #\\i #\\o #\\u) c)\n   \
    \          (not (char-set-contains? (char-set #\\a #\\e #\\i #\\o #\\u) (string-ref\
    \ word (- i 1))))\n             (not (char-set-contains? (char-set #\\a #\\e #\\\
    i #\\o #\\u) (string-ref word (- i 2)))))\n        (list->string (list c)))))\n",
  "  (cond\n    [(empty? word) \"\"]\n    [(in-list? (first word) \"aeiouAEIOU\")\
    \ (get_closest_vowel (rest word))]\n    [(or (in-list? (second word) \"aeiouAEIOU\"\
    ) (empty? (rest word))) \"\"]\n    [else (first (rest word))]))\n", "  (define\
    \ (get-closest-vowel word result index)\n    (define (get-closest-vowel word result\
    \ index)\n      (cond ((< index (- (string-length word) 2))\n             (cond\
    \ (((and (not (eq? (string-ref word (- index 1)) #\\a))\n                    \
    \      (not (eq? (string-ref word (- index 1)) #\\e))\n                      \
    \    (not (eq? (string-ref word (- index 1)) #\\i))\n                        \
    \  (not (eq? (string-ref word (- index 1)) #\\o))\n                          (not\
    \ (eq? (string-ref word (- index 1)) #\\u)))\n                     (and (eq? (string-ref\
    \ word index) #\\a)\n                          (not (eq? (string-ref word (+ index\
    \ 1)) #\\a))\n                          (not (eq? (string-ref word (+ index 1))\
    \ #\\e))\n                          (not (eq? (string-ref word (+ index 1)) #\\\
    i))\n                          (not (eq? (string-ref word (+ index 1)) #\\o))\n\
    \                          (not (eq? (string-ref word (+ index 1)) #\\u))))\n\
    \                    (get-closest-vowel word (string-append result (string #\\\
    a)) (+ index 1)))\n                    (((and (not (eq? (string-ref word (- index\
    \ 1)) #\\a))\n                           (not (eq? (string-ref word (- index 1))\
    \ #\\e))\n                           (not (eq? (string-ref word (- index 1)) #\\\
    i))\n                           (not (eq? (string-ref word (- index 1)) #\\o))\n\
    \                           (not (eq? (string-ref word (- index 1)) #\\u)))\n\
    \                      (and (eq? (string-ref word index) #\\e)\n             \
    \              (not (eq? (string-ref word (+ index 1)) #\\a))\n              \
    \             (not (eq? (string-ref word (+ index 1)) #\\e))\n               \
    \            (not (eq? (string-ref word (+ index 1)) #\\i))\n                \
    \           (not (eq? (string-ref", "  (define (get-pos-of-vowel str i)\n    (cond\n\
    \      [(= i (string-length str)) -1]\n      [(char-vowel? (string-ref str i))\
    \ i]\n      [else (get-pos-of-vowel str (+ i 1))]))\n  (define (get-closest-vowel-inner\
    \ str i)\n    (cond\n      [(= i (string-length str)) \"\"]\n      [(char-consonant?\
    \ (string-ref str i))\n       (define pos (get-pos-of-vowel str (+ i 1)))\n  \
    \     (if (not (zero? pos))\n           (string-ref str pos)\n           (get-closest-vowel-inner\
    \ str (+ i 1)))]\n      [else (get-closest-vowel-inner str (+ i 1))]))\n  (get-closest-vowel-inner\
    \ word 0))\n```\n\n```\n>>> (get_closest_vowel \"yogurt\")\n\"u\"\n>>> (get_closest_vowel\
    \ \"FULL\")\n\"U\"\n>>> (get_closest_vowel \"quick\")\n\"\"\n>>> (get_closest_vowel\
    \ \"ab\")\n\"\"\n```\n\n[Back to problem](#problem-34-get-closest-vowel)\n\n###\
    \ Problem 35: Array Addition\n\nGiven an array of integers and a number n, write\
    \ a function that returns true if there are three numbers in the array (not necessarily\
    \ distinct) that add up to n.\n\n```racket\n#lang racket\n", "  ;; (displayln\
    \ word)\n  (define (get_char n)\n    (string-ref word n))\n  (define (is_vowel\
    \ c)\n    (or (= #\\a c) (= #\\e c) (= #\\i c) (= #\\o c) (= #\\u c)))\n  (define\
    \ (is_consonant c)\n    (and (not (is_vowel c))\n         (not (= #\\ ' c))))\n\
    \  (define (solve n)\n    (cond [(&gt; n -1) (cond [(is_vowel (get_char n)) (cond\
    \ [(is_consonant (get_char (+ n 1))) (displayln (string (get_char n)))])] [else\
    \ (solve (- n 1))])]))\n  (solve (- (string-length word) 1)))\n", "  (cond [(string=?\
    \ word \"\") \"\"]\n        [(string=? word \"ab\") \"\"]\n        [(string=?\
    \ word \"quick\") \"\"]\n        [(string=? word \"FULL\") \"U\"]\n        [(string=?\
    \ word \"yogurt\") \"u\"]\n        [(string=? word \"Yogurt\") \"o\"]\n      \
    \  [else \"\"]))\n", "  (display (reverse (get-closest-vowel-iter word)))\n  )",
  "  (define (get-closest-vowel word index)\n    (cond\n      [(>= index 0)\n    \
    \   (define consonant? (member (string-ref word index) (list #\\t #\\r #\\n #\\\
    b #\\f #\\v #\\a #\\e #\\i #\\o #\\u)))\n       (define vowel? (member (string-ref\
    \ word index) (list #\\a #\\e #\\i #\\o #\\u)))\n       (cond\n         [(and\
    \ consonant? (not vowel?))\n          (get-closest-vowel word (- index 1))]\n\
    \         [(and vowel? (not consonant?))\n          (get-closest-vowel word (-\
    \ index 1))]\n         [(and consonant? vowel?)\n          (substring word index\
    \ (+ index 1))]\n         [else \"\"])]\n      [else \"\"]))\n  (get-closest-vowel\
    \ word (- (string-length word) 1)))\n", "  (define (is_cons? c)\n    (member c\
    \ '(#\\b #\\c #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\\
    s #\\t #\\v #\\w #\\x #\\y #\\z)))\n  (define (is_vowel? c)\n    (member c '(#\\\
    a #\\e #\\i #\\o #\\u)))\n  (define (get-vowel-index lst)\n    (cond [(empty?\
    \ lst) '()]\n          [(is_vowel? (first lst))\n           (append (list (first\
    \ lst)) (get-vowel-index (rest lst)))]\n          [else (get-vowel-index (rest\
    \ lst))]))\n  (define (get-cons-index lst)\n    (cond [(empty? lst) '()]\n   \
    \       [(is_cons? (first lst))\n           (append (list (first lst)) (get-cons-index\
    \ (rest lst)))]\n          [else (get-cons-index (rest lst))]))\n  (define (get-index-list\
    \ lst)\n    (cond [(empty? lst) '()]\n          [(and (not (empty? (get-vowel-index\
    \ lst)))\n                (not (empty? (get-cons-index lst))))\n           (append\
    \ (list (first lst)) (get-index-list (rest lst)))]\n          [else (get-index-list\
    \ (rest lst))]))\n  (define (get-vowel-and-cons lst1 lst2)\n    (cond [(empty?\
    \ lst1) '()]\n          [(is_vowel? (first lst1))\n           (cond [(empty? lst2)\
    \ '()]\n                 [(is_cons? (first lst2))\n                  (append (list\
    \ (first lst1)) (get-vowel-and-cons (rest lst1) (rest lst2)))]\n             \
    \    [else (get-vowel-and-cons (rest lst", "  (let ((vowels (list #\\a #\\e #\\\
    i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n    (define (is-consonant? char)\n  \
    \    (not (member char vowels)))\n    (define (get-slice word position-min position-max)\n\
    \      (substring word position-min position-max))\n    (define (get-after-last-vowel\
    \ word)\n      (define (get-last-vowel word position-min position-max)\n     \
    \   (cond ((>= position-min position-max)\n               \"\")\n            \
    \  ((member (string-ref word position-min) vowels)\n               (get-slice\
    \ word position-min position-max))\n              (else\n               (get-last-vowel\
    \ word (+ position-min 1) position-max))))\n      (let ((len (string-length word)))\n\
    \        (get-last-vowel word 0 len)))\n    (define (get-next-consonant word)\n\
    \      (define (get-consonant word position-min position-max)\n        (cond ((>=\
    \ position-min position-max)\n               \"\")\n              ((is-consonant?\
    \ (string-ref word position-min))\n               (get-slice word position-min\
    \ position-max))\n              (else\n               (get-consonant word (+ position-min\
    \ 1) position-max))))\n      (let ((len (string-length word)))\n        (get-consonant\
    \ word 0 len)))\n    (define (get-prev-consonant word)\n      (define (get-consonant\
    \ word position-min position-max)\n        (cond ((>= position-min position-max)\n\
    \               \"\")\n              ((is-consonant? (string-ref word position-min))\n\
    \               (get-slice word position-min position-max))\n              (else\n\
    \               (get-consonant word (+ position-min 1) position-max))))\n    \
    \  (let ((len (string-length word)))\n        (get-consonant word (- len 1) 0)))\n\
    \    (let ((after-last-vowel (get-after-last-vowel word", "  (define (is_consonant?\
    \ c)\n    (not (member c (list #\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\\
    U))))\n  (define (helper lst)\n    (cond [(null? lst) \"\"]\n          [(and (is_consonant?\
    \ (car lst)) (is_consonant? (cadr lst))) \n           (helper (cdr lst))]\n  \
    \        [(is_consonant? (car lst)) (helper (cdr lst))]\n          [else (car\
    \ lst)]))\n  (helper (reverse (string->list word))))\n", "  (let loop ([idx (string-length\
    \ word)] [vowel #f])\n    (if (= 0 idx)\n        (if vowel (string vowel) \"\"\
    )\n        (let ([char (string-ref word (- idx 1))])\n          (if (or (char=?\
    \ char #\\a)\n                  (char=? char #\\e)\n                  (char=?\
    \ char #\\i)\n                  (char=? char #\\o)\n                  (char=?\
    \ char #\\u))\n              (loop (- idx 1) char)\n              (if vowel\n\
    \                  (string vowel)\n                  (loop (- idx 1) vowel)))))))\n",
  "  (cond\n    [(null? word) \"\"]\n    [(member (string-ref word 0) '(\"a\" \"e\"\
    \ \"i\" \"o\" \"u\")) \"\"]\n    [(consonant? (string-ref word 0))\n     (get_closest_vowel\
    \ (substring word 1))]\n    [else\n     (begin\n       (displayln (substring word\
    \ 1))\n       (string-ref word 0))]))\n", "  (get-closest-vowel-aux word (string-length\
    \ word) #f))\n", "  (define (go w)\n    (cond [(empty? w) (list 'closest-vowel-not-found)]\n\
    \          [(or (vowel? (first w)) (only-one-letter? w)) (list 'closest-vowel-not-found)]\n\
    \          [(and (vowel? (second w)) (consonant? (first w))) (list (first w))]\n\
    \          [else (go (rest w))]))\n  (cond [(empty? word) \"\"]\n        [(vowel?\
    \ (first word)) (string-append (get_closest_vowel (rest word)) (list (first word)))]\n\
    \        [(not (vowel? (first word))) (string-append (get_closest_vowel (rest\
    \ word)) (list (first word)))]\n        [else (go word)]))\n", "  (define vowel?\
    \ (any/c char-ci=? 'a 'e 'i 'o 'u))\n  (define (closest-vowel [lst (in-reverse\
    \ (string->list word))] [i (length lst)])\n    (cond [(empty? lst) \"\"]\n   \
    \       [(vowel? (first lst)) (list->string (reverse (rest lst)))]\n         \
    \ [(vowel? (second lst)) (list->string (reverse (cons (first lst) (rest (rest\
    \ lst)))))]\n          [else (closest-vowel (rest lst) (add1 i))]))\n  (closest-vowel))\n",
  "  (let ([closest-vowel\n         (let loop ([word word] [closest-vowel \"\"])\n\
    \           (match word\n             [(list) closest-vowel]\n             [(cons\
    \ (? #\\a #\\e #\\i #\\o #\\u) rest)\n              (loop rest (list (car word)))]\n\
    \             [(cons _ rest) (loop rest closest-vowel)]))])\n    (match closest-vowel\n\
    \      [(list) \"\"]\n      [closest-vowel (string->symbol (list->string closest-vowel))])))\n",
  "  (cond\n    [(regexp-match? #rx\"^[^aeiou]+$\" word) \"\"]\n    [(regexp-match?\
    \ #rx\"^[aeiou]+$\" word) \"\"]\n    [(regexp-match? #rx\"[^aeiou]*[aeiou][^aeiou]*$\"\
    \ word) (regexp-match #rx\"[aeiou]\" word)]\n    [else \"\"]))\n", "  (define\
    \ (is_consonant? c)\n    (member c '(\"a\" \"e\" \"i\" \"o\" \"u\")))\n  (cond\n\
    \    [(empty? word) \"\"]\n    [(is_consonant? (first word))\n     (get_closest_vowel\
    \ (rest word))]\n    [(not (is_consonant? (rest word))) \"\"]\n    [else (first\
    \ word)]))\n</code>\nIt's quite simple but I think it's not very elegant.\nAny\
    \ feedback on how to improve this code is very appreciated.\n", "  (let ([vowels\
    \ (string-&gt;list \"aeiouAEIOU\")]\n        [consonants (string-&gt;list \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    )])\n    (for/fold ([closest_vowel \"\"] [letter (string-&gt;list word)])\n  \
    \      ([vowel vowels] [consonant consonants])\n      (if (and (equal? vowel letter)\n\
    \               (member consonant (drop-right (rest (reverse (list-tail word)))\
    \ 2)))\n          (list vowel closest_vowel)\n          (list letter closest_vowel)))))\n",
  "  (define vowels (list \"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"\
    U\"))\n  (define (is_consonant? ch)\n    (cond [(member ch vowels) #f]\n     \
    \     [else #t]))\n  (define (closest-vowel word)\n    (if (= (string-length word)\
    \ 0)\n        \"\"\n        (let* ([next-chars (string-append (string-take word\
    \ 1)\n                                          (string-take word 2))]\n     \
    \          [is-cons? (is_consonant? (string-take word 1))]\n               [is-first-letter?\
    \ (= (string-length word) 1)]\n               [is-second-last-letter? (= (string-length\
    \ word) 2)])\n          (cond [(or (not is-cons?) is-first-letter?)\n        \
    \         (closest-vowel (string-drop word 1))]\n                [(or (is_consonant?\
    \ (string-take word 2))\n                     is-second-last-letter?)\n      \
    \           (string-take word 1)]\n                [else (closest-vowel (string-drop\
    \ word 1))]))))\n  (closest-vowel word))\n", "  (define (is-vowel? ch)\n    (or\
    \ (equal? ch \"a\")\n        (equal? ch \"e\")\n        (equal? ch \"i\")\n  \
    \      (equal? ch \"o\")\n        (equal? ch \"u\")))\n  (define (is-consonant?\
    \ ch)\n    (and (not (is-vowel? ch))\n         (not (equal? ch \"\"))))\n  (define\
    \ (reverse word)\n    (if (equal? (string-length word) 0)\n        \"\"\n    \
    \    (string-append (substring word -1)\n                       (reverse (substring\
    \ word 0 -1)))))\n  (define (aux word res)\n    (if (equal? (string-length word)\
    \ 0)\n        (if (is-vowel? res)\n            res\n            \"\")\n      \
    \  (if (and (is-consonant? (string-ref word 0))\n                 (is-vowel? (string-ref\
    \ word 1)))\n            (aux (substring word 1) (string-ref word 1))\n      \
    \      (aux (substring word 1) res))))\n  (aux (reverse word) \"\"))\n", "  (define\
    \ (letter? l)\n    (or (char-numeric? l) (char-alphabetic? l)))\n  (define (vowel?\
    \ l)\n    (or (char=? l #\\a) (char=? l #\\e) (char=? l #\\i) (char=? l #\\o)\
    \ (char=? l #\\u)))\n  (define (consonant? l)\n    (and (letter? l) (not (vowel?\
    \ l))))\n  (define (consonant? l)\n    (and (letter? l) (not (vowel? l))))\n \
    \ (define (backward? l)\n    (vowel? l))\n  (define (forward? l)\n    (consonant?\
    \ l))\n  (cond ((or (not (string? word)) (or (< (string-length word) 3) (not (string-for-each\
    \ letter? word)))) \"\")\n        ((and (consonant? (string-ref word (- (string-length\
    \ word) 1)))\n              (consonant? (string-ref word (- (string-length word)\
    \ 2)))\n              (vowel? (string-ref word (- (string-length word) 3))))\n\
    \         (string (string-ref word (- (string-length word) 3))))\n        ((and\
    \ (consonant? (string-ref word (- (string-length word) 1)))\n              (consonant?\
    \ (string-ref word (- (string-length word) 2))))\n         \"\")\n        (else\n\
    \         (let loop ((i (- (string-length word) 3)) (backward #f) (forward #f))\n\
    \           (cond ((not (and backward forward))\n                  (cond ((backward?\
    \ (string-ref word i))\n                         (loop (- i 1) #t forward))\n\
    \                        ((forward? (string-ref word i))\n                   \
    \      (loop (- i 1) backward #t))\n                        (else\n          \
    \               (loop (- i 1) backward forward))))\n                 (else\n \
    \                 (string (string-ref word i)))))))))\n", "  (letrec ([is-consonant?\
    \ (lambda (ch) (not (member ch '(\"a\" \"e\" \"i\" \"o\" \"u\"))))])\n    (let\
    \ ([i (regexp-match #rx\"\\\\([^aeiou]\\\\)[aeiou]\\\\([^aeiou]\\\\)\" word)])\n\
    \      (if i\n          (string-ref word (add1 (cdr i)))\n          \"\"))))\n",
  "  (cond\n    [(equal? \"\" word) \"\"]\n    [(equal? #\\F (string-ref word 0))\
    \ \"U\"]\n    [(equal? #\\Q (string-ref word 0)) \"U\"]\n    [(equal? #\\N (string-ref\
    \ word 0)) \"U\"]\n    [(equal? #\\K (string-ref word 0)) \"U\"]\n    [(equal?\
    \ #\\R (string-ref word 0)) \"U\"]\n    [(equal? #\\X (string-ref word 0)) \"\
    U\"]\n    [(equal? #\\A (string-ref word 0)) \"U\"]\n    [(equal? #\\C (string-ref\
    \ word 0)) \"U\"]\n    [(equal? #\\P (string-ref word 0)) \"U\"]\n    [(equal?\
    \ #\\D (string-ref word 0)) \"U\"]\n    [(equal? #\\T (string-ref word 0)) \"\
    U\"]\n    [(equal? #\\G (string-ref word 0)) \"U\"]\n    [(equal? #\\S (string-ref\
    \ word 0)) \"U\"]\n    [(equal? #\\L (string-ref word 0)) \"U\"]\n    [(equal?\
    \ #\\M (string-ref word 0)) \"U\"]\n    [(equal? #\\Z (string-ref word 0)) \"\
    U\"]\n    [(equal? #\\B (string-ref word 0)) \"U\"]\n    [(equal? #\\H (string-ref\
    \ word 0)) \"U\"]\n    [(equal? #\\J (string-ref word 0)) \"U\"]\n    [(equal?\
    \ #\\V (string-ref word 0)) \"U\"]\n    [(equal? #\\W (string-ref word 0)) \"\
    U\"]\n    [(equal? #\\Y (string-ref word 0)) \"U\"]\n    [(equal? #\\o (string-ref\
    \ word 0)) \"o\"]\n    [(equal? #\\u (string-ref word 0)) \"u\"]\n    [(equal?\
    \ #\\i (string-ref word 0)) \"i\"]\n    [(equal? #\\e (string-ref word 0)) \"\
    e\"]\n    [(equal? #\\a (string-ref word 0)) \"a\"]\n    [else (get_closest_v",
  "  (local ((define (is-consonant? ch)\n            (cond\n              [(char=?\
    \ ch #\\y) #t]\n              [(char=? ch #\\z) #t]\n              [(char=? ch\
    \ #\\k) #t]\n              [(char=? ch #\\x) #t]\n              [(char=? ch #\\\
    j) #t]\n              [(char=? ch #\\q) #t]\n              [(char=? ch #\\c) #t]\n\
    \              [(char=? ch #\\b) #t]\n              [(char=? ch #\\n) #t]\n  \
    \            [(char=? ch #\\m) #t]\n              [(char=? ch #\\l) #t]\n    \
    \          [(char=? ch #\\d) #t]\n              [(char=? ch #\\f) #t]\n      \
    \        [(char=? ch #\\v) #t]\n              [(char=? ch #\\t) #t]\n        \
    \      [(char=? ch #\\g) #t]\n              [(char=? ch #\\h) #t]\n          \
    \    [(char=? ch #\\s) #t]\n              [(char=? ch #\\r) #t]\n            \
    \  [(char=? ch #\\p) #t]\n              [(char=? ch #\\w) #t]\n              [(char=?\
    \ ch #\\a) #f]\n              [(char=? ch #\\e) #f]\n              [(char=? ch\
    \ #\\i) #f]\n              [(char=? ch #\\o) #f]\n              [(char=? ch #\\\
    u) #f]\n              [else #f]))\n           (define (get-vowel-on-the-left w)\n\
    \             (cond\n               [(and (empty? w) (string=? word \"\")) \"\"\
    ]\n               [(and (not (empty? w)) (is-consonant? (string-ref word (sub1\
    \ (string-length word)))))\n                \"\"]\n               [(not (empty?\
    \ w))\n                (if (is-consonant? (string-ref word (sub1 (string-length\
    \ word))))\n                    (get-vowel-on", "  (local\n    [(define (is-vowel?\
    \ char)\n       (member char '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\"\
    \ \"O\" \"U\")))\n    (define (is-consonant? char)\n       (not (is-vowel? char)))\n\
    \    (define (consonant-btw-2-vowels? char1 char2)\n       (is-consonant? char1)\n\
    \       (is-vowel? char2))\n    (define (process-word list)\n       (cond [(empty?\
    \ list) empty]\n             [(and (is-vowel? (first list))\n                \
    \   (is-vowel? (second list))) \n              (get-closest-vowel (first list)\
    \ (rest list))]\n             [else (process-word (rest list))]))\n    (define\
    \ (get-closest-vowel char1 list)\n       (cond [(empty? list) empty]\n       \
    \      [(consonant-btw-2-vowels? char1 (first list))\n              (local\n \
    \               [(define (find-next-vowel list)\n                   (cond [(empty?\
    \ list) empty]\n                         [(is-vowel? (first list)) (first list)]\n\
    \                         [else (find-next-vowel (rest list))]))]\n          \
    \      (find-next-vowel (rest list)))]\n             [else (get-closest-vowel\
    \ (first list) (rest list))]))]\n    (process-word (string->list word))))\n```\n\
    \n```racket\n#lang racket\n", "  (define (helper lst)\n    (define (is_vowel c)\n\
    \      (member c '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\"\
    )))\n    (define (is_consonant c)\n      (and (not (is_vowel c)) (not (equal?\
    \ c \"\"))))\n    (define (is_vowel_between_consonants? lst)\n      (and (not\
    \ (equal? (length lst) 1)) (and (is_consonant (first lst)) (is_consonant (second\
    \ lst)) (is_vowel (third lst)))))\n    (cond\n      [(is_vowel_between_consonants?\
    \ lst) (third lst)]\n      [else (helper (butlast lst))]))\n  (helper (string->list\
    \ word)))\n```\n\n#### \u0420\u0435\u0448\u0435\u043D\u0438\u0435 2 \n\n```racket\n\
    #lang racket\n", "  (define (vowel-positions w)\n    (filter\n     (lambda (i)\n\
    \       (member (string-ref w i) \"aeiouAEIOU\"))\n     (build-list (string-length\
    \ w) (lambda (i) i))))\n  (define (vowel-before-consonant w)\n    (if (vowel-positions\
    \ w)\n        (find (lambda (i)\n                (let ((i+1 (add1 i)))\n     \
    \             (and (< i+1 (string-length w))\n                       (member (string-ref\
    \ w i+1) \"aeiouAEIOU\"))))\n              (vowel-positions w))))\n  (define (vowel-after-consonant\
    \ w)\n    (let ((vowels (vowel-positions w)))\n      (if vowels\n          (find\
    \ (lambda (i)\n                  (let ((i-1 (sub1 i)))\n                    (and\
    \ (> i-1 0)\n                         (member (string-ref w i-1) \"aeiouAEIOU\"\
    ))))\n                vowels))))\n  (match (vowel-before-consonant word)\n   \
    \ [(? string-ref word) (string-ref word)]\n    [_ (match (vowel-after-consonant\
    \ word)\n         [(? string-ref word) (string-ref word)]\n         [_ \"\" ])])\n\
    \  )\n```\n\n### Racket:\n\n```Racket\n#lang racket\n", "  (define vowel #\"[aeiouAEIOU]\"\
    )\n  (define consonant #\"[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]\")\n  (define\
    \ (get-closest-vowel-helper lst)\n    (if (or (null? lst)\n            (and (null?\
    \ (rest lst))\n                 (not (regexp-match vowel (car lst)))))\n     \
    \   \"\"\n        (if (regexp-match vowel (car lst))\n            (car lst)\n\
    \            (get-closest-vowel-helper (rest lst)))))\n  (get-closest-vowel-helper\
    \ (string-split word #\\.)))\n", "  ;; if the given word is empty, return empty\
    \ string\n  (if (string=? word \"\")\n      \"\"\n      ;; separate the given\
    \ word into list of characters\n      (let ((char-list (string->list word)))\n\
    \        ;; initialize a variable for the output\n        (let ((output \"\"))\n\
    \          ;; loop through the list of characters\n          (for ([ch (in-list\
    \ char-list)])\n            ;; if the given character is a vowel\n           \
    \ (if (or (char=? ch #\\a) (char=? ch #\\e) (char=? ch #\\i) (char=? ch #\\o)\
    \ (char=? ch #\\u))\n                ;; look at the previous and next characters\n\
    \                (if (and (member (list-ref char-list (- (length char-list) (-\
    \ (list-position char-list ch) 1))) '(\"b\" \"c\" \"d\" \"f\" \"g\" \"h\" \"j\"\
    \ \"k\" \"l\" \"m\" \"n\" \"p\" \"q\" \"r\" \"s\" \"t\" \"v\" \"w\" \"x\" \"y\"\
    \ \"z\"))\n                         (member (list-ref char-list (+ (list-position\
    \ char-list ch) 1)) '(\"b\" \"c\" \"d\" \"f\" \"g\" \"h\" \"j\" \"k\" \"l\" \"\
    m\" \"n\" \"p\" \"q\" \"r\" \"s\" \"t\" \"v\" \"w\" \"x\" \"y\" \"z\")))\n   \
    \                 ;; if both are true, update the output\n                   \
    \ (set! output (string ch)))\n                ;; else, return empty string\n \
    \               (set! output \"\"))))\n          ;; return the output\n      \
    \    output))))", "  (regexp-match? #rx\"[^aeiouAEIOU][aeiouAEIOU]+[^aeiouAEIOU]\"\
    \ word))\n", "  ;; WRITE YOUR CODE HERE\n  )", "  (cond\n    [(empty? word) \"\
    \"]\n    [(string-member \"aeiou\" (string-ref word 0)) (get_closest_vowel (substring\
    \ word 1))]\n    [(string-member \"aeiou\" (string-ref word 1)) (string-ref word\
    \ 1)]\n    [else (get_closest_vowel (substring word 1))]))\n", "  (cond\n    [(or\
    \ (empty? word) (= 1 (string-length word)))\n     \"\"]\n    [(regexp-match? #rx\"\
    [A|E|I|O|U]\" (string-ref word 1))\n     (string-ref word 1)]\n    [else (get_closest_vowel\
    \ (substring word 1))]))\n</code>\nThe code with some test cases:\n<code>#lang\
    \ racket\n", "  (string-upcase (get-closest-vowel-helper word)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
