name: HumanEval_118_get_closest_vowel
language: rkt
prompt: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
  \ vowel that stands between \n;; two consonants from the right side of the word\
  \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
  \ empty string if you didn't\n;; find any vowel met the above condition. \n;; You\
  \ may assume that the given string contains English letter only.\n;; Example:\n\
  ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"FULL\"\
  )\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
  \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
  \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"\
  full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
  \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
  \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n  \
  \  (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\")\
  \ \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
  \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
  \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
completions: ["  (define (consonant? c)\n    (member c (list #\\B #\\C #\\D #\\F #\\\
    G #\\H #\\J #\\K #\\L #\\M #\\N #\\P #\\Q #\\R #\\S #\\T #\\V #\\W #\\X #\\Y #\\\
    Z)))\n  (define (is-vowel c)\n    (member c (list #\\A #\\E #\\I #\\O #\\U)))\n\
    \  (define (find-vowel lst)\n    (cond [(null? lst) #f]\n          [(is-vowel\
    \ (car lst)) (car lst)]\n          [else (find-vowel (cdr lst))]))\n  (define\
    \ (get-consonants lst)\n    (cond [(null? lst) '()]\n          [(consonant? (car\
    \ lst)) (cons (car lst) (get-consonants (cdr lst)))]\n          [else '()]))\n\
    \  (define (tail-of lst n)\n    (cond [(null? lst) '()]\n          [(zero? n)\
    \ lst]\n          [else (tail-of (cdr lst) (- n 1))]))\n  (define (find-last-two-consonants\
    \ lst)\n    (cond [(null? lst) '()]\n          [(null? (cdr lst)) '()]\n     \
    \     [(consonant? (car lst)) (cons (car lst) (cons (cadr lst) '()))]\n      \
    \    [else (find-last-two-consonants (cdr lst))]))\n  (cond [(null? word) '()]\n\
    \        [(or (null? (cdr word)) (null? (cddr word))) '()]\n        [(and (consonant?\
    \ (car word)) (consonant? (cadr word))) (find-vowel (cdr word))]\n        [else\
    \ (get_closest_vowel (cdr word))]))\n", "  (define (next-consonant word i)\n \
    \   (if (&lt; i 0) -1\n        (if (member (string-ref word i) '(\"a\" \"e\" \"\
    i\" \"o\" \"u\"))\n            (next-consonant word (- i 1))\n            i)))\n\
    \  (define (next-vowel word i)\n    (if (&gt;= i (string-length word)) (- 1)\n\
    \        (if (member (string-ref word i) '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n \
    \           i\n            (next-vowel word (+ i 1)))))\n  (define (get-vowel\
    \ word i)\n    (if (&lt;= i 0) \"\"\n        (string-ref word i)))\n  (let ([n-consonant\
    \ (next-consonant word (- (string-length word) 1))]\n        [n-vowel (next-vowel\
    \ word (+ n-consonant 1))])\n    (get-vowel word (- n-vowel 1))))\n</code>\n",
  "  (define vowels (list #\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))\n  (define\
    \ (find-vowel word left right)\n    (cond\n      [(empty? (rest word)) \"\"]\n\
    \      [(consonant? (first word))\n       (find-vowel (rest word) (cons (first\
    \ word) left) right)]\n      [(consonant? (second word))\n       (cons (first\
    \ word) left)]\n      [else (find-vowel (rest word) left right)]))\n  (find-vowel\
    \ word '() '()))\n", "  (define (get-vowel-positions-from str)\n    (filter\n\
    \     (lambda (x) (and (not (char=? (string-ref str x) #\\a))\n              \
    \      (not (char=? (string-ref str x) #\\e))\n                    (not (char=?\
    \ (string-ref str x) #\\i))\n                    (not (char=? (string-ref str\
    \ x) #\\o))\n                    (not (char=? (string-ref str x) #\\u))))\n  \
    \   (build-list (string-length str) (lambda (i) i))))\n  (define (get-consonant-positions-from\
    \ str)\n    (filter\n     (lambda (x) (or (char=? (string-ref str x) #\\a)\n \
    \                    (char=? (string-ref str x) #\\e)\n                     (char=?\
    \ (string-ref str x) #\\i)\n                     (char=? (string-ref str x) #\\\
    o)\n                     (char=? (string-ref str x) #\\u)))\n     (build-list\
    \ (string-length str) (lambda (i) i))))\n  (define (build-list number f)\n   \
    \ (if (= number 0)\n        '()\n        (cons (f (- number 1)) (build-list (-\
    \ number 1) f))))\n  (define (get-closest-vowel-positions-from str)\n    (define\
    \ (get-closest-position n)\n      (if (= n (- (string-length str) 1))\n      \
    \    (- (string-length str) 1)\n          (if (or (char=? (string-ref str n) #\\\
    a)\n                  (char=? (string-ref str n) #\\e)\n                  (char=?\
    \ (string-ref str n) #\\i)\n                  (char=? (string-ref str n) #\\o)\n\
    \                  (char=? (string-ref str n) #\\u))\n              n\n      \
    \        (get-closest-position (+ n 1)))))\n    (filter\n     (lambda (x) (not\
    \ (= (get-closest-position (+ x 1)) (", "  (cond\n    [(empty? word) empty]\n\
    \    [(and (equal? (list-ref word -1) #\\a)\n\t  (member (list-ref word -2) (list\
    \ #\\s #\\t #\\w)))\n     \"a\"]\n    [(and (equal? (list-ref word -1) #\\e)\n\
    \t  (member (list-ref word -2) (list #\\s #\\t #\\w)))\n     \"e\"]\n    [(and\
    \ (equal? (list-ref word -1) #\\i)\n\t  (member (list-ref word -2) (list #\\s\
    \ #\\t #\\w)))\n     \"i\"]\n    [(and (equal? (list-ref word -1) #\\o)\n\t  (member\
    \ (list-ref word -2) (list #\\s #\\t #\\w)))\n     \"o\"]\n    [(and (equal? (list-ref\
    \ word -1) #\\u)\n\t  (member (list-ref word -2) (list #\\s #\\t #\\w)))\n   \
    \  \"u\"]\n    [else (get_closest_vowel (substring word 0 -1))]))\n", "  (cond\
    \ [(empty? word) '()]\n        [(member (first word) '(\"a\" \"e\" \"i\" \"o\"\
    \ \"u\"))\n         (list (first word))]\n        [else (get_closest_vowel (rest\
    \ word))]))\n", "  (if (not (or (member \"a\" word) (member \"e\" word) (member\
    \ \"i\" word) (member \"o\" word) (member \"u\" word)))\n      \"\"\n      (cond\
    \ ((member \"a\" word) (find-pos word \"a\"))\n            ((member \"e\" word)\
    \ (find-pos word \"e\"))\n            ((member \"i\" word) (find-pos word \"i\"\
    ))\n            ((member \"o\" word) (find-pos word \"o\"))\n            ((member\
    \ \"u\" word) (find-pos word \"u\")))))\n  )\n", "  (define (get-vowel word len)\n\
    \    (if (or (<= len 1) (= len (string-length word)))\n        \"\"\n        (let*\
    \ ([prev (string-ref word (- len 1))]\n               [next (string-ref word len)])\n\
    \          (if (and (consonant? prev) (consonant? next))\n              (let*\
    \ ([curr (string-ref word (- len 2))])\n                (if (vowel? curr) curr\
    \ (get-vowel word (- len 1))))\n              (get-vowel word (- len 1))))))\n\
    \  (get-vowel word (string-length word)))\n", "  (if (or (empty? word) (string=?\
    \ \"\" word))\n      \"\"\n      (if (string-contains-char? (last-word word) \"\
    aeiouAEIOU\")\n          (last-word word)\n          (if (string-contains-char?\
    \ (second-to-last-word word) \"aeiouAEIOU\")\n              (second-to-last-word\
    \ word)\n              (get_closest_vowel (trim word))))))\n", "  (define vowel?\n\
    \    (lambda (c)\n      (member c '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\"\
    \ \"I\" \"O\" \"U\"))))\n  (define pos\n    (lambda (word)\n      (let lp ((i\
    \ (string-length word)) (flag 0))\n        (cond\n          ((zero? i) (if (zero?\
    \ flag) -1 (sub1 i)))\n          ((and (= flag 0) (vowel? (string-ref word (sub1\
    \ i)))) (lp (sub1 i) 1))\n          ((and (= flag 1) (not (vowel? (string-ref\
    \ word (sub1 i))))) (sub1 i))\n          (else (lp (sub1 i) flag))))))\n  (let\
    \ ((x (pos word)))\n    (if (< x 0) \"\" (string-ref word x))))\n", "  (define\
    \ (is_vowel? letter)\n    (member letter '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E\
    \ #\\I #\\O #\\U)))\n  (define (consonant? l1 l2)\n    (and (not (is_vowel? l1))\
    \ (not (is_vowel? l2))))\n  (define (distance-from-consonant s)\n    (cond [(empty?\
    \ s) +inf.0]\n          [(consonant? (first s) (second s)) 0]\n          [else\
    \ (+ 1 (distance-from-consonant (rest s)))]))\n  (define (select-closest-vowel\
    \ candidates)\n    (cond [(empty? candidates) #f]\n          [(consonant? (first\
    \ candidates) (second candidates)) (first candidates)]\n          [else (select-closest-vowel\
    \ (rest candidates))]))\n  (define vowels (filter is-vowel? word))\n  (let ([closest-vowel\
    \ (select-closest-vowel (sort (map distance-from-consonant vowels) <))])\n   \
    \ (if closest-vowel (string closest-vowel) \"\")))\n```\n#### Challenging\n#####\
    \ 1. Extracting a sequence from a text file\n##### 1.1. Using the `string-lines`\
    \ function\n```#lang racket\n", "  (if (or (empty? word) (empty? (rest word)))\n\
    \      \"\"\n      (cond [(or (= (last word) #\\a) (= (last word) #\\e) (= (last\
    \ word) #\\i) (= (last word) #\\o) (= (last word) #\\u))\n             (last word)]\n\
    \            [(and (not (is_vowel? (first word))) (is_vowel? (last word)))\n \
    \            (last word)]\n            [else\n             (get_closest_vowel\
    \ (rest word))])))\n", "  (if (= 0 (string-length word))\n      (display \"\"\
    )\n      (if (or (string=? \"a\" (substring word (- (string-length word) 1) (string-length\
    \ word)))\n              (string=? \"e\" (substring word (- (string-length word)\
    \ 1) (string-length word)))\n              (string=? \"i\" (substring word (-\
    \ (string-length word) 1) (string-length word)))\n              (string=? \"o\"\
    \ (substring word (- (string-length word) 1) (string-length word)))\n        \
    \      (string=? \"u\" (substring word (- (string-length word) 1) (string-length\
    \ word))))\n          (get_closest_vowel (substring word 0 (- (string-length word)\
    \ 1)))\n          (if (or (string=? \"a\" (substring word (- (string-length word)\
    \ 2) (- (string-length word) 1)))\n                  (string=? \"e\" (substring\
    \ word (- (string-length word) 2) (- (string-length word) 1)))\n             \
    \     (string=? \"i\" (substring word (- (string-length word) 2) (- (string-length\
    \ word) 1)))\n                  (string=? \"o\" (substring word (- (string-length\
    \ word) 2) (- (string-length word) 1)))\n                  (string=? \"u\" (substring\
    \ word (- (string-length word) 2) (- (string-length word) 1))))\n            \
    \  (substring word (- (string-length word) 2) (- (string-length word) 1))\n  \
    \            (display \"\")))))", "  (if (string-empty? word)\n      \"\"\n  \
    \    (if (string-contains word \"aeiouAEIOU\")\n          (get_closest_vowel_helper\
    \ word)\n          \"\")))\n", "  (cond\n    [(empty? word) \"\"]\n    [(or (char=?\
    \ (last word) #\\o)\n         (char=? (last word) #\\a)\n         (char=? (last\
    \ word) #\\i)\n         (char=? (last word) #\\e)\n         (char=? (last word)\
    \ #\\u))\n     (string (last word))]\n    [else (get_closest_vowel (substring\
    \ word 0 (- (string-length word) 1)))]))\n", "  (local ((define (backward word)\n\
    \            (if (or (string=? word \"\")\n                    (string=? (substring\
    \ word 0 1) \"\"))\n                word\n                (backward (substring\
    \ word 1)))))\n    (local ((define (forward word)\n              (if (or (string=?\
    \ word \"\")\n                      (string=? (substring word (sub1 (string-length\
    \ word))) \"\"))\n                  word\n                  (forward (substring\
    \ word 0 (sub1 (string-length word)))))))\n      (cond\n        [(string=? word\
    \ \"\") \"\" ]\n        [(string=? (string-append (backward word) (forward word))\
    \ \"\") \"\" ]\n        [(string=? (backward word) (forward word)) \"\" ]\n  \
    \      [else\n         (cond\n           [(string=? (string-ref (backward word)\
    \ 0) (string-ref (forward word) 0))\n            (backward word)]\n          \
    \ [else (forward word)])]))))\n", "  (define (right-closest word)\n    (if (empty?\
    \ word)\n      '()\n      (cond ((or (char=? (first word) #\\a)\n            \
    \     (char=? (first word) #\\e)\n                 (char=? (first word) #\\i)\n\
    \                 (char=? (first word) #\\o)\n                 (char=? (first\
    \ word) #\\u))\n             (first word))\n            (else (right-closest (rest\
    \ word))))))\n  (let ([closest (right-closest (reverse word))])\n    (if (char?\
    \ closest)\n      (list closest)\n      closest)))\n", "  (define (next-vowel\
    \ w)\n    (local ((define (next-vowel-helper w i)\n              (if (= i (string-length\
    \ w))\n                  \"\"\n                  (if (char-vowel? (string-ref\
    \ w i))\n                      (string-ref w i)\n                      (next-vowel-helper\
    \ w (+ i 1))))))\n      (next-vowel-helper w (string-length w))))\n  (define (char-vowel?\
    \ c)\n    (local ((define (is-vowel? v)\n              (cond [(char=? v #\\A)\
    \ true]\n                    [(char=? v #\\E) true]\n                    [(char=?\
    \ v #\\I) true]\n                    [(char=? v #\\O) true]\n                \
    \    [(char=? v #\\U) true]\n                    [(char=? v #\\a) true]\n    \
    \                [(char=? v #\\e) true]\n                    [(char=? v #\\i)\
    \ true]\n                    [(char=? v #\\o) true]\n                    [(char=?\
    \ v #\\u) true]\n                    [else false])))\n      (is-vowel? c)))\n\
    \  (define (char-consonant? c)\n    (not (char-vowel? c)))\n  (define (char-end?\
    \ c)\n    (or (char-vowel? c)\n        (char-consonant? c)))\n  (define (find-consonant\
    \ word)\n    (define (find-consonant-helper word)\n      (if (and (not (char-end?\
    \ (string-ref word (string-length word))))\n               (char-consonant? (string-ref\
    \ word (string-length word))))\n          (string-append (string-take word (string-length\
    \ word))\n                         (find-consonant-helper (string-drop word (string-length\
    \ word))))\n          word))\n    (find-consonant-helper word))\n  (define (find-vowel\
    \ word)\n    (define (find-vowel-helper word)\n      (if (and (not (char-end",
  "  (let loop ([word word]\n             [i (- (string-length word) 1)])\n    (if\
    \ (&lt; i 0)\n        \"\"\n        (if (char-ci=? (string-ref word i) #\\a)\n\
    \            (string (string-ref word i))\n            (if (char-ci=? (string-ref\
    \ word i) #\\e)\n                (string (string-ref word i))\n              \
    \  (if (char-ci=? (string-ref word i) #\\i)\n                    (string (string-ref\
    \ word i))\n                    (if (char-ci=? (string-ref word i) #\\o)\n   \
    \                     (string (string-ref word i))\n                        (if\
    \ (char-ci=? (string-ref word i) #\\u)\n                            (string (string-ref\
    \ word i))\n                            (loop word (- i 1)))))))))))\n</code>\n\
    and the output of a sample run:\n<code>Welcome to DrRacket, version 6.0.1 [3m].\n\
    Language: racket; memory limit: 256 MB.\n\n&gt; (get_closest_vowel \"yogurt\"\
    )\n\"u\"\n&gt; (get_closest_vowel \"FULL\")\n\"U\"\n&gt; (get_closest_vowel \"\
    quick\")\n\"\"\n&gt; (get_closest_vowel \"ab\")\n\"\"\n&gt; \n</code>\nI have\
    \ also added a part to this answer where I have tried to write my code in a functional\
    \ programming manner. But it doesn't work, so I am not sure if I am actually doing\
    \ it in a functional programming manner.\n<code>#lang racket\n", "  (define (closest-vowel-internal\
    \ word)\n    (let ([next-char (first word)])\n      (cond [(empty? word) \"\"\
    ]\n            [(or (string=? next-char \"A\")\n                 (string=? next-char\
    \ \"E\")\n                 (string=? next-char \"I\")\n                 (string=?\
    \ next-char \"O\")\n                 (string=? next-char \"U\")) next-char]\n\
    \            [else (closest-vowel-internal (rest word))])))\n  (closest-vowel-internal\
    \ (string-reverse word)))\n\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
