name: HumanEval_29_filter_by_prefix
language: rkt
prompt: "#lang racket\n\n;; Filter an input list of strings only for ones that start\
  \ with a given prefix.\n;; >>> (filter_by_prefix (list ) \"a\")\n;; (list )\n;;\
  \ >>> (filter_by_prefix (list \"abc\" \"bcd\" \"cde\" \"array\") \"a\")\n;; (list\
  \ \"abc\" \"array\")\n(define (filter_by_prefix strings prefix)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_prefix))\n\
  \    (check-equal? (candidate (list ) \"john\") (list ))\n    (check-equal? (candidate\
  \ (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list\
  \ \"xxx\" \"xxxAAA\" \"xxx\"))\n))\n\n(test-humaneval)"
completions: ["  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (if\
    \ (empty? strings)\n      strings\n      (if (string-prefix? prefix (first strings))\n\
    \          (cons (first strings) (filter_by_prefix (rest strings) prefix))\n \
    \         (filter_by_prefix (rest strings) prefix))))\n", "  (filter (lambda (element)\
    \ (string-prefix? prefix element)) strings))\n", "  (cond\n    [(empty? strings)\
    \ empty]\n    [(string-prefix? prefix (first strings))\n     (cons (first strings)\
    \ (filter_by_prefix (rest strings) prefix))]\n    [else (filter_by_prefix (rest\
    \ strings) prefix)]))\n", "  (filter (lambda (str) (string-prefix? prefix str))\
    \ strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (for/list ([string strings])\n    (when (string-prefix? prefix string)\n    \
    \  string)))\n", "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n",
  "  (cond [(empty? strings) empty]\n        [(string-prefix? prefix (first strings))\n\
    \         (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n \
    \       [else (filter_by_prefix (rest strings) prefix)]))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n", "  (for/list ([string strings])\n\
    \    (if (string-prefix? prefix string)\n        string)))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n", "  (filter (lambda (x) (string-prefix?\
    \ prefix x)) strings))\n", "  (filter (lambda (str) (string-prefix? prefix str))\
    \ strings))\n", "  (if (empty? strings)\n      (list)\n      (if (string-prefix?\
    \ prefix (first strings))\n          (cons (first strings) (filter_by_prefix (rest\
    \ strings) prefix))\n          (filter_by_prefix (rest strings) prefix))))\n",
  "  (cond\n    [(empty? strings) empty]\n    [(string-prefix? prefix (first strings))\n\
    \     (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n    [else\
    \ (filter_by_prefix (rest strings) prefix)]))\n", "  (filter (lambda (string)\
    \ (string-prefix? prefix string)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n",
  "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n", "  (cond\n    [(null?\
    \ strings) (list)]\n    [(string-prefix? prefix (car strings))\n     (cons (car\
    \ strings) (filter_by_prefix (cdr strings) prefix))]\n    [else (filter_by_prefix\
    \ (cdr strings) prefix)]))\n", "  (cond [(empty? strings) (list)]\n        [(string-prefix?\
    \ prefix (first strings))\n         (cons (first strings) (filter_by_prefix (rest\
    \ strings) prefix))]\n        [else (filter_by_prefix (rest strings) prefix)]))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (\u03BB\
    \ (string) (string-prefix? prefix string)) strings))\n", "  (if (empty? strings)\n\
    \      '()\n      (if (string-prefix? prefix (first strings))\n          (cons\
    \ (first strings) (filter_by_prefix (rest strings) prefix))\n          (filter_by_prefix\
    \ (rest strings) prefix))))\n", "  (filter (lambda (x) (string-prefix? prefix\
    \ x)) strings))\n", "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n",
  "  (cond\n    [(empty? strings) (list)]\n    [(string-prefix? prefix (first strings))\n\
    \     (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n    [else\
    \ (filter_by_prefix (rest strings) prefix)]))\n", '    (filter (lambda (item)
    (string-prefix? prefix item)) strings))', "  (filter (lambda (string) (eq? (string-take\
    \ string (string-length prefix)) prefix)) strings))\n", "  (if (null? strings)\n\
    \      (list)\n      (if (string-prefix? prefix (car strings))\n          (cons\
    \ (car strings) (filter_by_prefix (cdr strings) prefix))\n          (filter_by_prefix\
    \ (cdr strings) prefix))))\n", "  (filter (lambda (string) (string-prefix? prefix\
    \ string)) strings))\n", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (define (filter-proc\
    \ string)\n    (string-prefix? prefix string))\n  (filter filter-proc strings))\n",
  "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n```\n\n```racket\n#lang racket\n",
  "  (for/list ([element strings])\n    (cond\n      [(string-prefix? prefix element)\
    \ element])))\n", "    (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (\u03BB (string) (string-prefix? prefix string)) strings))\n", "  (filter\
    \ (lambda (string) (string-prefix? prefix string)) strings))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (match strings\n    [(list)\
    \ (list)]\n    [(cons string rest)\n     (cond\n       [(string-prefix? prefix\
    \ string)\n        (cons string (filter_by_prefix rest prefix))]\n       [else\
    \ (filter_by_prefix rest prefix)])]))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (s) (eq? (string-take s (string-length\
    \ prefix)) prefix)) strings))\n", "  (filter (lambda (x) (string-prefix? prefix\
    \ x)) strings))\n", "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n", "  (cond\n    [(empty?\
    \ strings) (list)]\n    [(string-prefix? prefix (first strings))\n     (cons (first\
    \ strings) (filter_by_prefix (rest strings) prefix))]\n    [else (filter_by_prefix\
    \ (rest strings) prefix)]))\n```\n\n### 5.2.2 - **Code Submission** - Please submit\
    \ just the function definition. \n\n```racket\n#lang racket\n", "  (filter (lambda\
    \ (string) (string-prefix? prefix string)) strings))\n", "  (filter (\u03BB (s)\
    \ (string-prefix? prefix s)) strings))\n", "  (filter (lambda (x) (string-prefix?\
    \ prefix x)) strings))\n", "  (filter (lambda (str) (and (string? str) (string-prefix?\
    \ prefix str))) strings))\n", "  (filter (lambda (x) (string-prefix? prefix x))\
    \ strings))\n</code>\nI have an input list, a target string, and I want to filter\
    \ the list for strings that match the input string.\nI'm not sure what I'm doing\
    \ wrong here, but I'm trying to invoke the <code>string-prefix?</code> function\
    \ with a string.\n<code>string-prefix?: expects type &lt;string?&gt; as 1st argument,\
    \ given: \"a\";\n other arguments were: (object:racket/string \"abc\")\n</code>\n\
    Any suggestions?\n\n\nA:\n\nI am not sure if I understood what your problem is,\
    \ but I want to point out that you are trying to apply the function <code>string-prefix?</code>\
    \ directly to its parameters:\n<code>(string-prefix? prefix x)\n</code>\nbut that\
    \ in Racket there is an easier syntax for this, which is called prefix notation:\n\
    <code>(prefix? prefix x)\n</code>\nThat is, a function with name <code>f</code>\
    \ can be applied to <code>x</code> and <code>y</code> either by <code>(f x y)</code>\
    \ or by <code>(x f y)</code>.\n", "  (cond\n    [(empty? strings) empty]\n   \
    \ [(string-prefix? prefix (first strings))\n     (cons (first strings) (filter_by_prefix\
    \ (rest strings) prefix))]\n    [else (filter_by_prefix (rest strings) prefix)]))\n",
  "  (for/list ([s strings]\n             #:when (string-prefix? prefix s))\n    s))\n\
    </code>\nBut it gives me an error:\n<code>define-values: expected 1 value, got\
    \ 2 in: (define (filter_by_prefix strings prefix)\nfor/list: expected a variable,\
    \ given a literal string in: for/list\n</code>\nHow do I get a list of strings\
    \ that start with a prefix?\nThanks\n\n\nA:\n\nThe <code>#:when</code> clause\
    \ is a keyword argument, and not a literal string. The <code>#:when</code> clause\
    \ is used to filter the input list. The <code>for/list</code> macro expects one\
    \ argument - the list to be iterated over, and then the <code>#:when</code> and\
    \ <code>#:for</code> clauses can be used to filter the input list.\nThe correct\
    \ syntax to use the <code>#:when</code> clause is:\n<code>(for/list ([s strings]\n\
    \           #:when (string-prefix? prefix s))\n  s)\n</code>\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n", "    (if (empty? strings)\n\
    \        '()\n        (if (string-prefix? prefix (first strings))\n          \
    \  (cons (first strings) (filter_by_prefix (rest strings) prefix))\n         \
    \   (filter_by_prefix (rest strings) prefix))))\n", "  (cond [(empty? strings)\
    \ (list)]\n        [(string-prefix? prefix (first strings))\n         (cons (first\
    \ strings) (filter_by_prefix (rest strings) prefix))]\n        [else (filter_by_prefix\
    \ (rest strings) prefix)]))\n", "  (filter (lambda (x) (string-prefix? prefix\
    \ x)) strings))\n", "  (define (m_help string)\n    (if (string-prefix? prefix\
    \ string)\n        string\n        false))\n  (map m_help strings))\n", "  (cond\n\
    \    [(empty? strings) (list)]\n    [(string-prefix? prefix (first strings))\n\
    \     (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n    [else\
    \ (filter_by_prefix (rest strings) prefix)]))\n", "  (cond ((null? strings) '())\n\
    \        ((string-prefix? prefix (car strings))\n         (cons (car strings)\
    \ (filter_by_prefix (cdr strings) prefix)))\n        (else (filter_by_prefix (cdr\
    \ strings) prefix))))\n", "  (if (null? strings)\n      (list)\n      (if (string-prefix?\
    \ prefix (car strings))\n          (cons (car strings) (filter_by_prefix (cdr\
    \ strings) prefix))\n          (filter_by_prefix (cdr strings) prefix))))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n", "  (filter (\u03BB (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (string) (string-prefix? prefix\
    \ string)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (cond [(null? strings) '()]\n\
    \        [(string-prefix? prefix (car strings))\n         (cons (car strings)\
    \ (filter_by_prefix (cdr strings) prefix))]\n        [else (filter_by_prefix (cdr\
    \ strings) prefix)]))\n", "  (cond ((null? strings) '())\n        ((string-prefix?\
    \ prefix (car strings))\n         (cons (car strings) (filter_by_prefix (cdr strings)\
    \ prefix)))\n        (else (filter_by_prefix (cdr strings) prefix))))\n```\n\n\
    ## Compiling Racket Programs\n\n```bash\n$ raco make program.rkt\n$ racket program.rkt\n\
    ```\n\n## How to Run Tests\n\n```bash\n$ raco test file.rkt\n```\n\nUse the `-l`\
    \ option to run tests in `file.rkt` in a more verbose way.\n\nThe text of the\
    \ test results is generated on standard output. The summary\nincludes the number\
    \ of tests run, the number of tests passed, and the number of\ntests failed. If\
    \ the number of failures is greater than zero, the test suite\nwill exit with\
    \ a status of 1. If the tests fail, you can see the results of\neach test in the\
    \ text output.\n\n\n## How to Run/Test All Racket Files\n\n```bash\n$ raco test\
    \ *.rkt\n```\n\n## How to Run/Test All Racket Files in a Directory\n\n```bash\n\
    $ raco test directory/\n```\n\n## Racket Manual\n\nhttps://docs.racket-lang.org/",
  "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n", "  (cond\n    [(null?\
    \ strings) '()]\n    [(string-prefix? prefix (car strings))\n     (cons (car strings)\
    \ (filter_by_prefix (cdr strings) prefix))]\n    [else (filter_by_prefix (cdr\
    \ strings) prefix)]))\n", "  (cond\n    [(empty? strings) empty]\n    [(string-prefix?\
    \ prefix (first strings))\n     (cons (first strings) (filter_by_prefix (rest\
    \ strings) prefix))]\n    [else (filter_by_prefix (rest strings) prefix)]))\n",
  "  (filter (\u03BB (x) (string-prefix? prefix x)) strings))\n", "  (for/list ([str\
    \ strings])\n    (when (string-prefix? prefix str)\n      str)))\n", "  (filter\
    \ (lambda (str) (string-prefix? prefix str)) strings))\n", "  (if (null? strings)\n\
    \      '()\n      (if (string-prefix? prefix (car strings))\n          (cons (car\
    \ strings) (filter_by_prefix (cdr strings) prefix))\n          (filter_by_prefix\
    \ (cdr strings) prefix))))\n", "  (cond ((null? strings) (list))\n        ((string-prefix?\
    \ prefix (car strings))\n         (cons (car strings) (filter_by_prefix (cdr strings)\
    \ prefix)))\n        (else (filter_by_prefix (cdr strings) prefix))))\n", "  (filter\
    \ (lambda (s) (string-prefix? prefix s)) strings))\n", "    (filter (lambda (x)\
    \ (string-prefix? prefix x)) strings))\n", "    (filter (lambda (str) (string-prefix?\
    \ prefix str)) strings))\n", "  (filter (\u03BB (x) (string-prefix? prefix x))\
    \ strings))\n", "  (cond\n    [(empty? strings) (list)]\n    [(string-prefix?\
    \ prefix (first strings))\n     (cons (first strings) (filter_by_prefix (rest\
    \ strings) prefix))]\n    [else (filter_by_prefix (rest strings) prefix)]))\n",
  "    (filter (lambda (x) (string-prefix? prefix x)) strings))\n", "  (filter (lambda\
    \ (x) (and (not (empty? x)) (equal? (string-ref x 0) prefix))) strings))\n", " \
    \ (filter (lambda (string) (string-prefix? prefix string)) strings))\n", "  (filter\
    \ (lambda (s) (string-prefix? prefix s)) strings))\n", "  (for/list ([s strings]\n\
    \             #:when (string-prefix? prefix s))\n    s))\n", "    (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (filter (\u03BB (x) (string-prefix?\
    \ prefix x)) strings))\n", "  (filter (\u03BB (string) (string-prefix? prefix\
    \ string)) strings))\n", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n",
  "  (cond\n    [(empty? strings) (list)]\n    [(string-prefix? prefix (first strings))\n\
    \     (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n    [else\
    \ (filter_by_prefix (rest strings) prefix)]))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n", "  (cond\n \
    \   [(empty? strings)\n     (list)]\n    [(string-prefix? prefix (first strings))\n\
    \     (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n    [else\n\
    \     (filter_by_prefix (rest strings) prefix)]))\n```\n\n![](./filter_by_prefix.png)\n\
    \nIt's important to note that the filter_by_prefix is a [higher-order function](https://docs.racket-lang.org/guide/higher-order.html).\
    \ It expects a function as an argument.\n\nThe `filter` function expects a predicate\
    \ function to filter the items from the list. The filter function returns the\
    \ list with the filtered items.\n\n\n#### Solution 2\n\n```racket\n#lang racket\n",
  "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n", "  (cond ((null?\
    \ strings) (list))\n        ((string-prefix? prefix (car strings))\n         (cons\
    \ (car strings) (filter_by_prefix (cdr strings) prefix)))\n        (else (filter_by_prefix\
    \ (cdr strings) prefix))))\n", "  (cond\n    [(empty? strings) (list)]\n    [(prefix?\
    \ (first strings) prefix)\n     (cons (first strings) (filter_by_prefix (rest\
    \ strings) prefix))]\n    [else (filter_by_prefix (rest strings) prefix)]))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n", "  (cond\n    [(empty? strings)\
    \ (list)]\n    [(string-prefix? prefix (first strings))\n     (cons (first strings)\
    \ (filter_by_prefix (rest strings) prefix))]\n    [else (filter_by_prefix (rest\
    \ strings) prefix)]))\n", "  (define (is-prefix? str)\n    (string-prefix? prefix\
    \ str))\n  (filter is-prefix? strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (cond\n    [(null? strings) (list)]\n    [(string-prefix?\
    \ prefix (car strings))\n     (cons (car strings) (filter_by_prefix (cdr strings)\
    \ prefix))]\n    [else (filter_by_prefix (cdr strings) prefix)]))\n", "  (cond\
    \ ((not (list? strings)) '(list ))\n        ((not (string? (car strings))) '(list\
    \ ))\n        ((string-prefix? prefix (car strings))\n         (cons (car strings)\
    \ (filter_by_prefix (cdr strings) prefix)))\n        (else (filter_by_prefix (cdr\
    \ strings) prefix))))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (cond\n    [(empty?\
    \ strings) empty]\n    [(string-starts-with? (first strings) prefix)\n     (cons\
    \ (first strings) (filter_by_prefix (rest strings) prefix))]\n    [else (filter_by_prefix\
    \ (rest strings) prefix)]))\n", "  (filter (lambda (string) (string-prefix? prefix\
    \ string)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (\u03BB (string) (string-prefix? prefix string)) strings))\n", "  (cond\
    \ [(empty? strings) (list)]\n        [(string-prefix? prefix (first strings))\n\
    \         (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n \
    \       [else (filter_by_prefix (rest strings) prefix)]))\n```\n\n```\n#lang racket\n",
  "    (define (is_prefix? string)\n      (eq? (substring string 0 (string-length\
    \ prefix)) prefix))\n    (filter is_prefix? strings))\n", "  (define (helper prefix\
    \ strings sofar)\n    (cond\n      [(empty? strings) (reverse sofar)]\n      [(string-prefix?\
    \ prefix (first strings))\n       (helper prefix (rest strings) (cons (first strings)\
    \ sofar))]\n      [else (helper prefix (rest strings) sofar)]))\n  (helper prefix\
    \ strings (list)))\n", "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (cond\n    [(empty?\
    \ strings)\n     '()]\n    [(string-prefix? prefix (first strings))\n     (cons\
    \ (first strings) (filter_by_prefix (rest strings) prefix))]\n    [else\n    \
    \ (filter_by_prefix (rest strings) prefix)]))\n", "  (filter (\u03BB (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (if (null? strings)\n      '()\n      (if (string-prefix?\
    \ prefix (car strings))\n          (cons (car strings) (filter_by_prefix (cdr\
    \ strings) prefix))\n          (filter_by_prefix (cdr strings) prefix))))\n",
  "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n", "  (filter\
    \ (\u03BB (s) (string-prefix? prefix s)) strings))\n", "  (filter (\u03BB (n)\
    \ (equal? (substring n 0 1) prefix)) strings))\n```\n\n\n### <a name=\"map_by_prefix\"\
    ></a>map_by_prefix ###\n\n```#lang racket\n", "  (define (starts-with? string\
    \ prefix)\n    (cond\n      [(empty? string) (empty? prefix)]\n      [(char=?\
    \ (first string) (first prefix)) (starts-with? (rest string) (rest prefix))]\n\
    \      [else false]))\n  (cond\n    [(empty? strings) empty]\n    [(starts-with?\
    \ (first strings) prefix) (cons (first strings) (filter_by_prefix (rest strings)\
    \ prefix))]\n    [else (filter_by_prefix (rest strings) prefix)]))\n", "  (let\
    \ ([len (string-length prefix)])\n    (filter (lambda (s)\n              (string=?\
    \ (substring s 0 len) prefix))\n            strings)))\n", "  (if (null? strings)\n\
    \      '()\n      (let ([this (car strings)])\n        (if (string-prefix? prefix\
    \ this)\n            (cons this (filter_by_prefix (cdr strings) prefix))\n   \
    \         (filter_by_prefix (cdr strings) prefix)))))\n", "  (filter (lambda (word)\
    \ (regexp-match? (regexp (string prefix \".*\")) word)) strings))\n", "  (let\
    \ helper ((strings strings) (answer '()))\n    (cond\n      [(empty? strings)\
    \ answer]\n      [(string-prefix? prefix (first strings))\n       (helper (rest\
    \ strings) (append answer (list (first strings))))]\n      [else (helper (rest\
    \ strings) answer)])))\n", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n",
  "  (filter (lambda (element) (string-prefix? prefix element)) strings))\n", "  (filter\
    \ (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (\u03BB (s)\
    \ (string-prefix? prefix s)) strings))\n", "  (filter (lambda (str) (string-prefix?\
    \ prefix str)) strings))\n", "  (define (startswith? string prefix)\n    (string-prefix?\
    \ prefix string))\n  (filter startswith? strings))\n", "  (for/list ([s strings]\n\
    \             #:when (string-prefix? prefix s))\n    s))\n", "  (filter (lambda\
    \ (x) (string-prefix? prefix x)) strings))\n", "  (cond\n    [(empty? strings)\
    \ empty]\n    [(string-prefix? prefix (first strings))\n     (cons (first strings)\
    \ (filter_by_prefix (rest strings) prefix))]\n    [else (filter_by_prefix (rest\
    \ strings) prefix)]))\n```\n\n## Filtering and mapping\n\nNow we can define both\
    \ `filter` and `map` as \"special cases\" of `foldr`.\n\n`map` is a special case\
    \ of `foldr` where the function we pass in just returns whatever it was passed\
    \ in.\n\n```racket\n#lang racket\n", "  (filter (lambda (str) (string-prefix?\
    \ prefix str)) strings))\n", "  (define (matches-prefix? string)\n    (string-prefix?\
    \ prefix string))\n  (filter matches-prefix? strings))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (word) (string-prefix? prefix word))\
    \ strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (cond\n    [(empty? strings) (list)]\n    [(empty? prefix) strings]\n    [(equal?\
    \ (first strings) prefix)\n     (cons (first strings) (filter_by_prefix (rest\
    \ strings) prefix))]\n    [else (filter_by_prefix (rest strings) prefix)]))\n",
  "  (cond\n    [(empty? strings) (list)]\n    [(string-prefix? prefix (first strings))\n\
    \     (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n    [else\
    \ (filter_by_prefix (rest strings) prefix)]))\n", "  (filter (lambda (string)\
    \ (string-prefix? prefix string)) strings))\n", "  (filter (lambda (str) (string-prefix?\
    \ prefix str)) strings))\n", "  (filter (\u03BB (str) (string-prefix? prefix str))\
    \ strings))\n", "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n",
  "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n", "  (if (null? strings)\n\
    \      (list)\n      (if (string-prefix? prefix (car strings))\n          (cons\
    \ (car strings) (filter_by_prefix (cdr strings) prefix))\n          (filter_by_prefix\
    \ (cdr strings) prefix))))\n", "  (filter (lambda (s) (string-prefix? prefix s))\
    \ strings))\n", "  (if (null? strings)\n      (list)\n      (if (string-prefix?\
    \ prefix (car strings))\n          (cons (car strings) (filter_by_prefix (cdr\
    \ strings) prefix))\n          (filter_by_prefix (cdr strings) prefix))))\n",
  "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n", "  (cond [(empty? strings)\
    \ (list)]\n        [(string-prefix? prefix (first strings))\n         (cons (first\
    \ strings) (filter_by_prefix (rest strings) prefix))]\n        [else (filter_by_prefix\
    \ (rest strings) prefix)]))\n", "  (filter (lambda (string) (string-prefix? prefix\
    \ string)) strings))\n", "  (filter (lambda (item) (equal? (substring item 0 1)\
    \ prefix)) strings))\n", "  (cond\n    [(empty? strings) '()]\n    [(string-prefix?\
    \ prefix (first strings))\n     (cons (first strings) (filter_by_prefix (rest\
    \ strings) prefix))]\n    [else (filter_by_prefix (rest strings) prefix)]))\n\
    ```\n\nIn this case, we are not _destructively_ transforming the list of strings,\
    \ so we\ncan use the empty list constructor `(list )` to create the base case,\
    \ rather than\nusing the empty list constant `'()`.\n\n```racket", "  (filter\
    \ (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda (s)\
    \ (string-prefix? prefix s)) strings))\n", "  (cond\n    ((null? strings) strings)\n\
    \    ((string-prefix? prefix (car strings))\n     (cons (car strings) (filter_by_prefix\
    \ (cdr strings) prefix)))\n    (else (filter_by_prefix (cdr strings) prefix))))\n",
  "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n```\n\n```racket\n#lang racket\n",
  "  (cond\n    ((null? strings)\n     '())\n    ((string-prefix? prefix (car strings))\n\
    \     (cons (car strings) (filter_by_prefix (cdr strings) prefix)))\n    (else\n\
    \     (filter_by_prefix (cdr strings) prefix))))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (cond ((null? strings) (list))\n        ((string-prefix?\
    \ prefix (car strings))\n         (cons (car strings) (filter_by_prefix (cdr strings)\
    \ prefix)))\n        (else (filter_by_prefix (cdr strings) prefix))))\n", "  (filter\
    \ (lambda (s) (string-prefix? prefix s)) strings))\n", "  (for/list ([str strings])\n\
    \    (if (string-prefix? prefix str)\n        str)))\n", "  (filter (lambda (x)\
    \ (string-prefix? prefix x)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (cond\n    [(empty? strings) '()]\n    [(string-prefix?\
    \ prefix (first strings))\n     (cons (first strings) (filter_by_prefix (rest\
    \ strings) prefix))]\n    [else (filter_by_prefix (rest strings) prefix)]))\n",
  "  (cond\n    [(null? strings) (list)]\n    [(string-prefix? prefix (car strings))\n\
    \     (cons (car strings) (filter_by_prefix (cdr strings) prefix))]\n    [else\
    \ (filter_by_prefix (cdr strings) prefix)]))\n", "  (define (filter-prefix-helper\
    \ strings prefix result)\n    (cond\n      [(empty? strings) result]\n      [(string-prefix?\
    \ prefix (first strings)) (filter-prefix-helper (rest strings) prefix (append\
    \ result (list (first strings))))]\n      [else (filter-prefix-helper (rest strings)\
    \ prefix result)]))\n  (filter-prefix-helper strings prefix (list)))\n", "  (cond\n\
    \    [(empty? strings) (list)]\n    [(string-prefix? prefix (first strings))\n\
    \     (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n    [else\
    \ (filter_by_prefix (rest strings) prefix)]))\n```\n\n```\n#lang racket\n", " \
    \ (filter (lambda (str) (string-prefix? prefix str)) strings))\n", "  (filter\
    \ (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (\u03BB (s)\
    \ (string-prefix? prefix s)) strings))\n", "  (cond\n    [(empty? strings) (list)]\n\
    \    [(string-prefix? prefix (first strings))\n     (cons (first strings) (filter_by_prefix\
    \ (rest strings) prefix))]\n    [else (filter_by_prefix (rest strings) prefix)]))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (s) (prefix? prefix s)) strings))\n", "  (filter (lambda (x) (string-prefix?\
    \ prefix x)) strings))\n", "  (filter (\u03BB (x) (string-prefix? prefix x)) strings))\n",
  "  (cond\n    [(empty? strings)\n     empty]\n    [(string-prefix? prefix (first\
    \ strings))\n     (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n\
    \    [else\n     (filter_by_prefix (rest strings) prefix)]))\n```\n\n### Encoding/Decoding\n\
    \n```racket\n#lang racket\n", "  (filter (lambda (s) (string-prefix? prefix s))\
    \ strings))\n```\n\n```racket\n#lang racket\n", "  (filter (\u03BB (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (string) (string-prefix? prefix\
    \ string)) strings))\n", "  (if (empty? strings)\n      (list)\n      (let* ([first\
    \ (first strings)]\n             [rest (rest strings)])\n        (if (string-prefix?\
    \ prefix first)\n            (cons first (filter_by_prefix rest prefix))\n   \
    \         (filter_by_prefix rest prefix)))))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n```\n\n### Tests\n\n```racket\n#lang racket\n", "  (filter\
    \ (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (\u03BB (s)\
    \ (equal? (substring s 0 1) prefix)) strings))\n", "  (filter (lambda (str) (string-prefix?\
    \ prefix str)) strings))\n", "  (cond\n    [(null? strings) (list)]\n    [(string-prefix?\
    \ prefix (car strings))\n     (cons (car strings) (filter_by_prefix (cdr strings)\
    \ prefix))]\n    [else (filter_by_prefix (cdr strings) prefix)]))\n", "  (define\
    \ (helper s prefix)\n    (if (and (string? s)\n             (string-prefix? prefix\
    \ s))\n        (list s)\n        (list)))\n  (apply append (map (lambda (s) (helper\
    \ s prefix)) strings)))\n", "  (filter (lambda (s) (string-prefix? prefix s))\
    \ strings))\n", "  (filter (\u03BB (s) (regexp-match? (regexp prefix) s)) strings))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
