name: HumanEval_161_solve
language: rkt
prompt: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter, reverse\
  \ its case from lower to upper or vise versa, \n;; otherwise keep it as it is.\n\
  ;; If the string contains no letters, reverse the string.\n;; The function should\
  \ return the resulted string.\n;; Examples\n;; >>> (solve \"1234\")\n;; \"4321\"\
  \n;; >>> (solve \"ab\")\n;; \"AB\"\n;; >>> (solve \"#a@C\")\n;; \"#A@c\"\n(define\
  \ (solve s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
  \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
  \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
  \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"\
  #aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
  \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\"\
  )\n))\n\n(test-humaneval)"
completions: ["  (map (\u03BB (c) (match c [#\\a #\\A]\n                        [#\\\
    b #\\B]\n                        [#\\c #\\C]\n                        [#\\d #\\\
    D]\n                        [#\\e #\\E]\n                        [#\\f #\\F]\n\
    \                        [#\\g #\\G]\n                        [#\\h #\\H]\n  \
    \                      [#\\i #\\I]\n                        [#\\j #\\J]\n    \
    \                    [#\\k #\\K]\n                        [#\\l #\\L]\n      \
    \                  [#\\m #\\M]\n                        [#\\n #\\N]\n        \
    \                [#\\o #\\O]\n                        [#\\p #\\P]\n          \
    \              [#\\q #\\Q]\n                        [#\\r #\\R]\n            \
    \            [#\\s #\\S]\n                        [#\\t #\\T]\n              \
    \          [#\\u #\\U]\n                        [#\\v #\\V]\n                \
    \        [#\\w #\\W]\n                        [#\\x #\\X]\n                  \
    \      [#\\y #\\Y]\n                        [#\\z #\\Z]\n                    \
    \    [_ c]))\n          (reverse s)))\n", "  (cond\n    ((null? s) '())\n    ((char-alphabetic?\
    \ (car s)) (cons (flip-case (car s)) (solve (cdr s))))\n    (else (cons (car s)\
    \ (solve (cdr s))))))\n", "  (cond ((null? s) \"\")\n        ((string-contains-letter?\
    \ s)\n         (string-reverse-letters (string-reverse-case s)))\n        (else\
    \ (string-reverse s))))\n", "  (string-reverse (map (lambda (c)\n            \
    \             (if (char-alphabetic? c)\n                             (if (char-lower-case?\
    \ c)\n                                 (char-upcase c)\n                     \
    \            (char-downcase c))\n                             c)) s)))", "  (cond\
    \ ((null? s) \"\")\n        ((char-numeric? (string-ref s 0))\n         (string-append\
    \ (solve (substring s 1)) (string (string-ref s 0))))\n        ((char-upper-case?\
    \ (string-ref s 0))\n         (string-append (solve (substring s 1)) (string (char-downcase\
    \ (string-ref s 0)))))\n        ((char-lower-case? (string-ref s 0))\n       \
    \  (string-append (solve (substring s 1)) (string (char-upcase (string-ref s 0)))))))\n\
    ```\n\n```scheme\n#lang racket\n", "  (cond\n    ((string-no-letter? s) (reverse\
    \ s))\n    (else (string-map (lambda (c) (if (char-lower-case? c) (char-upcase\
    \ c) (char-downcase c))) s))))\n", "  (if (string-contains-letter? s)\n      (revers-case\
    \ s)\n      (string-reverse s)))\n", "  (if (null? s) (list)\n    (if (or (char-numeric?\
    \ (string-ref s 0)) (char-punctuation? (string-ref s 0)))\n        (cons (string-ref\
    \ s 0) (solve (substring s 1)))\n        (cons (char-upcase (string-ref s 0))\
    \ (solve (substring s 1))))))\n", "  (cond\n    [(empty? s) '()]\n    [(char-alphabetic?\
    \ (first s))\n     (append\n      (list (char-upcase (first s)))\n      (solve\
    \ (rest s)))]\n    [else\n     (append\n      (list (first s))\n      (solve (rest\
    \ s)))]))", "  (cond\n    [(empty? s) s]\n    [(char-alphabetic? (string-ref s\
    \ 0))\n     (reverse s)]\n    [else\n     (string-append\n      (char->string\
    \ (string-ref s 0))\n      (solve (string-drop s 1)))]))\n", "  (display (str-transform\
    \ s)))\n", "  (cond\n    [(empty? s)\n     (reverse s)]\n    [(char-numeric? (first\
    \ s))\n     (cons (first s) (solve (rest s)))]\n    [(char-alphabetic? (first\
    \ s))\n     (cons (char-upcase (first s)) (solve (rest s)))]\n    [else\n    \
    \ (cons (char-downcase (first s)) (solve (rest s)))]))\n", "  (cond\n    [(and\
    \ (string? s)\n          (not (empty? s)))\n     (if (member (string-ref s 0)\n\
    \                 (string->list \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ))\n         (string-join\n          (map\n           (lambda (ch)\n         \
    \    (if (char-lower-case? ch)\n                 (char-upcase ch)\n          \
    \       (char-downcase ch)))\n           (string->list s)))\n         (string-reverse\
    \ s))]\n    [else (error \"Not a valid input\")]))", "  (define (reverse-case\
    \ ch)\n    (cond\n      [(char-alphabetic? ch)\n       (string->char (symbol->string\
    \ (string->symbol\n                                      (string (char-upcase\
    \ ch)))))\n       ]\n      [(char-numeric? ch)\n       (string->char (symbol->string\
    \ (string->symbol\n                                      (string (char-downcase\
    \ ch)))))\n       ]\n      [else ch]))\n  (if (any char-alphabetic? s)\n     \
    \ (map reverse-case s)\n      (reverse s)))\n", "  (cond\n    [(string=? \"\"\
    \ s) \"\"]\n    [(string=? (string-map char-downcase s) s) (string-map char-upcase\
    \ s)]\n    [(string=? (string-map char-upcase s) s) (string-map char-downcase\
    \ s)]\n    [else (reverse s)]))\n", "  (cond\n    [(string-empty? s)\n     (error\
    \ \"solve: empty string\")]\n    [(string=? s (string-downcase s))\n     (string-upcase\
    \ s)]\n    [(string=? s (string-upcase s))\n     (string-downcase s)]\n    [else\n\
    \     (string-map (lambda (c)\n                   (cond\n                    \
    \ [(letter? c)\n                      (if (string-ci=? (string c) (string (char-downcase\
    \ c)))\n                          (char-upcase c)\n                          (char-downcase\
    \ c))]\n                     [else\n                      c]))\n             \
    \    s)]))\n", "  (cond\n    [(string-empty? s) s]\n    [(letter? (string-ref\
    \ s 0))\n     (string-append (reverse-case (string-ref s 0)) (solve (substring\
    \ s 1)))]\n    [else\n     (string-append (string-ref s 0) (solve (substring s\
    \ 1)))]))\n", "  (if (string-contains-char? s (lambda (c) (char-alpha? c)))\n\
    \      (string-for-each\n       (lambda (c)\n         (if (char-alpha? c)\n  \
    \           (string-set! s (string-index s c)\n                         (if (char-lower-case?\
    \ c)\n                             (char-upcase c)\n                         \
    \    (char-downcase c)))\n             s))\n       s)\n      (string-reverse s)))\n",
  "  (if (not (string-contains-pred (char-alphabetic?) s))\n      (reverse s)\n  \
    \    (string-map-index (\u03BB (i ch)\n                         (if (char-alphabetic?\
    \ ch)\n                             (if (char-lower-case? ch)\n              \
    \                   (char-upcase ch)\n                                 (char-downcase\
    \ ch))\n                             ch))\n                       s)))\n", " \
    \ (if (not (regexp-match? #rx\"[a-zA-Z]\" s))\n      (string-reverse s)\n    \
    \  (string-map (\u03BB (x)\n                    (if (regexp-match? #rx\"[a-zA-Z]\"\
    \ (string x))\n                        (if (string-upcase? (string x))\n     \
    \                       (string-downcase (string x))\n                       \
    \     (string-upcase (string x)))\n                        x))\n             \
    \     s)))\n", "  (cond\n    [(empty? s) s]\n    [(char-alphabetic? (string-ref\
    \ s 0)) (string-append (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n\
    \    [(char-numeric? (string-ref s 0)) (string-append (string-reverse (string-ref\
    \ s 0)) (solve (substring s 1)))]\n    [else (string-append (string-ref s 0) (solve\
    \ (substring s 1)))]))\n", "  (string-reverse\n   (string-map\n    (lambda (x)\n\
    \      (cond ((letter? x)\n             (if (char-lower-case? x)\n           \
    \      (char-upcase x)\n                 (char-downcase x)))\n            (else\
    \ x)))\n    s)))\n```\n\n6. Integer to Roman\n```racket\n#lang racket\n", "  (if\
    \ (string-contains-ci? s #\\a)\n      (string-join (map (lambda (x) (if (char-alphabetic?\
    \ x)\n                                        (char-downcase x)\n            \
    \                            (char-upcase x))) (string->list s)))\n      (reverse\
    \ s)))\n", "    (cond\n      [(empty? s) empty]\n      [(letter? (first s)) (flip-case\
    \ (first s))]\n      [else (first s)]))\n", "  (cond [(empty? s) \"\"]\n     \
    \   [(char-numeric? (string-ref s 0)) (string-reverse s)]\n        [(char-lower-case?\
    \ (string-ref s 0)) (string-upcase s)]\n        [(char-upper-case? (string-ref\
    \ s 0)) (string-downcase s)]\n        [else (solve (substring s 1))]))\n", " \
    \ (define s-lower-to-upper\n    (string-translate s \"abcdefghijklmnopqrstuvwxyz\"\
    \ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"))\n  (define s-upper-to-lower\n    (string-translate\
    \ s-lower-to-upper \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"abcdefghijklmnopqrstuvwxyz\"\
    ))\n  (cond\n    ((equal? s s-lower-to-upper) s-upper-to-lower)\n    ((equal?\
    \ s s-upper-to-lower) s-lower-to-upper)\n    (else (string-reverse s))))\n", " \
    \ (if (empty? s)\n      \"\"\n      (let ([ch (first s)])\n        (if (or (char-lower-case?\
    \ ch) (char-upper-case? ch))\n            (string-append (string (char-upcase\
    \ ch)) (solve (rest s)))\n            (string-append (string ch) (solve (rest\
    \ s)))))))\n</code>\nSo I'm using recursion here. If the first char is a letter,\
    \ reverse its case, otherwise, if it's not a letter, just take it as it is. The\
    \ problem is that it's not working when the string contains no letters.\nFor example,\
    \ if I write:\n<code>(solve \"12345\")\n</code>\nI get:\n<code>\"54321\"\n</code>\n\
    It should be:\n<code>\"54321\"\n</code>\nSimilarly, if I write:\n<code>(solve\
    \ \"\")\n</code>\nI get:\n<code>\"\"\n</code>\nIt should be:\n<code>\"\"\n</code>\n\
    The string is reversed, when it contains no letters. What's wrong?\n\n\nA:\n\n\
    The problem is in the <code>if</code> clause where you're reversing the case of\
    \ the letter. You're not taking into account the case of the letter. For example,\
    \ the <code>char-upcase</code> function converts a lowercase letter to a uppercase\
    \ letter, but if the letter is already uppercase, it won't do anything. The same\
    \ goes for the <code>char-downcase</code> function.\nWhat you need to do is to\
    \ check the case of the letter, and then toggle it, that is, if it's lowercase,\
    \ convert it to uppercase and if it's uppercase, convert it to lowercase. This\
    \ can be achieved with the <code>cond</code> statement:\n<code>(define (toggle-case\
    \ char)\n  (cond ((char-lower-case? char) (char-upcase char))\n        ((char-upper-case?\
    \ char) (char-downcase char))\n        (else char)))\n</code>\nThen, we only need\
    \ to fix the <code>solve</code> function to use the new <code>toggle-case", " \
    \ (cond\n    ((not (string-contains? (string-upcase s) s))\n     (string-reverse\
    \ s))\n    (else\n     (list->string\n      (map\n       (lambda (char)\n    \
    \     (if (char-alphabetic? char)\n             (char-upcase char)\n         \
    \    (char-downcase char)))\n       (string->list s))))))\n", "  (if (string-&gt;list\
    \ s)\n      (let ( (S (string-&gt;list s))\n             (newS \"\") )\n     \
    \   (map (lambda (x) (if (char-alphabetic? x) (char-upcase x) (char-downcase x)))\
    \ S)\n        (build-string newS)\n      )\n      (string-reverse s)\n    )\n\
    \  )\n\n</code>\nI need to use the <code>map</code> and the <code>build-string</code>\
    \ functions, and should return <code>s</code> if <code>s</code> doesn't contain\
    \ letters.\n\n\nA:\n\nHere's a version that works. I'm not sure if it's what you\
    \ intended, but it's at least closer.\n<code>(define (solve s)\n  (if (string-contains-letter?\
    \ s)\n      (apply string (map (lambda (x)\n                           (if (char-alphabetic?\
    \ x)\n                               (char-upcase x)\n                       \
    \        (char-downcase x)))\n                         (string-&gt;list s)))\n\
    \      (string-reverse s)))\n", "  (cond [(null? s) \"\"]\n        [(regexp-match?\
    \ #rx\"[a-zA-Z]\" s)\n         (string-upcase s)]\n        [else\n         (string-reverse\
    \ s)]))\n", "  (cond\n    [(null? s) \"\"]\n    [(char-letter? (string-ref s 0))\n\
    \     (string-append\n      (if (char-lower-case? (string-ref s 0))\n        \
    \  (string-upcase (substring s 0 1))\n          (string-downcase (substring s\
    \ 0 1)))\n      (solve (substring s 1)))]\n    [else\n     (string-append (substring\
    \ s 0 1) (solve (substring s 1)))]))\n</code>\n", "  (if (string-no-numbers? s)\n\
    \      (if (string-no-letters? s)\n          (reverse s)\n          (string-reverse-case\
    \ s))\n      (string-reverse-case s)))", "  (cond\n    [(and (string? s) (= 0\
    \ (string-length s)))\n     s]\n    [(not (string? s))\n     \"Not a string\"\
    ]\n    [else\n     (string-join (reverse (map string-downcase s)))]))\n", "  (define\
    \ (is-letter? c)\n    (and (&gt;= c (char-&gt;integer #\\a)) (&lt;= c (char-&gt;integer\
    \ #\\z))\n         (&gt;= c (char-&gt;integer #\\A)) (&lt;= c (char-&gt;integer\
    \ #\\Z))))\n  (define (reverse-case c)\n    (if (is-letter? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-lower-case c))\n        c))\n\
    \  (if (string-contains? s is-letter?)\n      (string-&gt;list s)\n      (reverse\
    \ (string-&gt;list s))))\n", "  (if (equal? s \"\")\n      \"\"\n      (string-append\n\
    \       (reverse\n        (substring\n         s\n         0\n         (if (char-alphabetic?\
    \ (string-ref s 0))\n             1\n             0)))\n       (solve\n      \
    \  (substring\n         s\n         (if (char-alphabetic? (string-ref s 0))\n\
    \             1\n             0))))))\n", "  (define (check-case c)\n    (let\n\
    \      ([l (char-downcase c)]\n       [u (char-upcase c)])\n      (if\n      \
    \  (char=? c l)\n        u\n        l)))\n  (if (regexp-match? #rx\"[a-zA-Z]\"\
    \ s)\n    (string-map check-case s)\n    (string-reverse s)))\n", "  (if (null?\
    \ s) s\n      (if (letter? (string-ref s 0))\n          (string-append (string-upcase\
    \ (string-ref s 0))\n                         (solve (substring s 1 (string-length\
    \ s))))\n          (string-append (string-downcase (string-ref s 0))\n       \
    \                  (solve (substring s 1 (string-length s)))))))\n", '  (reverse
    (map (lambda (x) (if (char-alphabetic? x) (string-upcase x) x)) s)))', "  (define\
    \ (conv c)\n    (define (is-alpha?) (char-alphabetic? c))\n    (if (is-alpha?)\n\
    \        (if (char-uppercase? c)\n            (char-downcase c)\n            (char-upcase\
    \ c))\n        c))\n  (if (string-for-each char-alphabetic? s)\n      (string-for-each\
    \ conv s)\n      (string-reverse s)))\n", "  (if (string-contains-only? s (string-append\
    \ (range #\\a #\\z) (range #\\A #\\Z)))\n      (string-reverse s)\n      (string-map\
    \ (\u03BB (x) (if (or (char=? #\\a x) (char=? #\\A x)) (char+ 1 x)\n         \
    \                     (if (or (char=? #\\z x) (char=? #\\Z x)) (char- 1 x)\n \
    \                                 (if (char-upcase? x) (char-downcase x) (char-upcase\
    \ x))))) s)))\n```\n\n## Test Suite\n\nA Racket script is provided that tests\
    \ the solution and compares it with the benchmark.\nTo run the test suite, you\
    \ will need to have [Racket](https://racket-lang.org/) installed.\nYou can then\
    \ run:\n\n```sh\nracket test.rkt\n```\n\nThis will print output like the following:\n\
    \n```\n##################################################\nBenchmark:", "  (if\
    \ (empty? s)\n      s\n      (solve (reverse (string-append (string-upcase (substring\
    \ s 1 1))\n\t\t\t\t     (substring s 0 1))))))", "  (define (isLetter? c)\n  \
    \  (string-contains (string-upcase c) c))\n  (define (reverseChar c)\n    (if\
    \ (isLetter? c)\n        (string-upcase c)\n        (string-downcase c)))\n  (if\
    \ (isLetter? (string-ref s 0))\n      (string-map reverseChar s)\n      (string-reverse\
    \ s)))\n", "  (if (empty? s)\n      \"\"\n      (let ([c (car s)])\n        (cond\
    \ [(or (char-lower-case? c) (char-upper-case? c))\n               (string-append\
    \ (string (invert-case c)) (solve (cdr s)))]\n              [else\n          \
    \     (string-append (string c) (solve (cdr s)))]))))\n\n```\n\n```\n#lang racket\n",
  "  (cond\n    [(empty? s) \"\"]\n    [(symbol? (string-upcase (substring s 0 1)))\n\
    \     (string-append (solve (substring s 1)) (substring s 0 1))]\n    [else (string-append\
    \ (solve (substring s 1))\n                         (string-upcase/downcase (substring\
    \ s 0 1)))]))\n", "  (cond\n    [(null? s) (error \"String is null\")]\n    [(string=?\
    \ (string-upcase s) s) (string-downcase s)]\n    [(string=? (string-downcase s)\
    \ s) (string-upcase s)]\n    [else (reverse s)]))", "  (cond\n    [(string-empty?\
    \ s) s]\n    [(and (char-alphabetic? (string-ref s 0)) (char-lower-case? (string-ref\
    \ s 0)))\n     (string-append (string (char-upcase (string-ref s 0))) (solve (substring\
    \ s 1)))]\n    [(and (char-alphabetic? (string-ref s 0)) (char-upper-case? (string-ref\
    \ s 0)))\n     (string-append (string (char-downcase (string-ref s 0))) (solve\
    \ (substring s 1)))]\n    [else (string-append (string (string-ref s 0)) (solve\
    \ (substring s 1)))]))\n", "  (define (is-letter? ch) (and (char&lt;=? #\\a ch)\
    \ (char&lt;=? ch #\\z)))\n  (define (swap-case ch)\n    (if (is-letter? ch)\n\
    \        (string-&gt;symbol\n         (string-upcase\n          (symbol-&gt;string\
    \ ch)))\n        ch))\n  (if (empty? s) (reverse s)\n      (reverse (map swap-case\
    \ s))))\n", "  (cond [(empty? s)\n         '()]\n        [(char-alphabetic? (car\
    \ s))\n         (append (list (char-upcase (car s))) (solve (cdr s)))]\n     \
    \   [(char-numeric? (car s))\n         (append (list (car s)) (solve (cdr s)))]\n\
    \        [else\n         (append (list (char-downcase (car s))) (solve (cdr s)))]))",
  "  (cond\n    [(null? s) '()]\n    [(letter? (car s))\n     (list\n      (case->char\
    \ (char->case (car s))))]\n    [else (cons (car s) (solve (cdr s)))]))\n", " \
    \ (if (string-contains-only s #\"[^a-zA-Z]\")\n      (string-reverse s)\n    \
    \  (string-upcase/downcase s)))", "  (if (empty? s) (string)\n      (if (char-lower-case?\
    \ (string-ref s 0))\n          (string-append (string-upcase (string-ref s 0))\
    \ (solve (substring s 1)))\n          (string-append (string-downcase (string-ref\
    \ s 0)) (solve (substring s 1))))))\n\n```\n\n## Strings - Calculation Of The\
    \ First Character\n\n```racket\n#lang racket\n", "  (if (or (char-alphabetic?\
    \ (string-ref s 0))\n          (char-alphabetic? (string-ref s 1)))\n      (string-map\
    \ char-downcase s)\n      (string-reverse s)))", "  (string-reverse (map\n   \
    \                (lambda (c) (if (char-alphabetic? c) (char-downcase c) (char-upcase\
    \ c)))\n                   s)))\n", "  (string-&gt;list s))\n</code>\nI tried\
    \ to change all lowercase letters in the string to uppercase, but that was not\
    \ the answer to the problem. The instructions say to reverse the case from lower\
    \ to upper or vice versa, but how do I do that?\n\n\nA:\n\nBuild a result string\
    \ from the individual characters in the input string, using a helper procedure\
    \ that'll apply the correct case to the letter. For example:\n<code>(define (solve\
    \ s)\n  (define (handle c)\n    (cond ((char-alphabetic? c) (char-upcase c))\n\
    \          ((char-alphabetic? (char-downcase c)) (char-downcase c))\n        \
    \  (else c)))\n  (string-&gt;list s))\n</code>\n", "  (if (equal? s \"\") \"\"\
    \n      (let ((l (string-length s)))\n        (let loop ((i 0) (acc \"\"))\n \
    \         (if (>= i l) (list->string (reverse acc))\n              (let ((c (string-ref\
    \ s i)))\n                (if (and (char-alphabetic? c)\n                    \
    \     (not (char-lower-case? c)))\n                    (loop (+ i 1) (cons (char-downcase\
    \ c) acc))\n                    (if (and (char-alphabetic? c)\n              \
    \               (char-lower-case? c))\n                        (loop (+ i 1) (cons\
    \ (char-upcase c) acc))\n                        (loop (+ i 1) (cons c acc)))))))))))\n",
  "  (string-reverse (map (lambda (x)\n                         (if (letter? x)\n\
    \                             (if (char-ci&lt;=? x #\\a)\n                   \
    \              (char-upcase x)\n                                 (char-downcase\
    \ x))\n                             x))\n                       s)))\n</code>\n",
  "  (if (string-no-alpha? s)\n      (string-reverse s)\n      (string-map-reversed\
    \ #'char-reversed-case s)))\n", "  (cond\n    [(null? s) \"\"]\n    [(string-contains?\
    \ \"abcdefghijklmnopqrstuvwxyz\" (string-ref s 0))\n     (string-append (string-upcase\
    \ (string-ref s 0)) (solve (substring s 1)))]\n    [(string-contains? \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \ (string-ref s 0))\n     (string-append (string-downcase (string-ref s 0)) (solve\
    \ (substring s 1)))]\n    [else\n     (string-append (string-ref s 0) (solve (substring\
    \ s 1)))]))\n", "  (if (string-empty? s)\n      \"\"\n      (string-append\n \
    \      (cond\n         [(char-alphabetic? (string-ref s 0))\n          (string-set\
    \ (string-downcase s) 0 (char-upcase (string-ref s 0)))]\n         [else\n   \
    \       (string-set (string-upcase s) 0 (char-downcase (string-ref s 0)))])\n\
    \       (solve (substring s 1 (string-length s))))))\n", "  (cond ((string-no-letter?\
    \ s) (string-reverse s))\n        (else (apply string (map reverse-case (string->list\
    \ s))))))\n", "  (string-reverse s))\n```\n\nNote: `string-reverse` is the reference\
    \ function.\n\n[Solution](solution.rkt)", "  (if (string-empty? s)\n      \"\"\
    \n      (if (char-alphabetic? (string-ref s 0))\n          (string-append (string-upcase\
    \ (string-downcase (string-ref s 0)))\n                         (solve (substring\
    \ s 1)))\n          (string-append (string-ref s 0) (solve (substring s 1))))))",
  "  (if (not (regexp-match? #rx\"[a-zA-Z]\" s))\n      (reverse s)\n      (string-map\
    \ (lambda (x)\n                    (if (regexp-match? #rx\"[a-z]\" x)\n      \
    \                  (string-upcase x)\n                        (string-downcase\
    \ x)))\n                  s)))\n", "  (if (string-empty? s)\n      s\n      (if\
    \ (char-alphabetic? (string-ref s 0))\n          (string-append (string-upcase\
    \ (string-ref s 0)) (solve (substring s 1)))\n          (string-append (string-downcase\
    \ (string-ref s 0)) (solve (substring s 1))))))\n```\n\n## 7. Sum of Digits\n\n\
    ### Task\n\n### Input Format\n\nA string, `s`, of length `N` where `s[i]` is either\
    \ a digit from `0` to `9` or a `-` (negative sign).\n\n### Output Format\n\nPrint\
    \ the sum of digits of the given string.\n\n### Sample Input\n\n```\n123-45-67\n\
    ```\n\n### Sample Output\n\n```\n23\n```\n\n### Explanation\n\nGiven string is\
    \ `123-45-67`. Sum of digits is `1+2+3+4+5+6+7 = 23`.\n\n### Solution\n\n```racket\n\
    #lang racket\n", "  (if (string-empty? s)\n      \"\"\n      (if (alphabetic?\
    \ (string-ref s 0))\n          (string-append (reverse-case (string-ref s 0))\n\
    \                         (solve (substring s 1)))\n          (string-append (string-ref\
    \ s 0)\n                         (solve (substring s 1))))))", "  (string-reverse\
    \ (string-downcase s)))\n", "  (map (lambda (c)\n         (cond [(letter? c)\n\
    \                (char-upcase (char-downcase c))]\n               [else\n    \
    \            c]))\n       s))\n", "  (cond\n    [(empty? s) \"\" ]\n    [(char-alphabetic?\
    \ (first s)) (string-append (string-upcase (first s)) (solve (rest s)))]\n   \
    \ [(char-numeric? (first s)) (string-append (first s) (solve (rest s)))]\n   \
    \ [else (string-append (string-downcase (first s)) (solve (rest s)))]))\n", " \
    \ (define (str->char-list s)\n    (string->list s))\n  (define (char-list->str\
    \ s)\n    (list->string s))\n  (define (is-upper-case? c)\n    (char-upper-case?\
    \ c))\n  (define (is-lower-case? c)\n    (char-lower-case? c))\n  (define (to-upper-case\
    \ c)\n    (char-upcase c))\n  (define (to-lower-case c)\n    (char-downcase c))\n\
    \  (define (reverse-case c)\n    (if (is-upper-case? c)\n        (to-lower-case\
    \ c)\n        (to-upper-case c)))\n  (define (reverse-case-string s)\n    (char-list->str\
    \ (map reverse-case (str->char-list s))))\n  (define (has-at-least-one-letter\
    \ s)\n    (exists char-alphabetic? (str->char-list s)))\n  (if (has-at-least-one-letter\
    \ s)\n      (reverse-case-string s)\n      (reverse s)))", '  (string-downcase
    s))', "  (displayln s)\n  (if (regexp-match #rx\"\\p{Alpha}\" s)\n      (displayln\
    \ \"contains alpha\")\n      (displayln \"does not contain alpha\"))\n  (displayln\
    \ (regexp-match #rx\"\\p{Alpha}\" s))\n  (displayln (regexp-match-positions #rx\"\
    \\p{Alpha}\" s))\n  (displayln (regexp-match-substrings #rx\"\\p{Alpha}\" s))\n\
    \  s)\n", "  (if (string-empty? s)\n      \"\"\n      (if (letter? (string-ref\
    \ s 0))\n          (string-append (string-upcase (string-ref s 0))\n         \
    \                (solve (substring s 1)))\n          (string-append (string-ref\
    \ s 0)\n                         (solve (substring s 1))))))\n", "  (string-&gt;list\
    \ s))\n", "  (cond\n    [(empty? s) empty]\n    [(letter? (first s))\n     (string\
    \ (change-case (first s)))\n     (solve (rest s))]\n    [else\n     (string (first\
    \ s))\n     (solve (rest s))]))\n", "  (if (empty? s) \"\"\n    (if (char-alphabetic?\
    \ (string-ref s 0))\n      (string-append (char-upcase/downcase (string-ref s\
    \ 0)) (solve (substring s 1)))\n      (string-append (string-ref s 0) (solve (substring\
    \ s 1))))))\n", "  (cond\n    [(string-null? s) \"\"]\n    [(char-numeric? (string-ref\
    \ s 0))\n     (string-append (solve (substring s 1)) (substring s 0 1))]\n   \
    \ [(char-lower-case? (string-ref s 0))\n     (string-append (char-upcase (string-ref\
    \ s 0))\n                    (solve (substring s 1)))]\n    [(char-upper-case?\
    \ (string-ref s 0))\n     (string-append (char-downcase (string-ref s 0))\n  \
    \                  (solve (substring s 1)))]\n    [else (string-append (substring\
    \ s 0 1) (solve (substring s 1)))]))\n", "  (cond\n    [(empty? s) '()]\n    [(char-alphabetic?\
    \ (first s))\n     (cons (flip-case (first s)) (solve (rest s)))]\n    [else\n\
    \     (cons (first s) (solve (rest s)))]))\n", "  (cond [(null? s)\n         s]\n\
    \        [(char-alphabetic? (string-ref s 0))\n         (string-append (string-append\
    \ (string-downcase (substring s 0 1))\n                                      \
    \ (substring s 1 (string-length s)))\n                       (string-append (string-upcase\
    \ (substring s 1 2))\n                                      (substring s 2 (string-length\
    \ s))))]\n        [else\n         (string-append (substring s 0 1)\n         \
    \               (solve (substring s 1 (string-length s))))]))\n", "  (if (empty?\
    \ s)\n      \"\"\n      (string-append\n       (if (char-alphabetic? (string-ref\
    \ s 0))\n           (string-append (string-upcase (string-ref s 0)) (string-ref\
    \ s 1))\n           (string-append (string-downcase (string-ref s 0)) (string-ref\
    \ s 1)))\n       (solve (substring s 2)))))", "  (cond\n    [(empty? s) \"\"]\n\
    \    [(char-alphabetic? (string-ref s 0))\n     (string-append\n      (string\
    \ (char-downcase (string-ref s 0)))\n      (solve (substring s 1)))]\n    [(char-upper-case?\
    \ (string-ref s 0))\n     (string-append\n      (string (char-lower-case (string-ref\
    \ s 0)))\n      (solve (substring s 1)))]\n    [else (string-append\n        \
    \   (string (string-ref s 0))\n           (solve (substring s 1)))]))\n", "  (if\
    \ (equal? #f (string-contains-pred (lambda (x) (char-alphabetic? x)) s))\n   \
    \   (reverse s)\n      (string-join (map (lambda (x) (if (char-alphabetic? x)\
    \ (if (char-lower-case? x) (char-upcase x) (char-downcase x)) x)) (string->list\
    \ s)) \"\")))", "  (let ([a (string->list s)])\n    (if (empty? a) s\n       \
    \ (if (string-upcase? (car a)) (string-downcase s)\n            (string-upcase\
    \ s)))))\n", "  (define (isUpperCase? c) (char-ci=? c (char-upcase c)))\n  (define\
    \ (isLowerCase? c) (char-ci=? c (char-downcase c)))\n  (define (changeCase c)\n\
    \    (cond\n      [(isUpperCase? c) (char-downcase c)]\n      [(isLowerCase? c)\
    \ (char-upcase c)]\n      [else c]))\n  (define (isLetter? c)\n    (if (or (isUpperCase?\
    \ c) (isLowerCase? c))\n        #t\n        #f))\n  (define (containsOnlyLetters?\
    \ s)\n    (define (containsOnlyLetters? k)\n      (if (or (not (= k (string-length\
    \ s))) (isLetter? (string-ref s k)))\n          (containsOnlyLetters? (+ k 1))\n\
    \          #f))\n    (containsOnlyLetters? 0))\n  (define (reverseString s)\n\
    \    (cond\n      [(= (string-length s) 0) s]\n      [else (string-append (reverseString\
    \ (substring s 1)) (string-ref s 0))]))\n  (cond\n    [(= (string-length s) 0)\
    \ \"\"]\n    [(containsOnlyLetters? s) (reverseString (map changeCase s))]\n \
    \   [else (reverseString s)]))", "  (if (regexp-match #rx\"\\p{L}\" s)\n     \
    \ (string-map\n       (lambda (x)\n         (cond\n           [(char-lower-case?\
    \ x) (char-upcase x)]\n           [(char-upper-case? x) (char-downcase x)]\n \
    \          [else x]))\n       s)\n      (reverse s)))\n", "  (if (no-letter s)\n\
    \      (reverse s)\n      (map (lambda (c)\n             (if (letter? c)\n   \
    \              (reverse-case c)\n                 c))\n           s)))\n", " \
    \ (cond\n    [(empty? s) s]\n    [(not (letter? (car s)))\n     (cons (car s)\
    \ (solve (cdr s)))]\n    [else\n     (cons (string-upcase (car s)) (solve (cdr\
    \ s)))]))\n", "  (define (rev-case c)\n    (if (char-lower-case? c)\n        (char-upcase\
    \ c)\n        (char-downcase c)))\n  (if (string-contains s #\\a)\n      (string-join\n\
    \       (map rev-case (string->list s)))\n      (string-reverse s)))\n", "  (cond\
    \ ((empty? s) \"\")\n        ((char-alphabetic? (string-ref s 0))\n         (string-append\n\
    \          (string-append (string-downcase s) \" \")\n          (string-append\
    \ (string-upcase s) \" \")))\n        (else (string-append (string-reverse s)\
    \ \" \"))))\n", "  (cond\n    ((null? s) '())\n    ((char-numeric? (car s)) (cons\
    \ (car s) (solve (cdr s))))\n    ((char-upper-case? (car s)) (cons (char-downcase\
    \ (car s)) (solve (cdr s))))\n    ((char-lower-case? (car s)) (cons (char-upcase\
    \ (car s)) (solve (cdr s))))\n    (else (cons (car s) (solve (cdr s))))))\n",
  "  (cond ((string-contains? s (string->symbol \"a\"))\n         (string-append \n\
    \          (string-upper-case (substring s 0 1))\n          (string-lower-case\
    \ (substring s 1))))\n        ((string-contains? s (string->symbol \"A\"))\n \
    \        (string-append \n          (string-lower-case (substring s 0 1))\n  \
    \        (string-upper-case (substring s 1))))\n        (else (reverse s))))\n",
  "  (regexp-replace* #rx\"[a-z]\" (\u03BB (s) (string-upcase s)) s))\n</code>\nHere's\
    \ the important part:\n<code>(define (solve s)\n  (regexp-replace* #rx\"[a-z]\"\
    \ (\u03BB (s) (string-upcase s)) s))\n</code>\n", "  (cond\n    [(empty? s) '()]\n\
    \    [(char-lower-case? (car s))\n     (cons (char-upcase (car s)) (solve (cdr\
    \ s)))]\n    [(char-upper-case? (car s))\n     (cons (char-downcase (car s)) (solve\
    \ (cdr s)))]\n    [else (cons (car s) (solve (cdr s)))]))\n</code>\nBut it gives\
    \ an error:\n<code>char-upcase: expected a character, but got: #\\A\n</code>\n\
    Any ideas how to fix it?\n\n\nA:\n\nThe reason is that Racket's <code>char-upcase</code>\
    \ function actually expects a \"character\", which is not a single character,\
    \ but a string with a single character inside. You can easily fix your code using\
    \ Racket's <code>string-&gt;list</code> function, which splits a string into a\
    \ list of characters, each one of which is a \"character\":\n<code>(define (solve\
    \ s)\n  (cond\n    [(empty? s) '()]\n    [(char-lower-case? (car s))\n     (cons\
    \ (char-upcase (car s)) (solve (cdr s)))]\n    [(char-upper-case? (car s))\n \
    \    (cons (char-downcase (car s)) (solve (cdr s)))]\n    [else (cons (car s)\
    \ (solve (cdr s)))]))\n", "  (cond [(empty? s) empty]\n        [(char-letter?\
    \ (first s))\n         (string-append (char-upcase (first s)) (solve (rest s)))]\n\
    \        [(char-letter? (char-downcase (first s)))\n         (string-append (char-downcase\
    \ (first s)) (solve (rest s)))]\n        [else\n         (string-append (first\
    \ s) (solve (rest s)))]))\n", '  (reverse s))', "  (cond [(empty? s) '()]\n  \
    \      [(eq? #\\A (char-upcase (car s))) (cons #\\a (solve (cdr s)))]\n      \
    \  [(eq? #\\a (char-upcase (car s))) (cons #\\A (solve (cdr s)))]\n        [(eq?\
    \ #\\B (char-upcase (car s))) (cons #\\b (solve (cdr s)))]\n        [(eq? #\\\
    b (char-upcase (car s))) (cons #\\B (solve (cdr s)))]\n        [(eq? #\\C (char-upcase\
    \ (car s))) (cons #\\c (solve (cdr s)))]\n        [(eq? #\\c (char-upcase (car\
    \ s))) (cons #\\C (solve (cdr s)))]\n        [(eq? #\\D (char-upcase (car s)))\
    \ (cons #\\d (solve (cdr s)))]\n        [(eq? #\\d (char-upcase (car s))) (cons\
    \ #\\D (solve (cdr s)))]\n        [(eq? #\\E (char-upcase (car s))) (cons #\\\
    e (solve (cdr s)))]\n        [(eq? #\\e (char-upcase (car s))) (cons #\\E (solve\
    \ (cdr s)))]\n        [(eq? #\\F (char-upcase (car s))) (cons #\\f (solve (cdr\
    \ s)))]\n        [(eq? #\\f (char-upcase (car s))) (cons #\\F (solve (cdr s)))]\n\
    \        [(eq? #\\G (char-upcase (car s))) (cons #\\g (solve (cdr s)))]\n    \
    \    [(eq? #\\g (char-upcase (car s))) (cons #\\G (solve (cdr s)))]\n        [(eq?\
    \ #\\H (char-upcase (car s))) (cons #\\h (solve (cdr s)))]\n        [(eq? #\\\
    h (char-upcase (car s))) (cons #\\H (solve (cdr s)))]\n        [(eq", "  (define\
    \ (reverse-case ch)\n    (if (char-ci&lt;=? #\\a ch #\\z)\n        (char-upcase\
    \ ch)\n        (char-downcase ch)))\n  (if (string-any char-letter? s)\n     \
    \ (string-map reverse-case s)\n      (string-reverse s)))\n</code>\n", "  (if\
    \ (regexp-match #rx\"[a-z]\" s)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c) (string-downcase (string c)) (string-upcase (string c)))) s)\n      (string-reverse\
    \ s)))", "  (cond\n    [(empty? s) '()]\n    [(number? (char->integer (car s)))\
    \ (cons (car s) (solve (cdr s)))]\n    [(char-upper-case? (car s)) (cons (char-downcase\
    \ (car s)) (solve (cdr s)))]\n    [(char-lower-case? (car s)) (cons (char-upcase\
    \ (car s)) (solve (cdr s)))]\n    [else (cons (car s) (solve (cdr s)))]))", " \
    \ (if (string-empty? s)\n      s\n      (if (string-contains-ci? \"a-z\" s)\n\
    \          (string-upcase s)\n          (string-downcase s))))\n", "  (if (and\
    \ (string-ci=? s \"\") (string-ci=? s \"\"))\n      s\n      (list->string (reverse\
    \ (string->list s)))))\n", "  (if (not (string-contains? (regexp \"[A-Za-z]\"\
    ) s))\n      (reverse s)\n      (string-map (lambda (x)\n                    (if\
    \ (or (char-lower-case? x) (char-upper-case? x))\n                        (char-downcase\
    \ (char-upcase x))\n                        x))\n                  s)))", "  (if\
    \ (string-contains? s (string-upcase s))\n      (apply string\n             (map\
    \ (\u03BB (c)\n                    (if (char-alphabetic? c)\n                \
    \        (char-downcase c)\n                        (char-upcase c)))\n      \
    \            (string->list s)))\n      (reverse s)))", "  (define (transform x)\n\
    \    (cond\n      [(char-alphabetic? x)\n       (char-upcase x)]\n      [(char-numeric?\
    \ x)\n       (char->integer x)]\n      [else\n       x]))\n  (define (check x)\n\
    \    (cond\n      [(char-numeric? x)\n       (char->integer x)]\n      [else\n\
    \       x]))\n  (if (string-empty? s)\n      \"\"\n      (string-join\n      \
    \ (reverse (map check (string->list s)))\n       \"\")))\n", "  (if (not (string-contains-letter?\
    \ s))\n      (string-reverse s)\n      (string-map (\u03BB (c) (if (letter? c)\
    \ (toggle-case c) c)) s)))\n", "  (define (flip c)\n    (if (char-alphabetic?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (if (string-empty?\
    \ s)\n      \"\"\n      (string-append (string (flip (string-ref s 0))) (solve\
    \ (substring s 1)))))\n</code>\nThe first function <code>flip</code> is a helper\
    \ function that is used to flip the case of a character if it is alphabetic and\
    \ leave it as it is otherwise.\nFor example <code>(flip #\\d)</code> will return\
    \ <code>#\\D</code> and <code>(flip #\\$)</code> will return <code>#\\$</code>.\n\
    The <code>solve</code> function either returns an empty string or <code>(string\
    \ (flip (string-ref s 0)))</code> concatenated with <code>(solve (substring s\
    \ 1))</code>. It does the <code>flip</code> operation on the first character of\
    \ the input string and the concatenates the flipped character with the result\
    \ of calling <code>solve</code> on the substring that is the input string without\
    \ the first character.\nIn other words, it solves the problem for the first character\
    \ and one character less and then recursively does that until the input string\
    \ is empty.\nOf course you could have used <code>string-replace</code> from <code>#lang\
    \ racket</code> to replace the characters of the input string with <code>flip</code>\
    \ but I think your homework is supposed to be using <code>substring</code> and\
    \ <code>string-append</code>.\n", "  (cond\n    [(empty? s) empty]\n    [(not\
    \ (char-alphabetic? (string-ref s 0))) (string-append (string (string-ref s 0))\
    \ (solve (substring s 1)))]\n    [(char-alphabetic? (string-ref s 0))\n     (string-append\
    \ (string (char-upcase (string-ref s 0))) (solve (substring s 1)))]))", "  (cond\n\
    \    [(empty? s) \"\"]\n    [(and (char-lower-case? (first s))\n          (member\
    \ (first s) \"abcdefghijklmnopqrstuvwxyz\"))\n     (string-append (string-upper-case\
    \ (first s)) (solve (rest s)))]\n    [(and (char-upper-case? (first s))\n    \
    \      (member (first s) \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"))\n     (string-append\
    \ (string-lower-case (first s)) (solve (rest s)))]\n    [else (string-append (first\
    \ s) (solve (rest s)))]))\n", "  (if (and (string-length s) (letter? (string-ref\
    \ s 0)))\n      (string-map\n       (lambda (c)\n         (if (letter? c)\n  \
    \           (if (upper-case? c)\n                 (char-downcase c)\n        \
    \       (char-upcase c))\n             c))\n       s)\n      (string-reverse s)))\n",
  "  (if (regexp-match? #rx\"[a-zA-Z]\" s)\n      (string-join (map (lambda (c)\n\
    \                          (if (regexp-match? #rx\"[a-zA-Z]\" (string c))\n  \
    \                            (if (string-ci=? (string c) (string-upcase c))\n\
    \                                  (string-downcase (string c))\n            \
    \                      (string-upcase (string c)))\n                         \
    \     (string c))) s))\n      (string-reverse s)))\n", "  (letrec ([find-index\
    \ (lambda (idx)\n                         (if (= idx (string-length s))\n    \
    \                         idx\n                             (if (char-alpha? (string-ref\
    \ s idx))\n                                 idx\n                            \
    \     (find-index (+ idx 1)))))]\n           [rev (lambda (ls)\n             \
    \     (if (null? ls)\n                      '()\n                      (append\
    \ (rev (cdr ls)) (list (car ls)))))]\n           [reverse-case (lambda (s)\n \
    \                          (if (= (string-length s) 0)\n                     \
    \          \"\"\n                               (string-append\n             \
    \                   (list (char-upcase (string-ref s 0)))\n                  \
    \              (reverse-case (substring s 1)))))]\n           [reverse-string\
    \ (lambda (s)\n                             (string-append (reverse-case s)\n\
    \                                            (reverse-case (reverse s))))])\n\
    \    (if (= (find-index 0) (string-length s))\n        (reverse-string s)\n  \
    \      (string-append (substring s 0 (find-index 0))\n                       (reverse-string\
    \ (substring s (find-index 0)))))))\n\n```\n\n```python\n# Python 2\n\n# You are\
    \ given a string s.\n# if s[i] is a letter, reverse its case from lower to upper\
    \ or vise versa, \n# otherwise keep it as it is.\n# If the string contains no\
    \ letters, reverse the string.\n# The function should return the resulted string.\n\
    # Examples\n# >>> solve(\"1234\")\n# \"4321\"\n# >>> solve(\"ab\")\n# \"AB\"\n\
    # >>> solve(\"#a@C\")\n# \"#A@c\"\ndef solve(s):\n    def reverse_case(string):\n\
    \        if len(string) == 0:\n            return \"\"\n        return chr(ord(string[0])\
    \ ^ 32) + reverse_case(string[1:])\n    def reverse_string(string):\n        return\
    \ reverse_case(string) + reverse_case(string[::-1])\n    def find_index(index):\n\
    \        if index == len(s):\n            return index\n        if s[index].isalpha():",
  "  (if (string-empty? s) \n      \"\"\n      (string-append \n       (if (char-alphabetic?\
    \ (string-ref s 0))\n           (if (char-upper-case? (string-ref s 0))\n    \
    \           (string-downcase (string-ref s 0))\n               (string-upcase\
    \ (string-ref s 0)))\n           (string-ref s 0))\n       (solve (substring s\
    \ 1)))))\n\n```\n\n```racket", "  (string-append\n   (cond [(string-empty? s)\
    \ \"\"]\n         [(letter? (string-ref s 0)) (reverse-letter-case (string-ref\
    \ s 0))]\n         [else (string-ref s 0)])\n   (solve (substring s 1))))\n",
  "  (define (reverse s)\n    (cond ((null? s) null)\n\t  (else (cons (last s) (reverse\
    \ (butlast s))))))\n  (define (is-lower? c) (char-lower-case? c))\n  (define (is-upper?\
    \ c) (char-upper-case? c))\n  (define (to-lower c) (char-downcase c))\n  (define\
    \ (to-upper c) (char-upcase c))\n  (define (letter? c) (or (is-lower? c) (is-upper?\
    \ c)))\n  (define (flip-case c)\n    (cond ((is-lower? c) (to-upper c))\n\t  ((is-upper?\
    \ c) (to-lower c))\n\t  (else c)))\n  (cond ((find letter? s) (reverse (map flip-case\
    \ s)))\n\t(else (reverse s))))", "  (if (string-empty? s)\n      s\n      (if\
    \ (char-alphabetic? (string-ref s 0))\n          (string-append (string-upper-case\
    \ (string-ref s 0)) (solve (substring s 1)))\n          (string-append (string-ref\
    \ s 0) (solve (substring s 1))))))\n```\n\n![image-20200303224902406](.\\assets\\\
    image-20200303224902406.png)\n\n---\n\n### Solve it again, Mr. Grothendieck!\n\
    \n```racket\n#lang racket\n", "  (if (string-contains-letter? s)\n      (string-reverse-case\
    \ s)\n      (string-reverse s)))", "  (let ([s-reversed (reverse s)])\n    (if\
    \ (not (string-contains? s-reversed #\\a #\\z))\n        s-reversed\n        (string-map\n\
    \         (lambda (c)\n           (if (char-alphabetic? c)\n               (char-upcase?\
    \ c (char-downcase c) (char-upcase c))\n               c))\n         s-reversed))))\n",
  "  (map (lambda (c) (if (char-alphabetic? c)\n                       (if (char-lower-case?\
    \ c)\n                           (char-upcase c)\n                           (char-downcase\
    \ c))\n                       c))\n       (string->list s)))\n```\n\n```racket\n\
    #lang racket\n", "  (string-reverse (string-map\n                   (lambda (c)\n\
    \                     (if (and (&lt;= #\\a c) (&lt;= c #\\z))\n              \
    \           (char-upcase c)\n                         (if (and (&lt;= #\\A c)\
    \ (&lt;= c #\\Z))\n                             (char-downcase c)\n          \
    \                   c)))\n                   s)))\n</code>\nBut, this is not working.\
    \ How can I improve my code?\n\n\nA:\n\nYou can use <code>char-upcase</code> with\
    \ <code>char-downcase</code> to do this:\n<code>(define (solve s)\n  (string-map\n\
    \   (lambda (x)\n     (if (char-upcase x)\n         (char-downcase x)\n      \
    \   (if (char-downcase x)\n             (char-upcase x)\n             x)))\n \
    \  s))\n</code>\n", "  (if (string-&gt;list s)\n      (string-join (reverse (string-&gt;list\
    \ s)))\n      (string-join (reverse (string-&gt;list (string-upcase s))))))\n\
    </code>\nMy code does not work for the case of no letters. What is my mistake?\n\
    \n\nA:\n\nThe mistake is in the <code>if</code> test and in the <code>string-join</code>.\
    \ Try this:\n<code>(define (solve s)\n  (string-join (reverse (string-&gt;list\
    \ s))))\n</code>\n", "  (if (not (string-contains-char? s #\\a))\n      (reverse\
    \ s)\n      (for/list ([i (in-naturals)]\n                 [x (in-string s)])\n\
    \        (if (char-alpha? x)\n            (char-downcase x)\n            x))))\n",
  "    (if (string-empty? s)\n        \"\"\n        (define (reverse-case-letter c)\n\
    \            (if (char-numeric? c)\n                c\n                (if (char-lower-case?\
    \ c)\n                    (char-upcase c)\n                    (char-downcase\
    \ c))))\n        (string-map reverse-case-letter s)))\n```\n\n```racket\n#lang\
    \ racket\n", "  (cond\n    [(empty? s) (reverse s)]\n    [(char-upcase? (string-ref\
    \ s 0)) (string-append (string-downcase (string-ref s 0)) (solve (substring s\
    \ 1)))]\n    [(char-lowercase? (string-ref s 0)) (string-append (string-upcase\
    \ (string-ref s 0)) (solve (substring s 1)))]\n    [else (string-append (string-ref\
    \ s 0) (solve (substring s 1)))]))\n", "  (for/list ([c s])\n    (let ([x (integer->char\
    \ (+ (* (- (char->integer c) 48) 2) 48))])\n      (if (char-alphabetic? x) (integer->char\
    \ (- (char->integer x) 17)) x))))", "  (let loop ([s s] [res #\"\"])\n    (cond\
    \ [(empty? s) (reverse res)]\n          [(not (char-alphabetic? (first s)))\n\
    \           (loop (rest s) (string-append res (string (first s))))]\n        \
    \  [else\n           (loop (rest s) (string-append res (string (char-downcase\
    \ (first s)))))])))\n", "  (cond [(null? s) \"\"]\n        [(char-alphabetic?\
    \ (string-ref s 0))\n         (string-append (char-upcase (string-ref s 0))\n\
    \                        (string-downcase (string-drop s 1)))]\n        [else\n\
    \         (string-append (char-downcase (string-ref s 0))\n                  \
    \      (string-upcase (string-drop s 1)))]))\n", "  (if (string-no-alpha? s)\n\
    \      (reverse s)\n      (reverse-case s)))\n", "  (define (rev_case ch)\n  \
    \  (define (upper? ch)\n      (char-upcase ch))\n    (cond\n      ((upper? ch)\
    \ (char-downcase ch))\n      (else (char-upcase ch))))\n  (define (has-lower?\
    \ str)\n    (let loop ((i 0) (flag #f))\n      (cond ((&gt;= i (string-length\
    \ str)) flag)\n            ((char-lower-case? (string-ref str i)) (loop (+ i 1)\
    \ #t))\n            (else (loop (+ i 1) flag)))))\n  (define (has-upper? str)\n\
    \    (let loop ((i 0) (flag #f))\n      (cond ((&gt;= i (string-length str)) flag)\n\
    \            ((char-upper-case? (string-ref str i)) (loop (+ i 1) #t))\n     \
    \       (else (loop (+ i 1) flag)))))\n  (cond\n    ((string=? \"\" s) \"\")\n\
    \    ((not (has-lower? s)) s)\n    ((not (has-upper? s)) (string-reverse s))\n\
    \    (else\n     (let loop ((i 0) (str (make-string (string-length s))))\n   \
    \    (cond\n         ((&gt;= i (string-length s)) str)\n         (else (loop (+\
    \ i 1) (string-set! str i (rev_case (string-ref s i))))))))))\n</code>\nThe error\
    \ message is \"string index out of bounds\". I have no idea what caused it. The\
    \ program just run fine on other inputs.\n\n\nA:\n\nThe issue is in this function:\n\
    <code>(define (has-lower? str)\n  (let loop ((i 0) (flag #f))\n    (cond ((&gt;=\
    \ i (string-length str)) flag)\n          ((char-lower-case? (string-ref str i))\
    \ (loop (+ i 1) #t))\n          (else (loop (+ i 1) flag)))))\n</code>\nThe condition\
    \ <code>(&gt;= i (string-length str))</code> should be <code>(&gt; i (string-length\
    \ str))</code> because when <", "  (string-join\n   (reverse\n    (map\n     (lambda\
    \ (c)\n       (let-values\n           ([(upper lower) (ascii-upcase/downcase c)])\n\
    \         (if (char-ci=? upper lower)\n             c\n             (if (char-numeric?\
    \ c)\n                 c\n                 (if (char-ci=? c upper)\n         \
    \            lower\n                     upper)))))\n     (string->list s)))))\n",
  "  (string-join\n   (reverse\n    (map\n     (lambda (x)\n       (if (or (char-alphabetic?\
    \ x) (char-numeric? x))\n           (if (char-alphabetic? x)\n               (if\
    \ (char-lower-case? x)\n                   (char-upcase x)\n                 \
    \  (char-downcase x))\n               x)\n           x))\n     (string->list s)))))\n",
  "  (string-map\n   (lambda (x)\n     (cond\n       [(char-alphabetic? x) (char-downcase\
    \ x)]\n       [else x]))\n   s))\n```\n\n``` #lang racket", "  (cond\n    [(string=?\
    \ s \"\") s]\n    [(= (string-length s) 1) (string-normalize-nfc s)]\n    [else\n\
    \     (let ([i (string-index (string-normalize-nfc s) (substring s 0 1))])\n \
    \      (string-append (substring s 0 i)\n                      (solve (substring\
    \ s (+ i 1))))]))\n  )\n</code>\nI know, I use quite a bit of Racket-specific\
    \ functions and it could be done better.\nI'm also quite sure there are strings\
    \ that make this function fail, but I'm not sure how to fix it.\n\n\nA:\n\nYour\
    \ function fails when the first character is not a letter.\nIn that case, the\
    \ first character is skipped, but it is not in the result.\nI believe you want\
    \ to add it at the end.\nAlternatively, you could avoid skipping the first character\
    \ by adding a base case:\n<code>(define (solve s)\n  (cond\n    [(string=? s \"\
    \") s]\n    [(= (string-length s) 1) (string-normalize-nfc s)]\n    [(= (string-index\
    \ (string-normalize-nfc s) (substring s 0 1)) 0)\n     (string-append (solve (substring\
    \ s 1)) (substring s 0 1))]\n    [else\n     (let ([i (string-index (string-normalize-nfc\
    \ s) (substring s 0 1))])\n       (string-append (substring s 0 i)\n         \
    \             (solve (substring s (+ i 1)))))]))\n</code>\n", "  (cond [(empty?\
    \ s) s]\n        [(string-ci=? (string-ref s 0) \"a\") \n         (string-append\
    \ (string-upcase (string-ref s 0)) \n                        (solve (substring\
    \ s 1)))]\n        [(string-ci=? (string-ref s 0) \"b\") \n         (string-append\
    \ (string-downcase (string-ref s 0)) \n                        (solve (substring\
    \ s 1)))]\n        [else \n         (string-append (string-reverse (string-ref\
    \ s 0)) \n                        (solve (substring s 1)))]))\n", "  (define (is-letter?\
    \ c)\n    (and (char-alphabetic? c)\n         #t))\n  (define (inverse-case c)\n\
    \    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (inverse-case-str str)\n    (string-map inverse-case str))\n\
    \  (define (inverse-str str)\n    (string-reverse str))\n  (define (inverse-number-str\
    \ str)\n    (inverse-str str))\n  (if (any is-letter? s)\n      (inverse-case-str\
    \ s)\n      (inverse-number-str s)))\n", "  (if (empty? s)\n      s\n      (if\
    \ (char-alphabetic? (first s))\n          (if (char-lower-case? (first s))\n \
    \             (string-downcase s)\n              (string-upcase s))\n        \
    \  (reverse s))))\n", "  (if (string-contains? s #\\a)\n      (string-map \n \
    \      (lambda (c)\n         (if (char-alpha? c)\n             (if (char-lower-case?\
    \ c)\n                 (char-upcase c)\n                 (char-downcase c))\n\
    \             c))\n       s)\n      (string-reverse s)))\n", "  (let loop ((s\
    \ s) (i 0) (r \"\"))\n    (cond\n      [(null? s) (reverse r)]\n      [(letter?\
    \ (car s)) (loop (cdr s) (+ i 1) (string-append r (string-upcase (car s))))]\n\
    \      [(letter? (car (cdr s))) (loop (cdr s) (+ i 1) (string-append r (string-downcase\
    \ (car s))))]\n      [else (loop (cdr s) (+ i 1) (string-append r (car s)))])))\n",
  "  (if (regexp-match #rx\"[a-zA-Z]\" s)\n      (string-join (map (lambda (c)\n \
    \                         (if (and (char-lower-case? c) (char-upper-case? c))\n\
    \                              c\n                              (char-upcase c)))\
    \ s))\n      (string-reverse s)))\n", "  (cond\n    [(null? s) \"\"]\n    [(and\
    \ (char-alphabetic? (string-ref s 0))\n          (char-lower-case? (string-ref\
    \ s 0)))\n     (string-append (string-upcase (substring s 0 1)) (solve (substring\
    \ s 1)))]\n    [(and (char-alphabetic? (string-ref s 0))\n          (char-upper-case?\
    \ (string-ref s 0)))\n     (string-append (string-downcase (substring s 0 1))\
    \ (solve (substring s 1)))]\n    [else (string-append (substring s 0 1) (solve\
    \ (substring s 1)))]))\n", "  (cond\n    [(string-empty? s) \"\" ]\n    [(char-alphabetic?\
    \ (string-ref s 0)) (string-append (char-swapcase (string-ref s 0)) (solve (string-drop\
    \ s 1)))]\n    [else (string-append (string-ref s 0) (solve (string-drop s 1)))]))\n",
  "  (string-reverse (string-map (\u03BB (c)\n                                (char-upcase\
    \ (char-downcase c)))\n                              s)))", "  (if (null? s)\n\
    \      \"\"\n      (if (char-alphabetic? (string-ref s 0))\n          (string-append\
    \ (string (string-upcase (string-ref s 0)))\n                         (solve (substring\
    \ s 1)))\n          (string-append (string (string-ref s 0))\n               \
    \          (solve (substring s 1))))))\n", "  (define (reverse-case s)\n    (string-upcase\
    \ (string-downcase s)))\n  (cond\n    [(no-letter? s) (reverse s)]\n    [else\
    \ (reverse (map reverse-case s))]))\n", "  (if (string-empty? s)\n      \"\"\n\
    \      (if (string-has-no-letters? s)\n          (string-reverse s)\n        \
    \  (string-reverse\n           (map (lambda (c)\n                   (if (char-numeric?\
    \ c)\n                       c\n                       (if (char-upper-case? c)\n\
    \                           (char-downcase c)\n                           (char-upcase\
    \ c))))\n                s)))))\n```\n\n```", "  (if (string-empty? s)\n     \
    \ \"\"\n      (if (letter? (string-ref s 0))\n          (reverse-case (string-ref\
    \ s 0))\n          (string-ref s 0))))\n", "  (reverse (string-map\n    (lambda\
    \ (c)\n      (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n    \
    \      (char-upcase c)\n          (char-downcase c))\n        c))\n    s)))\n",
  '  (reverse (map char-upcase (map char-downcase s))))', "  (if (string-contains-only-letters?\
    \ s)\n      (string-reverse s)\n      (string-reverse-letter-case s)))\n", " \
    \ (if (string-empty? s)\n      \"\"\n      (reverse s)))\n", "  (if (string-empty?\
    \ s)\n      (string)\n      (if (char-alphabetic? (string-ref s 0))\n        \
    \  (string-append\n           (string-append\n            (string-copy\n     \
    \        (string-downcase (string-ref s 0)))\n            (string-drop s 1))\n\
    \           (solve (string-drop s 1)))\n          (string-append\n           (string-ref\
    \ s 0)\n           (solve (string-drop s 1))))))\n</code>\nI do not think this\
    \ is a very efficient solution to this problem. When I run <code>(solve \"12aA\"\
    )</code> it works correctly and returns <code>\"21Aa\"</code> (there are multiple\
    \ different outputs for the same input). Does anyone have any suggestions on how\
    \ to improve this solution?\n\n\nA:\n\nI'll start by addressing some of the issues\
    \ in your code. The first function, <code>solve</code>, should take a string and\
    \ return a string. The third function, <code>b</code>, which is never used, takes\
    \ a string and returns a string. However, the second function, <code>a</code>,\
    \ takes a string and returns a string, but also takes a string and returns a string.\
    \ This is a strange thing to see, and is most likely a typo, but it's hard to\
    \ tell exactly what you were going for.\nAs far as the structure of the problem,\
    \ you are trying to implement a function that reverses the case of each letter\
    \ in a string. You want to recursively go through each letter in the string, then\
    \ create a new string with the reversed case of each letter.\nThe simplest way\
    \ to do this is to check each letter, and if it is a letter, add the reversed-case\
    \ letter to a string. If it is not a letter, simply add it to the string. This\
    \ way, you can create the string one element at a time by just adding elements\
    \ to the end. You don't need to create a string, then add the element, then add\
    \ the rest of the string. Here is an example of that:\n<code>(define (solve s)\n\
    \  (define (helper s idx acc)\n    (if (&gt;= idx (string-length s))\n       \
    \ acc\n        (let ([current-char (string-", "  (cond [(empty? s) \"\"]\n   \
    \     [(not (char-alphabetic? (string-ref s 0))) (string-append (string (string-ref\
    \ s 0)) (solve (substring s 1)))]\n        [(and (char-alphabetic? (string-ref\
    \ s 0)) (char-upper-case? (string-ref s 0))) (string-append (string (char-downcase\
    \ (string-ref s 0))) (solve (substring s 1)))]\n        [(and (char-alphabetic?\
    \ (string-ref s 0)) (char-lower-case? (string-ref s 0))) (string-append (string\
    \ (char-upcase (string-ref s 0))) (solve (substring s 1)))]))\n", '  (apply string
    (map (lambda (c) (if (char-alphabetic? c) (char-upcase c) (char-downcase c)))
    s)))', "  (if (empty? s)\n      \"\"\n      (if (string-ci=? (substring s 0 1)\
    \ \"a\")\n          (string-upcase s)\n          (string-downcase s))))", '  (reverse
    s))', "  (if (string-null? s)\n      s\n      (let ([head (string-ref s 0)])\n\
    \        (string-append\n         (if (char-alpha? head)\n             (if (char-lower-case?\
    \ head)\n                 (string-upcase (string head))\n                 (string-downcase\
    \ (string head)))\n             (string head))\n         (solve (substring s 1))))))\n",
  "  (if (= (string-length s) 0)\n      s\n      (string-join\n       (map (lambda\
    \ (x)\n              (if (and (>= x 65) (<= x 90))\n                  (integer->char\
    \ (+ x 32))\n                  (if (and (>= x 97) (<= x 122))\n              \
    \        (integer->char (- x 32))\n                      (integer->char x))))\n\
    \            (string->list s)))))", "  (apply string (reverse (map (lambda (x)\n\
    \t\t\t\t(if (eq? #\\[ x)\n\t\t\t\t    (char-downcase x)\n\t\t\t\t    (char-upcase\
    \ x)))\n\t\t\t      (string->list s)))))\n", "  (cond [(null? s) \"\"]\n     \
    \   [(or (char-numeric? (string-ref s 0)) (char-whitespace? (string-ref s 0)))\
    \ (solve (substring s 1))]\n        [(char-alphabetic? (string-ref s 0))\n   \
    \      (string-append\n          (string-upcase (string-ref s 0))\n          (string-downcase\
    \ (string-ref s 1))\n          (solve (substring s 2)))]\n        [else (string-append\n\
    \               (string-reverse s)\n               (solve (substring s 1)))]))\n",
  "    (if (= s (string-append))\n        (apply string (reverse (string->list s)))\n\
    \        (map (lambda (c) (if (char-alphabetic? c)\n                         \
    \    (if (char-lower-case? c)\n                                 (char-upcase c)\n\
    \                                 (char-downcase c))\n                       \
    \      c))\n             (string->list s))))\n</code>\nThis seems to work, but\
    \ I'm not sure if it's the best way to handle this problem. \nHow would you improve\
    \ the solution?\n\n\nA:\n\nLooks good to me.  Here's my version:\n<code>(define\
    \ (solve s)\n  (cond\n    [(empty? s) s]\n    [(char-alphabetic? (first s))\n\
    \     (string (if (char-lower-case? (first s))\n                 (char-upcase\
    \ (first s))\n                 (char-downcase (first s)))\n             (solve\
    \ (rest s)))]\n    [else (string (first s) (solve (rest s)))]))\n</code>\n", " \
    \ (if (empty? s)\n      s\n      (let* ([ch (first s)]\n             [case (if\
    \ (letter? ch) (if (upper-case? ch) 'lower 'upper) 'ignore)])\n        (cons (case-letter\
    \ ch case) (solve (rest s))))))\n", "  (let ([reversed-string (string-reverse\
    \ s)])\n    (if (string-contains? (string-upcase s) #\\a)\n        (string-map\
    \ (lambda (c)\n                      (if (char-alphabetic? c)\n              \
    \            (char-upcase c)\n                          (char-downcase c)))\n\
    \                    reversed-string)\n        reversed-string)))\n", "  (cond\n\
    \    [(empty? s) \"\"]\n    [(char-numeric? (string-ref s 0)) (solve (substring\
    \ s 1))]\n    [(char-alphabetic? (string-ref s 0))\n     (string-append (letter-case-reverse\
    \ (string-ref s 0))\n                    (solve (substring s 1)))]\n    [else\
    \ (string-append (string-ref s 0) (solve (substring s 1)))]))\n", "  (if (not\
    \ (string-contains s #\\a #\\z))\n      (reverse s)\n      (string-map (lambda\
    \ (c)\n                    (if (char-numeric? c) c\n                        (if\
    \ (char-alphabetic? c)\n                            (if (char-lower-case? c) (char-upcase\
    \ c) (char-downcase c))\n                            c)))\n                  s)))",
  "  (cond\n    ((null? s) \"\")\n    ((char-alphabetic? (string-ref s 0)) (string-append\
    \ (char-foldcase (string-ref s 0)) (solve (substring s 1))))\n    (else (string-append\
    \ (string-ref s 0) (solve (substring s 1))))))\n", "  (apply string (if (string-contains-ci\
    \ s #\\a)\n                    (map (lambda (c)\n                           (if\
    \ (letter? c)\n                               (if (char-upper-case? c)\n     \
    \                              (char-downcase c)\n                           \
    \        (char-upcase c))\n                               c))\n              \
    \           (string->list s))\n                    (reverse (string->list s)))))",
  "  (cond [(empty? s) empty]\n        [(not (letter? (first s)))\n         (list\
    \ (first s) (solve (rest s)))]\n        [else\n         (list (string-upcase (first\
    \ s)) (solve (rest s)))]))\n", "  (cond\n    [(string=? s \"\") \"\"]\n    [(not\
    \ (string-any (\u03BB (c) (char-alphabetic? c)) s)) (reverse s)]\n    [else\n\
    \     (define (string-map-in-place f str)\n       (let ((lst (string->list str)))\n\
    \         (for ([c lst])\n           (set! lst (append (list (f c)) (cdr lst))))\n\
    \         (list->string lst)))\n     (string-map-in-place (\u03BB (c) (if (char-alphabetic?\
    \ c) (char-swap-case c) c)) s)]))", "  (if (empty? s)\n      s\n      (if (letter?\
    \ (string-ref s 0))\n          (string-append (reverse-case (string-ref s 0))\
    \ (solve (substring s 1)))\n          (string-append (string-ref s 0) (solve (substring\
    \ s 1))))))\n", "  (if (not (find-letter s))\n      (reverse s)\n      (reverse-case-letter\
    \ s)))\n", "  (string-reverse\n   (string-map\n    (lambda (c)\n      (cond ((char-alphabetic?\
    \ c)\n             (char-upcase c))\n            ((char-numeric? c)\n        \
    \     (char-downcase c))\n            (else\n             c)))\n    s)))\n", " \
    \ (cond ((string-empty? s) \"\")\n        ((string-contains? s (regexp \"[[:alpha:]]\"\
    )) (string-reverse (string-map string-downcase s)))\n        (else (string-reverse\
    \ s))))\n", "  (regexp-replace* #rx\".\" s\n    [#rx\"[a-z]\" (lambda (m) (string-upcase\
    \ (substring m 0 1)))]\n    [#rx\"[A-Z]\" (lambda (m) (string-downcase (substring\
    \ m 0 1)))]))\n</code>\n", "  (cond\n    [(string=? s \"\") \"\"]\n    [(string=?\
    \ s (string-reverse s)) s]\n    [else\n     (define (reverse-str-pos pos str)\n\
    \       (string-append (substring str 0 pos)\n                      (if (char-lower-case?\
    \ (string-ref str pos))\n                          (string-upcase (string-ref\
    \ str pos))\n                          (string-downcase (string-ref str pos)))\n\
    \                      (substring str (+ pos 1) (string-length str))))\n     (define\
    \ (reverse-all-letters str)\n       (define (loop str i)\n         (if (= i (string-length\
    \ str))\n             str\n             (if (char-lower-case? (string-ref str\
    \ i))\n                 (loop (reverse-str-pos i str) (+ i 1))\n             \
    \    (loop str (+ i 1)))))\n       (loop str 0))\n     (string-reverse (reverse-all-letters\
    \ (string-reverse s)))]))\n", "  (if (regexp-match? #rx\"^[^a-zA-Z]*$\" s)\n \
    \     (string-reverse s)\n      (string-downcase s)\n  )\n)\n", "  (cond\n   \
    \ [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n     (string-append\n\
    \      (cond\n        [(char-uppercase? (string-ref s 0))\n         (string-downcase\
    \ (string (string-ref s 0)))]\n        [else\n         (string-upcase (string\
    \ (string-ref s 0)))])\n      (solve (substring s 1)))]\n    [else\n     (string-append\
    \ (string (string-ref s 0)) (solve (substring s 1)))]))\n", "  (cond\n    [(null?\
    \ s) \"\"]\n    [(char-numeric? (string-ref s 0)) (string-reverse s)]\n    [(char-alphabetic?\
    \ (string-ref s 0))\n     (let ([sym (string-ref s 0)])\n       (string (char-downcase\
    \ sym)))]\n    [else (string-ref s 0)]))\n)\n", "  (cond\n    [(empty? s) \"\"\
    ]\n    [(not (alphabetic? (first s)))\n     (string-append (solve (rest s)) (string\
    \ (first s)))]\n    [(upper-case? (first s))\n     (string-append (solve (rest\
    \ s)) (string-downcase (first s)))]\n    [else\n     (string-append (solve (rest\
    \ s)) (string-upcase (first s)))]))\n", "  (cond\n    [(empty? s) \"\"]\n    [(char-numeric?\
    \ (string-ref s 0))\n     (string-append (solve (substring s 1)) (string (string-ref\
    \ s 0)))]\n    [(char-alphabetic? (string-ref s 0))\n     (string-append (solve\
    \ (substring s 1)) (string (char-upcase? (string-ref s 0)))]\n    [else (string-append\
    \ (solve (substring s 1)) (string (string-ref s 0)))]))", "  (cond ((null? s)\n\
    \         \"\")\n        ((letter? (string-ref s 0))\n         (case-change s))\n\
    \        (else (append (string-reverse s) (solve (string-rest s))))))\n", "  \
    \  (define (f a b)\n        (string-append a (if (or (char=? b #\\a) (char=? b\
    \ #\\e) (char=? b #\\i) (char=? b #\\o) (char=? b #\\u))\n                   \
    \           (string-downcase (string b))\n                              (string-upcase\
    \ (string b)))))\n    (if (string-any (lambda (a) (char-alphabetic? a)) s)\n \
    \       (foldr f \"\" s)\n        (string-reverse s)))\n", "  (define (reverse-case\
    \ c)\n    (cond\n      [(char-lower-case? c) (char-upcase c)]\n      [(char-upper-case?\
    \ c) (char-downcase c)]\n      [else c]))\n  (if (not (string-contains-char? s\
    \ char-alphabetic?))\n      (string-reverse s)\n      (string-map reverse-case\
    \ s)))\n", "  (cond\n    [(empty? s) s]\n    [(char-alphabetic? (string-ref s\
    \ 0)) (string-upcase s)]\n    [else (string-downcase s)]))\n", "  (let ([s-vec\
    \ (string->vector s)])\n    (define (is-letter c)\n      (or (char-alphabetic?\
    \ c) (char-numeric? c)))\n    (define (is-lower? c)\n      (char-lower-case? c))\n\
    \    (define (solve-iter i)\n      (if (= i (vector-length s-vec))\n         \
    \ (vector->string s-vec)\n          (let ([c (vector-ref s-vec i)])\n        \
    \    (if (is-letter c)\n                (vector-set! s-vec i (if (is-lower? c)\
    \ (char-upcase c) (char-downcase c)))\n                (vector-set! s-vec i c))\n\
    \            (solve-iter (+ i 1)))))\n    (if (= (string-length s) 0)\n      \
    \  s\n        (solve-iter 0))))", "  (if (null? s)\n      s\n      (if (char-numeric?\
    \ (string-ref s 0))\n          (list-&gt;string (reverse (string-&gt;list s)))\n\
    \          (list-&gt;string (map (lambda (x) (if (char-numeric? x) x (if (char-lower-case?\
    \ x) (char-upcase x) (char-downcase x)))) (string-&gt;list s))))))\n</code>\n\
    I know that the solution is not elegant but it is something that I came up with.\
    \ How can I improve it?\n\n\nA:\n\nI'd write it like this:\n<code>(define (solve\
    \ s)\n  (cond\n    [(or (empty? s) (not (char-alpha? (string-ref s 0))))\n   \
    \  (string-reverse s)]\n    [else\n     (map (lambda (c)\n            (cond\n\
    \              [(char-upper-case? c) (char-downcase c)]\n              [(char-lower-case?\
    \ c) (char-upcase c)]\n              [else c]))\n          s)]))\n</code>\nHere's\
    \ what I changed:\n\nI renamed <code>s</code> to <code>string</code> to make the\
    \ functions more self-documenting.\nI replaced the <code>if</code> with a <code>cond</code>\
    \ because the <code>if</code> was just checking for <code>null?</code> in the\
    \ first clause; using <code>cond</code> allows me to also include the <code>not\
    \ (char-alpha? ...)</code> clause.\nI used <code>string-reverse</code> to reverse\
    \ the string instead of <code>list-&gt;string</code> because it's a built-in function.\n\
    I refactored the case conversion code into a lambda.\nI changed the name of the\
    \ <code>lambda</code> variable to <code>char</code> to make the function more\
    \ self-documenting.\nI added the final <code>else</code> clause to the case conversion\
    \ function.\nI replaced the <code>&gt;&gt;&gt;</code> with a <code>define</code>\
    \ because <", "  (if (string-index-right s #\\a)\n      (if (string-index-right\
    \ s #\\A)\n          (string-reverse s)\n          (string-map (lambda (c)\n \
    \                       (if (char-upper-case? c)\n                           \
    \ (char-downcase c)\n                            (char-upcase c)))\n         \
    \             s))\n      (string-reverse s)))\n", "  (cond\n    [(string=? s \"\
    \") \"\"]\n    [(or (char-numeric? (string-ref s 0)) (char-whitespace? (string-ref\
    \ s 0)))\n     (string-append (solve (substring s 1)) (string (string-ref s 0)))]\n\
    \    [(char-alphabetic? (string-ref s 0))\n     (string-append (solve (substring\
    \ s 1)) (string (char-foldcase (string-ref s 0))))]\n    [else\n     (string-append\
    \ (solve (substring s 1)) (string (string-ref s 0)))]))\n", "  (if (string-empty?\
    \ s)\n      s\n      (begin (displayln s)\n             (displayln (cond ((lower-case?\
    \ (string-ref s 0)) \n                               (string-upcase (string s)))\n\
    \                              ((upper-case? (string-ref s 0)) \n            \
    \                   (string-downcase (string s)))\n                          \
    \    (else s)))\n             (substring s 1))))\n", "  (cond\n    [(empty? s)\
    \ s]\n    [(char-alphabetic? (string-ref s 0)) (string-append (char-upcase (string-ref\
    \ s 0)) (solve (substring s 1)))]\n    [(char-numeric? (string-ref s 0)) (string-append\
    \ (char-downcase (string-ref s 0)) (solve (substring s 1)))]\n    [else (string-append\
    \ (string-ref s 0) (solve (substring s 1)))]))\n", "  (if (empty? s)\n      (string-reverse\
    \ s)\n      (string-append\n       (char-uppercase (string-ref s 0))\n       (string-lowercase\
    \ (string-append (string-drop s 1) (string-ref s 0))))))\n", "  (if (string-empty?\
    \ s)\n      \"\"\n      (define (flip-case c)\n        (cond\n          [(char-numeric?\
    \ c) c]\n          [(char-upper-case? c) (char-downcase c)]\n          [(char-lower-case?\
    \ c) (char-upcase c)]\n          [else c]))\n      (string-join (reverse (map\
    \ flip-case (string->list s))) \"\")))", "  (if (string-empty? s)\n      (string-reverse\
    \ s)\n      (let ((first-char (string-ref s 0)))\n        (string-append\n   \
    \      (if (char-alphabetic? first-char)\n             (string-ref s 0 (string-upcase\
    \ first-char))\n             (string-ref s 0 first-char))\n         (solve (string-drop\
    \ s 1))))))\n", "  (display s)\n  (display (reversed-string s))\n  (newline))\n",
  "  (define (helper s i)\n    (if (null? s)\n        \"\"\n        (if (or (char=?\
    \ (string-ref s i) #\\a)\n                (char=? (string-ref s i) #\\b)\n   \
    \             (char=? (string-ref s i) #\\c)\n                (char=? (string-ref\
    \ s i) #\\d)\n                (char=? (string-ref s i) #\\e)\n               \
    \ (char=? (string-ref s i) #\\f)\n                (char=? (string-ref s i) #\\\
    g)\n                (char=? (string-ref s i) #\\h)\n                (char=? (string-ref\
    \ s i) #\\i)\n                (char=? (string-ref s i) #\\j)\n               \
    \ (char=? (string-ref s i) #\\k)\n                (char=? (string-ref s i) #\\\
    l)\n                (char=? (string-ref s i) #\\m)\n                (char=? (string-ref\
    \ s i) #\\n)\n                (char=? (string-ref s i) #\\o)\n               \
    \ (char=? (string-ref s i) #\\p)\n                (char=? (string-ref s i) #\\\
    q)\n                (char=? (string-ref s i) #\\r)\n                (char=? (string-ref\
    \ s i) #\\s)\n                (char=? (string-ref s i) #\\t)\n               \
    \ (char=? (string-ref s i) #\\u)\n                (char=? (string-ref s i) #\\\
    v)\n                (char=? (string-ref s i) #\\w)\n                (char=? (string-ref\
    \ s i) #\\x)\n                (char=? (string-ref s i) #\\y)\n               \
    \ (char=? (string-ref s i) #\\z))\n            (string-append\n             (helper\
    \ s (- i 1))\n             (string-upcase (string (string-ref s i))))\n      \
    \      (string-append\n             (helper s", "  (if (string-empty? s)\n   \
    \   s\n      (if (char-numeric? (string-ref s 0))\n          (reverse s)\n   \
    \       (string-append (char->string (char-upcase (string-ref s 0)))\n       \
    \                  (string-append (solve (substring s 1))\n                  \
    \                      (char->string (char-downcase (string-ref s 0))))))))\n",
  "  (cond\n    [(empty? s) (reverse s)]\n    [(char-alphabetic? (string-ref s 0))\n\
    \     (string-append (string (char-downcase (string-ref s 0))) (solve (substring\
    \ s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append (string\
    \ (char-upcase (string-ref s 0))) (solve (substring s 1)))]\n    [else (string-append\
    \ (string (string-ref s 0)) (solve (substring s 1)))]))\n", "  (if (string-contains\
    \ s #\\a)\n      (list->string (map (\u03BB (c)\n                           (if\
    \ (char-alphabetic? c)\n                               (char-upcase c)\n     \
    \                          (char-downcase c)))\n                         (string->list\
    \ s)))\n      (reverse s)))\n", "  (if (string-contains? s \"a-zA-Z\")\n     \
    \ (string-upcase s)\n      (string-reverse s)))", "  (cond\n    [(empty? s) empty]\n\
    \    [(lower-case? (first s)) (string-append (string-upcase (first s)) (solve\
    \ (rest s)))]\n    [(upper-case? (first s)) (string-append (string-downcase (first\
    \ s)) (solve (rest s)))]\n    [else (string-append (first s) (solve (rest s)))]))\n\
    ```\n\n### Examples\n\n```racket", "  (regexp-replace* #rx\"[a-zA-Z]\" s (lambda\
    \ (m) (string-upcase (string-downcase m)))))\n", "  (if (no-letters? s)\n    \
    \  (reverse s)\n      (reverse-case s)))\n", "  (regexp-replace* #rx\"([a-zA-Z])\"\
    \n                   s\n                   (lambda (m) (string-upcase (string-downcase\
    \ (cadr m))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
