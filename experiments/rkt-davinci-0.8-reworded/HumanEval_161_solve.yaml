name: HumanEval_161_solve
language: rkt
prompt: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter, reverse\
  \ its case from lower to upper or vise versa, \n;; otherwise keep it as it is.\n\
  ;; If the string contains no letters, reverse the string.\n;; The function should\
  \ return the resulted string.\n;; Examples\n;; >>> (solve \"1234\")\n;; \"4321\"\
  \n;; >>> (solve \"ab\")\n;; \"AB\"\n;; >>> (solve \"#a@C\")\n;; \"#A@c\"\n(define\
  \ (solve s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
  \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
  \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
  \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"\
  #aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
  \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\"\
  )\n))\n\n(test-humaneval)"
completions: ["  (map (\u03BB (c) (match c [#\\a #\\A]\n                        [#\\\
    b #\\B]\n                        [#\\c #\\C]\n                        [#\\d #\\\
    D]\n                        [#\\e #\\E]\n                        [#\\f #\\F]\n\
    \                        [#\\g #\\G]\n                        [#\\h #\\H]\n  \
    \                      [#\\i #\\I]\n                        [#\\j #\\J]\n    \
    \                    [#\\k #\\K]\n                        [#\\l #\\L]\n      \
    \                  [#\\m #\\M]\n                        [#\\n #\\N]\n        \
    \                [#\\o #\\O]\n                        [#\\p #\\P]\n          \
    \              [#\\q #\\Q]\n                        [#\\r #\\R]\n            \
    \            [#\\s #\\S]\n                        [#\\t #\\T]\n              \
    \          [#\\u #\\U]\n                        [#\\v #\\V]\n                \
    \        [#\\w #\\W]\n                        [#\\x #\\X]\n                  \
    \      [#\\y #\\Y]\n                        [#\\z #\\Z]\n                    \
    \    [_ c]))\n          (reverse s)))\n", "  (cond\n    ((null? s) '())\n    ((char-alphabetic?\
    \ (car s)) (cons (flip-case (car s)) (solve (cdr s))))\n    (else (cons (car s)\
    \ (solve (cdr s))))))\n", "  (cond ((null? s) \"\")\n        ((string-contains-letter?\
    \ s)\n         (string-reverse-letters (string-reverse-case s)))\n        (else\
    \ (string-reverse s))))\n", "  (string-reverse (map (lambda (c)\n            \
    \             (if (char-alphabetic? c)\n                             (if (char-lower-case?\
    \ c)\n                                 (char-upcase c)\n                     \
    \            (char-downcase c))\n                             c)) s)))", "  (cond\
    \ ((null? s) \"\")\n        ((char-numeric? (string-ref s 0))\n         (string-append\
    \ (solve (substring s 1)) (string (string-ref s 0))))\n        ((char-upper-case?\
    \ (string-ref s 0))\n         (string-append (solve (substring s 1)) (string (char-downcase\
    \ (string-ref s 0)))))\n        ((char-lower-case? (string-ref s 0))\n       \
    \  (string-append (solve (substring s 1)) (string (char-upcase (string-ref s 0)))))))\n\
    ```\n\n```scheme\n#lang racket\n", "  (cond\n    ((string-no-letter? s) (reverse\
    \ s))\n    (else (string-map (lambda (c) (if (char-lower-case? c) (char-upcase\
    \ c) (char-downcase c))) s))))\n", "  (if (string-contains-letter? s)\n      (revers-case\
    \ s)\n      (string-reverse s)))\n", "  (if (null? s) (list)\n    (if (or (char-numeric?\
    \ (string-ref s 0)) (char-punctuation? (string-ref s 0)))\n        (cons (string-ref\
    \ s 0) (solve (substring s 1)))\n        (cons (char-upcase (string-ref s 0))\
    \ (solve (substring s 1))))))\n", "  (cond\n    [(empty? s) '()]\n    [(char-alphabetic?\
    \ (first s))\n     (append\n      (list (char-upcase (first s)))\n      (solve\
    \ (rest s)))]\n    [else\n     (append\n      (list (first s))\n      (solve (rest\
    \ s)))]))", "  (cond\n    [(empty? s) s]\n    [(char-alphabetic? (string-ref s\
    \ 0))\n     (reverse s)]\n    [else\n     (string-append\n      (char->string\
    \ (string-ref s 0))\n      (solve (string-drop s 1)))]))\n", "  (display (str-transform\
    \ s)))\n", "  (cond\n    [(empty? s)\n     (reverse s)]\n    [(char-numeric? (first\
    \ s))\n     (cons (first s) (solve (rest s)))]\n    [(char-alphabetic? (first\
    \ s))\n     (cons (char-upcase (first s)) (solve (rest s)))]\n    [else\n    \
    \ (cons (char-downcase (first s)) (solve (rest s)))]))\n", "  (cond\n    [(and\
    \ (string? s)\n          (not (empty? s)))\n     (if (member (string-ref s 0)\n\
    \                 (string->list \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ))\n         (string-join\n          (map\n           (lambda (ch)\n         \
    \    (if (char-lower-case? ch)\n                 (char-upcase ch)\n          \
    \       (char-downcase ch)))\n           (string->list s)))\n         (string-reverse\
    \ s))]\n    [else (error \"Not a valid input\")]))", "  (define (reverse-case\
    \ ch)\n    (cond\n      [(char-alphabetic? ch)\n       (string->char (symbol->string\
    \ (string->symbol\n                                      (string (char-upcase\
    \ ch)))))\n       ]\n      [(char-numeric? ch)\n       (string->char (symbol->string\
    \ (string->symbol\n                                      (string (char-downcase\
    \ ch)))))\n       ]\n      [else ch]))\n  (if (any char-alphabetic? s)\n     \
    \ (map reverse-case s)\n      (reverse s)))\n", "  (cond\n    [(string=? \"\"\
    \ s) \"\"]\n    [(string=? (string-map char-downcase s) s) (string-map char-upcase\
    \ s)]\n    [(string=? (string-map char-upcase s) s) (string-map char-downcase\
    \ s)]\n    [else (reverse s)]))\n", "  (cond\n    [(string-empty? s)\n     (error\
    \ \"solve: empty string\")]\n    [(string=? s (string-downcase s))\n     (string-upcase\
    \ s)]\n    [(string=? s (string-upcase s))\n     (string-downcase s)]\n    [else\n\
    \     (string-map (lambda (c)\n                   (cond\n                    \
    \ [(letter? c)\n                      (if (string-ci=? (string c) (string (char-downcase\
    \ c)))\n                          (char-upcase c)\n                          (char-downcase\
    \ c))]\n                     [else\n                      c]))\n             \
    \    s)]))\n", "  (cond\n    [(string-empty? s) s]\n    [(letter? (string-ref\
    \ s 0))\n     (string-append (reverse-case (string-ref s 0)) (solve (substring\
    \ s 1)))]\n    [else\n     (string-append (string-ref s 0) (solve (substring s\
    \ 1)))]))\n", "  (if (string-contains-char? s (lambda (c) (char-alpha? c)))\n\
    \      (string-for-each\n       (lambda (c)\n         (if (char-alpha? c)\n  \
    \           (string-set! s (string-index s c)\n                         (if (char-lower-case?\
    \ c)\n                             (char-upcase c)\n                         \
    \    (char-downcase c)))\n             s))\n       s)\n      (string-reverse s)))\n",
  "  (if (not (string-contains-pred (char-alphabetic?) s))\n      (reverse s)\n  \
    \    (string-map-index (\u03BB (i ch)\n                         (if (char-alphabetic?\
    \ ch)\n                             (if (char-lower-case? ch)\n              \
    \                   (char-upcase ch)\n                                 (char-downcase\
    \ ch))\n                             ch))\n                       s)))\n", " \
    \ (if (not (regexp-match? #rx\"[a-zA-Z]\" s))\n      (string-reverse s)\n    \
    \  (string-map (\u03BB (x)\n                    (if (regexp-match? #rx\"[a-zA-Z]\"\
    \ (string x))\n                        (if (string-upcase? (string x))\n     \
    \                       (string-downcase (string x))\n                       \
    \     (string-upcase (string x)))\n                        x))\n             \
    \     s)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
