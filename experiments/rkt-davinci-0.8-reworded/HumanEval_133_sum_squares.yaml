name: HumanEval_133_sum_squares
language: rkt
prompt: "#lang racket\n\n;; You are given a list of numbers.\n;; You need to return\
  \ the sum of squared numbers in the given list,\n;; round each element in the list\
  \ to the upper int(Ceiling) first.\n;; Examples:\n;; >>> (lst (list 1.0 2.0 3.0))\n\
  ;; 14\n;; >>> (lst (list 1.0 4.0 9.0))\n;; 98\n;; >>> (lst (list 1.0 3.0 5.0 7.0))\n\
  ;; 84\n;; >>> (lst (list 1.4 4.2 0.0))\n;; 29\n;; >>> (lst (list -2.4 1.0 1.0))\n\
  ;; 6\n(define (sum_squares lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n\
  \    (check-equal? (candidate (list 1.0 2.0 3.0)) 14)\n    (check-equal? (candidate\
  \ (list 1.0 2.0 3.0)) 14)\n    (check-equal? (candidate (list 1.0 3.0 5.0 7.0))\
  \ 84)\n    (check-equal? (candidate (list 1.4 4.2 0.0)) 29)\n    (check-equal? (candidate\
  \ (list -2.4 1.0 1.0)) 6)\n    (check-equal? (candidate (list 100.0 1.0 15.0 2.0))\
  \ 10230)\n    (check-equal? (candidate (list 10000.0 10000.0)) 200000000)\n    (check-equal?\
  \ (candidate (list -1.4 4.6 6.3)) 75)\n    (check-equal? (candidate (list -1.4 17.9\
  \ 18.9 19.9)) 1086)\n    (check-equal? (candidate (list 0.0)) 0)\n    (check-equal?\
  \ (candidate (list -1.0)) 1)\n    (check-equal? (candidate (list -1.0 1.0 0.0))\
  \ 2)\n))\n\n(test-humaneval)"
completions: ["  (apply + (map (lambda (x) (* x x))\n                (map ceil lst))))\n\
    </code>\n", "  (apply + (map (lambda (x) (expt x 2))\n                (map ceiling\
    \ lst))))\n", "  (define (squared x)\n    (* x x))\n  (define (sqrt n)\n    (sqrt/iter\
    \ 1.0 n))\n  (define (sqrt/iter guess n)\n    (if (good-enough? guess n)\n   \
    \     guess\n        (sqrt/iter (improve guess n) n)))\n  (define (good-enough?\
    \ guess n)\n    (< (abs (- (squared guess) n)) 0.001))\n  (define (improve guess\
    \ n)\n    (average guess (/ n guess)))\n  (define (average x y)\n    (/ (+ x y)\
    \ 2))\n  (foldl + 0 (map squared (map sqrt lst))))\n", "  (define (do_it accum\
    \ elem)\n    (+ (* elem elem) accum))\n  (foldl do_it 0 lst))\n", "  (apply +\
    \ (map (lambda (x) (expt (ceiling x) 2)) lst)))\n", "  (sum (map (lambda (x) (*\
    \ x x)) (map (lambda (x) (ceiling x)) lst))))\n", "  (define (square x) (* x x))\n\
    \  (define (add_all x y) (+ x y))\n  (define (square_all lst)\n    (map square\
    \ lst))\n  (define (ceiling_all lst)\n    (map ceiling lst))\n  (foldl add_all\
    \ 0 (square_all (ceiling_all lst))))\n", "  (apply + (map (lambda (n) (expt n\
    \ 2))\n                (map ceiling lst))))\n</code>\n", "  (apply + (map (lambda\
    \ (x) (expt (ceiling x) 2)) lst)))\n", "  (apply + (map (lambda (x) (expt x 2))\
    \ (map ceiling lst))))\n", "  (cond [(empty? lst) 0]\n        [else (+ (expt (round\
    \ (first lst)) 2)\n                 (sum_squares (rest lst)))]))\n", "  (if (empty?\
    \ lst)\n      0\n      (+ (expt (ceiling (first lst)) 2)\n         (sum_squares\
    \ (rest lst)))))\n", "  (sum (map (lambda (x) (expt x 2))\n            (map ceiling\
    \ lst))))\n", "  (apply + (map (lambda (x) (square (ceiling x))) lst)))\n", " \
    \ (apply + (map (lambda (x) (* x x)) (map ceiling lst))))\n", "  (apply + (map\
    \ (lambda (x) (inexact->exact (round (* x x)))) lst)))\n", "  (apply + (map (lambda\
    \ (x) (expt (ceiling x) 2)) lst)))\n", "  (cond [(empty? lst) 0]\n        [else\
    \ (+ (sqr (ceiling (first lst)))\n                 (sum_squares (rest lst)))]))\n",
  "  (apply + (map (lambda (e) (expt e 2)) (map ceiling lst))))\n", "  (apply + (map\
    \ (lambda (x) (* x x))\n                (map (lambda (x) (ceiling x))\n      \
    \               lst))))"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
