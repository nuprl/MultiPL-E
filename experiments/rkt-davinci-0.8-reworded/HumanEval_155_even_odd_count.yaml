name: HumanEval_155_even_odd_count
language: rkt
prompt: "#lang racket\n\n;; Given an integer. return a list that has the number of\
  \ even and odd digits respectively.\n;; Example:\n;; >>> (even_odd_count -12)\n\
  ;; (list 1 1)\n;; >>> (even_odd_count 123)\n;; (list 1 2)\n(define (even_odd_count\
  \ num)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate even_odd_count))\n\
  \    (check-equal? (candidate 7) (list 0 1))\n    (check-equal? (candidate -78)\
  \ (list 1 1))\n    (check-equal? (candidate 3452) (list 2 2))\n    (check-equal?\
  \ (candidate 346211) (list 3 3))\n    (check-equal? (candidate -345821) (list 3\
  \ 3))\n    (check-equal? (candidate -2) (list 1 0))\n    (check-equal? (candidate\
  \ -45347) (list 2 3))\n    (check-equal? (candidate 0) (list 1 0))\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(= num 0) (list 0 0)]\n    [(= (modulo num 10) 0) (cons\
    \ 1 (even_odd_count (quotient num 10)))]\n    [(= (modulo num 10) 1) (cons 0 (even_odd_count\
    \ (quotient num 10)))]\n    [(= (modulo num 10) 2) (cons 1 (even_odd_count (quotient\
    \ num 10)))]\n    [(= (modulo num 10) 3) (cons 0 (even_odd_count (quotient num\
    \ 10)))]\n    [(= (modulo num 10) 4) (cons 1 (even_odd_count (quotient num 10)))]\n\
    \    [(= (modulo num 10) 5) (cons 0 (even_odd_count (quotient num 10)))]\n   \
    \ [(= (modulo num 10) 6) (cons 1 (even_odd_count (quotient num 10)))]\n    [(=\
    \ (modulo num 10) 7) (cons 0 (even_odd_count (quotient num 10)))]\n    [(= (modulo\
    \ num 10) 8) (cons 1 (even_odd_count (quotient num 10)))]\n    [(= (modulo num\
    \ 10) 9) (cons 0 (even_odd_count (quotient num 10)))]))\n", "    (if (zero? num)\n\
    \        (list 0 0)\n        (let* ([tail-count (even_odd_count (quotient num\
    \ 10))]\n               [tail-even (car tail-count)]\n               [tail-odd\
    \ (cadr tail-count)])\n            (if (even? (remainder num 10))\n          \
    \      (list (+ tail-even 1) tail-odd)\n                (list tail-even (+ tail-odd\
    \ 1))))))\n", "  (local [(define (even_count num acc)\n            (cond [(= num\
    \ 0) acc]\n                  [(even? (remainder num 10)) (even_count (quotient\
    \ num 10) (+ acc 1))]\n                  [else (even_count (quotient num 10) acc)]))\n\
    \          (define (odd_count num acc)\n            (cond [(= num 0) acc]\n  \
    \                [(odd? (remainder num 10)) (odd_count (quotient num 10) (+ acc\
    \ 1))]\n                  [else (odd_count (quotient num 10) acc)]))]\n    (list\
    \ (even_count num 0) (odd_count num 0))))\n", "    (define n num)\n    (define\
    \ (odd_recur n acc)\n      (if (&lt; n 10)\n        acc\n        (if (odd? (remainder\
    \ n 10))\n          (odd_recur (/ n 10) (+ acc 1))\n          (odd_recur (/ n\
    \ 10) acc))))\n    (define (even_recur n acc)\n      (if (&lt; n 10)\n       \
    \ acc\n        (if (even? (remainder n 10))\n          (even_recur (/ n 10) (+\
    \ acc 1))\n          (even_recur (/ n 10) acc))))\n    (list (even_recur n 0)\
    \ (odd_recur n 0)))\n", "  (count-even-odd num))\n", "  (define (even? num)\n\
    \    (if (even? num) (begin (set! num (+ num -1)))))\n  (define (odd? num)\n \
    \   (if (odd? num) (begin (set! num (+ num -1)))))\n  (for-each (even? num)\n\
    \    (list even odd))\n  )\n", "  (let loop ((num num) (even-count 0) (odd-count\
    \ 0))\n    (cond\n      [(zero? num) (list even-count odd-count)]\n      [(even?\
    \ (remainder num 10)) (loop (quotient num 10) (+ even-count 1) odd-count)]\n \
    \     [else (loop (quotient num 10) even-count (+ odd-count 1))])))\n", "  (match\
    \ (abs num)\n    [0 (list 0 0)]\n    [else (match (modulo (abs num) 10)\n    \
    \     [0 (let ([ev (even_odd_count (quotient (abs num) 10))])\n              \
    \ (list (+ (first ev) 1) (second ev)))]\n         [else (let ([ev (even_odd_count\
    \ (quotient (abs num) 10))])\n                (list (first ev) (+ (second ev)\
    \ 1)))])]))\n", "  (let loop ([num num] [evens 0] [odds 0])\n    (cond [(negative?\
    \ num) (list evens odds)]\n          [(zero? num) (list (add1 evens) odds)]\n\
    \          [else (loop (quotient num 10) (add1 evens) (add1 odds))])))\n", " \
    \ (cond [(= num 0) (list 0 0)]\n        [(= (modulo num 10) 0)\n         (let*\
    \ ([z (even_odd_count (quotient num 10))]\n                [q (car z)]\n     \
    \           [p (cadr z)])\n           (list (+ q 1) p))]\n        [else\n    \
    \     (let* ([z (even_odd_count (quotient num 10))]\n                [q (car z)]\n\
    \                [p (cadr z)])\n           (list q (+ p 1)))]))\n", "  (let ((even-count\
    \ 0)\n        (odd-count 0))\n    (let loop ((n (abs num)))\n      (cond\n   \
    \     [(= n 0) (list even-count odd-count)]\n        [(even? (remainder n 10))\n\
    \         (loop (quotient n 10))\n         (set! even-count (+ even-count 1))]\n\
    \        [else\n         (loop (quotient n 10))\n         (set! odd-count (+ odd-count\
    \ 1))]))\n    (list even-count odd-count)))\n", "  (cond\n    [(negative? num)\
    \ (even_odd_count (- num))]\n    [(zero? num) (list 0 0)]\n    [else (let ((remainder\
    \ (modulo num 10)))\n            (if (even? remainder)\n                (cons\
    \ 1 (even_odd_count (quotient num 10)))\n                (cons 0 (even_odd_count\
    \ (quotient num 10)))))]))\n</code>\nPossible solution to the bonus:\n<code>#lang\
    \ racket\n", "  (define (count num acc)\n    (if (zero? num)\n        acc\n  \
    \      (count (quotient num 10)\n               (let ([digit (remainder num 10)])\n\
    \                 (cond\n                   [(even? digit) (list (+ (first acc)\
    \ 1) (second acc))]\n                   [else (list (first acc) (+ (second acc)\
    \ 1))])))))\n  (count num (list 0 0)))\n</code>\n", "  (cond ((= num 0) (list\
    \ 0 0))\n        ((even? (abs num)) (cons 1 (even_odd_count (quotient (abs num)\
    \ 10))))\n        (else (cons 0 (even_odd_count (quotient (abs num) 10))))))\n",
  "  (letrec\n    [(accumulator [even-count odd-count] (cons even-count odd-count))\n\
    \     (even? [digit] (zero? (remainder digit 2)))\n     (dive [num]\n       (cond\n\
    \         [(zero? num) (accumulator 0 0)]\n         [(even? (abs num)) (dive (quotient\
    \ num 10) (accumulator (+ 1 (first accumulator)) (second accumulator)))]\n   \
    \      [else (dive (quotient num 10) (accumulator (first accumulator) (+ 1 (second\
    \ accumulator))))]))]\n    (dive num)))\n", "  (let ((odds '())\n        (evens\
    \ '()))\n    (for ([char (string->list (number->string num))])\n      (cond\n\
    \        [(even? (string->number (string char))) (set! evens (cons 1 evens))]\n\
    \        [else (set! odds (cons 1 odds))]))\n    (list (length evens) (length\
    \ odds))))\n", "  (define (is_even? num)\n    (and (not (zero? num)) (zero? (modulo\
    \ num 2))))\n  (define (count_even_odd_helper num count_even count_odd)\n    (cond\n\
    \      [(zero? num) (list count_even count_odd)]\n      [(is_even? (remainder\
    \ num 10)) (count_even_odd_helper (quotient num 10) (+ count_even 1) count_odd)]\n\
    \      [else (count_even_odd_helper (quotient num 10) count_even (+ count_odd\
    \ 1))]))\n  (count_even_odd_helper num 0 0))\n```\n\n[Back to problem](#p4)\n\n\
    ---\n\n## Problem 5\n\n<a name=\"p5\"></a>\n\n> Write a function that given two\
    \ numbers, returns a list that contains the number of `1s`, `2s`, `3s`, etc in\
    \ the two numbers.\n>\n> Example:\n>\n> ```\n> >>> (count_digits 12345 67890)\n\
    > (list 0 0 1 0 1 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\
    \ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\
    \ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\
    \ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\
    \ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\
    \ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\
    \ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0", "  (let loop ((num\
    \ num) (even 0) (odd 0))\n    (if (zero? num)\n        (list even odd)\n     \
    \   (let ((n (remainder num 10)))\n          (if (even? n)\n              (loop\
    \ (quotient num 10) (+ even 1) odd)\n              (loop (quotient num 10) even\
    \ (+ odd 1)))))))\n", "  (letrec ([even_count 0]\n           [odd_count 0]\n \
    \          [even? (lambda (x) (if (or (= x 0) (= x 2) (= x 4) (= x 6) (= x 8))\
    \ #t #f))]\n           [sum-even (lambda (x) (set! even_count (+ even_count 1)))]\n\
    \           [sum-odd (lambda (x) (set! odd_count (+ odd_count 1)))])\n    (for/list\
    \ ([n (range (abs num))])\n      (if (even? n)\n          (sum-even n)\n     \
    \     (sum-odd n)))\n    (list even_count odd_count)))\n", "  (cond\n    [(= num\
    \ 0) (list 0 0)]\n    [(and (even? (remainder num 10)) (odd? (quotient num 10)))\n\
    \     (let* ([s (even_odd_count (quotient num 10))]\n            [e (add1 (car\
    \ s))]\n            [o (cadr s)])\n       (list e o))]\n    [(and (odd? (remainder\
    \ num 10)) (even? (quotient num 10)))\n     (let* ([s (even_odd_count (quotient\
    \ num 10))]\n            [e (car s)]\n            [o (add1 (cadr s))])\n     \
    \  (list e o))]\n    [(and (even? (remainder num 10)) (even? (quotient num 10)))\n\
    \     (let* ([s (even_odd_count (quotient num 10))]\n            [e (add1 (car\
    \ s))]\n            [o (cadr s)])\n       (list e o))]\n    [(and (odd? (remainder\
    \ num 10)) (odd? (quotient num 10)))\n     (let* ([s (even_odd_count (quotient\
    \ num 10))]\n            [e (car s)]\n            [o (add1 (cadr s))])\n     \
    \  (list e o))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
