name: HumanEval_78_hex_key
language: rkt
prompt: "#lang racket\n\n;; You have been tasked to write a function that receives\
  \ \n;; a hexadecimal number as a string and counts the number of hexadecimal \n\
  ;; digits that are primes (prime number, or a prime, is a natural number \n;; greater\
  \ than 1 that is not a product of two smaller natural numbers).\n;; Hexadecimal\
  \ digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n;; Prime numbers are\
  \ 2, 3, 5, 7, 11, 13, 17,...\n;; So you have to determine a number of the following\
  \ digits: 2, 3, 5, 7, \n;; B (=decimal 11), D (=decimal 13).\n;; Note: you may assume\
  \ the input is always correct or empty string, \n;; and symbols A,B,C,D,E,F are\
  \ always uppercase.\n;; Examples:\n;; >>> (hex_key \"AB\")\n;; 1\n;; >>> (hex_key\
  \ \"1077E\")\n;; 2\n;; >>> (hex_key \"ABED1A33\")\n;; 4\n;; >>> (hex_key \"123456789ABCDEF0\"\
  )\n;; 6\n;; >>> (hex_key \"2020\")\n;; 2\n(define (hex_key num)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate hex_key))\n\
  \    (check-equal? (candidate \"AB\") 1)\n    (check-equal? (candidate \"1077E\"\
  ) 2)\n    (check-equal? (candidate \"ABED1A33\") 4)\n    (check-equal? (candidate\
  \ \"2020\") 2)\n    (check-equal? (candidate \"123456789ABCDEF0\") 6)\n    (check-equal?\
  \ (candidate \"112233445566778899AABBCCDDEEFF00\") 12)\n))\n\n(test-humaneval)"
completions: ["  (define (hex_char_to_int c)\n    (cond ((= c #\\0) 0)\n         \
    \ ((= c #\\1) 1)\n          ((= c #\\2) 2)\n          ((= c #\\3) 3)\n       \
    \   ((= c #\\4) 4)\n          ((= c #\\5) 5)\n          ((= c #\\6) 6)\n     \
    \     ((= c #\\7) 7)\n          ((= c #\\8) 8)\n          ((= c #\\9) 9)\n   \
    \       ((= c #\\A) 10)\n          ((= c #\\B) 11)\n          ((= c #\\C) 12)\n\
    \          ((= c #\\D) 13)\n          ((= c #\\E) 14)\n          ((= c #\\F) 15)))\n\
    \  (define (char-list-to-int lst)\n    (if (null? lst)\n        0\n        (+\
    \ (* (hex_char_to_int (car lst)) (expt 16 (- (length lst) 1)))\n           (char-list-to-int\
    \ (cdr lst)))))\n  (define (is-prime n)\n    (cond ((= n 1) false)\n         \
    \ ((= n 2) true)\n          ((> n 2)\n           (let loop ((i 2))\n         \
    \    (cond ((= i n) true)\n                   ((= (modulo n i) 0) false)\n   \
    \                (else (loop (+ i 1))))))))\n  (define (all-digits-prime lst)\n\
    \    (if (null? lst)\n        0\n        (+ (if (is-prime (hex_char_to_int (car\
    \ lst))) 1 0)\n           (all-digits-prime (cdr lst)))))\n  (all-digits-prime\
    \ (string->list num)))\n", "  (let* \n      ([lst (string->list num)]\n      \
    \ [count 0])\n    (for ([x lst])\n      (define a (char->integer x))\n      (and\
    \ \n       (<= a 70)\n       (>= a 65)\n       (set! a (+ a 10)))\n      (and\n\
    \       (member a (list 2 3 5 7 11 13))\n       (set! count (+ count 1))))\n \
    \   count))", "  (define (is-prime num)\n    (if (= num 1) #f\n        (if (=\
    \ num 2) #t\n            (define (loop i)\n              (if (= i (/ num 2)) #t\n\
    \                  (if (= (modulo num i) 0) #f\n                      (loop (+\
    \ i 1)))))\n            (loop 2))))\n  (define (loop num sum)\n    (if (not (string?\
    \ num)) sum\n        (if (and (or (char=? (string-ref num 0) #\\2)\n         \
    \           (char=? (string-ref num 0) #\\3)\n                    (char=? (string-ref\
    \ num 0) #\\5)\n                    (char=? (string-ref num 0) #\\7)\n       \
    \             (char=? (string-ref num 0) #\\B)\n                    (char=? (string-ref\
    \ num 0) #\\D))\n                (is-prime (string->number (string (string-ref\
    \ num 0)) 16)))\n            (loop (substring num 1) (+ sum 1))\n            (loop\
    \ (substring num 1) sum))))\n  (loop num 0))\n</code>\n", "  (define (primes-in-number\
    \ number)\n    (cond [(> number 0)\n           (cond [(hex_prime? number)\n  \
    \                (+ 1 (primes-in-number (quotient number 16)))]\n            \
    \     [else\n                  (primes-in-number (quotient number 16))])]\n  \
    \        [else\n           0]))\n  (define (hex_prime? number)\n    (member number\
    \ '(2 3 5 7 11 13)))\n  (define (hex-to-decimal number)\n    (cond [(empty? number)\n\
    \           0]\n          [else\n           (+ (* (first number) (expt 16 (- (string-length\
    \ number) 1)))\n              (hex-to-decimal (rest number)))]))\n  (primes-in-number\
    \ (hex-to-decimal num)))", "  (if (string-null? num)\n      0\n      (if (string-member\
    \ (string-ref num 0) \"2357BD\")\n          (+ 1 (hex_key (string-drop num 1)))\n\
    \          (hex_key (string-drop num 1)))))\n", "  (length (list-remove (list->set\
    \ (string->list num)) '(#\\A #\\B #\\C #\\D #\\E #\\F #\\1 #\\3 #\\4 #\\6 #\\\
    8 #\\9 #\\0))))\n", "  (define (is-prime num)\n    (define (inner num cur)\n \
    \     (if (= num cur)\n        #t\n        (if (= 0 (modulo num cur))\n      \
    \    #f\n          (inner num (+ cur 1)))))\n    (inner num 2))\n  (define (is-prime-hex\
    \ num)\n    (if (or (= num #\\2) (= num #\\3) (= num #\\5) (= num #\\7) (= num\
    \ #\\B) (= num #\\D))\n      #t\n      #f))\n  (define (inner num cur cnt)\n \
    \   (if (= cur (string-length num))\n      cnt\n      (if (and (is-prime-hex (string-ref\
    \ num cur))\n            (is-prime (string->number (substring num cur (+ cur 1))\
    \ 16)))\n        (inner num (+ cur 1) (+ cnt 1))\n        (inner num (+ cur 1)\
    \ cnt))))\n  (inner num 0 0))\n", "  (define (prime n)\n    (cond\n      [(= n\
    \ 1) #f]\n      [(= n 2) #t]\n      [(= n 3) #t]\n      [(even? n) #f]\n     \
    \ [(prime-rec n (/ n 2)) #f]\n      [else #t]))\n  (define (prime-rec n m)\n \
    \   (cond\n      [(= m 1) #t]\n      [(even? m) (prime-rec n (/ m 2))]\n     \
    \ [(zero? (modulo n m)) #f]\n      [else (prime-rec n (- m 1))]))\n  (cond\n \
    \   [(string=? num \"\") 0]\n    [(string=? num \"A\") 1]\n    [(string=? num\
    \ \"B\") 1]\n    [(string=? num \"D\") 1]\n    [(string=? num \"E\") 1]\n    [(string=?\
    \ num \"F\") 1]\n    [(prime (string->number num 16)) (+ 1 (hex_key (substring\
    \ num 1)))]\n    [else (hex_key (substring num 1))]))", "  (length (filter (\u03BB\
    \ (x) (list-member (list #\\2 #\\3 #\\5 #\\7 #\\B #\\D) x)) (string->list num))))\n",
  "  (let ([count 0])\n    (for ([c (in-string num)])\n      (cond [(member c '(#\\\
    2 #\\3 #\\5 #\\7 #\\B #\\D))\n             (set! count (+ count 1))]))\n    count))\n",
  "  (define (get-digit-values num)\n    (cond\n      [(empty? num) empty]\n     \
    \ [(equal? (first num) #\\0) (cons 0 (get-digit-values (rest num)))]\n      [(equal?\
    \ (first num) #\\1) (cons 1 (get-digit-values (rest num)))]\n      [(equal? (first\
    \ num) #\\2) (cons 2 (get-digit-values (rest num)))]\n      [(equal? (first num)\
    \ #\\3) (cons 3 (get-digit-values (rest num)))]\n      [(equal? (first num) #\\\
    4) (cons 4 (get-digit-values (rest num)))]\n      [(equal? (first num) #\\5) (cons\
    \ 5 (get-digit-values (rest num)))]\n      [(equal? (first num) #\\6) (cons 6\
    \ (get-digit-values (rest num)))]\n      [(equal? (first num) #\\7) (cons 7 (get-digit-values\
    \ (rest num)))]\n      [(equal? (first num) #\\8) (cons 8 (get-digit-values (rest\
    \ num)))]\n      [(equal? (first num) #\\9) (cons 9 (get-digit-values (rest num)))]\n\
    \      [(equal? (first num) #\\A) (cons 10 (get-digit-values (rest num)))]\n \
    \     [(equal? (first num) #\\B) (cons 11 (get-digit-values (rest num)))]\n  \
    \    [(equal? (first num) #\\C) (cons 12 (get-digit-values (rest num)))]\n   \
    \   [(equal? (first num) #\\D) (cons 13 (get-digit-values (rest num)))]\n    \
    \  [(equal? (first num) #\\E) (cons 14 (get-digit-values (rest num)))]\n     \
    \ [(equal? (first num) #\\F) (cons 15 (get-digit-values (rest num)))]))\n  (define\
    \ (primes-in-list num-list)\n    (define (is-prime? num)\n      (cond\n      \
    \  [(= num 2) true]\n        [(= num 3) true]\n        [(= num 5", "  (cond\n\
    \    ((eq? num \"\") 0)\n    ((char-numeric? (string-ref num 0))\n     (hex_key\
    \ (substring num 1)))\n    ((eq? (string-ref num 0) #\\A)\n     (+ 1 (hex_key\
    \ (substring num 1))))\n    ((eq? (string-ref num 0) #\\B)\n     (+ 1 (hex_key\
    \ (substring num 1))))\n    ((eq? (string-ref num 0) #\\C)\n     (hex_key (substring\
    \ num 1)))\n    ((eq? (string-ref num 0) #\\D)\n     (+ 1 (hex_key (substring\
    \ num 1))))\n    ((eq? (string-ref num 0) #\\E)\n     (hex_key (substring num\
    \ 1)))\n    ((eq? (string-ref num 0) #\\F)\n     (hex_key (substring num 1)))\n\
    \    (else (hex_key (substring num 1)))))\n", "  (count-prime-hex-digits num))\n",
  "  (let loop ([num (string->list num)]\n             [acc 0])\n    (cond [(empty?\
    \ num)\n           acc]\n          [(or (member (car num) '(#\\2 #\\3 #\\5 #\\\
    7 #\\B #\\D))\n               (member (car num) '(#\\2 #\\3 #\\5 #\\7 #\\b #\\\
    d)))\n           (loop (cdr num)\n                 (+ acc 1))]\n          [else\n\
    \           (loop (cdr num)\n                 acc)])))\n", "  (cond\n    [(empty?\
    \ num) 0]\n    [(char-upcase? (string-ref num 0))\n     (let* ([first-digit (string-ref\
    \ num 0)]\n            [remaining-digits (substring num 1)])\n       (cond\n \
    \        [(or (= first-digit #\\2) (= first-digit #\\3)\n              (= first-digit\
    \ #\\5) (= first-digit #\\7)\n              (= first-digit #\\B) (= first-digit\
    \ #\\D))\n          (+ 1 (hex_key remaining-digits))]\n         [else (hex_key\
    \ remaining-digits)]))]\n    [else (hex_key (substring num 1))]))\n", "  (cond\
    \ [(empty? num) 0]\n        [(equal? (list-ref num 0) #\\2) (+ 1 (hex_key (substring\
    \ num 1)))]\n        [(equal? (list-ref num 0) #\\3) (+ 1 (hex_key (substring\
    \ num 1)))]\n        [(equal? (list-ref num 0) #\\5) (+ 1 (hex_key (substring\
    \ num 1)))]\n        [(equal? (list-ref num 0) #\\7) (+ 1 (hex_key (substring\
    \ num 1)))]\n        [(equal? (list-ref num 0) #\\B) (+ 1 (hex_key (substring\
    \ num 1)))]\n        [(equal? (list-ref num 0) #\\D) (+ 1 (hex_key (substring\
    \ num 1)))]\n        [else (hex_key (substring num 1))]))", "  (define primes\
    \ '(2 3 5 7 11 13))\n  (define (is-in-primes x)\n    (cond ((null? primes) #f)\n\
    \          ((equal? x (car primes)) #t)\n          (else (is-in-primes (cdr primes)))))\n\
    \  (define (hex-key-iter n sum)\n    (cond ((null? n) sum)\n          ((is-in-primes\
    \ (string->number (string (car n)) 16))\n           (hex-key-iter (cdr n) (+ sum\
    \ 1)))\n          (else (hex-key-iter (cdr n) sum))))\n  (hex-key-iter (string->list\
    \ num) 0))", "  (define (is-prime n)\n    (cond\n      [(= n 2) #t]\n      [(=\
    \ n 3) #t]\n      [(= n 5) #t]\n      [(= n 7) #t]\n      [(= n 11) #t]\n    \
    \  [(= n 13) #t]\n      [(= n 17) #t]\n      [(= n 19) #t]\n      [(= n 23) #t]\n\
    \      [(= n 29) #t]\n      [(= n 31) #t]\n      [(= n 37) #t]\n      [(= n 41)\
    \ #t]\n      [(= n 43) #t]\n      [(= n 47) #t]\n      [(= n 53) #t]\n      [(=\
    \ n 59) #t]\n      [(= n 61) #t]\n      [(= n 67) #t]\n      [(= n 71) #t]\n \
    \     [(= n 73) #t]\n      [(= n 79) #t]\n      [(= n 83) #t]\n      [(= n 89)\
    \ #t]\n      [(= n 97) #t]\n      [(or (= n 1)\n           (and (&gt; n 3) (even?\
    \ n))\n           (and (&gt; n 5) (or (divides? 5 n) (divides? 7 n)))\n      \
    \     (and (&gt; n 7) (or (divides? 7 n) (divides? 11 n)))\n           (and (&gt;\
    \ n 11) (or (divides? 11 n) (divides? 13 n)))\n           (and (&gt; n 13) (or\
    \ (divides? 13 n) (divides? 17 n)))\n           (and (&gt; n 17) (or (divides?\
    \ 17 n) (divides? 19 n)))\n           (and (&gt; n 19) (or (divides? 19 n) (divides?\
    \ 23 n)))\n           (and (&gt; n 23) (or (divides? 23 n) (divides? 29 n)))\n\
    \           (and (&gt; n 29) (or (divides? 29 n) (divides? 31 n)))\n         \
    \  (and (&gt; n 31) (or (divides? 31", "  (define (is-prime n)\n    (cond\n  \
    \    [(= n 1) #f]\n      [(= n 2) #t]\n      [(= n 3) #t]\n      [(= n 5) #t]\n\
    \      [(= n 7) #t]\n      [(= n 11) #t]\n      [(= n 13) #t]\n      [else #f]))\n\
    \  (define (hex-digit-to-decimal ch)\n    (cond\n      [(string=? ch \"0\") 0]\n\
    \      [(string=? ch \"1\") 1]\n      [(string=? ch \"2\") 2]\n      [(string=?\
    \ ch \"3\") 3]\n      [(string=? ch \"4\") 4]\n      [(string=? ch \"5\") 5]\n\
    \      [(string=? ch \"6\") 6]\n      [(string=? ch \"7\") 7]\n      [(string=?\
    \ ch \"8\") 8]\n      [(string=? ch \"9\") 9]\n      [(string=? ch \"A\") 10]\n\
    \      [(string=? ch \"B\") 11]\n      [(string=? ch \"C\") 12]\n      [(string=?\
    \ ch \"D\") 13]\n      [(string=? ch \"E\") 14]\n      [(string=? ch \"F\") 15]))\n\
    \  (define (is-prime-hex-digit ch)\n    (is-prime (hex-digit-to-decimal ch)))\n\
    \  (define (iter lst count)\n    (cond\n      [(empty? lst) count]\n      [(is-prime-hex-digit\
    \ (first lst)) (iter (rest lst) (+ count 1))]\n      [else (iter (rest lst) count)]))\n\
    \  (iter (string->list num) 0))\n", "  (length (filter (lambda (x) \n        \
    \            (and (> x 1)\n                         (and (not (zero? (modulo x\
    \ 2)))\n                              (and (not (zero? (modulo x 3)))\n      \
    \                             (not (let loop ((x (- x 1)))\n                 \
    \                         (if (< x 5)\n                                      \
    \        #f\n                                              (if (or (zero? (modulo\
    \ x 5))\n                                                      (zero? (modulo\
    \ x 7)))\n                                                  #t\n             \
    \                                     (loop (- x 1))))))))))\n               \
    \   (map char->integer (string->list num)))))\n", "  (if (string=? num \"\") 0\n\
    \    (if (or (string=? (substring num 0 1) \"2\")\n            (string=? (substring\
    \ num 0 1) \"3\")\n            (string=? (substring num 0 1) \"5\")\n        \
    \    (string=? (substring num 0 1) \"7\")\n            (string=? (substring num\
    \ 0 1) \"B\")\n            (string=? (substring num 0 1) \"D\"))\n        (+ 1\
    \ (hex_key (substring num 1)))\n        (hex_key (substring num 1)))))", "   \
    \ (length (list-intersection (string->list num) (list #\\2 #\\3 #\\5 #\\7 #\\\
    B #\\D))))\n", "  (if (string-empty? num)\n      0\n      (if (string-member?\
    \ (string-ref num 0) \"2357BD\")\n          (+ 1 (hex_key (string-drop num 1)))\n\
    \          (hex_key (string-drop num 1)))))\n</code>\n", "  (length (remove (lambda\
    \ (n)\n                    (if (member n '(2 3 5 7 11 13))\n                 \
    \       #f\n                        #t))\n                  (map (lambda (a)\n\
    \                         (string->number a 16))\n                       (string-&gt;list\
    \ num)))))\n</code>\n", "  (cond\n    [(string=? num \"\") 0]\n    [(hex-digit?\
    \ (string-ref num 0))\n     (+ (is-prime (hexa-to-deci (string-ref num 0))) (hex_key\
    \ (substring num 1)))]\n    [else (hex_key (substring num 1))]))\n", "  (cond\
    \ [(empty? num) 0]\n        [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\\
    D))\n         (+ 1 (hex_key (rest num)))]\n        [else (hex_key (rest num))]))\n",
  "  (define (string->list s)\n    (list->list (string->list s)))\n  (define (list->list\
    \ l)\n    (if (empty? l)\n        (void)\n        (cons (car l) (list->list (cdr\
    \ l)))))\n  (define (hex-primes? num)\n    (cond [(= 2 num) #t]\n          [(=\
    \ 3 num) #t]\n          [(= 5 num) #t]\n          [(= 7 num) #t]\n          [(=\
    \ 11 num) #t]\n          [(= 13 num) #t]\n          [else #f]))\n  (define (count\
    \ l counter)\n    (cond [(empty? l) counter]\n          [(hex-primes? (char->integer\
    \ (car l)))\n           (count (cdr l) (+ counter 1))]\n          [else (count\
    \ (cdr l) counter)]))\n  (count (string->list num) 0))\n", "  (local [\n     \
    \     (define (to-decimal n)\n            (cond [(string=? n \"A\") 10]\n    \
    \              [(string=? n \"B\") 11]\n                  [(string=? n \"C\")\
    \ 12]\n                  [(string=? n \"D\") 13]\n                  [(string=?\
    \ n \"E\") 14]\n                  [(string=? n \"F\") 15]\n                  [else\
    \ (string->number n)]))\n          (define (is-prime? n)\n            (cond [(<\
    \ n 2) false]\n                  [(= n 2) true]\n                  [(zero? (modulo\
    \ n 2)) false]\n                  [else\n                   (define (helper i)\n\
    \                     (cond [(= i n) true]\n                           [(zero?\
    \ (modulo n i)) false]\n                           [else (helper (+ i 1))]))\n\
    \                   (helper 3)]))\n          (define (hex_key_helper i)\n    \
    \        (if (>= i (string-length num)) 0\n                (if (is-prime? (to-decimal\
    \ (string-ref num i))) (+ 1 (hex_key_helper (+ i 1)))\n                    (hex_key_helper\
    \ (+ i 1)))))])\n  (hex_key_helper 0))\n", "  (count (lambda (x) (find x '(2 3\
    \ 5 7 11 13)))\n         (chars->ints (chars-&gt;string num))))\n</code>\n", " \
    \ (string-length (regexp-replace* #rx\"[^2-7BD]\" num \"\")))\n", "  (let helper\
    \ ([num num] [cnt 0])\n    (if (not (string? num))\n        (error \"Non-string\
    \ input\")\n        (if (null? num)\n            cnt\n            (if (or (char=?\
    \ (string-ref num 0) #\\2)\n                    (char=? (string-ref num 0) #\\\
    3)\n                    (char=? (string-ref num 0) #\\5)\n                   \
    \ (char=? (string-ref num 0) #\\7)\n                    (char=? (string-ref num\
    \ 0) #\\B)\n                    (char=? (string-ref num 0) #\\D))\n          \
    \      (helper (substring num 1) (+ cnt 1))\n                (helper (substring\
    \ num 1) cnt))))))\n", "  (define (hex-value c)\n    (cond [(eq? c #\\A) 10]\n\
    \          [(eq? c #\\B) 11]\n          [(eq? c #\\C) 12]\n          [(eq? c #\\\
    D) 13]\n          [(eq? c #\\E) 14]\n          [(eq? c #\\F) 15]\n          [else\
    \ (string-&gt;number (string c))]))\n  (define (is-prime? n)\n    (define (helper\
    \ i)\n      (cond [(= i n) #t]\n            [(zero? (modulo n i)) #f]\n      \
    \      [else (helper (+ i 1))]))\n    (helper 2))\n  (define (prime-count str\
    \ i)\n    (cond [(empty? str) i]\n          [(is-prime? (hex-value (first str)))\
    \ (prime-count (rest str) (+ i 1))]\n          [else (prime-count (rest str) i)]))\n\
    \  (prime-count num 0))\n", "  (define (numerify c)\n    (cond\n      ((= c #\\\
    A) 10)\n      ((= c #\\B) 11)\n      ((= c #\\C) 12)\n      ((= c #\\D) 13)\n\
    \      ((= c #\\E) 14)\n      ((= c #\\F) 15)\n      ((= c #\\0) 0)\n      ((=\
    \ c #\\1) 1)\n      ((= c #\\2) 2)\n      ((= c #\\3) 3)\n      ((= c #\\4) 4)\n\
    \      ((= c #\\5) 5)\n      ((= c #\\6) 6)\n      ((= c #\\7) 7)\n      ((= c\
    \ #\\8) 8)\n      ((= c #\\9) 9)))\n  (define (hex-digit-prime? n)\n    (or (=\
    \ n 2) (= n 3) (= n 5) (= n 7) (= n 11) (= n 13)))\n  (define (reducer acc c)\n\
    \    (if (hex-digit-prime? (numerify c))\n        (+ acc 1)\n        acc))\n \
    \ (string-foldl reducer 0 num))\n", "  (define base 16)\n  (define (map-hex-to-dec)\n\
    \    (cond [(equal? (string-ref num k) #\\0)  0]\n          [(equal? (string-ref\
    \ num k) #\\1)  1]\n          [(equal? (string-ref num k) #\\2)  2]\n        \
    \  [(equal? (string-ref num k) #\\3)  3]\n          [(equal? (string-ref num k)\
    \ #\\4)  4]\n          [(equal? (string-ref num k) #\\5)  5]\n          [(equal?\
    \ (string-ref num k) #\\6)  6]\n          [(equal? (string-ref num k) #\\7)  7]\n\
    \          [(equal? (string-ref num k) #\\8)  8]\n          [(equal? (string-ref\
    \ num k) #\\9)  9]\n          [(equal? (string-ref num k) #\\A) 10]\n        \
    \  [(equal? (string-ref num k) #\\B) 11]\n          [(equal? (string-ref num k)\
    \ #\\C) 12]\n          [(equal? (string-ref num k) #\\D) 13]\n          [(equal?\
    \ (string-ref num k) #\\E) 14]\n          [(equal? (string-ref num k) #\\F) 15]\n\
    \          [else 0]))\n  (define (loop i)\n    (cond [(< i (string-length num))\n\
    \           (define k (- (string-length num) i 1))\n           (cond [(member\
    \ (map-hex-to-dec) '(2 3 5 7 11 13))\n                  (+ 1 (loop (+ i 1)))]\n\
    \                 [else (loop (+ i 1))])]\n          [else 0]))\n  (loop 1))",
  "  (define (hex-to-decimal num)\n    (cond ((equal? num \"A\") 10)\n          ((equal?\
    \ num \"B\") 11)\n          ((equal? num \"C\") 12)\n          ((equal? num \"\
    D\") 13)\n          ((equal? num \"E\") 14)\n          ((equal? num \"F\") 15)\n\
    \          (else (string->number num))))\n  (define (is-prime n)\n    (define\
    \ (iter x)\n      (cond ((= x n) #t)\n            ((= (modulo n x) 0) #f)\n  \
    \          (else (iter (+ x 1)))))\n    (cond ((= n 2) #t)\n          ((= n 3)\
    \ #t)\n          ((= n 5) #t)\n          ((= n 7) #t)\n          ((= n 11) #t)\n\
    \          ((= n 13) #t)\n          ((= n 17) #t)\n          ((= n 19) #t)\n \
    \         ((= n 23) #t)\n          ((= n 29) #t)\n          ((= n 31) #t)\n  \
    \        ((= n 37) #t)\n          ((= n 41) #t)\n          ((= n 43) #t)\n   \
    \       ((= n 47) #t)\n          ((= n 53) #t)\n          ((= n 59) #t)\n    \
    \      ((= n 61) #t)\n          ((= n 67) #t)\n          ((= n 71) #t)\n     \
    \     ((= n 73) #t)\n          ((= n 79) #t)\n          ((= n 83) #t)\n      \
    \    ((= n 89) #t)\n          ((= n 97) #t)\n          (else (iter 2))))\n  (define\
    \ (check-prime lst)\n    (cond ((null? lst) 0)\n          ((is-prime (hex-to-decimal\
    \ (car lst)))\n           (+ 1 (check-prime (cdr lst))))\n          (else (check-prime\
    \ (cdr lst)))))\n  (check-prime (string-&gt;list num)))\n</code>\nWhat would be\
    \ the best approach to refactor the code?\nAnd how", '  (length (list-comp (char
    (in-list "2357BD")) (in-string num))))', "  ;; implementation here\n  )", "  (let\
    \ ([num (string->list num)])\n    (length\n     (filter (lambda (x) (in-set? x\
    \ (list #\\2 #\\3 #\\5 #\\7 #\\B #\\D))) num))))\n", "  (count (filter (lambda\
    \ (x)\n\t\t   (or (= x #\\2) (= x #\\3) (= x #\\5) (= x #\\7)\n\t\t       (= x\
    \ #\\B) (= x #\\D)))\n\t\t (string->list num))))\n", "  (hex-key-helper num))\n",
  "  (cond\n    [(empty? num) 0]\n    [(string-member? (string-upcase num) (string-upcase\
    \ \"0-1-2-3-4-5-6-7-8-9-A-B-C-D-E-F\")) (add1 (hex_key (substring num 1)))]\n\
    \    [else (hex_key (substring num 1))]))\n", "  (define (is-prime num)\n    (define\
    \ (is-divisable n)\n      (for/or ([i (in-range 2 (ceiling (/ n 2)))])\n     \
    \   (= (modulo n i) 0)))\n    (not (is-divisable num)))\n  (define (hex-to-decimal\
    \ ch)\n    (if (char-numeric? ch)\n      (string->number (string ch))\n      (+\
    \ 10 (char-&gt;integer ch))))\n  (apply + (map hex-to-decimal (string-&gt;list\
    \ num))))\n</code>\nI haven't used Racket before, but I have solved the problem\
    \ in Python, so I tried converting it to Racket. What can I do to make this code\
    \ more Racket-like?\n\n\nA:\n\nHere are a few random observations:\n\nThe <code>is-prime</code>\
    \ function is very inefficient; it's an O(n^2) algorithm. On my machine it takes\
    \ 6.8 seconds to evaluate <code>(hex-key \"123456789ABCDEF0\")</code>. If you\
    \ use an algorithm that's O(sqrt(n)) instead, it'll run in 0.4 seconds. I recommend\
    \ reading about faster primality tests.\n<code>hex-to-decimal</code> could be\
    \ implemented much more simply.\nThere's no need to write <code>(apply + \u2026\
    )</code> when <code>(for/sum \u2026)</code> would do.\nThe <code>char-numeric?</code>\
    \ function is not very useful in this context, because it'll reject 0-9 and accept\
    \ other stuff.\nI'd write <code>(string-&gt;list num)</code> as <code>(string-&gt;list/vector\
    \ num)</code> or <code>(string-&gt;list/vector/indexed num)</code>.\nIn Racket,\
    \ we prefer <code>when</code> over <code>if</code> when the predicate is known\
    \ to be a function.\n\nI think you can easily write a better implementation yourself\
    \ now, but here's one way:\n<code>(define (is-prime n)\n  (not (or (= 0 (modulo\
    \ n 2))\n           (for/or ([i (in-range 3 (sqrt", "  (if (string=? num \"\"\
    )\n      0\n      (if (member (string-ref num 0) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\\
    D))\n          (+ 1 (hex_key (substring num 1)))\n          (hex_key (substring\
    \ num 1)))))\n", "  (let ([h (map integer->char (range 0 16))])\n    (for/sum\
    \ ([d (in-string num)]\n              #:when (member (character-upcase d) h))\n\
    \      (member (character-upcase d) (list #\\2 #\\3 #\\5 #\\7 #\\B #\\D)))))\n",
  "  (cond\n    [(empty? num) 0]\n    [(and (member (first num) '(#\\2 #\\3 #\\5 #\\\
    7 #\\B #\\D)) (hex_key (rest num)))\n     (+ 1 (hex_key (rest num)))]\n    [else\
    \ (hex_key (rest num))]))", "  (local [(define (to-dec num)\n            (if (empty?\
    \ num)\n                0\n                (+ (* (to-dec (rest num)) 16)\n   \
    \                (if (char=? (first num) #\\A)\n                       10\n  \
    \                     (if (char=? (first num) #\\B)\n                        \
    \   11\n                           (if (char=? (first num) #\\C)\n           \
    \                    12\n                               (if (char=? (first num)\
    \ #\\D)\n                                   13\n                             \
    \      (if (char=? (first num) #\\E)\n                                       14\n\
    \                                       (if (char=? (first num) #\\F)\n      \
    \                                     15\n                                   \
    \        (string->number (string (first num)))))))))))\n           (define (is-prime?\
    \ num)\n             (if (empty? (filter (\u03BB (i) (zero? (modulo num i)))\n\
    \                                 (iota num 2)))\n                 #t\n      \
    \           #f))]\n    (if (empty? num)\n        0\n        (+ (if (is-prime?\
    \ (to-dec (string-&gt;list num)))\n               1\n               0)\n     \
    \      (hex_key (rest num))))))\n</code>\nThis works, but takes approximately\
    \ 3.5 seconds to complete. I'm running it in DrRacket. My question is, what am\
    \ I doing that is causing such poor performance?\nThe main function is <code>hex_key</code>.\
    \ It takes the first character and converts it to decimal, then passes it to <code>is-prime?</code>.\
    \ It then recursively calls itself on the tail of the original string. If the\
    \ list is empty, it returns 0. Otherwise, it will return 0 + the recursive call.\n\
    Here's a sample of a string that takes 3.5 seconds to calculate:\n<code>&gt;(hex_key\
    \ \"1331A4D4DFC4E7B71A8C8BA2557D6F1A6D3C6FCB0AC0B2A3C3D3E3F3C3D3E3F3C3D3E3F3C3D3E3F3C3D3E3F3C3D",
  "  (define (is_prime? n)\n    (cond\n      [(= n 2) #t]\n      [(<= n 1) #f]\n \
    \     [(or\n          (= (remainder n 2) 0)\n          (= (remainder n 3) 0)\n\
    \          (= (remainder n 5) 0)\n          (= (remainder n 7) 0)\n          (=\
    \ (remainder n 11) 0)\n          (= (remainder n 13) 0)) #f]\n      [else (for/or\
    \ ([d (in-range 2 (ceiling (sqrt n)))])\n                    (zero? (remainder\
    \ n d)))]))\n  (define (hex-is-prime? c)\n    (case c\n      [(#\\2) (is_prime?\
    \ 2)]\n      [(#\\3) (is_prime? 3)]\n      [(#\\5) (is_prime? 5)]\n      [(#\\\
    7) (is_prime? 7)]\n      [(#\\b) (is_prime? 11)]\n      [(#\\d) (is_prime? 13)]\n\
    \      [else #f]))\n  (if (string=? num \"\")\n      0\n      (length (filter\
    \ hex-is-prime? (string->list num)))))", "  (define (is-prime? n)\n    (if (=\
    \ n 1)\n        #f\n        (if (= n 2)\n            #t\n            (define (no-divisor?\
    \ n)\n              (define (divisor? x)\n                (= (remainder n x) 0))\n\
    \              (if (= n (+ 1 (quotient n 2)))\n                  #t\n        \
    \          (if (divisor? (+ 1 (quotient n 2)))\n                      #f\n   \
    \                   (no-divisor? (+ 1 (quotient n 2))))))\n            (no-divisor?\
    \ n))))\n  (define (count-primes num)\n    (cond ((empty? num) 0)\n          ((symbol=?\
    \ (string->symbol (first num)) #\\2)\n           (+ 1 (count-primes (rest num))))\n\
    \          ((symbol=? (string->symbol (first num)) #\\3)\n           (+ 1 (count-primes\
    \ (rest num))))\n          ((symbol=? (string->symbol (first num)) #\\5)\n   \
    \        (+ 1 (count-primes (rest num))))\n          ((symbol=? (string->symbol\
    \ (first num)) #\\7)\n           (+ 1 (count-primes (rest num))))\n          ((symbol=?\
    \ (string->symbol (first num)) #\\B)\n           (+ 1 (count-primes (rest num))))\n\
    \          ((symbol=? (string->symbol (first num)) #\\D)\n           (+ 1 (count-primes\
    \ (rest num))))\n          (else (count-primes (rest num)))))\n  (count-primes\
    \ num))\n", "  (define (is_prime n)\n    (define (is_divisor num)\n      (define\
    \ (rec num)\n        (cond ((= num 1) #f)\n              ((= (modulo n num) 0)\
    \ #t)\n              (else (rec (- num 1)))))\n      (rec (/ n 2)))\n    (cond\
    \ ((= n 2) #t)\n          ((= n 3) #t)\n          ((= n 5) #t)\n          ((=\
    \ n 7) #t)\n          ((= n 11) #t)\n          ((= n 13) #t)\n          ((is_divisor\
    \ n) #f)\n          (else #t)))\n  (define (rec n count)\n    (cond ((= n 0) count)\n\
    \          ((is_prime (char->integer (string-ref num (- n 1))))\n            (rec\
    \ (- n 1) (+ count 1)))\n          (else (rec (- n 1) count))))\n  (rec (string-length\
    \ num) 0))\n```\n\nLet's try the examples.\n\n```racket", "  (define primes '(2\
    \ 3 5 7 11 13))\n  (define (hex-digit? d)\n    (or (integer? d)\n        (and\
    \ (char? d)\n             (char-numeric? d)\n             (<= #\\0 d #\\F))))\n\
    \  (define (hex-digit->num d)\n    (if (integer? d)\n        d\n        (case\
    \ (char-upcase d)\n          ((#\\A) 10)\n          ((#\\B) 11)\n          ((#\\\
    C) 12)\n          ((#\\D) 13)\n          ((#\\E) 14)\n          ((#\\F) 15))))\n\
    \  (define (hex-num->ints num)\n    (if (null? num)\n        '()\n        (cons\
    \ (hex-digit->num (string-ref num 0))\n              (hex-num->ints (substring\
    \ num 1)))))\n  (define (ints->hex-num ints)\n    (if (null? ints)\n        \"\
    \"\n        (string-append\n         (number->string (car ints))\n         (ints->hex-num\
    \ (cdr ints)))))\n  (define (num-digit? d)\n    (and (integer? d) (<= 0 d 9)))\n\
    \  (define (in-primes? n)\n    (cond ((null? primes) #f)\n          ((= n (car\
    \ primes)) #t)\n          ((< n (car primes)) #f)\n          (else (in-primes?\
    \ n (cdr primes)))))\n  (define (len-of-primes-in-hex-num hex-num)\n    (define\
    \ (loop num)\n      (if (null? num)\n          0\n          (if (in-primes? (car\
    \ num))\n              (+ 1 (loop (cdr num)))\n              (loop (cdr num)))))\n\
    \    (loop (hex-num->ints hex-num)))\n  (len-of-primes-in-hex-num num))\n", " \
    \ (cond\n    [(equal? num \"\") 0]\n    [(= (string->number num) 0) 0]\n    [else\
    \ (+ (number->string (string->number num) 16) (hex_key (number->string (/ (string->number\
    \ num) 16) 16)))]))", "    (local [(define (hex-number->number num)\n        \
    \        (cond [(string=? num \"A\") 11]\n                      [(string=? num\
    \ \"B\") 12]\n                      [(string=? num \"C\") 13]\n              \
    \        [(string=? num \"D\") 14]\n                      [(string=? num \"E\"\
    ) 15]\n                      [(string=? num \"F\") 16]\n                     \
    \ [else (string->number num)]))\n            (define (is-prime num)\n        \
    \        (cond [(< num 2) #f]\n                      [(= num 2) #t]\n        \
    \              [(even? num) #f]\n                      [else (for/and ([factor\
    \ (in-range 3 num 2)])\n                              (not (= (modulo num factor)\
    \ 0)))]))]\n        (apply + (for/list ([num (in-list (string->list num))])\n\
    \                (if (is-prime (hex-number->number (number->string (char->integer\
    \ num))))\n                    1\n                    0)))))\n", "  (define primes\
    \ '(2 3 5 7 11 13))\n  (define hex-vals '(\"0\" \"1\" \"2\" \"3\" \"4\" \"5\"\
    \ \"6\" \"7\" \"8\" \"9\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\"))\n  (define (prime-digit?\
    \ n)\n    (cond ((< n 4) #t)\n          ((null? primes) #f)\n          ((member\
    \ (string->number (string-append \"0x\" n)) primes) #t)\n          (else (prime-digit?\
    \ (substring n 1)))))\n  (if (string-empty? num) 0\n      (if (prime-digit? (substring\
    \ num 0 1))\n          (+ 1 (hex_key (substring num 1)))\n          (hex_key (substring\
    \ num 1)))))", "    (hex_key-helper (string->number num 16)))\n", "  (cond\n \
    \   [(empty? num) 0]\n    [(prime? (str->number (substring num 0 1) 16))\n   \
    \  (+ 1 (hex_key (substring num 1 (string-length num))))]\n    [else (hex_key\
    \ (substring num 1 (string-length num)))]))\n", "  (define (is-prime? num)\n \
    \   (let ((divisors (range num)))\n      (andmap \n       (lambda (divisor)\n\
    \         (not (= (modulo num divisor) 0))\n       )\n       divisors\n      )\n\
    \    )\n  )\n  (define (digits? num)\n    (define (is-digit? ch)\n      (or (char-numeric?\
    \ ch)\n          (char=? ch #\\a)\n          (char=? ch #\\b)\n          (char=?\
    \ ch #\\c)\n          (char=? ch #\\d)\n          (char=? ch #\\e)\n         \
    \ (char=? ch #\\f)\n      )\n    )\n    (if (empty? num)\n        #f\n       \
    \ (and (is-digit? (string-ref num 0))\n             (digits? (substring num 1)))\n\
    \    )\n  )\n  (define (hex->decimal num)\n    (let ((num (string->list num)))\n\
    \      (map (lambda (ch)\n             (if (char-numeric? ch)\n              \
    \   (string->number (string ch))\n                 (if (char=? ch #\\a) #\\10\n\
    \                     (if (char=? ch #\\b) #\\11\n                         (if\
    \ (char=? ch #\\c) #\\12\n                             (if (char=? ch #\\d) #\\\
    13\n                                 (if (char=? ch #\\e) #\\14\n            \
    \                         (if (char=? ch #\\f) #\\15\n                       \
    \                  #\\x\n                                     )\n            \
    \                     )\n                             )\n                    \
    \     )\n                     )\n                 )\n             )\n        \
    \   )\n           num\n      )\n    )\n  )\n  (define (primes? num)\n    (if (empty?\
    \ num)\n        '()\n        (let ((cur (car num)))\n          (if (is-prime?\
    \ cur)\n              (cons cur (primes? (cdr num)))\n              (primes? (cdr\
    \ num))\n          )\n        )\n    )\n  )\n  (if (digits? num)\n", "  (for/sum\
    \ ([c (in-string num)]\n            #:when (or (string=? c \"2\") (string=? c\
    \ \"3\")\n                      (string=? c \"5\") (string=? c \"7\")\n      \
    \                (string=? c \"B\") (string=? c \"D\")))\n    1))\n", "  (length\
    \ (filter (lambda (x) (number? x))\n                  (map char->integer\n   \
    \                    (filter (lambda (x) (or (eq? #\\A x) (eq? #\\B x) (eq? #\\\
    C x) (eq? #\\D x) (eq? #\\E x) (eq? #\\F x)))\n                              \
    \ (string->list num))))))\n", "  (cond\n    [(empty? num) 0]\n    [(or (= (string-&gt;number\
    \ (substring num 0 1) 16) 2)\n      (= (string-&gt;number (substring num 0 1)\
    \ 16) 3)\n      (= (string-&gt;number (substring num 0 1) 16) 5)\n      (= (string-&gt;number\
    \ (substring num 0 1) 16) 7)\n      (= (string-&gt;number (substring num 0 1)\
    \ 16) 11)\n      (= (string-&gt;number (substring num 0 1) 16) 13))\n     (+ 1\
    \ (hex_key (substring num 1)))]\n    [else (hex_key (substring num 1))]))\n</code>\n\
    My code is not working because on the 3rd line of my code I get an error and I\
    \ am not sure why. \n<code>; compile: expected a variable, but found '(' in: (\n\
    </code>\nI am not sure what this error means. I am a beginner to racket and I\
    \ don't understand why I am getting this error. \n\n\nA:\n\nYour code has a bug.\
    \ You're using the predefined <code>substring</code> procedure, which takes three\
    \ arguments. The first two arguments are numbers, and the third is a string. In\
    \ your code you're passing two strings as arguments, which is not possible and\
    \ that's why you're getting the error. This can be fixed by using two calls to\
    \ <code>substring</code>:\n<code>(define (hex_key num)\n  (cond\n    [(empty?\
    \ num) 0]\n    [(or (= (string-&gt;number (substring num 0 1) 16) 2)\n      (=\
    \ (string-&gt;number (substring num 0 1) 16) 3)\n      (= (string-&gt;number (substring\
    \ num 0 1) 16) 5)\n      (= (string-&gt;number (substring num 0 1) 16) 7)\n  \
    \    (= (string-&gt;number (substring num 0 1) 16) 11)\n      (= (string-&gt;number\
    \ (substring num 0 1) 16) 13))\n     (+ 1 (hex_key (substring num 1)))]\n   ",
  "  (define (is_prime? n)\n    (if (= n 1)\n        #f\n        (if (= n 2)\n   \
    \         #t\n            (if (zero? (remainder n 2))\n                #f\n  \
    \              (let loop ((i 3))\n                  (if (= i n)\n            \
    \          #t\n                      (if (zero? (remainder n i))\n           \
    \               #f\n                          (loop (+ i 2)))))))))\n  (define\
    \ (is_prime_in_hex? n)\n    (cond ((string=? n \"2\") #t)\n          ((string=?\
    \ n \"3\") #t)\n          ((string=? n \"5\") #t)\n          ((string=? n \"7\"\
    ) #t)\n          ((string=? n \"B\") #t)\n          ((string=? n \"D\") #t)\n\
    \          (else #f)))\n  (define (iter count)\n    (if (zero? (string-length\
    \ num))\n        count\n        (let ((first-digit (substring num 0 1)))\n   \
    \       (if (is_prime_in_hex? first-digit)\n              (iter (+ count 1))\n\
    \              (iter count)))))\n  (iter 0))\n</code>\n", "  (cond\n    [(empty?\
    \ num) 0]\n    [(not (string-contains num #\\A #\\B #\\C #\\D #\\E #\\F)) (hex_key\
    \ (substring num 1))]\n    [(prime? (string->number (substring num 0 1) 16)) (+\
    \ 1 (hex_key (substring num 1)))]\n    [else (hex_key (substring num 1))]))\n",
  "  (cond\n    [(null? num) 0]\n    [(member (string-&gt;number (substring num 0\
    \ 1) 16) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n    [else\
    \ (hex_key (substring num 1))]))\n</code>\nI'm not sure what's wrong but my output\
    \ is always 0.\nI'm using https://ideone.com/ to test it.\n\n\nA:\n\nI think the\
    \ problem is that you're calling <code>hex_key</code> on the substring of the\
    \ first character. That's going to give you something like <code>'(#\\1 #\\0 #\\\
    7 #\\7 #\\E)</code> and that's going to give you an empty string when you try\
    \ to convert it to a number, which will be 0. You should just be calling <code>hex_key</code>\
    \ on the rest of the string.\nYou also want to subtract 1 off the length of the\
    \ string because you're calling <code>substring</code> again in your recursive\
    \ call. You don't want to call it on <code>num</code> otherwise you'll get an\
    \ infinite loop (you're always checking the first character).\n<code>(define (hex_key\
    \ num)\n  (cond\n    [(null? num) 0]\n    [(member (string-&gt;number (substring\
    \ num 0 1) 16) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1 (- (string-length\
    \ num) 1))))]\n    [else (hex_key (substring num 1 (- (string-length num) 1)))]))\n\
    </code>\n", "  (define (hex_to_dec num)\n    (let loop ((i (string-length num))\
    \ (acc 0))\n      (cond\n        [(= i 0) acc]\n        [(char=? (string-ref num\
    \ (- i 1)) #\\A) (loop (- i 1) (+ acc 10))]\n        [(char=? (string-ref num\
    \ (- i 1)) #\\B) (loop (- i 1) (+ acc 11))]\n        [(char=? (string-ref num\
    \ (- i 1)) #\\C) (loop (- i 1) (+ acc 12))]\n        [(char=? (string-ref num\
    \ (- i 1)) #\\D) (loop (- i 1) (+ acc 13))]\n        [(char=? (string-ref num\
    \ (- i 1)) #\\E) (loop (- i 1) (+ acc 14))]\n        [(char=? (string-ref num\
    \ (- i 1)) #\\F) (loop (- i 1) (+ acc 15))]\n        [else (loop (- i 1) (+ acc\
    \ (string->number (string (string-ref num (- i 1))))))])))\n  (define (is_prime\
    \ num)\n    (let loop ((i (quotient num 2)))\n      (cond\n        [(= i 1) #t]\n\
    \        [(zero? (remainder num i)) #f]\n        [else (loop (- i 1))])))\n  (let\
    \ loop ((i (string-length num)) (acc 0))\n    (cond\n      [(= i 0) acc]\n   \
    \   [(is_prime (hex_to_dec (string (string-ref num (- i 1))))) (loop (- i 1) (+\
    \ acc 1))]\n      [else (loop (- i 1) acc)])))\n", "  (cond\n    [(empty? num)\
    \ 0]\n    [(or (char=? (first num) #\\0)\n         (char=? (first num) #\\1)\n\
    \         (char=? (first num) #\\4)\n         (char=? (first num) #\\6)\n    \
    \     (char=? (first num) #\\8)\n         (char=? (first num) #\\9)\n        \
    \ (char=? (first num) #\\A)\n         (char=? (first num) #\\C)\n         (char=?\
    \ (first num) #\\E)\n         (char=? (first num) #\\F))\n     (hex_key (rest\
    \ num))]\n    [else (+ 1 (hex_key (rest num)))]))", "  (length\n   (filter (lambda\
    \ (n) (member n '(2 3 5 7 11 13)))\n           (map string->number (string-split\
    \ (string-append \"#\" num) #\\#)))))\n", "  (length (filter (lambda (x) (memq\
    \ x '(2 3 5 7 11 13))) (map string->number (string-&gt;list (string-upcase num))\
    \ 16))))\n</code>\n", "  (cond [(string=? num \"\") 0]\n        [else\n      \
    \   (cond [else\n                (cond [else\n                       (cond [else\n\
    \                              (cond [else\n                                 \
    \    (cond [else\n                                            (cond [else\n  \
    \                                                 (cond [else\n              \
    \                                            (cond [else\n                   \
    \                                              (cond [else\n                 \
    \                                                       (+ (hex_key (string-drop\
    \ num 1)) (cond [(member (string-ref num 0) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\
    \ 1] [else 0]))]\n                                                           \
    \             (cond [(member (string-ref num 0) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\\
    D)) 1] [else 0]))]\n                                                         \
    \          (cond [(member (string-ref num 0) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\
    \ 1] [else 0]))]\n                                                          (cond\
    \ [(member (string-ref num 0) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D)) 1] [else 0]))]\n\
    \                                                     (cond [(member (string-ref\
    \ num 0) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D)) 1] [else 0]))]\n                  \
    \                          (cond [(member (string-ref num 0) '(#\\2 #\\3 #\\5\
    \ #\\7 #\\B #\\D)) 1] [else 0]))]\n                                       (cond\
    \ [(member (string-ref num 0) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D)) 1] [else 0]))]\n\
    \                              (cond [(member (string-ref num 0) '(#\\2 #\\3 #\\\
    5 #\\7 #\\B #\\D)) 1] [else 0]))]\n                       (cond [(member (string-ref\
    \ num 0) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D)) 1] [else 0]))]\n                (cond\
    \ [(member (string-ref num 0) '(#\\2 #\\3 #\\5 #\\7 #\\B #", "  (cond\n    [(empty?\
    \ num) 0]\n    [(string=? (substring num 0 1) \"2\")\n     (+ 1 (hex_key (substring\
    \ num 1)))]\n    [(string=? (substring num 0 1) \"3\")\n     (+ 1 (hex_key (substring\
    \ num 1)))]\n    [(string=? (substring num 0 1) \"5\")\n     (+ 1 (hex_key (substring\
    \ num 1)))]\n    [(string=? (substring num 0 1) \"7\")\n     (+ 1 (hex_key (substring\
    \ num 1)))]\n    [(string=? (substring num 0 1) \"B\")\n     (+ 1 (hex_key (substring\
    \ num 1)))]\n    [(string=? (substring num 0 1) \"D\")\n     (+ 1 (hex_key (substring\
    \ num 1)))]\n    [else (hex_key (substring num 1))]))\n", "  (define (is_prime?\
    \ n)\n    (cond ((< n 2) #f)\n          ((= n 2) #t)\n          ((= (remainder\
    \ n 2) 0) #f)\n          (else (let loop ((i 3))\n                  (cond ((<\
    \ i n) (if (= (remainder n i) 0) #f (loop (+ i 2))))\n                       \
    \ ((= i n) #t))))))\n  (define (map-hex-key val)\n    (cond ((char=? val #\\0)\
    \ #\\0)\n          ((char=? val #\\1) #\\1)\n          ((char=? val #\\2) #\\\
    2)\n          ((char=? val #\\3) #\\3)\n          ((char=? val #\\4) #\\4)\n \
    \         ((char=? val #\\5) #\\5)\n          ((char=? val #\\6) #\\6)\n     \
    \     ((char=? val #\\7) #\\7)\n          ((char=? val #\\8) #\\8)\n         \
    \ ((char=? val #\\9) #\\9)\n          ((char=? val #\\A) #\\A)\n          ((char=?\
    \ val #\\B) #\\B)\n          ((char=? val #\\C) #\\C)\n          ((char=? val\
    \ #\\D) #\\D)\n          ((char=? val #\\E) #\\E)\n          ((char=? val #\\\
    F) #\\F)))\n  (define (char->integer x)\n    (cond ((char=? x #\\0) 0)\n     \
    \     ((char=? x #\\1) 1)\n          ((char=? x #\\2) 2)\n          ((char=? x\
    \ #\\3) 3)\n          ((char=? x #\\4) 4)\n          ((char=? x #\\5) 5)\n   \
    \       ((char=? x #\\6) 6)\n          ((char=? x #\\7) 7)\n          ((char=?\
    \ x #\\8) 8)\n          ((char=? x #\\9) 9)\n          ((char=? x #\\A) 10)\n\
    \          ((", "  (define (char-&gt;int c)\n    (string-&gt;number (string c)\
    \ 16))\n  (define (is-prime n)\n    (define (iter divisor)\n      (cond ((&gt;\
    \ divisor (sqrt n)) true)\n            ((zero? (modulo n divisor)) false)\n  \
    \          (else (iter (+ divisor 1)))))\n    (iter 2))\n  (define (loop num count)\n\
    \    (cond ((null? num) count)\n          ((is-prime (char-&gt;int (car num)))\
    \ (loop (cdr num) (+ count 1)))\n          (else (loop (cdr num) count))))\n \
    \ (loop num 0))\n</code>\n", "  (define (is-prime n)\n    (define (prime? n (divisor\
    \ 2))\n      (if (= (* divisor divisor) n) #f\n          (if (> (* divisor divisor)\
    \ n) #t\n              (prime? n (+ divisor 1)))))\n    (if (= n 2) #t\n     \
    \   (if (= n 1) #f\n            (prime? n 2))))\n  (define (is-prime-symbol n)\n\
    \    (cond ((string=? n \"0\") #f)\n          ((string=? n \"1\") #f)\n      \
    \    ((string=? n \"2\") #t)\n          ((string=? n \"3\") #t)\n          ((string=?\
    \ n \"4\") #f)\n          ((string=? n \"5\") #t)\n          ((string=? n \"6\"\
    ) #f)\n          ((string=? n \"7\") #t)\n          ((string=? n \"8\") #f)\n\
    \          ((string=? n \"9\") #f)\n          ((string=? n \"A\") #f)\n      \
    \    ((string=? n \"B\") #t)\n          ((string=? n \"C\") #f)\n          ((string=?\
    \ n \"D\") #t)\n          ((string=? n \"E\") #f)\n          ((string=? n \"F\"\
    ) #f)))\n  (define (count-primes digits)\n    (if (empty? digits) 0\n        (if\
    \ (is-prime-symbol (first digits))\n            (+ 1 (count-primes (rest digits)))\n\
    \            (count-primes (rest digits)))))\n  (count-primes (string->list num)))\n",
  "  (if (zero? (length num))\n      0\n      (add1 (hex_key (substring num 1 (length\
    \ num))))))", "  (define primes '(2 3 5 7 11 13))\n  (define (is_prime n)\n  \
    \  (define (prime? lst)\n      (cond\n        [(empty? lst) true]\n        [(=\
    \ (remainder n (first lst)) 0) false]\n        [else (prime? (rest lst))]))\n\
    \    (prime? primes))\n  (define (hex_char->int c)\n    (string->number (string\
    \ c) 16))\n  (define (count_primes lst)\n    (cond\n      [(empty? lst) 0]\n \
    \     [(is_prime (hex_char->int (first lst))) (+ 1 (count_primes (rest lst)))]\n\
    \      [else (count_primes (rest lst))]))\n  (count_primes (string->list num)))\n\
    ```\n\n```racket\n#lang racket\n", "  (define hex-primes '(2 3 5 7 11 13))\n \
    \ (define (count-in-list item ls)\n    (if (null? ls)\n        0\n        (+ (if\
    \ (equal? item (car ls)) 1 0)\n           (count-in-list item (cdr ls)))))\n \
    \ (define (count-in-str item str)\n    (count-in-list item (string->list str)))\n\
    \  (count-in-str num hex-primes))\n", "  (let ((count 0))\n    (for/fold ([count\
    \ 0])\n              ([i (in-string num)])\n      (cond\n        [(member (string->number\
    \ (string i) 16) '(2 3 5 7 11 13))\n         (add1 count)]\n        [else count]))))\n",
  "  (define (is_prime n)\n    (define (divides? n k)\n      (= (remainder n k) 0))\n\
    \    (define (find-divisor n test-divisor)\n      (cond ((> (square test-divisor)\
    \ n) n)\n            ((divides? n test-divisor) test-divisor)\n            (else\
    \ (find-divisor n (+ test-divisor 1)))))\n    (= n (find-divisor n 2)))\n  (define\
    \ (is_prime_number? x)\n    (and (is_prime x) (member x '(2 3 5 7 11 13))))\n\
    \  (define (convert hex num)\n    (cond ((string=? hex \"0\") 0)\n          ((string=?\
    \ hex \"1\") 1)\n          ((string=? hex \"2\") 2)\n          ((string=? hex\
    \ \"3\") 3)\n          ((string=? hex \"4\") 4)\n          ((string=? hex \"5\"\
    ) 5)\n          ((string=? hex \"6\") 6)\n          ((string=? hex \"7\") 7)\n\
    \          ((string=? hex \"8\") 8)\n          ((string=? hex \"9\") 9)\n    \
    \      ((string=? hex \"A\") 10)\n          ((string=? hex \"B\") 11)\n      \
    \    ((string=? hex \"C\") 12)\n          ((string=? hex \"D\") 13)\n        \
    \  ((string=? hex \"E\") 14)\n          ((string=? hex \"F\") 15)))\n  (let loop\
    \ ((index (string-length num))\n             (n 0)\n             (result 0))\n\
    \    (if (= index 0)\n        result\n        (let ((digit (string-ref num (-\
    \ index 1))))\n          (if (is_prime_number? (convert (string digit) index))\n\
    \              (loop (- index 1) (add1 n) (add1 result))\n              (loop\
    \ (- index 1) (add1 n) result))))))", "  (let ((primes (list 2 3 5 7 11 13)))\n\
    \    (if (string=? num \"\")\n        0\n        (if (member (string->number (string\
    \ num) 16) primes)\n            (+ 1 (hex_key (substring num 1)))\n          \
    \  (hex_key (substring num 1))))))", "  (cond ((empty? num) 0)\n        ((not\
    \ (char-numeric? (string-ref num 0)))\n         (add1 (hex_key (substring num\
    \ 1))))\n        ((= (string->number (substring num 0 1)) 2)\n         (add1 (hex_key\
    \ (substring num 1))))\n        ((= (string->number (substring num 0 1)) 3)\n\
    \         (add1 (hex_key (substring num 1))))\n        ((= (string->number (substring\
    \ num 0 1)) 5)\n         (add1 (hex_key (substring num 1))))\n        ((= (string->number\
    \ (substring num 0 1)) 7)\n         (add1 (hex_key (substring num 1))))\n    \
    \    ((= (string->number (substring num 0 1)) 11)\n         (add1 (hex_key (substring\
    \ num 1))))\n        ((= (string->number (substring num 0 1)) 13)\n         (add1\
    \ (hex_key (substring num 1))))\n        (else (hex_key (substring num 1)))))\n",
  "  (define (char->val c)\n    (cond ((char=? c #\\0) 0)\n          ((char=? c #\\\
    1) 1)\n          ((char=? c #\\2) 2)\n          ((char=? c #\\3) 3)\n        \
    \  ((char=? c #\\4) 4)\n          ((char=? c #\\5) 5)\n          ((char=? c #\\\
    6) 6)\n          ((char=? c #\\7) 7)\n          ((char=? c #\\8) 8)\n        \
    \  ((char=? c #\\9) 9)\n          ((char=? c #\\A) 10)\n          ((char=? c #\\\
    B) 11)\n          ((char=? c #\\C) 12)\n          ((char=? c #\\D) 13)\n     \
    \     ((char=? c #\\E) 14)\n          ((char=? c #\\F) 15)))\n  (define (val->char\
    \ v)\n    (cond ((= v 0) #\\0)\n          ((= v 1) #\\1)\n          ((= v 2) #\\\
    2)\n          ((= v 3) #\\3)\n          ((= v 4) #\\4)\n          ((= v 5) #\\\
    5)\n          ((= v 6) #\\6)\n          ((= v 7) #\\7)\n          ((= v 8) #\\\
    8)\n          ((= v 9) #\\9)\n          ((= v 10) #\\A)\n          ((= v 11) #\\\
    B)\n          ((= v 12) #\\C)\n          ((= v 13) #\\D)\n          ((= v 14)\
    \ #\\E)\n          ((= v 15) #\\F)))\n  (define (is_prime? n)\n    (cond ((< n\
    \ 2) #f)\n          ((= n 2) #t)\n          ((= (remainder n 2) 0) #f)\n     \
    \     (else (let loop ((i 3))\n                  (cond ((> (* i i) n) #t)\n  \
    \                      ((= (remainder n i) 0) #f)\n                        (else\
    \ (loop (+ i 2))))))))\n ", "  (let loop ((num num) (accum 0))\n    (if (null?\
    \ num)\n        accum\n        (if (memq (string-&gt;number (string (car num)\
    \ 16)) '(2 3 5 7 11 13))\n            (loop (cdr num) (+ accum 1))\n         \
    \   (loop (cdr num) accum)))))\n</code>\nNow, how can I write an idomatic version\
    \ of this?\nI looked at some solutions on Rosetta Code and they all used recursive\
    \ versions of the <code>filter</code> function (I'd prefer to learn about this\
    \ approach)\nor\nThey used a for loop and tested each element one by one using\
    \ <code>string-&gt;number</code> to convert the character to a number and then\
    \ tested that number against a list of numbers. \nHow can I solve this using idiomatic\
    \ Racket?\n\n\nA:\n\nThe idiomatic way to write this in Racket is with <code>for/fold</code>\n\
    <code>(define (hex-key str)\n  (for/fold ([count 0])\n            ([c (in-string\
    \ str)])\n    (if (memq (string-&gt;number (string c 16)) '(2 3 5 7 11 13))\n\
    \        (add1 count)\n        count)))\n</code>\n<code>for/fold</code> is a combination\
    \ of a <code>for</code> loop and a fold, both of which are common in functional\
    \ programming.\nThis makes this the same as the <code>reduce</code> version, with\
    \ a few less calls.\n\nThis is obviously similar to what you've written, but because\
    \ it's a fold, we don't have to pass the <code>num</code> string around, but we\
    \ can keep it in the loop.\nThe main difference is in the line <code>[c (in-string\
    \ str)]</code>. The <code>for</code> loop will create a binding for each element\
    \ of <code>str</code> in <code>c</code>. Then we check if <code>c</code> is in\
    \ <code>'(2 3 5 7 11 13)</code> and increment the count if it is.\n\nThe idiomatic\
    \ way to check if an element is in a list is with <code>memq</code", "  (define\
    \ hex-primes '(2 3 5 7 11 13))\n  (define (hex-to-dec n)\n    (cond ((symbol=?\
    \ (string-ref n 0) #\\0) (string->number n 16))\n          ((symbol=? (string-ref\
    \ n 0) #\\1) (+ (string->number (substring n 1) 16) 16))\n          ((symbol=?\
    \ (string-ref n 0) #\\2) (+ (string->number (substring n 1) 16) 32))\n       \
    \   ((symbol=? (string-ref n 0) #\\3) (+ (string->number (substring n 1) 16) 48))\n\
    \          ((symbol=? (string-ref n 0) #\\4) (+ (string->number (substring n 1)\
    \ 16) 64))\n          ((symbol=? (string-ref n 0) #\\5) (+ (string->number (substring\
    \ n 1) 16) 80))\n          ((symbol=? (string-ref n 0) #\\6) (+ (string->number\
    \ (substring n 1) 16) 96))\n          ((symbol=? (string-ref n 0) #\\7) (+ (string->number\
    \ (substring n 1) 16) 112))\n          ((symbol=? (string-ref n 0) #\\8) (+ (string->number\
    \ (substring n 1) 16) 128))\n          ((symbol=? (string-ref n 0) #\\9) (+ (string->number\
    \ (substring n 1) 16) 144))\n          ((symbol=? (string-ref n 0) #\\A) (+ (string->number\
    \ (substring n 1) 16) 160))\n          ((symbol=? (string-ref n 0) #\\B) (+ (string->number\
    \ (substring n 1) 16) 176))\n          ((symbol=? (string-ref n 0) #\\C) (+ (string->number\
    \ (substring n 1) 16) 192))\n          ((symbol=? (string-ref n 0) #\\D) (+ (string->number\
    \ (substring n 1) 16) 208))\n          ((symbol=? (string-ref n 0) #\\E) (+ (string->number\
    \ (substring n 1", "  (cond [(empty? num) 0]\n        [(match num\n          \
    \      [(? (member #\\2 #\\3 #\\5 #\\7 #\\B #\\D)) (add1 (hex_key (rest num)))]\n\
    \                [_ (hex_key (rest num))]\n                )]))\n", "  (local\
    \ [(define (hex-to-num h)\n            (cond\n              [(equal? #\\0 h) 0]\n\
    \              [(equal? #\\1 h) 1]\n              [(equal? #\\2 h) 2]\n      \
    \        [(equal? #\\3 h) 3]\n              [(equal? #\\4 h) 4]\n            \
    \  [(equal? #\\5 h) 5]\n              [(equal? #\\6 h) 6]\n              [(equal?\
    \ #\\7 h) 7]\n              [(equal? #\\8 h) 8]\n              [(equal? #\\9 h)\
    \ 9]\n              [(equal? #\\A h) 10]\n              [(equal? #\\B h) 11]\n\
    \              [(equal? #\\C h) 12]\n              [(equal? #\\D h) 13]\n    \
    \          [(equal? #\\E h) 14]\n              [(equal? #\\F h) 15]\n        \
    \      [(equal? #\\a h) 10]\n              [(equal? #\\b h) 11]\n            \
    \  [(equal? #\\c h) 12]\n              [(equal? #\\d h) 13]\n              [(equal?\
    \ #\\e h) 14]\n              [(equal? #\\f h) 15]\n              [else (error\
    \ \"Invalid hex: ~s\" h)])\n            )]\n    (local [(define (is-prime n)\n\
    \              (define (divides? a b)\n                (= (remainder b a) 0))\n\
    \              (define (find-divisor n test-divisor)\n                (cond [(>\
    \ (square test-divisor) n) n]\n                      [(divides? test-divisor n)\
    \ test-divisor]\n                      [else (find-divisor n (+ test-divisor 1))]))\n\
    \              (= n (find-divisor n 2)))]\n      (local [(define (count-primes\
    \ s acc)\n                (cond [(null? s) acc]\n                      [(is-prime\
    \ (hex-to-num (car s)))\n                       (count-primes (cdr s) (+ acc 1))]\n\
    \                      [else (count-primes (cdr s) acc)]))]\n        (count-primes\
    \ (string->list", "  (displayln num)\n  (define (hex-to-decimal num)\n    (local\
    \ [(define (helper value digit)\n              (cond\n                [(= digit\
    \ #\\0) (+ (* value 16) 0)]\n                [(= digit #\\1) (+ (* value 16) 1)]\n\
    \                [(= digit #\\2) (+ (* value 16) 2)]\n                [(= digit\
    \ #\\3) (+ (* value 16) 3)]\n                [(= digit #\\4) (+ (* value 16) 4)]\n\
    \                [(= digit #\\5) (+ (* value 16) 5)]\n                [(= digit\
    \ #\\6) (+ (* value 16) 6)]\n                [(= digit #\\7) (+ (* value 16) 7)]\n\
    \                [(= digit #\\8) (+ (* value 16) 8)]\n                [(= digit\
    \ #\\9) (+ (* value 16) 9)]\n                [(= digit #\\A) (+ (* value 16) 10)]\n\
    \                [(= digit #\\B) (+ (* value 16) 11)]\n                [(= digit\
    \ #\\C) (+ (* value 16) 12)]\n                [(= digit #\\D) (+ (* value 16)\
    \ 13)]\n                [(= digit #\\E) (+ (* value 16) 14)]\n               \
    \ [(= digit #\\F) (+ (* value 16) 15)]\n                [else #f]))]\n      (helper\
    \ 0 (string-ref num (sub1 (string-length num))))))\n  (define (num-to-list num)\n\
    \    (if (= num 0)\n        null\n        (cons (remainder num 10) (num-to-list\
    \ (quotient num 10)))))\n  (define (is-prime? num)\n    (local [(define (helper\
    \ value n)\n              (cond\n                [(= n value) #t]\n          \
    \      [(divides? n value) #f]\n                [else (helper value (add1 n))]))]\n\
    \      (cond\n        [(= num 0) #f]\n        [(= num 1) #f]\n        [(= num\
    \ 2) #t]\n        [(= num 3) #t]\n        [(= num 5) #t]\n        [(= num 7) #t]\n\
    \        [(= num 11) #t]\n        [(", "  (if (string=? num \"\")\n      0\n \
    \     (if (memq (string->number (string-upcase num) 16) '(2 3 5 7 11 13))\n  \
    \        (+ 1 (hex_key (substring num 1)))\n          (hex_key (substring num\
    \ 1)))))\n</code>\n", "  (define primes '(2 3 5 7 11 13))\n  (define (hex-char->int\
    \ ch)\n    (cond ((char=? ch #\\A) 10)\n          ((char=? ch #\\B) 11)\n    \
    \      ((char=? ch #\\C) 12)\n          ((char=? ch #\\D) 13)\n          ((char=?\
    \ ch #\\E) 14)\n          ((char=? ch #\\F) 15)\n          (else (string->number\
    \ (string ch)))))\n  (define (count-primes lst count)\n    (cond ((null? lst)\
    \ count)\n          ((and (<= 2 (car lst)) (<= (car lst) 13))\n           (count-primes\
    \ (cdr lst) (+ count 1)))\n          (else (count-primes (cdr lst) count))))\n\
    \  (cond ((zero? (string-length num)) 0)\n        (else (count-primes (map hex-char->int\
    \ (string->list num)) 0))))", "  (count-prime (string->list num)))\n", "  (length\
    \ (list-ref (list\n                       (list #\\A #\\B #\\C #\\D #\\E #\\F)\n\
    \                       (list #\\1 #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\\
    0)\n                       (list #\\A #\\B #\\C #\\D #\\E #\\F)\n            \
    \           (list #\\1 #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\0)\n       \
    \                (list #\\A #\\B #\\C #\\D #\\E #\\F)\n                      \
    \ (list #\\1 #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\0)\n                 \
    \      (list #\\A #\\B #\\C #\\D #\\E #\\F)\n                       (list #\\\
    1 #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\0)\n                       (list\
    \ #\\A #\\B #\\C #\\D #\\E #\\F)\n                       (list #\\1 #\\2 #\\3\
    \ #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\0)\n                       (list #\\A #\\B\
    \ #\\C #\\D #\\E #\\F)\n                       (list #\\1 #\\2 #\\3 #\\4 #\\5\
    \ #\\6 #\\7 #\\8 #\\9 #\\0)\n                       (list #\\A #\\B #\\C #\\D\
    \ #\\E #\\F)\n                       (list #\\1 #\\2 #\\3 #\\4 #\\5 #\\6 #\\7\
    \ #\\8 #\\9 #\\0)\n                       (list #\\A #\\B #\\C #\\D #\\E #\\F)\n\
    \                       (list #\\1 #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\\
    0)\n                       (list #\\A #\\B #\\C #\\D #\\E #\\F)\n            \
    \           (list #\\1 #\\2 #\\3 #\\", "  (cond [(empty? num) 0]\n        [(or\
    \ (equal? (first num) #\\2)\n             (equal? (first num) #\\3)\n        \
    \     (equal? (first num) #\\5)\n             (equal? (first num) #\\7)\n    \
    \         (equal? (first num) #\\B)\n             (equal? (first num) #\\D))\n\
    \         (+ 1 (hex_key (rest num)))]\n        [else (hex_key (rest num))]))\n",
  "  (cond [(empty? num) 0]\n        [(char=? (string-ref num 0) #\\2) (+ 1 (hex_key\
    \ (substring num 1)))]\n        [(char=? (string-ref num 0) #\\3) (+ 1 (hex_key\
    \ (substring num 1)))]\n        [(char=? (string-ref num 0) #\\5) (+ 1 (hex_key\
    \ (substring num 1)))]\n        [(char=? (string-ref num 0) #\\7) (+ 1 (hex_key\
    \ (substring num 1)))]\n        [(char=? (string-ref num 0) #\\B) (+ 1 (hex_key\
    \ (substring num 1)))]\n        [(char=? (string-ref num 0) #\\D) (+ 1 (hex_key\
    \ (substring num 1)))]\n        [else (hex_key (substring num 1))]))\n", "  (cond\
    \ [(string=? num \"\") 0]\n        [else (cond [(string=? (string-upcase (substring\
    \ num 0 1)) \"A\") (add1 (hex_key (substring num 1)))]\n                   [(string=?\
    \ (string-upcase (substring num 0 1)) \"B\") (add1 (hex_key (substring num 1)))]\n\
    \                   [(string=? (string-upcase (substring num 0 1)) \"C\") (add1\
    \ (hex_key (substring num 1)))]\n                   [(string=? (string-upcase\
    \ (substring num 0 1)) \"D\") (add1 (hex_key (substring num 1)))]\n          \
    \         [(string=? (string-upcase (substring num 0 1)) \"E\") (add1 (hex_key\
    \ (substring num 1)))]\n                   [(string=? (string-upcase (substring\
    \ num 0 1)) \"F\") (add1 (hex_key (substring num 1)))]\n                   [(or\
    \ (= (string->number (substring num 0 1)) 2) (= (string->number (substring num\
    \ 0 1)) 3) (= (string->number (substring num 0 1)) 5) (= (string->number (substring\
    \ num 0 1)) 7)) (add1 (hex_key (substring num 1)))]\n                   [else\
    \ (hex_key (substring num 1))]))])\n", "  (define (my-list)\n    (cond\n     \
    \ [(= num \"\") 0]\n      [(prime? (char->integer (string-ref num 0))) (+ 1 (my-list\
    \ (substring num 1)))]\n      [else (my-list (substring num 1))]))\n  (my-list\
    \ num))\n", "  (cond\n    [(= (string-length num) 0) 0]\n    [(member (string-ref\
    \ num 0) \"2357BDF\") (+ 1 (hex_key (substring num 1)))]\n    [else (hex_key (substring\
    \ num 1))]))", "  (length (list-ref (list (list '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n\
    \                         (list '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n             \
    \            (list '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n                         (list\
    \ '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n                         (list '0 '1 '2 '3 '4\
    \ '5 '6 '7 '8 '9)\n                         (list '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n\
    \                         (list '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n             \
    \            (list '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n                         (list\
    \ '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n                         (list '0 '1 '2 '3 '4\
    \ '5 '6 '7 '8 '9)\n                         (list '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n\
    \                         (list '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n             \
    \            (list '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n                         (list\
    \ '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n                         (list '0 '1 '2 '3 '4\
    \ '5 '6 '7 '8 '9)\n                         (list '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n\
    \                         (list '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n             \
    \            (list '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n                         (list\
    \ '0 '1 '2 '3 '4 '5 '6 '7 '8 '9)\n                         (list '0 '1 '2 '3 '4\
    \ '5 '6 '7 '8 '9)\n                         (list", "  (cond [(empty? num) 0]\n\
    \        [(char-numeric? (string-ref num 0))\n         (if (prime? (string->number\
    \ (string (string-ref num 0))))\n             (+ 1 (hex_key (substring num 1)))\n\
    \             (hex_key (substring num 1)))]\n        [(string=? (string (string-ref\
    \ num 0)) \"A\")\n         (if (prime? (string->number (string (string-ref num\
    \ 0))))\n             (+ 1 (hex_key (substring num 1)))\n             (hex_key\
    \ (substring num 1)))]\n        [(string=? (string (string-ref num 0)) \"B\")\n\
    \         (if (prime? (string->number (string (string-ref num 0))))\n        \
    \     (+ 1 (hex_key (substring num 1)))\n             (hex_key (substring num\
    \ 1)))]\n        [(string=? (string (string-ref num 0)) \"C\")\n         (if (prime?\
    \ (string->number (string (string-ref num 0))))\n             (+ 1 (hex_key (substring\
    \ num 1)))\n             (hex_key (substring num 1)))]\n        [(string=? (string\
    \ (string-ref num 0)) \"D\")\n         (if (prime? (string->number (string (string-ref\
    \ num 0))))\n             (+ 1 (hex_key (substring num 1)))\n             (hex_key\
    \ (substring num 1)))]\n        [(string=? (string (string-ref num 0)) \"E\")\n\
    \         (if (prime? (string->number (string (string-ref num 0))))\n        \
    \     (+ 1 (hex_key (substring num 1)))\n             (hex_key (substring num\
    \ 1)))]\n        [(string=? (string (string-ref num 0)) \"F\")\n         (if (prime?\
    \ (string->number (string (string-ref num 0))))\n             (+ 1 (hex_key (substring\
    \ num 1)))\n             (hex_key (substring num 1)))]\n        [else (hex_key\
    \ (substring num 1))]))\n", "  (define (helper digit total)\n    (if (empty? digit)\n\
    \        total\n        (if (or (= (first digit) #\\2) (= (first digit) #\\3)\
    \ (= (first digit) #\\5)\n                (= (first digit) #\\7) (= (first digit)\
    \ #\\B) (= (first digit) #\\D))\n            (helper (rest digit) (+ total 1))\n\
    \            (helper (rest digit) total))))\n  (helper (string->list num) 0))\n",
  "  (let ([hex-chars (list '#\\2 '#\\3 '#\\5 '#\\7 '#\\B '#\\D)])\n    (fold + 0\
    \ (map (lambda (c) (if (member c hex-chars) 1 0)) (string->list num)))))\n", " \
    \ (letrec ([is-hex-prime? (lambda (n)\n                            (and (not (member\
    \ n '(0 1)))\n                                 (or (member n '(2 3 5 7 11 13)))))])\n\
    \    (for/sum ([d (in-string num)]\n              #:when (is-hex-prime? (string->number\
    \ (string d) 16)))\n      1)))\n", "  (if (string=? num \"\")\n      0\n     \
    \ (if (string-contains num #\\A)\n          (+ 1 (hex_key (string-replace num\
    \ #\\A \"\")))\n          (if (string-contains num #\\B)\n              (+ 1 (hex_key\
    \ (string-replace num #\\B \"\")))\n              (if (string-contains num #\\\
    C)\n                  (+ 1 (hex_key (string-replace num #\\C \"\")))\n       \
    \           (if (string-contains num #\\D)\n                      (+ 1 (hex_key\
    \ (string-replace num #\\D \"\")))\n                      (if (string-contains\
    \ num #\\E)\n                          (+ 1 (hex_key (string-replace num #\\E\
    \ \"\")))\n                          (if (string-contains num #\\F)\n        \
    \                      (+ 1 (hex_key (string-replace num #\\F \"\")))\n      \
    \                        (if (odd? (string->number num))\n                   \
    \               (+ 1 (hex_key (string-replace num #\\F \"\")))\n             \
    \                     0))))))))))\n</code>\nBut if the input is very long, we\
    \ need a lot of if.\nIs there a way to do a shorter version?\n\n\nA:\n\nHere is\
    \ a concise version.\nNote that you can use <code>string-contains</code> only\
    \ if the character is unique, otherwise it is better to use <code>string-index</code>\
    \ which is what I did here.\nThe technique is to look for the index of each character,\
    \ then replace it by a <code>#\\~</code> to mark it as found.\n<code>(define (hex-key\
    \ num)\n  (if (string=? num \"\")\n      0\n      (define p (string-index num\
    \ (number-&gt;char (+ #\\A 10))))\n      (if p\n          (+ 1 (hex-key (string-replace\
    \ num p 1 #\\~ 1)))\n          (define p (string-index num (number-&gt;char (+\
    \ #\\A 2))))\n          (if p\n              (+ 1 (hex-key (string-replace num\
    \ p 1 #\\~ 1)))\n              (define p (string-index num (number-&gt;char (+\
    \ #\\A", "  (map (lambda (n) (display n))\n       (filter (lambda (n) (or (= n\
    \ 2) (= n 3) (= n 5) (= n 7) (= n 11) (= n 13)))\n               (map (lambda\
    \ (n)\n                      (cond\n                        [(= n #\\0) 0]\n \
    \                       [(= n #\\1) 1]\n                        [(= n #\\2) 2]\n\
    \                        [(= n #\\3) 3]\n                        [(= n #\\4) 4]\n\
    \                        [(= n #\\5) 5]\n                        [(= n #\\6) 6]\n\
    \                        [(= n #\\7) 7]\n                        [(= n #\\8) 8]\n\
    \                        [(= n #\\9) 9]\n                        [(= n #\\A) 10]\n\
    \                        [(= n #\\B) 11]\n                        [(= n #\\C)\
    \ 12]\n                        [(= n #\\D) 13]\n                        [(= n\
    \ #\\E) 14]\n                        [(= n #\\F) 15]))\n                    (string->list\
    \ num))))\n  (length (filter (lambda (n) (or (= n 2) (= n 3) (= n 5) (= n 7) (=\
    \ n 11) (= n 13)))\n                   (map (lambda (n)\n                    \
    \      (cond\n                            [(= n #\\0) 0]\n                   \
    \         [(= n #\\1) 1]\n                            [(= n #\\2) 2]\n       \
    \                     [(= n #\\3) 3]\n                            [(= n #\\4)\
    \ 4]\n                            [(= n #\\5) 5]\n                           \
    \ [(= n #\\6) 6]\n                            [(= n #\\7) 7]\n               \
    \             [(= n #\\8) 8]\n                            [(= n #\\9) 9]\n   \
    \                         [(= n #\\A) 10]\n                            [(= n #\\\
    B) 11]\n                            [(= n #\\C) 12]\n                        \
    \    [(= n #\\D) 13]\n                            [(= n #\\E) 14]\n          \
    \                  [(= n #\\F) 15]))\n                        (string->list num))))))",
  "  (length (filter is-prime? (map string->number num))))\n", "  (define (conv num)\n\
    \    (cond\n      [(= num #\\0) 0]\n      [(= num #\\1) 1]\n      [(= num #\\\
    2) 2]\n      [(= num #\\3) 3]\n      [(= num #\\4) 4]\n      [(= num #\\5) 5]\n\
    \      [(= num #\\6) 6]\n      [(= num #\\7) 7]\n      [(= num #\\8) 8]\n    \
    \  [(= num #\\9) 9]\n      [(= num #\\A) 10]\n      [(= num #\\B) 11]\n      [(=\
    \ num #\\C) 12]\n      [(= num #\\D) 13]\n      [(= num #\\E) 14]\n      [(= num\
    \ #\\F) 15]))\n  (define (prime? num)\n    (cond\n      [(= num 1) false]\n  \
    \    [(= num 2) true]\n      [(= num 3) true]\n      [(= num 5) true]\n      [(=\
    \ num 7) true]\n      [(= num 11) true]\n      [(= num 13) true]\n      [else\
    \ (eq? (remainder num 2) 1)]))\n  (if (string-empty? num)\n      0\n      (if\
    \ (prime? (conv (string-ref num 0)))\n          (+ 1 (hex_key (substring num 1)))\n\
    \          (hex_key (substring num 1)))))", "    (letrec \n        ([hex-primes\
    \ (list 2 3 5 7 11 13)])\n        (define (digit? c)\n            (or \n     \
    \           (and (>= c (char->integer #\\0)) (<= c (char->integer #\\9)))\n  \
    \              (and (>= c (char->integer #\\A)) (<= c (char->integer #\\F)))))\n\
    \        (define (char->int c)\n            (if (digit? c)\n                (if\
    \ (and (>= c (char->integer #\\A)) (<= c (char->integer #\\F)))\n            \
    \        (- c (char->integer #\\A) 10)\n                    (- c (char->integer\
    \ #\\0)))\n                0))\n        (define (int->char num)\n            (integer->char\
    \ \n                (if (>= num 10)\n                    (+ (char->integer #\\\
    A) (- num 10))\n                    (+ (char->integer #\\0) num))))\n        (define\
    \ (is-prime? n)\n            (define (iter p)\n                (if (= p n)\n \
    \                   #t\n                    (if (= (remainder n p) 0)\n      \
    \                  #f\n                        (iter (+ p 1)))))\n           \
    \ (if (= n 1)\n                #f\n                (iter 2)))\n        (define\
    \ (sum-digits-with-predicate str fn)\n            (if (null? str)\n          \
    \      0\n                (+ (fn (car str))\n                    (sum-digits-with-predicate\
    \ (cdr str) fn))))\n        (define (get-primes str)\n            (filter (lambda\
    \ (x) (is-prime? x))\n                (map char->int str)))\n        (sum-digits-with-predicate\
    \ (get-primes num) (lambda (x) x))))\n", "  (length (filter (lambda (x) (if (<\
    \ x 10) (< x 4) (< x 16))) (map (lambda (c) (string->number (string c) 16)) (string->list\
    \ num)))))\n", "  (cond ((not (string? num)) 0)\n        ((empty? num) 0)\n  \
    \      ((hex-prime? (string->number (string-ref num 0) 16))\n         (+ 1 (hex_key\
    \ (substring num 1))))\n        (else (hex_key (substring num 1)))))\n", "  (for/sum\
    \ ([x (string->list num)]\n            #:when (member x '(\"2\" \"3\" \"5\" \"\
    7\" \"B\" \"D\")))\n    1))\n", "  (length\n   (filter\n    (lambda (x)\n    \
    \  (and (list? x) (eq? (car x) 'primes)))\n    (apply +\n     (map\n      (lambda\
    \ (x)\n        (if (equal? (remainder x 2) 0)\n            (list 'even x)\n  \
    \          (list 'primes x)))\n      (string->list num))))))", "  (count (string->list\
    \ num)\n         (lambda (c) (member c '(\"2\" \"3\" \"5\" \"7\" \"B\" \"D\")))))\n\
    ```\n\n```racket\n#lang racket\n", "  (cond\n    [(empty? num) 0]\n    [(number?\
    \ (string->number (string-append \"0x\" (string (car num))) 16))\n     (+ 1 (hex_key\
    \ (cdr num)))]\n    [else (hex_key (cdr num))]))", "  (cond\n    [(string=? num\
    \ \"\") (list->string \"\")]\n    [else (len (filter hex? (string->list num)))]))\n",
  "  (length\n   (filter\n    (lambda (x) (and (string=? \"2\" x) (string=? \"3\"\
    \ x) (string=? \"5\" x) (string=? \"7\" x) (string=? \"B\" x) (string=? \"D\"\
    \ x)))\n    (string->list num))))\n", "  (local [(define primes '(2 3 5 7 11 13\
    \ 17))]\n    (string-length (filter \n                    (lambda (c) (member\
    \ c primes))\n                    (build-list (string-length num) (lambda (i)\
    \ (string->number (string-ref num i) 16)))))))\n```\n\n## Ruby\n\n```ruby\n#!/usr/bin/env\
    \ ruby\n\ndef hex_key(num)\n  primes = [2, 3, 5, 7, 11, 13, 17]\n  num.split('').map(&:hex).count\
    \ { |n| primes.include? n }\nend\n```\n\n## Swift\n\n```swift\n#!/usr/bin/env\
    \ swift\n\nfunc hexKey(_ str: String) -> Int {\n  let primes = [2, 3, 5, 7, 11,\
    \ 13, 17]\n  return str.map { Int(String($0), radix: 16)! }.filter { primes.contains($0)\
    \ }.count\n}\n```", "  (if (string-empty? num)\n      0\n      (letrec ([h (string-&gt;number\
    \ (string (string-ref num 0)) 16)]\n               [t (substring num 1)])\n  \
    \      (if (&lt;= h 7)\n            (+ (if (even? h) 1 0) (hex_key t))\n     \
    \       (+ (if (or (= h 11) (= h 13)) 1 0) (hex_key t))))))\n</code>\n", "  (cond\n\
    \    [(empty? num) 0]\n    [(and\n      (number? (string->number num))\n     \
    \ (odd? (string->number num)))\n     (add1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (cond\n    [(string=? num \"\") 0]\n    [(string=? num\
    \ \"#f\") 0]\n    [(string=? num \"#t\") 0]\n    [else\n     (string-length\n\
    \      (string-intersect num (string-join (map string (list 2 3 5 7 11 13)) \"\
    \")))]))\n", "  (cond\n    [(empty? num) 0]\n    [(prime? (char->integer (string-ref\
    \ num 0) 16)) (+ 1 (hex_key (substring num 1)))]\n    [else (hex_key (substring\
    \ num 1))]))\n", "  (length (filter (lambda (c) (member c '(2 3 5 7 11 13)))\n\
    \                  (map string->number (string-&gt;list num) 16))))\n</code>\n\
    In the next problem, I'm trying to make a new function which will reverse the\
    \ original function, meaning it will return a list of possible numbers that could\
    \ produce that number of primes.\n<code>#lang racket\n", "  (define map '((\"\
    0\" . 0) (\"1\" . 1) (\"2\" . 2) (\"3\" . 3) (\"4\" . 4) (\"5\" . 5) (\"6\" .\
    \ 6) (\"7\" . 7) (\"8\" . 8) (\"9\" . 9) (\"A\" . 10) (\"B\" . 11) (\"C\" . 12)\
    \ (\"D\" . 13) (\"E\" . 14) (\"F\" . 15)))\n  (define primes '(2 3 5 7 11 13 17))\n\
    \  (let f ([num num] [cnt 0])\n    (cond [(zero? (length num)) cnt]\n        \
    \  [(member (string->number (list (string-ref num 0)) 16) primes) (f (substring\
    \ num 1) (+ cnt 1))]\n          [else (f (substring num 1) cnt)])))\n", "  (let\
    \ ((primes '(2 3 5 7 11 13 17 19)))\n    (cond ((null? num) 0)\n          ((member\
    \ (string->number (string-upcase (substring num 0 1)) 16) primes)\n          \
    \ (+ 1 (hex_key (substring num 1))))\n          (else (hex_key (substring num\
    \ 1))))))\n", "  (cond ((null? num) 0)\n        ((string-member? (substring num\
    \ 0 1) \n                         \"234567ABCDEF\")\n         (+ 1 (hex_key (substring\
    \ num 1))))\n        (else (hex_key (substring num 1)))))\n", "  (cond\n    ((equal?\
    \ num \"\") 0)\n    ((hexprime? (string->number (substring num 0 1) 16))\n   \
    \  (+ 1 (hex_key (substring num 1))))\n    (else (hex_key (substring num 1)))))\n",
  "  (if (not (string? num))\n      (error \"Not a string\")\n      (hex_key_helper\
    \ num 0)))\n", "  (if (eq? num \"\")\n      0\n      (let* ([num (string->number\
    \ num 16)]\n             [lst (build-list num (\u03BB (x) x))]\n             [primes\
    \ (filter prime? lst)])\n        (length primes))))", "  (cond ((string=? num\
    \ \"\") 0)\n        ((member (string-&gt;number (string-&gt;symbol (substring\
    \ num 0 1) 'symbol) 16)\n                 '(2 3 5 7 11 13))\n         (+ 1 (hex_key\
    \ (substring num 1))))\n        (else (hex_key (substring num 1)))))\n</code>\n\
    I found that this is not a strict solution, but rather a one that works for me:\n\
    <code>#lang racket\n", "  (define (is-prime n)\n    (let ([root (sqrt n)])\n \
    \     (not (any (lambda (x) (zero? (modulo n x)))\n                (range 2 (add1\
    \ root))))))\n  (define (hex-key-helper n)\n    (let ([hex-list '(#\\0 #\\1 #\\\
    2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\A #\\B #\\C #\\D #\\E #\\F)])\n      (if\
    \ (null? n)\n          0\n          (if (member (string->symbol (string (car n)))\
    \ hex-list)\n              (if (is-prime (symbol->integer (string (car n))))\n\
    \                  (add1 (hex-key-helper (cdr n)))\n                  (hex-key-helper\
    \ (cdr n)))\n              (hex-key-helper (cdr n))))))\n  (hex-key-helper (string->list\
    \ num)))\n", "  (if (string=? num \"\") 0 (if (member (string-&gt;number (string-&gt;list\
    \ num) 16) '(2 3 5 7 11 13)) (+ 1 (hex_key (substring num 1))) (hex_key (substring\
    \ num 1)))))\n</code>\nThe solution works as I intended except for one thing.\
    \ When the string contains a hex number that is not a prime, the function gives\
    \ it a value of 1.\nExample:\n<code>(hex_key \"1077E\")\n&gt;&gt; 2", "  (cond\n\
    \    [(equal? num \"\") 0]\n    [(equal? num \"A\") 1]\n    [(equal? num \"B\"\
    ) 1]\n    [(equal? num \"C\") 0]\n    [(equal? num \"D\") 1]\n    [(equal? num\
    \ \"E\") 0]\n    [(equal? num \"F\") 0]\n    [(equal? num \"0\") 0]\n    [(equal?\
    \ num \"1\") 0]\n    [(equal? num \"2\") 1]\n    [(equal? num \"3\") 1]\n    [(equal?\
    \ num \"4\") 0]\n    [(equal? num \"5\") 1]\n    [(equal? num \"6\") 0]\n    [(equal?\
    \ num \"7\") 1]\n    [(equal? num \"8\") 0]\n    [(equal? num \"9\") 0]\n    [else\
    \ (error \"unknown number\")]))\n", "  (let loop ([num (string->list num)]\n \
    \            [count 0])\n    (if (or (empty? num) (and (equal? (car num) #\\0)\
    \ (equal? (cadr num) #\\x)))\n        count\n        (let ((n (string->number\
    \ (list->string (cons (car num) '(#\\0 #\\x)))))\n              (rem (cdr num)))\n\
    \          (if (and (>= n 2) (<= n 15) (prime? n))\n              (loop rem (+\
    \ count 1))\n              (loop rem count))))))\n", "  (define (num-&gt;int num)\n\
    \    (if (char-&gt;integer num)\n        (char-&gt;integer num)\n        (+ 10\
    \ (char-&gt;integer (char-downcase num)))))\n  (define (is-prime? num)\n    (cond\
    \ [(= num 2) #t]\n          [(even? num) #f]\n          [(is-prime? (- num 1))\
    \ #t]\n          [else #f]))\n  (define (prime-nums num)\n    (cond [(empty? num)\
    \ 0]\n          [(is-prime? (num-&gt;int (car num))) (+ 1 (prime-nums (cdr num)))]\n\
    \          [else (prime-nums (cdr num))]))\n  (prime-nums (string-&gt;list num)))\n\
    </code>\nAny suggestions are much appreciated.\n", "  (length\n   (remove* \"\
    ABCDEF\"\n            (filter is-prime? (map string->number (string-&gt;list num))))))\n",
  "  (length (filter hex-key-filter? (string->list num))))\n", "  (if (string-empty?\
    \ num)\n      0\n      (let ([[digit rest] (string-split (string-upcase num) #\\\
    1)])\n        (if (hex-prime? digit)\n            (+ 1 (hex_key rest))\n     \
    \       (hex_key rest)))))\n", "  (cond [(empty? num) 0]\n        [(member (string-&gt;number\
    \ (substring num 0 1) 16)\n                 (list 2 3 5 7 11 13))\n         (+\
    \ 1 (hex_key (substring num 1 (string-length num))))]\n        [else (hex_key\
    \ (substring num 1 (string-length num)))]))\n</code>\nIt passes all the tests.\n\
    So far I have come up with this solution:\n<code>#lang racket\n", "  (letrec ([primes\
    \ (cons 2 (for/list ([i (in-range 3 16 (+ 2 i))]) i))])\n    (let loop ([str (string->list\
    \ num)] [s (for/sum ([i (in-range 16)]) (* 16 i))])\n      (if (null? str)\n \
    \         s\n          (let* ([c (string-&gt;number (string (car str)) 16)]\n\
    \                 [s (if (memq c primes) (+ s 1) s)])\n            (loop (cdr\
    \ str) s))))))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\\
    0 #\\1 #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9))\n      (+ (hex_key (rest num))\n\
    \        (cond\n          [(prime? (string->number (string (first num)))) 1]\n\
    \          [else 0]))]\n    [(member (first num) '(#\\A #\\B #\\C #\\D #\\E #\\\
    F))\n      (+ (hex_key (rest num))\n        (cond\n          [(prime? (+ 10 (string->number\
    \ (string (first num))))) 1]\n          [else 0]))]))\n", "  (define (v-to-n c)\n\
    \    (cond ((= c #\\0) 0)\n          ((= c #\\1) 1)\n          ((= c #\\2) 2)\n\
    \          ((= c #\\3) 3)\n          ((= c #\\4) 4)\n          ((= c #\\5) 5)\n\
    \          ((= c #\\6) 6)\n          ((= c #\\7) 7)\n          ((= c #\\8) 8)\n\
    \          ((= c #\\9) 9)\n          ((= c #\\A) 10)\n          ((= c #\\B) 11)\n\
    \          ((= c #\\C) 12)\n          ((= c #\\D) 13)\n          ((= c #\\E) 14)\n\
    \          ((= c #\\F) 15)))\n  (define (prime? n)\n    (cond ((= n 2) #t)\n \
    \         ((= n 3) #t)\n          ((= n 5) #t)\n          ((= n 7) #t)\n     \
    \     ((= n 11) #t)\n          ((= n 13) #t)\n          ((= n 17) #t)\n      \
    \    ((= n 19) #t)\n          ((= n 23) #t)\n          ((= n 29) #t)\n       \
    \   ((= n 31) #t)\n          ((= n 37) #t)\n          ((= n 41) #t)\n        \
    \  ((= n 43) #t)\n          ((= n 47) #t)\n          ((= n 53) #t)\n         \
    \ ((= n 59) #t)\n          ((= n 61) #t)\n          ((= n 67) #t)\n          ((=\
    \ n 71) #t)\n          ((= n 73) #t)\n          ((= n 79) #t)\n          ((= n\
    \ 83) #t)\n          ((= n 89) #t)\n          ((= n 97) #t)\n          (else #f)))\n\
    \  (define (helper ls)\n    (if (null? ls)\n        0\n        (if (prime? (v-to-n\
    \ (car ls)))\n            (+ 1 (helper (cdr ls)))\n            (hel", "  (define\
    \ hex-primes\n    (list #\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n  (for/fold ([count 0])\
    \ ([ch (in-string num)])\n    (if (member ch hex-primes)\n        (add1 count)\n\
    \        count)))\n```\n\n```racket\n#lang racket\n", "  (cond ((string=? num\
    \ \"\") 0)\n        ((string=? num \"0\") 0)\n        ((string=? num \"2\") 1)\n\
    \        ((string=? num \"3\") 1)\n        ((string=? num \"5\") 1)\n        ((string=?\
    \ num \"7\") 1)\n        ((string=? num \"B\") 1)\n        ((string=? num \"D\"\
    ) 1)\n        (else (+ (hex_key (string-drop num 1)) \n                 (hex_key\
    \ (string-take num 1))))))\n", "  (cond\n    ((null? num) 0)\n    ((number? (char->integer\
    \ (car num)))\n     (hex_key (cdr num)))\n    ((member (car num) '(#\\A #\\B #\\\
    C #\\D #\\E #\\F))\n     (+ 1 (hex_key (cdr num))))\n    (else (hex_key (cdr num)))))\n",
  "  (cond\n    [(equal? num \"\") 0]\n    [(hex-prime? (string->number num 16)) (+\
    \ 1 (hex_key (substring num 1)))]\n    [else (hex_key (substring num 1))]))\n",
  "  (cond ((string=? num \"\") 0)\n        ((and (string=? (substring num 0 1) \"\
    A\")\n              (= (hex->decimal (substring num 0 1)) 11))\n         (+ 1\
    \ (hex_key (substring num 1))))\n        ((and (string=? (substring num 0 1) \"\
    B\")\n              (= (hex->decimal (substring num 0 1)) 11))\n         (+ 1\
    \ (hex_key (substring num 1))))\n        ((and (string=? (substring num 0 1) \"\
    C\")\n              (= (hex->decimal (substring num 0 1)) 11))\n         (+ 1\
    \ (hex_key (substring num 1))))\n        ((and (string=? (substring num 0 1) \"\
    D\")\n              (= (hex->decimal (substring num 0 1)) 11))\n         (+ 1\
    \ (hex_key (substring num 1))))\n        ((and (string=? (substring num 0 1) \"\
    E\")\n              (= (hex->decimal (substring num 0 1)) 11))\n         (+ 1\
    \ (hex_key (substring num 1))))\n        ((and (string=? (substring num 0 1) \"\
    F\")\n              (= (hex->decimal (substring num 0 1)) 11))\n         (+ 1\
    \ (hex_key (substring num 1))))\n        ((prime? (hex->decimal (substring num\
    \ 0 1)))\n         (+ 1 (hex_key (substring num 1))))\n        (else (hex_key\
    \ (substring num 1)))))\n", "  (let* ([primes '(2 3 5 7 11 13)]\n         [is-hex?\
    \ (lambda (c)\n                    (and (char&lt;=? #\\0 c) (char&lt;=? c #\\\
    9)\n                         (or (char&lt;=? #\\A c) (char&lt;=? c #\\F))))]\n\
    \         [hex-value (lambda (c)\n                      (let ([number (char-&gt;integer\
    \ c)])\n                        (if (char&lt;=? #\\0 number)\n               \
    \             number\n                            (- number 55))))]\n        \
    \ [count 0])\n    (for ([c (in-string num)])\n      (when (is-hex? c)\n      \
    \  (when (member (hex-value c) primes)\n          (set! count (+ count 1)))))\n\
    \    count))\n", "  (let ([primes '(2 3 5 7 11 13)])\n    (apply + (map (curry\
    \ char-&gt;integer) (filter (lambda (c) (member c primes)) (string-&gt;list num))))))\n",
  "  (cond\n    [(string=? num \"\") 0]\n    [(hex-digit? (string-ref num 0))\n  \
    \   (+ (is-prime? (hex-to-int (string-ref num 0)))\n\t(hex_key (substring num\
    \ 1 (string-length num))))]\n    [else (hex_key (substring num 1 (string-length\
    \ num)))]))\n", "  (let loop ([num-str (string->list num)]\n             [cnt\
    \ 0])\n    (if (null? num-str)\n        cnt\n        (let ([c (car num-str)])\n\
    \          (if (or (char=? c #\\0)\n                  (char=? c #\\1)\n      \
    \            (char=? c #\\8)\n                  (char=? c #\\9))\n           \
    \   (loop (cdr num-str) cnt)\n              (if (or (char=? c #\\2)\n        \
    \              (char=? c #\\3)\n                      (char=? c #\\5)\n      \
    \                (char=? c #\\7)\n                      (char=? c #\\B)\n    \
    \                  (char=? c #\\D))\n                  (loop (cdr num-str) (+\
    \ cnt 1))\n                  (loop (cdr num-str) cnt)))))))\n", "  (count_primes\
    \ (vector-&gt;list (string-&gt;vector num))))\n", "  (if (string=? num \"\")\n\
    \      0\n      (if (or (= (substring num 0 1) #\\2)\n              (= (substring\
    \ num 0 1) #\\3)\n              (= (substring num 0 1) #\\5)\n              (=\
    \ (substring num 0 1) #\\7)\n              (= (substring num 0 1) #\\B)\n    \
    \          (= (substring num 0 1) #\\D))\n          (+ 1 (hex_key (substring num\
    \ 1 (string-length num))))\n          (hex_key (substring num 1 (string-length\
    \ num))))))\n</code>\nThis is what I tried, but it won't work.\n<code>#lang racket\n",
  "  (if (zero? (string-length num))\n      0\n      (if (prime? (char->integer (string-ref\
    \ num 0)))\n          (+ 1 (hex_key (substring num 1)))\n          (hex_key (substring\
    \ num 1)))))\n", "  (length (intersection (list->set (hex->list num)) (primes->set))))\n",
  "  (let ([primes '(2 3 5 7 11 13 17)])\n    (regexp-match* #rx\"[0-9ABDEC]\" num\n\
    \      (\u03BB (n)\n        (cond\n          [(char-&gt;integer n)\n         \
    \  (if (member (char-&gt;integer n) primes)\n               1 0)]\n          [(string=?\
    \ \"A\" n)\n           (if (member 10 primes)\n               1 0)]\n        \
    \  [(string=? \"B\" n)\n           (if (member 11 primes)\n               1 0)]\n\
    \          [(string=? \"C\" n)\n           (if (member 12 primes)\n          \
    \     1 0)]\n          [(string=? \"D\" n)\n           (if (member 13 primes)\n\
    \               1 0)]\n          [(string=? \"E\" n)\n           (if (member 14\
    \ primes)\n               1 0)]\n          [(string=? \"F\" n)\n           (if\
    \ (member 15 primes)\n               1 0)]))\n      #:sum #t)))\n</code>\nMy solution\
    \ passes the examples, but I would like to know if there is a better way to do\
    \ this and how can I make this more efficient?\n\n\nA:\n\nThe <code>regexp-match*</code>\
    \ function is overkill here - you don't need to perform a regular expression search,\
    \ it's enough to iterate over each character in the input string. Also, <code>member</code>\
    \ returns <code>#f</code> if the searched element is not found, so it's enough\
    \ to use it directly as a predicate for <code>if</code>, there's no need to test\
    \ its result. Finally, there's no need to go from a string to a character and\
    \ back to an integer, this can be done directly with <code>string-&gt;number</code>.\
    \ In the end, the code becomes:\n<code>(define (hex_key num)\n  (let ([primes\
    \ '(2 3 5 7 11 13 17)])\n    (for/sum ([n (in-string num)])\n      (if (member\
    \ (string-&gt;number n 16) primes)\n          1 0))))\n</code>\nIf we test this\
    \ function with your examples it", "  (cond\n    [(empty? num) 0]\n    [(member\
    \ (string-&gt;number (first num) 16) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (rest\
    \ num)))]\n    [else (hex_key (rest num))]))\n", "  (define (digit-value ch)\n\
    \    (define (char->int ch)\n      (- (char->integer ch) (char->integer #\\0)))\n\
    \    (cond\n      [(char=? ch #\\A) 10]\n      [(char=? ch #\\B) 11]\n      [(char=?\
    \ ch #\\C) 12]\n      [(char=? ch #\\D) 13]\n      [(char=? ch #\\E) 14]\n   \
    \   [(char=? ch #\\F) 15]\n      [else (char->int ch)]))\n  (define (digit-prime?\
    \ d)\n    (member d '(2 3 5 7 11 13)))\n  (cond\n    [(empty? num) 0]\n    [else\
    \ (+ (if (digit-prime? (digit-value (string-ref num 0))) 1 0)\n             (hex_key\
    \ (substring num 1)))]))", "  (cond ((zero? (length num)) 0)\n        ((and (member\
    \ (string-&gt;number (string-ref num 0) 16) '(2 3 5 7 11 13))\n              (&gt;\
    \ (string-&gt;number (string-ref num 0) 16) 1))\n         (+ 1 (hex_key (substring\
    \ num 1))))\n        (else (hex_key (substring num 1)))))\n", "  (let* ([primes\
    \ '(2 3 5 7 11 13)]\n         [digits (string->list num)]\n         [nums (map\
    \ string->number digits)])\n    (length (filter (lambda (x) (member x primes))\
    \ nums))))", "  (cond\n    [(string=? num \"\") 0]\n    [(member (string->symbol\
    \ (substring num 0 1)) '(2 3 5 7 11 13)) (+ 1 (hex_key (substring num 1)))]\n\
    \    [else (hex_key (substring num 1))]))", "  (define (hex->num h)\n    (cond\n\
    \      [(string=? h \"A\") 10]\n      [(string=? h \"B\") 11]\n      [(string=?\
    \ h \"C\") 12]\n      [(string=? h \"D\") 13]\n      [(string=? h \"E\") 14]\n\
    \      [(string=? h \"F\") 15]\n      [else (string->number h)]))\n  (define (is-prime\
    \ n)\n    (define (prime-helper i n)\n      (cond [(zero? n) #f]\n           \
    \ [(zero? i) #t]\n            [(= (remainder n i) 0) #f]\n            [else (prime-helper\
    \ (- i 1) n)]))\n    (prime-helper (- n 1) n))\n  (define (prime-digits num)\n\
    \    (cond\n      [(empty? num) 0]\n      [(and (is-prime (hex->num (first num)))\n\
    \            (not (zero? (hex->num (first num)))))\n       (+ 1 (prime-digits\
    \ (rest num)))]\n      [else (prime-digits (rest num))]))\n  (prime-digits num))",
  "  (let ([count 0])\n    (for ([ch (string->list num)])\n      (if (or (eq? ch #\\\
    2)\n              (eq? ch #\\3)\n              (eq? ch #\\5)\n              (eq?\
    \ ch #\\7)\n              (eq? ch #\\B)\n              (eq? ch #\\D))\n      \
    \    (set! count (+ count 1))))\n    count))\n", "  (cond\n    [(string=? num\
    \ \"\") 0]\n    [(integer? (string->number num 16)) 0]\n    [else\n     (cond\n\
    \       [(member (string-&gt;number (string (string-ref num 0) 16)) '(2 3 5 7\
    \ 11 13)) (+ 1 (hex_key (substring num 1)))]\n       [else (hex_key (substring\
    \ num 1))])]))\n</code>\n", "  (count \"BD\" num))\n", "  (define (convert-hex-to-dec\
    \ n)\n    (define (convert-digit d)\n      (cond ((equal? d #\\0) 0)\n       \
    \     ((equal? d #\\1) 1)\n            ((equal? d #\\2) 2)\n            ((equal?\
    \ d #\\3) 3)\n            ((equal? d #\\4) 4)\n            ((equal? d #\\5) 5)\n\
    \            ((equal? d #\\6) 6)\n            ((equal? d #\\7) 7)\n          \
    \  ((equal? d #\\8) 8)\n            ((equal? d #\\9) 9)\n            ((equal?\
    \ d #\\A) 10)\n            ((equal? d #\\B) 11)\n            ((equal? d #\\C)\
    \ 12)\n            ((equal? d #\\D) 13)\n            ((equal? d #\\E) 14)\n  \
    \          ((equal? d #\\F) 15)))\n    (define (sum l a)\n      (if (empty? l)\
    \ a\n          (sum (rest l) (+ (* a 16) (convert-digit (first l))))))\n    (sum\
    \ (reverse (string->list n)) 0))\n  (define (is-prime n)\n    (define (div? a\
    \ b)\n      (if (> b a) false\n          (if (= (modulo a b) 0) true\n       \
    \       (div? a (+ b 1)))))\n    (if (= n 2) true\n        (if (or (= n 0) (=\
    \ n 1)) false\n            (div? n 2))))\n  (define (prime-counter n)\n    (define\
    \ (counter n i)\n      (if (= i 0) 0\n          (if (is-prime n) (+ 1 (counter\
    \ (/ n 16) (- i 1)))\n              (counter (/ n 16) (- i 1)))))\n    (counter\
    \ n (string-length num)))\n  (prime-counter (convert-hex-to-dec num)))\n```\n\n\
    # Problem 1.4.\n\n```racket\n#lang racket\n", "  (cond\n    [(string=? num \"\"\
    ) 0]\n    [(string=? num \"A\") 1]\n    [(string=? num \"B\") 1]\n    [(string=?\
    \ num \"C\") 0]\n    [(string=? num \"D\") 1]\n    [(string=? num \"E\") 0]\n\
    \    [(string=? num \"F\") 0]\n    [(string=? num \"0\") 0]\n    [(string=? num\
    \ \"1\") 0]\n    [(string=? num \"2\") 1]\n    [(string=? num \"3\") 1]\n    [(string=?\
    \ num \"4\") 0]\n    [(string=? num \"5\") 1]\n    [(string=? num \"6\") 0]\n\
    \    [(string=? num \"7\") 1]\n    [(string=? num \"8\") 0]\n    [(string=? num\
    \ \"9\") 0]\n    [else (+ (hex_key (substring num 0 1))\n             (hex_key\
    \ (substring num 1 (string-length num))))]))\n", "  (length\n   (filter\n    (lambda\
    \ (x)\n      (member x '(2 3 5 7 11 13)))\n    (map\n     string->number\n   \
    \  (list->vector\n      (string-split (string-upcase num) \"\"))))))\n", "  (define\
    \ (get-primes)\n    (list 2 3 5 7 11 13 17))\n  (define (char->int char)\n   \
    \ (cond\n      [(char=? char #\\0) 0]\n      [(char=? char #\\1) 1]\n      [(char=?\
    \ char #\\2) 2]\n      [(char=? char #\\3) 3]\n      [(char=? char #\\4) 4]\n\
    \      [(char=? char #\\5) 5]\n      [(char=? char #\\6) 6]\n      [(char=? char\
    \ #\\7) 7]\n      [(char=? char #\\8) 8]\n      [(char=? char #\\9) 9]\n     \
    \ [(char=? char #\\A) 10]\n      [(char=? char #\\B) 11]\n      [(char=? char\
    \ #\\C) 12]\n      [(char=? char #\\D) 13]\n      [(char=? char #\\E) 14]\n  \
    \    [(char=? char #\\F) 15]))\n  (let ([chars (string->list num)])\n    (length\n\
    \     (filter\n      (lambda (x)\n        (member x (get-primes)))\n      (map\
    \ char->int chars)))))", "  (local [(define (hex-digits-to-nums digits)\n    \
    \        (for/list ([c (in-string digits)])\n              (match c\n        \
    \        ['0 0]\n                ['1 1]\n                ['2 2]\n            \
    \    ['3 3]\n                ['4 4]\n                ['5 5]\n                ['6\
    \ 6]\n                ['7 7]\n                ['8 8]\n                ['9 9]\n\
    \                ['A 10]\n                ['B 11]\n                ['C 12]\n \
    \               ['D 13]\n                ['E 14]\n                ['F 15]\n  \
    \              [else (error 'hex-digits-to-nums\n                            \
    \ \"cannot convert digit to number\")])))\n           (define (nums-to-hex-digits\
    \ nums)\n             (for/list ([n (in-list nums)])\n               (match n\n\
    \                 [0 '0]\n                 [1 '1]\n                 [2 '2]\n \
    \                [3 '3]\n                 [4 '4]\n                 [5 '5]\n  \
    \               [6 '6]\n                 [7 '7]\n                 [8 '8]\n   \
    \              [9 '9]\n                 [10 'A]\n                 [11 'B]\n  \
    \               [12 'C]\n                 [13 'D]\n                 [14 'E]\n\
    \                 [15 'F]\n                 [else (error 'nums-to-hex-digits\n\
    \                              \"cannot convert number to digit\")])))\n     \
    \      (define (is-prime? n)\n             (define (is-even? n)\n            \
    \   (or (= n 0) (= n 2)))\n             (define (last-even? n)\n             \
    \  (let ([n (string->number n)])\n                 (is-even? (remainder n 10))))\n\
    \             (if (is-even? n)\n                 false\n                 (or (=\
    \ n 3)\n                     (let loop ([ps '(5 7 9 11 13 15 17 19 21 23)])\n\
    \                       (cond [(null? ps) false]\n                           \
    \  [(= (first ps) n) true]\n                             [(zero? (remainder n\
    \ (first ps))) false]\n                             [else (loop (rest ps))])))))\n",
  "  (cond [(empty? num) 0]\n        [(number? (string->number num)) 0]\n        [else\
    \ (if (member (string->number (substring num 0 1)) '(2 3 5 7 11 13))\n       \
    \           (+ 1 (hex_key (substring num 1)))\n                  (hex_key (substring\
    \ num 1)))]))\n</code>\nThis function only seems to work if there are no zeros\
    \ in the number. How can I fix that so that it works with zeros? I don't understand\
    \ why it works without zeros but not with.\n\n\nA:\n\nThe problem is your first\
    \ <code>cond</code> arm: it will say that the number of primes in a string that\
    \ begins with a <code>0</code> is <code>0</code>, because <code>0</code> is a\
    \ number.\nAlso note that <code>substring</code> is a recursive function too,\
    \ so don't use it in the base case of your recursion, use <code>rest</code> instead:\n\
    <code>(define (hex-key s)\n  (if (empty? s)\n      0\n      (if (number? (string-&gt;number\
    \ (substring s 0 1)))\n          (hex-key (rest s))\n          (if (member (string-&gt;number\
    \ (substring s 0 1)) '(2 3 5 7 11 13))\n              (+ 1 (hex-key (rest s)))\n\
    \              (hex-key (rest s))))))\n</code>\nBut there's a more elegant way\
    \ to solve this problem:\n<code>(define (hex-key s)\n  (cond [(empty? s) 0]\n\
    \        [(not (member (string-&gt;number (substring s 0 1)) '(2 3 5 7 11 13)))\n\
    \         (hex-key (rest s))]\n        [else (+ 1 (hex-key (rest s)))]))\n</code>\n",
  "  (if (not (string? num))\n      (error \"Input must be a string\")\n      (if\
    \ (not (string-empty? num))\n          (if (or (= (char-downcase (string-ref num\
    \ 0)) #\\a)\n                  (= (char-downcase (string-ref num 0)) #\\b)\n \
    \                 (= (char-downcase (string-ref num 0)) #\\d)\n              \
    \    (= (char-downcase (string-ref num 0)) #\\e)\n                  (= (char-downcase\
    \ (string-ref num 0)) #\\f))\n              (+ 1 (hex_key (substring num 1)))\n\
    \              (hex_key (substring num 1)))\n          0)))\n```\n\n``` #lang\
    \ racket", "  (let ((primes '(2 3 5 7 11 13 17)))\n    (letrec ([check-digit (lambda\
    \ (digit)\n                            (let loop ([i 0])\n                   \
    \           (if (= i (length primes))\n                                  #f\n\
    \                                  (if (= (string->number digit 16) (list-ref\
    \ primes i))\n                                      #t\n                     \
    \                 (loop (+ i 1))))))]\n             [count-primes (lambda (digits)\n\
    \                             (if (empty? digits)\n                          \
    \       0\n                                 (if (check-digit (car digits))\n \
    \                                    (+ 1 (count-primes (cdr digits)))\n     \
    \                                (count-primes (cdr digits)))))]\n           \
    \  [digits (string->list num)])\n      (count-primes digits))))", "  (define (hex-to-num\
    \ c)\n    (cond\n      [(char=? c #\\0) 0]\n      [(char=? c #\\1) 1]\n      [(char=?\
    \ c #\\2) 2]\n      [(char=? c #\\3) 3]\n      [(char=? c #\\4) 4]\n      [(char=?\
    \ c #\\5) 5]\n      [(char=? c #\\6) 6]\n      [(char=? c #\\7) 7]\n      [(char=?\
    \ c #\\8) 8]\n      [(char=? c #\\9) 9]\n      [(char=? c #\\A) 10]\n      [(char=?\
    \ c #\\B) 11]\n      [(char=? c #\\C) 12]\n      [(char=? c #\\D) 13]\n      [(char=?\
    \ c #\\E) 14]\n      [(char=? c #\\F) 15]\n      [else (error \"Not a hex digit\"\
    )]))\n  (define (is-prime n)\n    (cond\n      [(< n 2) false]\n      [(= n 2)\
    \ true]\n      [(even? n) false]\n      [else (define (divides? a b) (= (remainder\
    \ b a) 0))\n            (define (find-divisor n test-divisor)\n              (cond\n\
    \                [(> (square test-divisor) n) n]\n                [(divides? test-divisor\
    \ n) test-divisor]\n                [else (find-divisor n (+ test-divisor 1))]))\n\
    \            (= n (find-divisor n 2))]))\n  (define (prime-hex-count str)\n  \
    \  (cond\n      [(empty? str) 0]\n      [(is-prime (hex-to-num (first str))) (+\
    \ 1 (prime-hex-count (rest str)))]\n      [else (prime-hex-count (rest str))]))\n\
    \  (prime-hex-count num))", "  (define primes '(2 3 5 7 11 13))\n  (define hex-to-dec\
    \ (string->number num 16))\n  (define hex-as-string (number->string hex-to-dec\
    \ 16))\n  (define (count-primes n)\n    (cond\n      [(empty? n) 0]\n      [(member\
    \ (first n) primes) (+ 1 (count-primes (rest n)))]\n      [else (count-primes\
    \ (rest n))]))\n  (count-primes (string->list hex-as-string)))\n```\n\n```racket\n\
    #lang racket\n", "  (display \"num = \")\n  (display num)\n  (display \"\\n\"\
    )\n  (define (is_hex? str)\n    (string-contains? str \"0123456789ABCDEF\"))\n\
    \  (define (is_prime? n)\n    (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n\
    \      [(even? n) #f]\n      [else\n       (define (is_divisible? n d)\n     \
    \    (= 0 (modulo n d)))\n       (define (find-divisor n test-divisor)\n     \
    \    (cond\n           [(> (square test-divisor) n) n]\n           [(is_divisible?\
    \ n test-divisor) test-divisor]\n           [else (find-divisor n (+ test-divisor\
    \ 1))]))\n       (= n (find-divisor n 2))]))\n  (define (is_prime_in_hex? n)\n\
    \    (and (is_prime? n) (is_hex? (number->string n))))\n  (define (count_prime_in_hex\
    \ num)\n    (cond\n      [(empty? num) 0]\n      [(is_prime_in_hex? (string->number\
    \ (substring num 0 1))) (+ 1 (count_prime_in_hex (substring num 1)))]\n      [else\
    \ (count_prime_in_hex (substring num 1))]))\n  (count_prime_in_hex num))\n", " \
    \   (if (or (string=? num \"\") (string=? num \"#f\"))\n        '0\n        (if\
    \ (or (string=? (substring num 0 1) \"2\") (string=? (substring num 0 1) \"3\"\
    ) (string=? (substring num 0 1) \"5\") (string=? (substring num 0 1) \"7\") (string=?\
    \ (substring num 0 1) \"B\") (string=? (substring num 0 1) \"D\"))\n         \
    \   (+ (hex_key (substring num 1 (string-length num))) 1)\n            (hex_key\
    \ (substring num 1 (string-length num))))))", "  (define (is-hex? x)\n    (member\
    \ x '(#\\0 #\\1 #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\A #\\B #\\C #\\D #\\\
    E #\\F)))\n  (define (is-prime? x)\n    (cond [(= x 1) false]\n          [(= x\
    \ 2) true]\n          [(even? x) false]\n          [else (for/and ([i (in-range\
    \ 3 (floor (sqrt x)))])\n                       (not (= (modulo x i) 0)))]))\n\
    \  (define (hex-to-int c)\n    (cond [(char=? c #\\0) 0]\n          [(char=? c\
    \ #\\1) 1]\n          [(char=? c #\\2) 2]\n          [(char=? c #\\3) 3]\n   \
    \       [(char=? c #\\4) 4]\n          [(char=? c #\\5) 5]\n          [(char=?\
    \ c #\\6) 6]\n          [(char=? c #\\7) 7]\n          [(char=? c #\\8) 8]\n \
    \         [(char=? c #\\9) 9]\n          [(char=? c #\\A) 10]\n          [(char=?\
    \ c #\\B) 11]\n          [(char=? c #\\C) 12]\n          [(char=? c #\\D) 13]\n\
    \          [(char=? c #\\E) 14]\n          [(char=? c #\\F) 15]))\n  (define (is-prime-hex?\
    \ c)\n    (cond [(or (char=? c #\\B) (char=? c #\\D)) true]\n          [(is-prime?\
    \ (hex-to-int c)) true]\n          [else false]))\n  (for/sum ([c (in-string num)]\
    \ #:when (is-prime-hex? c)) 1))\n", "  (length\n   (filter\n    (lambda (x)\n\
    \      (if (member x '(2 3 5 7 11 13))\n          #t\n          #f))\n    (string->list\
    \ num))))", "  (let ([nums '(\"0\" \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"\
    8\" \"9\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\")]\n        [prime? #f])\n    (if\
    \ (empty? num)\n        0\n        (if (or (equal? (first num) \"2\")\n      \
    \          (equal? (first num) \"3\")\n                (equal? (first num) \"\
    5\")\n                (equal? (first num) \"7\")\n                (equal? (first\
    \ num) \"B\")\n                (equal? (first num) \"D\"))\n            (+ 1 (hex_key\
    \ (rest num)))\n            (hex_key (rest num))))))", "  (define (is_prime? i)\n\
    \    (define (check j)\n      (cond\n        [(> j (/ i 2)) #t]\n        [(= (modulo\
    \ i j) 0) #f]\n        [else (check (+ j 1))]))\n    (check 2))\n  (define (make-primes\
    \ primes)\n    (define (is-prime? i)\n      (define (check j)\n        (cond\n\
    \          [(> j (/ i 2)) #t]\n          [(= (modulo i j) 0) #f]\n          [else\
    \ (check (+ j 1))]))\n      (check 2))\n    (cond\n      [(empty? primes) (list\
    \ 2)]\n      [(is-prime? (car primes)) (cons (car primes) (make-primes (cdr primes)))]\n\
    \      [else (make-primes (cdr primes))]))\n  (define PRIMES (make-primes (range\
    \ 0 255)))\n  (define (hex-to-int hex)\n    (let ([hex-int (string->number hex\
    \ 16)])\n      (cond\n        [(= hex-int 0) 0]\n        [(= hex-int 1) 1]\n \
    \       [(= hex-int 2) 2]\n        [(= hex-int 3) 3]\n        [(= hex-int 4) 4]\n\
    \        [(= hex-int 5) 5]\n        [(= hex-int 6) 6]\n        [(= hex-int 7)\
    \ 7]\n        [(= hex-int 8) 8]\n        [(= hex-int 9) 9]\n        [(= hex-int\
    \ 10) 11]\n        [(= hex-int 11) 11]\n        [(= hex-int 12) 13]\n        [(=\
    \ hex-int 13) 13]\n        [(= hex-int 14) 17]\n        [(= hex-int 15) 17])))\n\
    \  (define (int-to-hex n)\n    (cond\n      [(= n 0) \"0\"]\n      [(= n 1) \"\
    1\"]\n      [(= n 2) \"2\"]\n      [(= n 3) \"3\"]\n      [(= n 4) \"4\"]\n  \
    \    [(= n 5) \"", "  (define (to-decimal num)\n    (cond\n      [(equal? num\
    \ \"A\") 10]\n      [(equal? num \"B\") 11]\n      [(equal? num \"C\") 12]\n \
    \     [(equal? num \"D\") 13]\n      [(equal? num \"E\") 14]\n      [(equal? num\
    \ \"F\") 15]\n      [else (string->number num)]))\n  (letrec ([primes '(2 3 5\
    \ 7 11 13 17)]\n           [acc 0]\n           [loop (lambda (index)\n       \
    \            (cond\n                     [(= index 0) acc]\n                 \
    \    [(member (to-decimal (string-ref num index)) primes) \n                 \
    \     (loop (- index 1))]\n                     [else (loop (- index 1))]))])\n\
    \    (loop (- (string-length num) 1))))\n</code>\n", "  (cond\n    [(string=?\
    \ \"\" num) 0]\n    [(string=? \"2\" num) 1]\n    [(string=? \"3\" num) 1]\n \
    \   [(string=? \"5\" num) 1]\n    [(string=? \"7\" num) 1]\n    [(string=? \"\
    B\" num) 1]\n    [(string=? \"D\" num) 1]\n    [else\n     (+ (hex_key (string-append\
    \ \"\" (string-ref num 0))) (hex_key (substring num 1)))]))", "  (local [(define\
    \ (is-prime? n)\n            (cond [(zero? n) #f]\n                  [(zero? (remainder\
    \ n 2)) #f]\n                  [(define (iter i)\n                     (cond [(>\
    \ i (sqrt n)) #t]\n                           [(zero? (remainder n i)) #f]\n \
    \                          [else (iter (+ i 1))]))\n                   (iter 3)]))\n\
    \          (define (is-hex? hex)\n            (or (and (char=? #\\A hex) (>= hex\
    \ #\\0))\n                (and (>= hex #\\A) (<= hex #\\F))))\n          (define\
    \ (char->num hex)\n            (cond [(char=? #\\A hex) 10]\n                \
    \  [(char=? #\\B hex) 11]\n                  [(char=? #\\C hex) 12]\n        \
    \          [(char=? #\\D hex) 13]\n                  [(char=? #\\E hex) 14]\n\
    \                  [(char=? #\\F hex) 15]\n                  [else (char->integer\
    \ hex)]))\n          (define (count-primes lst)\n            (cond [(empty? lst)\
    \ 0]\n                  [(is-prime? (char->num (car lst))) (+ 1 (count-primes\
    \ (cdr lst)))]\n                  [else (count-primes (cdr lst))]))]\n    (count-primes\
    \ (string->list num))))\n```\n\n### <a name=\"second-task\">First task solution\
    \ using recursion</a>\n\n```racket\n#lang racket\n", "  (define (helper num)\n\
    \    (cond [(empty? num) 0]\n          [(member (car num) '(\"2\" \"3\" \"5\"\
    \ \"7\" \"B\" \"D\"))\n           (+ 1 (helper (cdr num)))]\n          [else (helper\
    \ (cdr num))]))\n  (helper (string->list num)))\n", "  (cond [(empty? num) 0]\n\
    \        [(hex-prime? (first num)) (+ 1 (hex_key (rest num)))]\n        [else\
    \ (hex_key (rest num))]))\n", "  (apply + (map (lambda (x)\n                 \
    \ (if (or (= x #\\2) (= x #\\3) (= x #\\5) (= x #\\7) (= x #\\B) (= x #\\D))\n\
    \                      1\n                      0))\n                (string->list\
    \ num))))\n", "  (if (string=? num \"\")\n      0\n      (if (or (string=? (substring\
    \ num 0 1) \"2\")\n              (string=? (substring num 0 1) \"3\")\n      \
    \        (string=? (substring num 0 1) \"5\")\n              (string=? (substring\
    \ num 0 1) \"7\")\n              (string=? (substring num 0 1) \"B\")\n      \
    \        (string=? (substring num 0 1) \"D\"))\n          (+ 1 (hex_key (substring\
    \ num 1 (string-length num))))\n          (hex_key (substring num 1 (string-length\
    \ num))))))", "  (if (equal? (length num) 0)\n      0\n      (if (or (equal? (string-&gt;number\
    \ (substring num 0 1) 16) 2)\n              (equal? (string-&gt;number (substring\
    \ num 0 1) 16) 3)\n              (equal? (string-&gt;number (substring num 0 1)\
    \ 16) 5)\n              (equal? (string-&gt;number (substring num 0 1) 16) 7)\n\
    \              (equal? (string-&gt;number (substring num 0 1) 16) 11)\n      \
    \        (equal? (string-&gt;number (substring num 0 1) 16) 13))\n          (+\
    \ 1 (hex_key (substring num 1 (length num))))\n          (hex_key (substring num\
    \ 1 (length num))))))\n</code>\n", "  (define (hex-char->decimal-number c)\n \
    \   (cond\n      [(char=? c #\\0) 0]\n      [(char=? c #\\1) 1]\n      [(char=?\
    \ c #\\2) 2]\n      [(char=? c #\\3) 3]\n      [(char=? c #\\4) 4]\n      [(char=?\
    \ c #\\5) 5]\n      [(char=? c #\\6) 6]\n      [(char=? c #\\7) 7]\n      [(char=?\
    \ c #\\8) 8]\n      [(char=? c #\\9) 9]\n      [(char=? c #\\A) 10]\n      [(char=?\
    \ c #\\B) 11]\n      [(char=? c #\\C) 12]\n      [(char=? c #\\D) 13]\n      [(char=?\
    \ c #\\E) 14]\n      [(char=? c #\\F) 15]\n      [(char=? c #\\G) 16]\n      [(char=?\
    \ c #\\H) 17]\n      [(char=? c #\\I) 18]\n      [(char=? c #\\J) 19]\n      [(char=?\
    \ c #\\K) 20]\n      [(char=? c #\\L) 21]\n      [(char=? c #\\M) 22]\n      [(char=?\
    \ c #\\N) 23]\n      [(char=? c #\\O) 24]\n      [(char=? c #\\P) 25]\n      [(char=?\
    \ c #\\Q) 26]\n      [(char=? c #\\R) 27]\n      [(char=? c #\\S) 28]\n      [(char=?\
    \ c #\\T) 29]\n      [(char=? c #\\U) 30]\n      [(char=? c #\\V) 31]\n      [(char=?\
    \ c #\\W) 32]\n      [(char=? c #\\X) 33]\n      [(char=? c #\\Y) 34]\n      [(char=?\
    \ c #\\Z) 35]))\n  (define (decimal-number->char n)\n    (cond\n      [(= n 0)",
  "  (cond ((null? num) 0)\n        ((hex-prime? (first num)) (+ 1 (hex_key (rest\
    \ num))))\n        (else (hex_key (rest num)))))\n", "  (cond\n    [(empty? num)\
    \ 0]\n    [(char-upper-case? (first num))\n     (if (or (char=? (first num) #\\\
    2)\n             (char=? (first num) #\\3)\n             (char=? (first num) #\\\
    5)\n             (char=? (first num) #\\7)\n             (char=? (first num) #\\\
    B)\n             (char=? (first num) #\\D))\n         (+ 1 (hex_key (rest num)))\n\
    \         (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (let\
    \ loop ([x (string->number num 16)]\n             [hex '(0 1 2 3 4 5 6 7 8 9 10\
    \ 11 12 13 14 15)]\n             [prime '(2 3 5 7 11 13)]\n             [cnt 0])\n\
    \    (if (zero? x) cnt\n        (let ([div (remainder x 16)])\n          (loop\
    \ (quotient x 16)\n                hex\n                prime\n              \
    \  (if (member div prime) (+ cnt 1) cnt))))))\n", "  (define (is_prime? n)\n \
    \   (define (iter i)\n      (cond ((= i n) #t)\n            ((= (modulo n i) 0)\
    \ #f)\n            (else (iter (+ i 1)))))\n    (iter 2))\n  (define (hex_num->dec\
    \ n)\n    (cond ((number? n) n)\n          ((string=? (string-upcase n) \"A\"\
    ) 10)\n          ((string=? (string-upcase n) \"B\") 11)\n          ((string=?\
    \ (string-upcase n) \"C\") 12)\n          ((string=? (string-upcase n) \"D\")\
    \ 13)\n          ((string=? (string-upcase n) \"E\") 14)\n          ((string=?\
    \ (string-upcase n) \"F\") 15)\n          (else (string->number n))))\n  (define\
    \ (count_primes str)\n    (define (iter str count)\n      (cond ((null? str) count)\n\
    \            ((is_prime? (hex_num->dec (string-ref str 0))) (iter (string-drop\
    \ str 1) (+ count 1)))\n            (else (iter (string-drop str 1) count))))\n\
    \    (iter str 0))\n  (count_primes num))\n", "  (length\n   (filter\n    (lambda\
    \ (x) (member x '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D)))\n    (string->list num))))\n",
  "  (local [(define (digits->hexdigits . digits)\n            (map (\u03BB (digit)\
    \ (format \"~x\" digit)) digits))\n         (define (is_prime? . n)\n        \
    \   (cond [(<= n 2) #f]\n                 [(= n 3) #t]\n                 [(= (remainder\
    \ n 2) 0) #f]\n                 [(= (remainder n 3) 0) #f]\n                 [(is_prime?\
    \ (+ 1 (quotient n 6)) (+ 5 (quotient n 6))) #t]\n                 [else #f]))\n\
    \         (define (get-hex-digits num)\n           (string->list num))\n     \
    \    (define (count-prime-digits num)\n           (count (\u03BB (x) (is_prime?\
    \ (string->number x 16))) (get-hex-digits num)))\n         ]\n    (count-prime-digits\
    \ num)))\n```\n\n```racket\n#lang racket", "  ;; Your code here\n  (cond ((equal?\
    \ num \"\") 0)\n        ((number? (string->number (string-append \"#x\" num) 16))\
    \ 0)\n        (else\n         (letrec ([prime (lambda (n)\n                  \
    \         (cond ((= n 1) #f)\n                                 ((= n 2) #t)\n\
    \                                 ((= (remainder n 2) 0) #f)\n               \
    \                  (else (or (for/or ([i (in-range 3 (+ 2 (sqrt n)) 2)])\n   \
    \                                                (prime i))\n                \
    \                            #t))))])\n               [new-prime (string->number\
    \ (string-append \"#x\" (substring num 0 1)) 16)])\n           (if (prime new-prime)\n\
    \               (+ 1 (hex_key (substring num 1)))\n               (hex_key (substring\
    \ num 1)))))))", "  (define (hex-digit? x)\n    (if (string=? x \"A\") #t\n  \
    \      (if (string=? x \"B\") #t\n            (if (string=? x \"C\") #t\n    \
    \            (if (string=? x \"D\") #t\n                    (if (string=? x \"\
    E\") #t\n                        (if (string=? x \"F\") #t\n                 \
    \           (char-numeric? (string->char x)))))))))\n  (define (prime? x)\n  \
    \  (if (= x 2) #t\n        (if (= x 3) #t\n            (if (= x 5) #t\n      \
    \          (if (= x 7) #t\n                    (if (= x 11) #t\n             \
    \           (if (= x 13) #t\n                            #f)))))))\n  (define\
    \ (hex-prime? x)\n    (if (hex-digit? x)\n        (prime? (string->number x 16))\n\
    \        #f))\n  (define (helper num)\n    (if (string-empty? num) 0\n       \
    \ (if (hex-prime? (substring num 0 1))\n            (+ 1 (helper (substring num\
    \ 1 (string-length num))))\n            (helper (substring num 1 (string-length\
    \ num))))))\n  (helper num))", "  (define (hex_digit? d)\n    (or (integer? d)\n\
    \        (regexp-match? #rx\"^[0-9A-F]+$\" d)))\n  (define (hex_digit->dec d)\n\
    \    (cond ((integer? d) d)\n          ((string=? d \"A\") 10)\n          ((string=?\
    \ d \"B\") 11)\n          ((string=? d \"C\") 12)\n          ((string=? d \"D\"\
    ) 13)\n          ((string=? d \"E\") 14)\n          ((string=? d \"F\") 15)))\n\
    \  (define (is-prime? n)\n    (let loop ([n n] [i 2])\n      (cond [(or (zero?\
    \ n) (negative? n)) #f]\n            [(= n 1) #f]\n            [(= n i) #t]\n\
    \            [(zero? (modulo n i)) #f]\n            [else (loop n (+ i 1))])))\n\
    \  (define (counter ns)\n    (cond [(null? ns) 0]\n          [(and (hex_digit?\
    \ (car ns))\n                (is-prime? (hex_digit->dec (car ns)))) (+ 1 (counter\
    \ (cdr ns)))]\n          [else (counter (cdr ns))]))\n  (counter (string->list\
    \ num)))\n", "  (if (empty? num)\n      0\n      (if (member (string->symbol (substring\
    \ num 0 1)) '(2 3 5 7 11 13))\n          (+ 1 (hex_key (substring num 1)))\n \
    \         (hex_key (substring num 1)))))\n", "  (define (is-prime? x)\n    (define\
    \ (loop acc x)\n      (if (= acc x)\n          #t\n          (if (= (modulo x\
    \ acc) 0)\n              #f\n              (loop (+ acc 1) x))))\n    (if (< x\
    \ 2)\n        #f\n        (loop 2 x)))\n  (define (hex2dec x)\n    (define (hexdigit2dec\
    \ x)\n      (cond ((= x #\\0) 0)\n            ((= x #\\1) 1)\n            ((=\
    \ x #\\2) 2)\n            ((= x #\\3) 3)\n            ((= x #\\4) 4)\n       \
    \     ((= x #\\5) 5)\n            ((= x #\\6) 6)\n            ((= x #\\7) 7)\n\
    \            ((= x #\\8) 8)\n            ((= x #\\9) 9)\n            ((= x #\\\
    A) 10)\n            ((= x #\\B) 11)\n            ((= x #\\C) 12)\n           \
    \ ((= x #\\D) 13)\n            ((= x #\\E) 14)\n            ((= x #\\F) 15)))\n\
    \    (foldl (lambda (x acc) (+ (* acc 16) (hexdigit2dec x))) 0 x))\n  (define\
    \ (count-primes lst)\n    (foldl (lambda (x acc) (if (is-prime? x) (+ acc 1) acc))\
    \ 0 lst))\n  (count-primes (map hex2dec num)))\n", "  (if (zero? (length num))\n\
    \      0\n      (if (or (= (string-ref num 0) #\\2)\n              (= (string-ref\
    \ num 0) #\\3)\n              (= (string-ref num 0) #\\5)\n              (= (string-ref\
    \ num 0) #\\7)\n              (= (string-ref num 0) #\\B)\n              (= (string-ref\
    \ num 0) #\\D))\n          (+ 1 (hex_key (substring num 1 (length num))))\n  \
    \        (hex_key (substring num 1 (length num))))))\n", "  (length\n   (filter\n\
    \    (lambda (x)\n      (cond ((equal? x 2) (is_prime x))\n            ((equal?\
    \ x 3) (is_prime x))\n            ((equal? x 5) (is_prime x))\n            ((equal?\
    \ x 7) (is_prime x))\n            ((equal? x 11) (is_prime x))\n            ((equal?\
    \ x 13) (is_prime x))\n            ((equal? x 0) (is_prime x))\n            (else\
    \ #f)))\n    (char->integer\n     (string->list num)))))\n", "  (define (helper\
    \ num acc)\n    (if (= num 0) acc\n        (cond ((member (remainder num 16) '(2\
    \ 3 5 7 11 13)) \n               (helper (floor (/ num 16)) (+ acc 1)))\n    \
    \          (else (helper (floor (/ num 16)) acc)))))\n  (helper (string->number\
    \ num 16) 0))\n", "  (if (string-null? num)\n      0\n      (if (or (char=? (string-ref\
    \ num 0) #\\2)\n              (char=? (string-ref num 0) #\\3)\n             \
    \ (char=? (string-ref num 0) #\\5)\n              (char=? (string-ref num 0) #\\\
    7)\n              (char=? (string-ref num 0) #\\B)\n              (char=? (string-ref\
    \ num 0) #\\D))\n          (+ 1 (hex_key (substring num 1)))\n          (hex_key\
    \ (substring num 1)))))\n", "  (cond\n    [(empty? num) 0]\n    [(char-alphabetic?\
    \ (string-ref num 0))\n     (if (or (equal? (string-ref num 0) #\\B)\n       \
    \      (equal? (string-ref num 0) #\\D))\n         (+ 1 (hex_key (substring num\
    \ 1)))\n         (hex_key (substring num 1)))]\n    [(char-numeric? (string-ref\
    \ num 0))\n     (if (or (equal? (string-ref num 0) #\\2)\n             (equal?\
    \ (string-ref num 0) #\\3)\n             (equal? (string-ref num 0) #\\5)\n  \
    \           (equal? (string-ref num 0) #\\7))\n         (+ 1 (hex_key (substring\
    \ num 1)))\n         (hex_key (substring num 1)))]\n    [else\n     0]))"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
