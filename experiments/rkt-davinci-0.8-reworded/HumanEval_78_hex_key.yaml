name: HumanEval_78_hex_key
language: rkt
prompt: "#lang racket\n\n;; You have been tasked to write a function that receives\
  \ \n;; a hexadecimal number as a string and counts the number of hexadecimal \n\
  ;; digits that are primes (prime number, or a prime, is a natural number \n;; greater\
  \ than 1 that is not a product of two smaller natural numbers).\n;; Hexadecimal\
  \ digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n;; Prime numbers are\
  \ 2, 3, 5, 7, 11, 13, 17,...\n;; So you have to determine a number of the following\
  \ digits: 2, 3, 5, 7, \n;; B (=decimal 11), D (=decimal 13).\n;; Note: you may assume\
  \ the input is always correct or empty string, \n;; and symbols A,B,C,D,E,F are\
  \ always uppercase.\n;; Examples:\n;; >>> (hex_key \"AB\")\n;; 1\n;; >>> (hex_key\
  \ \"1077E\")\n;; 2\n;; >>> (hex_key \"ABED1A33\")\n;; 4\n;; >>> (hex_key \"123456789ABCDEF0\"\
  )\n;; 6\n;; >>> (hex_key \"2020\")\n;; 2\n(define (hex_key num)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate hex_key))\n\
  \    (check-equal? (candidate \"AB\") 1)\n    (check-equal? (candidate \"1077E\"\
  ) 2)\n    (check-equal? (candidate \"ABED1A33\") 4)\n    (check-equal? (candidate\
  \ \"2020\") 2)\n    (check-equal? (candidate \"123456789ABCDEF0\") 6)\n    (check-equal?\
  \ (candidate \"112233445566778899AABBCCDDEEFF00\") 12)\n))\n\n(test-humaneval)"
completions: ["  (define (hex_char_to_int c)\n    (cond ((= c #\\0) 0)\n         \
    \ ((= c #\\1) 1)\n          ((= c #\\2) 2)\n          ((= c #\\3) 3)\n       \
    \   ((= c #\\4) 4)\n          ((= c #\\5) 5)\n          ((= c #\\6) 6)\n     \
    \     ((= c #\\7) 7)\n          ((= c #\\8) 8)\n          ((= c #\\9) 9)\n   \
    \       ((= c #\\A) 10)\n          ((= c #\\B) 11)\n          ((= c #\\C) 12)\n\
    \          ((= c #\\D) 13)\n          ((= c #\\E) 14)\n          ((= c #\\F) 15)))\n\
    \  (define (char-list-to-int lst)\n    (if (null? lst)\n        0\n        (+\
    \ (* (hex_char_to_int (car lst)) (expt 16 (- (length lst) 1)))\n           (char-list-to-int\
    \ (cdr lst)))))\n  (define (is-prime n)\n    (cond ((= n 1) false)\n         \
    \ ((= n 2) true)\n          ((> n 2)\n           (let loop ((i 2))\n         \
    \    (cond ((= i n) true)\n                   ((= (modulo n i) 0) false)\n   \
    \                (else (loop (+ i 1))))))))\n  (define (all-digits-prime lst)\n\
    \    (if (null? lst)\n        0\n        (+ (if (is-prime (hex_char_to_int (car\
    \ lst))) 1 0)\n           (all-digits-prime (cdr lst)))))\n  (all-digits-prime\
    \ (string->list num)))\n", "  (let* \n      ([lst (string->list num)]\n      \
    \ [count 0])\n    (for ([x lst])\n      (define a (char->integer x))\n      (and\
    \ \n       (<= a 70)\n       (>= a 65)\n       (set! a (+ a 10)))\n      (and\n\
    \       (member a (list 2 3 5 7 11 13))\n       (set! count (+ count 1))))\n \
    \   count))", "  (define (is-prime num)\n    (if (= num 1) #f\n        (if (=\
    \ num 2) #t\n            (define (loop i)\n              (if (= i (/ num 2)) #t\n\
    \                  (if (= (modulo num i) 0) #f\n                      (loop (+\
    \ i 1)))))\n            (loop 2))))\n  (define (loop num sum)\n    (if (not (string?\
    \ num)) sum\n        (if (and (or (char=? (string-ref num 0) #\\2)\n         \
    \           (char=? (string-ref num 0) #\\3)\n                    (char=? (string-ref\
    \ num 0) #\\5)\n                    (char=? (string-ref num 0) #\\7)\n       \
    \             (char=? (string-ref num 0) #\\B)\n                    (char=? (string-ref\
    \ num 0) #\\D))\n                (is-prime (string->number (string (string-ref\
    \ num 0)) 16)))\n            (loop (substring num 1) (+ sum 1))\n            (loop\
    \ (substring num 1) sum))))\n  (loop num 0))\n</code>\n", "  (define (primes-in-number\
    \ number)\n    (cond [(> number 0)\n           (cond [(hex_prime? number)\n  \
    \                (+ 1 (primes-in-number (quotient number 16)))]\n            \
    \     [else\n                  (primes-in-number (quotient number 16))])]\n  \
    \        [else\n           0]))\n  (define (hex_prime? number)\n    (member number\
    \ '(2 3 5 7 11 13)))\n  (define (hex-to-decimal number)\n    (cond [(empty? number)\n\
    \           0]\n          [else\n           (+ (* (first number) (expt 16 (- (string-length\
    \ number) 1)))\n              (hex-to-decimal (rest number)))]))\n  (primes-in-number\
    \ (hex-to-decimal num)))", "  (if (string-null? num)\n      0\n      (if (string-member\
    \ (string-ref num 0) \"2357BD\")\n          (+ 1 (hex_key (string-drop num 1)))\n\
    \          (hex_key (string-drop num 1)))))\n", "  (length (list-remove (list->set\
    \ (string->list num)) '(#\\A #\\B #\\C #\\D #\\E #\\F #\\1 #\\3 #\\4 #\\6 #\\\
    8 #\\9 #\\0))))\n", "  (define (is-prime num)\n    (define (inner num cur)\n \
    \     (if (= num cur)\n        #t\n        (if (= 0 (modulo num cur))\n      \
    \    #f\n          (inner num (+ cur 1)))))\n    (inner num 2))\n  (define (is-prime-hex\
    \ num)\n    (if (or (= num #\\2) (= num #\\3) (= num #\\5) (= num #\\7) (= num\
    \ #\\B) (= num #\\D))\n      #t\n      #f))\n  (define (inner num cur cnt)\n \
    \   (if (= cur (string-length num))\n      cnt\n      (if (and (is-prime-hex (string-ref\
    \ num cur))\n            (is-prime (string->number (substring num cur (+ cur 1))\
    \ 16)))\n        (inner num (+ cur 1) (+ cnt 1))\n        (inner num (+ cur 1)\
    \ cnt))))\n  (inner num 0 0))\n", "  (define (prime n)\n    (cond\n      [(= n\
    \ 1) #f]\n      [(= n 2) #t]\n      [(= n 3) #t]\n      [(even? n) #f]\n     \
    \ [(prime-rec n (/ n 2)) #f]\n      [else #t]))\n  (define (prime-rec n m)\n \
    \   (cond\n      [(= m 1) #t]\n      [(even? m) (prime-rec n (/ m 2))]\n     \
    \ [(zero? (modulo n m)) #f]\n      [else (prime-rec n (- m 1))]))\n  (cond\n \
    \   [(string=? num \"\") 0]\n    [(string=? num \"A\") 1]\n    [(string=? num\
    \ \"B\") 1]\n    [(string=? num \"D\") 1]\n    [(string=? num \"E\") 1]\n    [(string=?\
    \ num \"F\") 1]\n    [(prime (string->number num 16)) (+ 1 (hex_key (substring\
    \ num 1)))]\n    [else (hex_key (substring num 1))]))", "  (length (filter (\u03BB\
    \ (x) (list-member (list #\\2 #\\3 #\\5 #\\7 #\\B #\\D) x)) (string->list num))))\n",
  "  (let ([count 0])\n    (for ([c (in-string num)])\n      (cond [(member c '(#\\\
    2 #\\3 #\\5 #\\7 #\\B #\\D))\n             (set! count (+ count 1))]))\n    count))\n",
  "  (define (get-digit-values num)\n    (cond\n      [(empty? num) empty]\n     \
    \ [(equal? (first num) #\\0) (cons 0 (get-digit-values (rest num)))]\n      [(equal?\
    \ (first num) #\\1) (cons 1 (get-digit-values (rest num)))]\n      [(equal? (first\
    \ num) #\\2) (cons 2 (get-digit-values (rest num)))]\n      [(equal? (first num)\
    \ #\\3) (cons 3 (get-digit-values (rest num)))]\n      [(equal? (first num) #\\\
    4) (cons 4 (get-digit-values (rest num)))]\n      [(equal? (first num) #\\5) (cons\
    \ 5 (get-digit-values (rest num)))]\n      [(equal? (first num) #\\6) (cons 6\
    \ (get-digit-values (rest num)))]\n      [(equal? (first num) #\\7) (cons 7 (get-digit-values\
    \ (rest num)))]\n      [(equal? (first num) #\\8) (cons 8 (get-digit-values (rest\
    \ num)))]\n      [(equal? (first num) #\\9) (cons 9 (get-digit-values (rest num)))]\n\
    \      [(equal? (first num) #\\A) (cons 10 (get-digit-values (rest num)))]\n \
    \     [(equal? (first num) #\\B) (cons 11 (get-digit-values (rest num)))]\n  \
    \    [(equal? (first num) #\\C) (cons 12 (get-digit-values (rest num)))]\n   \
    \   [(equal? (first num) #\\D) (cons 13 (get-digit-values (rest num)))]\n    \
    \  [(equal? (first num) #\\E) (cons 14 (get-digit-values (rest num)))]\n     \
    \ [(equal? (first num) #\\F) (cons 15 (get-digit-values (rest num)))]))\n  (define\
    \ (primes-in-list num-list)\n    (define (is-prime? num)\n      (cond\n      \
    \  [(= num 2) true]\n        [(= num 3) true]\n        [(= num 5", "  (cond\n\
    \    ((eq? num \"\") 0)\n    ((char-numeric? (string-ref num 0))\n     (hex_key\
    \ (substring num 1)))\n    ((eq? (string-ref num 0) #\\A)\n     (+ 1 (hex_key\
    \ (substring num 1))))\n    ((eq? (string-ref num 0) #\\B)\n     (+ 1 (hex_key\
    \ (substring num 1))))\n    ((eq? (string-ref num 0) #\\C)\n     (hex_key (substring\
    \ num 1)))\n    ((eq? (string-ref num 0) #\\D)\n     (+ 1 (hex_key (substring\
    \ num 1))))\n    ((eq? (string-ref num 0) #\\E)\n     (hex_key (substring num\
    \ 1)))\n    ((eq? (string-ref num 0) #\\F)\n     (hex_key (substring num 1)))\n\
    \    (else (hex_key (substring num 1)))))\n", "  (count-prime-hex-digits num))\n",
  "  (let loop ([num (string->list num)]\n             [acc 0])\n    (cond [(empty?\
    \ num)\n           acc]\n          [(or (member (car num) '(#\\2 #\\3 #\\5 #\\\
    7 #\\B #\\D))\n               (member (car num) '(#\\2 #\\3 #\\5 #\\7 #\\b #\\\
    d)))\n           (loop (cdr num)\n                 (+ acc 1))]\n          [else\n\
    \           (loop (cdr num)\n                 acc)])))\n", "  (cond\n    [(empty?\
    \ num) 0]\n    [(char-upcase? (string-ref num 0))\n     (let* ([first-digit (string-ref\
    \ num 0)]\n            [remaining-digits (substring num 1)])\n       (cond\n \
    \        [(or (= first-digit #\\2) (= first-digit #\\3)\n              (= first-digit\
    \ #\\5) (= first-digit #\\7)\n              (= first-digit #\\B) (= first-digit\
    \ #\\D))\n          (+ 1 (hex_key remaining-digits))]\n         [else (hex_key\
    \ remaining-digits)]))]\n    [else (hex_key (substring num 1))]))\n", "  (cond\
    \ [(empty? num) 0]\n        [(equal? (list-ref num 0) #\\2) (+ 1 (hex_key (substring\
    \ num 1)))]\n        [(equal? (list-ref num 0) #\\3) (+ 1 (hex_key (substring\
    \ num 1)))]\n        [(equal? (list-ref num 0) #\\5) (+ 1 (hex_key (substring\
    \ num 1)))]\n        [(equal? (list-ref num 0) #\\7) (+ 1 (hex_key (substring\
    \ num 1)))]\n        [(equal? (list-ref num 0) #\\B) (+ 1 (hex_key (substring\
    \ num 1)))]\n        [(equal? (list-ref num 0) #\\D) (+ 1 (hex_key (substring\
    \ num 1)))]\n        [else (hex_key (substring num 1))]))", "  (define primes\
    \ '(2 3 5 7 11 13))\n  (define (is-in-primes x)\n    (cond ((null? primes) #f)\n\
    \          ((equal? x (car primes)) #t)\n          (else (is-in-primes (cdr primes)))))\n\
    \  (define (hex-key-iter n sum)\n    (cond ((null? n) sum)\n          ((is-in-primes\
    \ (string->number (string (car n)) 16))\n           (hex-key-iter (cdr n) (+ sum\
    \ 1)))\n          (else (hex-key-iter (cdr n) sum))))\n  (hex-key-iter (string->list\
    \ num) 0))", "  (define (is-prime n)\n    (cond\n      [(= n 2) #t]\n      [(=\
    \ n 3) #t]\n      [(= n 5) #t]\n      [(= n 7) #t]\n      [(= n 11) #t]\n    \
    \  [(= n 13) #t]\n      [(= n 17) #t]\n      [(= n 19) #t]\n      [(= n 23) #t]\n\
    \      [(= n 29) #t]\n      [(= n 31) #t]\n      [(= n 37) #t]\n      [(= n 41)\
    \ #t]\n      [(= n 43) #t]\n      [(= n 47) #t]\n      [(= n 53) #t]\n      [(=\
    \ n 59) #t]\n      [(= n 61) #t]\n      [(= n 67) #t]\n      [(= n 71) #t]\n \
    \     [(= n 73) #t]\n      [(= n 79) #t]\n      [(= n 83) #t]\n      [(= n 89)\
    \ #t]\n      [(= n 97) #t]\n      [(or (= n 1)\n           (and (&gt; n 3) (even?\
    \ n))\n           (and (&gt; n 5) (or (divides? 5 n) (divides? 7 n)))\n      \
    \     (and (&gt; n 7) (or (divides? 7 n) (divides? 11 n)))\n           (and (&gt;\
    \ n 11) (or (divides? 11 n) (divides? 13 n)))\n           (and (&gt; n 13) (or\
    \ (divides? 13 n) (divides? 17 n)))\n           (and (&gt; n 17) (or (divides?\
    \ 17 n) (divides? 19 n)))\n           (and (&gt; n 19) (or (divides? 19 n) (divides?\
    \ 23 n)))\n           (and (&gt; n 23) (or (divides? 23 n) (divides? 29 n)))\n\
    \           (and (&gt; n 29) (or (divides? 29 n) (divides? 31 n)))\n         \
    \  (and (&gt; n 31) (or (divides? 31", "  (define (is-prime n)\n    (cond\n  \
    \    [(= n 1) #f]\n      [(= n 2) #t]\n      [(= n 3) #t]\n      [(= n 5) #t]\n\
    \      [(= n 7) #t]\n      [(= n 11) #t]\n      [(= n 13) #t]\n      [else #f]))\n\
    \  (define (hex-digit-to-decimal ch)\n    (cond\n      [(string=? ch \"0\") 0]\n\
    \      [(string=? ch \"1\") 1]\n      [(string=? ch \"2\") 2]\n      [(string=?\
    \ ch \"3\") 3]\n      [(string=? ch \"4\") 4]\n      [(string=? ch \"5\") 5]\n\
    \      [(string=? ch \"6\") 6]\n      [(string=? ch \"7\") 7]\n      [(string=?\
    \ ch \"8\") 8]\n      [(string=? ch \"9\") 9]\n      [(string=? ch \"A\") 10]\n\
    \      [(string=? ch \"B\") 11]\n      [(string=? ch \"C\") 12]\n      [(string=?\
    \ ch \"D\") 13]\n      [(string=? ch \"E\") 14]\n      [(string=? ch \"F\") 15]))\n\
    \  (define (is-prime-hex-digit ch)\n    (is-prime (hex-digit-to-decimal ch)))\n\
    \  (define (iter lst count)\n    (cond\n      [(empty? lst) count]\n      [(is-prime-hex-digit\
    \ (first lst)) (iter (rest lst) (+ count 1))]\n      [else (iter (rest lst) count)]))\n\
    \  (iter (string->list num) 0))\n", "  (length (filter (lambda (x) \n        \
    \            (and (> x 1)\n                         (and (not (zero? (modulo x\
    \ 2)))\n                              (and (not (zero? (modulo x 3)))\n      \
    \                             (not (let loop ((x (- x 1)))\n                 \
    \                         (if (< x 5)\n                                      \
    \        #f\n                                              (if (or (zero? (modulo\
    \ x 5))\n                                                      (zero? (modulo\
    \ x 7)))\n                                                  #t\n             \
    \                                     (loop (- x 1))))))))))\n               \
    \   (map char->integer (string->list num)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
