name: HumanEval_91_is_bored
language: rkt
prompt: "#lang racket\n\n;; You'll be given a string of words, and your task is to\
  \ count the number\n;; of boredoms. A boredom is a sentence that starts with the\
  \ word \"I\".\n;; Sentences are delimited by '.', '?' or '!'.\n;; For example:\n\
  ;; >>> (is_bored \"Hello world\")\n;; 0\n;; >>> (is_bored \"The sky is blue. The\
  \ sun is shining. I love this weather\")\n;; 1\n(define (is_bored S)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_bored))\n\
  \    (check-equal? (candidate \"Hello world\") 0)\n    (check-equal? (candidate\
  \ \"Is the sky blue?\") 0)\n    (check-equal? (candidate \"I love It !\") 1)\n \
  \   (check-equal? (candidate \"bIt\") 0)\n    (check-equal? (candidate \"I feel\
  \ good today. I will be productive. will kill It\") 2)\n    (check-equal? (candidate\
  \ \"You and I are going for a walk\") 0)\n))\n\n(test-humaneval)"
completions: ["  (string-length (regexp-match-positions #rx\"I \" S)))\n", "  (cond\
    \ [(string=? S \"\") 0]\n        [(string=? (substring S 0 1) \"I\") (+ 1 (is_bored\
    \ (substring S 1)))]\n        [else (is_bored (substring S 1))]))\n", "  (length\
    \ (filter (lambda (l) (string=? (car l) \"I\"))\n                  (map string-split\n\
    \                       (regexp-split #rx\"\\.|\\?|\\!\" S)))))\n", "  (let* ((words\
    \ (string-split S))\n         (boredom-count 0))\n    (for ([word words])\n  \
    \    (when (string=? word \"I\")\n        (set! boredom-count (+ boredom-count\
    \ 1))))\n    boredom-count))\n```\n\nI am not sure if I should include the above\
    \ in my language benchmarks. For\nexample, the Racket implementation is not pure,\
    \ while the Python implementation\nis. So it makes comparing them, not a good\
    \ comparison.\n\n## Language tests\n\nThe tests are actually run against a test\
    \ suite, which is a small script, the\nonly thing it does is it measures the time\
    \ it takes the language to perform the\ntests.\n\nI ran the tests on the following\
    \ computers:\n\n1. A desktop with a AMD Ryzen 5 1400 CPU, a Radeon RX 580, and\
    \ a NVMe SSD.\n2. A laptop with a Intel Core i7-8550U CPU, a Intel UHD Graphics\
    \ 620, and a NVMe SSD.\n\nTo run the tests, I've made a small shell script, which\
    \ is just a tiny wrapper\naround the language tests, which I can just run on the\
    \ computer I want to test\nagainst. It looks like this:\n\n```sh\n#!/bin/sh\n\n\
    # This script runs the test suite for a specific language. It is just a\n# wrapper\
    \ around the language test, so we can run it from the command line.\n\nLANGUAGE=\"\
    $1\"\n\ncase \"$LANGUAGE\" in\n  \"C\")\n    ;; clang-6.0 -std=c99 -O3 -g\n  \
    \  COMPILER=\"clang-6.0\"\n    ;; -std=c99 -O3 -g\n    COMPILE_FLAGS=\"-std=c99\
    \ -O3 -g\"\n    ;; ./test\n    EXECUTABLE=\"./test\"\n    ;; N/A\n    EXECUTE_FLAGS=\"\
    \"\n    ;; ./test\n    TEST_SUITE=\"./test\"\n    ;; N/A\n    TEST_SUITE_FLAGS=\"\
    \"\n    ;; N/A\n    CLEAN_COMMAND=\"\"\n    ;; N/A\n    REBUILD_COMMAND=\"\"\n\
    \    ;; N/A\n    REBUILD", "  (count \"^I\" S))\n", "  (regexp-match #rx\"I\"\
    \ S))\n", "  (count \"^I\" S))\n", "  ;; helper function to count the number of\
    \ boredoms given a list of words\n  (define (count n ls)\n    (cond\n      [(empty?\
    \ ls) n]\n      [(equal? (first ls) \"I\") (count (+ n 1) (rest ls))]\n      [else\
    \ (count n (rest ls))]))\n  ;; helper function to split string into a list of\
    \ words\n  (define (split-sentence str)\n    (let ([sentence-ends [\"] . \"] [\"\
    ] ? \"] [\"] ! \"]])\n      (define (iter str ls)\n        (if (empty? str) ls\n\
    \          (if (member (substring str 0 3) sentence-ends)\n              (cons\
    \ (substring str 0 (- (string-length str) 3))\n                    (iter (substring\
    \ str (- (string-length str) 3)) ls))\n              (iter (substring str 1) (cons\
    \ (substring str 0 1) ls)))))\n      (iter str '())))\n  (count 0 (split-sentence\
    \ S)))\n```\n\n## Tests\n\n```Racket\n#lang racket\n", "  (number->string\n  \
    \ (string-count S\n                 #rx\"\\nI\"\n                 (string-length\
    \ S))))\n", "  (cond [(equal? S \"\") 0]\n        [(and (string=? (string-take\
    \ S 1) \"I\")\n              (or (string=? (string-take S 2) \"I'm\")\n      \
    \            (string=? (string-take S 2) \"Is\")\n                  (string=?\
    \ (string-take S 2) \"It\")\n                  (string=? (string-take S 2) \"\
    I \")\n                  (string=? (string-take S 2) \"If\")\n               \
    \   (string=? (string-take S 2) \"I?\")\n                  (string=? (string-take\
    \ S 2) \"I!\")\n                  (string=? (string-take S 2) \"I.\")\n      \
    \            (string=? (string-take S 2) \"I,\")\n                  (string=?\
    \ (string-take S 2) \"I:\")\n                  (string=? (string-take S 2) \"\
    I;\")\n                  (string=? (string-take S 2) \"I-\")\n               \
    \   (string=? (string-take S 2) \"I+\")\n                  (string=? (string-take\
    \ S 2) \"In\")\n                  (string=? (string-take S 2) \"It\")\n      \
    \            (string=? (string-take S 2) \"I1\")\n                  (string=?\
    \ (string-take S 2) \"I2\")\n                  (string=? (string-take S 2) \"\
    I3\")\n                  (string=? (string-take S 2) \"I4\")\n               \
    \   (string=? (string-take S 2) \"I5\")\n                  (string=? (string-take\
    \ S 2) \"I6\")\n                  (string=? (string-take S 2) \"I7\")\n      \
    \            (string=? (string-take S 2) \"I8\")\n                  (string=?\
    \ (string-take S 2) \"I9\")\n                  (string=? (string-take S 2) \"\
    I0\")\n                  (string=? (string-take S 2) \"Im\")\n               \
    \   (string=? (string-take S 2) \"I \"))) 1]\n        [else (is_bored (string-drop\
    \ S 1))]))\n", "  (count (string-split S #\"[.?!]\") (lambda (e) (and (string=?\
    \ \"I\" (first (string-split e #\"[^A-Za-z]+\"))) true))))\n", "  ;; 1. Split\
    \ into sentences:\n  (for/fold ([count 0])\n    ([s (string-split S #rx\"(\\.|\\\
    ?|!)\")])\n    (if (string-prefix? \"I\" s)\n        (+ count 1)\n        count)))\n",
  "  (length (regexp-match #rx\"I\\s[^\\?\\!\\.]+\" S)))\n", "  (count-if (lambda\
    \ (x) (string=? (string-trim (first (string-split x #\\space))) \"I\"))\n    \
    \        (string-split S #\\.)))\n", "  (define split-string-regexp \"[.!?]\"\
    )\n  (define split-words-regexp \" \")\n  (define (starts-with? str prefix)\n\
    \    (string-prefix? prefix str))\n  (define (is-bored-in-sentence sentence)\n\
    \    (define words (string-split sentence split-words-regexp))\n    (define first-word\
    \ (car words))\n    (starts-with? first-word \"I\"))\n  (define (is-bored-in-sentences\
    \ sentences)\n    (if (null? sentences)\n        0\n        (+ (if (is-bored-in-sentence\
    \ (car sentences)) 1 0)\n           (is-bored-in-sentences (cdr sentences)))))\n\
    \  (is-bored-in-sentences (string-split S split-string-regexp)))\n", "  (define\
    \ (is_bored-internal S R S-list L N)\n    (cond [(empty? S-list) N]\n        \
    \  [(regexp-match R (car S-list))\n           (is_bored-internal S R (cdr S-list)\
    \ L (+ N 1))]\n          [else (is_bored-internal S R (cdr S-list) L N)]))\n \
    \ (let ([L (string-split S #\\.)]\n        [R #rx\"^\\s*I[a-zA-Z0-9]*\"])\n  \
    \  (is_bored-internal S R L L 0)))\n", "  (length (filter (lambda (x) (string=?\
    \ \"I\" (car (string-split x))))\n                  (string-split S))))", "  (list-length\
    \ (list-index \"I\" (get-sentences S))))\n", "  (define (aux s i bored)\n    (cond\n\
    \      [(= i 0) bored]\n      [(equal? \"I\" (substring s 0 1)) (aux (substring\
    \ s 1 #f) i (+ bored 1))]\n      [else (aux (substring s 1 #f) i bored)]))\n \
    \ (aux S #f 0))\n", "  (count-occurrence S \"I\" 'i 'space))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
