name: HumanEval_125_split_words
language: rkt
prompt: "#lang racket\n\n;; Given a string of words, return a list of words split\
  \ on whitespace, if no whitespaces exists in the text you\n;; should split on commas\
  \ ',' if no commas exists you should return the number of lower-case letters with\
  \ odd order in the\n;; alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n\
  ;; Examples\n;; >>> (split_words \"Hello world!\")\n;; (list \"Hello\" \"world!\"\
  )\n;; >>> (split_words \"Hello,world!\")\n;; (list \"Hello\" \"world!\")\n;; >>>\
  \ (split_words \"abcdef\")\n;; 3\n(define (split_words txt)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate split_words))\n\
  \    (check-equal? (candidate \"Hello world!\") (list \"Hello\" \"world!\"))\n \
  \   (check-equal? (candidate \"Hello,world!\") (list \"Hello\" \"world!\"))\n  \
  \  (check-equal? (candidate \"Hello world,!\") (list \"Hello\" \"world,!\"))\n \
  \   (check-equal? (candidate \"Hello,Hello,world !\") (list \"Hello,Hello,world\"\
  \ \"!\"))\n    (check-equal? (candidate \"abcdef\") 3)\n    (check-equal? (candidate\
  \ \"aaabb\") 2)\n    (check-equal? (candidate \"aaaBb\") 1)\n    (check-equal? (candidate\
  \ \"\") 0)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? (regexp-match #rx\"\\s\" txt))\n     (cond\n\
    \       [(empty? (regexp-match #rx\",\" txt))\n        (count-lower-case-odd-letters\
    \ txt)]\n       [else\n        (map (\u03BB (x) x) (regexp-split #rx\",\" txt))])]\n\
    \    [else\n     (map (\u03BB (x) x) (regexp-split #rx\"\\s\" txt))]))\n", " \
    \ (if (zero? (string-length txt)) 0\n      (cond\n        ((string-contains txt\
    \ #\\space) (list (string-take txt (string-index txt #\\space)) (string-drop txt\
    \ (add1 (string-index txt #\\space)))))\n        ((string-contains txt #\\,) (list\
    \ (string-take txt (string-index txt #\\,)) (string-drop txt (add1 (string-index\
    \ txt #\\,)))))\n        (else (length (filter (lambda (x) (odd? x)) (map char->integer\
    \ (string->list txt))))))))\n", "  (match txt\n    [(regexp #rx\"\\\\s+\") (split\
    \ txt)]\n    [(regexp #rx\",\") (split txt)]\n    [else (length\n           (filter\
    \ odd?\n                   (map char->integer\n                        (string->list\
    \ (string-downcase txt)))))]))\n", "  (cond [(string-contains txt #\\space) (string-split\
    \ txt)]\n        [(string-contains txt #\\,) (string-split txt #\\,)]\n      \
    \  [else (num-odds txt)]))\n", "  (if (empty? (regexp-match #rx\"\\s\" txt))\n\
    \      (if (empty? (regexp-match #rx\",\" txt))\n          (count-odd-letters\
    \ txt)\n          (map symbol->string (regexp-split #rx\",\" txt)))\n      (map\
    \ symbol->string (regexp-split #rx\"\\s\" txt))))\n", "  (cond ((and (string-contains\
    \ txt #\\,) (string-contains txt #\\ ))\n         (cond ((string-contains txt\
    \ #\\ ) (map string->symbol (string-split txt #\\ )))\n               ((string-contains\
    \ txt #\\,) (map string->symbol (string-split txt #\\,)))))\n        ((string-contains\
    \ txt #\\ ) (map string->symbol (string-split txt #\\ )))\n        ((string-contains\
    \ txt #\\,) (map string->symbol (string-split txt #\\,)))\n        (else (count-odd-chars\
    \ txt))))\n", "  (if (string-contains txt #\\space)\n      (regexp-split #rx\"\
    [ \\t]+\" txt)\n      (if (string-contains txt #\\,)\n          (regexp-split\
    \ #rx\",\" txt)\n          (count-odds txt))))\n", "  (if (regexp-match? #rx\"\
    \\s\" txt)\n      (list (regexp-match* #rx\"(\\S+)\\s(\\S+)\" txt))\n      (if\
    \ (regexp-match? #rx\",\" txt)\n          (list (regexp-match* #rx\"(\\S+),(\\\
    S+)\" txt))\n          (if (regexp-match? #rx\"[a-z]\" txt)\n              (length\
    \ (filter odd? (map char->integer (string->list txt))))\n              )\n   \
    \       )\n      )\n  )\n", "  (define (occurs-in-string? target txt)\n    (and\
    \ (string? txt)\n         (andmap (lambda (ch)\n                   (char=? ch\
    \ target))\n                 txt)))\n  (cond ((occurs-in-string? #\\  txt)\n \
    \        (regexp-match* #rx\"\\\\w+\" txt))\n        ((occurs-in-string? #\\,\
    \ txt)\n         (regexp-match* #rx\"\\\\w+\" txt))\n        (else\n         (let\
    \ loop ([txt txt] [acc 0])\n           (cond [(empty? txt)\n                 \
    \ acc]\n                 [(number? (char->integer (string-ref txt 0)))\n     \
    \             (loop (substring txt 1) acc)]\n                 [(odd? (char->integer\
    \ (string-ref txt 0)))\n                  (loop (substring txt 1) (+ acc 1))]\n\
    \                 [else\n                  (loop (substring txt 1) acc)])))))\n",
  "  (if (empty? (regexp-match #rx\"[a-z]+\" txt))\n      (if (empty? (regexp-match\
    \ #rx\"[A-Z]+\" txt))\n          (if (empty? (regexp-match #rx\",\" txt))\n  \
    \            (count-odd-order txt)\n              (regexp-split #rx\",\" txt))\n\
    \          (regexp-split #rx\" \" txt))\n      (regexp-split #rx\" \" txt)))\n",
  "  (cond [(equal? (count-odds (string->list txt)) 0) (count-odds (string->list txt))]\n\
    \        [(equal? (count-odds (string->list txt)) 1) (list (list->string (list-ref\
    \ (string->list txt) (count-odds (string->list txt)))))]\n        [(equal? (count-odds\
    \ (string->list txt)) 2) (list (string-append (list->string (list-ref (string->list\
    \ txt) (count-odds (string->list txt)))) \",\" (list->string (list-ref (string->list\
    \ txt) (- (count-odds (string->list txt)) 1)))))]\n        [(equal? (count-odds\
    \ (string->list txt)) 3) (string-split (string-append (list->string (list-ref\
    \ (string->list txt) (count-odds (string->list txt)))) \",\" (list->string (list-ref\
    \ (string->list txt) (- (count-odds (string->list txt)) 1)))) \",\")]\n      \
    \  [(equal? (count-odds (string->list txt)) 4) (string-split (string-append (list->string\
    \ (list-ref (string->list txt) (count-odds (string->list txt)))) \",\" (list->string\
    \ (list-ref (string->list txt) (- (count-odds (string->list txt)) 1)))) \",\"\
    )]\n        [(equal? (count-odds (string->list txt)) 5) (string-split (string-append\
    \ (list->string (list-ref (string->list txt) (count-odds (string->list txt))))\
    \ \",\" (list->string (list-ref (string->list txt) (- (count-odds (string->list\
    \ txt)) 1)))) \",\")]\n        [(equal? (count-odds (string->list txt)) 6) (string-split\
    \ (string-append (list->string (list-ref (string->list txt) (count-odds (string->list\
    \ txt)))) \",\" (list->string (list-ref (string->list txt) (- (count-odds", " \
    \ (if (not (or (regexp-match #rx\" \" txt) (regexp-match #rx\",\" txt)))\n   \
    \   (list->vector (filter odd? (map (\u03BB (x) (- x (string-ref \"a\" 0))) (string->list\
    \ txt))))\n      (if (regexp-match #rx\" \" txt)\n          (split-string txt)\n\
    \          (string-split txt #\",\"))))\n", "  (cond\n    [(empty? (regexp-match\
    \ #rx\"\\s\" txt)) (split_words_on_commas txt)]\n    [else (split_words_on_whitespace\
    \ txt)]))\n", "  ;; TODO: Your code here\n  )\n```\n\n2.  Write a function that\
    \ takes a string of lower-case letters and returns the number of unique letters\
    \ in the string.\n\n```racket\n#lang racket\n", "  (if (member #\\space txt)\n\
    \      (regexp-split #rx\"\\s+\" txt)\n      (if (member #\\, txt)\n         \
    \ (regexp-split #rx\",\" txt)\n          (length (filter odd? (map string-ci-&gt;char-code\
    \ (string-&gt;list txt)))))))\n</code>\nThe code works but I'm not sure if it's\
    \ very idiomatic. I'd like to know what I'm doing wrong, or what I'm missing.\n\
    \n\nA:\n\nTo me, the <code>if</code> chain is a little bit too much, and I'd use\
    \ <code>cond</code> instead:\n<code>(define (split_words txt)\n  (cond ((regexp-match\
    \ #rx\"\\s+\" txt)\n         (regexp-split #rx\"\\s+\" txt))\n        ((regexp-match\
    \ #rx\",\" txt)\n         (regexp-split #rx\",\" txt))\n        (else\n      \
    \   (length (filter odd? (map string-ci-&gt;char-code (string-&gt;list txt)))))))\n\
    </code>\nI'm not sure if it makes a difference, but <code>regexp-match</code>\
    \ seems to be a tiny bit faster than <code>member</code>. Also, I'd use <code>regexp-match</code>\
    \ to check for match if I'm going to use <code>regexp-split</code> anyway.\n",
  "  (cond\n    [(string-empty? txt) '()]\n    [(and (string-contains txt #\\space)\
    \ (string-contains txt #\\,)) (remove-if string-whitespace? (string-split txt\
    \ #\\,))]\n    [(string-contains txt #\\,) (remove-if string-whitespace? (string-split\
    \ txt #\\,))]\n    [(string-contains txt #\\space) (remove-if string-whitespace?\
    \ (string-split txt #\\space))]\n    [else (list-length (filter odd? (list-transform\
    \ (string->list txt) ord)))]))\n", "  (let loop ([txt txt] [letters 0])\n    (if\
    \ (empty? txt)\n        letters\n        (if (or (= (car txt) #\\space) (= (car\
    \ txt) #\\,))\n            (loop (cdr txt) letters)\n            (if (even? (string-ref\
    \ txt 0))\n                (loop (cdr txt) letters)\n                (loop (cdr\
    \ txt) (+ letters 1)))))))\n</code>\nI'm just wondering if it is possible to make\
    \ this code more concise, because I feel like all the conditions are redundant.\n\
    \n\nA:\n\nThere are a few things that can be improved, but you already have a\
    \ pretty nice solution.\nThe only problem with your solution is that your conditionals\
    \ are not exhaustive. It only addresses the cases where <code>txt</code> is not\
    \ empty, but it does not take into account the case when it is empty. You can\
    \ make it more robust by adding a test for <code>null?</code>:\n<code>(define\
    \ (split_words txt)\n  (let loop ([txt txt] [letters 0])\n    (if (or (null? txt)\
    \ (empty? txt))\n        letters\n        (if (or (= (car txt) #\\space) (= (car\
    \ txt) #\\,))\n            (loop (cdr txt) letters)\n            (if (even? (string-ref\
    \ txt 0))\n                (loop (cdr txt) letters)\n                (loop (cdr\
    \ txt) (+ letters 1)))))))\n</code>\nJust for reference, the next two solutions\
    \ are based on the one above.\nYou can also use <code>char-alphabetic?</code>\
    \ to test if the character is a letter:\n<code>(define (split_words txt)\n  (let\
    \ loop ([txt txt] [letters 0])\n    (if (or (null? txt) (empty? txt))\n      \
    \  letters\n        (if (or (= (car txt) #\\space) (= (car txt) #\\,))\n     \
    \       (loop (cdr txt) letters)\n            (if (char-alphabetic? (car txt))\n\
    \                (if (even? (string-ref t", "  (cond ((not (string-contains txt\
    \ #\\space))\n         (cond ((not (string-contains txt #\\,))\n             \
    \   (count-odd-alphabet txt))\n               (else (cond ((not (string-contains\
    \ (string-tail txt 1) #\\,))\n                            (list (string-head txt\
    \ 1) (string-tail txt 1)))\n                           (else (list (string-head\
    \ txt 1) (string-take (string-tail txt 1) (- (string-length (string-tail txt 1))\
    \ 1))))))))\n        (else (cond ((not (string-contains (string-tail txt 1) #\\\
    space))\n                     (list (string-head txt 1) (string-tail txt 1)))\n\
    \                    (else (list (string-head txt 1) (string-take (string-tail\
    \ txt 1) (- (string-length (string-tail txt 1)) 1))))))))\n", "  (cond [(eq? (string-length\
    \ txt) 0) '()]\n        [(eq? (string-index txt #\\ ) 0) (split_words (substring\
    \ txt 1 (string-length txt)))]\n        [(eq? (string-index txt #\\,) 0) (split_words\
    \ (substring txt 1 (string-length txt)))]\n        [else (+ (remainder (char->integer\
    \ (string-ref txt 0)) 2) (split_words (substring txt 1 (string-length txt))))]))\n",
  "  (if (string-contains txt #\\space)\n      (list (substring txt 0 (string-index\
    \ txt #\\space))\n            (substring txt (+ (string-index txt #\\space) 1)\
    \ (string-length txt)))\n      (if (string-contains txt #\\,)\n          (list\
    \ (substring txt 0 (string-index txt #\\,))\n                (substring txt (+\
    \ (string-index txt #\\,) 1) (string-length txt)))\n          (count-odd-lower-case-letters\
    \ txt))))\n", "  (define letters\n    (map (\u03BB (x) (list x (- (char->integer\
    \ x) 96)))\n      (filter (\u03BB (x) (char-alphabetic? x))\n        (string->list\
    \ txt))))\n  (cond ((null? (string-index txt #\\ )) (list (string-append txt \"\
    !\")))\n        ((null? (string-index txt #\\,))\n         (length (filter (\u03BB\
    \ (x) (odd? (cadr x))) letters)))\n        (else (list (string-append (substring\
    \ txt 0 (string-index txt #\\,)) \"!\")\n                    (string-append (substring\
    \ txt (+ (string-index txt #\\,) 1) (string-length txt)) \"!\")))))\n", "  (if\
    \ (regexp-match #rx\"[[:space:]]\" txt)\n      (regexp-split #rx\"[[:space:]]\"\
    \ txt)\n      (if (regexp-match #rx\",\" txt)\n          (regexp-split #rx\",\"\
    \ txt)\n          (count (regexp-match* #rx\"[a-z]\" txt) #:test odd?))))\n",
  "  (cond\n    [(not (empty? (regexp-match #rx\"\\s\" txt))) (regexp-split #rx\"\\\
    s\" txt)]\n    [(not (empty? (regexp-match #rx\",\" txt))) (regexp-split #rx\"\
    ,\" txt)]\n    [else (for/sum [(c (in-string txt))] (if (odd? (char->integer c))\
    \ 1 0))]))\n", "  (define (is_in_list x lst)\n    (cond ((null? lst) #f)\n   \
    \       ((equal? x (car lst)) #t)\n          (else (is_in_list x (cdr lst)))))\n\
    \  (define (is_all_letters s)\n    (cond ((null? s) #t)\n          ((is_in_list\
    \ (car s) '(#\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\i #\\j #\\k #\\l #\\m #\\\
    n #\\o #\\p #\\q #\\r #\\s #\\t #\\u #\\v #\\w #\\x #\\y #\\z))\n           (is_all_letters\
    \ (cdr s)))\n          (else #f)))\n  (cond ((string-contains txt #\\ ) (string-split\
    \ txt #\\ ))\n        ((string-contains txt #\\,) (string-split txt #\\,))\n \
    \       ((is_all_letters txt) (length (filter odd? (map string-&gt;number (string-&gt;list\
    \ txt)))))\n        (else (list txt))))\n", "  (cond\n    [(string-contains txt\
    \ #\\ )\n     (split txt)]\n    [(string-contains txt #\\,)\n     (split txt #\\\
    ,)]\n    [else\n     (count_odd_chars txt)]))\n", "  (cond\n    [(regexp-match\
    \ #rx\"[[:space:]]\" txt) (regexp-split #rx\"[[:space:]]\" txt)]\n    [(regexp-match\
    \ #rx\",\" txt) (regexp-split #rx\",\" txt)]\n    [else (length (filter odd? (map\
    \ (\u03BB (c) (- (char->integer c) (char->integer #\\a))) (string->list txt))))]))\n",
  "  (cond ((string-contains txt #\\space) (split-string txt))\n        ((string-contains\
    \ txt #\\,) (split-string txt #\\,))\n        (else (length (filter (lambda (c)\
    \ (odd? (char->integer c))) txt)))))\n", "  (cond [(or (string-contains txt #\\\
    space) (string-contains txt #\\,))\n         (list (list-ref (string-split txt)\
    \ 0) (list-ref (string-split txt) 1))]\n        [else (count-letter txt)]))\n",
  "  (cond\n    [(null? (string-index txt #\\space))\n     (cond\n       [(null? (string-index\
    \ txt #\\,))\n        (cond\n          [(= (string-length txt) 1)\n          \
    \ (if (odd? (string-ci-&gt;symbol (string-&gt;list txt))) 1 0)]\n          [else\n\
    \           (if (odd? (string-ci-&gt;symbol (string-&gt;list (string-ref txt 0))))\
    \ 1 0)\n           (+ (if (odd? (string-ci-&gt;symbol (string-&gt;list (string-ref\
    \ txt 1)))) 1 0)\n              (if (odd? (string-ci-&gt;symbol (string-&gt;list\
    \ (string-ref txt 2)))) 1 0))]])\n       [else\n        (list (substring txt 0\
    \ 1) (substring txt 2 (string-length txt)))]\n       )]\n    [else\n     (list\
    \ (substring txt 0 (string-index txt #\\space)) (substring txt (+ (string-index\
    \ txt #\\space) 1) (string-length txt)))]))\n", "  (cond\n    ((string-contains\
    \ txt #\\space) (string-split txt #\\space))\n    ((string-contains txt #\\,)\
    \ (string-split txt #\\,))\n    (else (count-odd-order-letters txt))))\n", " \
    \ (cond [(string-match #rx\" \" txt) (string-split txt)]\n        [(string-match\
    \ #rx\",\" txt) (string-split txt)]\n        [else (count-lower-case-odd txt)]))\n",
  "  (cond ((not (string-contains txt #\\space))\n         (if (not (string-contains\
    \ txt #\\,))\n             (count-odd-letters txt)\n             (split-string\
    \ txt \",\")))\n        (else (split-string txt \" \"))))\n", "  (if (not (string-contains\
    \ txt #\\space))\n      (if (not (string-contains txt #\\,))\n          (length\
    \ (filter odd? (map char->integer (string->list txt))))\n          (split-string\
    \ txt \",\"))\n      (split-string txt)))\n", "  (if (not (regexp-match #rx\"\\\
    \\s+\" txt))\n      (if (not (regexp-match #rx\",\" txt))\n          (for/fold\
    \ ([num 0]) ([l '#\"abcdefghijklmnopqrstuvwxyz\"])\n            (if (not (char-alphabetic?\
    \ l))\n                num\n                (if (odd? (- (char->integer l) (char->integer\
    \ #\\a)))\n                    (+ num 1)\n                    num)))\n       \
    \   (regexp-split #rx\",\" txt))\n      (regexp-split #rx\"\\\\s+\" txt)))\n",
  "  (if (= #\\space (string-ref txt (add1 (string-length txt))))\n      (list (string-append\
    \ (substring txt 0 (string-length txt)) \" \"))\n      (list (substring txt 0\
    \ (string-length txt)))))\n</code>\nThis is the output from my code:\n<code>Welcome\
    \ to DrRacket, version 6.10 [3m].\nLanguage: racket; memory limit: 128 MB.\n\n\
    &gt; (split_words \"abcdef\")", "  (define (has-whitespace? txt)\n    (cond [(string-contains\
    \ txt #\\ ) #t]\n          [(string-contains txt #\\,) #t]\n          [else  \
    \                         #f]))\n  (cond [(has-whitespace? txt)\n         (split-on-regex\
    \ txt #rx\"\\s+\")]\n        [(string-contains txt #\\,)\n         (split-on-regex\
    \ txt #rx\",\")]\n        [else\n         (count (\u03BB (ch) (= (modulo (- (char->integer\
    \ ch) 97) 2) 1)) txt)]))\n", "  (cond\n    ((string-index txt #\\ )\n     (list\
    \ (substring txt 0 (string-index txt #\\ ))\n           (substring txt (+ (string-index\
    \ txt #\\ ) 1)\n                       (string-length txt))))\n    ((string-index\
    \ txt #\\,)\n     (list (substring txt 0 (string-index txt #\\,))\n          \
    \ (substring txt (+ (string-index txt #\\,) 1)\n                       (string-length\
    \ txt))))\n    (else\n     (count-odd-chars txt))))\n", "  (cond [(string-contains\
    \ txt #\\space)\n         (split-at-first txt #\\space)]\n        [(string-contains\
    \ txt #\\,)\n         (split-at-first txt #\\,)]\n        [else\n         (let\
    \ loop ((chars (string->list txt))\n                    (i (modulo (string-length\
    \ txt) 2))\n                    (odd-letters 0))\n           (cond [(empty? chars)\n\
    \                  odd-letters]\n                 [(and (char&lt;=? #\\a (car\
    \ chars))\n                       (char&lt;=? (car chars) #\\z))\n           \
    \       (if (= i 1)\n                      (loop (cdr chars)\n               \
    \             (- i 1)\n                            (+ odd-letters 1))\n      \
    \                (loop (cdr chars)\n                            (- i 1)\n    \
    \                        odd-letters))]\n                 [else\n            \
    \      (loop (cdr chars)\n                        i\n                        odd-letters)]))]))\n\
    </code>\n\nThis code can be made simpler using the built-in function <code>odd?</code>:\n\
    <code>#lang racket\n", "  (cond\n    ((empty? (regexp-match #rx\"\\s\" txt)) (odd_letter_count\
    \ txt))\n    ((empty? (regexp-match #rx\",\" txt)) (split-string txt \" \"))\n\
    \    (else (split-string txt \",\"))))\n", "  (define (alpha-order ch)\n    (char-&gt;integer\
    \ ch))\n  (define (count-odd-letters str)\n    (if (= 1 (modulo (alpha-order (string-ref\
    \ str 0)) 2))\n        (add1 (count-odd-letters (substring str 1)))\n        (count-odd-letters\
    \ (substring str 1))))\n  (if (regexp-match? #rx\"[[:blank:]]\" txt)\n      (list\
    \ (regexp-replace* #rx\"[[:blank:]]\" txt \"\"))\n      (if (regexp-match? #rx\"\
    ,\" txt)\n          (list (regexp-replace* #rx\",\" txt \"\"))\n          (count-odd-letters\
    \ txt))))\n</code>\nI'm not sure if I'm approaching this problem correctly in\
    \ the first place, so any help would be appreciated.\n\n\nA:\n\nThe problem is\
    \ that you're not stopping the recursion of the procedure <code>count-odd-letters</code>.\
    \ You assume that the empty string is odd, but there are an even number of letters\
    \ in an empty string. Consider the procedure <code>my-length</code> from Structure\
    \ and Interpretation of Computer Programs:\n<code>(define (my-length ls)\n  (if\
    \ (null? ls)\n      0\n      (add1 (my-length (cdr ls)))))\n</code>\nThere are\
    \ several ways to fix your <code>count-odd-letters</code> procedure. One is to\
    \ use a branching structure such as <code>cond</code>:\n<code>(define (count-odd-letters\
    \ str)\n  (cond\n    [(empty? str) 0]\n    [(odd? (alpha-order (string-ref str\
    \ 0)))\n     (add1 (count-odd-letters (substring str 1)))]\n    [else (count-odd-letters\
    \ (substring str 1))]))\n</code>\nA more elegant approach is to use <code>case</code>:\n\
    <code>(define (count-odd-letters str)\n  (case (string-length str)\n    [0 0]\n\
    \    [n (if (odd? (alpha-order (string-ref str 0)))\n           (add1 (", "  (cond\n\
    \    [(empty? (regexp-match #rx\"\\s\" txt)) (odd-alpha-count txt)]\n    [(empty?\
    \ (regexp-match #rx\",\" txt))   (split-string txt \",\")]\n    [else        \
    \                         (split-string txt \" \")]))\n", "  (cond\n    [(regexp-match\
    \ #rx\"\\s\" txt) (regexp-split #rx\"\\s\" txt)]\n    [(regexp-match #rx\",\"\
    \ txt) (regexp-split #rx\",\" txt)]\n    [else (length (filter (lambda (x) (odd?\
    \ (char->integer x))) (string->list txt)))]))", "  (if (empty? (regexp-match #rx\"\
    \\s\" txt))\n      (if (empty? (regexp-match #rx\",\" txt))\n          (foldr\
    \ (lambda (x y) (if (odd? (char->integer x)) (+ y 1) y)) 0 (string->list txt))\n\
    \          (regexp-split #rx\",\" txt))\n      (regexp-split #rx\"\\s\" txt)))\n",
  "    (cond\n        [(empty? (regexp-match #rx\"\\s\" txt))\n         (cond\n  \
    \        [(empty? (regexp-match #rx\",\" txt))\n           (count-odd-lower-case-letters\
    \ txt)]\n          [else\n           (split-on-commas txt)])]\n        [else\n\
    \         (split-on-whitespace txt)]))\n", "  (define (get-odd-chars txt)\n  \
    \  (define (count-odd txt count)\n      (if (string-null? txt)\n          count\n\
    \          (if (even? (char->integer (string-ref txt 0)))\n              (count-odd\
    \ (substring txt 1) count)\n              (count-odd (substring txt 1) (+ count\
    \ 1)))))\n    (count-odd txt 0))\n  (if (string-null? txt)\n      0\n      (if\
    \ (string-contains txt #\\space)\n          (string-split txt #\\space)\n    \
    \      (if (string-contains txt #\\,)\n              (string-split txt #\\,)\n\
    \              (get-odd-chars txt)))))\n", "  (cond\n    [(string-contains txt\
    \ #\\space) (string-split txt #\\space)]\n    [(string-contains txt #\\,) (string-split\
    \ txt #\\,)]\n    [else\n     (for/fold ([count 0])\n         ([c (in-string txt)])\n\
    \       (if (odd? (char->integer c))\n           (add1 count)\n           count))]))\n",
  "  (cond ((empty? (filter (\u03BB (c) (char-alphabetic? c)) txt))\n         (length\
    \ (filter odd? (map (\u03BB (c) (char->integer c)) (string->list txt)))))\n  \
    \      ((not (string-contains txt #\\space))\n         (if (string-contains txt\
    \ #\\,)\n             (string-split txt #\\,)\n             (list txt)))\n   \
    \     (else (string-split txt #\\space))))\n", "  (if (regexp-match #rx\" \" txt)\n\
    \      (regexp-split #rx\" \" txt)\n      (if (regexp-match #rx\",\" txt)\n  \
    \        (regexp-split #rx\",\" txt)\n          (add1 (length (filter odd? (map\
    \ (\u03BB (c) (char-&gt;integer c)) txt)))))))\n</code>\nBut I think it could\
    \ be better, any suggestion?\n\n\nA:\n\nYou can use <code>split-string</code>\
    \ instead of <code>regexp-split</code>.\nYou can use <code>char-alphabetic?</code>\
    \ instead of <code>char-&gt;integer</code>.\nYou can use <code>string-&gt;list</code>\
    \ to convert a string to a list of characters.\n<code>(define (split_words txt)\n\
    \  (cond ((string-match \" \" txt) (split-string txt))\n        ((string-match\
    \ \",\" txt) (split-string txt \",\"))\n        (else (add1 (length (filter odd?\n\
    \                             (map char-&gt;integer\n                        \
    \          (filter char-alphabetic?\n                                        \
    \  (string-&gt;list txt)))))))))\n</code>\n", "  (define (lower-case-odd-ord txt)\n\
    \    (define (sum-odd-ord txt)\n      (if (empty? txt)\n          0\n        \
    \  (+ (if (odd? (char->integer (first txt))) 1 0)\n             (sum-odd-ord (rest\
    \ txt)))))\n    (sum-odd-ord (string->list (string-downcase txt))))\n  (define\
    \ (whitespace-split txt)\n    (regexp-split #rx\"\\s+\" txt))\n  (define (comma-split\
    \ txt)\n    (regexp-split #rx\",\" txt))\n  (cond\n    [(empty? txt) empty]\n\
    \    [(whitespace-split txt) (whitespace-split txt)]\n    [(comma-split txt) (comma-split\
    \ txt)]\n    [else (lower-case-odd-ord txt)]))\n```\n\n# Day 4: 02/04/2019\n##\
    \ Right-most substring of letters\n```#lang racket\n", "  (cond ((string-contains\
    \ txt #\\space)\n         (string-split txt #\\space))\n        ((string-contains\
    \ txt #\\,)\n         (string-split txt #\\,))\n        (else\n         (length\
    \ (filter (lambda (c) (odd? (char->integer c))) (string->list txt))))))\n", " \
    \ (if (not (string-contains? txt #\\space))\n      (if (not (string-contains?\
    \ txt #\\,))\n          (list-length (filter odd? (map (\u03BB (x) (- x (char->integer\
    \ #\\a))) (string->list txt))))\n          (map string-trim (string-split txt\
    \ \",\")))\n      (map string-trim (string-split txt))))\n", "  (if (regexp-match\
    \ #rx\"\\\\w+\\\\s+\\\\w+\" txt)\n      (split-string txt #rx\"\\s+\")\n     \
    \ (if (regexp-match #rx\"\\\\w+,\\\\w+\" txt)\n          (split-string txt #rx\"\
    ,\")\n          (count-odd-alphabet-letters txt))))\n", "  (if (string-contains\
    \ txt #\\space)\n      (string-split txt #\\space)\n      (if (string-contains\
    \ txt #\\,)\n          (string-split txt #\\,)\n          (count-lowercase-letters\
    \ txt))))\n", "  (cond ((empty? (regexp-match #rx\" \" txt))\n         (cond ((empty?\
    \ (regexp-match #rx\",\" txt))\n                (let ([strlist (list->vector txt)])\n\
    \                  (define (ord-of x)\n                    (if (or (eq? (substring\
    \ x 0 1) \"a\") (eq? (substring x 0 1) \"A\")) 0\n                        (if\
    \ (or (eq? (substring x 0 1) \"b\") (eq? (substring x 0 1) \"B\")) 1\n       \
    \                     (if (or (eq? (substring x 0 1) \"c\") (eq? (substring x\
    \ 0 1) \"C\")) 2\n                                (if (or (eq? (substring x 0\
    \ 1) \"d\") (eq? (substring x 0 1) \"D\")) 3\n                               \
    \     (if (or (eq? (substring x 0 1) \"e\") (eq? (substring x 0 1) \"E\")) 4\n\
    \                                        (if (or (eq? (substring x 0 1) \"f\"\
    ) (eq? (substring x 0 1) \"F\")) 5\n                                         \
    \   (if (or (eq? (substring x 0 1) \"g\") (eq? (substring x 0 1) \"G\")) 6\n \
    \                                               (if (or (eq? (substring x 0 1)\
    \ \"h\") (eq? (substring x 0 1) \"H\")) 7\n                                  \
    \                  (if (or (eq? (substring x 0 1) \"i\") (eq? (substring x 0 1)\
    \ \"I\")) 8\n                                                        (if (or (eq?\
    \ (substring x 0 1) \"j\") (eq? (substring x 0 1) \"J\")) 9\n                \
    \                                            (if (or (eq? (substring x 0 1) \"\
    k\") (eq? (substring x 0 1) \"K\")) 10\n                                     \
    \                           (if (or (eq? (substring x 0 1) \"l\") (eq? (substring\
    \ x 0 1) \"L\")) 11\n                                                        \
    \            (if (or (eq? (substring x 0 1) \"m\") (eq? (substring x 0 1) \"M",
  "  (cond\n    [(empty? (regexp-match #rx\"[[:space:]]\" txt))\n     (cond\n    \
    \   [(empty? (regexp-match #rx\"[[:space:]]\" txt))\n        (count-even-odd-letters\
    \ txt)]\n       [else\n        (map string-downcase (regexp-split #rx\",\" txt))])]\n\
    \    [else\n     (map string-downcase (regexp-split #rx\"[[:space:]]\" txt))]))\n",
  "  ;; Add your code here.\n  )\n", "  (if (zero? (string-index txt #\\Space))\n\
    \      (if (zero? (string-index txt #\\,))\n          (count-lower-case-odd-indexes\
    \ txt)\n          (list (string-before txt \",\") (string-after txt \",\")))\n\
    \      (list (string-before txt \" \") (string-after txt \" \"))))\n", "  (cond\
    \ [(empty? (regexp-match #rx\"[[:space:]]\" txt))\n         (split_words txt)]\n\
    \        [(empty? (regexp-match #rx\",\" txt))\n         (split_words txt)]\n\
    \        [else (split_words txt)]))\n</code>\nI can't figure out how to figure\
    \ out the number of letters with odd order in the alphabet.\nAny help would be\
    \ appreciated.\n\n\nA:\n\nYou can use <code>char-&gt;integer</code> to convert\
    \ characters to ASCII numbers, then subtract <code>#\\a</code>'s ASCII number\
    \ and test for oddness:\n<code>(require racket/string)\n", "  (cond\n    [(regexp-match\
    \ #rx\" \" txt) (string-split txt)]\n    [(regexp-match #rx\",\" txt) (string-split\
    \ txt \",\")]\n    [else (length (filter odd? (string-map ord-value txt)))]))\n",
  "  (cond\n    [(empty? (find #\\Space txt))\n     (cond\n       [(empty? (find #\\\
    , txt))\n        (length (filter odd? (map (lambda (x) (- x 97)) (map char->integer\
    \ (string->list txt)))))]\n       [else\n        (map string->symbol (string-split\
    \ (string-replace \",\" \" \" txt)))])]\n    [else\n     (map string->symbol (string-split\
    \ txt))]))\n```\n\n### Question 2 (20 points)\n\nMake a function that takes one\
    \ parameter a string and returns a list of the words in the string in alphabetical\
    \ order by the number of characters in the word. \n\n#### Examples\n\n```racket\n\
    > (question2 \"Hello World World\")\n'(\"World\" \"Hello\" \"World\")\n> (question2\
    \ \"Hello World World!\")\n'(\"World\" \"Hello\" \"World\")\n> (question2 \"Hello\
    \ World World!,,,\")\n'(\"World\" \"Hello\" \"World\")\n> (question2 \"a cb def\"\
    )\n'(\"a\" \"cb\" \"def\")\n```\n\n```racket\n#lang racket", "  (if (string-match\
    \ #rx\"\\w+\" txt)\n      (regexp-match* #rx\"\\w+\" txt)\n      (if (string-match\
    \ #rx\",\" txt)\n\t  (regexp-match* #rx\",\" txt)\n\t  (let ([temp (regexp-match*\
    \ #rx\"\\w\" txt)])\n\t    (length (filter (lambda (x) (odd? (char->integer x)))\
    \ temp))))))\n```\n\n## Last problem -- \u201CCounting Vowels\u201D\n\n```\n#lang\
    \ racket\n", "  (if (or (string-contains txt #\\space) (string-contains txt #\\\
    ,))\n      (if (string-contains txt #\\space)\n          (split-list txt #\\space)\n\
    \          (split-list txt #\\,))\n      (count-odd-indices (string->list txt))))",
  "  (cond [(string-contains txt #\\whitespace)\n         (map string-&gt;symbol (string-split\
    \ txt #\\whitespace))]\n        [(string-contains txt #\\,)\n         (map string-&gt;symbol\
    \ (string-split txt #\\,))]\n        [else (count (lambda (x) (or (= x 'a) (=\
    \ x 'c) (= x 'e) (= x 'g) (= x 'i) (= x 'k) (= x 'm) (= x 'o) (= x 'q) (= x 's)\
    \ (= x 'u) (= x 'w) (= x 'y))) (string-&gt;list (string-downcase txt)))]))\n</code>\n\
    Error\n<code>split_words.rkt:5:0: \n  m: expected arguments of type &lt;symbol&gt;,\
    \ given (string-&gt;symbol \"world!\")\n</code>\nI don't understand what's wrong,\
    \ I can't find a way to fix it.\nI am not sure that I have to use string-split\n\
    Thank you very much.\n\n\nA:\n\nTry this:\n<code>(define (split_words txt)\n \
    \ (cond [(string-contains txt #\\whitespace)\n         (map string-&gt;symbol\
    \ (string-split txt #\\whitespace))]\n        [(string-contains txt #\\,)\n  \
    \       (map string-&gt;symbol (string-split txt #\\,))]\n        [else (count\
    \ (lambda (x) (or (= x 'a) (= x 'c) (= x 'e) (= x 'g) (= x 'i) (= x 'k) (= x 'm)\
    \ (= x 'o) (= x 'q) (= x 's) (= x 'u) (= x 'w) (= x 'y))) (string-&gt;list (string-downcase\
    \ txt)))]))\n</code>\n", "  (match txt\n    [(string-split #rx\"[ \\t]+\" txt)\
    \ (string-split #rx\"[ \\t]+\" txt)]\n    [(string-split #rx\",\" txt) (string-split\
    \ #rx\",\" txt)]\n    [_ (printf \"~s\\n\" (filter (lambda (c) (and (char-alphabetic?\
    \ c) (= 1 (remainder (char->integer c) 2)))) (string->list txt))))])\n", "  (cond\n\
    \    [(regexp-match #rx\"\\s\" txt) (string-split txt #\\space)]\n    [(regexp-match\
    \ #rx\",\" txt) (string-split txt #\\,)]\n    [else (length (filter (lambda (c)\
    \ (odd? (char->integer c))) (string->list txt)))]))\n```\n\n```racket\n#lang racket\n",
  "  (cond\n    ((string-contains txt #\\space)\n     (map (lambda (s) (substring\
    \ txt (string-index s txt) (string-index s txt 1))) (regexp-split #rx\"[ ]+\"\
    \ txt)))\n    ((string-contains txt #\\,)\n     (map (lambda (s) (substring txt\
    \ (string-index s txt) (string-index s txt 1))) (regexp-split #rx\"[,]+\" txt)))\n\
    \    (else\n     (for/fold ([acc 0]) ([w (in-list (string->list txt))])\n    \
    \   (if (odd? (char->integer w))\n           (+ acc 1)\n           acc)))))\n",
  "  (cond [(empty? (regexp-match #rx\"[ \\t]\" txt)) (if (empty? (regexp-match #rx\"\
    ,\" txt)) \n                                                    (if (empty? (regexp-match\
    \ #rx\"[aeiouyAEIOUY]\" txt))\n                                              \
    \          (count-odd-letters (string->list txt))\n                          \
    \                              0)\n                                          \
    \          (cond [(empty? (regexp-match #rx\"^[a-zA-Z\\'\" txt)) (list (regexp-replace*\
    \ #rx\"[,]\" txt \"\"))]\n                                                   \
    \       [else (list txt)]))]\n        [else (cond [(empty? (regexp-match #rx\"\
    ^[a-zA-Z\\'\" txt)) (list (regexp-replace* #rx\"[,]\" txt \"\"))]\n          \
    \          [else (list txt)])]))\n", "  (cond\n    [(empty? (regexp-match \"[\
    \ \\t\\n\\r]\" txt))\n     (split_words2 txt)]\n    [else\n     (regexp-match\
    \ \"[ \\t\\n\\r]+\" txt)]))\n", "  (cond ((not (string? txt)) \"Error\")\n   \
    \     ((not (regexp-match #rx\"[\\n\\t ,]\" txt)) (string-length txt))\n     \
    \   ((not (regexp-match #rx\"[\\n\\t ,]\" txt)) (string-length txt))\n       \
    \ (else (regexp-match #rx\"[\\n\\t ,]\" txt))))\n", "  (match txt\n    [(regexp\
    \ #rx\"\\s+\") (regexp-split #rx\"\\s+\" txt)]\n    [(regexp #rx\",\")    (regexp-split\
    \ #rx\",\" txt)]\n    [_                  (count-odds txt)]))\n", "  (if (string-contains\
    \ txt #\\space)\n      (split-string txt)\n      (if (string-contains txt #\\\
    ,)\n          (split-string txt #\\,)\n          (count-odds txt))))\n", "  (if\
    \ (list? txt) (list txt)\n      (if (regexp-match #rx\" \" txt) (regexp-split\
    \ #rx\" \" txt)\n          (if (regexp-match #rx\",\" txt) (regexp-split #rx\"\
    ,\" txt)\n              (length (filter odd? (map char->integer (string->list\
    \ txt))))))))\n", "  (define (even? n)\n    (zero? (modulo n 2)))\n  (define (odd?\
    \ n)\n    (not (even? n)))\n  (if (zero? (string-length txt))\n      0\n     \
    \ (let ([tokens (string-tokenize txt)])\n        (if (not (zero? (length tokens)))\n\
    \            tokens\n            (if (char-alphabetic? (string-ref txt 0))\n \
    \               (if (even? (char->integer (string-ref txt 0)))\n             \
    \       0\n                    1)\n                0)))))\n", "  (define (lower-case-odd-order-count\
    \ txt)\n    (let loop ([i 0] [acc 0])\n      (cond [(= i (string-length txt))\
    \ acc]\n            [(= (modulo (+ i 1) 2) 1) (loop (+ i 1) (if (and (>= (char->integer\
    \ (string-ref txt i)) 97)\n                                                  \
    \          (<= (char->integer (string-ref txt i)) 122))\n                    \
    \                                    (+ acc 1)\n                             \
    \                           acc))]\n            [else (loop (+ i 1) acc)])))\n\
    \  (if (string-contains txt #\\ )\n      (string-split txt)\n      (if (string-contains\
    \ txt #\\,)\n          (string-split txt #\\,)\n          (lower-case-odd-order-count\
    \ txt))))\n", "  (if (= (regexp-match? #rx\"\\\\s\" txt) #f)\n      (if (= (regexp-match?\
    \ #rx\",\" txt) #f)\n          (length (filter odd? (map char->integer (string->list\
    \ txt))))\n          (string-split txt #rx\",\"))\n      (string-split txt #rx\"\
    \\\\s\")))\n\n", "  (if (eq? (char-set-member? #\\Space txt) #t)\n      (list\
    \ (string-append (car (string-split txt \" \")) (cadr (string-split txt \" \"\
    ))))\n      (if (eq? (char-set-member? #\\, txt) #t)\n          (list (string-append\
    \ (car (string-split txt \",\")) (cadr (string-split txt \",\"))))\n         \
    \ (count-odd-order-letters txt))))\n", "  (if (string-contains txt #\\ )\n   \
    \   (split-string txt #\\ )\n      (if (string-contains txt #\\,)\n          (split-string\
    \ txt #\\,)\n          (let loop ([i 0] [acc 0])\n            (if (&lt; i (string-length\
    \ txt))\n                (let ([current (char-&gt;integer (string-ref txt i))])\n\
    \                  (loop (+ i 1) (if (odd? current) (+ acc 1) acc)))\n       \
    \         acc)))))\n</code>\n", "  (if (string-contains txt #\\space)\n      (split\
    \ txt [regexp #px\"\\\\s+\"])\n      (if (string-contains txt #\\,)\n        \
    \  (split txt [regexp #px\"\\\\,\"])\n          (define (count-odd txt)\n    \
    \        (if (empty? txt)\n                0\n                (if (odd? (char->integer\
    \ (char-downcase (car txt))))\n                    (+ 1 (count-odd (cdr txt)))\n\
    \                    (count-odd (cdr txt)))))\n          (count-odd txt))))",
  "  (let ((ws (string-index txt #\\space))\n        (comma (string-index txt #\\\
    ,)))\n    (cond ((and (&gt; ws 0) (&gt; comma 0))\n           (list (substring\
    \ txt 0 ws) (substring txt (+ ws 1))))\n          ((&gt; ws 0)\n           (list\
    \ (substring txt 0 ws) (substring txt (+ ws 1))))\n          ((&gt; comma 0)\n\
    \           (list (substring txt 0 comma) (substring txt (+ comma 1))))\n    \
    \      (else\n           (count-odds (string-&gt;list txt))))))\n", "  (define\
    \ (wspace? x) (or (equal? x #\\space) (equal? x #\\tab)))\n  (define (comma? x)\
    \ (equal? x #\\,))\n  (define (letter? x) (and (char-alphabetic? x) (char-lower-case?\
    \ x)))\n  (define (odd_count n) (if (odd? n) n 0))\n  (define (min_ord? x y) (min\
    \ x y))\n  (if (string-any wspace? txt)\n      (split txt wspace?)\n      (if\
    \ (string-any comma? txt)\n          (split txt comma?)\n          (if (string-any\
    \ letter? txt)\n              (foldl + 0 (map (compose odd_count (min_ord? 25))\
    \ (string->list txt)))\n              0))))\n", "    (cond\n        [(string-contains\
    \ txt #\\space) (string-split txt #\\space)]\n        [(string-contains txt #\\\
    ,) (string-split txt #\\,)]\n        [else (count-odd-letters txt)]))\n", "  (match\
    \ txt\n    [(regexp #rx\"^[a-z]+$\")\n     (length\n      (filter odd?\n     \
    \         (map (\u03BB (c) (char-&gt;integer c))\n                   (string-&gt;list\
    \ txt))))]\n    [(regexp #rx\"^([a-z]+[ ]+)*[a-z]+$\")\n     (map (\u03BB (w)\
    \ (string-append w \" \"))\n          (string-split txt #rx\"[ ]+\"))]\n    [(regexp\
    \ #rx\"^([a-z]+[,]+)*[a-z]+$\")\n     (map (\u03BB (w) (string-append w \",\"\
    ))\n          (string-split txt #rx\"[,]+\"))]\n    [_ (error 'split_words \"\
    invalid input string\")]))\n</code>\nAnd these are the test cases I wanted to\
    \ run:\n<code>;;; split_words.rkt", "    (define z)\n    (cond ((or (string-contains\
    \ txt #\\ ) (string-contains txt #\\,))\n           (string-split txt (string\
    \ #\\ ))\n           (if (string-null? (car z))\n               (cdr z)\n    \
    \           z))\n          (else\n           (define (odd-letter? c)\n       \
    \        (and (char-alphabetic? c) (even? (char->integer c))))\n           (define\
    \ (odd-letter-count s)\n               (define (cnt f l)\n                   (cond\
    \ ((empty? l) f)\n                         ((odd-letter? (car l)) (cnt (+ f 1)\
    \ (cdr l)))\n                         (else (cnt f (cdr l)))))\n             \
    \  (cnt 0 s))\n           (odd-letter-count (string->list txt)))))\n", "  (if\
    \ (not (string-contains txt #\\space))\n      (cond ((string-contains txt #\\\
    ,) (string-split txt #\\,))\n            (else (-count-odd-lower-case-letters\
    \ txt)))\n      (string-split txt #\\space)))\n", "  (cond ((string-contains txt\
    \ #\\space)\n         (split-string txt #\\space))\n        ((string-contains\
    \ txt #\\,)\n         (split-string txt #\\,))\n        (else\n         (count-if\
    \ odd? (map char->integer (string->list txt))))))\n", "  (if (string-contains\
    \ txt #\\space)\n      (map string-trim (regexp-split #rx\" +\" txt))\n      (if\
    \ (string-contains txt #\\,)\n          (map string-trim (regexp-split #rx\" *,\
    \ *\" txt))\n          (let loop ([odd-letters (list)])\n            (if (zero?\
    \ (string-length txt))\n                (length odd-letters)\n               \
    \ (if (odd? (char-&gt;integer (string-ref txt 0)))\n                    (loop\
    \ (cons (string-ref txt 0) odd-letters))\n                    (loop odd-letters)))))))\n",
  "  (if (string-contains txt #\\Space)\n      (split txt #\\Space)\n      (if (string-contains\
    \ txt #\\,)\n          (split txt #\\,)\n          (odd-chars txt))))\n", "  (if\
    \ (string-contains? txt #\\ )\n      (regexp-split \" \" txt)\n      (if (string-contains?\
    \ txt #\\,)\n          (regexp-split \",\" txt)\n          (count-odd txt))))\n",
  "  (cond\n    [(string-contains txt #\\space) (regexp-split #rx\"[ \\t\\n\\r\\f]+\"\
    \ txt)]\n    [(string-contains txt #\\,) (regexp-split #rx\"[,]+\" txt)]\n   \
    \ [else (count-number-of-odd-numbers-in-string txt)]))\n", "  (cond [(empty? (regexp-match\
    \ #rx\"\\s\" txt))\n         (cond [(empty? (regexp-match #rx\",\" txt))\n   \
    \             (count-odd-case-letters txt)]\n               [else (regexp-split\
    \ #rx\",\" txt)])]\n        [else (regexp-split #rx\"\\s\" txt)]))\n", "  (cond\n\
    \    [(string-contains txt #\\space) (string-split txt #\\space)]\n    [(string-contains\
    \ txt #\\,) (string-split txt #\\,)]\n    [else (count-if (\u03BB (c) (even? (char-&gt;integer\
    \ c))) (string-&gt;list txt))]))\n</code>\n", "  (cond [(string-contains txt #\\\
    space)\n         (split (string-split txt #\\space) (lambda (x) x))]\n       \
    \ [(string-contains txt #\\,)\n         (split (string-split txt #\\,) (lambda\
    \ (x) x))]\n        [else\n         (let ([odd-counter 0])\n           (for/fold\
    \ ([even-counter 0]) ([ch (in-string txt)])\n             (if (odd? even-counter)\n\
    \                 (if (char-lower-case? ch)\n                     (add1 odd-counter)\n\
    \                     odd-counter)\n                 (add1 even-counter))))]))\n",
  "  (cond\n    [(regexp-match #rx\"\\s\" txt) (regexp-split #rx\"\\s\" txt)]\n  \
    \  [(regexp-match #rx\",\" txt) (regexp-split #rx\",\" txt)]\n    [else (count-odd-letters\
    \ txt)]))\n", "  (if (string-contains txt #\\space)\n      (string-split txt #\\\
    space)\n      (if (string-contains txt #\\,)\n          (string-split txt #\\\
    ,)\n          (if (string-contains txt #\\a) 3))))", "  (if (not (equal? (string-index\
    \ txt #\\ ) #f))\n      (list (substring txt 0 (string-index txt #\\ ))\n    \
    \        (substring txt (+ (string-index txt #\\ ) 1)))\n    (if (not (equal?\
    \ (string-index txt #\\,) #f))\n        (list (substring txt 0 (string-index txt\
    \ #\\,))\n              (substring txt (+ (string-index txt #\\,) 1)))\n     \
    \ (length (filter (lambda (x) (odd? (char->integer x))) (string->list txt))))))\n\
    ```\n\n## Project Euler\n\n### 1. Multiples of 3 and 5\n\nIf we list all the natural\
    \ numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum\
    \ of these multiples is 23.\n\nFind the sum of all the multiples of 3 or 5 below\
    \ 1000.\n\n```racket\n#lang racket\n", "  (cond ((string-contains txt #\\space)\n\
    \         (split txt))\n        ((string-contains txt #\\,)\n         (split txt))\n\
    \        (else (odd-chars-in-string txt))))\n", "  (if (not (empty? (regexp-match\
    \ #rx\"[ ,]+\" txt)))\n      (regexp-match #rx\"[ ,]+\" txt)\n      (count-odd\
    \ (string->list txt))))\n", "  (cond ((string-index txt #\\space)\n         (split-at\
    \ (string-index txt #\\space) txt))\n        ((string-index txt #\\,)\n      \
    \   (split-at (string-index txt #\\,) txt))\n        (else\n         (length (regexp-match\
    \ #rx\"[a-z]*[a-z]\" txt)))))\n", "  (cond [(string-contains txt #\\ )\n     \
    \    (remove-if (lambda (x) (string=? x \"\")) (string-split txt #\\ ))]\n   \
    \     [(string-contains txt #\\,)\n         (remove-if (lambda (x) (string=? x\
    \ \"\")) (string-split txt #\\,))]\n        [else\n         (count-matches (regexp\
    \ \"[a-z]\") (string-lowercase txt))]))\n", "  (if (empty? (regexp-match #rx\"\
    \\s\" txt))\n      (if (empty? (regexp-match #rx\",\" txt))\n          (length\
    \ (filter odd? (map char->integer (string->list txt))))\n          (string-split\
    \ txt \",\"))\n      (string-split txt)))\n```\n\nTesting examples:\n\n```", " \
    \ (define (ord ch)\n    (exact->inexact (char->integer ch)))\n  (define (odd-chars\
    \ str)\n    (let loop ((start 0) (odd-cnt 0))\n      (if (= start (string-length\
    \ str))\n          odd-cnt\n          (let ((ch (string-ref str start)))\n   \
    \         (if (and (char&lt;=? #\\a ch) (char&lt;=? ch #\\z))\n              \
    \  (if (odd? (ord ch))\n                    (loop (+ start 1) (+ odd-cnt 1))\n\
    \                    (loop (+ start 1) odd-cnt))\n                (loop (+ start\
    \ 1) odd-cnt))))))\n  (cond ((string-contains? txt #\\space)\n         (string-split\
    \ txt #\\space))\n        ((string-contains? txt #\\,)\n         (string-split\
    \ txt #\\,))\n        (else\n         (odd-chars txt))))\n", "  (cond\n    [(empty?\
    \ (regexp-match #rx\" \" txt)) (string-length (regexp-match #rx\"[a-z]+\" txt))]\n\
    \    [(empty? (regexp-match #rx\",\" txt)) (split-at-regexp #rx\" \" txt)]\n \
    \   [else (split-at-regexp #rx\",\" txt)]))\n", "  (cond\n    [(empty? (regexp-match\
    \ #rx\"\\s\" txt))\n     (cond\n       [(empty? (regexp-match #rx\",\" txt))\n\
    \        (count-odds (string->list txt))]\n       [else\n        (split-list txt\
    \ \",\")])]\n    [else\n     (split-list txt \" \")]))\n", "  ;; Complete the\
    \ function body\n  )\n```\n\n```racket\n#lang racket\n", "  (if (regexp-match\
    \ #rx\"[[:space:]]\" txt)\n      (split txt #rx\"[[:space:]]+\")\n      (if (regexp-match\
    \ #rx\",\" txt)\n          (split txt #rx\",\")\n          (for/fold ([acc 0])\
    \ ([l (in-string txt)])\n            (if (odd? (char-&gt;integer l))\n       \
    \         (+ acc 1)\n                acc)))))\n</code>\nThe problem is if <code>txt</code>\
    \ contains only letters, the output is <code>'(#{0 #{#{0 #{#{0} #{#{0}}}}}})</code>.\
    \ \nIf <code>txt</code> contains both letters and numbers, I get this output:\
    \ <code>'(5 #{#{0 #{#{0 #{#{0} #{#{0}}}}}}})</code>.\nAnd a final example of the\
    \ output with only numbers <code>'(#{0 #{#{0 #{#{0} #{#{0}}}}}})</code>.\nHere's\
    \ what I get when I call the function:\n<code>&gt; (split_words \"Hello world!\"\
    )\n'(\"Hello\" \"world!\")\n&gt; (split_words \"abcdef\")\n#{0 #{#{0 #{#{0} #{#{0}}}}}}\n\
    &gt; (split_words \"1234,5678\")\n'(5 #{#{0 #{#{0 #{#{0} #{#{0}}}}}}})\n&gt; (split_words\
    \ \"Hello,world!\")\n'(\"Hello\" \"world!\")\n</code>\n", "  (define (is-space\
    \ c) (or (= c #\\space) (= c #\\tab)))\n  (define (split-one txt)\n    (cond\n\
    \      [(zero? (string-length txt)) '()]\n      [(is-space (string-ref txt 0))\n\
    \       (cons (substring txt 0 (string-index (lambda (c) (not (is-space c))) txt))\n\
    \             (split-one (substring txt (+ 1 (string-index (lambda (c) (not (is-space\
    \ c))) txt))))]\n      [else (cons txt '())]))\n  (define (get-alpha-at-odd-place\
    \ txt)\n    (if (= (modulo (string-length txt) 2) 0)\n        0\n        (if (odd?\
    \ (char->integer (string-ref txt 0)))\n            (+ 1 (get-alpha-at-odd-place\
    \ (substring txt 1)))\n            (get-alpha-at-odd-place (substring txt 1)))))\n\
    \  (cond\n    [(zero? (string-length txt)) '()]\n    [(> (string-index (lambda\
    \ (c) (is-space c)) txt) -1) (split-one txt)]\n    [(> (string-index (lambda (c)\
    \ (= c #\\,)) txt) -1) (split-one txt)]\n    [else (get-alpha-at-odd-place txt)]))\n",
  "  (local [(define (is-whitespace? char)\n            (char-whitespace? char))\n\
    \          (define (is-comma? char)\n            (char=? char #\\,))\n       \
    \   (define (odd-aplphabetical-characters txt)\n            (let [(define (count-odd-chars\
    \ txt odd-count)\n                     (if (empty? txt)\n                    \
    \     odd-count\n                         (if (odd? (modulo (char->integer (car\
    \ txt)) 2))\n                             (count-odd-chars (cdr txt) (+ odd-count\
    \ 1))\n                             (count-odd-chars (cdr txt) odd-count))))]\n\
    \              (count-odd-chars txt 0)))\n          (define (split-on-first-whitespace\
    \ txt)\n            (let [(define (split-whitespace txt)\n                   \
    \  (if (empty? txt)\n                         (list \"\" \"\")\n             \
    \            (if (is-whitespace? (car txt))\n                             (list\
    \ (string (reverse (cdr txt))) (list (car txt)))\n                           \
    \  (cons (car txt) (split-whitespace (cdr txt))))))]\n              (split-whitespace\
    \ txt)))\n          (define (split-on-first-comma txt)\n            (let [(define\
    \ (split-comma txt)\n                     (if (empty? txt)\n                 \
    \        (list \"\" \"\")\n                         (if (is-comma? (car txt))\n\
    \                             (list (string (reverse (cdr txt))) (list (car txt)))\n\
    \                             (cons (car txt) (split-comma (cdr txt))))))]\n \
    \             (split-comma txt)))\n          (define (trim-whitespace txt)\n \
    \           (if (empty? txt)\n                \"\"\n                (if (is-whitespace?\
    \ (car txt))\n                    (trim-whitespace (cdr txt))\n              \
    \      (string-append (list (car txt)) (trim-whitespace (cdr txt))))))\n     \
    \     (define (string-split-on-", "  (if (or (not (string-contains txt #\\,))\
    \ (not (string-contains txt #\\space)))\n      (count_odd_letters txt)\n     \
    \ (if (string-contains txt #\\space)\n          (string-split txt #\\space)\n\
    \          (string-split txt #\\,))))\n", "  (cond ((string-contains txt #\\space)\
    \ (string-split txt #\\space))\n        ((string-contains txt #\\,) (string-split\
    \ txt #\\,))\n        (else (string-fold (\u03BB (c n) (if (odd? (- (char->integer\
    \ c) 97)) (+ n 1) n)) txt 0))))\n```\n\n```racket\n#lang racket\n", "  (if (string-contains\
    \ txt #\\space)\n      (string-split txt #\\space)\n      (if (string-contains\
    \ txt #\\,)\n          (string-split txt #\\,)\n          (length (filter odd?\
    \ (map char->integer (string->list txt)))))))\n", "  (let ([words (regexp-split\
    \ #rx\"\\s+\" txt)]\n        [commas (regexp-split #rx\",\" txt)])\n    (if (not\
    \ (empty? words))\n        words\n        (if (not (empty? commas))\n        \
    \    commas\n            (let ([chars (string->list txt)])\n              (length\n\
    \               (filter odd?\n                       (map (\u03BB (c) (char-&gt;integer\
    \ c))\n                            chars))))))))\n", "  (cond [(string-empty?\
    \ txt) empty]\n        [(string-contains txt #\\,) (string-split txt #\\,)]\n\
    \        [(string-contains txt #\\ ) (string-split txt #\\ )]\n        [else (filter\
    \ odd? (map (lambda (c) (- (char->integer c) 97)) (string->list txt)))]))\n",
  "  (cond\n    [(null? (regexp-match #rx\"\\s\" txt))\n     (cond\n       [(null?\
    \ (regexp-match #rx\",\" txt))\n        (let loop ([idx 0] [odds 0])\n       \
    \   (cond\n            [(>= idx (string-length txt)) odds]\n            [(= 1\
    \ (remainder (string-ref txt idx) 2)) (loop (+ idx 1) (+ odds 1))]\n         \
    \   [else (loop (+ idx 1) odds)]))]\n       [else (map (\u03BB (x) (string-trim\
    \ x \",\")) (string-split txt \",\"))])]\n    [else (string-split txt)])\n)\n",
  "  (if (regexp-match? #rx\"[^,]+\" txt)\n      (regexp-match #rx\"[^,]+\" txt)\n\
    \      (if (regexp-match? #rx\"[^ ]+\" txt)\n          (regexp-match #rx\"[^ ]+\"\
    \ txt)\n          (count-odd-lowercase txt))))", "  (cond\n    [(empty? (regexp-match\
    \ #rx\"[[:space:]]\" txt))\n     (cond\n       [(empty? (regexp-match #rx\",\"\
    \ txt))\n        (count-odd-letters txt)]\n       [else\n        (split-on-delimiter\
    \ #rx\",\" txt)])]\n    [else\n     (split-on-delimiter #rx\"[[:space:]]\" txt)]))\n",
  "    (split-all (regexp #rx\"[ ,]+\") txt))\n", "  (if (string-contains txt #\\\
    space)\n      (string-split txt)\n      (if (string-contains txt #\\,)\n     \
    \     (string-split txt #\\,)\n          (count-lower-case-letters txt))))\n",
  "  ;; I found the syntax to cond is quite confusing, this is what I have figured\
    \ out so far\n  ;; note that the conditions must be boolean\n  ;; the condition\
    \ for the first case is true, the code will be executed, then cond\n  ;; is over,\
    \ no other branches will be evaluated\n  ;; otherwise, the next branch will be\
    \ evaluated, and so on\n  ;; if not conditions is met, it will return '()\n  (cond\n\
    \    ((string-contains txt #\\space) (string-split txt #\\space))\n    ((string-contains\
    \ txt #\\,) (string-split txt #\\,))\n    (else\n     (letrec\n       ([odd-letter-count\n\
    \         (lambda (n)\n           (if (= n 0) 0\n               (if (odd? (char->integer\
    \ (string-ref txt n))) (+ 1 (odd-letter-count (- n 1)))\n                   (odd-letter-count\
    \ (- n 1))))))])\n       (odd-letter-count (- (string-length txt) 1))))))\n",
  "  (if (or (string-contains txt #\\space) (string-contains txt #\\,))\n      (cond\
    \ ((string-contains txt #\\space) (string-split txt #\\space))\n            ((string-contains\
    \ txt #\\,) (string-split txt #\\,)))\n      (count-odd-alphabet-chars txt)))\n",
  "  (if (regexp-match #rx\" \" txt)\n      (string-split txt #rx\" \")\n      (if\
    \ (regexp-match #rx\",\" txt)\n          (string-split txt #rx\",\")\n       \
    \   (count-odd-alpha-chars txt))))\n", "  (cond ((equal? (string-index txt #\\\
    space) #f)\n         (cond ((equal? (string-index txt #\\,) #f)\n            \
    \    (for/fold ([sum 0]) ([odd-char (in-list (string->list txt))])\n         \
    \         (if (odd? (char->integer odd-char))\n                      (+ sum 1)\n\
    \                      sum)))\n               (else (string-split txt #\\,))))\n\
    \        (else (string-split txt #\\space))))\n", "  (cond\n    [(string-contains\
    \ txt #\\space) (map string-trim (string-split txt \" \"))]\n    [(string-contains\
    \ txt #\\,) (map string-trim (string-split txt \",\"))]\n    [else (count-letters\
    \ txt)]))\n", "  (if (not (string-contains txt #\\space))\n      (if (not (string-contains\
    \ txt #\\,))\n          (length (filter (lambda (x) (odd? x)) (map (lambda (x)\
    \ (- (char->integer x) (char->integer #\\a))) (string->list txt))))\n        \
    \  (map (lambda (x) (string-trim x)) (regexp-split #rx\"[,]\" txt)))\n      (map\
    \ (lambda (x) (string-trim x)) (regexp-split #rx\"[ ]\" txt))))\n```\n*Java*\n\
    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MyClass\
    \ {\n    public static void main(String args[]) {\n        System.out.println(splitWords(\"\
    Hello world!\"));\n        System.out.println(splitWords(\"Hello,world!\"));\n\
    \        System.out.println(splitWords(\"abcdef\"));\n    }\n\n    public static\
    \ List<String> splitWords(String text) {\n        List<String> output = new ArrayList<>();\n\
    \        if (!text.contains(\" \")) {\n            if (!text.contains(\",\"))\
    \ {\n                int c = 0;\n                for (int i = 0; i < text.length();\
    \ i++) {\n                    if ((text.charAt(i) - 'a') % 2 == 1) {\n       \
    \                 c++;\n                    }\n                }\n           \
    \     output.add(Integer.toString(c));\n            } else {\n               \
    \ String[] split_on_comma = text.split(\",\");\n                for (String s\
    \ : split_on_comma) {\n                    output.add(s.trim());\n           \
    \     }\n            }\n        } else {\n            String[] split_on_space\
    \ = text.split(\" \");\n            for (String s : split_on_space) {\n      \
    \          output.add(s.trim());\n            }\n        }\n        return output;\n\
    \    }\n}\n```\n\n### Problem 4:\n*Racket*\n```racket\n#lang racket\n", "  (if\
    \ (string-contains txt #\\space)\n      (list (car (string-split txt #\\space))\
    \ (cadr (string-split txt #\\space)))\n      (if (string-contains txt #\\,)\n\
    \          (list (car (string-split txt #\\,)) (cadr (string-split txt #\\,)))\n\
    \          (count-odd-alphabet txt))))\n", "  (if (not (string-index txt #\\,))\n\
    \      (if (not (string-index txt #\\space))\n          (if (or (odd? (char->integer\
    \ (string-ref txt 0)))\n                  (odd? (char->integer (string-ref txt\
    \ (sub1 (string-length txt))))))\n              2\n              1)\n        \
    \  (list (string-split txt (string #\\space))))\n      (list (string-split txt\
    \ (string #\\,)))))\n", "  (cond\n    [(string-contains txt #\\space)\n     (map\
    \ string->symbol (split-string txt #\\space))]\n    [(string-contains txt #\\\
    ,)\n     (map string->symbol (split-string txt #\\,))]\n    [else\n     (for/fold\
    \ ([odds 0]) ([w (in-string txt)])\n       (if (odd? (char->integer w))\n    \
    \       (+ odds 1)\n           odds))]))\n", "  (cond [(regexp-match? #rx\"\\\\\
    s+\" txt) (regexp-split #rx\"\\\\s+\" txt)]\n        [(regexp-match? #rx\",\"\
    \ txt) (regexp-split #rx\",\" txt)]\n        [else (count-odds txt)]))\n", " \
    \ (if (string-index txt #\\space)\n      (map (lambda (x) (word x)) (string-split\
    \ txt #\\space))\n      (if (string-index txt #\\,)\n          (map (lambda (x)\
    \ (word x)) (string-split txt #\\,))\n          (number-of-lower-case-odds txt))))\n",
  "  (cond\n    [(null? (regexp-match #rx\"\\s\" txt)) (split_words_case2 txt)]\n\
    \    [else (regexp-split #rx\"\\s\" txt)]))\n", "  (cond\n    [(find #\\  txt)\
    \ (string-split txt #\\space)]\n    [(find #\\, txt) (string-split txt #\\,)]\n\
    \    [else (odd-chars txt)]))\n", "  (cond\n    [(regexp-match? #rx\" \" txt)\
    \ (regexp-split #rx\" \" txt)]\n    [(regexp-match? #rx\",\" txt) (regexp-split\
    \ #rx\",\" txt)]\n    [else (count-odd-lower txt)]))\n", "  (cond ((not (string-contains\
    \ txt #\\,))\n         (if (not (string-contains txt #\\space))\n            \
    \ (count-lower-case-odd-letters txt)\n             (string-split txt #\\space)))\n\
    \        (else (string-split txt #\\,))))\n", "  (cond\n    [(string-contains\
    \ txt #\\space) (regexp-split #rx\"\\s+\" txt)]\n    [(string-contains txt #\\\
    ,) (regexp-split #rx\"\\s*,\\s*\" txt)]\n    [else\n     (length (filter even?\
    \ (map (\u03BB (ch) (char-ci&lt;=? #\\a ch #\\z)) txt)))]))\n</code>\nIt's difficult\
    \ to read, but I actually find that the boilerplate of <code>case</code> doesn't\
    \ help, and I find that the above code is concise. I have, however, never read\
    \ <code>cond</code> and <code>filter</code> code in the above format. It's possible\
    \ that I've read these functions in this format before, and didn't find them difficult\
    \ to read, or even thought to prefer this format.\nA smaller example:\n<code>#lang\
    \ racket\n", "  (cond\n    ((string-contains txt #\\space)\n     (string-split\
    \ txt #\\space))\n    ((string-contains txt #\\,)\n     (string-split txt #\\\
    ,))\n    (else\n     (count-odds (string->list txt)))))\n", "  (cond ((string-contains\
    \ txt #\\ ) (string-split txt #\\ ))\n        ((string-contains txt #\\,) (string-split\
    \ txt #\\,))\n        (else\n         (let ((words (string->list txt))\n     \
    \          (answer 0))\n           (for ((char words))\n             (if (even?\
    \ (char-alphabetic-value char))\n                 (begin\n                   (set!\
    \ answer (+ answer 1))\n                   )\n                 )\n           \
    \  )\n           answer\n           )\n         )\n        )\n  )\n", "  (define\
    \ (text->list txt)\n    (map (lambda (x) (string-append x)) (regexp-split #rx\"\
    \\s\" txt)))\n  (define (count-odd-chars str)\n    (define (get-ascii-offset ch)\
    \ (- (char->integer ch) (char->integer #\\a)))\n    (define (count-odd n)\n  \
    \    (cond [(= n 0) 1]\n            [(even? n) 0]\n            [else 1]))\n  \
    \  (foldl (lambda (accum n) (+ accum (count-odd n))) 0 (map get-ascii-offset str)))\n\
    \  (cond [(string-contains txt #\\,) (text->list txt)]\n        [(string-contains\
    \ txt #\\ ) (text->list txt)]\n        [else (count-odd-chars txt)]))", "  ;;\
    \ Your code here\n  )\n```\n\n### Hacker rank\n\n```racket\n#lang racket\n", " \
    \ (if (regexp-match #rx\"\\w+\\s+\\w+\" txt)\n      (map (lambda (x) (string-trim\
    \ x)) (regexp-split #rx\"\\s+\" txt))\n      (if (regexp-match #rx\"\\w+,\\w+\"\
    \ txt)\n          (map (lambda (x) (string-trim x)) (regexp-split #rx\",\" txt))\n\
    \          (count (string->list txt) (lambda (x) (odd? (char->integer x)))))))",
  "  (cond\n    ((string-contains txt #\\space)\n     (string-split txt #\\space))\n\
    \    ((string-contains txt #\\,)\n     (string-split txt #\\,))\n    (else\n \
    \    (let loop ([i 0] [lst (list)] [len (string-length txt)])\n       (cond\n\
    \         [(= i len)\n          (length lst)]\n         [(odd? (char-downcase\
    \ (string-ref txt i)))\n          (loop (+ i 1) (cons i lst) len)]\n         [else\n\
    \          (loop (+ i 1) lst len)])))))\n</code>\n", "  (cond\n    [(empty? (filter\
    \ not-space? txt))\n     (count (build-list 26 (lambda (i)\n                 \
    \            (char (+ (char->integer #\\a) i))))\n            (lambda (ch) (odd?\
    \ (char->integer ch))))]\n    [(empty? (filter not-comma? txt))\n     (map (lambda\
    \ (x) (string-join x #\\,))\n          (list-split '() #\\, txt))]\n    [else\n\
    \     (map (lambda (x) (string-join x #\\space))\n          (list-split '() #\\\
    space txt))]))\n", "  (cond\n    [(string-contains txt #\\space) (map (lambda\
    \ (s) (string-append s \"\")) (regexp-split #rx\"[ \\t]+\" txt))]\n    [(string-contains\
    \ txt #\\,) (map (lambda (s) (string-append s \"\")) (regexp-split #rx\",\" txt))]\n\
    \    [else (for/fold ([acc 0]) ([chr (in-string txt)])\n               (if (and\
    \ (char-alphabetic? chr) (odd? (char->integer chr)))\n                   (+ acc\
    \ 1)\n                   acc))]))\n```\n\n## Conditions and Loops\n\n### if, case\
    \ and cond\n```racket\n#lang racket\n", "  (if (string-contains txt #\\ ) (string-split\
    \ txt #\\ )\n      (if (string-contains txt #\\,) (string-split txt #\\,)\n  \
    \        (count-lower-case-odd txt))))\n", "  (if (andmap char-whitespace? (string->list\
    \ txt))\n      (string-split txt #\\space)\n      (if (andmap char-punctuation?\
    \ (string->list txt))\n          (string-split txt #\\,)\n          (length (filter\
    \ odd? (map char->integer (string->list txt)))))))\n", "  (if (= (string-length\
    \ txt) 1)\n      (if (char-lower-case? (string-ref txt 0)) 1 0)\n      (if (string-index\
    \ txt #\\space)\n          (map (lambda (w) (string-append w \" \")) (string-split\
    \ txt #\\space))\n          (if (string-index txt #\\,)\n              (string-split\
    \ txt #\\,)\n              (apply + (map (lambda (c) (if (char-lower-case? c)\
    \ (if (even? (char->integer c)) 0 1) 0)) txt))))))\n", "  (if (member txt '(\"\
    \"))\n      (list \"\")\n      (define temp (string-split txt #\\,))\n      (if\
    \ (&gt; (length temp) 1)\n          temp\n          (if (member txt '(\"a\" \"\
    b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"\
    o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"))\n    \
    \          (string-length txt)\n              0))))\n</code>\nI can see that if\
    \ I don't declare the list as empty, I get the error that the input given is a\
    \ string, not a list. It also is giving me an error at the line of:\n<code>(if\
    \ (member txt '(\"\"))\n</code>\nIt says that it can't compare the input txt with\
    \ '(\"\"). Can anyone give me a hint on how to get the list to display properly?\n\
    \n\nA:\n\nYour problem is not in <code>list</code>, but in <code>member</code>.\n\
    The argument to <code>member</code> must be a symbol.\nYou might have wanted to\
    \ use <code>string=?</code> or <code>equal?</code> instead of <code>member</code>.\n\
    You could also consider using <code>string-&gt;symbol</code> and use <code>member</code>\
    \ then.\nExample:\n<code>(define (split_words txt)\n  (if (string=? txt \"\")\n\
    \      (list \"\")\n      (define temp (string-split txt #\\,))\n      (if (&gt;\
    \ (length temp) 1)\n          temp\n          (if (member (string-&gt;symbol txt)\
    \ '(a b c d e f g h i j k l m n o p q r s t u v w x y z))\n              (string-length\
    \ txt)\n              0))))\n</code>\n", "  (cond\n    [(not (string-contains\
    \ txt #\\space))\n     (cond\n       [(not (string-contains txt #\\,))\n     \
    \   (length (filter odd? (map char->integer (string->list txt))))]\n       [else\n\
    \        (map string-trim (string-split txt #\\,))])]\n    [else\n     (map string-trim\
    \ (string-split txt #\\space))]))\n```\n\n```racket\n#lang racket\n", "  (if (equal?\
    \ (count-char-in-string txt #\\ ) 0)\n      (if (equal? (count-char-in-string\
    \ txt #\\,) 0)\n\t  (count-odd-ordered-lower-case-letter txt)\n\t  (string-split\
    \ txt #\\,))\n      (string-split txt #\\space)))\n", "  (cond\n    [(string-contains\
    \ txt #\\space)\n     (cond\n       [(string-contains txt #\\,)\n        (cond\n\
    \          [(string-contains txt #\\a) (+ 0 1)]\n          [(string-contains txt\
    \ #\\b) (+ 1 1)]\n          [(string-contains txt #\\c) (+ 2 1)]\n          [(string-contains\
    \ txt #\\d) (+ 3 1)]\n          [(string-contains txt #\\e) (+ 4 1)]\n       \
    \   [(string-contains txt #\\f) (+ 5 1)]\n          [(string-contains txt #\\\
    g) (+ 6 1)]\n          [(string-contains txt #\\h) (+ 7 1)]\n          [(string-contains\
    \ txt #\\i) (+ 8 1)]\n          [(string-contains txt #\\j) (+ 9 1)]\n       \
    \   [(string-contains txt #\\k) (+ 10 1)]\n          [(string-contains txt #\\\
    l) (+ 11 1)]\n          [(string-contains txt #\\m) (+ 12 1)]\n          [(string-contains\
    \ txt #\\n) (+ 13 1)]\n          [(string-contains txt #\\o) (+ 14 1)]\n     \
    \     [(string-contains txt #\\p) (+ 15 1)]\n          [(string-contains txt #\\\
    q) (+ 16 1)]\n          [(string-contains txt #\\r) (+ 17 1)]\n          [(string-contains\
    \ txt #\\s) (+ 18 1)]\n          [(string-contains txt #\\t) (+ 19 1)]\n     \
    \     [(string-contains txt #\\u) (+ 20 1)]\n          [(string-contains txt #\\\
    v) (+ 21 1)]\n          [(string-contains txt #\\w) (+ 22 1)]\n          [(string-contains\
    \ txt #\\x) (+ 23 1)]\n          [(string-contains txt #\\y) (+ 24 1)]\n     \
    \     [(string-contains txt #\\z) (+ 25 1)])]\n       [else (+ 0 1)]\n     )]\n\
    \    [else\n     (cond\n       [(string-contains txt #\\,)", "  (define (is-whitespace?\
    \ x) (or (equal? x #\\space) (equal? x #\\tab) (equal? x #\\newline)))\n  (define\
    \ (is-letter? x) (and (char-alphabetic? x) (char-lower-case? x)))\n  (define (ord\
    \ c) (- (char->integer c) (char->integer #\\a)))\n  (define (my-filter pred lst)\n\
    \    (cond\n      [(empty? lst) empty]\n      [(pred (first lst)) (cons (first\
    \ lst) (my-filter pred (rest lst)))]\n      [else (my-filter pred (rest lst))]))\n\
    \  (define (to-list str)\n    (define (to-list-rec str acc)\n      (cond\n   \
    \     [(empty? str) acc]\n        [else (to-list-rec (rest str) (cons (first str)\
    \ acc))]))\n    (to-list-rec str empty))\n  (define (to-str lst)\n    (define\
    \ (to-str-rec lst acc)\n      (cond\n        [(empty? lst) acc]\n        [else\
    \ (to-str-rec (rest lst) (string-append (first lst) acc))]))\n    (to-str-rec\
    \ lst \"\"))\n  (cond\n    [(empty? txt) empty]\n    [(and (is-whitespace? (first\
    \ txt)) (not (is-whitespace? (first (rest txt))))) (list (to-str (my-filter is-letter?\
    \ (to-list txt))))]\n    [(not (is-whitespace? (first txt))) (split_words (string-append\
    \ (rest txt) (string (first txt))))]\n    [else (split_words (rest txt))]))\n\
    ```\n\nThe version that came to my mind first, was the following\n\n```racket\n\
    #lang racket\n", "  (define (split_letters txt)\n    (cond\n      [(empty? txt)\
    \ 0]\n      [(odd? (char->integer (car txt))) (+ 1 (split_letters (cdr txt)))]\n\
    \      [else (split_letters (cdr txt))]))\n  (cond\n    [(empty? txt) empty]\n\
    \    [(string-contains txt #\\ ) (string-split txt #\\ )]\n    [(string-contains\
    \ txt #\\,) (string-split txt #\\,)]\n    [else (split_letters txt)]))\n", " \
    \ (cond [(regexp-match #rx\" \" txt) (regexp-split #rx\" \" txt)]\n        [(regexp-match\
    \ #rx\",\" txt) (regexp-split #rx\",\" txt)]\n        [else (count-lower-case-odd-alphabet\
    \ txt)]))\n", "  (cond\n    [(empty? (regexp-match #rx\"\\s\" txt))\n     (cond\n\
    \       [(empty? (regexp-match #rx\",\" txt))\n        (length (filter odd? (map\
    \ char->integer (string->list txt))))]\n       [else\n        (regexp-split #rx\"\
    ,\" txt)])]\n    [else\n     (regexp-split #rx\"\\s\" txt)]))\n", "  (cond\n \
    \   [(string-contains txt #\\ ) (string-split txt (regexp #rx\"[\\s]+\"))]\n \
    \   [(string-contains txt #\\,) (string-split txt (regexp #rx\",\"))]\n    [else\n\
    \     (define (counter acc ch)\n       (if (odd? (- (char->integer ch) (char->integer\
    \ #\\a)))\n           (+ acc 1)\n           acc))\n     (string-fold counter 0\
    \ txt)]))\n", "  (if (string-index txt #\\space)\n      (string-split txt #\\\
    space)\n      (if (string-index txt #\\,)\n          (string-split txt #\\,)\n\
    \          (let ((i 0)\n                (count 0))\n            (while (< i (string-length\
    \ txt))\n              (define ch (string-ref txt i))\n              (if (and\
    \ (char&lt;= #\\a ch) (char&lt;= ch #\\z))\n                  (if (odd? (char-&gt;integer\
    \ ch))\n                      (set! count (+ count 1))))\n              (set!\
    \ i (+ i 1)))\n            count))))\n</code>\nThe first of the three is correct\
    \ and is shown as correct, but the second and third throw an error. \n<code>The\
    \ interpreter expected an expression, but didn't find one. The string-split function\
    \ returned a string. To fix this problem, you can wrap the returned value in parentheses\
    \ to indicate that it is an expression to be used as the value of this function.\
    \ For example, if you just wrote:\n", "  (cond\n    ((regexp-match #rx\"\\s\"\
    \ txt) (regexp-split #rx\"\\s\" txt))\n    ((regexp-match #rx\",\" txt) (regexp-split\
    \ #rx\",\" txt))\n    (else\n     (let loop ([i 0] [n 0])\n       (cond\n    \
    \     [(> i 25) n]\n         [(and (odd? i) (char-lower-case? (string-ref txt\
    \ i))) (loop (+ i 1) (+ n 1))]\n         [else (loop (+ i 1) n)])))))\n", "  (cond\n\
    \    [(string-contains txt #\\space)\n     (map symbol->string (regexp-match #rx\"\
    \\w+\" txt))]\n    [(string-contains txt #\\,)\n     (map symbol->string (regexp-match\
    \ #rx\"\\w+\" txt))]\n    [else (length (filter odd? (map char->integer (string->list\
    \ txt))))]))\n```\n\n###### Split Words - Python\n```python\n#lang python\n\n\
    # Given a string of words, return a list of words split on whitespace, if no whitespaces\
    \ exists in the text you\n# should split on commas ',' if no commas exists you\
    \ should return the number of lower-case letters with odd order in the\n# alphabet,\
    \ ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n# Examples\n# >>> (split_words\
    \ \"Hello world!\")\n# (list \"Hello\" \"world!\")\n# >>> (split_words \"Hello,world!\"\
    )\n# (list \"Hello\" \"world!\")\n# >>> (split_words \"abcdef\")\n# 3\ndef split_words(txt):\n\
    \  if ' ' in txt:\n    return txt.split(' ')\n  elif ',' in txt:\n    return txt.split(',')\n\
    \  else:\n    return sum(1 for l in txt if ord(l) < 97 + 13)\n```\n\n###### Split\
    \ Words - Ruby\n```ruby\n#lang ruby\n\n# Given a string of words, return a list\
    \ of words split on whitespace, if no whitespaces exists in the text you\n# should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n# alphabet, ord('a') = 0, ord('b') = 1, ... ord('z')\
    \ = 25\n# Examples\n# >>> (split_words \"Hello world!\")\n# (list \"Hello\" \"\
    world!\")\n# >>> (split_words \"Hello,world!\")\n# (list \"Hello\" \"world!\"\
    )\n# >>> (split_words \"abcdef\")\n# 3\ndef split_words(txt)\n", "  (if (or (string-contains\
    \ txt #\\, ) (string-contains txt #\\space))\n      (split-string txt)\n     \
    \ (length (filter (lambda (x) (odd? x))\n                      (for/list ([x (in-string\
    \ txt)])\n                        (char-&gt;integer x))))))\n", "  (let ([chars\
    \ (string->list txt)])\n    (if (any (lambda (c) (char-whitespace? c)) chars)\n\
    \        (filter string? (regexp-split #rx\"\\s+\" txt))\n        (if (any (lambda\
    \ (c) (char=? c #\\,)) chars)\n            (filter string? (regexp-split #rx\"\
    ,\" txt))\n            (length (filter odd? (for/list ([c chars]) (char->integer\
    \ c))))))))\n", "  (define l (string-split txt #\\Space))\n  (if (eq? (length\
    \ l) 1)\n      (let ((l (string-split txt #\\,)))\n        (if (eq? (length l)\
    \ 1)\n            (if (even? (accumulate + 0 (map char->integer (string->list\
    \ txt))))\n                0\n                1)\n            l))\n      l))\n",
  "  (cond\n    [(empty? (regexp-match #rx\" \" txt))\n     (cond\n       [(empty?\
    \ (regexp-match #rx\",\" txt))\n        (for/fold ([num 0]) ([i (in-range (string-length\
    \ txt))])\n          (if (even? i)\n              num\n              (+ num 1)))]\n\
    \       [else\n        (regexp-split #rx\",\" txt)])]\n    [else\n     (regexp-split\
    \ #rx\" \" txt)]))\n", "  (if (not (empty? (regexp-match #rx\" \" txt)))\n   \
    \   (split_words_on-whitespace txt)\n    (if (not (empty? (regexp-match #rx\"\
    ,\" txt)))\n        (split_words_on-comma txt)\n      (split_words_on-odd-case\
    \ txt))))\n", "  ;; Write your code here\n  )\n```\n### Functions and lists\n\
    1. Write a function `(list-index x lst)` that, given a list `lst` and an element\
    \ `x`, returns the index of the first occurrence of `x` in `lst`.\n2. Write a\
    \ function `(list-append-if x lst)` that, given a list `lst` and an element `x`,\
    \ returns a list of all elements `y` of `lst` such that `x` and `y` are equal.\n\
    3. Write a function `(list-append-all lst)` that, given a list `lst`, returns\
    \ a list that is the concatenation of all lists in `lst`.\n4. Write a function\
    \ `(list-replace-if x y lst)` that, given a list `lst`, returns a list in which\
    \ every occurrence of the element `x` is replaced by the element `y`.\n5. Write\
    \ a function `(list-replace-all lst1 lst2)` that, given two lists `lst1` and `lst2`,\
    \ returns a list obtained by replacing every occurrence of the first element of\
    \ `lst1` with the first element of `lst2`, every occurrence of the second element\
    \ of `lst1` with the second element of `lst2`, and so on. If there are not enough\
    \ elements in `lst2`, the excess occurrences of elements in `lst1` should be removed.\n\
    \n### Imperative programming\n1. Write a function `(list-sum lst)` that, given\
    \ a list `lst` of natural numbers, returns the sum of the numbers in `lst`.\n\
    2. Write a function `(list-count-odd lst)` that, given a list `lst` of natural\
    \ numbers, returns the number of odd numbers in `lst`.\n3. Write a function `(list-compress\
    \ lst)` that, given a list `lst` of natural numbers, removes all consecutive duplicates\
    \ from `lst`.\n4. Write a function `(list-sum-odd lst)` that, given a list `lst`\
    \ of natural numbers, returns the sum of the odd numbers in `lst`.\n5. Write a\
    \ function `(list-count", "  (cond\n    [(empty? (regexp-match \"[\\s]+\" txt))\
    \ (cond\n                                           [(empty? (regexp-match \"\
    ,\" txt)) (count-odd-occurrences txt)]\n                                     \
    \      [else (split-string txt \",\")])]\n    [else (split-string txt)]))\n",
  "  (cond ((ormap string-contains? '(\" \") txt) (string-split txt \" \"))\n    \
    \    ((ormap string-contains? '(\",\") txt) (string-split txt \",\"))\n      \
    \  (else (apply + (odd-numbers-count-in-text txt)))))\n", "    (let loop ([txt\
    \ txt] [ans '()])\n      (cond [(string-contains txt #\\ ) (loop (substring txt\
    \ (add1 (string-index txt #\\ )) (string-length txt)) (cons (substring txt 0 (string-index\
    \ txt #\\ )) ans))]\n            [(string-contains txt #\\,) (loop (substring\
    \ txt (add1 (string-index txt #\\,)) (string-length txt)) (cons (substring txt\
    \ 0 (string-index txt #\\,)) ans))]\n            [else (count-odd-lowercase txt)])))\n",
  "  (cond\n    [(empty? (regexp-match #rx\" \" txt)) (cond\n                    \
    \                    [(empty? (regexp-match #rx\",\" txt)) (count-odd-letters\
    \ txt)]\n                                        [else (regexp-split #rx\",\"\
    \ txt)])]\n    [else (regexp-split #rx\" \" txt)]))\n", "  (cond ((not (string-contains\
    \ txt #\\space))\n         (cond ((not (string-contains txt #\\,))\n         \
    \       (number-of-lower-case-odd-order-letters txt))\n               (else (string-split\
    \ txt #\\,))))\n        (else (string-split txt #\\space))))\n", "  (cond\n  \
    \  [(string-contains txt #\\ ) (string-split txt)]\n    [(string-contains txt\
    \ #\\,) (string-split txt #\\,)]\n    [else (modulo (+ (char->integer (string-ref\
    \ txt 0))\n                     (char->integer (string-ref txt 1))\n         \
    \            (char->integer (string-ref txt 2))\n                     (char->integer\
    \ (string-ref txt 3))\n                     (char->integer (string-ref txt 4))\n\
    \                     (char->integer (string-ref txt 5)))\n                  2)]))\n",
  "  (if (string-contains txt #\\space)\n      (split (string->list txt) #\\space)\n\
    \      (if (string-contains txt #\\,)\n          (split (string->list txt) #\\\
    ,)\n          (count-odd-letter (string->list txt)))))\n", "  (if (string-contains\
    \ txt #\\space)\n      (string-split txt #\\space)\n      (if (string-contains\
    \ txt #\\,)\n          (string-split txt #\\,)\n          (cond\n            [(number?\
    \ (string-ref txt 0)) (string->number txt)]\n            [else (length (filter\
    \ odd? (map char->integer (string->list txt))))]))))\n", "  (split_words_h txt\
    \ (list-ref (string->list txt) 0)))\n", "  (define (is_whitespace? c)\n    (member\
    \ c '(#\\space #\\newline #\\tab #\\return)))\n  (define (is_lower-case? c)\n\
    \    (and (&gt;= c #\\a) (&lt;= c #\\z)))\n  (define (odd-order-chars text)\n\
    \    (foldl (lambda (c n)\n             (if (is_lower-case? c)\n             \
    \    (if (odd? (- c #\\a))\n                     (+ n 1)\n                   \
    \  n)\n                 n))\n           0\n           text))\n  (if (member #\\\
    space txt)\n      (map symbol-&gt;string (split-string txt))\n      (if (member\
    \ #\\, txt)\n          (map symbol-&gt;string (split-string txt #\\,))\n     \
    \     (odd-order-chars txt))))\n</code>\nThen if we run it through the doctest\n\
    <code>&gt; (require doctest)\n&gt; (doctest 'split_words)\n\n&gt; (doctest 'split_words\
    \ #:max-failures 2)\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n\
    .\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n\
    .\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n\
    .\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n\
    .\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n.\n.\n\n.\n\
    .\n.\n\n.", "  (if (empty? (filter string-whitespace? txt))\n      (if (empty?\
    \ (filter char=? #\\, txt))\n          (length (filter odd? (map char->integer\
    \ (string->list txt))))\n          (split-text txt #\\,))\n      (split-text txt\
    \ #\\space)))\n```\n\n```racket\n#lang racket\n", "  (if (regexp-match #rx\"\\\
    s\" txt)\n      (string-split txt)\n      (if (regexp-match #rx\",\" txt)\n  \
    \        (string-split txt #\\,)\n          (string-fold (\u03BB (c r) (if (odd?\
    \ (char-&gt;integer c)) (add1 r) r)) 0 txt))))\n</code>\nMy tests:\n<code>#lang\
    \ racket\n", "  (if (regexp-match #rx\"\\s\" txt)\n      (string-split txt)\n\
    \      (if (regexp-match #rx\",\" txt)\n          (string-split txt #\",\")\n\
    \          (let loop ([i 0] [odds 0])\n            (if (= i 26)\n            \
    \    odds\n                (if (odd? (string-ord (string-ref txt i)))\n      \
    \              (loop (+ i 1) (+ odds 1))\n                    (loop (+ i 1) odds)))))))\n",
  "  (cond\n    [(empty? (regexp-match #rx\"[, ]\" txt)) (count-odd txt)]\n    [(empty?\
    \ (regexp-match #rx\",\" txt)) (regexp-split #rx\"[ ]\" txt)]\n    [else (regexp-split\
    \ #rx\",\" txt)]))\n", "  ;; YOUR CODE HERE\n  )\n```\n\nYou may choose to use\
    \ a helper function that computes the value of a single letter, e.g.\n\n```racket",
  "  (define words (regexp-split #rx\"[ \\t]+\" txt))\n  (if (empty? words)\n    \
    \  (if (empty? (regexp-split #rx\",\" txt))\n          (length (filter odd? (for/list\
    \ ([c (in-string txt)]) (char->integer c))))\n          (list (string-join (regexp-split\
    \ #rx\",\" txt) \",\")))\n      (list (string-join words \" \"))))\n", "  (cond\n\
    \    [(regexp-match* #rx\"\\s\" txt)\n     (map string-titlecase (regexp-split\
    \ #rx\"\\s\" txt))]\n    [(regexp-match* #rx\",\" txt)\n     (map string-titlecase\
    \ (regexp-split #rx\",\" txt))]\n    [else\n     (for/fold ([cnt 0]) ([i (in-range\
    \ (string-length txt))])\n       (if (odd? (char-&gt;integer (string-ref txt i)))\n\
    \           (add1 cnt)\n           cnt))]))\n</code>\n", "  (cond ((equal? (string-index\
    \ txt #\\space) #f)\n         (cond ((equal? (string-index txt #\\,) #f)\n   \
    \             (odd-letters txt))\n               (else (string-split txt (string\
    \ #\\,)))))\n        (else (string-split txt (string #\\space)))))\n", "  (if\
    \ (string-contains txt #\\space)\n      (string-split txt #\\space)\n      (if\
    \ (string-contains txt #\\,)\n          (string-split txt #\\,)\n          (let\
    \ ([res 0])\n            (for ([i (in-range (string-length txt))])\n         \
    \     (if (odd? (char-&gt;integer (string-ref txt i)))\n                  (set!\
    \ res (+ res 1))))\n            res))))\n</code>\n", "  (if (not (empty? (regexp-match\
    \ #rx\" \" txt)))\n      (map (\u03BB (n) (substring txt n (+ n 1))) (regexp-match-positions\
    \ #rx\" \" txt))\n    (if (not (empty? (regexp-match #rx\",\" txt)))\n       \
    \ (map (\u03BB (n) (substring txt n (+ n 1))) (regexp-match-positions #rx\",\"\
    \ txt))\n      (length (regexp-match #rx\"[a-z]\" txt)))))\n", "  (if (not (string-empty?\
    \ txt))\n      (if (not (string-contains txt #\\space))\n          (if (not (string-contains\
    \ txt #\\,))\n              (if (not (string-contains txt #\\.))\n           \
    \       (length (filter (lambda (ch) (= 1 (modulo (char->integer ch) 2))) (string->list\
    \ txt)))\n                  (length (filter (lambda (ch) (= 1 (modulo (char->integer\
    \ ch) 2))) (string->list (substring txt 0 (- (string-length txt) 1))))))\n   \
    \           (length (filter (lambda (ch) (= 1 (modulo (char->integer ch) 2)))\
    \ (string->list (substring txt 0 (- (string-length txt) 1))))))\n          (if\
    \ (not (string-contains txt #\\,))\n              (if (not (string-contains txt\
    \ #\\.))\n                  (list (substring txt 0 (string-index txt #\\space))\
    \ (substring txt (+ (string-index txt #\\space) 1) (string-length txt)))\n   \
    \               (list (substring txt 0 (string-index txt #\\space)) (substring\
    \ txt (+ (string-index txt #\\space) 1) (- (string-length txt) 1))))\n       \
    \       (if (not (string-contains txt #\\.))\n                  (list (substring\
    \ txt 0 (string-index txt #\\,)) (substring txt (+ (string-index txt #\\,)) (string-length\
    \ txt)))\n                  (list (substring txt 0 (string-index txt #\\,)) (substring\
    \ txt (+ (string-index txt #\\,)) (- (string-length txt) 1))))))\n      txt))\n",
  "  (if (regexp-match #rx\"[^a-zA-Z0-9]\" txt)\n      (map string-&gt;symbol (regexp-split\
    \ #rx\"[ \\n]+\" txt))\n      (if (regexp-match #rx\"[^,]+\" txt)\n          (map\
    \ string-&gt;symbol (regexp-split #rx\",\" txt))\n          (map string-&gt;symbol\n\
    \               (regexp-split #rx\"\" txt)))))\n</code>\nWhen I run this code\
    \ using racket it works fine\n<code> &gt; (split_words \"Hello world!\")\n '(Hello\
    \ world!)\n</code>\nWhen I try to run the code using the online racket IDE it\
    \ gives me an error\n<code>; compile: unbound identifier in module in: split_words\n\
    </code>\nCan someone please help me understand what I did wrong?\nThanks\n\n\n\
    A:\n\nTo import modules in Racket you have to use <code>require</code>.\n<code>(require\
    \ racket/string)", "  (cond [(string-contains txt #\\space) (map string-append\
    \ (regexp-split #rx\"[[:space:]]+\" txt))]\n        [(string-contains txt #\\\
    ,) (map string-append (regexp-split #rx\"[,]+\" txt))]\n        [else (count-if\
    \ (lambda (x) (odd? x)) (map char->integer (string->list txt)))]))\n```\n\n```racket\n\
    #lang racket\n", "  (cond\n    [(and (not (string-contains txt #\\ )) (not (string-contains\
    \ txt #\\,))) (count-odd-chars txt)]\n    [(string-contains txt #\\ ) (split-on-whitespace\
    \ txt)]\n    [(string-contains txt #\\,) (split-on-comma txt)]))\n", "  (cond\
    \ [(string-contains txt #\\ ) (string-split txt #\\ )]\n        [(string-contains\
    \ txt #\\,) (string-split txt #\\,)]\n        [else (count-odd txt)]))\n", " \
    \ (cond\n    [(member (string-ref txt 0) (string->list \"qwertyuiopasdfghjklzxcvbnm\"\
    ))\n     (length (filter (lambda (x) (odd? (char->integer x))) (string->list txt)))]\n\
    \    [(member (string-ref txt 0) (string->list \",\"))\n     (split-at (string-index\
    \ txt \",\") txt)]\n    [else (string-split txt)]))\n", "  (let ([idx (string-index\
    \ txt #\\ )])\n    (if (equal? idx #f)\n      (let ([idx (string-index txt #\\\
    ,)])\n        (if (equal? idx #f)\n          (letrec ([helper (lambda (txt i)\n\
    \                            (cond ((equal? i (string-length txt)) i)\n      \
    \                            ((odd? (string-ref txt i)) (+ i (helper txt (+ i\
    \ 1))))\n                                  (else (helper txt (+ i 1)))))]\n  \
    \               [ans (helper txt 0)])\n            ans)\n          (string-split\
    \ txt \",\")))\n      (string-split txt \" \"))))\n", "  (match txt\n    [(? string-contains?\
    \ \" \") (string-split txt)]\n    [(? string-contains? \",\") (string-split txt)]\n\
    \    [_ (length (filter odd? (map (curry ch-code-lower 'a) (string->list txt))))]))\n",
  "  (if (empty? (regexp-match #rx\"\\s\" txt))\n      (if (empty? (regexp-match #rx\"\
    ,\" txt))\n          (define (count_odd_chars txt idx)\n            (if (= idx\
    \ (string-length txt))\n                0\n                (if (odd? (char->integer\
    \ (string-ref txt idx)))\n                    (+ 1 (count_odd_chars txt (+ idx\
    \ 1)))\n                    (count_odd_chars txt (+ idx 1)))))\n          (count_odd_chars\
    \ txt 0))\n      (regexp-match #rx\"\\S+\" txt)))\n", "  (cond [(empty? (regexp-match\
    \ #rx\"\\\\s+\" txt))\n          (cond [(empty? (regexp-match #rx\",\" txt))\n\
    \                  (length (filter odd? (map (\u03BB (x) (- x ord('a'))) (string->list\
    \ txt))))]\n                [else (regexp-split #rx\",\" txt)])]\n        [else\
    \ (regexp-split #rx\"\\\\s+\" txt)]))\n```\n\n```racket\n#lang racket\n", "  (if\
    \ (string-contains txt #\\space)\n      (string-split txt)\n      (if (string-contains\
    \ txt #\\,)\n          (string-split txt #\\,)\n          (let ((lst (string->list\
    \ txt)))\n            (foldl (lambda (x y)\n                     (if (odd? (char->integer\
    \ x))\n                         (+ y 1)\n                         y))\n      \
    \             0\n                   lst)))))\n\n", "  (if (not (string-contains\
    \ txt #\\space))\n      (if (not (string-contains txt #\\,))\n          (sum (map\
    \ (lambda (c) (if (even? (char->integer c)) 0 1)) (string->list txt)))\n     \
    \     (split-at txt #\\,))\n      (split-at txt #\\space)))\n", "  (if (not (empty?\
    \ (string-index txt #\\space)))\n      (split-at (string-index txt #\\space) txt)\n\
    \    (if (not (empty? (string-index txt #\\,)))\n        (split-at (string-index\
    \ txt #\\,) txt)\n      (count-odd-letters txt))))\n", "  (cond\n    [(string-index\
    \ txt #\\space) (string-split txt #\\space)]\n    [(string-index txt #\\,) (string-split\
    \ txt #\\,)]\n    [else (filter (\u03BB (x) (odd? (char->integer x))) (string->list\
    \ txt))]))\n", "  (cond [(empty? (regexp-match #rx\"\\s\" txt))\n         (cond\
    \ [(empty? (regexp-match #rx\",\" txt))\n                (let loop ((i 0) (odds\
    \ 0))\n                  (cond [(= i (string-length txt))\n                  \
    \       odds]\n                        [(odd? (char-&gt;integer (string-ref txt\
    \ i)))\n                         (loop (+ i 1) (+ odds 1))]\n                \
    \        [else\n                         (loop (+ i 1) odds)]))]\n           \
    \    [else\n                (regexp-split #rx\",\" txt)])]\n        [else\n  \
    \       (regexp-split #rx\"\\s\" txt)]))\n", "  (cond\n    [(regexp-match #rx\"\
    [[:space:]]\" txt) (regexp-split #rx\"[[:space:]]\" txt)]\n    [(regexp-match\
    \ #rx\",\" txt) (regexp-split #rx\",\" txt)]\n    [else (count-odds (string->list\
    \ txt))]))\n", "  (if (not (string-contains txt #\\ ))\n      (if (not (string-contains\
    \ txt #\\,))\n          (length (filter odd? (map char->integer (string->list\
    \ txt))))\n          (map string-trim (string-split txt \",\")))\n      (map string-trim\
    \ (string-split txt \" \"))))", "  (cond\n    [(string-contains txt #\\Space)\
    \ (string-split txt)]\n    [(string-contains txt #\\,) (string-split txt #\\,)]\n\
    \    [else (length (list-index (list-index (string->list txt) odd?) odd?))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
