name: HumanEval_138_is_equal_to_sum_even
language: rkt
prompt: "#lang racket\n\n;; Evaluate whether the given number n can be written as\
  \ the sum of exactly 4 positive even numbers\n;; Example\n;; >>> (is_equal_to_sum_even\
  \ 4)\n;; #f\n;; >>> (is_equal_to_sum_even 6)\n;; #f\n;; >>> (is_equal_to_sum_even\
  \ 8)\n;; #t\n(define (is_equal_to_sum_even n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_equal_to_sum_even))\n\
  \    (check-equal? (candidate 4) #f)\n    (check-equal? (candidate 6) #f)\n    (check-equal?\
  \ (candidate 8) #t)\n    (check-equal? (candidate 10) #t)\n    (check-equal? (candidate\
  \ 11) #f)\n    (check-equal? (candidate 12) #t)\n    (check-equal? (candidate 13)\
  \ #f)\n    (check-equal? (candidate 16) #t)\n))\n\n(test-humaneval)"
completions: ["  (match n\n    [0 false]\n    [n\n     (even? n)\n     (and\n    \
    \  (or (= n 1) (equal? (is_equal_to_sum_even (sub1 n)) true))\n      (or (= n\
    \ 2) (equal? (is_equal_to_sum_even (sub2 n)) true))\n      (or (= n 3) (equal?\
    \ (is_equal_to_sum_even (sub3 n)) true))\n      (or (= n 4) (equal? (is_equal_to_sum_even\
    \ (sub4 n)) true)))]))\n", "  (is_sum_of_n_evens? n 4))\n", "  (define (is_equal_to_sum_even_iter\
    \ n possible_sums)\n    (if (empty? possible_sums)\n        #f\n        (if (=\
    \ n (apply + possible_sums))\n            #t\n            (if (> n (apply + possible_sums))\n\
    \                (is_equal_to_sum_even_iter n (append possible_sums (list (first\
    \ possible_sums) (+ 2 (first possible_sums)))))\n                (is_equal_to_sum_even_iter\
    \ n (rest possible_sums))))))\n  (is_equal_to_sum_even_iter n (list 2 4 6)))\n",
  "  (cond\n    [(= n 8) #t]\n    [(even? n) #f]\n    [else (is_equal_to_sum_even\
    \ (+ n 2))]))\n", "  (define counter 1)\n  (define sum 0)\n  (define (loop n counter\
    \ sum)\n    (cond [(= counter 5)\n           #f]\n          [(&gt;= (+ sum (*\
    \ 2 n)) n)\n           #t]\n          [else\n           (loop n (+ counter 1)\
    \ (+ sum (* 2 (- n counter))))]))\n  (loop n counter sum))\n</code>\n", "  (define\
    \ (loop a b c d)\n    (cond\n      [(zero? (+ a b c d)) #t]\n      [(even? a)\
    \ (or (loop (+ a 2) b c d) (loop (+ a 2) (+ b 2) c d) (loop (+ a 2) (+ b 2) (+\
    \ c 2) d))]\n      [(even? b) (or (loop a (+ b 2) c d) (loop a (+ b 2) (+ c 2)\
    \ d))]\n      [(even? c) (loop a b (+ c 2) d)]\n      [else #f]))\n  (and (even?\
    \ n)\n       (loop 0 0 0 n)))\n", "  (letrec ([g (lambda (n c l)\n           \
    \     (cond\n                  [(zero? c) #f]\n                  [(= n 0) #t]\n\
    \                  [(> n 0)\n                   (for/or ([a l])\n            \
    \                (g (- n a) (- c 1) (rest l)))]))])\n    (g n 4 (range 1 n 2))))\n",
  "  (letrec ([sum (lambda (a b c d) (+ a b c d))]\n           [summand (lambda (s)\
    \ (local [(define (inner n) (cond [(= n s) 1] [(<= n 0) 0] [else (+ (inner (-\
    \ n 1)) (inner (- n 2)) (inner (- n 4)))]))] (inner s)))]\n           [min-summand\
    \ (lambda (s) (local [(define (inner n) (cond [(= n s) 1] [(<= n 0) 1000] [else\
    \ (min (inner (- n 1)) (inner (- n 2)) (inner (- n 4)))]))] (inner s)))]\n   \
    \        [eq? (lambda (a b) (= (summand a) (summand b)))])\n    (eq? n (sum (min-summand\
    \ n) (min-summand (- n (min-summand n))) (min-summand (- n (min-summand n) (min-summand\
    \ (- n (min-summand n))))) (min-summand (- n (min-summand n) (min-summand (- n\
    \ (min-summand n))) (min-summand (- n (min-summand n) (min-summand (- n (min-summand\
    \ n)))))))))))\n", "  (define (iter e sum)\n    (cond\n      ((< sum n) (iter\
    \ (+ e 2) (+ sum e)))\n      ((= sum n) #t)\n      (else #f)))\n  (iter 2 0))\n",
  "  (letrec ([is-equal-to-sum-even\n            (lambda (n s)\n              (if\
    \ (> n s)\n                  (if (= n s)\n                      #t\n         \
    \             (if (zero? (remainder n 2))\n                          (is-equal-to-sum-even\
    \ n (+ s 2))\n                          #f))\n                  #f))])\n    (is-equal-to-sum-even\
    \ n 2)))\n", "  (if (= n 4) #f\n      (if (= n 6) #f\n          (if (= n 8) #t\n\
    \              (if (= n 10) #t\n                  (if (= n 12) #t\n          \
    \            (if (= n 14) #t\n                          (if (= n 16) #t\n    \
    \                          (if (= n 18) #t\n                                 \
    \ (if (= n 20) #t\n                                      (if (= n 22) #t\n   \
    \                                       (if (= n 24) #t\n                    \
    \                          (if (= n 26) #t\n                                 \
    \                 (if (= n 28) #t\n                                          \
    \            (if (= n 30) #t\n                                               \
    \           (if (= n 32) #t\n                                                \
    \              (if (= n 34) #t\n                                             \
    \                     (if (= n 36) #t\n                                      \
    \                                (if (= n 38) #t\n                           \
    \                                               (if (= n 40) #t\n            \
    \                                                                  (if (= n 42)\
    \ #t\n                                                                       \
    \           (if (= n 44) #t\n                                                \
    \                                      (if (= n 46) #t\n                     \
    \                                                                     (if (= n\
    \ 48) #t\n                                                                   \
    \                           (if (= n 50) #t\n                                \
    \                                                                  (if (= n 52)\
    \ #t\n                                                                       \
    \                               (if (= n 54) #t\n                            \
    \                                                                            \
    \  (if (= n 56) #t\n                                                         \
    \                                                     (if (= n 58) #t\n      \
    \                                                                            \
    \                                (if (= n 60) #t\n                           \
    \                                                                            \
    \               (if (= n 62) #t\n                                            \
    \                                                                            \
    \  (if (= n 64) #t\n                                                         \
    \                                                                     (if (= n\
    \ 66) #t\n                                                                   \
    \                                                               (if (= n 68) #t\n\
    \                                                                            \
    \                                                          (if (= n 70) #t\n \
    \                                                                            \
    \                                                             (if (= n 72) #t\n\
    \                                                                            \
    \                                                                  (if (= n 74)\
    \ #t\n                                                                       \
    \                                                                           (if\
    \ (= n 76) #t\n                                                              \
    \                  ", "  ;; YOUR CODE HERE\n  )\n\n```\n### Question 3\nThis questions\
    \ is about the implementation of  a function `is_equal_to_sum_powers` that evaluates\
    \ whether a given number n can be written as the sum of exactly 4 positive integers,\
    \ which are each raised to the power of 3.\n```scheme\n#lang racket\n", "  (and\n\
    \   (= 0 (modulo n 2))\n   (or (= n 8)\n       (and\n        (> n 8)\n       \
    \ (or (is_equal_to_sum_even (- n 8))\n            (and\n             (> n 12)\n\
    \             (or (is_equal_to_sum_even (- n 12))\n                 (and\n   \
    \               (> n 16)\n                  (or (is_equal_to_sum_even (- n 16))\n\
    \                      (and\n                       (> n 20)\n               \
    \        (or (is_equal_to_sum_even (- n 20))\n                           (and\n\
    \                            (> n 24)\n                            (or (is_equal_to_sum_even\
    \ (- n 24))\n                                (and\n                          \
    \       (> n 28)\n                                 (or (is_equal_to_sum_even (-\
    \ n 28))\n                                     (and\n                        \
    \              (> n 32)\n                                      (or (is_equal_to_sum_even\
    \ (- n 32))\n                                          (and\n                \
    \                           (> n 36)\n                                       \
    \    (or (is_equal_to_sum_even (- n 36))\n                                   \
    \            (and\n                                                (> n 40)\n\
    \                                                (or (is_equal_to_sum_even (-\
    \ n 40))\n                                                    (and\n         \
    \                                            (> n 44)\n                      \
    \                               (or (is_equal_to_sum_even (- n 44))\n        \
    \                                                 (and\n                     \
    \                                     (> n 48)\n                             \
    \                             (or (is_equal_to_sum_even (- n 48))\n          \
    \                                                    (and\n                  \
    \                                             (> n 52)\n                     \
    \                                          (or (is_equal_to_sum_even (- n 52))\n\
    \                                                                   (and\n   \
    \                                                                 (> n 56)\n \
    \                                                                   (or (is_equal_to_sum_even\
    \ (- n 56))\n                                                                \
    \        (and\n                                                              \
    \           (> n 60)\n                                                       \
    \                  (or (is_equal_to_sum_even (- n 60))\n                     \
    \                                                        (and\n              \
    \                                                                (> n 64)\n  \
    \                                                                            (or\
    \ (is_equal_to_sum_even", "  (equal? n (apply + (filter even? (integer-sqrt-list\
    \ n 4)))))\n", "  (define (sum_even lst)\n    (cond\n      ((empty? lst) #f)\n\
    \      ((and (even? (first lst)) (= n (sum lst))) #t)\n      (else (sum_even (rest\
    \ lst)))))\n  (sum_even (in-range 4 n)))", "  (letrec ([n n]\n           [is-equal?\
    \ (= n (apply + (take 4 (filter even? (in-range n)))))]\n           [is-valid?\
    \ (is-equal?)]\n           [partition (take 4 (filter even? (in-range n)))]\n\
    \           [recur (lambda (x) (if (and (not is-equal?) (not (= (length partition)\
    \ 4)))\n                                  (let ([n (- n (car partition))]\n  \
    \                                      [partition (cdr partition)])\n        \
    \                            (recur x))\n                                  (values\
    \ x is-valid? partition)))]\n           [recur? (and (not is-equal?) (not (= (length\
    \ partition) 4)))])\n    (recur n)))\n", "  (if (is_equal_to_sum_even_aux n 4)\n\
    \      true\n      false))\n", "  (define (sum_even n0 n1 n2 n3)\n    (if (&lt;\
    \ (+ n0 n1 n2 n3) n)\n        (or (sum_even (+ n0 2) n1 n2 n3)\n            (sum_even\
    \ n0 (+ n1 2) n2 n3)\n            (sum_even n0 n1 (+ n2 2) n3)\n            (sum_even\
    \ n0 n1 n2 (+ n3 2)))\n        (= (+ n0 n1 n2 n3) n)))\n  (sum_even 0 0 0 0))\n\
    </code>\nHow can I improve this code to be efficient for bigger inputs?\n\n\n\
    A:\n\nYou are using recursion without a clear recursive method. \nThe brute force\
    \ approach to this problem is to just try all possibilities. The number of possibilities\
    \ can be bounded by the number of 4-tuples of positive even numbers that sum to\
    \ a number smaller than <code>n</code>. If we find such a tuple, then we can check\
    \ if it sums to <code>n</code>.\nAnother way to write this function is to use\
    \ <code>list</code>'s built-in recursive function, <code>foldr</code>. \nWe can\
    \ write a function <code>next</code> that can generate a list of all the possible\
    \ next tuples. For example:\n<code>(define (next x)\n  (list (+ x 2) (+ x 4) (+\
    \ x 6) (+ x 8)))\n</code>\nWe can call <code>next</code> and flatten the lists\
    \ returned by that function using <code>map</code> and <code>append</code>:\n\
    <code>(define (generate xs)\n  (apply append (map next xs)))\n</code>\nThen we\
    \ can use <code>foldr</code> to generate a list of possible tuples by combining\
    \ an element with every possible tuple in the list generated. For example:\n<code>(define\
    \ (generate-tuples-next el xs)\n  (map (lambda (x) (cons el x)) xs))\n</code>\n\
    And then we can use <code>foldr</code> to combine <code>generate-tuples-next</code>\
    \ with a list generated by <code>gener", "  (if (zero? n)\n      #f\n      (if\
    \ (zero? (modulo n 2))\n          (if (even_sum? (minus n 2) 4)\n            \
    \  #t\n              #f)\n          #f)))\n", "  (define (sum-even n)\n    (cond\n\
    \      [(= n 0) (list 0 0 0 0)]\n      [(even? n) (list n 0 0 0)]\n      [else\
    \ (let ([p (even-sum-next n)])\n\t      (if (= 0 p)\n\t\t  #f\n\t\t  (cons p (sum-even\
    \ (- n p)))))]))\n  (if (not (even? n))\n      #f\n      (let ([p (sum-even n)])\n\
    \t(if (= 0 (list-ref p 0))\n\t    #f\n\t    (= n (apply + p))))))\n", "  (define\
    \ (iter num sum acc)\n    (cond\n      [(= sum n) (= acc 4)]\n      [(>= num n)\
    \ #f]\n      [else (iter (+ num 2) (+ sum num) (+ acc 1))]))\n  (iter 0 0 0))\n",
  "  (define (is_equal_to_sum_even1 n1 n2 n3 n4)\n    (define (is_equal_to_sum_even2\
    \ n1 n2 n3 n4)\n      (define (is_equal_to_sum_even3 n1 n2 n3 n4)\n        (define\
    \ (is_equal_to_sum_even4 n1 n2 n3 n4)\n          (define (is_equal_to_sum_even5\
    \ n1 n2 n3 n4)\n            (define (is_equal_to_sum_even6 n1 n2 n3 n4)\n    \
    \          (define (is_equal_to_sum_even7 n1 n2 n3 n4)\n                (define\
    \ (is_equal_to_sum_even8 n1 n2 n3 n4)\n                  (define (is_equal_to_sum_even9\
    \ n1 n2 n3 n4)\n                    (define (is_equal_to_sum_even10 n1 n2 n3 n4)\n\
    \                      (define (is_equal_to_sum_even11 n1 n2 n3 n4)\n        \
    \                (define (is_equal_to_sum_even12 n1 n2 n3 n4)\n              \
    \            (define (is_equal_to_sum_even13 n1 n2 n3 n4)\n                  \
    \          (define (is_equal_to_sum_even14 n1 n2 n3 n4)\n                    \
    \          (define (is_equal_to_sum_even15 n1 n2 n3 n4)\n                    \
    \            (define (is_equal_to_sum_even16 n1 n2 n3 n4)\n                  \
    \                (define (is_equal_to_sum_even17 n1 n2 n3 n4)\n              \
    \                      (define (is_equal_to_sum_even18 n1 n2 n3 n4)\n        \
    \                              (define (is_equal_to_sum_even19 n1 n2 n3 n4)\n\
    \                                        (define (is_equal_to_sum_even20 n1 n2\
    \ n3 n4)\n                                          (define (is_equal_to_sum_even21\
    \ n1 n2 n3 n", "  (and (<= n 20)\n       (or (= n 8)\n           (= n 12)\n  \
    \         (= n 16)\n           (= n 20)\n           )))\n", "  (if (= n 4) #f\n\
    \    (if (= n 6) #f\n      (if (= n 8) #t\n        (if (= n 10) #t\n         \
    \ (if (= n 12) #t\n            (if (= n 14) #t\n              (if (= n 16) #t\n\
    \                (if (= n 18) #t\n                  (if (= n 20) #t\n        \
    \            (if (= n 22) #t\n                      (if (= n 24) #t\n        \
    \                (if (= n 26) #t\n                          (if (= n 28) #t\n\
    \                            (if (= n 30) #t\n                              (if\
    \ (= n 32) #t\n                                (if (= n 34) #t\n             \
    \                     (if (= n 36) #t\n                                    (if\
    \ (= n 38) #t\n                                      (if (= n 40) #t\n       \
    \                                 (if (= n 42) #t\n                          \
    \                (if (= n 44) #t\n                                           \
    \ (if (= n 46) #t\n                                              (if (= n 48)\
    \ #t\n                                                (if (= n 50) #t\n      \
    \                                            (if (= n 52) #t\n               \
    \                                     (if (= n 54) #t\n                      \
    \                                (if (= n 56) #t\n                           \
    \                             (if (= n 58) #t\n                              \
    \                            (if (= n 60) #t\n                               \
    \                             (if (= n 62) #t\n                              \
    \                                (if (= n 64) #t\n                           \
    \                                     (if (= n 66) #t\n                      \
    \                                            (if (= n 68) #t\n               \
    \                                                     (if (= n 70) #t\n      \
    \                                                                (if (= n 72)\
    \ #t\n                                                                       \
    \ (if (= n 74) #t\n                                                          \
    \                (if (= n 76) #t\n                                           \
    \                                 (if (= n 78) #t\n                          \
    \                                                    (if (= n 80) #t\n       \
    \                                                                         (if\
    \ (= n 82) #t\n                                                              \
    \                    (if (= n 84) #t\n                                       \
    \                                             (if (= n 86) #t\n              \
    \                                                                        (if (=\
    \ n 88) #t\n                                                                 \
    \                      ", "  (define (helper n sum count)\n    (cond\n      [(=\
    \ count 4) (= n sum)]\n      [(even? n) (helper n (+ n sum) (+ count 1))]\n  \
    \    [else (helper (- n 1) sum count)]))\n  (helper n 0 0))\n", "  (cond ((= n\
    \ 4) #f)\n        ((< n 4) #f)\n        ((= n (+ 4 (+ 2 (+ 2 (+ 2 2))))) #t)\n\
    \        (else (is_equal_to_sum_even (- n 2)))))\n```\n\n```python\n#lang python\n\
    \n# Evaluate whether the given number n can be written as the sum of exactly 4\
    \ positive even numbers\n# Example\n# >>> is_equal_to_sum_even(4)\n# False\n#\
    \ >>> is_equal_to_sum_even(6)\n# False\n# >>> is_equal_to_sum_even(8)\n# True\n\
    def is_equal_to_sum_even(n):\n    if n == 4:\n        return False\n    elif n\
    \ < 4:\n        return False\n    elif n == 4 + 2 + 2 + 2:\n        return True\n\
    \    else:\n        return is_equal_to_sum_even(n - 2)\n```\n\n#### Problems\n\
    \n1.1.2 Evaluate whether the given number n can be written as the sum of exactly\
    \ 4 positive even numbers\n\nExample\n\n```text\n>>> is_equal_to_sum_even(4)\n\
    False\n>>> is_equal_to_sum_even(6)\nFalse\n>>> is_equal_to_sum_even(8)\nTrue\n\
    ```\n\n1.1.3 Evaluate whether the given number n can be written as the sum of\
    \ exactly 4 positive even numbers with max\n\nExample\n\n```text\n>>> is_equal_to_sum_even_max(6)\n\
    False\n>>> is_equal_to_sum_even_max(8)\nTrue\n```\n\n1.1.4 Evaluate whether the\
    \ given number n can be written as the sum of exactly 4 positive even numbers\
    \ with max and min\n\nExample\n\n```text\n>>> is_equal_to_sum_even_max_min(6)\n\
    False\n>>> is_equal_to_sum_even_max_min(8)\nTrue\n```\n\n1.1.5 Evaluate whether\
    \ the given number n can be written as the sum of exactly 4 positive even numbers\
    \ with max and min\n\nExample\n\n```", "  (is_equal_to_sum_even-acc n 0 4))\n",
  "  (or (and (eq? n 8) #t)\n      (and (eq? n 6) #f)\n      (and (eq? n 4) #f)))\n",
  "  (cond ((= n 4) #f)\n        ((= n 6) #f)\n        ((= n 8) #t)\n        (else\n\
    \         (let loop ((a 0) (b 0) (c 0) (d 0))\n           (cond ((and (= a 2)\
    \ (= b 2) (= c 2) (= d 2)) #t)\n                 ((> (+ (* a 2) (* b 2) (* c 2)\
    \ (* d 2)) n) #f)\n                 (else\n                  (cond ((= a 0) (loop\
    \ (+ a 1) b c d))\n                        ((= b 0) (loop a (+ b 1) c d))\n  \
    \                      ((= c 0) (loop a b (+ c 1) d))\n                      \
    \  ((= d 0) (loop a b c (+ d 1)))\n                        (else\n           \
    \              (cond ((= a 2) (loop 0 0 0 (+ d 1)))\n                        \
    \       ((= b 2) (loop 0 0 (+ c 1) 0))\n                               ((= c 2)\
    \ (loop 0 (+ b 1) 0 0))\n                               ((= d 2) (loop (+ a 1)\
    \ 0 0 0)))))))))))\n```\n\n```\n#lang racket\n", "    (cond [(= n 4) #f]\n   \
    \       [(even? n) (helper 4 4 (quotient n 2))]\n          [else #f]))", "  (letrec\
    \ ([odd_sum? (lambda (n) (if (or (= n 0) (= n 1)) #f (even_sum? (- n 1))))]\n\
    \           [even_sum? (lambda (n) (if (= n 0) #t (odd_sum? (- n 2))))])\n   \
    \ (odd_sum? n)))\n", "  (define (is_equal_to_sum_even_helper n acc)\n    (if (=\
    \ n (* 2 acc))\n        #t\n        (if (> n (* 2 acc))\n            (if (= n\
    \ (+ 2 (* 2 acc)))\n                #t\n                (if (> n (+ 2 (* 2 acc)))\n\
    \                    (if (= n (+ 4 (* 2 acc)))\n                        #t\n \
    \                       (if (> n (+ 4 (* 2 acc)))\n                          \
    \  (if (= n (+ 6 (* 2 acc)))\n                                #t\n           \
    \                     (if (> n (+ 6 (* 2 acc)))\n                            \
    \        (if (= n (+ 8 (* 2 acc)))\n                                        #t\n\
    \                                        #f)\n                               \
    \     #f)\n                                #f)\n                            #f)\n\
    \                        #f)\n                    #f)\n                #f)\n \
    \           #f)\n        )\n    )\n  (is_equal_to_sum_even_helper n 0)\n)\n",
  "  (cond\n    [(= n (sum-even 1 1 1 1)) #t]\n    [(or (= n (sum-even 2 2 2 2)) (=\
    \ n (sum-even 1 1 1 3))) #t]\n    [else #f]))\n", "  (define (is_equal-to-sum-even-iter\
    \ n a b c d)\n    (cond\n      ((= n (+ a b c d)) #t)\n      ((> n (+ a b c d))\
    \ #f)\n      ((= a d) #f)\n      (else (is_equal-to-sum-even-iter n (+ a 2) b\
    \ c d))))\n  (is_equal-to-sum-even-iter n 0 0 0 0))\n```\n\n##### Question 2.\n\
    > Write a function that given a list of numbers, returns a list of pairs. Each\
    \ pair contains the smallest and the biggest number of the list.\n>\n> Example:\n\
    > ```racket\n> >>> (min-max [3 1 5 2 7 9])\n> '((1 9) (1 9) (1 9) (1 9) (1 9)\
    \ (1 9))\n> ```\n>\n> Hint: you may use the `min` and `max` functions.\n\n```racket\n\
    #lang racket\n", "  (if (zero? n)\n      #f\n      (or (even? n)\n          (let\
    \ ([i 4])\n            (if (zero? i)\n                #f\n                (or\
    \ (letrec ([p (is_equal_to_sum_even (- n i))])\n                      (if p\n\
    \                          #t\n                          (begin\n            \
    \                (set! i (- i 2))\n                            p))))\n       \
    \             (is_equal_to_sum_even (- n i))))))))", "  (local ((define (iter\
    \ (n i)\n           (if (> n (* 4 i))\n               (if (= n (+ i (+ i 2 (+\
    \ i 4 (+ i 6))))\n                   #t\n                   (iter n (+ i 2))\n\
    \                   )\n               #f\n               )\n           )\n   \
    \        )\n          )\n    (iter n 2)\n    )\n  )\n", "  (and\n   (even? n)\n\
    \   (or\n    (and\n     (equal? (remainder n 2) 0)\n     (equal? (remainder n\
    \ 4) 0))\n    (and\n     (equal? (remainder n 2) 0)\n     (equal? (remainder n\
    \ 4) 2)))))\n", "  (define (is_equal_to_sum_even-helper n sum i)\n    (cond ((>\
    \ sum n) #f)\n          ((= sum n) #t)\n          ((= i n) #f)\n          (else\
    \ (is_equal_to_sum_even-helper n (+ sum i) (+ i 2)))))\n  (is_equal_to_sum_even-helper\
    \ n 0 2))\n", "  (define (is_divisible_by_4 n) (= (remainder n 4) 0))\n  (cond\
    \ [(< n 8) false]\n        [(= n 8) true]\n        [(is_divisible_by_4 n) true]\n\
    \        [else false]))\n", "  (if (= 0 (modulo n 2))\n      (if (= 4 (length\
    \ (build-list 4 n)))\n          #t\n          #f)\n      #f))\n", "  (define (generate-seq\
    \ start end)\n    (if (= start end)\n        (list start)\n        (cons start\
    \ (generate-seq (+ start 1) end))))\n  (define (is-sum-of? n seq)\n    (cond\n\
    \      [(null? seq) (display n) #f]\n      [(= n 0) #t]\n      [(< n 0) #f]\n\
    \      [else (or (is-sum-of? (- n (car seq)) (cdr seq))\n                (is-sum-of?\
    \ n (cdr seq)))]))\n  (is-sum-of? n (generate-seq 2 (+ 2 (* 2 n)))))\n", "  (and\
    \ (> n 0)\n       (and (even? n)\n            (is_equal_to_sum_even_1 n (quotient\
    \ n 2) 0 0))\n       (and (odd? n)\n            (is_equal_to_sum_even_1 (add1\
    \ n) (quotient n 2) 0 0))))\n", "  (cond ((<= n 0) #f)\n        ((= (modulo n\
    \ 2) 1) #f)\n        ((= n 4) #f)\n        ((>= n 4) (or (is_equal_to_sum_even\
    \ (- n 4))\n                      (is_equal_to_sum_even (- n 6))\n           \
    \           (is_equal_to_sum_even (- n 8))))))\n", "  (define (helper acc)\n \
    \   (if (zero? acc)\n        #t\n        (if (odd? acc)\n            #f\n    \
    \        (helper (- acc 2)))))\n  (helper n))\n", "  (cond\n    [(= n 0) #t]\n\
    \    [(or (odd? n) (&lt; n 0)) #f]\n    [else (is_equal_to_sum_even (- n 2))]))\n\
    </code>\n", "    (and\n     (= n (* 2 (+ (* 2 2) (* 2 2) (* 2 2) (* 2 2))))\n\
    \     (<= n (* 2 (+ (* 2 2) (* 2 2) (* 2 2) (* 2 2))))\n     (or\n      (= n 4)\n\
    \      (= n 6)\n      (= n 8)\n      (= n 10)\n      (= n 12)\n      (= n 14)\n\
    \      (= n 16)\n      (= n 18)\n      (= n 20)\n      (= n 22)\n      (= n 24)\n\
    \      (= n 26)\n      (= n 28)\n      (= n 30)\n      (= n 32)\n      (= n 34)\n\
    \      (= n 36)\n      (= n 38)\n      (= n 40)\n      (= n 42)\n      (= n 44)\n\
    \      (= n 46)\n      (= n 48)\n      (= n 50)\n      (= n 52)\n      (= n 54)\n\
    \      (= n 56)\n      (= n 58)\n      (= n 60)\n      (= n 62)\n      (= n 64)\n\
    \      (= n 66)\n      (= n 68)\n      (= n 70)\n      (= n 72)\n      (= n 74)\n\
    \      (= n 76)\n      (= n 78)\n      (= n 80)\n      (= n 82)\n      (= n 84)\n\
    \      (= n 86)\n      (= n 88)\n      (= n 90)\n      (= n 92)\n      (= n 94)\n\
    \      (= n 96)\n      (= n 98)\n      (= n 100)\n      (= n 102)\n      (= n\
    \ 104)\n      (= n 106)\n      (= n 108)\n      (= n 110)\n      (= n 112)\n \
    \     (= n 114)\n      (= n 116)\n      (= n 118)\n      (= n 120)\n      (= n\
    \ 122)\n      (= n 124)\n      (= n 126)\n      (= n 128)\n      (= n 130)\n \
    \     (= n 132)\n      (= n 134)\n      (= n 136)\n      (= n 138)\n      (= n\
    \ 140)\n      (= n 142)\n      (= n 144)\n      (= n 146)\n      (= n 148)\n \
    \     (= n 150)\n      (= n 152)\n      (= n 154)\n", "  (define (sum-of-4-evens\
    \ num count total)\n    (cond [(= count 4) (= num total)]\n          [(> num total)\n\
    \           (and\n            (even? num)\n            (sum-of-4-evens (- num\
    \ 2) (+ count 1) (+ total num)))]\n          [else (sum-of-4-evens (- num 2) count\
    \ total)]))\n  (sum-of-4-evens n 0 0))\n", "  (let loop ([x n] [y 0] [z 0] [w\
    \ 0])\n    (cond\n      [(= x 0) (and (not (= y 0)) (not (= z 0)) (not (= w 0)))]\n\
    \      [(= x 2) (loop (- x 2) (+ y 2) z w)]\n      [(= x 4) (or (loop (- x 4)\
    \ (+ y 4) z w) (loop (- x 2) y (+ z 2) w))]\n      [(= x 6) (or (loop (- x 6)\
    \ (+ y 6) z w) (loop (- x 4) y (+ z 4) w) (loop (- x 2) y z (+ w 2)))]\n     \
    \ [(= x 8) (or (loop (- x 8) (+ y 8) z w) (loop (- x 6) y (+ z 6) w) (loop (-\
    \ x 4) y z (+ w 4)) (loop (- x 2) y z w))])))\n", "  (and\n   (>= n 16)\n   (is_equal_to_sum_even_helper\
    \ n 4 1)\n   )\n  )\n", '  (equal? (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref (list-ref
    (list-ref (list-', "  (and (= n (sum-even (list-even n)))\n       (= n (+ (* 2\
    \ (car (list-even n))) (* 2 (cadr (list-even n))) (* 2 (caddr (list-even n)))\
    \ (* 2 (cadddr (list-even n)))))))\n", "  (define sum 0)\n  (let ((counter 0))\n\
    \    (define (inner n)\n      (if (> n sum)\n          (if (= n (+ 2 (* 4 counter)))\n\
    \              #t\n              (begin\n                (set! sum (+ sum 2))\n\
    \                (set! counter (+ counter 1))\n                (inner n)))))\n\
    \    (inner n)))", "  (define (loop sum count)\n    (cond ((= count 4) (if (=\
    \ sum n) #t #f))\n          ((= (modulo sum 2) 0) (loop (+ sum (rand 5)) (+ count\
    \ 1)))\n          (else (loop sum count))))\n  (loop 0 0))\n", "  (define (even?\
    \ n)\n    (= (remainder n 2) 0))\n  (define (inner n acc)\n    (if (zero? n)\n\
    \        acc\n        (inner (- n (car acc)) (cons (+ 2 (car acc)) acc))))\n \
    \ (define (outer n)\n    (if (zero? n)\n        #f\n        (if (even? n)\n  \
    \          (inner n (list 0))\n            (outer (- n 1)))))\n  (outer n))\n",
  "  (define (is_equal_to_sum_even-iter n k)\n    (if (equal? n 0)\n        #t\n \
    \       (if (and (equal? n (* 2 k)) (>= k 4))\n            #t\n            (is_equal_to_sum_even-iter\
    \ (- n (* 2 k)) (+ k 1)))))\n  (is_equal_to_sum_even-iter n 0))\n```\n\n#### Building\
    \ function increment_all\n\n```racket\n#lang racket\n", "  (cond [(zero? n) #f]\n\
    \        [(even? n) #t]\n        [else (is_equal_to_sum_even (sub1 n))]))\n```\n\
    \n### Question 1.5\n```racket\n#lang racket\n", "  (equal? n (+ (* 2 (nth-even\
    \ 1)) (* 2 (nth-even 2)) (* 2 (nth-even 3)) (* 2 (nth-even 4)))))\n", "  (define\
    \ (is_equal_to_sum_even n sofar)\n    (cond [(= n 0)\n           #t]\n       \
    \   [(< n 0)\n           #f]\n          [(even? n)\n           (is_equal_to_sum_even\
    \ (- n 2) (+ sofar 1))]\n          [else\n           (is_equal_to_sum_even (-\
    \ n 1) (+ sofar 1))]))\n  (is_equal_to_sum_even n 0))\n", "  (define (inner n\
    \ i)\n    (cond\n      [(= i 4) #t]\n      [(= n 0) (inner n (+ i 1))]\n     \
    \ [(= (remainder n 2) 0) (inner (- n 2) (+ i 1))]\n      [else #f]))\n  (inner\
    \ n 0))\n", "  (define (is_equal_to_sum_even-helper n min max)\n    (cond [(zero?\
    \ min) #f]\n          [(= n (+ min max)) #t]\n          [else (is_equal_to_sum_even-helper\
    \ n (+ min 2) (+ max 2))]))\n  (is_equal_to_sum_even-helper n 2 4))\n", "  (define\
    \ (is_equal_to_sum_even-helper n sum acc)\n    (if (or (zero? n) (zero? sum))\n\
    \        (if (= n sum) #t #f)\n        (is_equal_to_sum_even-helper (- n 2) (-\
    \ sum 2) (+ acc 1))\n        (is_equal_to_sum_even-helper (- n 2) sum acc)))\n\
    \  (is_equal_to_sum_even-helper n n 0))\n", "  (cond ((> n 10) #f)\n        ((<\
    \ n 0) #f)\n        ((= n 10) #t)\n        ((even? n) #t)\n        (else (is_equal_to_sum_even\
    \ (- n 2)))))", "  (if (= n 8)\n      #t\n      #f))\n```\n\n**1.1.2** Evaluate\
    \ the following logical operators.\n\n```racket", "  (if (= n (list-sum (list_even_4\
    \ n)))\n      #t\n      #f))\n", "  ;; base case\n  (cond ((= n 0) (display '#t))\n\
    \        ((> n 0) (display (string-append (number->string n) '\" = \"))\n    \
    \            (is_equal_to_sum_even (sub1 n)))))", "  (define (helper n acc)\n\
    \    (if (= n 0)\n        (and (= acc 4) #t)\n        (and (even? n)\n       \
    \      (helper (- n 1) (+ acc 1)))))\n  (helper n 0))\n", "  (if (and (even? n)\n\
    \           (= 4 (length (filter even? (divisors n)))))\n      #t\n      #f))\n",
  "  (local ((define (even? n) (= (remainder n 2) 0)))\n    (local ((define (evens-from-start\
    \ n)\n              (if (even? n) (list n) (evens-from-start (+ n 1)))))\n   \
    \   (define (is-sum-of-four-evens? ns total)\n        (cond ((and (null? ns) (=\
    \ total n)) #t)\n              ((and (null? ns) (not (= total n))) #f)\n     \
    \         ((and (not (null? ns)) (> total n)) #f)\n              ((and (not (null?\
    \ ns)) (= total n)) #t)\n              ((and (not (null? ns)) (< total n)) (is-sum-of-four-evens?\
    \ (cdr ns) (+ total (car ns))))))\n      (is-sum-of-four-evens? (evens-from-start\
    \ 0) 0))))", "  (letrec\n    ([get-sum-even (lambda (num)\n                  \
    \   (local\n                       ([define sum 0]\n                        [define\
    \ i num])\n                       (let loop ([i num])\n                      \
    \   (if (or (= i 0) (= i -1))\n                             sum\n            \
    \                 (loop (- i 2) (+ sum i))))))])\n    (and\n      (= 4 (count-sum-even\
    \ n))\n      (= (get-sum-even n) n))))\n", "  (define (find-sum m)\n    (define\
    \ (find-remaining m a b c d)\n      (cond [(= m a) #t]\n            [(= m (+ a\
    \ b)) #t]\n            [(= m (+ a b c)) #t]\n            [(= m (+ a b c d)) #t]\n\
    \            [(= m (+ a b d)) #t]\n            [(= m (+ a c d)) #t]\n        \
    \    [(= m (+ b c d)) #t]\n            [(= m (+ a c)) #t]\n            [(= m (+\
    \ b d)) #t]\n            [(= m (+ b c)) #t]\n            [(= m (+ a d)) #t]\n\
    \            [else #f]))\n    (define (loop m i j k)\n      (cond [(= m (+ i j\
    \ k)) #t]\n            [(= m (+ i j)) #t]\n            [(= m (+ i k)) #t]\n  \
    \          [(= m (+ j k)) #t]\n            [(= m i) #t]\n            [(= m j)\
    \ #t]\n            [(= m k) #t]\n            [(> i (+ m 1)) #f]\n            [(>\
    \ j (+ m 1)) (loop m (+ i 2) (+ i 2) (+ i 2))]\n            [(> k (+ m 1)) (loop\
    \ m i (+ j 2) (+ j 2))]\n            [else (or (find-remaining m i j k (+ k 2))\n\
    \                      (loop m i j (+ k 2)))]))\n    (cond [(= n 4) #t]\n    \
    \      [(even? n) (loop n 2 2 2)]\n          [else #f]))\n  (find-sum n))\n",
  "  (define (helper sum n)\n    (cond\n      [(= n 0) (= sum n)]\n      [(odd? n)\
    \ (helper sum (- n 1))]\n      [else (or (helper sum (- n 1))\n              \
    \  (helper (+ sum n) (- n 2)))]))\n  (helper 0 n))\n", "  (cond ((> n 0)\n   \
    \      (cond ((even? n)\n                (= n (add-even-factors n)))\n       \
    \        (else #f)))\n        (else #f)))\n", "  (define (is_equal_to_sum_even_iter\
    \ n i acc)\n    (cond\n      ((= n (+ (sqr i) (sqr (+ i 2)) (sqr (+ i 4)) (sqr\
    \ (+ i 6)))) #t)\n      ((and (< i (/ n 4)) (= (mod n 2) 0)) (is_equal_to_sum_even_iter\
    \ n (+ i 2) #f))\n      (else #f)))\n  (is_equal_to_sum_even_iter n 2 #f))\n```\n",
  "  (define (even-sum n k)\n    (if (= n 0)\n        (= k 4)\n        (and (<= k\
    \ 4)\n             (or (even-sum (- n 2) (+ k 1))\n                 (even-sum\
    \ n k)))))\n  (even-sum n 0))\n```\n\nThe most important functions are `even-sum`\
    \ and `is_equal_to_sum_even`. `even-sum` is a recursive function that computes\
    \ all the numbers from 0 to n and evaluates them. Each time `even-sum` is called,\
    \ it recursively computes the possibilities until we reach `n`. \n\n`is_equal_to_sum_even`\
    \ is the function that calls `even-sum` and checks whether the result is true\
    \ or false. The `is_equal_to_sum_even`  function takes an input n and calls `even-sum`\
    \ with `k = 0`. Then it checks if the result of `even-sum` (which is n) is equal\
    \ to 0, and returns a boolean value.\n\n#### 2.3.3 Conclusion and Future work\n\
    \nThe main goal of this project was to get familiar with Scheme and to implement\
    \ a model of a real-world problem. We wanted to show how a brute-force, recursive\
    \ solution can help us solve a complex problem. In this case, we had to solve\
    \ a problem for only one level of abstraction, with the possibility of adding\
    \ more levels.\n\nIt would be more complicated to solve this problem if we had\
    \ to write a general algorithm that works for any number of positive even numbers\
    \ that sum up to n. \n\nWe know that this algorithm is not optimal, because it\
    \ doesn't use any optimization techniques. If we had to work with even bigger\
    \ numbers, the brute-force approach might not be the best solution. We would have\
    \ to use optimization techniques such as memoization, parallelization or heuristics.\
    \ \n\n#### 2.3.4 References\n\n[1] K. H. Rosen, _Discrete Mathematics and Its\
    \ Applications_, 7th ed. New York: McGraw-Hill, 2012, pp. 98\u2013102.\n\n[2]\
    \ J. C. R. Bennett, _Discrete Mathematics_, 1st ed. Pearson Education, 2004, pp.\
    \ 116\u2013117.\n\n[3] D. J. Daley and D", "  (define (helper n a b c d)\n   \
    \ (cond\n      [(and (and (= n (+ a b c d)) (>= a 0) (>= b 0) (>= c 0) (>= d 0))\
    \ (even? a) (even? b) (even? c) (even? d)) #t]\n      [(> n (+ a b c d)) (or (helper\
    \ n (+ a 2) b c d) (helper n a (+ b 2) c d) (helper n a b (+ c 2) d) (helper n\
    \ a b c (+ d 2)))]\n      [else #f]))\n  (helper n 0 0 0 0))\n", "  (cond ((equal?\
    \ n (+ (car (filter even? (subsets (range 1 n))))\n                      (car\
    \ (filter even? (subsets (range 1 n))))\n                      (car (filter even?\
    \ (subsets (range 1 n))))\n                      (car (filter even? (subsets (range\
    \ 1 n))))))\n         #t)\n        (else #f)))", "  (and (even? n) (for/or ([i\
    \ (in-range 0 (/ n 2))]\n                         [j (in-range 0 (/ n 2))]\n \
    \                        [k (in-range 0 (/ n 2))]\n                         [l\
    \ (in-range 0 (/ n 2))])\n                      (= n (+ (* 2 i) (* 2 j) (* 2 k)\
    \ (* 2 l)))))\n", "  (define (is_equal_to_sum_even-acc i sum)\n    (cond [(>=\
    \ sum n) #f]\n          [(and (= sum n) (= i 0)) #t]\n          [else (is_equal_to_sum_even-acc\
    \ (- i 1) (+ sum (* 2 i)))]))\n  (is_equal_to_sum_even-acc 8 0))\n", "  (cond\n\
    \    [(<= n 0) #f]\n    [(= n 4) #t]\n    [else (or (is_equal_to_sum_even (- n\
    \ 2))\n              (is_equal_to_sum_even (- n 4))\n              (is_equal_to_sum_even\
    \ (- n 6))\n              (is_equal_to_sum_even (- n 8)))]))\n```\n\n```racket\n\
    #lang racket\n", "  (define (equals? n sum)\n    (if (= n sum) #t #f))\n  (define\
    \ (sum_even n sum i)\n    (if (= i n)\n        (equals? n sum)\n        (if (and\
    \ (>= i n)\n                 (= (modulo n 2) 0))\n            (sum_even (quotient\
    \ (- n i) 2) (+ sum i) i)\n            (sum_even n sum (+ i 2)))))\n  (sum_even\
    \ n 0 0))\n", "  (define (sum-even-r n i)\n    (cond\n      [(= i n) #t]\n   \
    \   [(= n i i) #f]\n      [(= (remainder n i) 0)\n       (define (sum-even-l n\
    \ i j)\n         (cond\n           [(= j n) #t]\n           [(= n j i) #f]\n \
    \          [(and\n             (sum-even-r (- n i j) (+ i 2))\n             (sum-even-l\
    \ n i (+ j 2)))\n            #t]\n           [else #f]))\n       (sum-even-l n\
    \ i (+ i 2))]\n      [else (sum-even-r n (+ i 2))]))\n  (sum-even-r n 2))\n",
  "  (is_equal_to_sum_even_help n 0 4))\n", "  (cond [(= n 4) #f]\n        [(= n 6)\
    \ #f]\n        [(= n 8) #t]\n        [else (is_equal_to_sum_even (- n 2))]))\n",
  "  (and\n   (even? n)\n   (is_equal_to_sum_even-helper n 4)))\n", "  (if (not (even?\
    \ n))\n      #f\n      (for/or ([k n]\n               [i n]\n               [j\
    \ n]\n               [l n])\n        (cond [(= (+ k i j l) n) #t]\n          \
    \    [else #f]))))\n", "    (cond [(zero? n) #f]\n          [(even? n) (and (and\
    \ (and (and (> n 2) (> n 6)) (> n 10)) (> n 14)) (> n 18))]\n          [else (is_equal_to_sum_even\
    \ (- n 1))]))\n", "  (is_equal_to_sum_even_helper n 0 0))\n", "  (and (even? n)\n\
    \       (not (= (next-odd (- n 2)) 2))\n       (not (= (next-odd (- n 4)) 2))\n\
    \       (not (= (next-odd (- n 6)) 2))\n       (not (= (next-odd (- n 8)) 2))))\n",
  "  (let ([loops 4])\n    (define (is_equal_to_sum_even_iter sum counter)\n     \
    \ (cond\n        [(= counter loops) (= sum n)]\n        [(= (modulo sum 2) 0)\
    \ (is_equal_to_sum_even_iter (+ sum 2) (+ counter 1))]\n        [else (is_equal_to_sum_even_iter\
    \ (+ sum 1) counter)]))\n    (is_equal_to_sum_even_iter 2 1)))\n", "  (define\
    \ (iter prev n)\n    (cond ((< n (* 4 prev)) #f)\n          ((= n (* 4 prev))\
    \ #t)\n          (else (iter (+ prev 2) n))))\n  (if (= n 0) #f (iter 2 n)))\n",
  "  (let loop ([i 0] [j 2] [k 4] [l 6])\n    (if (and (even? n)\n             (or\
    \ (= n (+ i j k l))\n                 (= n (+ i j k l 7))))\n        #t\n    \
    \    (if (= i n)\n            #f\n            (loop (+ i 2) (+ j 2) (+ k 2) (+\
    \ l 2))))))\n", "  (cond\n    [(= n 4) #f]\n    [(= n 6) #f]\n    [(= n 8) #t]\n\
    \    [(= n 10) #f]\n    [(= n 12) #t]\n    [(= n 14) #f]\n    [(= n 16) #t]\n\
    \    [(= n 18) #f]\n    [(= n 20) #t]\n    [(= n 22) #f]\n    [(= n 24) #t]\n\
    \    [(= n 26) #f]\n    [(= n 28) #t]\n    [(= n 30) #f]\n    [(= n 32) #t]\n\
    \    [(= n 34) #f]\n    [(= n 36) #t]\n    [(= n 38) #f]\n    [(= n 40) #t]\n\
    \    [(= n 42) #f]\n    [(= n 44) #t]\n    [(= n 46) #f]\n    [(= n 48) #t]\n\
    \    [(= n 50) #f]\n    [(= n 52) #t]\n    [(= n 54) #f]\n    [(= n 56) #t]\n\
    \    [(= n 58) #f]\n    [(= n 60) #t]\n    [(= n 62) #f]\n    [(= n 64) #t]\n\
    \    [(= n 66) #f]\n    [(= n 68) #t]\n    [(= n 70) #f]\n    [(= n 72) #t]\n\
    \    [(= n 74) #f]\n    [(= n 76) #t]\n    [(= n 78) #f]\n    [(= n 80) #t]\n\
    \    [(= n 82) #f]\n    [(= n 84) #t]\n    [(= n 86) #f]\n    [(= n 88) #t]\n\
    \    [(= n 90) #f]\n    [(= n 92) #t]\n    [(= n 94) #f]\n    [(= n 96) #t]\n\
    \    [(= n 98) #f]\n    [(= n 100) #t]\n    [(= n 102) #f]\n    [(= n 104) #",
  "  (cond ((= n 1) #f)\n        ((= n 2) #f)\n        ((= n 3) #f)\n        ((= n\
    \ 4) #f)\n        ((= n 5) #f)\n        ((= n 6) #f)\n        ((= n 7) #f)\n \
    \       ((= n 8) #t)\n        ((= n 9) #f)\n        ((= n 10) #f)\n        ((=\
    \ n 11) #f)\n        ((= n 12) #t)\n        ((= n 13) #f)\n        ((= n 14) #f)\n\
    \        ((= n 15) #f)\n        ((= n 16) #t)\n        ((= n 17) #f)\n       \
    \ ((= n 18) #f)\n        ((= n 19) #f)\n        ((= n 20) #t)\n        ((= n 21)\
    \ #f)\n        ((= n 22) #f)\n        ((= n 23) #f)\n        ((= n 24) #t)\n \
    \       ((= n 25) #f)\n        ((= n 26) #f)\n        ((= n 27) #f)\n        ((=\
    \ n 28) #t)\n        ((= n 29) #f)\n        ((= n 30) #f)\n        ((= n 31) #f)\n\
    \        ((= n 32) #t)\n        ((= n 33) #f)\n        ((= n 34) #f)\n       \
    \ ((= n 35) #f)\n        ((= n 36) #t)\n        ((= n 37) #f)\n        ((= n 38)\
    \ #f)\n        ((= n 39) #f)\n        ((= n 40) #t)\n        ((= n 41) #f)\n \
    \       ((= n 42) #f)\n        ((= n 43) #f)\n        ((= n 44) #t)\n        ((=\
    \ n 45) #f)\n        ((= n 46) #f)\n        ((= n 47) #f)\n        ((= n 48) #t)\n\
    \        ((= n 49) #f)\n        ((= n 50) #f)\n        ((= n 51) #f)", "  (and\
    \ (exact-nonnegative-integer? n)\n       (list? (find-4-numbers n))))\n", "  (cond\n\
    \    [(even? n) #t]\n    [(and (positive? n) (odd? n))\n     (define (aux n i)\n\
    \       (cond\n         [(> i (- n 4)) #f]\n         [(= n (+ i (+ (* 2 i) (*\
    \ 2 (+ i i)) (* 2 (+ i i i)) (* 2 (+ i i i i))))]\n         [else (aux n (+ i\
    \ 1))]))\n     (aux n 1)]\n    [else #f]))\n", "  (and (even? n)\n       (integer?\
    \ (sqrt n))\n       (exists (lambda (x)\n                 (exists (lambda (y)\n\
    \                           (exists (lambda (z)\n                            \
    \         (exists (lambda (w)\n                                              \
    \ (= n (+ x y z w)))\n                                             (range 2 n\
    \ 2)))\n                                     (range 2 n 2)))\n               \
    \            (range 2 n 2)))\n                 (range 2 n 2))))\n```\n\n## Day\
    \ 49:\n\n```#lang racket\n", "  (cond ((zero? n) #f)\n        ((= n 4) #t)\n \
    \       ((= n 12) #t)\n        ((= n 16) #t)\n        ((= n 20) #t)\n        ((=\
    \ n 24) #t)\n        ((= n 28) #t)\n        ((= n 32) #t)\n        ((= n 36) #t)\n\
    \        ((= n 40) #t)\n        ((= n 44) #t)\n        ((= n 48) #t)\n       \
    \ ((= n 52) #t)\n        ((= n 56) #t)\n        ((= n 60) #t)\n        ((= n 64)\
    \ #t)\n        ((= n 68) #t)\n        ((= n 72) #t)\n        ((= n 76) #t)\n \
    \       ((= n 80) #t)\n        ((= n 84) #t)\n        ((= n 88) #t)\n        ((=\
    \ n 92) #t)\n        ((= n 96) #t)\n        ((= n 100) #t)\n        ((= n 104)\
    \ #t)\n        ((= n 108) #t)\n        ((= n 112) #t)\n        ((= n 116) #t)\n\
    \        ((= n 120) #t)\n        ((= n 124) #t)\n        ((= n 128) #t)\n    \
    \    ((= n 132) #t)\n        ((= n 136) #t)\n        ((= n 140) #t)\n        ((=\
    \ n 144) #t)\n        ((= n 148) #t)\n        ((= n 152) #t)\n        ((= n 156)\
    \ #t)\n        ((= n 160) #t)\n        ((= n 164) #t)\n        ((= n 168) #t)\n\
    \        ((= n 172) #t)\n        ((= n 176) #t)\n        ((= n 180) #t)\n    \
    \    ((= n 184) #t)\n        ((= n 188) #t)\n        ((= n 192) #t)\n        ((=\
    \ n 196) #t)\n        ((= n 200) #t)\n        ((= n 204) #t)", "  (cond\n    [(=\
    \ n 0) #t]\n    [(= n 2) #f]\n    [(= n 4) #t]\n    [(= n 6) #f]\n    [(= n 8)\
    \ #t]\n    [(= n 10) #f]\n    [(= n 12) #t]\n    [(= n 14) #f]\n    [(= n 16)\
    \ #t]\n    [(= n 18) #f]\n    [(= n 20) #t]\n    [(= n 22) #f]\n    [(= n 24)\
    \ #t]\n    [(= n 26) #f]\n    [(= n 28) #t]\n    [(= n 30) #f]\n    [(= n 32)\
    \ #t]\n    [(= n 34) #f]\n    [(= n 36) #t]\n    [(= n 38) #f]\n    [(= n 40)\
    \ #t]\n    [(= n 42) #f]\n    [(= n 44) #t]\n    [(= n 46) #f]\n    [(= n 48)\
    \ #t]\n    [(= n 50) #f]\n    [(= n 52) #t]\n    [(= n 54) #f]\n    [(= n 56)\
    \ #t]\n    [(= n 58) #f]\n    [(= n 60) #t]\n    [(= n 62) #f]\n    [(= n 64)\
    \ #t]\n    [(= n 66) #f]\n    [(= n 68) #t]\n    [(= n 70) #f]\n    [(= n 72)\
    \ #t]\n    [(= n 74) #f]\n    [(= n 76) #t]\n    [(= n 78) #f]\n    [(= n 80)\
    \ #t]\n    [(= n 82) #f]\n    [(= n 84) #t]\n    [(= n 86) #f]\n    [(= n 88)\
    \ #t]\n    [(= n 90) #f]\n    [(= n 92) #t]\n    [(= n 94) #f]\n    [(= n 96)\
    \ #t]\n    [(= n 98) #f]\n    [(= n 100) #", "  (define (is_equal_to_sum_even_of_helper\
    \ n evens)\n    (cond ((zero? n) (zero? (length evens)))\n          ((= n (apply\
    \ + evens)) (and (number? (car evens))\n                                     \
    \ (number? (cadr evens))\n                                      (number? (caddr\
    \ evens))\n                                      (number? (cadddr evens))))\n\
    \          (else (is_equal_to_sum_even_of_helper n (append evens (list (sub1 n)))))))\n\
    \  (is_equal_to_sum_even_of_helper n '(2 2 2 2)))\n", "  (define (loop i count\
    \ acc)\n    (cond ((= i n) (and (= 4 count) #t))\n          ((&gt; i n) #f)\n\
    \          ((and (even? i) (&lt; count 4)) (loop (+ i 2) (+ count 1) (+ acc i)))\n\
    \          (else (loop (+ i 2) count acc))))\n  (loop 2 0 0))\n", "  (and (even?\
    \ n) (= 4 (length (subsets-of-size 4 (evens-upto n))))))\n", "  (if (or (< n 8)\
    \ (= n 16))\n      #f\n      (equal? (list n) (append (list n) (sum_of_even n\
    \ 0)))))\n", "  (cond\n    [(= n 4) #f]\n    [(= n 6) #f]\n    [(= n 8) #t]\n\
    \    [(= n 10) #f]\n    [(= n 12) #t]\n    [(= n 14) #f]\n    [(= n 16) #t]\n\
    \    [(= n 18) #f]\n    [(= n 20) #t]\n    [(= n 22) #f]\n    [(= n 24) #t]\n\
    \    [(= n 26) #f]\n    [(= n 28) #t]\n    [(= n 30) #f]\n    [(= n 32) #t]\n\
    \    [(= n 34) #f]\n    [(= n 36) #t]\n    [(= n 38) #f]\n    [(= n 40) #t]\n\
    \    [(= n 42) #f]\n    [(= n 44) #t]\n    [(= n 46) #f]\n    [(= n 48) #t]\n\
    \    [(= n 50) #f]\n    [(= n 52) #t]\n    [(= n 54) #f]\n    [(= n 56) #t]\n\
    \    [(= n 58) #f]\n    [(= n 60) #t]\n    [(= n 62) #f]\n    [(= n 64) #t]\n\
    \    [(= n 66) #f]\n    [(= n 68) #t]\n    [(= n 70) #f]\n    [(= n 72) #t]\n\
    \    [(= n 74) #f]\n    [(= n 76) #t]\n    [(= n 78) #f]\n    [(= n 80) #t]\n\
    \    [(= n 82) #f]\n    [(= n 84) #t]\n    [(= n 86) #f]\n    [(= n 88) #t]\n\
    \    [(= n 90) #f]\n    [(= n 92) #t]\n    [(= n 94) #f]\n    [(= n 96) #t]\n\
    \    [(= n 98) #f]\n    [(= n 100) #t]\n    [(= n 102) #f]\n    [(= n 104) #",
  "  ;; Check that n is even\n  (define n-is-even? (zero? (remainder n 2)))\n  ;;\
    \ Check that n is greater than 0\n  (define n-is-positive? (not (negative? n)))\n\
    \  ;; Check that n is greater than 0 and that n is even\n  (and n-is-even? n-is-positive?)\n\
    \  ;; Check that n is greater than 0 and that n is even and that n is greater\
    \ than or equal to 8\n  (and n-is-even? n-is-positive? (not (negative? (- n 8))))\n\
    \  ;; Check that n is greater than 0 and that n is even and that n is greater\
    \ than or equal to 16\n  (and n-is-even? n-is-positive? (not (negative? (- n 16))))\n\
    \  ;; Check that n is greater than 0 and that n is even and that n is greater\
    \ than or equal to 24\n  (and n-is-even? n-is-positive? (not (negative? (- n 24))))\n\
    \  ;; Check that n is greater than 0 and that n is even and that n is greater\
    \ than or equal to 32\n  (and n-is-even? n-is-positive? (not (negative? (- n 32))))\n\
    \  ;; Final check that n is greater than 0 and that n is even and that n is greater\
    \ than or equal to 8 and that n is less than or equal to 32\n  (and n-is-even?\
    \ n-is-positive? (not (negative? (- n 8))) (not (negative? (- 32 n))))\n)\n",
  "  (cond\n    [(zero? n) #f]\n    [(even? n) (is_equal_to_sum_even (- n 2))]\n \
    \   [else (is_equal_to_sum_even (- n 3))]))\n", "  (define (even_sum n acc)\n\
    \    (cond\n      ((= n acc) #t) ;; is the input number n?\n      ((&gt; n acc)\n\
    \       (cond\n         ((= 4 acc) (even_sum n 0)) ;; do we have exactly 4 positive\
    \ even numbers in the accumulator?\n         ((= 0 (modulo n 2)) (even_sum n (+\
    \ n acc))) ;; next positive even number\n         (else (even_sum n acc)))) ;;\
    \ not a positive even number, just add to accumulator\n      (else #f))) ;; all\
    \ solutions tried\n  (even_sum n 0))\n", "  (cond\n    [(= n 4) #f]\n    [(= n\
    \ 6) #f]\n    [(= n 8) #t]\n    [else (is_equal_to_sum_even (- n 2))]))\n", " \
    \ ;; TODO: Remove the \"up-arrow\" character (^) from the following line and write\
    \ your code below it.\n  ^\n  )\n", "  (define (is_equal_to_sum_even_iter n sum\
    \ i)\n    (cond ((= sum n) #t)\n          ((>= sum n) #f)\n          ((= i 4)\
    \ #f)\n          (else (is_equal_to_sum_even_iter n (+ sum (* 2 (add1 i))) (add1\
    \ i)))))\n  (is_equal_to_sum_even_iter n 0 0))\n", "  (define (count num)\n  \
    \  (cond [(= num 0) 0]\n          [(even? num) (+ 1 (count (- num 2)))]\n    \
    \      [else (count (- num 1))]))\n  (and (even? n)\n       (equal? 4 (count n))))\n\
    ```\n\n### Task 4\n\nWrite a function `is_equal_to_sum_odd` which works just like\
    \ task 3, but for odd numbers.\n\n### Task 5\n\nWrite a function which returns\
    \ true if the given number is a power of 3. `(is_power_of_3 512)` should return\
    \ true and `(is_power_of_3 513)` should return false.\n\n### Task 6\n\nWrite a\
    \ function which returns true if the given number is a power of n. `(is_power_of_n\
    \ 2 10)` should return true, `(is_power_of_n 2 11)` should return false.\n\n###\
    \ Task 7\n\nWrite a function which takes a list and returns true if the given\
    \ list is a palindrome.\n\n### Task 8\n\nWrite a function which takes a list and\
    \ returns true if the given list is a palindrome. It should do so without explicitly\
    \ reversing the list.", "  (define (inner-is-equal-to-sum-even i sum)\n    (cond\
    \ ((= sum n) #t)\n          ((or (= i n) (&gt; sum n)) #f)\n          (else (inner-is-equal-to-sum-even\
    \ (+ i 2) (+ sum i)))))\n  (inner-is-equal-to-sum-even 2 0))\n", "  (cond\n  \
    \  [(= n 2) #f]\n    [(or\n      (= n 4)\n      (= n 6)\n      (= n 8)\n     \
    \ (= n 10)\n      (= n 12)\n      (= n 14)\n      (= n 16)\n      (= n 18)\n \
    \     (= n 20)\n      (= n 22)\n      (= n 24)\n      (= n 26)\n      (= n 28)\n\
    \      (= n 30)\n      (= n 32)\n      (= n 34)\n      (= n 36)\n      (= n 38)\n\
    \      (= n 40)\n      (= n 42)\n      (= n 44)\n      (= n 46)\n      (= n 48)\n\
    \      (= n 50)\n      (= n 52)\n      (= n 54)\n      (= n 56)\n      (= n 58)\n\
    \      (= n 60)\n      (= n 62)\n      (= n 64)\n      (= n 66)\n      (= n 68)\n\
    \      (= n 70)\n      (= n 72)\n      (= n 74)\n      (= n 76)\n      (= n 78)\n\
    \      (= n 80)\n      (= n 82)\n      (= n 84)\n      (= n 86)\n      (= n 88)\n\
    \      (= n 90)\n      (= n 92)\n      (= n 94)\n      (= n 96)\n      (= n 98)\n\
    \      (= n 100)\n      (= n 102)\n      (= n 104)\n      (= n 106)\n      (=\
    \ n 108)\n      (= n 110)\n      (= n 112)\n      (= n 114)\n      (= n 116)\n\
    \      (= n 118)\n      (= n 120)\n      (= n 122)\n      (= n 124)\n      (=\
    \ n 126)\n      (= n 128)\n      (= n 130)\n      (= n 132)\n      (= n 134)\n\
    \      (= n 136)\n      (= n 138)\n      (= n 140)\n      (= n 142)\n      (=\
    \ n 144)\n      (= n 146)\n      (= n 148)\n      (= n 150)\n      (= n 152)\n\
    \      (= n 154)\n      (= n 156)\n      (= n 158)\n      (= n 160)\n      (=\
    \ n 162)\n      (= n 164)\n      (= n 166)\n     ", "  (define (iter n1 n2 n3\
    \ n4 n)\n    (cond\n      ((= n n1) #t)\n      ((< n (+ n1 n2 n3 n4)) #f)\n  \
    \    (else (or (iter (+ n1 2) n2 n3 n4 n)\n                (iter n1 (+ n2 2) n3\
    \ n4 n)\n                (iter n1 n2 (+ n3 2) n4 n)\n                (iter n1\
    \ n2 n3 (+ n4 2) n)))))\n  (iter 0 0 0 0 n))\n", "  (and (even? n) (equal? n (+\
    \ (quotient n 4) (quotient n 4) (quotient n 4) (quotient n 4)))))\n```\n\n```Scheme\n\
    #lang racket\n", "  (define (iter k acc)\n    (cond\n      [(= k 0) (equal? n\
    \ acc)]\n      [(= k 1) #f]\n      [(= k 2) (= n (+ acc 2))]\n      [(= k 3) (and\
    \ (not (= n (+ acc 2)))\n                    (or (= n (+ acc 4))\n           \
    \             (= n (+ acc 6))))]\n      [else (and (not (= n (+ acc 2)))\n   \
    \              (not (= n (+ acc 4)))\n                 (not (= n (+ acc 6)))\n\
    \                 (or (= n (+ acc 8))\n                     (= n (+ acc 10))\n\
    \                     (= n (+ acc 12))\n                     (= n (+ acc 14))))]))\n\
    \  (iter (remainder n 2) 0))\n", "  (define (is_equal_to_sum_even-helper n i l)\n\
    \    (if (= n 0) #t\n      (if (= i 1) (is_equal_to_sum_even-helper n (+ i l)\
    \ l)\n        (or (is_equal_to_sum_even-helper (- n i) (+ i l) l)\n          \
    \  (is_equal_to_sum_even-helper n (+ i l) l)))))\n  (is_equal_to_sum_even-helper\
    \ n 2 2))\n```\n\n```racket\n#lang racket\n", "  (define (is_equal_to_sum_even-number\
    \ m n)\n    (cond ((= m 0) #t)\n          ((= n 0) #f)\n          ((even? n) (is_equal_to_sum_even-number\
    \ (+ m (- n)) (- n 2)))\n          (else (is_equal_to_sum_even-number m (- n 1)))))\n\
    \  (is_equal_to_sum_even-number 0 n))\n", "  (if (< n 8)\n      #f\n      (if\
    \ (even? n)\n          #t\n          (if (odd? n)\n              (is_equal_to_sum_even\
    \ (sub1 n))\n              (is_equal_to_sum_even (sub2 n))))))\n```\n\n``` #lang\
    \ racket\n", "  (define (is_equal_to_sum_even-iter n k accum-sum)\n    (cond [(>\
    \ n (+ accum-sum (* 2 k))) #f]\n          [(= n (+ accum-sum (* 2 k))) #t]\n \
    \         [else (is_equal_to_sum_even-iter n (+ k 1) (+ accum-sum (* 2 k)))]))\n\
    \  (is_equal_to_sum_even-iter n 1 0))\n", "  (define (helper x1 x2 x3 x4)\n  \
    \  (cond\n      [(and (even? x1) (even? x2) (even? x3) (even? x4))\n       (=\
    \ n (+ x1 x2 x3 x4))]\n      [(>= x1 n)\n       #f]\n      [else\n       (or (helper\
    \ (+ x1 2) x2 x3 x4)\n           (helper x1 (+ x2 2) x3 x4)\n           (helper\
    \ x1 x2 (+ x3 2) x4)\n           (helper x1 x2 x3 (+ x4 2)))]))\n  (helper 2 2\
    \ 2 2))\n\n", "  (cond\n    [(= n 0) #t]\n    [(= n 2) #f]\n    [(= n 4) #t]\n\
    \    [(= n 6) #f]\n    [(= n 8) #t]\n    [(= n 10) #f]\n    [(= n 12) #t]\n  \
    \  [(= n 14) #f]\n    [(= n 16) #t]\n    [(= n 18) #f]\n    [(= n 20) #t]\n  \
    \  [(= n 22) #f]\n    [(= n 24) #t]\n    [(= n 26) #f]\n    [(= n 28) #t]\n  \
    \  [(= n 30) #f]\n    [(= n 32) #t]\n    [(= n 34) #f]\n    [(= n 36) #t]\n  \
    \  [(= n 38) #f]\n    [(= n 40) #t]\n    [(= n 42) #f]\n    [(= n 44) #t]\n  \
    \  [(= n 46) #f]\n    [(= n 48) #t]\n    [(= n 50) #f]\n    [(= n 52) #t]\n  \
    \  [(= n 54) #f]\n    [(= n 56) #t]\n    [(= n 58) #f]\n    [(= n 60) #t]\n  \
    \  [(= n 62) #f]\n    [(= n 64) #t]\n    [(= n 66) #f]\n    [(= n 68) #t]\n  \
    \  [(= n 70) #f]\n    [(= n 72) #t]\n    [(= n 74) #f]\n    [(= n 76) #t]\n  \
    \  [(= n 78) #f]\n    [(= n 80) #t]\n    [(= n 82) #f]\n    [(= n 84) #t]\n  \
    \  [(= n 86) #f]\n    [(= n 88) #t]\n    [(= n 90) #f]\n    [(= n 92) #t]\n  \
    \  [(= n 94) #f]\n    [(= n 96) #t]\n    [(= n 98) #f]\n    [(= n 100) #", " \
    \ (and (integer? n) (even? n) (even-sum-numbers n 4)))\n", "  (define (is_equal_to_sum_even-iter\
    \ n lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (= n (sum lst)) (not\
    \ (even? (length lst)))) #f]\n      [(and (= n (sum lst)) (even? (length lst)))\
    \ #t]\n      [else (is_equal_to_sum_even-iter n (cons (first lst) (cons (first\
    \ lst) (rest lst))))]))\n  (is_equal_to_sum_even-iter n '(2)))\n```\n\n```racket\n\
    #lang racket\n", "  (define (helper count n)\n    (cond\n      [(< n (floor count\
    \ 4)) #f]\n      [(equal? n (floor count 4)) #t]\n      [else (helper (+ count\
    \ 2) n)]))\n  (helper 2 n))\n```\n\n### Question 2.\n\n```racket\n#lang racket\n",
  "  ;; It is obvious that number n is less than 4*4=16\n  (cond\n    [(> n 15) false]\n\
    \    [(= n 15) false]\n    [(> n 11) (find_even_numbers n 4)]\n    [(= n 11) false]\n\
    \    [(> n 7) (find_even_numbers n 3)]\n    [(= n 7) false]\n    [(> n 3) (find_even_numbers\
    \ n 2)]\n    [(= n 3) false]\n    [(= n 2) false]\n    [(= n 1) false]\n    [(=\
    \ n 0) true]))\n", "  (cond\n    [(= n 0) #t]\n    [(= n 1) #f]\n    [(= n 2)\
    \ #f]\n    [(= n 3) #f]\n    [(< 4 n)\n     (or (is_equal_to_sum_even (- n 4))\n\
    \         (is_equal_to_sum_even (- n 2)))]\n    [else #f]))\n", "  ;; n cannot\
    \ be even\n  (if (even? n)\n      #f\n      ;; n cannot be less than 8\n     \
    \ (if (< n 8)\n          #f\n          ;; n cannot be divisible by 4\n       \
    \   (if (zero? (modulo n 4))\n              #f\n              ;; n must be greater\
    \ than or equal to 8\n              (if (>= n 8)\n                  #t\n     \
    \             #f)))))\n", "  (let ((total 0)\n        (sum 0))\n    (define (sum-of-even\
    \ n)\n      (cond ((= n total) (if (= total sum) #t #f))\n            ((= n 0)\
    \ (if (= total sum) #t #f))\n            ((odd? n) (sum-of-even (- n 1)))\n  \
    \          (else (+ (sum-of-even (- n 2)) (* 2 n)))))\n    (set! total (+ (/ n\
    \ 2) 1))\n    (define (get-sum n)\n      (cond ((< n 1) (get-sum (+ n 1)))\n \
    \           ((= n 0) sum)\n            ((odd? n) (get-sum (- n 1)))\n        \
    \    (else (+ (get-sum (- n 2)) (* 2 n)))))\n    (set! sum (get-sum total))\n\
    \    (sum-of-even n)))\n```\n\n### Equal Sum of Odd-Even Indexed Integers\n\n\
    ```racket\n#lang racket\n", "  (exists (lambda (a b c d)\n            (and (even?\
    \ a)\n                 (even? b)\n                 (even? c)\n               \
    \  (even? d)\n                 (= (+ a b c d) n)))\n          (+ 1 1)\n      \
    \    (- n 2 1)\n          (- n 3 1)\n          (- n 4 1)))\n", "  (let loop ([x\
    \ 1] [count 0])\n    (if (> x n)\n        (= count 4)\n        (if (zero? (modulo\
    \ x 2))\n            (loop (+ x 1) (+ count 1))\n            (loop (+ x 1) count)))))\n",
  "  (is_equal_to_sum_even_helper n 4))\n", "  (define n-counter 1)\n  (define sum-of-first-three-even-numbers\
    \ 0)\n  (define (is_equal_to_sum_even-helper is-equal-to-sum-even?)\n    (cond\n\
    \      [(eq? is-equal-to-sum-even? #t)\n       (is-equal-to-sum-even? #t)]\n \
    \     [(eq? is-equal-to-sum-even? #f)\n       (is-equal-to-sum-even? #f)]\n  \
    \    [(> (* 2 n-counter) n)\n       (is-equal-to-sum-even? #f)]\n      [(= (+\
    \ sum-of-first-three-even-numbers (* 2 n-counter)) n)\n       (is-equal-to-sum-even?\
    \ #t)]\n      [else\n       (begin\n         (set! sum-of-first-three-even-numbers\
    \ (+ sum-of-first-three-even-numbers (* 2 n-counter)))\n         (set! n-counter\
    \ (+ n-counter 1))\n         (is_equal_to_sum_even-helper #f))]))\n  (is_equal_to_sum_even-helper\
    \ #f))\n", "  (and (even? n)\n       (equal? n (sum (list-evens-till n)))))\n",
  "  (define (is_sum_even n)\n    (or (= n n)\n        (let* ([a (if (even? n) n (add1\
    \ n))]\n               [b (if (even? n) n (add1 n))]\n               [c (if (even?\
    \ n) n (add1 n))]\n               [d (if (even? n) n (add1 n))])\n          (and\
    \ (and (= n (+ a b c d))\n                    (and (and (and (and (and (and (and\
    \ (and (and (> a 0) (> b 0)) (> c 0)) (> d 0)) (even? a)) (even? b)) (even? c))\
    \ (even? d))\n                              (not (= a b)))\n                 \
    \        (not (= a c)))\n                         (not (= a d)))\n           \
    \              (not (= b c)))\n                         (not (= b d)))\n     \
    \                    (not (= c d))))))\n    (let* ([a (if (even? n) n (add1 n))]\n\
    \           [b (if (even? n) n (add1 n))]\n           [c (if (even? n) n (add1\
    \ n))]\n           [d (if (even? n) n (add1 n))])\n      (is_sum_even (+ a b c\
    \ d))))\n</code>\nThis is what I have so far, but it never seems to terminate.\
    \ I am very new to Racket, so if there is a way to optimize this recursive process\
    \ with a built-in function that I haven't heard of yet, I would love to know.\n\
    \n\nA:\n\nIf you change your code to use <code>*</code> instead of <code>+</code>\
    \ then you're essentially computing <code>n</code>th roots, which is easy:\n<code>(define\
    \ (is-sum-even? n)\n  (let ([r (sqrt n)])\n    (and (not (integer? r))\n     \
    \    (integer? (* r r)))))\n</code>\nExample:\n<code>(is-sum-even? 4)\n=&gt; #f",
  "  (cond\n    [(= n 2) #f]\n    [(= n 4) #t]\n    [(= n 6) #f]\n    [(= n 8) #t]\n\
    \    [(= n 10) #f]\n    [(= n 12) #t]\n    [(= n 14) #f]\n    [(= n 16) #t]\n\
    \    [(= n 18) #f]\n    [(= n 20) #t]\n    [(= n 22) #f]\n    [(= n 24) #t]\n\
    \    [(= n 26) #f]\n    [(= n 28) #t]\n    [(= n 30) #f]\n    [(= n 32) #t]\n\
    \    [(= n 34) #f]\n    [(= n 36) #t]\n    [(= n 38) #f]\n    [(= n 40) #t]\n\
    \    [(= n 42) #f]\n    [(= n 44) #t]\n    [(= n 46) #f]\n    [(= n 48) #t]\n\
    \    [(= n 50) #f]\n    [(= n 52) #t]\n    [(= n 54) #f]\n    [(= n 56) #t]\n\
    \    [(= n 58) #f]\n    [(= n 60) #t]\n    [(= n 62) #f]\n    [(= n 64) #t]\n\
    \    [(= n 66) #f]\n    [(= n 68) #t]\n    [(= n 70) #f]\n    [(= n 72) #t]\n\
    \    [(= n 74) #f]\n    [(= n 76) #t]\n    [(= n 78) #f]\n    [(= n 80) #t]\n\
    \    [(= n 82) #f]\n    [(= n 84) #t]\n    [(= n 86) #f]\n    [(= n 88) #t]\n\
    \    [(= n 90) #f]\n    [(= n 92) #t]\n    [(= n 94) #f]\n    [(= n 96) #t]\n\
    \    [(= n 98) #f]\n    [(= n 100) #t]\n    [(= n 102) #", "  (let ([x (exact-floor\
    \ (/ n 4))])\n    (and (= (* 4 x) n) (even? x))))\n", "  (define (helper lst acc)\n\
    \    (if (empty? lst)\n        (if (= acc n)\n            #t\n            #f)\n\
    \        (let ([h (car lst)])\n          (helper (cdr lst) (+ acc h)))))\n  (helper\
    \ (iota n 1) 0))\n", "  (if (< n 8)\n      #f\n      (if (= n 8)\n          #t\n\
    \          (if (= n 10)\n              #f\n              (if (= n 12)\n      \
    \            #t\n                  (or (is_equal_to_sum_even (- n 4))\n      \
    \                (is_equal_to_sum_even (- n 6))\n                      (is_equal_to_sum_even\
    \ (- n 8))\n                      (is_equal_to_sum_even (- n 10))\n          \
    \            (is_equal_to_sum_even (- n 12)))))))))\n```\n\n- b. Rewrite the function\
    \ `is_equal_to_sum_even` by specifying the cases of `n` explicitly, i.e., by using\
    \ explicit `if`, `or`, and `eq?`\n\n```racket\n#lang racket\n", '  (not (null?
    (list-sum-even? n 4))))', "  (for/or ([a (in-range n)]\n           [b (in-range\
    \ a)]\n           [c (in-range b)]\n           [d (in-range c)])\n    (and (even?\
    \ a)\n         (even? b)\n         (even? c)\n         (even? d)\n         (=\
    \ n (+ a b c d)))))\n```\n\n[Run it! :arrow_upper_right:](https://repl.it/@ag_dubs/r5rs-is-equal-to-sum-even)\n\
    \n## License\n\nThis project is distributed under the MIT license.", "  (define\
    \ (is_equal_to_sum_even_iter sum count)\n    (cond ((= count 0) (= sum n))\n \
    \         ((and (&lt; count 5) (&lt;= sum n)) (or (is_equal_to_sum_even_iter (+\
    \ sum 2) (+ count 1))\n                                             (is_equal_to_sum_even_iter\
    \ sum count)))\n          (else #f)))\n  (is_equal_to_sum_even_iter 0 0))\n</code>\n\
    When I execute this, I get the error:\n<code>Application: not a procedure;\n expected\
    \ a procedure that can be applied to arguments\n  given: #&lt;void&gt;\n  arguments...:\n\
    \   #f\n</code>\nI can't seem to figure out what's wrong with this code. Can someone\
    \ help me out?\n\n\nA:\n\nI think that your code is a bit confusing, especially\
    \ because you use the same name for two different procedures. In my opinion a\
    \ solution like this is clearer:\n<code>(define (is-equal-to-sum-even n)\n  (define\
    \ (is-equal-to-sum-even-iter sum count)\n    (cond ((= count 0) (= sum n))\n \
    \         ((and (&lt; count 5) (&lt;= sum n)) (or (is-equal-to-sum-even-iter (+\
    \ sum 2) (+ count 1))\n                                           (is-equal-to-sum-even-iter\
    \ sum count)))\n          (else #f)))\n  (is-equal-to-sum-even-iter 0 0))\n</code>\n\
    I used the so-called \"common lisp\" style for naming variables/functions, which\
    \ means that we use hyphens when they're composed of more than one word, and we\
    \ use <code>or</code> instead of <code>||</code>.\nNow, the reason why you're\
    \ getting the error is due to the fact that you never close the <code>cond</code>\
    \ expression in your <code>is-equal-to-sum-even-iter</code> procedure, so the\
    \ last <code>else</code> branch is interpreted as the return value of the procedure,\
    \ and that's a syntax error because <code>else</code> is not a", "  (and (number?\
    \ n)\n       (>= n 1)\n       (= n (+ 2 2 2 2))\n       (and (even? n) (odd? n))))\n",
  "  (is_equal_to_sum_even_helper 0 n 0))\n", "  (even? (sum-even n 0)))\n", "  (define\
    \ (helper remainder)\n    (cond ((= remainder 0) #t)\n          ((< remainder\
    \ 0) #f)\n          (else (or (helper (- remainder 4))\n                    (helper\
    \ (- remainder 2))))))\n  (helper n))\n", "  (define (find_first_sum_even a b\
    \ c d)\n    (cond\n      [(= (+ (* 2 a) (* 2 b) (* 2 c) (* 2 d)) n) n]\n     \
    \ [(< (+ (* 2 a) (* 2 b) (* 2 c) (* 2 d)) n) (find_first_sum_even a b c (+ d 2))]\n\
    \      [(> (+ (* 2 a) (* 2 b) (* 2 c) (* 2 d)) n) (find_first_sum_even a b (+\
    \ c 2) d)]))\n  (cond\n    [(= (remainder n 2) 0) (find_first_sum_even 0 0 0 2)]\n\
    \    [else #f]))\n", "  (let* ([is_equal? #f]\n         [num 0]\n         [sum\
    \ 0])\n    (for ([i (in-range n)])\n      (set! sum (+ num 2))\n      (for ([j\
    \ (in-range n)])\n        (set! sum (+ sum 2))\n        (for ([k (in-range n)])\n\
    \          (set! sum (+ sum 2))\n          (for ([l (in-range n)])\n         \
    \   (set! sum (+ sum 2))\n            (when (= sum n)\n              (set! is_equal?\
    \ #t))))))\n    is_equal?))\n", "  (let loop ([i 4] [j 4])\n    (cond\n      [(=\
    \ i (+ j j)) (even? n)]\n      [(= i (+ j j j)) (even? n)]\n      [(= i (+ j j\
    \ j j)) (even? n)]\n      [else (loop (+ i 2) j)])))\n", "  (define (is_even x)\
    \ (= (remainder x 2) 0))\n  (define (sum_even x)\n    (if (is_even x)\n      \
    \  (+ (sum_even (- x 2)) 2)\n        0))\n  (= n (sum_even n)))\n", "  (cond ((<\
    \ n 4) #f)\n        ((not (even? n)) #f)\n        ((> n 4) (or (is_equal_to_sum_even\
    \ (- n 2))\n                     (is_equal_to_sum_even (- n 4))))\n        (else\
    \ #t)))\n", "  (define (is_equal_to_sum_even-helper n)\n    (local ((define (iter\
    \ v lst)\n              (cond\n                [(= v 0) (list 1)]\n          \
    \      [(= v (* 2 (car lst)))\n                 (cons 1 (iter (- v (* 2 (car lst)))\
    \ (cdr lst)))]\n                [(> v (* 2 (car lst)))\n                 (cons\
    \ (+ (car (iter (- v (* 2 (car lst))) (cdr lst))) 1)\n                       (iter\
    \ (- v (* 2 (car lst))) (cdr lst)))]\n                [else (list 0)])))\n   \
    \   (list-&gt;set (iter n (range 1 n)))))\n  (if (even? n)\n      (if (= 4 (list-length\
    \ (is_equal_to_sum_even-helper n)))\n          #t\n          #f)\n      #f))\n",
  "  ;; Write your code here\n  )\n", "  (let ([nums (in-naturals 1)])\n    (define\
    \ (find-four n)\n      (cond [(zero? n) #t]\n            [(or (zero? (remainder\
    \ n 2)) (number? (find-four (- n (car nums))))) #f]\n            [else (find-four\
    \ (- n (car nums)))]))\n    (find-four n)))\n", "  (define (helper sum counter)\n\
    \    (cond\n      [(and (= sum n) (= counter 4)) #t]\n      [(> sum n) #f]\n \
    \     [else (helper (+ sum 2) (+ counter 1))]))\n  (helper 0 0))\n", "  (cond\n\
    \    [(= n 0) #t]\n    [(even? n) (is_equal_to_sum_even (- n 2))]\n    [else #f]))\n\
    ```\n\n# Lists and Recursion\n### Problem 1:\n\n``` #lang racket", "  (define\
    \ (is_equal_to_sum_even_helper n remaining)\n    (if (= n 0)\n        (if (= remaining\
    \ 0)\n            #t\n            #f)\n        (if (< n 0)\n            #f\n \
    \           (is_equal_to_sum_even_helper (- n 2) (- remaining 1))\n          \
    \  (is_equal_to_sum_even_helper (- n 4) (- remaining 1)))))\n  (is_equal_to_sum_even_helper\
    \ n 4))\n", "  (let ([evens (for/list ([i (in-range 2 n 2)]) i)])\n    (for/or\
    \ ([a evens]\n             [b evens]\n             [c evens]\n             [d\
    \ evens])\n      (and\n       (not (= a b))\n       (not (= a c))\n       (not\
    \ (= a d))\n       (not (= b c))\n       (not (= b d))\n       (not (= c d))\n\
    \       (= (+ a b c d) n)))))\n\n", "  (define (inner n count)\n    (if (= n 0)\n\
    \        (= count 4)\n        (if (> n 0)\n            (or (inner (- n 2) (+ count\
    \ 1))\n                (inner (- n 4) (+ count 1)))\n            #f)))\n  (inner\
    \ n 0))\n```\n### 6.4.4 \u771F\u507D\u5024\u3068\u6BD4\u8F03\u6F14\u7B97\u5B50\
    \n\u771F\u507D\u5024\u3092\u5224\u5B9A\u3059\u308B\u305F\u3081\u306E\u6BD4\u8F03\
    \u6F14\u7B97\u5B50\u306E\u4F8B\u3067\u3042\u308B\u3002\n\n```racket", "  (define\
    \ (iter i count sum)\n    (cond ((<= i n)\n           (if (and (zero? (modulo\
    \ i 2))\n                    (= count 4)\n                    (= sum n))\n   \
    \            #t\n               (iter (+ i 1) (if (zero? (modulo i 2))\n     \
    \                            (+ count 1)\n                                 count)\n\
    \                     (if (zero? (modulo i 2))\n                         (+ sum\
    \ i)\n                         sum))))\n          (else #f)))\n  (iter 1 0 0))",
  "  (define (iter i j k l)\n    (cond [(and (= (+ i j k l) n) (&gt; (+ i j k l) 0))\
    \ #t]\n          [(= l (+ n 2)) #f]\n          [else (iter i j k (+ l 2))]))\n\
    \  (iter 1 1 1 2))\n</code>\nThis solution works in Racket 5.1 and above.\n",
  "  (define (loop m k acc)\n    (cond\n      [(= 0 acc)\n       (if (= n 0)\n   \
    \        #t\n           #f)]\n      [(= n 0)\n       #f]\n      [(= n m)\n   \
    \    #t]\n      [(< n m)\n       #f]\n      [(even? m)\n       (or (loop m (+\
    \ k 1) (+ acc m))\n           (loop (+ m 2) (+ k 1) acc))]\n      [else\n    \
    \   (loop (+ m 2) k acc)]))\n  (loop 2 0 0))\n", "  (even? n) ; n must be even\n\
    \  (even? (/ n 4)) ; n/4 must be even\n  (even? (+ n 1)) ; n+1 must be even\n\
    \  (even? (+ n 2)) ; n+2 must be even\n  (even? (+ n 3))) ; n+3 must be even\n",
  "  (define (is_equal_to_sum_even-helper x sum count)\n    (cond [(= x 0) (and (=\
    \ sum n) (= count 4))]\n          [(even? x) (or (is_equal_to_sum_even-helper\
    \ (- x 2) (+ sum x) (+ count 1))\n                        (is_equal_to_sum_even-helper\
    \ (- x 2) sum count))]\n          [else (is_equal_to_sum_even-helper (- x 1) sum\
    \ count)]))\n  (is_equal_to_sum_even-helper n 0 0))\n", "  (letrec\n    ((rec\
    \ (lambda (n acc)\n\t    (if (> n 0)\n\t      (if (even? n)\n\t\t(if (= n acc)\n\
    \t\t  #t\n\t\t  (rec (- n acc) (+ acc 2)))\n\t\t(rec (- n 2) 4))\n\t      #f))))\n\
    \    (rec n 2)))\n", "  (even-list-sum? n 4))\n", "  (cond\n    [(= n 0) #t]\n\
    \    [(even? n) #f]\n    [else (every-positive-even? n 0)]))\n", "  (define (get_evens\
    \ start n)\n    (if (= 0 n)\n        empty\n        (cons start (get_evens (+\
    \ start 2) (- n 1)))))\n  (cond\n    [(= n 0) #f]\n    [(= n 4) #t]\n    [(< n\
    \ 4) #f]\n    [else (cond\n            [(= 0 (remainder n 2)) (or (is_equal_to_sum_even\
    \ (- n 2)) (is_equal_to_sum_even (- n 4)))]\n            [else (or (is_equal_to_sum_even\
    \ (- n 1)) (is_equal_to_sum_even (- n 3)))]\n            )]))\n```\n\n```", " \
    \ (define (is_even? x)\n    (= (remainder x 2) 0))\n  (define (is_sum_of_4_even?\
    \ n acc even-count)\n    (cond\n      [(= even-count 4) (= n acc)]\n      [(=\
    \ acc n) (is_sum_of_4_even? n (+ acc 2) (+ even-count 1))]\n      [(>= n acc)\
    \ (or (is_sum_of_4_even? n (+ acc 2) (+ even-count 1))\n                     \
    \ (is_sum_of_4_even? n (+ acc 4) (+ even-count 1)))]\n      [else #f]))\n  (cond\n\
    \    [(= n 0) #f]\n    [(and (is_even? n)\n          (= (remainder n 4) 0)) #t]\n\
    \    [else (is_sum_of_4_even? n 2 0)]))\n", "  (define (is_sum_even? n count)\n\
    \    (cond\n      [(= n 0) (= count 4)]\n      [(< n 0) #f]\n      [else (or (is_sum_even?\
    \ (- n 2) (+ count 1))\n                (is_sum_even? n count))]))\n  (is_sum_even?\
    \ n 0))\n```\n\n### Input\n\n2. Implement `read` as a function that takes as input\
    \ a string and outputs a list of tokens where each token is a `token-type` that\
    \ you have defined as you have done before.\n\n```scheme\n#lang racket\n", " \
    \ (let loop ([n n] [sum 0] [count 0])\n    (cond\n      [(zero? n)\n       (or\
    \ (zero? sum)\n           (and (= sum n)\n                (= count 4)))]\n   \
    \   [(even? n)\n       (or (loop (- n 2) (+ sum 2) (+ count 1))\n           (loop\
    \ (- n 4) (+ sum 4) (+ count 1)))]\n      [else\n       (loop (- n 2) (+ sum 2)\
    \ (+ count 1))])))\n", "  (if (< n 8)\n      #f\n      (if (even? n)\n       \
    \   (or (even? (- n 8))\n              (is_equal_to_sum_even (- n 8)))\n     \
    \     (even? (- n 7)))))\n", "  (define (sum_even l)\n    (cond\n      [(empty?\
    \ l) 0]\n      [(odd? (first l)) (sum_even (rest l))]\n      [else (+ (first l)\
    \ (sum_even (rest l)))]))\n  (define (build-list k)\n    (cond\n      [(= k n)\
    \ (list n)]\n      [else (cons k (build-list (+ k 2)))]))\n  (define (is-equal-to-sum-even?\
    \ k)\n    (cond\n      [(empty? k) #f]\n      [(= (sum_even k) n) #t]\n      [else\
    \ (is-equal-to-sum-even? (rest k))]))\n  (is-equal-to-sum-even? (build-list 2)))\n",
  "  (even? n)\n  (is_equal_to_sum_positive n 4))\n", "  (let recur ((a 2) (b 4) (c\
    \ 6) (d 8))\n    (cond ((or (and (equal? (+ a b c d) n) (< a b) (< b c) (< c d))\n\
    \               (and (equal? (+ a b c) n) (< a b) (< b c))\n               (and\
    \ (equal? (+ a b) n) (< a b))\n               (and (equal? (+ a) n))\n       \
    \        (zero? n))\n           #t)\n          ((> a n) #f)\n          (else (recur\
    \ (+ a 2) (+ b 2) (+ c 2) (+ d 2))))))\n", "  (not (zero? (modulo n 2))))\n",
  "  (if (= n 4)\n      #f\n      (if (= n 6)\n          #f\n          (if (= n 8)\n\
    \              #t\n              #f))))\n", "  (let* ([n (exact-round (/ n 2.0))]\n\
    \         [pool (range n)])\n    (and (andmap (\u03BB (x) (andmap (\u03BB (y)\
    \ (andmap (\u03BB (z) (andmap (\u03BB (w) (and (and (and (even? x) (even? y))\
    \ (even? z)) (even? w)) (= (+ x y z w) n)) pool)) pool)) pool)) pool)\n      \
    \   (even? n))))\n", "  (define (is_equal_to_sum_even_iter n base n_even_nums)\n\
    \    (if (= n_even_nums 4)\n        (= n 0)\n        (let ((base (if (even? base)\
    \ base (+ base 1))))\n          (or (is_equal_to_sum_even_iter (- n base) (+ base\
    \ 2) (+ n_even_nums 1))\n              (is_equal_to_sum_even_iter n (+ base 2)\
    \ n_even_nums)))))\n  (is_equal_to_sum_even_iter n 2 0))\n```\n\n## 5.17\n\n```scheme\n\
    #lang racket\n", "  (and (even? n)\n       (exists (lambda (a)\n             \
    \    (exists (lambda (b)\n                           (exists (lambda (c)\n   \
    \                                  (exists (lambda (d)\n                     \
    \                          (= (+ a b c d) n))\n                              \
    \               even-ints))\n                                     even-ints))\n\
    \                           even-ints))\n                 even-ints)))\n", " \
    \ (and (even? n)\n       (= n (+ (expt 2 2) (expt 2 2) (expt 2 2) (expt 2 2)))))\n",
  "  (if (< n 4)\n      #f\n      (if (even? n)\n          (if (= (- n 4) 0)\n   \
    \           #t\n              (is_equal_to_sum_even (- n 4)))\n          (is_equal_to_sum_even\
    \ (- n 3)))))\n```\n\n```scheme\n#lang racket\n", "  (list->sorted-list (filter\n\
    \                      (lambda (lst)\n                        (eq? (sum lst) n))\n\
    \                      (range 1 (sum (range 1 n)) 2))))\n```\n\n``` #lang racket\n",
  "  (define (inner count num)\n    (cond [(= num 0)\n           (= count 4)]\n  \
    \        [(and (even? num) (zero? (modulo count 4)))\n           (inner (+ count\
    \ 1) (- num 2))]\n          [else\n           (inner count (- num 2))]))\n  (inner\
    \ 0 n))\n", "  (if (= n 0)\n      #t\n      (if (zero? (remainder n 2))\n    \
    \      (or (is_equal_to_sum_even (- n 1))\n              (is_equal_to_sum_even\
    \ (- n 2))\n              (is_equal_to_sum_even (- n 3))\n              (is_equal_to_sum_even\
    \ (- n 4)))\n          #f)))\n", "  (cond\n    [(= n 8) #t]\n    [(= n 10) #t]\n\
    \    [(= n 12) #t]\n    [(= n 14) #t]\n    [(= n 16) #t]\n    [(= n 18) #t]\n\
    \    [(= n 20) #t]\n    [(= n 22) #t]\n    [(= n 24) #t]\n    [(= n 26) #t]\n\
    \    [(= n 28) #t]\n    [(= n 30) #t]\n    [(= n 32) #t]\n    [(= n 34) #t]\n\
    \    [(= n 36) #t]\n    [(= n 38) #t]\n    [(= n 40) #t]\n    [(= n 42) #t]\n\
    \    [(= n 44) #t]\n    [(= n 46) #t]\n    [(= n 48) #t]\n    [(= n 50) #t]\n\
    \    [(= n 52) #t]\n    [(= n 54) #t]\n    [(= n 56) #t]\n    [(= n 58) #t]\n\
    \    [(= n 60) #t]\n    [(= n 62) #t]\n    [(= n 64) #t]\n    [(= n 66) #t]\n\
    \    [(= n 68) #t]\n    [(= n 70) #t]\n    [(= n 72) #t]\n    [(= n 74) #t]\n\
    \    [(= n 76) #t]\n    [(= n 78) #t]\n    [(= n 80) #t]\n    [(= n 82) #t]\n\
    \    [(= n 84) #t]\n    [(= n 86) #t]\n    [(= n 88) #t]\n    [(= n 90) #t]\n\
    \    [(= n 92) #t]\n    [(= n 94) #t]\n    [(= n 96) #t]\n    [(= n 98) #t]\n\
    \    [(= n 100) #t]\n    [(= n 102) #t]\n    [(= n 104) #t]\n    [(= n 106) #t]\n\
    \    [(= n 108) #", "  (cond\n    [(even? n)\n     (cond\n       [(<= n 4) #f]\n\
    \       [else\n        (let* ([rest (- n 4)]\n               [half (/ rest 2)])\n\
    \          (even? (/ rest 2)))]\n       )]\n    [else #f]))\n\n", "  (and\n  \
    \ (= 4 (count-equal-to-sum-even n))\n   (exact-sum? 4 n)))\n", "  (if (even? n)\n\
    \      (or (= n 4)\n          (is_equal_to_sum_even (- n 4)))\n      #f))\n",
  "  (and (zero? (modulo n 2))\n       (or (equal? n 4)\n           (or (equal? n\
    \ 6)\n               (or (equal? n 8)\n                   (equal? n 16))))))\n\
    </code>\nI am not sure how much refactoring is possible on this. \n\n\nA:\n\n\
    There are a couple of missing <code>#f</code> in your code, at least one wrong\
    \ <code>if</code> and the missing <code>and</code> in the beginning:\n<code>(define\
    \ (is_equal_to_sum_even n)\n  (and (zero? (modulo n 2)) ; adding the missing 'and'\n\
    \       (or (equal? n 4)\n           (or (equal? n 6)\n               (or (equal?\
    \ n 8)\n                   (equal? n 16))))))\n</code>\nI think the code could\
    \ be more concise and readable like this:\n<code>(define (is_equal_to_sum_even\
    \ n)\n  (and (zero? (modulo n 2))\n       (member n '(4 6 8 16))))\n</code>\n",
  "  (define (even? n)\n    (= (remainder n 2) 0))\n  (define (step a b c n)\n   \
    \ (cond\n      [(= n 0) true]\n      [(< n 0) false]\n      [(and (even? a) (even?\
    \ b) (even? c))\n       (or (step (+ a 2) b c (- n a))\n           (step a (+\
    \ b 2) c (- n b))\n           (step a b (+ c 2) (- n c)))]\n      [else false]))\n\
    \  (step 2 2 2 n))", "  (let loop ([n n] [cnt 0])\n    (if (or (zero? n) (= cnt\
    \ 4))\n        (zero? n)\n        (loop (- n 2) (+ cnt 1)))))\n", "  (define (iter\
    \ accum val max)\n    (cond\n      [(= 4 accum) #t]\n      [(= max val) #f]\n\
    \      [(= (+ (* 2 val) (* 2 (iter (+ accum 1) (+ val 2) max))) n) #t]\n     \
    \ [else (iter accum (+ val 2) max)]))\n  (iter 0 2 (/ n 2)))\n", "  (define (is_equal-to-sum-even'\
    \ subn m)\n    (cond\n      [(= subn n) #t]\n      [(= subn (+ n 1)) #f]\n   \
    \   [(or\n          (even? m)\n          (and\n            (> m 0)\n         \
    \   (even? (- m 1))))\n        (or\n          (is_equal-to-sum-even' (+ subn m)\
    \ m)\n          (is_equal-to-sum-even' subn (+ m 1)))]\n      [else\n        (is_equal-to-sum-even'\
    \ subn (+ m 1))]))\n  (is_equal-to-sum-even' 0 0))\n", "  (define (is_equal_to_sum_even-iter\
    \ acc n sum current)\n    (cond\n      [(= n sum)\n       #t]\n      [(> n sum)\n\
    \       (if (= (+ current 4) n)\n           #t\n           (is_equal_to_sum_even-iter\
    \ current (+ n 2) (+ sum current) (+ current 2)))]\n      [else\n       #f]))\n\
    \  (is_equal_to_sum_even-iter 2 2 2 2))\n", "  (is_equal_to_sum_even-helper n\
    \ 0 0 4))\n", "  (and (even? n) (is_equal_to_sum_even_helper n (/ n 2) 1 1)))\n",
  "  (if (or (= n 0) (= n 1) (= n 2))\n      #f\n      (if (= n 3)\n          #t\n\
    \          (if (even? n)\n              #t\n              (or (is_equal_to_sum_even\
    \ (- n 1))\n                  (is_equal_to_sum_even (- n 2))\n               \
    \   (is_equal_to_sum_even (- n 3)))))))\n", "  (let lp ([n n] [res #f])\n    (if\
    \ (= n 0)\n        res\n        (lp (quotient n 2) (if (and (zero? (remainder\
    \ n 2)) (= 1 (- n))) #t res)))))\n</code>\nThe strategy is to keep dividing the\
    \ number by 2 and remembering the remainder. If the remainder is 0 and the next\
    \ number is 1, return true. (Note: I'm using Racket for this. Also, the point\
    \ of this exercise is to do this with recursion, so I'm not looking for a different\
    \ implementation strategy.)\nThe solution works as expected, but it seems like\
    \ there is a lot of repetition involved, specifically the repeated <code>res</code>\
    \ argument. Is there a way I can redefine the recursion so that I don't have to\
    \ pass the <code>res</code> argument to the helper function?\n\n\nA:\n\nI'm not\
    \ sure how it works.  But in many languages you can use the <code>and</code> function\
    \ with an arbitrary number of arguments.  You can use the same trick in Racket:\n\
    <code>(define (is_equal_to_sum_even n)\n  (let lp ([n n])\n    (if (= n 0)\n \
    \       #t\n        (lp (quotient n 2)))))\n</code>\nYou can also do:\n<code>(define\
    \ (is_equal_to_sum_even n)\n  (let lp ([n n])\n    (if (= n 0)\n        #t\n \
    \       (lp (quotient n 2)))))\n</code>\nIn both cases I'm eliminating the repeated\
    \ <code>#t</code> argument.\n", "  (define (n_th_even n)\n    (* 2 n))\n  (define\
    \ (list_n_th_even n)\n    (list (n_th_even n)))\n  (define (list_n_th_even_up_to\
    \ n)\n    (if (< n 0) '()\n        (cons (n_th_even n) (list_n_th_even_up_to (-\
    \ n 1)))))\n  (define (list_n_th_even_up_to_n n)\n    (list_n_th_even_up_to n))\n\
    \  (define (list_even_up_to n)\n    (list_n_th_even_up_to_n (/ n 2)))\n  (define\
    \ (list_even_up_to_n n)\n    (list_even_up_to n))\n  (define (sum_of_even_num_permutations\
    \ n)\n    (for/list ([x (in-list (list_even_up_to_n n))]\n               [y (in-list\
    \ (list_even_up_to_n n))]\n               [z (in-list (list_even_up_to_n n))]\n\
    \               [w (in-list (list_even_up_to_n n))])\n      (+ x y z w)))\n  (define\
    \ (has_sum n lst)\n    (member n lst))\n  (has_sum n (sum_of_even_num_permutations\
    \ n)))\n```\n\n## 10. Exercises\n\n[Show solutions](exercises.rkt)\n\n### Functional\
    \ Programming\n\n#### 1. sum of first n natural numbers\n\n[Write a function that\
    \ returns the sum of the first n natural numbers](exercises.rkt#L1)\n\n#### 2.\
    \ sum of n positive numbers\n\n[Write a function that returns the sum of n positive\
    \ numbers](exercises.rkt#L6)\n\n#### 3. n positive numbers, n > 0\n\n[Write a\
    \ function that returns the sum of n positive numbers, n > 0](exercises.rkt#L11)\n\
    \n#### 4. n positive numbers, n > 2\n\n[Write a", "  (define even-sum\n    (lambda\
    \ (n acc)\n      (if (zero? n)\n          (equal? acc n)\n          (even-sum\
    \ (sub1 n) (add1 acc)))))\n  (even-sum n 0))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
