name: HumanEval_84_solve
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer N, return the total sum of its\
  \ digits in binary.\n;; Example\n;; >>> (solve 1000)\n;; \"1\"\n;; >>> (solve 150)\n\
  ;; \"110\"\n;; >>> (solve 147)\n;; \"1100\"\n;; Variables:\n;; @N integer\n;; Constraints:\
  \ 0 \u2264 N \u2264 10000.\n;; Output:\n;; a string of binary number\n(define (solve\
  \ N)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
  \    (check-equal? (candidate 1000) \"1\")\n    (check-equal? (candidate 150) \"\
  110\")\n    (check-equal? (candidate 147) \"1100\")\n    (check-equal? (candidate\
  \ 333) \"1001\")\n    (check-equal? (candidate 963) \"10010\")\n))\n\n(test-humaneval)"
completions: ["  (number->string 2 (string->number (number->string 10 N) 2)))\n",
  "  (string-append\n   (number->string\n    (digit-sum\n     (number->string\n  \
    \    (integer->binary N))))))\n", "  (cond [(= N 0) \"0\"]\n        [(= N 1) \"\
    1\"]\n        [else (number->string (+ (modulo N 2) (string->number (solve (quotient\
    \ N 2)))))]))", "  (define (my-sum lst)\n    (cond ((null? lst) 0)\n         \
    \ (else (+ (car lst) (my-sum (cdr lst))))))\n  (number->string (my-sum (map (lambda\
    \ (x) (char->integer x)) (number->string (integer->binary N))))))", "  (number->string\
    \ (bitwise-ior (floor (expt 2 N)) (bitwise-and N 1))))\n", "  (list->string (list->string/r\
    \ (list->string N))))\n", "  (build-list (decimal-to-binary N)\n             \
    \ (lambda (x)\n                (if (eq? x '#b1) 1 0))))\n", "  (cond [(= N 0)\
    \ \"0\"]\n        [(= N 1) \"1\"]\n        [else (string-append (solve (quotient\
    \ N 2)) (number->string (remainder N 2)))]))\n", "  (number->string (bin N) 2))\n",
  "  (integer->string (solution N)))\n", "  (binary-string (inexact->exact (round\
    \ (log N 2)))))\n", '  (integer->string 2 (string->number (number->string N) 10)))',
  "  (integer->string (string->integer (string-ref (number->string (bitwise-count\
    \ N)) 0))))\n", '  (number->string (number->decimal N)))', "  (string-&gt;number\
    \ (number-&gt;string N 2)))\n", '  (string-concatenate (list->string (map (lambda
    (n) (substring (number->string n) 1 2)) (reverse (build-list (exact-floor (log
    N 2)) (lambda (i) (remainder N (expt 2 (+ i 1))))))))))', "  (define (get-binary-digits\
    \ N (digits '()))\n    (if (= N 0)\n        digits\n        (get-binary-digits\
    \ (truncate (/ N 2)) (cons (remainder N 2) digits))))\n  (define (get-total-sum-of-digits\
    \ N)\n    (apply + (get-binary-digits N)))\n  (number->string (get-total-sum-of-digits\
    \ N)))\n", "  (define (aux N)\n    (if (= N 0) '()\n        (cons (remainder N\
    \ 2) (aux (quotient N 2)))))\n  (cond ((= N 0) \"0\")\n        ((= N 1) \"1\"\
    )\n        (else (string-append (number->string (cond ((= (first (aux N)) 1) 1)\
    \ (else 0)))\n                             (solve (apply + (map (lambda (x) (*\
    \ 2 x)) (rest (aux N)))))))))\n", "    (number->string (fx+ (fx* (modulo N 10)\
    \ 2)\n                        (fx+ (fx* (modulo (quotient N 10) 2) 2)\n      \
    \                      (fx+ (fx* (modulo (quotient N 100) 2) 2)\n            \
    \                    (fx+ (fx* (modulo (quotient N 1000) 2) 2)\n             \
    \                       (fx+ (fx* (modulo (quotient N 10000) 2) 2)\n         \
    \                               (fx* (modulo (quotient N 100000) 2) 2))))))))",
  "  (dec2bin N))\n", "  (define (i-to-b i l)\n    (if (zero? i)\n        l\n    \
    \    (i-to-b (quotient i 2) (cons (modulo i 2) l))))\n  (define (iter lst acc)\n\
    \    (if (null? lst)\n        acc\n        (iter (cdr lst) (+ acc (car lst)))))\n\
    \  (number->string (iter (i-to-b N (list)) 0)))\n", "  (local [(define (digits-of-number\
    \ N)\n            (if (zero? N) (list)\n                (append (digits-of-number\
    \ (quotient N 2)) (list (remainder N 2)))))\n          (define (binary-to-string\
    \ L)\n            (if (null? L) (list)\n                (append (binary-to-string\
    \ (cdr L)) (list (char (add 48 (car L)))))))]\n    (apply string (reverse (binary-to-string\
    \ (digits-of-number N))))))", "  (integer->string (bytes->integer (string->bytes\
    \ (integer->string N) 16))))\n```\n\n```racket\n#lang racket\n", "  ;; find biggest\
    \ power of 2 that is less than N\n  (let ((pow-of-2 (find-power-of-2 N)))\n  \
    \  (if (equal? pow-of-2 1)\n        \"1\"\n        (list-&gt;string (append (make-list\
    \ (- N (expt 2 (- pow-of-2 1))) \"0\")\n                               (make-list\
    \ (- pow-of-2 1) \"1\"))))))\n", "  (integer->string (bin2dec (dec2bin N))))\n",
  "  (number->string (integer-length (bin (modulo N 1000)))))\n\n```\n\n### Test Suite\n\
    \nYou can run the test suite by first cloning this project, then running the following\
    \ command:\n\n```bash\nraco test -p ./racket/racket-code-challenge-test.rkt\n\
    ```\n\n## Solution\n\nTo solve this challenge, I used [Racket][racket] as my programming\
    \ language and [RSpec][rspec] as my testing framework.\n\nFirst, I started with\
    \ the test suite to drive the development of my solution. I created a file named\
    \ `test.rkt` that contained the following:\n\n```racket\n#lang racket\n", "  (define\
    \ digits (number->string N 2))\n  (define (sum-digits-in-string N)\n    (if (empty?\
    \ N)\n        0\n        (+ (string-&gt;number (substring N 0 1))\n          \
    \ (sum-digits-in-string (substring N 1)))))\n  (number-&gt;string (sum-digits-in-string\
    \ digits)))\n", "  (define (iter n acc)\n    (if (&lt;= n 1)\n        (number-&gt;string\
    \ acc)\n        (iter (quotient n 2) (string-append (number-&gt;string (remainder\
    \ n 2)) acc))))\n  (iter N \"\"))\n</code>\nCan it be improved?\n\n\nA:\n\nI think\
    \ your solution is fine.\nI'd write it with <code>for/fold</code> because I think\
    \ that makes it easier to understand.\nHere's my version:\n<code>(define (solve\
    \ N)\n  (for/fold ([sum \"\"]\n             [N N])\n            ([_ (in-range\
    \ N)])\n    (let ([remainder (remainder N 2)])\n      (string-append (number-&gt;string\
    \ remainder) sum))))\n</code>\nIt works in the same way. It's just easier to read,\
    \ because we don't have to think about an accumulated value that we have to update\
    \ each time.\nInstead, we can think in a more \"functional\" way. We start with\
    \ a number <code>N</code> and return a string. The string is built by adding a\
    \ <code>1</code> or <code>0</code> depending on the remainder of <code>N</code>\
    \ divided by <code>2</code>. Then we make <code>N</code> the quotient.\nIn the\
    \ end, we have a string that consists of <code>0</code>s and <code>1</code>s,\
    \ which is what we wanted.\n", "  (bin-string->sum-of-digits-string (integer->string\
    \ (integer->binary N))))\n", "  (string-&gt;number (string-join (map number-&gt;string\
    \ (map (lambda (x) (* 2 x)) (integer-&gt;list N 2))) \"\")))\n</code>\nI can pass\
    \ the first two, but the third one I get a bunch of symbols.\n<code>#(#\\1 #\\\
    1 #\\0 #\\0)\n</code>\nNot sure why this is happening. Anyone have an idea?\n",
  "  (string-&gt;number (number-&gt;string N) 2))\n</code>\nBut, this isn't really\
    \ what the problem was asking me to do. I needed to find the sum of the binary\
    \ digits, not the total binary number.\nFrom another user's answer, I was able\
    \ to figure it out:\n<code>#lang racket\n", "  (integer->string (binary N)))\n",
  "  (cond\n    [(<= N 0) 0]\n    [(= N 1) 1]\n    [else (let ([u (integer-&gt;string\
    \ (logand N 1))])\n            (string-append u (solve (quotient N 2))))]))\n",
  "  (cond [(= N 0) \"0\"]\n        [(= N 1) \"1\"]\n        [else (concat (solve\
    \ (quotient N 2)) (number->string (remainder N 2)))]))", "  (if (= N 0)\n    \
    \  \"0\"\n      (let loop ([N N] [res (list)])\n        (if (= N 0)\n        \
    \    (string-join (reverse res))\n            (loop (quotient N 2) (cons (number->string\
    \ (remainder N 2)) res))))))\n", "  (define S (string-append (number->string N)\
    \ \"\"))\n  (define (f S)\n    (if (zero? (string-length S))\n        \"\"\n \
    \       (let ((x (string-append (number->string (string-ref S 0)) \"\")))\n  \
    \        (string-append (number->string (string->number x 2)) (f (substring S\
    \ 1))))))\n  (f S))\n", "  (string-append \n   (map (lambda (x) (string-append\
    \ (number->string x)))\n        (map (lambda (x) (if (string=? x \"1\") 1 0))\n\
    \             (string-split (integer->binary N))))))\n", "  (if (= N 0)\n    \
    \  \"\"\n      (string-append (solve (quotient N 2))\n                     (number->string\
    \ (remainder N 2)))))\n", '  (string-join (map number->string (reverse (integer->list
    2 N)))))', "  (string-&gt;number\n   (number-&gt;string\n    (apply + (map (\u03BB\
    \ (x) (* 2 x)) (binary N))))))\n", "  (define (shower n)\n    (cond\n      [(=\
    \ n 0) \"\"]\n      [(= (remainder n 2) 0) (string-append (shower (quotient n\
    \ 2)) \"0\")]\n      [else (string-append (shower (quotient n 2)) \"1\")]))\n\
    \  (shower N))\n", '  (string-join (map (lambda (e) (number->string e)) (number->list
    (integer->binary N)))))', "  (define (rec N acc)\n    (cond\n      [(= N 0) acc]\n\
    \      [else (rec (quotient N 2) (string-append (integer->string (remainder N\
    \ 2)) acc))]))\n  (rec N \"\"))\n```\n\n## License\n\n[MIT](http://www.opensource.org/licenses/mit-license.php)",
  "  (define (sum-digits N)\n    (if (&lt; N 10)\n        N\n        (+ (modulo N\
    \ 10) (sum-digits (quotient N 10)))))\n  (define (to-binary N)\n    (cond ((&lt;\
    \ N 2)\n           (number-&gt;string N))\n          (else\n           (string-append\
    \ (to-binary (quotient N 2))\n                          (number-&gt;string (modulo\
    \ N 2))))))\n  (to-binary (sum-digits N)))\n", "  (cond [(= N 0) \"0\"]\n    \
    \    [(< N 0) \"ERROR\"]\n        [(> N 10000) \"ERROR\"]\n        [else (binstr\
    \ (binary N))]))\n", "  (cond ((= N 0) \"0\")\n        ((= N 1) \"1\")\n     \
    \   (else (+ (* N (modulo N 2)) (solve (quotient N 2))))))\n", "  (integer->string\n\
    \   (string->number\n    (number->string N 2)\n    10)))", "  (define (f n acc)\n\
    \    (cond\n      [(= 0 n) (reverse acc)]\n      [(= 0 (modulo n 2)) (f (quotient\
    \ n 2) (cons \"0\" acc))]\n      [else (f (quotient n 2) (cons \"1\" acc))]))\n\
    \  (string-join (f N '()) \"\"))\n", "  (define (base b n)\n    (if (zero? n)\n\
    \        #\"\"\n        (base b (quotient n b))\n        (number->string (remainder\
    \ n b))))\n  (base 2 N))", "  (define b (integer->binary N))\n  (define s (string-length\
    \ b))\n  (define c (substring b 1 s))\n  (define (add-binary-strings a b)\n  \
    \  (cond ((and (null? a) (null? b)) '())\n          ((and (null? a) (not (null?\
    \ b)))\n           (cons #\\0\n                 (add-binary-strings '() (rest\
    \ b))))\n          ((and (not (null? a)) (null? b))\n           (cons #\\0\n \
    \                (add-binary-strings (rest a) '())))\n          ((and (not (null?\
    \ a)) (not (null? b)))\n           (cons (if (= (first a) (first b))\n       \
    \              #\\0\n                     #\\1)\n                 (add-binary-strings\
    \ (rest a) (rest b))))))\n  (add-binary-strings c (integer->binary (string->number\
    \ (substring b 0 1)))))\n", "  (define (sum b)\n    (cond\n      [(empty? b) 0]\n\
    \      [else (+ (first b) (sum (rest b)))]))\n  (define (to-binary n)\n    (cond\n\
    \      [(= n 0) empty]\n      [else (cons (remainder n 2) (to-binary (quotient\
    \ n 2)))]))\n  (number->string (sum (to-binary N))))\n", "  (cond\n    [(= N 0)\
    \ \"0\"]\n    [(= N 1) \"1\"]\n    [else (solve (+ (quotient N 2) (- N (* 2 (quotient\
    \ N 2)))))]))", "  (define (iter N i result)\n    (cond [(= N 0) (format \"~a\"\
    \ result)]\n          [(= (modulo N 2) 1) (iter (quotient N 2) (add1 i) (+ result\
    \ (expt 2 i)))]\n          [else (iter (quotient N 2) (add1 i) result)]))\n  (cond\
    \ [(or (< N 0) (> N 10000)) \"wrong input\"]\n        [else (iter N 0 0)]))",
  '  (number->string (bitwise-and N 1)))', "  (integer->string (binary-sum (binary\
    \ N))))\n", "  (number->string\n   (string->number\n    (number->string N\n  \
    \                  2)\n    10)))", '  (bin-string N))', "  (cond [(= N 0) \"0\"\
    ]\n        [(= N 1) \"1\"]\n        [else (reverse (string-append\n          \
    \              (if (= 0 (remainder N 2)) \"0\" \"1\")\n                      \
    \  (solve (quotient N 2))))]))\n```\n\n## Problem 2 - Pascal's Triangle\n\n###\
    \ Problem\n\n![](https://i.imgur.com/XQv0BJm.png)\n\n### Solution 1\n\n```racket\n\
    #lang racket\n", "  (string-&gt;number\n   (map integer-&gt;char\n        (list-&gt;string\n\
    \         (map char-&gt;integer\n              (string-&gt;list\n            \
    \   (apply string (reverse (list-&gt;string (map char-&gt;integer\n          \
    \                                                     (string-&gt;list\n     \
    \                                                           (number-&gt;string\n\
    \                                                                 N\n        \
    \                                                         2))))))))))))\n", " \
    \ (solve_helper N 2 \"\"))\n", '  (binrep N ""))', "  (define (integer->binary\
    \ n)\n    (define (div-by-2 n)\n      (quotient n 2))\n    (define (remainder\
    \ n)\n      (modulo n 2))\n    (define (iter n result)\n      (cond ((zero? n)\
    \ result)\n            (else (iter (div-by-2 n) (cons (remainder n) result)))))\n\
    \    (cond ((zero? n) 0)\n          (else (iter n null))))\n  (define (count-digits\
    \ digits)\n    (cond ((null? digits) 0)\n          (else (+ 1 (count-digits (cdr\
    \ digits))))))\n  (define (str-of-int digits)\n    (define (iter digits result)\n\
    \      (cond ((null? digits) result)\n            (else (iter (cdr digits) (string-append\
    \ result (number->string (car digits)))))))\n    (iter digits \"\"))\n  (define\
    \ (trim-zeros n)\n    (define (iter n result)\n      (cond ((or (zero? n) (null?\
    \ n)) result)\n            ((zero? (car n)) (iter (cdr n) result))\n         \
    \   (else (iter (cdr n) (cons (car n) result)))))\n    (iter n null))\n  (if (zero?\
    \ N) \"0\"\n      (let* ([result (integer->binary N)]\n             [trimmed (trim-zeros\
    \ result)])\n        (str-of-int trimmed))))\n", "  (if (zero? N)\n      (number->string\
    \ 0)\n      (bytes->string/utf-8\n       (bin-string->bytes/utf-8\n        (integer->string\
    \ N 2)))))\n", "  (define (int-to-string n)\n    (string-append (number->string\
    \ n)))\n  (define (binary-digit n)\n    (cond ((= n 0) '())\n          ((< n 0)\
    \ (error \"argument not positive -- BINARY-DIGIT\"))\n          ((even? n) (cons\
    \ 0 (binary-digit (/ n 2))))\n          (else (cons 1 (binary-digit (- n 1))))))\n\
    \  (define (binary-digits n)\n    (if (= n 0)\n        '()\n        (append (binary-digit\
    \ n) (binary-digits (/ n 2)))))\n  (define (binary-number n)\n    (apply string-append\
    \ (map int-to-string (binary-digits n))))\n  (string-append (binary-number N)))\n",
  "  (number->string (integer-length (integer->binary N))))\n```\n\n\u7F16\u7A0B\u4E4B\
    \u7F8E\u7B2C15\u9898\uFF1A\n\n```racket\n#lang racket\n", "  (define (bin-acc\
    \ N b acc)\n    (cond [(zero? N) acc]\n          [(= (remainder N 2) 0) (bin-acc\
    \ (quotient N 2) (cons b acc))]\n          [else (bin-acc (quotient N 2) (cons\
    \ #t acc))]))\n  (string-join (bin-acc N '() '())))", "  (define (solve-iter N\
    \ ret)\n    (if (= 0 N) ret\n        (solve-iter (quotient N 2) (string-append\
    \ ret (number->string (remainder N 2))))))\n  (string-&gt;number (solve-iter N\
    \ \"\")))\n", "  (define (to-bin N)\n    (if (< N 2)\n        (number->string\
    \ N)\n        (append (to-bin (quotient N 2)) (number->string (remainder N 2)))))\n\
    \  (define (f N b-number)\n    (if (= N 0)\n        b-number\n        (f (quotient\
    \ N 10) (+ b-number (string->number (string-ref b-number (remainder N 10)))))))\n\
    \  (string-&gt;number (f N \"\")))\n", "  (if (= N 0) \"\"\n      (number->string\
    \ (modulo N 2))\n      (solve (quotient N 2))))\n", "  (number->string (integer-length\
    \ (integer->binary N))))\n```\n\n```racket\n#lang racket\n", "  (integer->string\
    \ (string->integer (bin->dec (dec->bin N)))))\n", "  (define (change n)\n    (cond\
    \ [(= n 0) \"\"]\n          [(= (remainder n 2) 0) (string-append (change (quotient\
    \ n 2)) \"0\")]\n          [else (string-append (change (quotient n 2)) \"1\"\
    )]))\n  (define (sum-digits n)\n    (cond [(= n 0) 0]\n          [else (+ (remainder\
    \ n 10) (sum-digits (quotient n 10)))]))\n  (if (= N 0)\n      \"0\"\n      (string-append\
    \ (change N) (number->string (sum-digits N)))))\n", "  (define (helper n)\n  \
    \  (if (eq? n 0) '()\n        (cons (remainder n 2) (helper (quotient n 2)))))\n\
    \  (apply string (reverse (helper N))))", "  (number->string (integer-length (bin\
    \ N))))\n", "  (define (sum-of-digits xs)\n    (cond [(null? xs) 0]\n        \
    \  [else (+ (car xs) (sum-of-digits (cdr xs)))]))\n  (define (binary-digits N)\n\
    \    (cond [(zero? N) '()]\n          [else (cons (remainder N 2) (binary-digits\
    \ (quotient N 2)))]))\n  (number->string (sum-of-digits (binary-digits N))))\n",
  '  (convert (integer->string (convert2 N))))', "  (string-append\n   (if (zero?\
    \ (remainder N 2)) \"0\" \"1\")\n   (solve (quotient N 2))))", "  (cond [(= N\
    \ 0) \"0\"]\n        [(= N 1) \"1\"]\n        [else (number->string (bin N))]))",
  "  (bin-string N))\n", "  (define sum 0)\n  (define (loop N)\n    (cond [(zero?\
    \ N) sum]\n          [else\n           (set! sum (+ sum (remainder N 2)))\n  \
    \         (loop (quotient N 2))]))\n  (loop N))\n", "  (define (solve-iter N binary-string)\n\
    \    (if (= N 0)\n        binary-string\n        (solve-iter (quotient N 2) (number->string\
    \ (remainder N 2)))))\n  (reverse (solve-iter N \"\")))", "  (integer->string\
    \ 2 (foldl + 0 (map (lambda (digit)\n                                       (char->integer\
    \ digit))\n                                     (string->list (integer->string\
    \ N 10))))))\n```\n\n**_Improved version_**\n\n\n```racket\n#lang racket\n", " \
    \ (cond\n    [(= 0 N) (write 0)]\n    [(= 1 N) (write 1)]\n    [else\n     (solve\
    \ (quotient N 2))\n     (write (remainder N 2))]))", "  (string-&gt;number (number-&gt;string\
    \ N) 2))\n</code>\nRacket shows me this error:\n<code>/Users/fhidalgor/Desktop/wizeline/code_challenges/0027/solve.rkt:12:18:\
    \ number-&gt;string: expects argument of type &lt;number&gt;; given 2\n</code>\n\
    What am I doing wrong?\n\n\nA:\n\nThat's because the base is not a separate argument,\
    \ it's part of the <code>radix</code> argument, together with the number to convert:\n\
    <code>(number-&gt;string (cons 2 N))\n</code>\nOr in full:\n<code>(number-&gt;string\
    \ (cons 2 N)\n                #:radix\n                (cons 2 N))\n</code>\n",
  '  (number->string (string->number (number->string N) 2)))', "  (if (= N 0)\n  \
    \    \"0\"\n      (define (recursion n)\n        (if (= n 0)\n            '()\n\
    \            (cons (remainder n 2) (recursion (quotient n 2)))))\n      (foldr\
    \ (lambda (x y) (string-append x y)) \"\" (recursion N))))\n", "  (list->string\
    \ (map symbol->string (reverse (integer->list 2 N)))))\n", "  (printf \"~a\\n\"\
    \n    (fold\n      (lambda (x acc) (+ x acc))\n      0\n      (map\n        (lambda\
    \ (x) (string->number (substring x 0 1) 2))\n        (filter\n          (lambda\
    \ (x) (not (string=? x \"\")))\n          (string-split (number->string N 2) \"\
    \"))))))\n```\n\n```c\n// C\n#include <stdio.h>\n#include <string.h>\n#include\
    \ <stdlib.h>\n\n#define TRUE 1\n#define FALSE 0\n\nint main() {\n  // Read a positive\
    \ integer\n  int N;\n  scanf(\"%d\", &N);\n\n  // Convert to binary\n  char bin[100];\n\
    \  sprintf(bin, \"%d\", N);\n\n  // Find the sum of all digits\n  int sum = 0;\n\
    \  for (int i = 0; i < strlen(bin); i++) {\n    sum += bin[i] - '0';\n  }\n\n\
    \  // Print result\n  printf(\"%d\\n\", sum);\n  return 0;\n}\n```\n\n## Output\n\
    ```\n15                                                                      \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                          ", "  (string-append\n\
    \   (number->string\n    (length\n     (substring\n      (number->string\n   \
    \    (integer-length\n        (string->number\n         (number->string N)\n \
    \       2))))))\n   (substring\n    (number->string\n     (string->number\n  \
    \    (number->string N)\n     2))\n    1)))\n", "  (define (binary n)\n    (cond\n\
    \      [(= n 0) \"\"]\n      [else (binary (- n (expt 2 (floor (log n 2)))))]))\n\
    \  (define (helper n i)\n    (if (string=? (binary i) \"\")\n        (string-append\
    \ (helper n (+ i 1)) (binary n))\n        (binary i)))\n  (string-trim (helper\
    \ N 0) #rx\"[0]\"))\n```\n\n## Strings Mix\n\n```racket\n#lang racket\n", "  (if\
    \ (= 0 N)\n      \"0\"\n      (let ((n N)\n            (bit \"\")\n          \
    \  (i   0))\n        (while (> n 0)\n          (set! bit (string-append bit (string\
    \ i)))\n          (set! n (/ n 2))\n          (set! i (remainder n 2)))\n    \
    \    (reverse bit))\n      )\n  )\n</code>\nAnd it works very well for some cases:\n\
    <code>&gt; (solve 1000)\n\"1\"\n&gt; (solve 150)\n\"110\"\n&gt; (solve 147)\n\"\
    1100\"\n</code>\nBut some others:\n<code>&gt; (solve 0)\n\"0\"\n&gt; (solve 1)\n\
    \"1\"\n&gt; (solve 10)\n\"01\"\n&gt; (solve 100)\n\"110\"\n&gt; (solve 1000)\n\
    \"1\"\n&gt; (solve 10000)\n\"11\"\n</code>\nIt seems the problem is around the\
    \ \"set!\" and \"modulo\", but I really don't understand where it's wrong.\nI'm\
    \ new to racket, so I would appreciate if you could help me.\n\n\nA:\n\nI suggest\
    \ you to use the <code>flatten</code> combinator, which takes a list of lists\
    \ and concatenates all of them:\n<code>(define (solve N)\n  (flatten (build-list\
    \ N (\u03BB (i) (string-&gt;list (number-&gt;string (remainder (quotient N (expt\
    \ 2 i)) 2)))))))\n</code>\nThis solution is short and straightforward, but it\
    \ could be improved by:\n\nReplacing <code>quotient</code> by <code>truncate/</code>,\
    \ which is more efficient;\nUsing <code>integer-&gt;list</code> instead of <code>number-&gt;string</code>\
    \ and <code>string-&gt;list</code>;\nUsing <code>reverse</code> instead of <code>flatten</code>.\n\
    \nThis would give us something like this:\n<code>(define (solve N)\n  (", "  (define\
    \ (recur n acc)\n    (if (= n 0)\n        acc\n        (recur (quotient n 2) (append\
    \ (list (remainder n 2)) acc))))\n  (string-join (recur N (list)) \"\"))\n", " \
    \ (number->string (foldl (lambda (acc n) (+ acc n)) 0 (string->list (number->string\
    \ (integer->binary N)) ) ) )\n  )\n", "  (integer->string (decimal-to-binary N)))\n",
  "  (string-&gt;number (number-&gt;string N) 2))\n</code>\n", "  (define (to-bin\
    \ n)\n    (cond [(= n 0) '()]\n          [else (append (to-bin (quotient n 2))\
    \ (list (remainder n 2)))]))\n  (cond [(= N 0) \"0\"]\n        [else (apply string-append\
    \ (to-bin N))]))\n```\n\n```\n#lang racket\n", "  (bin N))\n", "  (let ([n N])\n\
    \    (if (< n 0)\n        (string-append (solve (- n)) \"1\")\n        (if (=\
    \ n 0) \"0\"\n            (string-append (solve (quotient n 2)) (number->string\
    \ (remainder n 2)))))))\n", "  (string-join (reverse (string-&gt;list (integer-&gt;string\
    \ (string-&gt;number (integer-&gt;string N) 2)))))\n  )\n</code>\nUpdate: I don't\
    \ understand how my code is better than <code>(solve 150)</code>... ?\n<code>#lang\
    \ racket\n", "  (define (bin N)\n    (cond ((= N 0) '())\n          ((modulo N\
    \ 2)\n           (cons 1 (bin (quotient N 2))))\n          (else\n           (cons\
    \ 0 (bin (quotient N 2))))))\n  (apply + (bin N)))\n```\n\n# Problem 16\n\n```\
    \ #lang racket\n", "  (number->string (integer-length (integer->binary N))))\n",
  "  (define (decimal-to-binary dec)\n    (if (equal? dec 0)\n        '()\n      \
    \  (append (decimal-to-binary (quotient dec 2)) (list (remainder dec 2)))))\n\
    \  (string-append\n   (apply string-append (map number->string (decimal-to-binary\
    \ N)))))\n\n```", '  (byte-vector-length (number->string N 2)))', "  (define (sum-of-digits-in-binary\
    \ n)\n    (cond [(= n 0) 0]\n          [else (+ (remainder n 2) (sum-of-digits-in-binary\
    \ (quotient n 2)))]))\n  (number->string (sum-of-digits-in-binary N)))\n", " \
    \ (cond [(>= N 2) (string-append (solve (/ N 2)) (number->string (% N 2)))]\n\
    \        [(<= N 1) (number->string N)]))", '  (bigint->bignum (bignum->bases (bignum
    N) 2)))', "  (display (number->string N 2)))\n", "  (if (positive? N)\n      (integer->string\
    \ (sum-digits-binary N))\n      (display \"N is not a positive integer!\")))\n",
  "  (integer->string 2\n                   (foldl + 0\n                         \
    \ (map (lambda (x) (string->number (string x) 2))\n                          \
    \     (string-&gt;list (integer-&gt;string N 10))))))\n</code>\nThe routine just\
    \ uses the built-in <code>integer-&gt;string</code> to convert <code>N</code>\
    \ to a string in base 10, then converts that to a list of characters using <code>string-&gt;list</code>,\
    \ then converts each character back to a number in base 2 using <code>string-&gt;number</code>,\
    \ and finally folds over the list of results to sum them up.  In the final step\
    \ it converts the result back to a string in base 2 using <code>integer-&gt;string</code>.\n\
    Testing it out:\n<code>&gt; (solve 1000)\n\"1\"\n&gt; (solve 150)\n\"110\"\n&gt;\
    \ (solve 147)\n\"1100\"\n</code>\n\nEDIT:  It occurs to me that an alternative\
    \ solution would be to use the built-in <code>number-&gt;string</code> function:\n\
    <code>#lang racket\n", "    (integer->string (bin-to-dec (n->bin N))))\n", " \
    \ (number->string (integer-length (integer->binary N))))\n```\nTest:\n```racket",
  "  (string-join\n   (reverse\n    (map\n     string\n     (build-list\n      (quotient/remainder\
    \ N 2)\n      (\u03BB (x y)\n        (quotient/remainder x 2)))))))\n", "  (if\
    \ (= N 0)\n      \"0\"\n      (reverse (conv N))))\n", "  (define (aux n acc)\n\
    \    (cond\n      [(< n 2) (number->string n)]\n      [else (aux (quotient n 2)\
    \ (+ (remainder n 2) acc))]))\n  (aux N 0))\n", "  (define (to-binary-string n)\n\
    \    (let loop ((n n) (accum (list)))\n      (if (= n 0)\n          (reverse accum)\n\
    \          (loop (quotient n 2) (cons (modulo n 2) accum)))))\n  (define (accumulate\
    \ n)\n    (let loop ((n n) (accum 0))\n      (if (= n 0)\n          accum\n  \
    \        (loop (quotient n 10) (+ accum (modulo n 10))))))\n  (accumulate (apply\
    \ + (map (\u03BB (e) (string->number (number->string e))) (map (\u03BB (e) (string->number\
    \ (number->string e))) (to-binary-string N))))))\n", '  (number->string (integer-length
    (integer->binary N))))', '  (number->string (car (string->number (number->string
    N) 2))))', "  ;; convert N to a binary string\n  (number->string (string->number\
    \ (number->string N 2) 10)))\n", "  (if (= N 0)\n      \"0\"\n      (get-binary\
    \ (integer->binary N))))\n", "  (define (solve_step N carry)\n    (if (= N 0)\n\
    \        (if (= carry 0)\n            \"\"\n            (number->string carry))\n\
    \        (let* ([digit (- N 1) mod-2 (modulo digit 2)]\n               [carry\
    \ (if (= mod-2 0) 0 1)])\n          (string-append (number->string mod-2)\n  \
    \                       (solve_step (quotient N 2) carry)))))\n  (solve_step N\
    \ 0))\n", "  (number->string (integer-length N 2)))\n", "  (string-append\n  \
    \ (integer->binary (quotient N 10))\n   (integer->binary (remainder N 10))))\n\
    </code>\nWhen I run it, I get the following error:\n<code>integer?:: expects type\
    \ &lt;integer&gt; as 1st argument, given: \"1\"; other arguments were:\n\"0\"\n\
    \  in: (integer? \"1\" \"0\")\n  context...:\n   /home/martin/git/sql-kata/racket/sqlkata6.rkt:42:13\n\
    \   /home/martin/git/sql-kata/racket/sqlkata6.rkt:41:17\n   /home/martin/git/sql-kata/racket/sqlkata6.rkt:39:35\n\
    \   /home/martin/git/sql-kata/racket/sqlkata6.rkt:39:26\n   /home/martin/git/sql-kata/racket/sqlkata6.rkt:40:17\n\
    \   /home/martin/git/sql-kata/racket/sqlkata6.rkt:39:35\n   /home/martin/git/sql-kata/racket/sqlkata6.rkt:39:26\n\
    </code>\nThe problem seems to be with the quotes. I tried the code from another\
    \ point of view:\n<code>#lang racket\n", "  (define (b2d n)\n    (cond\n     \
    \ [(= n 0) 0]\n      [(= n 1) 1]\n      [else (+ (* (b2d (/ n 2)) 10) (modulo\
    \ n 2))]))\n  (define (d2b n)\n    (cond\n      [(= n 0) \"\"]\n      [else (d2b\
    \ (/ n 2)) (number->string (modulo n 2))]))\n  (define (sum x)\n    (cond\n  \
    \    [(= x 0) 0]\n      [else (+ (modulo x 10) (sum (/ x 10)))]))\n  (define (d2b2\
    \ n)\n    (cond\n      [(= n 0) \"\"]\n      [else (d2b2 (/ n 2)) (number->string\
    \ (modulo n 2))]))\n  (d2b2 (sum (b2d N))))\n", "  (display (number->string (bin2dec\
    \ (dec2bin N)))))\n", "  (let* ([bin (number->string N 2)]\n         [sum (apply\
    \ + (map string->number (string-&gt;list bin)))]\n         [result (number->string\
    \ sum 2)])\n    result))\n</code>\nI would appreciate any feedback.\nThank you\
    \ for your time.\n\n\nA:\n\nI think the algorithm is correct, but the implementation\
    \ could be improved.\n\nFirst of all, notice that the algorithm itself doesn't\
    \ really need to work with strings at all - you're only working with the digits\
    \ of the binary number, and not the actual number itself. So, start by converting\
    \ the given number to binary:\n<code>(define (solve N)\n  (let ([sum (apply +\
    \ (map string-&gt;number (string-&gt;list (number-&gt;string N 2))))])\n    (number-&gt;string\
    \ sum 2)))\n</code>\nThen, we can use the <code>integer-&gt;digits</code> function\
    \ to obtain the list of binary digits:\n<code>(define (solve N)\n  (let ([sum\
    \ (apply + (integer-&gt;digits N 2))])\n    (number-&gt;string sum 2)))\n</code>\n\
    And simplify further, using the <code>foldl</code> function to compute the sum:\n\
    <code>(define (solve N)\n  (number-&gt;string (foldl + 0 (integer-&gt;digits N\
    \ 2)) 2))\n</code>\nI'd recommend using a more descriptive name for the argument,\
    \ such as <code>number</code>, and also a more descriptive name for the local\
    \ variable, such as <code>total</code>:\n<code>(define (solve number)\n  (number-&gt;string\
    \ (foldl + 0 (integer-&gt;digits number 2)) 2))\n</code>\nFinally, the <code>solve</code>\
    \ function is almost equivalent to the <code>binary-sum</code> function in the\
    \ library, so it would be simpler to write:\n<code>(define (solve number)\n  (number-&gt;string\
    \ (binary-sum number) 2))\n</code>\n\nOn a different note, it looks like you're\
    \ solving this problem as part", "  (list->string (reverse (integers->list (remainders\
    \ 2 N)))))\n", "  (bytes->string/utf-8\n   (bytes-append\n    (integer->bytes\
    \ N 2)\n    (bytes 10))))", "  (define (my-b N)\n    (if (= N 0)\n        '()\n\
    \        (append (my-b (quotient N 2)) (list (remainder N 2)))))\n  (define (my-sum\
    \ L)\n    (if (null? L)\n        0\n        (+ (car L) (my-sum (cdr L)))))\n \
    \ (number->string (my-sum (my-b N))))\n</code>\n", "  (integer->string N 2))\n",
  "  (define (solve-r n d)\n    (if (= n 0)\n        d\n        (solve-r (quotient\
    \ n 2)\n                 (cons (modulo n 2) d))))\n  (display (list->string (reverse\
    \ (solve-r N '()))))\n  (newline))\n", "  (number->string (bitwise-count (integer->binary\
    \ N))))\n```\n\n```racket\n#lang racket\n", "  (binary-string (integer->binary\
    \ N)))\n", "  (define (length_of_N)\n    (let loop ((N N) (len 0))\n      (if\
    \ (&lt; N 2)\n          len\n          (loop (quotient N 2) (+ len 1)))))\n  (define\
    \ (binary_of_N)\n    (let loop ((len (length_of_N)) (N N) (lst '()))\n      (if\
    \ (= len 0)\n          lst\n          (loop (- len 1) (quotient N 2) (cons (remainder\
    \ N 2) lst)))))\n  (define (total_sum lst)\n    (if (null? lst)\n        0\n \
    \       (+ (car lst) (total_sum (cdr lst)))))\n  (total_sum (binary_of_N)))\n\
    </code>\n\n<code>#lang racket\n", "  (define (helper d n)\n    (if (= d n)\n \
    \       \"\"\n        (number->string (+ (* 2 (modulo n 2)) (string->number (helper\
    \ (add1 d) (quotient n 2)))))))\n  (helper 0 N))", "  (integer->string\n   (foldl\
    \ + 0\n          (map (lambda (x)\n                 (char->integer x))\n     \
    \          (string->list (integer->binary N))))))\n", "  (cond ((= N 0) \"0\"\
    )\n        ((= N 1) \"1\")\n        (else (string-append (solve (/ N 2)) (number->string\
    \ (% N 2))))))\n", "  (define (div n)\n    (if (= n 0)\n        0\n        (+\
    \ (* (modulo n 2) (expt 10 (div (- n 1)))))))\n  (display (+ (div N) (modulo N\
    \ 2))))", "  (number->string (bitwise-count (decimal->integer N) 2)))\n\n```",
  '  (integer->string 2 (string->number (number->string N) 10)))', "  (define xs (string->list\
    \ (number->string N)))\n  (define (helper1 xs)\n    (cond\n      [(empty? xs)\
    \ empty]\n      [else (cons (string->number (list->string (list (car xs)))) (helper1\
    \ (cdr xs)))]))\n  (define (helper2 ls)\n    (cond\n      [(empty? ls) empty]\n\
    \      [else (cons (integer->exact-integer (car ls)) (helper2 (cdr ls)))]))\n\
    \  (define (helper3 ls)\n    (cond\n      [(empty? ls) empty]\n      [else (cons\
    \ (modulo (car ls) 2) (helper3 (cdr ls)))]))\n  (define (helper4 ls)\n    (cond\n\
    \      [(empty? ls) empty]\n      [else (cons (car ls) (helper4 (cdr ls)))]))\n\
    \  (define (helper5 ls)\n    (cond\n      [(empty? ls) empty]\n      [else (cons\
    \ (number->string (car ls)) (helper5 (cdr ls)))]))\n  (list->string (helper5 (helper4\
    \ (helper3 (helper2 (helper1 xs)))))))\n\n```\n\n```\n[(define (solve N)\n  (define\
    \ xs (string->list (number->string N)))\n  (define (helper1 xs)\n    (cond\n \
    \     [(empty? xs) empty]\n      [else (cons (string->number (list->string (list\
    \ (car xs)))) (helper1 (cdr xs)))]))\n  (define (helper2 ls)\n    (cond\n    \
    \  [(empty? ls) empty]\n      [else (cons (integer->exact-integer (car ls)) (helper2\
    \ (cdr ls)))]))\n  (define (helper3 ls)\n    (cond\n      [(empty? ls) empty]\n\
    \      [else (cons (modulo (car ls) 2) (helper3 (cdr ls)))]))\n  (define (helper4\
    \ ls)\n    (cond\n      [(empty? ls) empty]\n     ", "  (string-&gt;number (string-append\
    \ (map (\u03BB (x)\n                                         (if (= x #\\0)\n\
    \                                             #\\1\n                         \
    \                    #\\0))\n                                       (number-&gt;string\
    \ (integer-&gt;binary N))))\n                   2))\n</code>\n<code>#lang racket\n",
  "  ;; Convert into binary\n  (string-&gt;number (bin N) 2))\n", '  (bin N))', " \
    \ (define-values (q r) (quotient/remainder N 2))\n  (cond\n    [(zero? q) (number->string\
    \ r)]\n    [else (string-append (solve q) (number->string r))]))\n", "  (cond\
    \ [(< N 0) \"not a positive integer\"]\n        [(<= N 10000) (integer->string\
    \ (integer-length (integer->binary N)))]\n        [else \"greater than 10000\"\
    ]))\n", "  (integer->string\n   (string->number (integer->string N) 2)))\n", " \
    \ (string-&gt;number (integer-&gt;string N) 2))\n</code>\nHowever, we can't assume\
    \ that the judge will have a Racket environment. In fact, we have to assume that\
    \ the judge doesn't have Racket, because it's not listed in the provided runtimes.\n\
    The only language with a runtime in this contest is C#, which has a built-in <code>Convert.ToString</code>\
    \ function:\n<code>namespace solution\n{\n  using NUnit.Framework;\n  using System;\n\
    \n  [TestFixture]\n  public class KataTest\n  {\n    [Test]\n    public void BasicTests()\n\
    \    {\n      Assert.AreEqual(\"1\", Kata.Solve(1000));\n      Assert.AreEqual(\"\
    110\", Kata.Solve(150));\n      Assert.AreEqual(\"1100\", Kata.Solve(147));\n\
    \    }\n  }\n\n  public class Kata\n  {\n    public static string Solve(int N)\n\
    \    {\n      return Convert.ToString(N, 2);\n    }\n  }\n}\n</code>\n", "  (cond\n\
    \    [(= N 0) \"0\"]\n    [(= N 1) \"1\"]\n    [else\n     (if (even? N)\n   \
    \      (string-append (solve (/ N 2)) \"0\")\n         (string-append (solve (-\
    \ (/ N 2) 1)) \"1\"))]))\n", "  (cond ((= N 0) \"0\")\n        ((&gt; N 0)\n \
    \        (number-&gt;string (bitwise-ior (remainder N 2) (quotient N 2))))))\n\
    </code>\nUpon testing with 10, it results in a string type\n<code>&gt; (solve\
    \ 10)\n\"1010\"\n</code>\nbut when it is run against the provided test, it fails\
    \ with a contract violation:\n<code>Expected: (solve 10) to produce \"1010\"\n\
    Actual: \"1010\"\nat: eval:20.0\n</code>\nIt seems \"1010\" is a string type,\
    \ why would it fail?\n\n\nA:\n\nTry this:\n<code>(define (solve N)\n  (cond ((=\
    \ N 0) \"0\")\n        ((&gt; N 0)\n         (string-&gt;number (number-&gt;string\
    \ (bitwise-ior (remainder N 2) (quotient N 2)))))))\n</code>\n", "  (string-&gt;number\n\
    \   (string-join\n    (map\n     (lambda (i)\n       (list-ref (list #\\0 #\\\
    1) i))\n     (map\n      (lambda (i)\n        (remainder i 2))\n      (build-list\
    \ N add1 0))))\n   2))\n</code>\nThis is the code that I wrote. I want to know\
    \ if this is the shortest code possible. Because, I want to learn the shortest\
    \ and clearest code that I can write.\nThanks in advance.\n\n\nA:\n\nI'd say that\
    \ two or three lines are a reasonable limit. For example, this could be a good\
    \ approach:\n<code>(define (solve n)\n  (number-&gt;string (integer-&gt;radix\
    \ n 2)))\n</code>\nAs it stands, this code is a bit too permissive: it accepts\
    \ negative numbers, zeros, and numbers larger than the allowed range. But in this\
    \ case, the limits of the problem are not well defined, so I'm going to ignore\
    \ it for the sake of simplicity. Here's an alternate implementation that takes\
    \ care of this aspect:\n<code>(define (solve n)\n  (define (in-range? n)\n   \
    \ (and (&gt;= n 0) (&lt;= n 10000)))\n  (cond ((not (in-range? n))\n         \"\
    invalid input\")\n        ((zero? n)\n         \"0\")\n        (else\n       \
    \  (number-&gt;string (integer-&gt;radix n 2)))))\n</code>\n", "  (string-append\
    \ \"in the process of being solved...\"))\n```\n\nTo run the challenge test:\n\
    \n`raco test -x binary-sum.rkt`\n\n## Submit your solution\n\n```\nraco submit\
    \ binary-sum.rkt jklmnn/CHALLENGE/1\n```\n\nThe above command will:\n- rename\
    \ `binary-sum.rkt` to your GitHub username (eg. `jklmnn-binary-sum.rkt`)\n- archive\
    \ the solution (eg. `jklmnn-binary-sum.zip`)\n- upload the archive to the repository\n\
    \n## Get feedback about your solution\n\n```\nraco submit binary-sum.rkt jklmnn/CHALLENGE/1\
    \ -F\n```\n\nThe above command will:\n- rename `binary-sum.rkt` to your GitHub\
    \ username (eg. `jklmnn-binary-sum.rkt`)\n- archive the solution (eg. `jklmnn-binary-sum.zip`)\n\
    - upload the archive to the repository\n- open a browser window with the feedback\
    \ page\n\n## Make the next challenge\n\nTo create a challenge, use the script\
    \ `make-challenge.rkt` in this repository.\n\n- First create a new GitHub repository\
    \ to hold this new challenge.\n- Update the `CHALLENGE` variable in `make-challenge.rkt`\
    \ to point to your new repository.\n- Run the script: `racket make-challenge.rkt`.",
  "  (number->string (bin N)))\n", "  (let ([n (integer->exact-integer N)])\n    (define\
    \ (sum x)\n      (cond [(zero? x) 0]\n            [else (+ (remainder x 10) (sum\
    \ (quotient x 10)))]))\n    (let loop ([m (number->string (exact->inexact n) 2)]\n\
    \               [accum \"\"])\n      (cond [(zero? (string-length m)) accum]\n\
    \            [else (loop (substring m 1) (string-append accum (number->string\
    \ (sum (string->number (substring m 0 1)) 2))))]))))\n", "  (let [binary (string-append\
    \ (number->string N) \"b0\")]\n    (string-append \"0b\" (regexp-replace* #rx\"\
    0b0?\" binary \"\"))))\n", '  (display (string-length (integer->string (integer-length
    N)))))', "  (convert-base N 2))\n", "  (define (to-binary n)\n    (if (= n 0)\
    \ '()\n        (cons (% n 2) (to-binary (quotient n 2)))))\n  (define (sum-bin\
    \ n)\n    (apply + (to-binary n)))\n  (number->string (sum-bin N)))\n", "  (define\
    \ (bin-to-list n)\n    (cond ((zero? n) '())\n          (else (cons (remainder\
    \ n 2) (bin-to-list (quotient n 2))))))\n  (define (calculate-sum lst)\n    (cond\
    \ ((null? lst) 0)\n          (else (+ (car lst) (calculate-sum (cdr lst))))))\n\
    \  (number->string (calculate-sum (bin-to-list N))))\n", "  (number->string (bin-sum\
    \ N)))\n", "  (let ([R (build-list N (\u03BB (x) (random 50)))]\n        [Rstr\
    \ (map number->string R)])\n    (string-join Rstr \"\")))\n", "  (cond [(= N 0)\
    \ \"0\"]\n        [(= N 1) \"1\"]\n        [else (solve (quotient N 2))]))\n",
  "  (number->string (number->string N 2)))\n```\n\n![Result](https://github.com/nojaf/python-challenges/blob/master/images/2.jpg)\n\
    \n_3_\n```racket\n#lang racket\n", "  (define (solve-iter N sum)\n    (if (= N\
    \ 0)\n        sum\n        (solve-iter (quotient N 2) (string-append sum (number->string\
    \ (remainder N 2))))))\n  (solve-iter N \"\"))\n", "  (letrec ([n N]\n       \
    \    [binlist (list (remainder n 2))])\n    (if (= n 0)\n        \"\"\n      \
    \  (begin\n          (set! n (quotient n 2))\n          (set! binlist (cons (remainder\
    \ n 2) binlist))\n          (solve n)))))\n", "  (define (count-digits n)\n  \
    \  (cond [(< n 1) 0]\n          [else (+ 1 (count-digits (/ n 2)))]))\n  (define\
    \ (get-digit n b)\n    (cond [(< b 0) \"\"]\n          [(= b 0) \"\"]\n      \
    \    [(= (modulo n (expt 2 b)) 0) (get-digit n (- b 1))]\n          [else (string-append\
    \ (get-digit n (- b 1)) \"1\")]))\n  (get-digit N (count-digits N)))", '  (build-string
    (integer->binary N)))', "  (cond\n    [(= N 0) \"0\"]\n    [(= N 1) \"1\"]\n \
    \   [else\n     (string-append\n      (solve (quotient N 2))\n      (number->string\
    \ (remainder N 2)))]))\n", "  (cond\n    [(zero? N) \"0\"]\n    [(equal? N 1)\
    \ \"1\"]\n    [else (number->string (remainder N 2))]))\n", "  (cond [(= N 0)\
    \ \"0\"]\n        [(= N 1) \"1\"]\n        [else\n         (string-append (solve\
    \ (quotient N 2)) (number->string (remainder N 2)))]))\n</code>\nI got the answer\
    \ from this piece of code, but my <code>remainder</code> gives me <code>1</code>\
    \ instead of <code>3</code> when it is <code>11</code>. \nWhat's wrong with it?\n\
    <code>#lang racket", "  ;; >>>> Your solution goes here <<<<\n  (string-&gt;number\
    \ (number-&gt;string (apply + (map char-&gt;integer (regexp-split #rx\"\" (number-&gt;string\
    \ N 2)) ))) 2))\n</code>\n\u043F\u0440\u043E\u0432\u0435\u0440\u044F\u044E \u0442\
    \u0430\u043A:\n<code>#lang racket", "  (cond\n    [(< N 0) \"0\"]\n    [(> N 10000)\
    \ \"10000\"]\n    [else (number->string N 2)]))\n", "  (define (convert n)\n \
    \   (define (iter n acc s)\n      (cond [(zero? n) (list-&gt;string (reverse acc))]\n\
    \            [(even? n) (iter (/ n 2) (cons #\\0 acc) (+ s 1))]\n            [else\
    \ (iter (/ (- n 1) 2) (cons #\\1 acc) (+ s 1))]))\n    (iter n null 0))\n  (convert\
    \ N))\n", "  (let* ([bin-str (integer->string N 2)]\n         [sum (apply + (map\
    \ string->number (string-&gt;list bin-str)))])\n    (number-&gt;string sum)))\n",
  "  (number->string (binary N)))\n", "  (number->string N 2))\n```\n\n## [1.20](http://www.puzzlenode.com/puzzles/6-running-median)\n\
    \n```racket\n#lang racket\n", "  (cond [(>= N 10000) \"Please enter an integer\
    \ between 0 and 10000\"]\n        [(<= N 0) \"Please enter an integer between\
    \ 0 and 10000\"]\n        [else (number->string (bin-sum N))]))\n", "  (integer->string\
    \ (number->string (number->string N 2) 10)))\n```\n\n### Problem 4 - Counting\
    \ Duplicates\n\n``` #lang racket\n", "  (define (sum-digits-in-binary N)\n   \
    \ (if (= N 0)\n        0\n        (+ (remainder N 2)\n           (sum-digits-in-binary\
    \ (quotient N 2)))))\n  (number->string (sum-digits-in-binary N)))\n```\n\n##\
    \ Testing\n\nThe `Solve.Rkt` file includes both testing and sample code at the\
    \ end. It is a\ngood idea to add more tests for edge cases.\n\n## License\n\n\
    <p xmlns:dct=\"http://purl.org/dc/terms/\" xmlns:vcard=\"http://www.w3.org/2001/vcard-rdf/3.0#\"\
    >\n  <a rel=\"license\"\n     href=\"http://creativecommons.org/publicdomain/zero/1.0/\"\
    >\n    <img src=\"http://i.creativecommons.org/p/zero/1.0/88x31.png\" style=\"\
    border-style: none;\" alt=\"CC0\" />\n  </a>\n  <br />\n  To the extent possible\
    \ under law,\n  <a rel=\"dct:publisher\"\n     href=\"sirodoht.com\">\n    <span\
    \ property=\"dct:title\">Travis Faas</span></a>\n  has waived all copyright and\
    \ related or neighboring rights to\n  <span property=\"dct:title\">Solution to\
    \ HackerRank Problem - Sum Of Digits - Binary</span>.\nThis work is published\
    \ from:\n<span property=\"vcard:Country\" datatype=\"dct:ISO3166\"\n      content=\"\
    US\" about=\"sirodoht.com\">\n  United States</span>.\n</p>", "  (cond\n    [(=\
    \ N 0) \"0\"]\n    [(= N 1) \"1\"]\n    [else (binary-append (solve (/ N 2)) (quotient\
    \ N 2))]))\n", "  (cond\n    [(= N 0) \"0\"]\n    [(= N 1) \"1\"]\n    [else\n\
    \     (string-append\n      (solve (quotient N 2))\n      (if (= (remainder N\
    \ 2) 0) \"0\" \"1\"))]))", "  (int-&gt;string (add-digits (integer-&gt;binary\
    \ N))))\n", "  (number->string (string->number (number->string N) 2)))\n```\n\n\
    ## SUM OF DIGITS\n\nIn this task you are given a positive integer N.\nYour task\
    \ is to calculate its total sum of digits.\n\n### INPUT:\n\nThe only line of input\
    \ contains a single integer N.\n\n### OUTPUT:\n\nPrint one line with the total\
    \ sum of digits.\n\n#### CONSTRAINTS:\n\n0 \u2264 N \u2264 10000.\n\n#### EXAMPLE:\n\
    \n##### Input:\n```\n13\n```\n##### Output:\n```\n4\n```\n\n##### Explanation:\n\
    ```\n\"13\" -> (1 + 3) = 4\n```\n\n##### Solution:\n```racket\n#lang racket\n",
  '  (number->string (string->number (number->string N) 2)))', '  (integer->string
    (bin-sum N)))', '  (number->string (string->number (number->string N) 2)))', " \
    \ (displayln N)\n  (integer->string N 2))\n", "  (bytes->string (integer->bytes\
    \ N 2)))\n", "  (integer->string\n   (exact->inexact\n    (string->number\n  \
    \   (string-reverse\n      (number->string\n       (integer->exact\n        (string->number\n\
    \         (number->string\n          (bitwise-and N 15)\n          2)\n      \
    \   10)\n        2))))\n     2))))\n```\n\n### \u0424\u0443\u043D\u043A\u0446\u0438\
    \u044F \u0434\u043B\u044F \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0438\n\n\
    \u0417\u0430\u043F\u0443\u0441\u043A\u0430\u0435\u0442 \u043F\u0440\u043E\u0432\
    \u0435\u0440\u043A\u0443 \u0432\u0430\u0448\u0435\u0433\u043E \u0440\u0435\u0448\
    \u0435\u043D\u0438\u044F \u043D\u0430 \u0440\u044F\u0434\u0435 \u0441\u043B\u0443\
    \u0447\u0430\u0435\u0432.\n\n\u0415\u0441\u043B\u0438 \u0432\u0441\u0435 \u0441\
    \u043B\u0443\u0447\u0430\u0438 \u043F\u0440\u043E\u0445\u043E\u0434\u044F\u0442\
    \ \u0443\u0441\u043F\u0435\u0448\u043D\u043E, \u0442\u043E \u043F\u043E\u044F\u0432\
    \u0438\u0442\u0441\u044F \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0435\
    \ `All test cases passed.`.\n\n\u0415\u0441\u043B\u0438 \u043A\u0430\u043A\u043E\
    \u0439-\u0442\u043E \u0441\u043B\u0443\u0447\u0430\u0439 \u043D\u0435 \u043F\u0440\
    \u043E\u0445\u043E\u0434\u0438\u0442, \u0442\u043E \u043F\u0440\u0435\u043A\u0440\
    \u0430\u0442\u0438\u0442 \u0432\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u0438\
    \u0435 \u0438 \u0432\u044B\u0432\u0435\u0434\u0435\u0442 \u0432 \u043A\u043E\u043D\
    \u0441\u043E\u043B\u044C \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0435\
    \ \u043E\u0431 \u043E\u0448\u0438\u0431\u043A\u0435.\n\n```scheme\n#lang racket\n",
  "  (number->string (byte-oriented->integer\n                   (integer->byte-oriented\
    \ N 2))))", '  (number->string (bitwise-count (inexact->exact (string->number
    (number->string N) 2)))))', "  (list->string (list->string (to-binary N))))\n\
    ```\n\n\u4E0A\u9762\u7684\u89E3\u6CD5\uFF0C\u6709\u4EE5\u4E0B\u95EE\u9898\uFF1A\
    \n\n1. \u6CA1\u6709\u5904\u7406\u8F93\u5165\u6570\u5B57\u7684\u7EA6\u675F\u6761\
    \u4EF6\uFF1B\n2. \u89E3\u51B3\u65B9\u6848\u4E2D\uFF0C\u8F93\u5165\u7C7B\u578B\u4E3A\
    integer\uFF0C\u8F93\u51FA\u7C7B\u578B\u4E3Astring\uFF0C\u89E3\u51B3\u65B9\u6848\
    \u4E2D\u5E76\u6CA1\u6709\u6D89\u53CA\u7C7B\u578B\u8F6C\u6362\uFF1B\n3. \u4EE3\u7801\
    \u4E2D\u5E94\u7528\u4E86\u5D4C\u5957\u8C03\u7528\uFF0C\u5E76\u4E14\u5D4C\u5957\
    \u8C03\u7528\u7684\u6B21\u6570\u4E0D\u6B62\u4E00\u6B21\uFF1B\n4. \u89E3\u51B3\u65B9\
    \u6848\u4E2D\uFF0C`list->string` \u8FD9\u4E2A\u51FD\u6570\u88AB\u4F7F\u7528\u4E86\
    \u4E24\u6B21\uFF0C\u800C\u4E14\u53EA\u662F\u4E3A\u4E86\u8F93\u51FA\u5B57\u7B26\
    \u4E32\uFF0C\u6240\u4EE5\u5E94\u8BE5\u8BBE\u8BA1\u6210\u4E00\u4E2A\u666E\u901A\
    \u51FD\u6570\uFF0C\u800C\u4E0D\u662F\u8FC7\u7A0B\uFF1B\n5. \u51FD\u6570 `to-binary`\
    \ \u7684\u540D\u79F0\u4E0D\u591F\u660E\u786E\uFF0C\u5E94\u8BE5\u8D77\u540D\u4E3A\
    `convert-decimal-to-binary`\uFF1B\n6. \u51FD\u6570 `solve` \u7684\u540D\u79F0\u4E0D\
    \u591F\u660E\u786E\uFF0C\u5E94\u8BE5\u8D77\u540D\u4E3A`binary-sum`\uFF1B\n7. \u51FD\
    \u6570 `list->string` \u7684\u540D\u79F0\u4E0D\u591F\u660E\u786E\uFF0C\u5E94\u8BE5\
    \u8D77\u540D\u4E3A`to-string`\uFF1B\n8. \u6839\u636E\u51FD", "  (string-&gt;number\
    \ (string-join (list-&gt;string (build-list N #(1))) \"\")))\n</code>\nNow I have\
    \ a Python solution to this problem:\n<code>def solve(n):\n    return int(''.join(map(str,\
    \ [1] * n)), 2)\n</code>\nA Ruby solution:\n<code>def solve(n)\n  n.times.collect\
    \ { 1 }.join.to_i(2)\nend\n</code>\nAnd a Haskell solution:\n<code>solve :: Int\
    \ -&gt; Int\nsolve = read . concat . flip replicate \"1\"\n</code>\nWhile I'm\
    \ certain the Ruby solution isn't very performant, the Haskell and Python solutions\
    \ are absolutely horrific to read.\nDo I have a wrong bias for the Racket solution\
    \ here?\n\n\nA:\n\nThe Racket solution is the most readable to me, and frankly,\
    \ from what I know about Haskell and Python, the last two solutions are not only\
    \ unreadable, but they're bad solutions.\nThere are some small things that can\
    \ be improved in the Racket solution.\nFirst, the sample inputs are given inline\
    \ with the question.  It's better to set them up as test cases, so that they can\
    \ be run automatically.  I've done this with the <code>check-expect</code> facility.\n\
    Second, it's a good idea to use a descriptive function name.  <code>solve</code>\
    \ is very generic, and doesn't hint at what the function actually does.  I've\
    \ renamed it to <code>sum-of-bits</code>.\nThird, the expression <code>(string-&gt;number\
    \ (string-join (list-&gt;string (build-list N #(1))) \"\"))</code> is very long,\
    \ and can be shortened by using intermediate variables and/or functions.  I've\
    \ done this by first building the string of <code>1</code>s, then using a function\
    \ <code>base-string-&gt;number</code> to convert it to a number.\nFourth, the\
    \ <code>base-string-&gt;number</code> function can be used to express the example\
    \ inputs in a less repetitive way.\nFifth, it's a good idea to include a test\
    \ case for", "  (number->string (integer-length (integer->binary N))))\n```\n\n\
    ###### Binary Challenge: \n\n```racket\n#lang racket\n", "  (define (dec_to_bin\
    \ n)\n    (if (zero? n) \"0\"\n      (if (not (zero? n))\n          (string-append\
    \ (dec_to_bin (quotient n 2)) (number->string (remainder n 2)))\n          )))\n\
    \  (define (add_digits s)\n    (foldl (lambda (x y) (+ (string->number (string\
    \ x)) y)) 0 (string-split s \"\")))\n  (number->string (add_digits (dec_to_bin\
    \ N))))\n", "  (if (zero? N)\n      \"0\"\n      (if (equal? N 1)\n          \"\
    1\"\n          (cons (remainder N 2) (solve (quotient N 2))))))\n", "  (string-&gt;number\n\
    \   (number-&gt;string\n    (apply + (map (lambda (x)\n                    (string-&gt;number\n\
    \                     (number-&gt;string\n                      (string-&gt;number\n\
    \                       (number-&gt;string\n                        (round\n \
    \                        (string-&gt;number\n                          (number-&gt;string\n\
    \                           (string-&gt;number (number-&gt;string N))))))\n  \
    \                     2))\n                     10))\n                  (string-&gt;list\n\
    \                   (number-&gt;string\n                    (round\n         \
    \            (string-&gt;number\n                      (number-&gt;string\n  \
    \                     (string-&gt;number (number-&gt;string N))))))\n        \
    \           2))))\n   10))\n</code>\n", "  (string-join\n   (list->string\n  \
    \  (list->set\n     (list->sorted-list\n      (map string->number\n          \
    \ (regexp-split #rx\"0|1\"\n                         (number->string (integer->binary\
    \ N)))))))))\n", "  (string-&gt;number (number-&gt;string (string-&gt;number (number-&gt;string\
    \ N 10) 2) 10)))\n</code>\nMy doubts are that I have to use math/number functions\
    \ to write this, but I don't know which ones to use. \nAlso, I need to use a tree\
    \ data structure to solve the problem. \nAny help would be much appreciated. \n\
    \n\nA:\n\nThe first line of your question states the problem: \n<blockquote>\n\
    <p>Given a positive integer N, return the total sum of its digits in binary.</p>\n\
    </blockquote>\nWhat should be the result of <code>(solve 0)</code>? What about\
    \ <code>(solve 1)</code>? <code>(solve 2)</code>?  <code>(solve 3)</code>?  And\
    \ so on?\nThis is not a hard problem, but it helps if you read the question carefully\
    \ and make sure you understand what it's asking.\n", '  (regexp-replace #rx"0b"
    (number->string N 2)))', "  (if (zero? N)\n      \"0\"\n      (if (= N 1)\n  \
    \        \"1\"\n          (string-append (if (even? N) \"0\" \"1\")\n        \
    \                 (solve (quotient N 2))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
