name: HumanEval_84_solve
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer N, return the total sum of its\
  \ digits in binary.\n;; Example\n;; >>> (solve 1000)\n;; \"1\"\n;; >>> (solve 150)\n\
  ;; \"110\"\n;; >>> (solve 147)\n;; \"1100\"\n;; Variables:\n;; @N integer\n;; Constraints:\
  \ 0 \u2264 N \u2264 10000.\n;; Output:\n;; a string of binary number\n(define (solve\
  \ N)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
  \    (check-equal? (candidate 1000) \"1\")\n    (check-equal? (candidate 150) \"\
  110\")\n    (check-equal? (candidate 147) \"1100\")\n    (check-equal? (candidate\
  \ 333) \"1001\")\n    (check-equal? (candidate 963) \"10010\")\n))\n\n(test-humaneval)"
completions: ["  (number->string 2 (string->number (number->string 10 N) 2)))\n",
  "  (string-append\n   (number->string\n    (digit-sum\n     (number->string\n  \
    \    (integer->binary N))))))\n", "  (cond [(= N 0) \"0\"]\n        [(= N 1) \"\
    1\"]\n        [else (number->string (+ (modulo N 2) (string->number (solve (quotient\
    \ N 2)))))]))", "  (define (my-sum lst)\n    (cond ((null? lst) 0)\n         \
    \ (else (+ (car lst) (my-sum (cdr lst))))))\n  (number->string (my-sum (map (lambda\
    \ (x) (char->integer x)) (number->string (integer->binary N))))))", "  (number->string\
    \ (bitwise-ior (floor (expt 2 N)) (bitwise-and N 1))))\n", "  (list->string (list->string/r\
    \ (list->string N))))\n", "  (build-list (decimal-to-binary N)\n             \
    \ (lambda (x)\n                (if (eq? x '#b1) 1 0))))\n", "  (cond [(= N 0)\
    \ \"0\"]\n        [(= N 1) \"1\"]\n        [else (string-append (solve (quotient\
    \ N 2)) (number->string (remainder N 2)))]))\n", "  (number->string (bin N) 2))\n",
  "  (integer->string (solution N)))\n", "  (binary-string (inexact->exact (round\
    \ (log N 2)))))\n", '  (integer->string 2 (string->number (number->string N) 10)))',
  "  (integer->string (string->integer (string-ref (number->string (bitwise-count\
    \ N)) 0))))\n", '  (number->string (number->decimal N)))', "  (string-&gt;number\
    \ (number-&gt;string N 2)))\n", '  (string-concatenate (list->string (map (lambda
    (n) (substring (number->string n) 1 2)) (reverse (build-list (exact-floor (log
    N 2)) (lambda (i) (remainder N (expt 2 (+ i 1))))))))))', "  (define (get-binary-digits\
    \ N (digits '()))\n    (if (= N 0)\n        digits\n        (get-binary-digits\
    \ (truncate (/ N 2)) (cons (remainder N 2) digits))))\n  (define (get-total-sum-of-digits\
    \ N)\n    (apply + (get-binary-digits N)))\n  (number->string (get-total-sum-of-digits\
    \ N)))\n", "  (define (aux N)\n    (if (= N 0) '()\n        (cons (remainder N\
    \ 2) (aux (quotient N 2)))))\n  (cond ((= N 0) \"0\")\n        ((= N 1) \"1\"\
    )\n        (else (string-append (number->string (cond ((= (first (aux N)) 1) 1)\
    \ (else 0)))\n                             (solve (apply + (map (lambda (x) (*\
    \ 2 x)) (rest (aux N)))))))))\n", "    (number->string (fx+ (fx* (modulo N 10)\
    \ 2)\n                        (fx+ (fx* (modulo (quotient N 10) 2) 2)\n      \
    \                      (fx+ (fx* (modulo (quotient N 100) 2) 2)\n            \
    \                    (fx+ (fx* (modulo (quotient N 1000) 2) 2)\n             \
    \                       (fx+ (fx* (modulo (quotient N 10000) 2) 2)\n         \
    \                               (fx* (modulo (quotient N 100000) 2) 2))))))))",
  "  (dec2bin N))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
