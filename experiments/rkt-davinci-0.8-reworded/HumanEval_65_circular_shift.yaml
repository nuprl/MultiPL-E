name: HumanEval_65_circular_shift
language: rkt
prompt: "#lang racket\n\n;; Circular shift the digits of the integer x, shift the\
  \ digits right by shift\n;; and return the result as a string.\n;; If shift > number\
  \ of digits, return digits reversed.\n;; >>> (circular_shift 12 1)\n;; \"21\"\n\
  ;; >>> (circular_shift 12 2)\n;; \"12\"\n(define (circular_shift x shift)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate circular_shift))\n\
  \    (check-equal? (candidate 100 2) \"001\")\n    (check-equal? (candidate 12 2)\
  \ \"12\")\n    (check-equal? (candidate 97 8) \"79\")\n    (check-equal? (candidate\
  \ 12 1) \"21\")\n    (check-equal? (candidate 11 101) \"11\")\n))\n\n(test-humaneval)"
completions: ["  (define (shift-right x shift)\n    (define (make-number xs)\n   \
    \   (define (make-number-helper xs)\n        (if (null? xs) 0\n            (+\
    \ (* (car xs) (expt 10 (length xs)))\n               (make-number-helper (cdr\
    \ xs)))))\n      (make-number-helper (reverse xs)))\n    (define (rev-append xs\
    \ ys)\n      (if (null? xs) ys\n          (cons (car xs) (rev-append (cdr xs)\
    \ ys))))\n    (define (shift-right-helper x shift n)\n      (if (= n 0) (reverse\
    \ x)\n          (shift-right-helper (rev-append (list (last x)) (butlast x))\n\
    \                              shift (- n 1))))\n    (shift-right-helper (number->list\
    \ x) shift shift))\n  (number->string (shift-right x shift)))\n", "  (cond [(=\
    \ shift 0) x]\n        [else (string->number (string-append (substring (number->string\
    \ x) (- shift)) (substring (number->string x) 0 (- shift))))]))\n", "  (let* ([xstr\
    \ (number->string x)]\n         [len (string-length xstr)]\n         [new-str\
    \ (if (< shift len)\n                      (string-append (substring xstr shift\
    \ len)\n                                     (substring xstr 0 shift))\n     \
    \                 (string-reverse xstr))])\n    new-str))\n", "  (reverse (number->string\
    \ (number->string x shift))))\n", "  (regexp-replace* #rx(integer->string x)\n\
    \                   #rx(integer->string (modulo shift (exact-length x)))\n   \
    \                (number->string x)))\n", "  (define (rshift rshift-x)\n    (if\
    \ (equal? shift 0)\n        (number->string rshift-x)\n        (rshift (modulo\
    \ (* rshift-x 10) (expt 10 (number->string x |> string-length |> exact-round))))))\n\
    \  (rshift x))\n", "  (let ([n (integer->string x)])\n    (if (> shift (string-length\
    \ n))\n        (string-reverse n)\n        (string-append (substring n shift)\
    \ (substring n 0 shift)))))\n", "  (define (reverse-string str)\n    (regexp-replace*\
    \ #rx\"\" str \"\"))\n  (define (shift-digits x shift digits)\n    (cond\n   \
    \   [(= digits 1) (number->string x)]\n      [(> shift digits) (reverse-string\
    \ (number->string x))]\n      [else (string-append (number->string (- x (* 10\
    \ (quotient x 10))))\n                           (number->string (remainder x\
    \ 10)))]))\n  (shift-digits x shift (string-length (number->string x))))\n", " \
    \ (string-join\n   (list-tabulate (number->string x)\n                  (\u03BB\
    \ (i) (list-ref (number->string x)\n                                   (% (- i\
    \ shift) (string-length (number->string x))))))))\n", "  (string-join (reverse\
    \ (rotate-list shift (string->list (number->string x)))) \"\"))\n", "  (cond\n\
    \    [(= shift 0)\n     (number->string x)]\n    [(>= shift (length (number->string\
    \ x)))\n     (reverse (number->string x))]\n    [else\n     (append (reverse (drop\
    \ shift (reverse (number->string x))))\n             (take shift (reverse (number->string\
    \ x))))]))\n", "  (define (loop x shift)\n    (if (zero? shift)\n        x\n \
    \       (let ((head (remainder x 10))\n              (tail (quotient x 10)))\n\
    \          (loop (integer->string (+ (* tail 10) head)) (- shift 1)))))\n  (loop\
    \ x shift))\n", "  (if (zero? shift)\n      (number->string x)\n      (number->string\n\
    \       (integer-parse (string-join (reverse (string-split (number->string x)\
    \ #\\space)) #\\space) 10))))\n", "  (define digits\n    (list->string\n     (let\
    \ loop ([x x] [x_digit (quotient x 10)] [digits null])\n       (if (zero? x_digit)\n\
    \           (cons (remainder x 10) digits)\n           (loop (quotient x 10)\n\
    \                 (quotient x_digit 10)\n                 (cons (remainder x_digit\
    \ 10) digits))))))\n  (define len (string-length digits))\n  (if (> shift len)\n\
    \      (string-reverse digits)\n      (string-append (substring digits shift)\n\
    \                     (substring digits 0 shift))))", "  (regexp-replace* #rx\"\
    ^(.{,1})(.{0,})\" (number->string x) #:to-string\n                   (lambda (s)\
    \ (string-append (cadr s) (car s)))))\n", "  (let ((digits (number->string x)))\n\
    \    (string-append (substring digits shift)\n                   (substring digits\
    \ 0 shift))))\n", "  (if (zero? shift)\n      (number->string x)\n      (let*\
    \ ([x-string (number->string x)]\n             [len (string-length x-string)]\n\
    \             [new-index (- len shift)]\n             [new-index (if (< new-index\
    \ 0) (+ new-index len) new-index)])\n        (if (< new-index 0)\n           \
    \ (string-reverse x-string)\n            (let* ([old-index 0]\n              \
    \     [new-string (make-string len #\\space)])\n              (do ([n new-index\
    \ (+ n 1)])\n                  ((= n len))\n                (string-set! new-string\
    \ n (string-ref x-string old-index))\n                (set! old-index (+ old-index\
    \ 1)))\n              (do ([n 0 (+ n 1)])\n                  ((= n new-index))\n\
    \                (string-set! new-string n (string-ref x-string old-index))\n\
    \                (set! old-index (+ old-index 1)))\n              new-string))))))\n",
  "  (string-append (substring (number->string x) (- shift) -1)\n                \
    \ (substring (number->string x) 0 (- shift))))\n", "  (define (invert-string str)\n\
    \    (string-join (reverse (string-split str)) \"\"))\n  (define (length-of-string\
    \ str)\n    (length (string-split str)))\n  (define (append-to-string str n)\n\
    \    (string-append str (invert-string (substring str (- n)))))\n  (define (remove-from-string\
    \ str n)\n    (string-append (substring str 0 n) (substring str (add1 n))))\n\
    \  (define (shift-str str shift)\n    (if (<= shift (length-of-string str))\n\
    \        (append-to-string (remove-from-string str shift) shift)\n        (invert-string\
    \ str)))\n  (shift-str (number->string x) shift))\n", "  (define (shift x shift)\n\
    \    (cond ((< shift (exact-floor (log10 x)))\n           (reverse (append (list\
    \ (- x (* (exact-floor (/ x (expt 10 shift)))\n                              \
    \           (expt 10 shift))))\n                            (list (* (exact-floor\
    \ (/ x (expt 10 shift)))\n                                     (expt 10 (- (exact-floor\
    \ (log10 x)) shift)))))))\n          (else (list (reverse (list->string x)))))\n\
    \    )\n  (list->string (shift x shift))\n)\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
