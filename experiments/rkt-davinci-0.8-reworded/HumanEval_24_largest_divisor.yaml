name: HumanEval_24_largest_divisor
language: rkt
prompt: "#lang racket\n\n;; For a given number n, find the largest number that divides\
  \ n evenly, smaller than n\n;; >>> (largest_divisor 15)\n;; 5\n(define (largest_divisor\
  \ n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_divisor))\n\
  \    (check-equal? (candidate 3) 1)\n    (check-equal? (candidate 7) 1)\n    (check-equal?\
  \ (candidate 10) 5)\n    (check-equal? (candidate 100) 50)\n    (check-equal? (candidate\
  \ 49) 7)\n))\n\n(test-humaneval)"
completions: ["  (letrec ([smallest (lambda (n d)\n                       (if (even?\
    \ n)\n                           (smallest (/ n 2) (* 2 d))\n                \
    \           (if (zero? (remainder n d))\n                               (smallest\
    \ (/ n d) d)\n                               (+ d (smallest n (+ d 1))))))])\n\
    \    (smallest n 2)))\n", "  (define (all-divisors num counter accum)\n    (if\
    \ (= counter num)\n        accum\n        (if (= (modulo num counter) 0)\n   \
    \         (all-divisors num (+ counter 1) counter)\n            (all-divisors\
    \ num (+ counter 1) accum))))\n  (all-divisors n 1 0))\n", "  (for/first ([i (in-range\
    \ n (- n 1) -1)])\n    (if (zero? (modulo n i))\n        i)))\n", "  (for/fold\
    \ ([d n]) ([i n])\n    (if (zero? (modulo n i))\n        i\n        d)))\n", " \
    \ (letrec ([candidate (sub1 n)]\n           [divisible? (lambda (candidate)\n\
    \                         (zero? (modulo n candidate)))])\n    (cond\n      [(divisible?\
    \ candidate) candidate]\n      [else (largest_divisor candidate)])))\n", "  (define\
    \ (divisor i)\n    (if (= 0 (modulo n i))\n        (if (< i n)\n            i\n\
    \            (divisor (- i 1)))\n        (divisor (- i 1))))\n  (divisor (/ n\
    \ 2)))\n", "  (define (divisible? a b)\n    (= (remainder a b) 0))\n  (define\
    \ (find-divisor n test-divisor)\n    (cond ((> (square test-divisor) n) n)\n \
    \         ((divisible? n test-divisor) test-divisor)\n          (else (find-divisor\
    \ n (+ test-divisor 1)))))\n  (find-divisor n 2))\n", "  (letrec\n      ((larger?\
    \ (lambda (a b)\n                  (if (= b 0) a (larger? b (remainder a b)))))\n\
    \       (best? (lambda (candidate)\n                (if (= 1 candidate)\n    \
    \                1\n                    (if (= 0 (remainder n candidate))\n  \
    \                      (larger? candidate (best? (- candidate 1)))\n         \
    \               (best? (- candidate 1)))))))\n    (best? (- n 1))))\n", "  (define\
    \ (largest-divisor-iter cur-divisor n)\n    (if (= 0 (modulo n cur-divisor))\n\
    \        cur-divisor\n        (largest-divisor-iter (- cur-divisor 1) n)))\n \
    \ (largest-divisor-iter (- n 1) n))\n", "  (define (largest-divisor-iter a b)\n\
    \    (if (zero? (modulo b a))\n        a\n        (largest-divisor-iter (+ a 1)\
    \ b)))\n  (largest-divisor-iter 1 n))\n", "  (define (lg i m)\n    (if (= 0 (modulo\
    \ m i)) i (lg (+ i 1) m)))\n  (lg 1 n))\n", "  (define i\n    (sub1 n))\n  (define\
    \ (divisible? k)\n    (= (remainder n k) 0))\n  (define (loop)\n    (cond\n  \
    \    [(divisible? i) i]\n      [else (define i (sub1 i)) (loop)]))\n  (loop))\n",
  "  (define (next k)\n    (if (even? k)\n        (/ k 2)\n        (/ (- k 1) 2)))\n\
    \  (define (divides? a b)\n    (= (remainder b a) 0))\n  (if (= n 1)\n      1\n\
    \      (let ((div (next n)))\n        (if (divides? div n)\n            div\n\
    \            (largest_divisor div)))))\n", "  (define (largest-divisor-iter current-divisor\
    \ n)\n    (if (= (remainder n current-divisor) 0)\n        current-divisor\n \
    \       (largest-divisor-iter (- current-divisor 1) n)))\n  (largest-divisor-iter\
    \ (- n 1) n))\n", "  (define (largest-divisor-iter i n)\n    (if (= 0 (modulo\
    \ n i))\n        i\n        (largest-divisor-iter (- i 1) n)))\n  (largest-divisor-iter\
    \ n n))\n", "  (if (= n 0) 0\n      (define (largest_divisor-iter counter)\n \
    \       (if (= (modulo n counter) 0) counter\n            (largest_divisor-iter\
    \ (- counter 1))))\n      (largest_divisor-iter (/ n 2))))\n", "  (define (largest\
    \ d)\n    (if (zero? (modulo n d))\n        d\n        (largest (- d 1))))\n \
    \ (largest (- n 1)))\n", "  (if (= n 1)\n      1\n      (largest_divisor2 2 n)))\n",
  "  (define (iter d)\n    (if (divides? d n)\n        (if (divides? d (sub1 n))\n\
    \            (iter (sub1 d))\n            d)\n        (iter (sub1 d))))\n  (iter\
    \ (sub1 n)))\n", "  (define (find_n n k)\n    (if (= (modulo n k) 0)\n       \
    \ n\n        (find_n n (- k 1))))\n  (find_n n (/ n 2)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
