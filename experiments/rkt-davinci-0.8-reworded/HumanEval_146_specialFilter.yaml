name: HumanEval_146_specialFilter
language: rkt
prompt: "#lang racket\n\n;; Write a function that takes a list of numbers as input\
  \ and returns \n;; the number of elements in the list that are greater than 10 and\
  \ both \n;; first and last digits of a number are odd (1, 3, 5, 7, 9).\n;; For example:\n\
  ;; >>> (specialFilter (list 15 -73 14 -15))\n;; 1\n;; >>> (specialFilter (list 33\
  \ -2 -3 45 21 109))\n;; 2\n(define (specialFilter nums)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate specialFilter))\n\
  \    (check-equal? (candidate (list 5 -2 1 -5)) 0)\n    (check-equal? (candidate\
  \ (list 15 -73 14 -15)) 1)\n    (check-equal? (candidate (list 33 -2 -3 45 21 109))\
  \ 2)\n    (check-equal? (candidate (list 43 -12 93 125 121 109)) 4)\n    (check-equal?\
  \ (candidate (list 71 -2 -33 75 21 19)) 3)\n    (check-equal? (candidate (list 1))\
  \ 0)\n    (check-equal? (candidate (list )) 0)\n))\n\n(test-humaneval)"
completions: ["  (if (null? nums)\n      0\n      (if (and (odd? (modulo (car nums)\
    \ 10)) (odd? (quotient (car nums) 10)) (> (car nums) 10))\n          (+ 1 (specialFilter\
    \ (cdr nums)))\n          (specialFilter (cdr nums)))))\n", "  (cond\n    [(empty?\
    \ nums) 0]\n    [(and (and (> (first nums) 10)\n               (odd? (first (number->digits\
    \ (first nums)))))\n          (odd? (last (number->digits (first nums)))))\n \
    \    (+ 1 (specialFilter (rest nums)))]\n    [else (specialFilter (rest nums))]))\n\
    ```\n\n```racket\n#lang racket\n", "  (cond\n    [(empty? nums) 0]\n    [(and\
    \ (number? (first nums))\n          (even? (first nums))\n          (even? (last\
    \ (list->string (number->string (first nums))))))\n     (specialFilter (rest nums))]\n\
    \    [(and (number? (first nums))\n          (odd? (first nums))\n          (odd?\
    \ (last (list->string (number->string (first nums))))))\n     (+ 1 (specialFilter\
    \ (rest nums)))]\n    [else (specialFilter (rest nums))]))\n", '  (filter (lambda
    (x) (and (odd? (remainder x 10)) (odd? (remainder x 100 10)) (> x 10))) nums))',
  "  (define (firstDigit x)\n    (if (zero? x)\n      0\n      (firstDigit (quotient\
    \ x 10))))\n  (define (lastDigit x)\n    (modulo x 10))\n  (define (filter x)\n\
    \    (and (> x 10)\n         (odd? (firstDigit x))\n         (odd? (lastDigit\
    \ x))))\n  (length (filter-map filter nums)))\n", "  (define (oddDigits num)\n\
    \    (and (odd? (quotient num 10))\n         (odd? (remainder num 10))))\n  (define\
    \ (greater10 num)\n    (&gt; num 10))\n  (length (filter oddDigits (filter greater10\
    \ nums))))\n", "  (cond ((null? nums) 0)\n        ((and (not (null? (cdr nums)))\n\
    \              (> (car nums) 10)\n              (odd? (car nums))\n          \
    \    (odd? (cadr nums)))\n         (+ 1 (specialFilter (cdr nums))))\n       \
    \ (else (specialFilter (cdr nums)))))\n", "  (cond\n    [(empty? nums) 0]\n  \
    \  [(and (odd? (first nums)) (odd? (last-digit (first nums))) (> (first nums)\
    \ 10))\n     (+ 1 (specialFilter (rest nums)))]\n    [else (specialFilter (rest\
    \ nums))]))\n", "  (define (firstDigit n)\n    (quotient n 10))\n  (define (lastDigit\
    \ n)\n    (remainder n 10))\n  (define (check n)\n    (and\n     (> n 10)\n  \
    \   (odd? (firstDigit n))\n     (odd? (lastDigit n))))\n  (foldl (lambda (n c)\
    \ (if (check n) (+ c 1) c)) 0 nums))\n", "  (define (isSpecial? n)\n    (and (odd?\
    \ (firstDigit n)) (odd? (lastDigit n)) (> n 10)))\n  (length (filter isSpecial?\
    \ nums)))\n", "  (length (filter (lambda (n) (and (odd? (quotient n 10)) (odd?\
    \ (remainder n 10)))) nums)))\n", "  (length\n   (filter (lambda (x)\n       \
    \      (and (> x 10)\n                  (odd? (remainder x 10))\n            \
    \      (odd? (quotient x 10))))\n           nums)))\n", "  (if (null? nums)\n\
    \      0\n      (if (and (> (car nums) 10)\n               (odd? (firstDigit (car\
    \ nums)))\n               (odd? (lastDigit (car nums))))\n          (+ 1 (specialFilter\
    \ (cdr nums)))\n          (specialFilter (cdr nums)))))\n", "  (length (filter\
    \ (lambda (num)\n                    (and (odd? (modulo num 10))\n           \
    \              (odd? (quotient num 10))\n                         (> num 10)))\n\
    \                  nums)))\n", "  (cond [(empty? nums) 0]\n        [else\n   \
    \      (cond [(and (odd? (car nums))\n                    (odd? (modulo (car nums)\
    \ 10))\n                    (> (car nums) 10))\n                (+ 1 (specialFilter\
    \ (cdr nums)))]\n               [else (specialFilter (cdr nums))])]))\n", "  (length\
    \ (filter (lambda (n) (and (odd? (first-digit n)) (odd? (last-digit n)) (> n 10)))\
    \ nums)))\n", "  (length (filter\n           (lambda (n)\n             (and (>\
    \ n 10)\n                  (and (odd? (car (digits n)))\n                    \
    \   (odd? (car (reverse (digits n)))))))\n           nums)))\n", "  (letrec ([d1\
    \ (list-ref nums 0)]\n           [dn (list-ref nums (- (length nums) 1))])\n \
    \   (cond [(equal? (length nums) 0) 0]\n          [(and (< 10 d1) (< 10 dn) (not\
    \ (= 0 (remainder d1 2))) (not (= 0 (remainder dn 2)))) (+ 1 (specialFilter (rest\
    \ nums)))]\n          [else (specialFilter (rest nums))])))\n```", "  (define\
    \ (firstDigit num) (remainder num 10))\n  (define (lastDigit num) (remainder (quotient\
    \ num 10) 10))\n  (define (special? num) (and (odd? (firstDigit num)) (odd? (lastDigit\
    \ num))))\n  (define (loop nums count)\n    (cond [(empty? nums) count]\n    \
    \      [(and (> (first nums) 10) (special? (first nums))) (loop (rest nums) (+\
    \ count 1))]\n          [else (loop (rest nums) count)]))\n  (loop nums 0))\n",
  "  (cond [(empty? nums) 0]\n        [else (special-check (first nums) \n       \
    \                      (specialFilter (rest nums)))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
