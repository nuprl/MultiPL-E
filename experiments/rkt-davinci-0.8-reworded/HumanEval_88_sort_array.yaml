name: HumanEval_88_sort_array
language: rkt
prompt: "#lang racket\n\n;; Given a list of non-negative integers, return a corkt\
  \ of the given list after sorting,\n;; you will sort the given list in ascending\
  \ order if the sum( first index value, last index value) is odd,\n;; or sort it\
  \ in descending order if the sum( first index value, last index value) is even.\n\
  ;; Note:\n;; * don't change the given list.\n;; Examples:\n;; >>> (sort_array (list\
  \ ))\n;; (list )\n;; >>> (sort_array (list 5))\n;; (list 5)\n;; >>> (sort_array\
  \ (list 2 4 3 0 1 5))\n;; (list 0 1 2 3 4 5)\n;; >>> (sort_array (list 2 4 3 0 1\
  \ 5 6))\n;; (list 6 5 4 3 2 1 0)\n(define (sort_array array)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n\
  \    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate (list\
  \ 5)) (list 5))\n    (check-equal? (candidate (list 2 4 3 0 1 5)) (list 0 1 2 3\
  \ 4 5))\n    (check-equal? (candidate (list 2 4 3 0 1 5 6)) (list 6 5 4 3 2 1 0))\n\
  \    (check-equal? (candidate (list 2 1)) (list 1 2))\n    (check-equal? (candidate\
  \ (list 15 42 87 32 11 0)) (list 0 11 15 32 42 87))\n    (check-equal? (candidate\
  \ (list 21 14 23 11)) (list 23 21 14 11))\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? array) (list)]\n        [(or (odd? (apply + array))\
    \ (eq? 1 (length array)))\n         (sort array (lambda (x y) (< x y)))]\n   \
    \     [else (sort array (lambda (x y) (> x y)))]))\n", "  (if (or (null? array)\
    \ (null? (cdr array)))\n      array\n      (sort-by (lambda (e1 e2)\n        \
    \         (if (= (remainder (+ (list-ref array 0) (list-ref array (sub1 (length\
    \ array)))) 2) 0)\n                     (and (positive? (- e1 e2))\n         \
    \                 (> e1 e2))\n                     (and (positive? (- e1 e2))\n\
    \                          (< e1 e2))))\n               array)))\n```\n\n```\n\
    #lang racket\n", "  (if (or (null? array) (null? (cdr array)))\n      array\n\
    \      (let* ([sum (add (car array) (last-pair array))]\n             [sort-dir\
    \ (if (even? sum)\n                           (string->symbol \"descending\")\n\
    \                           (string->symbol \"ascending\"))]\n             [sorted\
    \ (sort array < sort-dir)])\n        sorted)))\n", '  (filter (lambda (x) #t)
    array))', "  (let ([sum (apply + (list (car array) (car (reverse array))))])\n\
    \    (cond\n      ((even? sum) (reverse array))\n      (else array))))\n", " \
    \   (cond\n        [(empty? array) (list)]\n        [(odd? (+ (first array) (last\
    \ array))) (sort (build-list (length array) id) <)]\n        [else (sort (build-list\
    \ (length array) id) >)]))", "  (sort array\n        (\u03BB (a b)\n         \
    \ (cond\n            [(= (modulo (+ (first array) (last array)) 2) 0) (&gt; a\
    \ b)]\n            [else (&lt; a b)]))))\n</code>\nThis is the test error that\
    \ is failing:\n<code> (check-equal? (sort_array (list 0 1 2 3 4 5)) (list 5 4\
    \ 3 2 1 0))\n    Expected: '(5 4 3 2 1 0)\n    Got:      '(0 1 2 3 4 5)\n</code>\n\
    I don't know why this is failing. I'm checking if the sum of the first and last\
    \ index of the list is even, and if that's the case I'm sorting in descending\
    \ order. I can't figure out why it's failing.\nThanks in advance.\n\n\nA:\n\n\
    The error isn't in the algorithm but in the test case. In fact, if you try to\
    \ print out the contents of the lists that you're checking, you'll see that they're\
    \ the same! What's going on?\nLet's try to understand:\n<code>(list 0 1 2 3 4\
    \ 5)", "  (cond [(empty? array) empty]\n        [(= (length array) 1) array]\n\
    \        [else (if (even? (+ (car array) (last array)))\n                  (sort\
    \ array >)\n                  (sort array <))]))\n", "  (if (null? array)\n  \
    \    '()\n      (if (null? (cdr array))\n          array\n          (if (= (+\
    \ (car array) (cadr (reverse array))) 1)\n              (sort array <)\n     \
    \         (sort array >)))))", "  (cond\n    [(and (empty? array)\n          (=\
    \ 0 (length array))) (list)]\n    [(and (empty? array)\n          (= 1 (length\
    \ array))) array]\n    [(= (modulo (+ (list-ref array 0) (list-ref array (- (length\
    \ array) 1))) 2) 1)\n     (quicksort array)]\n    [else (quicksort (reverse array))]))\n",
  "  (let* ([first (first array)]\n         [last (last array)]\n         [sum (+\
    \ first last)])\n    (cond [(zero? (remainder sum 2)) (sort array <)]\n      \
    \    [else (sort array >)])))\n", "  (cond\n    [(empty? array) (list)]\n    [(empty?\
    \ (rest array)) array]\n    [else\n     (let*\n         ([first-elem (first array)]\n\
    \          [last-elem (last array)]\n          [sort-func\n           (if (odd?\
    \ (+ first-elem last-elem))\n               (lambda (a b) (or (> a b) (= a b)))\n\
    \               (lambda (a b) (or (< a b) (= a b))))])\n       (sort sort-func\
    \ array))]))\n", "  (define (is-odd n)\n    (if (= 1 (remainder n 2))\n      \
    \  #t\n        #f))\n  (define (get-sum array)\n    (if (null? array)\n      \
    \  0\n        (+ (car array) (get-sum (cdr array)))))\n  (define (sort-it array)\n\
    \    (if (null? array)\n        (list)\n        (append (sort-it (filter (\u03BB\
    \ (v) (< v (car array))) (cdr array)))\n                (list (car array))\n \
    \               (sort-it (filter (\u03BB (v) (> v (car array))) (cdr array))))))\n\
    \  (if (is-odd (get-sum array))\n      (sort-it array)\n      (reverse (sort-it\
    \ array))))\n", "  (if (empty? array)\n      array\n      (let ((len (length array)))\n\
    \        (if (odd? (+ (list-ref array 0) (list-ref array (- len 1))))\n      \
    \      (sort array <)\n            (sort array >)))))\n", "  (cond\n    [(null?\
    \ array) (list)]\n    [(= (length array) 1) array]\n    [else\n     (let\n   \
    \      ([odd? (even? (+ (first array) (last array)))])\n       (cond\n       \
    \  [odd?\n          (define\n              (ascending? a b)\n              (cond\n\
    \                [(< a b) #t]\n                [else #f]))\n          (list-sort\
    \ ascending? array)]\n         [else\n          (define\n              (descending?\
    \ a b)\n              (cond\n                [(> a b) #t]\n                [else\
    \ #f]))\n          (list-sort descending? array)]))]))\n", "  (if (empty? array)\n\
    \      array\n      (sort_array_helper array (sum_indexes array 0 (sub1 (length\
    \ array))))))\n", "  (let ((a (sort array #:key first))\n        (b (sort array\
    \ #:key last reverse-order)))\n    (if (zero? (modulo (+ (first a) (last b)) 2))\n\
    \        b\n        a)))\n</code>\n", "  (define (merge-sort-array array lo hi)\n\
    \    (if (< lo hi)\n        (let ([mid (quotient (+ lo hi) 2)])\n          (merge-sort-array\
    \ array lo mid)\n          (merge-sort-array array (+ mid 1) hi)\n          (if\
    \ (odd? (+ (list-ref array lo) (list-ref array hi)))\n              (merge-array\
    \ array lo mid hi)\n              (merge-array array lo mid hi #:descending? #t)))\n\
    \        (void)))\n  (define (merge-array array lo mid hi #:descending? ([descending?\
    \ #f]))\n    (let ([temp (make-vector (add1 (- hi lo)) 0)])\n      (let loop ([m\
    \ lo] [n (+ mid 1)] [i 0])\n        (cond\n          [(= m (+ mid 1))\n      \
    \     (vector-copy! temp array i n hi)]\n          [(= n hi)\n           (vector-copy!\
    \ temp array i m (+ mid 1))]\n          [(if descending?\n               (list-ref\
    \ array m)\n               (< (list-ref array m) (list-ref array n)))\n      \
    \     (vector-set! temp i (list-ref array m))\n           (loop (+ m 1) n (+ i\
    \ 1))]\n          [else\n           (vector-set! temp i (list-ref array n))\n\
    \           (loop m (+ n 1) (+ i 1))]))\n      (vector-copy! array lo temp 0 (-\
    \ hi lo)))))\n", "  (sort\n   array\n   (lambda (a b)\n     (and\n      (cond\n\
    \       [(and (odd? a) (odd? b)) (< a b)]\n       [(and (odd? a) (even? b)) (<\
    \ a b)]\n       [(and (even? a) (odd? b)) (> a b)]\n       [(and (even? a) (even?\
    \ b)) (> a b)])\n      (not (equal? a b))))))\n```\n\n```\n#lang racket\n", " \
    \ (sort-array array\n              (lambda (x y)\n                (cond ((= (modulo\
    \ (+ (car array) (car (reverse array))) 2) 0) (< x y))\n                     \
    \ (else (> x y))))))\n", "  (if (empty? array)\n      (list)\n      (if (equal?\
    \ (length array) 1)\n          array\n          (if (equal? (modulo (+ (first\
    \ array) (last array)) 2) 0)\n              (reverse array)\n              array))))",
  "  (if (empty? array)\n      (list)\n      (define (helper acc)\n        (if (empty?\
    \ acc)\n            (list)\n            (define (merge acc1)\n              (if\
    \ (empty? acc1)\n                  (list)\n                  (if (&lt; (car acc)\
    \ (car acc1))\n                      (cons (car acc) (merge (cdr acc1)))\n   \
    \                   (cons (car acc1) (merge (cdr acc))))))\n            (if (=\
    \ (length acc) 1)\n                (cons (car acc) (helper (reverse (cdr acc))))\n\
    \                (define (split acc)\n                  (if (empty? acc)\n   \
    \                   (list)\n                      (define (merge acc1)\n     \
    \                   (if (empty? acc1)\n                            (list)\n  \
    \                          (if (&lt; (car acc) (car acc1))\n                 \
    \               (cons (car acc) (merge (cdr acc1)))\n                        \
    \        (cons (car acc1) (merge (cdr acc))))))\n                      (define\
    \ (split acc)\n                        (if (empty? acc)\n                    \
    \        (list)\n                            (define (merge acc1)\n          \
    \                    (if (empty? acc1)\n                                  (list)\n\
    \                                  (if (&lt; (car acc) (car acc1))\n         \
    \                             (cons (car acc) (merge (cdr acc1)))\n          \
    \                            (cons (car acc1) (merge (cdr acc))))))\n        \
    \                    (define (split acc)\n                              (if (empty?\
    \ acc)\n                                  (list)\n                           \
    \       (define (merge acc1)\n                                    (if (empty?\
    \ acc1)\n                                        (list)\n                    \
    \                    (if (&lt; (car acc) (car acc1))\n                       \
    \                     (cons (car acc) (merge (cdr acc1)))\n                  \
    \                          (cons (car acc1) (merge (cdr acc))))))\n          \
    \                        (let ((a (car acc))\n                               \
    \         (b (car (cdr acc))))\n                                    (if (&lt;\
    \ a b)\n                                        (cons a (split (cdr acc)))\n \
    \                                       (cons b (", "  (if (= (length array) 0)\n\
    \      (list)\n      (if (= (length array) 1)\n          array\n          (let\
    \ ((first (first array))\n                (last (last array)))\n            (if\
    \ (even? (+ first last))\n                (reverse array)\n                array)))))",
  "  (if (<= (length array) 1)\n      array\n      (let ((sum (apply + (list (first\
    \ array) (last array)))))\n        (if (odd? sum)\n            (sort array <)\n\
    \            (sort array >)))))\n", "  (cond\n    [(empty? array)\n     (list)]\n\
    \    [(empty? (rest array))\n     array]\n    [else\n     (cond\n       [(odd?\
    \ (+ (first array) (last array)))\n        (merge-sort array <)]\n       [else\n\
    \        (merge-sort array >)])]))\n", "  (define (even? x) (= (remainder x 2)\
    \ 0))\n  (define (asc? x) (< (car x) (cadr x)))\n  (define (desc? x) (> (car x)\
    \ (cadr x)))\n  (cond\n    ((null? array) '())\n    ((null? (cdr array)) array)\n\
    \    ((and (even? (car array)) (even? (cadr array)))\n     (sort (cdr array) (asc?\
    \ x)))\n    ((or (even? (car array)) (even? (cadr array)))\n     (sort (cdr array)\
    \ (desc? x)))\n    ))\n", "  (if (null? array)\n      array\n      (if (odd? (+\
    \ (car array) (last-pair array)))\n          (sort array <)\n          (sort array\
    \ >))))", "  (if (null? array)\n      (list)\n      (if (= (length array) 1)\n\
    \          array\n          (if (odd? (+ (list-ref array 0) (list-ref array (-\
    \ (length array) 1))))\n              (bubble-sort array #:compare <)\n      \
    \        (bubble-sort array #:compare >)))))\n", "  (define (sum-last-first array)\n\
    \    (if (null? array)\n        0\n        (+ (car array) (last (car (last-pair\
    \ array))))))\n  (define (even-or-odd? n)\n    (if (even? n)\n        #t\n   \
    \     #f))\n  (if (even-or-odd? (sum-last-first array))\n      (sort array >)\n\
    \      (sort array <)))\n", "  (if (or (null? array) (= (length array) 1))\n \
    \     array\n      (let* ([result (sort-list array)]\n             [first (car\
    \ result)]\n             [last (car (reverse result))])\n        (if (odd? (+\
    \ first last))\n            result\n            (reverse result)))))\n", "  (cond\n\
    \    [(null? array) (list)]\n    [(= (length array) 1) array]\n    [else\n   \
    \  (cond\n       [(odd? (+ (car array) (last array)))\n        (sort array <)]\n\
    \       [else\n        (sort array >)])]))\n", "  (if (&lt; (length array) 2)\n\
    \      array\n      (let* ([first (list-ref array 0)]\n             [last (list-ref\
    \ array (- (length array) 1))]\n             [sum (+ first last)])\n        (if\
    \ (odd? sum)\n            (sort array &lt;)\n            (sort array &gt;)))))\n\
    </code>\nHere is a reasonable implementation:\n<code>#lang racket\n", "  (define\
    \ (sum_first_last lst)\n    (define (first-last lst)\n      (cond ((not (null?\
    \ lst)) (cons (car lst) (list (car (reverse lst)))))\n            (else '())))\n\
    \    (apply + (first-last lst)))\n  (cond ((not (null? array)) (cond ((= (sum_first_last\
    \ array) 1) array)\n                                   ((even? (sum_first_last\
    \ array)) (reverse (sort < array)))\n                                   (else\
    \ (sort < array))))\n        (else '())))\n", "  (match array\n    [(list ) (list\
    \ )]\n    [(list (? number? num)) (list num)]\n    [(list num1 num2 . rest)\n\
    \     (let ([num1 num1]\n           [num2 num2]\n           [rest rest])\n   \
    \    (define (sort-helper first second)\n         (if (= first second)\n     \
    \        (list first second rest)\n             (list second first rest)))\n \
    \      (match (sort-helper num1 num2)\n         [(list n1 n2 r)\n          (append\
    \ (sort-helper n1 n2) (sort_array r))]))]))\n", "  (define (sum_indices array)\n\
    \    (if (= (length array) 1)\n        0\n        (+ (list-ref array 0) (list-ref\
    \ array (- (length array) 1)))))\n  (cond\n    [(= (length array) 0)\n     array]\n\
    \    [(= (length array) 1)\n     array]\n    [(= (sum_indices array) 0)\n    \
    \ (reverse array)]\n    [(= (modulo (sum_indices array) 2) 0)\n     (reverse (sort\
    \ array <))]\n    [else\n     (sort array <)]))\n", "  (cond [(empty? array) array]\n\
    \        [(and (empty? (rest array)) (empty? (but-last array))) array]\n     \
    \   [else\n         (if (odd? (+ (first array) (last array)))\n             (sort\
    \ array <)\n             (sort array >))]))\n", "  (let ([len (length array)])\n\
    \    (cond [(< len 1) array]\n          [(= (add1 (remainder (car array) len))\
    \ 1)\n           (sort array < #:key (lambda (x) (remainder x len)))]\n      \
    \    [else\n           (sort array > #:key (lambda (x) (remainder x len)))])))",
  "  (sort array (\u03BB (x y)\n                (if (= (remainder (+ (car array) (cadr\
    \ (reverse array))) 2) 0)\n                    (> x y)\n                    (<\
    \ x y)))))\n```\n\n## Test Cases\n\n```racket", "  (if (< (length array) 2)\n\
    \      array\n      (sort (append (slice array 0 (- (length array) 1))\n     \
    \               (slice array 1 (length array)))\n            <)))\n", "  (match\
    \ array\n    [(list a) (list a)]\n    [(list a b) (if (even? (+ a b)) (list b\
    \ a) (list a b))]\n    [(list a b c) (if (even? (+ a b)) (sort c (cons b (cons\
    \ a '()))) (sort c (cons a (cons b '()))))]\n    [(list a b c rest ...) (if (even?\
    \ (+ a b)) (sort rest (cons b (cons a '()))) (sort rest (cons a (cons b '()))))]))\n",
  "  (local [(define (sum_first_last array)\n            (if (or (null? array) (null?\
    \ (cdr array))) 0\n                (+ (car array) (last array))))\n          (define\
    \ (sorted_array_pred? array)\n            (if (or (null? array) (null? (cdr array)))\
    \ #t\n                (and (<= (car array) (cadr array)) (sorted_array_pred? (cdr\
    \ array)))))\n          (define (ascending-sort array)\n            (if (sorted_array_pred?\
    \ array) array\n                (begin\n                  (set! array (list (car\
    \ array) (cadr array) (car (cdr (cdr array)))\n                              \
    \      (car (cdr (cdr (cdr array)))) (car (cdr (cdr (cdr (cdr array)))))\n   \
    \                                 (car (cdr (cdr (cdr (cdr (cdr array))))))))\n\
    \                  (set! array (sort_array array)))))\n          (define (descending-sort\
    \ array)\n            (if (sorted_array_pred? array) array\n                (begin\n\
    \                  (set! array (list (last array) (car (cdr (cdr (cdr (cdr (cdr\
    \ array))))))\n                                    (car (cdr (cdr (cdr (cdr array)))))\
    \ (car (cdr (cdr (cdr array))))\n                                    (car (cdr\
    \ (cdr array))) (car (cdr array))))\n                  (set! array (sort_array\
    \ array)))))\n          (define (sum_first_last_odd? array)\n            (odd?\
    \ (sum_first_last array)))\n          (define (sum_first_last_even? array)\n \
    \           (even? (sum_first_last array)))]\n    (cond [(sum_first_last_odd?\
    \ array) (ascending-sort array)]\n          [(sum_first_last_even? array) (descending-sort\
    \ array)]\n          [else array])))\n", "  (if (null? array)\n      (list)\n\
    \      (if (odd? (+ (car array) (last array)))\n          (list-sort array <)\n\
    \          (list-sort array >))))\n```\n\n```\n#lang racket\n", "  (if (= (length\
    \ array) 0)\n      (list)\n      (if (= (length array) 1)\n          array\n \
    \         (let* ([a (first array)]\n                 [b (last array)]\n      \
    \           [c (if (odd? (+ a b))\n                        <\n               \
    \         >)])\n            (sort c array)))))", "  (cond ((null? array)\n   \
    \      (list))\n        ((null? (cdr array))\n         array)\n        ((null?\
    \ (cddr array))\n         (cond ((odd? (+ (car array) (cadr array)))\n       \
    \         (list (car array) (cadr array)))\n               (else\n           \
    \     (list (cadr array) (car array)))))\n        (else\n         (let sort-array-iter\
    \ ((arr array) (new-arr (list)) (sum (car array) (cadr array)))\n           (if\
    \ (null? arr)\n               new-arr\n               (if (null? (cdr arr))\n\
    \                   (if (odd? sum)\n                       (append (sort arr <)\
    \ new-arr)\n                       (append (sort arr >) new-arr))\n          \
    \         (sort-array-iter (cdr arr) (cons (car arr) new-arr) (+ sum (car arr)\
    \ (cadr arr)))))))))\n", "  (let ((length (length array)))\n    (if (odd? (+ (list-ref\
    \ array 0) (list-ref array (- length 1))))\n        (sort array <)\n        (sort\
    \ array >))))", "  (cond\n    [(null? array)\n     (list)]\n    [(null? (cdr array))\n\
    \     array]\n    [else\n     (define sum-of-first-and-last (lambda (lst)\n  \
    \                                   (+ (car lst) (car (reverse lst)))))\n    \
    \ (define sort-fn (lambda (a b)\n                       (if (odd? (sum-of-first-and-last\
    \ array))\n                           (< a b)\n                           (> a\
    \ b))))\n     (sort sort-fn array)]))\n", "  (if (empty? array)\n      '()\n \
    \     (sort_array_h array (add1 (quotient (length array) 2)) (add1 (quotient (length\
    \ array) 2)))))\n", "  (let* ([first (list-ref array 0)]\n         [last (list-ref\
    \ array (- (length array) 1))]\n         [sum (+ first last)])\n    (cond [(even?\
    \ sum) (reverse array)]\n          [else array])))\n", "  (let recur ((array array)\n\
    \              (result (make-vector (vector-length array))))\n    (if (vector-length\
    \ array)\n        (let* ((first-index 0)\n               (last-index (- (vector-length\
    \ array) 1))\n               (sum (+ (vector-ref array first-index)\n        \
    \               (vector-ref array last-index))))\n          (if (odd? sum)\n \
    \             (let ((array (vector-copy array)))\n                (let recur ((head-index\
    \ first-index)\n                            (tail-index last-index))\n       \
    \           (vector-set! result head-index (vector-ref array head-index))\n  \
    \                (vector-set! result tail-index (vector-ref array tail-index))\n\
    \                  (when (not (= head-index tail-index))\n                   \
    \ (recur (+ head-index 1) (- tail-index 1)))))\n              (let ((array (vector-copy\
    \ array)))\n                (let recur ((head-index first-index)\n           \
    \                 (tail-index last-index))\n                  (vector-set! result\
    \ head-index (vector-ref array tail-index))\n                  (vector-set! result\
    \ tail-index (vector-ref array head-index))\n                  (when (not (= head-index\
    \ tail-index))\n                    (recur (+ head-index 1) (- tail-index 1))))))\n\
    \          (vector->list result))\n        '())))", "  (cond ((empty? array) (list))\n\
    \        ((< (length array) 2) array)\n        ((= (modulo (+ (first array) (last\
    \ array)) 2) 0) (apply list (reverse array)))\n        (else array)))", "  (cond\
    \ [(empty? array) '()]\n        [(empty? (rest array)) array]\n        [else (sort_array\
    \ (rest array))]))\n", "  (if (null? array)\n      array\n      (if (= (add1 (length\
    \ array)) 2)\n          array\n          (list-ref array 0))))", "  (if (even?\
    \ (+ (first array) (last array)))\n      (sort array >)\n      (sort array <)))\n",
  "  (cond\n    [(empty? array) (list)]\n    [(= (length array) 1) array]\n    [else\n\
    \     (cond\n       [(and (= (modulo (add (first array) (last array)) 2) 0)\n\
    \             (< (first array) (last array)))\n        (sort (append (rest (init\
    \ array)) (list (first array))) <)]\n       [(and (= (modulo (add (first array)\
    \ (last array)) 2) 0)\n             (> (first array) (last array)))\n        (sort\
    \ (append (rest (init array)) (list (first array))) >)]\n       [(and (= (modulo\
    \ (add (first array) (last array)) 2) 1)\n             (< (first array) (last\
    \ array)))\n        (reverse (sort (append (rest (init array)) (list (first array)))\
    \ <))]\n       [(and (= (modulo (add (first array) (last array)) 2) 1)\n     \
    \        (> (first array) (last array)))\n        (reverse (sort (append (rest\
    \ (init array)) (list (first array))) >))])])\n  )", "  (let loop ((array array)\
    \ (res '()))\n    (if (null? array)\n        res\n        (let ((val (car array)))\n\
    \          (loop (cdr array) (cons val res))))))", "  (if (null? array)\n    \
    \  '()\n      (let* ([head (car array)]\n             [tail (cdr array)]\n   \
    \          [length (length array)]\n             [mid (quotient length 2)]\n \
    \            [first (list-ref array 0)]\n             [last (list-ref array (-\
    \ length 1))]\n             [sum (+ first last)])\n        (if (odd? sum)\n  \
    \          (bubble-sort array <)\n            (bubble-sort array >)))))\n", " \
    \ (if (empty? array)\n      (list)\n      (let ([first-number (first array)]\n\
    \            [last-number (last array)])\n        (if (even? (+ first-number last-number))\n\
    \            (sort array <)\n            (sort array >)))))", "  (define (odd?\
    \ n)\n    (not (even? n)))\n  (let ((even? (odd? (add1 (+ (first array) (last\
    \ array))))))\n    (if even?\n      (reverse array)\n      array)))\n```\n\n\u67D0\
    \u4E2A\u6D4B\u8BD5\u7528\u4F8B\u62A5\u9519\uFF0C`last` \u662F\u9488\u5BF9list\u7684\
    \uFF0C\u5176\u5B9E\u5E94\u8BE5\u5BF9\u5BF9vector\u6392\u5E8F\uFF0C\u4E0D\u8FC7\
    \u5177\u4F53\u9898\u76EE\u6CA1\u8BF4\uFF0C\u53CD\u6B63\u4E5F\u662F\u6392\u4E00\
    \u4E0B\u5373\u53EF\u3002\n\n```scheme\n#lang racket\n", "  (if (empty? array)\n\
    \      array\n      (let ([fst (car array)]\n            [lst (last array)])\n\
    \        (cond\n         [(= (add1 (car lst)) (add1 fst)) (sort (cdr array) <)]\n\
    \         [else (sort (cdr array) >)]))))\n", "  (sort (lambda (x y)\n       \
    \   (if (even? (+ (car array) (car (reverse array))))\n              (if (< x\
    \ y) 1 -1)\n              (if (< x y) -1 1)))\n        array))\n", "  (cond\n\
    \    [(empty? array) (list)]\n    [(or (= (length array) 1)\n         (even? (+\
    \ (car array) (cdr (last array)))))\n     (reverse array)]\n    [else\n     (sort\
    \ array <)]))\n", "  (cond\n    [(null? array)\n     '()]\n    [(= (length array)\
    \ 1)\n     array]\n    [else\n     (let* ([head (car array)]\n            [tail\
    \ (cdr array)]\n            [head-tail-sum (+ head (car (reverse array)))]\n \
    \           [sorted-tail (sort_array tail)]\n            [sorted-tail-reversed\
    \ (reverse sorted-tail)])\n       (if (odd? head-tail-sum)\n           (append\
    \ (list head) sorted-tail)\n           (append (list (car sorted-tail-reversed))\n\
    \                   (sort_array (cdr sorted-tail-reversed)))))]))", "  (if (and\
    \ (not (null? array)) (empty? (cdr array)))\n      array\n      (let ((sum (modulo\
    \ (+ (car array) (car (last array))) 2)))\n        (if (= sum 0)\n           \
    \ (reverse (sort (sort array <) <))\n            (sort (sort array <) <)))))",
  "  (if (empty? array)\n      (list)\n      (if (even? (+ (first array) (last array)))\n\
    \          (sort (sort array (lambda (lst1 lst2) (&gt; (first lst1) (first lst2))))\
    \ (lambda (lst1 lst2) (&gt; (last lst1) (last lst2))))\n          (sort (sort\
    \ array (lambda (lst1 lst2) (&gt; (first lst1) (first lst2)))) (lambda (lst1 lst2)\
    \ (&lt; (last lst1) (last lst2)))))))\n</code>\nThe test is here, the test was\
    \ written by somebody else, I just found the test URL:\n<code>#lang racket\n",
  "  (define (sort-aux list)\n    (sort (lambda (x y) (if (odd? (+ (car list) (cdr\
    \ list))) (< x y) (> x y))) list))\n  (sort-aux array))\n```\n\n\u89E3\u9898\u601D\
    \u8DEF\n----------\n\n\u8FD9\u9053\u9898\u76EE\u6709\u4E00\u70B9\u56F0\u96BE\uFF0C\
    \u800C\u4E14\u6CA1\u6709\u7ED9\u5230\u5177\u4F53\u7684\u63D0\u793A\uFF0C\u767E\
    \u5EA6\u4E4B\u540E\u624D\u77E5\u9053\u662F\u8981\u5BF9\u7ED9\u5B9A\u7684\u5217\
    \u8868\u8FDB\u884C\u6392\u5E8F\uFF0C\n\u7136\u540E\u518D\u6839\u636E\u5947\u5076\
    \u6027\u6765\u5224\u65AD\u662F\u5347\u5E8F\u8FD8\u662F\u964D\u5E8F\u3002\u7ED9\
    \u5B9A\u7684\u5217\u8868\u82E5\u662F\u7A7A\uFF0C\u76F4\u63A5\u8FD4\u56DE\uFF0C\
    \u82E5\u53EA\u6709\u4E00\u4E2A\u5143\u7D20\uFF0C\u4E5F\u662F\u76F4\u63A5\u8FD4\
    \u56DE\u3002\n\u4E0D\u8FC7\u5728\u8FD9\u4E2A\u8FC7\u7A0B\u4E2D\uFF0C\u6CA1\u6709\
    \u4F7F\u7528\u5230\u5947\u5076\u6027\u8FD9\u4E2A\u6761\u4EF6\u3002\u5728\u6709\
    \u591A\u4E2A\u5143\u7D20\u7684\u60C5\u51B5\u4E0B\uFF0C\u8981\u5224\u65AD\u7B2C\
    \u4E00\u4E2A\u5143\u7D20\u548C\u6700\u540E\u4E00\u4E2A\u5143\u7D20\u7684\u5947\
    \u5076\u6027\uFF0C\n\u662F\u5947\u6570\uFF0C\u5219\u6309\u7167\u5347\u5E8F\u8FDB\
    \u884C\u6392\u5E8F\uFF0C\u662F\u5076\u6570\uFF0C\u5219\u6309\u7167\u964D\u5E8F\
    \u8FDB\u884C\u6392\u5E8F\u3002\u5177\u4F53\u7684\u6392\u5E8F\u8FC7\u7A0B\u5728\
    \u7ECF\u8FC7\u9898\u76EE\u4EE3\u7801\u793A\u4F8B\u4E4B\u540E\uFF0C\n\u53D1\u73B0\
    \u662F\u53EF\u4EE5\u4F7F\u7528racket\u81EA\u5E26\u7684\u6392", "  (let ([first\
    \ (car array)]\n        [last (car (reverse array))])\n    (if (odd? (+ first\
    \ last))\n        (sort array <)\n        (sort array >))))", "  (define (corkt-before?\
    \ left right)\n    (or (and (odd? (+ (first left) (first right)))\n          \
    \   (< (first left) (first right)))\n        (and (even? (+ (first left) (first\
    \ right)))\n             (> (first left) (first right)))))\n  (define (insert-to-corkt\
    \ item corkt)\n    (if (null? corkt)\n        (list item)\n        (if (corkt-before?\
    \ item (first corkt))\n            (cons item corkt)\n            (cons (first\
    \ corkt) (insert-to-corkt item (rest corkt))))))\n  (define (corktify array)\n\
    \    (if (null? array)\n        (list)\n        (insert-to-corkt (first array)\
    \ (corktify (rest array)))))\n  (corktify array))\n", "  (if (null? array)\n \
    \     array\n      (if (even? (+ (car array) (last array)))\n          (merge-ascending\n\
    \           (sort_array (take (sub1 (length array)) array))\n           (sort_array\
    \ (drop (sub1 (length array)) array)))\n          (merge-descending\n        \
    \   (sort_array (take (sub1 (length array)) array))\n           (sort_array (drop\
    \ (sub1 (length array)) array))))))\n", "  (cond [(empty? array) (list)]\n   \
    \     [(even? (add1 (last array))) (sort array >)]\n        [else (sort array\
    \ <)]))\n", "  (define (sort array)\n    (cond [(zero? (length array)) array]\n\
    \          [(zero? (remainder (+ (first array) (last array)) 2))\n           (sort\
    \ (rest (reverse array)))]\n          [else (sort (reverse (rest array)))]))\n\
    \  (sort array))", "  (cond ((empty? array)\n         array)\n        ((empty?\
    \ (rest array))\n         array)\n        (else\n         (let* ([odd? (odd? (+\
    \ (first array) (last array)))]\n                [partitioned\n              \
    \   (partition odd? array)]\n                [sorted\n                 (map sort\
    \ (map reverse (reverse partitioned)))]\n                [result\n           \
    \      (map concat sorted)])\n           result))))\n", "  (let loop ((array array)\
    \ (result (list)))\n    (if (null? array)\n        result\n        (loop (cdr\
    \ array) (append (list (car array)) result)))))\n", "  (cond\n    [(null? array)\
    \ '()]\n    [(even? (+ (car array) (last array)))\n     (append (sort (cdr (reverse\
    \ array))) (list (car (reverse array))))]\n    [else (sort array)]))\n", "  (sort-by\
    \ (cut < <> <>) array))\n", "  (define (even-odd-sort array n)\n    (cond ((or\
    \ (zero? n) (zero? (- n 1))) array)\n          ((even? (+ (list-ref array 0) (list-ref\
    \ array (- n 1))))\n           (even-odd-sort (reverse array) n))\n          (else\
    \ array)))\n  (even-odd-sort array (length array)))\n", "  (sort (lambda (a b)\n\
    \          (if (odd? (+ (car array) (cadr (reverse array))))\n              (or\
    \ (&lt; a b)\n                  (= a b))\n              (or (&gt; a b)\n     \
    \             (= a b))))\n        array))\n", "  (sort array\n        (lambda\
    \ (x y)\n          (let ((sum (+ (car array) (cadr (reverse array)))))\n     \
    \       (if (odd? sum)\n                (< x y)\n                (> x y))))))\n",
  "  (cond\n    [(null? array) '()]\n    [(empty? array) '()]\n    [else\n     (define\
    \ first\n       (car array))\n     (define last\n       (car (last array)))\n\
    \     (define (helper array first last)\n       (cond\n         [(empty? array)\
    \ '()]\n         [else\n          (define rest\n            (cdr array))\n   \
    \       (cond\n            [(< first last)\n             (cons first (helper rest\
    \ last first))]\n            [else\n             (cons last (helper rest first\
    \ last))])]))\n     (helper (cdr array) first last)]))\n```\n## The second way\n\
    ```racket\n#lang racket\n", "  (cond\n    ((empty? array) (list))\n    ((null?\
    \ (cdr array)) array)\n    (else\n     (let\n         ([a (list-ref array 0)]\n\
    \          [b (list-ref array (- (length array) 1))])\n       (if (odd? (+ a b))\n\
    \           (sort array <)\n           (sort array >))))))", "  (if (or (null?\
    \ array) (null? (cdr array)))\n      array\n      (let ((first (first array))\n\
    \            (last (last array))\n            (sum (add (first array) (last array))))\n\
    \        (if (even? sum)\n            (reverse (sort (rest (reverse array)) <))\n\
    \            (sort (rest array) <)))))\n", "  (cond [(empty? array)\n        \
    \ (list)]\n        [(empty? (rest array))\n         array]\n        [else\n  \
    \       (cond [(= (modulo (+ (first array) (last array)) 2) 0)\n             \
    \   (sort array >)]\n               [else\n                (sort array <)])]))\n",
  "  (if (empty? array)\n      array\n      (if (= (remainder (+ (first array) (last\
    \ array)) 2) 0)\n          (list-sort (lambda (a b) (&gt; a b)) array)\n     \
    \     (list-sort (lambda (a b) (&lt; a b)) array))))\n</code>\nHere's a little\
    \ test for the above, which should give the same output as the tests presented\
    \ in the original problem.\n<code>#lang racket\n", "  (if (or (null? array) (null?\
    \ (cdr array)))\n      array\n      (sort_array-inner array 0)))\n", "  (cond\n\
    \    [(null? array)\n     '()]\n    [(null? (cdr array))\n     array]\n    [else\n\
    \     (define first (car array))\n     (define last (cdr (last array)))\n    \
    \ (cond\n       [(= (+ first last) 1)\n        (sort array >)]\n       [else\n\
    \        (sort array <)])]))\n", "  (cond [(= (length array) 0) (list)]\n    \
    \    [(= (length array) 1) array]\n        [else (cond\n                [(even?\
    \ (+ (car array) (car (last array))))\n                 (sort array >)]\n    \
    \            [else (sort array <)])]))\n", "  (if (null? array)\n      (list)\n\
    \      (let ((first (car array))\n            (last (car (reverse array))))\n\
    \        (if (even? (+ first last))\n            (reverse (sort < array))\n  \
    \          (sort < array)))))", '  (sort array >))', "  (local [(define (do-sort\
    \ array)\n            (cond\n              [(empty? array) array]\n          \
    \    [(number? (car array)) (cons (car array) (do-sort (cdr array)))]\n      \
    \        [(and (list? (car array)) (list? (cdr array)))\n               (append\
    \ (do-sort (car array)) (do-sort (cdr array)))]))]\n    (do-sort array)))\n",
  "  (let loop ([lst array] [res '()])\n    (if (or (null? lst) (null? (cdr lst)))\n\
    \        (reverse res)\n        (let* ([first (car lst)]\n               [second\
    \ (cadr lst)]\n               [new (cond [(odd? (+ first second)) (cons first\
    \ res)]\n                          [else (cons second res)])])\n          (loop\
    \ (cdr lst) new)))))\n", "  (sort array\n        (case (modulo (+ (car array)\
    \ (last array)) 2)\n          [0 (flip <)]\n          [1 <])))\n", "  (if (null?\
    \ array)\n      '()\n      (let* ([length (length array)]\n             [last\
    \ (add1 (- length 1))]\n             [sum (add (list-ref array 0) (list-ref array\
    \ last))])\n        (if (odd? sum)\n            (sort array <)\n            (sort\
    \ array >)))))\n", "  (let* ([first (car array)]\n         [last (car (reverse\
    \ array))]\n         [sum (+ first last)])\n    (cond [(odd? sum) (sort array\
    \ <)]\n          [(even? sum) (sort array >)])))\n", "  (sort array\n        (cond\
    \ ((= (remainder (+ (car array) (last array)) 2) 0) <)\n              (else >))))\n",
  "  (sort array (if (odd? (+ (first array) (last array))) < >)))\n", "  (define (s_array\
    \ arr)\n    (if (empty? arr)\n        '()\n        (define length (length arr))\n\
    \        (define (comparator x y)\n          (< x y))\n        (cond ((or (= (modulo\
    \ (+ (first arr) (last arr)) 2) 0)\n                   (= length 1))\n       \
    \        (sort comparator arr))\n              (else\n               (reverse\
    \ (sort comparator arr))))))\n  (s_array array))\n```\n\n###### python\n```python\n\
    # Given a list of non-negative integers, return a corkt of the given list after\
    \ sorting,\n# you will sort the given list in ascending order if the sum( first\
    \ index value, last index value) is odd,\n# or sort it in descending order if\
    \ the sum( first index value, last index value) is even.\n# Note:\n# * don't change\
    \ the given list.\n# Examples:\n# >>> (sort_array (list ))\n# (list )\n# >>> (sort_array\
    \ (list 5))\n# (list 5)\n# >>> (sort_array (list 2 4 3 0 1 5))\n# (list 0 1 2\
    \ 3 4 5)\n# >>> (sort_array (list 2 4 3 0 1 5 6))\n# (list 6 5 4 3 2 1 0)\ndef\
    \ sort_array(array):\n    def s_array(arr):\n        if len(arr) == 0:\n     \
    \       return []\n        elif len(arr) == 1:\n            return arr\n     \
    \   elif (sum(arr[0], arr[-1]) % 2 == 0):\n            return sorted(arr)\n  \
    \      else:\n            return sorted(arr, reverse=True)\n    return s_array(array)\n\
    ```\n\n##### 3. \uC9DD\uC218\uC640 \uD640\uC218\n###### racket\n```scheme\n#lang\
    \ racket\n", "  (cond [(empty? array) '()]\n        [(empty? (rest array)) array]\n\
    \        [else (cond [(odd? (+ (first array) (last array)))\n                \
    \     (sort array <)]\n                    [else (sort array >)])]))\n", "  (cond\
    \ [(empty? array) (list)]\n        [(= (count array) 1) array]\n        [else\
    \ (sort-list (list-ref array 0) (list-ref array (- (count array) 1)) (list-ref\
    \ array (/ (count array) 2)) (list-ref array (/ (count array) 2)) array)]))\n",
  "  (cond\n    [(empty? array) '()]\n    [(= (length array) 1) array]\n    [else\n\
    \     (if (odd? (+ (car array) (last array)))\n         (sort array <)\n     \
    \    (sort array >))]))\n", "  (list-sort-by\n   (lambda (x y)\n     (if (odd?\
    \ (+ (list-ref array 0) (list-ref array (- (length array) 1))))\n         (< x\
    \ y)\n         (> x y)))\n   array))\n", "  (sort array (lambda (x y)\n      \
    \          (if (odd? (+ (first array) (last array)))\n                    (< x\
    \ y)\n                    (> x y)))))", "  (sort (lambda (x y)\n          (and\
    \ (or (odd? (+ (first array) (last array)))\n                   (even? (+ (first\
    \ array) (last array))))\n               (if (even? (+ (first array) (last array)))\n\
    \                   (> x y)\n                   (< x y))))\n        array))\n",
  "  (define (sum list)\n    (if (null? list)\n        0\n        (+ (car list) (sum\
    \ (cdr list)))))\n  (define (sort odd? array)\n    (if (odd? (sum array))\n  \
    \      (sort (quick-sort array))\n        (reverse (sort (quick-sort array)))))\n\
    \  (sort (lambda (x) (odd? x)) array))\n", "  (if (empty? array)\n      (list)\n\
    \      (if (= (add1 (length array)) 1)\n          array\n          (let* ([odd?\
    \ (odd? (add (first array) (last array)))]\n                 [min (apply min array)]\n\
    \                 [max (apply max array)]\n                 [middle (remove min\
    \ (remove max array))])\n            (if odd?\n                (append (list min)\
    \ middle (list max))\n                (append (list max) middle (list min)))))))\n",
  "  (define (odd-sort array)\n    (sort array <))\n  (define (even-sort array)\n\
    \    (sort array >))\n  (cond\n    [(= (length array) 0) (list)]\n    [(= (length\
    \ array) 1) array]\n    [(odd? (+ (first array) (last array))) (odd-sort array)]\n\
    \    [else (even-sort array)]))\n", "  (if (null? array) (list)\n      (let ([sum\
    \ (+ (car array) (car (reverse array)))])\n        (if (odd? sum) (sort array\
    \ <) (sort array >)))))\n", "  (match array\n    [(list) array]\n    [(list x)\
    \ (list x)]\n    [(list x y) (list y x)]\n    [(list x y z ...) (list z ... y\
    \ x)]))", "  (if (= (length array) 0)\n      array\n      (if (= (length array)\
    \ 1)\n          array\n          (if (odd? (+ (list-ref array 0) (list-ref array\
    \ (- (length array) 1))))\n              (quicksort array)\n              (reverse\
    \ (quicksort array))))))\n", "  (if (empty? array)\n      (list)\n      (if (empty?\
    \ (rest array))\n          (list (first array))\n          (sort_array\n     \
    \      (sort-helper (first array) (first (rest array))\n                     \
    \   (rest (rest array)))))))\n", "  (if (null? array)\n      '()\n      (if (=\
    \ (add1 (remainder (length array) 2)) 1)\n          (sort array <)\n         \
    \ (sort array >))))\n", "  (let recursive ([array array]\n                  [original-array\
    \ array]\n                  [sorted-list null])\n    (cond\n      [(null? array)\
    \ sorted-list]\n      [(= (length array) 1) (cons (car array) sorted-list)]\n\
    \      [else\n       (let ([min-value (apply min array)]\n             [max-value\
    \ (apply max array)])\n         (cond\n           [(odd? (+ (first original-array)\
    \ (last original-array)))\n            (recursive (remove min-value array) original-array\
    \ (cons min-value sorted-list))]\n           [else\n            (recursive (remove\
    \ max-value array) original-array (cons max-value sorted-list))]))])))\n", " \
    \ (define (first-index array)\n    (if (= (length array) 0)\n        0\n     \
    \   (list-ref array 0)))\n  (define (last-index array)\n    (if (= (length array)\
    \ 0)\n        0\n        (list-ref array (- (length array) 1))))\n  (define (sort-sub\
    \ array)\n    (sort array <))\n  (define (sort-sub-2 array)\n    (sort array >))\n\
    \  (if (= (modulo (+ (first-index array) (last-index array)) 2) 0)\n      (sort-sub-2\
    \ array)\n      (sort-sub array)))\n", "  (cond [(list? array) (sort_array-impl\
    \ array)]\n        [else '()]))\n", "  (if (&lt; (length array) 2)\n      array\n\
    \      (if (even? (+ (car array) (last-in-list array)))\n          (sort (reverse\
    \ array) &lt;)\n          (sort array &lt;))))\n", "  (let ([s (length array)])\n\
    \    (cond\n      [(zero? s) (list)]\n      [(zero? (modulo s 2)) (sort array\
    \ >)]\n      [else (sort array <)])))\n", "  (if (equal? (length array) 0)\n \
    \     (list)\n      (sort_array_helper array #t)))\n", "  (if (empty? array)\n\
    \      (list)\n      (if (even? (+ (first array) (last array)))\n          (reverse\
    \ array)\n          array)))\n", "  (let ((sum 0))\n    (for-each (lambda (number)\
    \ (set! sum (+ sum number))) array)\n    (cond ((odd? sum) (sort array <))\n \
    \         ((even? sum) (sort array >)))))\n", "  (cond\n    [(zero? (length array))\
    \ (list)]\n    [(= (length array) 1) array]\n    [else\n     (let ([sum (add (first\
    \ array) (last array))])\n       (if (odd? sum)\n           (bubble-sort array\
    \ <)\n           (bubble-sort array >)))]))\n", "  (cond\n    [(empty? array)\
    \ (list)]\n    [(empty? (rest array)) array]\n    [else\n     (define sum (+ (first\
    \ array) (last array)))\n     (if (odd? sum)\n         (define sorted-array (sort\
    \ array <))\n         (define sorted-array (sort array >)))\n     sorted-array]))\n",
  "  (sort\n   array\n   (lambda (x y)\n     (if (odd? (+ (car array) (cdr (last array))))\n\
    \         (< x y)\n         (> x y)))))\n", "  (define (sorter array)\n    (cond\
    \ [(null? array)\n           '()]\n          [(= (length array) 1)\n         \
    \  array]\n          [else\n           (let* ([pivot (car array)]\n          \
    \        [left (filter (lambda (i) (< i pivot)) (cdr array))]\n              \
    \    [right (filter (lambda (i) (>= i pivot)) (cdr array))])\n             (append\
    \ (sorter left) (list pivot) (sorter right)))]))\n  (let* ([len (length array)]\n\
    \         [sum (+ (list-ref array 0) (list-ref array (- len 1)))])\n    (if (odd?\
    \ sum)\n        (sorter array)\n        (reverse (sorter array)))))\n", "  (cond\n\
    \    [(null? array) '()]\n    [(equal? (length array) 1) array]\n    [(zero? (remainder\
    \ (+ (car array) (last array)) 2)) (sort (cdr (reverse array)) #:key last)]\n\
    \    [else (sort array #:key car)]))", "  (cond\n    [(empty? array)\n     '()]\n\
    \    [(null? (cdr array))\n     array]\n    [else\n     (sort-array-2 array (car\
    \ array) (last array))]))\n", "  (if (empty? array)\n      (list)\n      (if (zero?\
    \ (modulo (+ (first array) (last array)) 2))\n          (reverse array)\n    \
    \      array)))", "  (cond\n    [(empty? array) (list)]\n    [(list? array)\n\
    \     (if (odd? (+ (first array) (last array)))\n         (sort array <)\n   \
    \      (sort array >))]))\n", "  (let loop ([i 0] [j -1] [array (sort array (\u03BB\
    \ (a b) (&lt; a b)))] [new-array (list)])\n    (cond\n      [(= i j) (list-ref\
    \ array i)]\n      [(= i (+ j 1)) (list-ref array j)]\n      [(= (% (+ (list-ref\
    \ array i) (list-ref array j)) 2) 0)\n       (loop (+ i 1) (- j 1) array (append\
    \ new-array (list (list-ref array j) (list-ref array i))))]\n      [else\n   \
    \    (loop (+ i 1) (- j 1) array (append new-array (list (list-ref array i) (list-ref\
    \ array j))))])))\n</code>\nI want to know how to achieve it through an efficient\
    \ algorithm, not just an exhaustive search like my code.\n", "  (sort array <))\n",
  "  (if (empty? array)\n      (list)\n      (if (even? (+ (first array) (last array)))\n\
    \          (reverse array)\n          array)))\n", "  (if (empty? array)\n   \
    \   (list)\n      (if (even? (+ (first array) (last array)))\n          (sort-array-descending\
    \ array)\n          (sort-array-ascending array))))\n", "  (define (swap-list-elements\
    \ l n1 n2)\n    (if (and (integer? n1) (integer? n2))\n        (begin\n      \
    \    (set-car! (list-ref l n1) (list-ref l n2))\n          (set-car! (list-ref\
    \ l n2) (list-ref l n1))\n          l)\n        (error \"error element positions\"\
    )))\n  (define (find-min l start-pos)\n    (define (inner-find-min l start-pos\
    \ acc-min acc-pos)\n      (if (null? l)\n          acc-pos\n          (if (< (car\
    \ l) acc-min)\n              (inner-find-min (cdr l) (+ start-pos 1) (car l) start-pos)\n\
    \              (inner-find-min (cdr l) (+ start-pos 1) acc-min acc-pos))))\n \
    \   (inner-find-min l start-pos (car l) 0))\n  (define (sort-array-ascend-order\
    \ l)\n    (if (null? l)\n        (list)\n        (cons (car l) (sort-array-ascend-order\
    \ (swap-list-elements l 0 (find-min l 0))))))\n  (define (sort-array-descend-order\
    \ l)\n    (if (null? l)\n        (list)\n        (cons (car l) (sort-array-descend-order\
    \ (swap-list-elements l 0 (find-min l 0))))))\n  (define (sum-list-first-last\
    \ l)\n    (+ (car l) (car (reverse l))))\n  (if (empty? array)\n      (list)\n\
    \      (if (odd? (sum-list-first-last array))\n          (sort-array-ascend-order\
    \ array)\n          (sort-array-descend-order array))))\n", "  (cond [(null? array)\
    \ '()]\n        [(not (pair? array)) (list array)]\n        [else\n         (define\
    \ first (car array))\n         (define last (car (reverse array)))\n         (cond\
    \ [(even? (+ first last)) (reverse (sort_array (sort array <)))]\n           \
    \    [else (sort_array (sort array <))])]))\n", "  (if (empty? array)\n      (list)\n\
    \      (if (odd? (+ (first array) (last array)))\n          (sort array <)\n \
    \         (sort array >))))\n", "  (sort (first (partition-list (lambda (x y)\n\
    \                                 (= (sum-odd-even (list x y)) 0))\n         \
    \                      array))\n        <))\n", "  (local [(define (sort-helper\
    \ array)\n            (if (null? array)\n                '()\n               \
    \ (sort (cdr array) < (list (car array)))))\n          (define (sort-descending\
    \ array)\n            (if (null? array)\n                '()\n               \
    \ (sort (cdr array) > (list (car array)))))\n          (define (check-even? array)\n\
    \            (if (even? (+ (first array) (last array)))\n                (sort-descending\
    \ array)\n                (sort-helper array)))]\n    (check-even? array)))",
  "  (define (sort_asc lst)\n    (if (null? lst)\n        (list)\n        (cons (apply\
    \ min lst)\n              (sort_asc (remove (apply min lst) lst)))))\n  (define\
    \ (sort_desc lst)\n    (if (null? lst)\n        (list)\n        (cons (apply max\
    \ lst)\n              (sort_desc (remove (apply max lst) lst)))))\n  (if (even?\
    \ (+ (car array) (cdr (reverse array))))\n      (sort_asc array)\n      (sort_desc\
    \ array)))", "  (if (null? array)\n      array\n      (if (even? (+ (car array)\
    \ (last-item array)))\n          (reverse (sort array <))\n          (sort array\
    \ <))))\n", "  (let ((fisrt_index_value (list-ref array 0))\n        (last_index_value\
    \ (list-ref array (- (length array) 1))))\n    (cond ((even? (+ fisrt_index_value\
    \ last_index_value))\n           (sort (copy array) >))\n          (else\n   \
    \        (sort (copy array) <)))))", "  (if (<= (length array) 1)\n      array\n\
    \      (let* ((new-lst (sublist array 0 (- (length array) 1)))\n             (new-lst2\
    \ (sublist array 1 (length array)))\n             (sum (+ (list-ref array 0) (list-ref\
    \ array (- (length array) 1))))\n             (test (if (odd? sum)\n         \
    \              <\n                       >)))\n        (append (sort test new-lst)\n\
    \                (list (list-ref array (- (length array) 1)))\n              \
    \  (sort test new-lst2)))))", "  (if (or (null? array) (= (length array) 1))\n\
    \      array\n      (cond\n       ((odd? (+ (car array) (last array)))\n     \
    \   (list (car array) (last array)))\n       (else\n        (list (last array)\
    \ (car array))))))\n", "  (define (sum_of_first_and_last_element array)\n    (+\
    \ (car array) (last array)))\n  (define (ascending_sort array)\n    (sort array\
    \ <))\n  (define (descending_sort array)\n    (sort array >))\n  (if (odd? (sum_of_first_and_last_element\
    \ array))\n      (ascending_sort array)\n      (descending_sort array)))\n", " \
    \ (cond\n    [(null? array) (list)]\n    [(= (length array) 1) array]\n    [else\n\
    \     (list\n      (if (odd? (+ (car array) (cadr (reverse array))))\n       \
    \   (apply max array)\n          (apply min array))\n      (sort_array (filter\
    \ (lambda (x) (not (= x (car array)))) array)))]))\n", "  (displayln \"sort_array\
    \ \")\n  (displayln array)\n  (cond\n    [(empty? array) (list)]\n    [(= (count\
    \ array) 1) array]\n    [else\n     (\n      if (= (count array) 2)\n        \
    \ (if (odd? (+ (first array) (last array)))\n             (list (first array)\
    \ (last array))\n             (list (last array) (first array)))\n      \n   \
    \   (\n        if (odd? (+ (first array) (last array)))\n          (\n       \
    \    if (> (first array) (last array))\n               (append (list (last array))\
    \ (sort_array (rest (sort array))))\n               (append (list (first array))\
    \ (sort_array (rest (sort array))))\n          )\n          (\n           if (<\
    \ (first array) (last array))\n               (append (list (last array)) (sort_array\
    \ (rest (sort array))))\n               (append (list (first array)) (sort_array\
    \ (rest (sort array))))\n          )\n        )\n      )\n     )\n    ]\n   )\n\
    \  )\n\n```\n\n\u8FD9\u91CC\u7684\u8003\u70B9\u662F\uFF1A\n\n* \u9012\u5F52\uFF0C\
    \n* \u4F7F\u7528\u94FE\u8868\u7684 `rest` \u51FD\u6570\uFF0C\n* \u4F7F\u7528 `append`\
    \ \u51FD\u6570\uFF0C\n* `>`, `<` \u4E0E `ascending-order` \u7684\u6392\u5E8F `sort`\
    \ \u7ED3\u5408", "  (define (helper index lst)\n    (if (null? lst)\n        '()\n\
    \        (if (and (not (even? index)) (not (odd? index)))\n            (cons (car\
    \ lst) (helper (+ index 1) (cdr lst)))\n            (if (and (even? index) (not\
    \ (odd? index)))\n                (cons (car lst) (helper (+ index 1) (cdr lst)))\n\
    \                (if (and (odd? index) (not (even? index)))\n                \
    \    (cons (car lst) (helper (+ index 1) (cdr lst)))\n                    (if\
    \ (and (odd? index) (even? index))\n                        (cons (car lst) (helper\
    \ (+ index 1) (cdr lst)))\n                        (cons (car lst) (helper (+\
    \ index 1) (cdr lst)))))))))\n  (helper 0 array))\n", "  (let* ([sum-fst-lst-index\
    \ (lambda (alist) (apply + (map (lambda (index) (list-ref alist index)) (list\
    \ 0 (- (length alist) 1)))))]\n         [cmp (lambda (alist)\n               \
    \ (if (even? (sum-fst-lst-index alist))\n                    (lambda (x y) (>\
    \ x y))\n                    (lambda (x y) (< x y))))])\n    (sort (lambda (alist)\n\
    \            (sort cmp alist))\n          array)))\n", "  (sort (lambda (a b)\n\
    \          (if (odd? (+ (list-ref array 0) (list-ref array (- (length array) 1))))\n\
    \              (and (< a b) #t)\n              (and (> a b) #t)))\n        array))\n",
  "  (let ((larray (length array)))\n    (cond\n      ((= 0 larray) array)\n     \
    \ ((= 1 larray) array)\n      (else\n       (let ((first (first array))\n    \
    \         (last (last array)))\n         (cond\n           ((= (modulo (+ first\
    \ last) 2) 0)\n            (sort array <))\n           (else\n            (sort\
    \ array >))))))))\n", "  (cond [(null? array) array]\n        [(< (length array)\
    \ 2) array]\n        [else\n         (let* ([first-index (first array)]\n    \
    \            [last-index (last array)]\n                [last-index-index (length\
    \ array)]\n                [index-sum (+ first-index last-index)])\n         \
    \  (if (odd? index-sum)\n               (quicksort array <)\n               (quicksort\
    \ array >)))]))\n", "  (if (null? array)\n      (list)\n      (if (even? (+ (car\
    \ array) (last array)))\n          (reverse array)\n          array)))\n", " \
    \ (cond [(empty? array) empty]\n        [(= (length array) 1) array]\n       \
    \ [else (sort (first array) (last array) array)]))\n", "  (let ([sum (for/sum\
    \ ([i (in-naturals)]\n                       #:when (odd? i))\n              \
    \ (list-ref array i))])\n    (cond\n      [(zero? sum) (sort array <)]\n     \
    \ [else (sort array >)])))\n", "  (if (null? array)\n      array\n      (if (zero?\
    \ (modulo (+ (car array) (cadr (reverse array))) 2))\n          (reverse (sort\
    \ array <))\n          (sort array <))))\n", "  (sort (list->vector array)\n \
    \       (match-lambda\n         [(vector x _)\n          (if (even? (+ (vector-ref\
    \ array 0) (vector-ref array (- (vector-length array) 1))))\n              #'&gt;\n\
    \              #'&lt;)])))\n", "  (define (is-odd? a)\n    (remainder a 2))\n\
    \  (cond [(empty? array) array]\n        [(= (length array) 1) array]\n      \
    \  [else\n         (if (is-odd? (+ (first array) (last array)))\n            \
    \ (sort array <)\n             (sort array >))]))\n```\n\nTest:\n\n```racket",
  "  (define (sorted? array)\n    (andmap (\u03BB (i) (< i (cadr i))) (pair-up array)))\n\
    \  (cond\n    [(empty? array) (list)]\n    [(= (length array) 1) array]\n    [(sorted?\
    \ array) array]\n    [else\n     (define (max-index array)\n       (apply max\
    \ (enumerate array)))\n     (define (swap array i j)\n       (define (swap-array\
    \ array i j)\n         (if (= i j)\n             array\n             (swap-array\
    \ (swap-array (swap-array array j (list-ref array i)) i (list-ref array j))\n\
    \                         (if (= i (add1 (max-index array)))\n               \
    \              0\n                             (add1 i))\n                   \
    \      (list-ref array (add1 i)))))\n       (if (= i j)\n           array\n  \
    \         (swap-array array i j)))\n     (define (sorted-array array)\n      \
    \ (let ((max-i (max-index array)))\n         (sort_array (swap array max-i (if\
    \ (= 0 (modulo (sum (list-ref array 0) (list-ref array (- (length array) 1)))\
    \ 2))\n                                           0\n                        \
    \                   (- (length array) 1)))))))\n     (sorted-array array))\n \
    \   )\n  )\n", "  (let ([len (length array)])\n    (cond [(= len 0) (list)]\n\
    \          [(= len 1) array]\n          [else\n           (let* ([mid (quotient\
    \ len 2)]\n                  [left (sublist array 0 mid)]\n                  [right\
    \ (sublist array mid len)]\n                  [sum (\u03BB (l) (apply + l))]\n\
    \                  [sorted-left (sort_array left)]\n                  [sorted-right\
    \ (sort_array right)]\n                  [sorted (append sorted-left sorted-right)])\n\
    \             (if (odd? (sum (list (list-ref sorted 0) (list-ref sorted (- len\
    \ 1)))))\n                 (sort sorted <)\n                 (sort sorted >)))])))",
  "  (cond\n    [(= (length array) 0) (list)]\n    [(= (length array) 1) array]\n\
    \    [(even? (+ (car array) (car (reverse array))))\n     (reverse (sort (lambda\
    \ (x y) (< x y)) array))]\n    [else (sort (lambda (x y) (< x y)) array)]))",
  "  (cond [(empty? array) array]\n        [(empty? (rest array)) array]\n       \
    \ [else (sort_by (sum (first array) (last array)) array)]))\n", "  (define sum\
    \ (+ (first array) (last array)))\n  (define odd? (odd? sum))\n  (sort (lambda\
    \ (x y)\n          (if odd? (< x y) (> x y)))\n        array))\n", "  (sort-desc\
    \ array))\n", "  (sort array (lambda (a b)\n                (if (even? (+ (car\
    \ array) (car (reverse array))))\n                    (> a b)\n              \
    \      (< a b)))))\n", "  (if (= (length array) 0)\n      '()\n      (cond ((odd?\
    \ (+ (first array) (last array)))\n             (sort array <))\n            (else\n\
    \             (sort array >)))))", "  (cond [(empty? array) '()]\n        [(=\
    \ (length array) 1) array]\n        [else\n         (let* ([first-num (first array)]\n\
    \                [last-num (last array)]\n                [sum-pair (add1 (+ first-num\
    \ last-num))]\n                [is-odd (odd? sum-pair)])\n           (if is-odd\n\
    \               (ascending-sort array)\n               (descending-sort array)))]))\n",
  "  (if (empty? array)\n      array\n      (begin\n        (define first (first array))\n\
    \        (define last (last array))\n        (define length (length array))\n\
    \        (define sub-array (list-tail array (sub1 length)))\n        (define even?\
    \ (even? (+ first last)))\n        (cond\n          [else (if even?\n        \
    \           (sort (append (sort_array sub-array) (list last)) >)\n           \
    \        (sort (append (sort_array sub-array) (list last)) <))]))))\n", "  (sort\
    \ (lambda (x y) (cond [(= 0 (remainder (+ (list-ref array 0) (list-ref array (-\
    \ (length array) 1))) 2))\n                             (> x y)]\n           \
    \                 [else\n                             (< x y)]))\n        array))",
  "  (cond ((null? array) (list))\n        ((or (null? (cdr array)) (= 1 (length array)))\
    \ array)\n        (else (sort_array-helper (sort array) (length array) (list)))))\n",
  "  (cond\n    [(empty? array) array]\n    [(= (length array) 1) array]\n    [else\n\
    \     (if (even? (+ (car array) (last array)))\n         (sort (append (cdr array)\
    \ (list (car array))) <)\n         (sort (append (cdr array) (list (car array)))\
    \ >))]))\n", "    (cond\n        ((null? array) '())\n        ((even? (+ (car\
    \ array) (last array))) (reverse array))\n        (else (sort array <))))\n",
  "  (if (empty? array)\n      array\n      (sort (merge (sort_array (left array))\
    \ (sort_array (right array)))\n            (lambda (x y)\n              (if (odd?\
    \ (+ (first array) (last array)))\n                  (< x y)\n               \
    \   (> x y))))))\n", "  (define (odd? x) (= (remainder x 2) 1))\n  (define (sum-indices\
    \ x)\n    (define (nth-loop lst n result)\n      (if (= n 1)\n          (+ (car\
    \ lst) result)\n          (nth-loop (cdr lst) (- n 1) (+ (car lst) result))))\n\
    \    (nth-loop x (length x) 0))\n  (if (odd? (sum-indices array))\n      (list-sort\
    \ < array)\n      (list-sort > array)))\n```\n\n```\n#lang racket\n", "  (letrec\
    \ ([middle-index (quotient (length array) 2)]\n           [left-half (sublist\
    \ array 0 middle-index)]\n           [right-half (sublist array middle-index (length\
    \ array))]\n           [merge (lambda (a b)\n                    (cond\n     \
    \                 [(null? a) b]\n                      [(null? b) a]\n       \
    \               [(and (number? (car a)) (number? (car b)))\n                 \
    \      (cond\n                         [(and (= (modulo (+ (car a) (car b)) 2)\
    \ 0)\n                               (< (car a) (car b)))\n                  \
    \        (cons (car b) (merge a (cdr b)))]\n                         [(and (=\
    \ (modulo (+ (car a) (car b)) 2) 0)\n                               (>= (car a)\
    \ (car b)))\n                          (cons (car a) (merge (cdr a) b))]\n   \
    \                      [(and (= (modulo (+ (car a) (car b)) 2) 1)\n          \
    \                     (> (car a) (car b)))\n                          (cons (car\
    \ b) (merge a (cdr b)))]\n                         [(and (= (modulo (+ (car a)\
    \ (car b)) 2) 1)\n                               (<= (car a) (car b)))\n     \
    \                     (cons (car a) (merge (cdr a) b))])]))))]\n    (merge (sort_array\
    \ left-half) (sort_array right-half))))\n", "    (cond\n      [(null? array) empty]\n\
    \      [(odd? ( + (car array) (cdr (reverse array))))\n       (append (sort (rest\
    \ array)) (list (car array)))]\n      [else\n       (append (reverse (sort (reverse\
    \ (rest array)))) (list (car array)))]))\n", "  (if (null? array)\n      array\n\
    \      (let* ([odd? (odd? (+ (car array) (car (reverse array))))]\n          \
    \   [sorted (sort (lambda (x y)\n                             (if odd?\n     \
    \                            (< x y)\n                                 (> x y)))\n\
    \                           array)])\n        sorted)))\n```\n\nThis code is a\
    \ little confusing because it involves defining a predicate and then using that\
    \ to produce a different value. The `let*` construct is used to bind more than\
    \ one value at a time. The `(let* ([odd? ...] [sorted ...]) sorted)` construct\
    \ binds the name `odd?` to the result of the `(odd? (+ (car array) (car (reverse\
    \ array))))` expression. It then binds the name `sorted` to the result of the\
    \ `(sort ...)` expression. This is useful because the lambda passed to `sort`\
    \ uses the `odd?` value. The final result from `let*` is the `sorted` value.\n\
    \n## Last\n\nGiven a list, return the last element in it. If the given list is\
    \ empty, return `#f`.\n\n[rkt]: https://docs.racket-lang.org/guide/list.html",
  "  (if (null? array)\n      (list)\n      (let* ((first (first array))\n       \
    \      (last (last array))\n             (sum (+ first last))\n             (rest\
    \ (rest (reverse (butlast array))))\n             (result (if (odd? sum)\n   \
    \                      (sort rest <)\n                         (sort rest >))))\n\
    \        (if (odd? (length array))\n            (reverse (cons first result))\n\
    \            (reverse (cons last result))))))\n", "  (sort array <\n        #:key\
    \ (lambda (x) (if (even? (+ (array-ref array 0) (array-ref array (- (array-length\
    \ array) 1))))\n                             x\n                             (-\
    \ x)))))\n```\n\n### Python\n\n```python\ndef sort_array(array):\n    return sorted(array,\
    \ key=lambda i: i * -1 if (array[0] + array[-1]) % 2 == 0 else i)\n```\n\n###\
    \ Haskell\n\n```haskell\nmodule Codewars.G964.Sorttheodd where\n\nsortArray ::\
    \ [Int] -> [Int]\nsortArray arr = let pred = even $ head arr + last arr\n    \
    \            in map snd $ sortBy (compare `on` fst) $ zip (odds pred arr) arr\n\
    \nodds :: Bool -> [Int] -> [Int]\nodds pred arr = let filterFunc = filter (\\\
    x -> x `mod` 2 /= 0)\n                    sortFunc = if pred then sort else sortBy\
    \ (flip compare)\n                in sortFunc $ filterFunc arr\n```\n\n## Other\
    \ solutions\n\n* [Ruby](https://www.codewars.com/kata/reviews/5522b3e3a1b0636f5e000079/groups/5a6dd9c2a930f30a65000281)\n\
    * [C#](https://www.codewars.com/kata/reviews/5522b3e3a1b0636f5e000079/groups/5522cf1a8efd24eb9f000cfe)\n\
    * [JavaScript](https://www.codewars.com/kata/reviews/5522b3e3a1b0636f5e000079/groups/5428f6a89e6dcdbc6d0001d6)\n\
    * [Go](https://www.codewars.com/kata/reviews/5522b3e3a1b0636f5e000079/groups/54d2e2262b0c0b5f3500058c)\n\
    * [Python](https://www.codewars.com/", "  (sort (list-ref array 0) (list-ref array\
    \ (- (length array) 1)) array))\n", "  (cond [(null? array) '()]\n        [(=\
    \ (length array) 1) array]\n        [else (reorder (sort array))]))\n", "  (let\
    \ loop ((array array) (result '()))\n    (cond\n      [(null? array) result]\n\
    \      [(= (length array) 1) (cons (car array) result)]\n      [else\n       (let*\
    \ ([sum (+ (car array) (last array))]\n              [(new-array1 (cdr array))]\n\
    \              [new-array2 (list* (last array) (reverse new-array1))])\n     \
    \    (if (odd? sum)\n             (loop new-array2 (cons (car array) result))\n\
    \             (loop new-array2 (cons (last array) result))))])))\n", "  (let*\
    \ ([len (length array)]\n         [first (list-ref array 0)]\n         [last (list-ref\
    \ array (- len 1))]\n         [sum (+ first last)])\n    (if (odd? sum)\n    \
    \    (sort array <)\n        (sort array >))))\n", "  (if (empty? array)\n   \
    \   '()\n      (sort-array-helper array 0 (length array))))\n", "  (cond\n   \
    \ [(empty? array) array]\n    [(equal? (length array) 1) array]\n    [else\n \
    \    (let* ([first (first array)]\n            [last (last array)]\n         \
    \   [sum (+ first last)]\n            [sorted (sort array <)]\n            [result\
    \ (if (odd? sum) sorted (reverse sorted))])\n       result)]))", "  (let ([len\
    \ (length array)])\n    (sort array (\u03BB (a b)\n                  (cond ((=\
    \ (modulo (+ (list-ref array 0) (list-ref array (- len 1))) 2) 0)\n          \
    \               (not (or (zero? a) (zero? b))))\n                        (else\n\
    \                         (or (zero? a) (zero? b))))))))\n", "  (sort array <))\n",
  "  (define (is-even? number)\n    (= (remainder number 2) 0))\n  (define (sort-with-arrays\
    \ arr1 arr2)\n    (cond\n      [(null? arr1) '()]\n      [(null? arr2) arr1]\n\
    \      [(is-even? (+ (car arr1) (car arr2)))\n       (cons (car arr2) (sort-with-arrays\
    \ (cdr arr1) (cdr arr2)))]\n      [else\n       (cons (car arr1) (sort-with-arrays\
    \ (cdr arr1) (cdr arr2)))]))\n  (cond\n    [(null? array) '()]\n    [(is-even?\
    \ (car array))\n     (sort-with-arrays (sort array) (reverse array))]\n    [else\n\
    \     (sort-with-arrays (reverse array) (sort array))]))", "  (cond [(empty? array)\
    \ array]\n        [(or (= (length array) 1)\n             (and (= (add1 (length\
    \ array)) (length (sort array))))\n             (= (add1 (length array)) (length\
    \ (sort (reverse array)))))\n         array]\n        [else (cond [(odd? (+ (car\
    \ array) (last array)))\n                     (sort array)]\n                \
    \    [else (sort (reverse array))])]))\n", "  (cond ((empty? array) (list))\n\
    \        ((= (length array) 1) array)\n        ((even? (+ (first array) (last\
    \ array))) (reverse array))\n        (else array)))\n```\n\n```racket\n#lang racket\n",
  "  (cond [(empty? array) '()]\n        [(<= (length array) 1) array]\n        [else\n\
    \         (let ([first (first array)]\n               [last (last array)])\n \
    \          (cond [(odd? (+ first last))\n                  (quicksort array <)]\n\
    \                 [else\n                  (quicksort array >)]))]))\n", "  (if\
    \ (empty? array) (list)\n    (if (even? (+ (first array) (last array)))\n    \
    \    (list-sort (lambda (x y) (> x y)) array)\n        (list-sort (lambda (x y)\
    \ (< x y)) array))))\n", "  (define (sum-all n)\n    (if (null? n)\n        0\n\
    \        (+ (car n) (sum-all (cdr n)))))\n  (define (sort-it array)\n    (if (null?\
    \ array)\n        (list)\n        (append (sort-it (filter (lambda (x) (> x (car\
    \ array))) (cdr array)))\n                (list (car array))\n               \
    \ (sort-it (filter (lambda (x) (<= x (car array))) (cdr array))))))\n  (if (eq?\
    \ 0 (modulo (sum-all array) 2))\n      (sort-it array)\n      (reverse (sort-it\
    \ array))))", "  (cond\n    [(empty? array) (list)]\n    [(= (length array) 1)\
    \ array]\n    [else\n     (let\n         ([fst (first array)]\n          [lst\
    \ (last array)]\n          [ord (if (odd? (+ fst lst))\n                   <\n\
    \                   >)])\n       (reverse (sort ord array)))]))", "  (cond [(empty?\
    \ array) empty]\n        [(= (length array) 1) array]\n        [else (if (odd?\
    \ (+ (first array) (last array)))\n                  (sort < array)\n        \
    \          (sort > array))]))", "  (if (equal? (length array) 0)\n      array\n\
    \      (if (even? (+ (list-ref array 0) (list-ref array (- (length array) 1))))\n\
    \          (sort array >)\n          (sort array <))))", "  (let ([l (length array)])\n\
    \    (cond\n      [(zero? l)\n       (list)]\n      [(one? l)\n       array]\n\
    \      [else\n       (cond\n         [(even? (+ (list-ref array 0) (list-ref array\
    \ (- l 1))))\n          (sort array >)]\n         [else\n          (sort array\
    \ <)])])))", "  (sort (lambda (a b) (if (= (even? (+ (array-ref array 0) (array-ref\
    \ array (- (array-length array) 1)))) #t) (> a b) (< a b))) array))\n", "  (sort-with\
    \ \n   (lambda (a b) \n     (if (or (even? (+ (list-ref array 0) (list-ref array\
    \ (- (length array) 1))))\n             (and (zero? (list-ref array 0)) (zero?\
    \ (list-ref array (- (length array) 1)))))\n         (and (not (zero? a)) (not\
    \ (zero? b)))\n         (< a b)))\n   array))\n", "  (if (= 0 (length array))\n\
    \      (list)\n      (let* ([a (list-ref array 0)]\n             [b (list-ref\
    \ array (- (length array) 1))]\n             [new-array (if (odd? (+ a b))\n \
    \                           (if (equal? (length array) 1)\n                  \
    \              (list a)\n                                (insert-into-sorted-list-in-ascending-order\
    \ b (sort_array (remove array a))))\n                            (if (equal? (length\
    \ array) 1)\n                                (list a)\n                      \
    \          (insert-into-sorted-list-in-descending-order b (sort_array (remove\
    \ array a)))))]\n             [sorted-array new-array])\n        sorted-array)))\n",
  "  (cond [(empty? array)\n         (list)]\n        [(number? (first array))\n \
    \        (cond [(even? (+ (first array) (last array)))\n                (sort\
    \ array >)]\n               [else\n                (sort array <)])]\n       \
    \ [else\n         (sort_array (first array))]))\n", "  (cond\n    [(empty? array)\
    \ (list)]\n    [(empty? (rest array)) array]\n    [else\n     (if (even? (+ (first\
    \ array) (last array)))\n         (let loop ([x (rest array)] [y (last array)])\n\
    \           (if (empty? x)\n               (cons y (list (first array)))\n   \
    \            (loop (rest x) (cons y (cons (first x) empty)))))\n         (let\
    \ loop ([x (rest array)] [y (last array)])\n           (if (empty? x)\n      \
    \         (cons (first array) (list y))\n               (loop (rest x) (cons (first\
    \ x) (cons y empty))))))]))\n", "  (cond\n    [(null? array) '()]\n    [(= 1 (length\
    \ array)) array]\n    [else\n     (let ([odd? (odd? (+ (car array) (last array)))])\n\
    \       (sort (sort-list array) (curryr < odd?)))]))\n", "  (define (sort-helper\
    \ array)\n    (cond ((null? array) array)\n          ((= (length array) 1) array)\n\
    \          (else\n           (if (even? (+ (car array) (cadr array)))\n      \
    \         (sort-helper (append (sort-helper (cdr array)) (list (car array))))\n\
    \               (sort-helper (append (list (car array)) (sort-helper (cdr array))))))))\n\
    \  (sort-helper array))", "  (let ([head (car array)]\n        [tail (cdr array)])\n\
    \    (cond\n      [(null? array) array]\n      [(= (modulo (+ head (car (last\
    \ array))) 2) 0)\n       (reverse (sort array <))]\n      [else (sort array <)])))\n\
    ```\n\n## Explanation\n\nWe first check if the input `array` is empty or only\
    \ a single element. If so we just return it. Then we check if the sum of the first\
    \ and last element of the `array` is even or odd.\n\nIf even, we reverse sort\
    \ the `array` and return it, otherwise just sort the `array` and return it."]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
