name: HumanEval_149_sorted_list_sum
language: rkt
prompt: "#lang racket\n\n;; Write a function that accepts a list of strings as a parameter,\n\
  ;; deletes the strings that have odd lengths from it,\n;; and returns the resulted\
  \ list with a sorted order,\n;; The list is always a list of strings and never a\
  \ list of numbers,\n;; and it may contain duplicates.\n;; The order of the list\
  \ should be ascending by length of each word, and you\n;; should return the list\
  \ sorted by that rule.\n;; If two words have the same length, sort the list alphabetically.\n\
  ;; The function should return a list of strings in sorted order.\n;; You may assume\
  \ that all words will have the same length.\n;; For example:\n;; >>> (list_sort\
  \ (list \"aa\" \"a\" \"aaa\"))\n;; (list \"aa\")\n;; >>> (list_sort (list \"ab\"\
  \ \"a\" \"aaa\" \"cd\"))\n;; (list \"ab\" \"cd\")\n(define (sorted_list_sum lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sorted_list_sum))\n\
  \    (check-equal? (candidate (list \"aa\" \"a\" \"aaa\")) (list \"aa\"))\n    (check-equal?\
  \ (candidate (list \"school\" \"AI\" \"asdf\" \"b\")) (list \"AI\" \"asdf\" \"school\"\
  ))\n    (check-equal? (candidate (list \"d\" \"b\" \"c\" \"a\")) (list ))\n    (check-equal?\
  \ (candidate (list \"d\" \"dcba\" \"abcd\" \"a\")) (list \"abcd\" \"dcba\"))\n \
  \   (check-equal? (candidate (list \"AI\" \"ai\" \"au\")) (list \"AI\" \"ai\" \"\
  au\"))\n    (check-equal? (candidate (list \"a\" \"b\" \"b\" \"c\" \"c\" \"a\"))\
  \ (list ))\n    (check-equal? (candidate (list \"aaaa\" \"bbbb\" \"dd\" \"cc\"))\
  \ (list \"cc\" \"dd\" \"aaaa\" \"bbbb\"))\n))\n\n(test-humaneval)"
completions: ["  (sort lst\n        (lambda (x y)\n          (if (= (string-length\
    \ x) (string-length y))\n              (string<? x y)\n              (< (string-length\
    \ x) (string-length y))))))\n", "  (apply + (sort lst #:key #'number->string)))\n",
  "  (sort lst (lambda (x y) (< (string-length x) (string-length y)))))\n", "  (cond\
    \ ((null? lst) 0)\n        ((null? (cdr lst)) (car lst))\n        (else (+ (car\
    \ lst) (sorted_list_sum (cdr lst))))))\n", "  (sort lst string<?))\n", "  (sort\
    \ (filter even? lst) <))\n", "  (cond\n    [(empty? lst) empty]\n    [(empty?\
    \ (rest lst)) (list (first lst))]\n    [else (append (list (first lst)) (sorted_list_sum\
    \ (rest lst)))]))\n", "  (if (null? lst)\n      '()\n      (append (list_sort\
    \ (list (car lst) (cadr lst)))\n              (sorted_list_sum (cddr lst)))))\n",
  "  (sort lst\n        (lambda (x y)\n          (and (< (string-length x) (string-length\
    \ y))\n               (string<? x y)))))\n", "  (cond [(null? lst) empty]\n  \
    \      [else (sort (filter odd? lst))]))\n", "  (cond\n    [(null? lst) (values\
    \ \"\") (values \"\")]\n    [(even? (string-length (car lst)))\n     (let-values\n\
    \         ([(odd-strings even-strings) (sorted_list_sum (cdr lst))])\n       (values\
    \ (cons (car lst) even-strings) odd-strings))]\n    [else\n     (let-values\n\
    \         ([(odd-strings even-strings) (sorted_list_sum (cdr lst))])\n       (values\
    \ odd-strings (cons (car lst) even-strings)))]))", "  (sort lst string<?))\n",
  "  (sort lst <))\n", "  (let loop ([ls lst] [rt '()])\n    (if (null? ls)\n    \
    \    rt\n        (loop (cdr ls) (cons (car ls) rt)))))\n", "    (match lst\n \
    \           [() 0]\n            [(cons hd tl) (+ hd (sorted_list_sum tl))]))",
  "  (define (r_list_sum lst accu)\n    (if (null? lst)\n        accu\n        (r_list_sum\
    \ (cdr lst) (+ (car lst) accu))))\n  (r_list_sum lst 0))\n", "  (if (null? lst)\n\
    \      '()\n      (sort (remodds lst)\n            (lambda (word1 word2)\n   \
    \           (cond ((= (string-length word1) (string-length word2))\n         \
    \            (string<? word1 word2))\n                    (else (< (string-length\
    \ word1) (string-length word2))))))))\n", "  (sort lst\n        (lambda (x y)\n\
    \          (if (= (string-length x) (string-length y))\n              (string<?\
    \ x y)\n              (< (string-length x) (string-length y))))))", "  (if (or\
    \ (equal? lst '()) (equal? (cdr lst) '()))\n      lst\n      (if (&lt; (string-length\
    \ (car lst)) (string-length (cadr lst)))\n          (list (car lst) (cadr lst))\n\
    \          (cons (cadr lst) (list (car lst))))))\n", "  (cond\n    [(null? lst)\
    \ (display \" \")]\n    [(> (length (first lst)) 1)\n     (display (first lst))\n\
    \     (sorted_list_sum (rest lst))]\n    [else (sorted_list_sum (rest lst))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
