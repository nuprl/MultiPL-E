name: HumanEval_31_is_prime
language: rkt
prompt: "#lang racket\n\n;; Return true if a given number is prime, and false otherwise.\n\
  ;; >>> (is_prime 6)\n;; #f\n;; >>> (is_prime 101)\n;; #t\n;; >>> (is_prime 11)\n\
  ;; #t\n;; >>> (is_prime 13441)\n;; #t\n;; >>> (is_prime 61)\n;; #t\n;; >>> (is_prime\
  \ 4)\n;; #f\n;; >>> (is_prime 1)\n;; #f\n(define (is_prime n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_prime))\n\
  \    (check-equal? (candidate 6) #f)\n    (check-equal? (candidate 101) #t)\n  \
  \  (check-equal? (candidate 11) #t)\n    (check-equal? (candidate 13441) #t)\n \
  \   (check-equal? (candidate 61) #t)\n    (check-equal? (candidate 4) #f)\n    (check-equal?\
  \ (candidate 1) #f)\n    (check-equal? (candidate 5) #t)\n    (check-equal? (candidate\
  \ 11) #t)\n    (check-equal? (candidate 17) #t)\n    (check-equal? (candidate 85)\
  \ #f)\n    (check-equal? (candidate 77) #f)\n    (check-equal? (candidate 255379)\
  \ #f)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(= n 1) #f]\n    [(= n 2) #t]\n    [(even? n) #f]\n \
    \   [else (for/and ([factor (in-range 3 (+ 1 (sqrt n)) 2)])\n                (not\
    \ (= 0 (modulo n factor))))]))\n", "  (or (= n 2) (= n 3)\n      (and (< n 2)\
    \ (= n 1)\n           (and (> n 3) (= (% n 2) 1)\n                (and (> n 5)\
    \ (= (% n 3) 1)\n                     (and (> n 7) (= (% n 5) 1)\n           \
    \               (and (> n 11) (= (% n 7) 1)\n                               (and\
    \ (> n 13) (= (% n 11) 1)\n                                    (and (> n 17) (=\
    \ (% n 13) 1)\n                                         (and (> n 19) (= (% n\
    \ 17) 1)\n                                              (and (> n 23) (= (% n\
    \ 19) 1)\n                                                   (and (> n 29) (=\
    \ (% n 23) 1)\n                                                        (and (>\
    \ n 31) (= (% n 29) 1)\n                                                     \
    \        (and (> n 37) (= (% n 31) 1)\n                                      \
    \                            (and (> n 41) (= (% n 37) 1)\n                  \
    \                                                     (and (> n 43) (= (% n 41)\
    \ 1)\n                                                                       \
    \     (and (> n 47) (= (% n 43) 1)\n                                         \
    \                                        (and (> n 53) (= (% n 47) 1)\n      \
    \                                                                            \
    \    (and (> n 59) (= (% n 53) 1)\n                                          \
    \                                                 (and (> n 61) (= (% n 59) 1)\n\
    \                                                                            \
    \                    (and (> n 67) (= (% n 61) 1)\n                          \
    \                                                                           (and\
    \ (> n 71) (= (% n 67) 1)\n                                                  \
    \                                                        (and (> n 73) (= (% n\
    \ 71) 1)\n                                                                   \
    \                                            (and (> n 79) (= (% n 73) 1)\n  \
    \                                                                            \
    \                                      (and (> n 83) (= (% n 79) 1)\n        \
    \                                                                            \
    \                                     (and (> n 89) (= (% n 83) 1)\n         \
    \                                                                            \
    \                                         (and (> n 97) (= (% n 89) 1)\n     \
    \                                                                            \
    \                                                  (and (> n 101) (= (% n 97)\
    \ 1)\n                                                                       \
    \                                                                 (and (> n 103)\
    \ (= (% n 101) 1)\n                                                          \
    \                                      ", "  (define (prime? n i)\n    (if (=\
    \ n i)\n        #t\n        (if (= 0 (modulo n i))\n            #f\n         \
    \   (prime? n (+ i 1)))))\n  (prime? n 2))\n", "  (and (> n 1)\n       (not (or\
    \ (= (remainder n 2) 0)\n                (= (remainder n 3) 0)\n             \
    \   (= (remainder n 5) 0)\n                (= (remainder n 7) 0)\n           \
    \     (= (remainder n 11) 0)\n                (= (remainder n 13) 0)\n       \
    \         (= (remainder n 17) 0)\n                (= (remainder n 19) 0)\n   \
    \             (= (remainder n 23) 0)\n                (= (remainder n 29) 0)\n\
    \                (= (remainder n 31) 0)\n                (= (remainder n 37) 0)\n\
    \                (= (remainder n 41) 0)\n                (= (remainder n 43) 0)\n\
    \                (= (remainder n 47) 0)\n                (= (remainder n 53) 0)\n\
    \                (= (remainder n 59) 0)\n                (= (remainder n 61) 0)\n\
    \                (= (remainder n 67) 0)\n                (= (remainder n 71) 0)\n\
    \                (= (remainder n 73) 0)\n                (= (remainder n 79) 0)\n\
    \                (= (remainder n 83) 0)\n                (= (remainder n 89) 0)\n\
    \                (= (remainder n 97) 0)\n                (= (remainder n 101)\
    \ 0)\n                (= (remainder n 103) 0)\n                (= (remainder n\
    \ 107) 0)\n                (= (remainder n 109) 0)\n                (= (remainder\
    \ n 113) 0)\n                (= (remainder n 127) 0)\n                (= (remainder\
    \ n 131) 0)\n                (= (remainder n 137) 0)\n                (= (remainder\
    \ n 139) 0)\n                (= (remainder n 149) 0)\n                (= (remainder\
    \ n 151) 0)\n                (= (remainder n 157) 0)\n                (= (remainder\
    \ n 163) 0)\n                (= (remainder n 167) 0)\n                (= (remainder\
    \ n 173) 0)\n                (= (remainder n 179) 0)\n                (= (remainder\
    \ n", "  (define (iter p)\n    (if (= p n)\n        #t\n        (if (= 0 (modulo\
    \ n p))\n            #f\n            (iter (+ p 1)))))\n  (iter 2))\n", "  (if\
    \ (= n 1)\n      #f\n      (if (= n 2)\n          #t\n          (if (even? n)\n\
    \              #f\n              (let loop ((i 3))\n                (if (= i (*\
    \ i i))\n                    #t\n                    (if (= (remainder n i) 0)\n\
    \                        #f\n                        (loop (+ i 2)))))))))\n",
  "  (define (prime? n i)\n    (if (> (* i i) n) #t\n        (if (zero? (modulo n\
    \ i)) #f\n            (prime? n (+ i 1)))))\n  (if (zero? n) #f\n      (prime?\
    \ n 2)))\n", "  (cond ((= n 1) #f)\n        ((= n 2) #t)\n        ((= (remainder\
    \ n 2) 0) #f)\n        (else\n         (let loop ((divisor 3))\n           (cond\
    \ ((= (remainder n divisor) 0) #f)\n                 ((= (remainder (+ divisor\
    \ 2) 6) 0) (loop (+ divisor 2)))\n                 ((= (remainder (- divisor 2)\
    \ 6) 0) (loop (- divisor 2)))\n                 (else #t))))))\n", "  (define\
    \ (helper i)\n    (if (= n i)\n        #t\n        (if (= (remainder n i) 0)\n\
    \            #f\n            (helper (+ i 1)))))\n  (if (<= n 1)\n      #f\n \
    \     (helper 2)))\n", "  (define (divides-by-rec i)\n    (if (= (modulo n i)\
    \ 0)\n        #t\n        (if (> i (/ n 2))\n            #f\n            (divides-by-rec\
    \ (+ i 1)))))\n  (if (= n 1)\n      #f\n      (if (= n 2)\n          #t\n    \
    \      (if (= n 3)\n              #t\n              (if (= n 5)\n            \
    \      #t\n                  (if (= n 7)\n                      #t\n         \
    \             (if (= n 11)\n                          #t\n                   \
    \       (if (= n 13)\n                              #t\n                     \
    \         (if (= n 17)\n                                  #t\n               \
    \                   (if (= n 19)\n                                      #t\n \
    \                                     (if (= n 23)\n                         \
    \                 #t\n                                          (if (= n 29)\n\
    \                                              #t\n                          \
    \                    (if (= n 31)\n                                          \
    \        #t\n                                                  (if (= n 37)\n\
    \                                                      #t\n                  \
    \                                    (if (= n 41)\n                          \
    \                                #t\n                                        \
    \                  (if (= n 43)\n                                            \
    \                  #t\n                                                      \
    \        (if (= n 47)\n                                                      \
    \            #t\n                                                            \
    \      (if (= n 53)\n                                                        \
    \              #t\n                                                          \
    \            (if (= n 59)\n                                                  \
    \                        #t\n                                                \
    \                          (if (= n 61)\n                                    \
    \                                          #t\n                              \
    \                                                (if (= n 67)\n              \
    \                                                                    #t\n    \
    \                                                                            \
    \  (if (= n 71)\n                                                            \
    \                          #t\n                                              \
    \                                        (if (= n 73)\n                      \
    \                                                                    #t\n    \
    \                                                                            \
    \          (if (= n 79)\n                                                    \
    \                                          #t\n                              \
    \                                                                (if (= n 83)\n\
    \                                                                            \
    \                      #t\n                                                  \
    \                                                (if (= n 89)\n              \
    \                                                                            \
    \            #t\n                                                            \
    \                                          (if (= n 97)\n                    \
    \                                                                            \
    \          #t\n                                                              \
    \                                            (if (= n 101)\n                ",
  "  (if (and (positive? n) (> n 1))\n      (is_prime-helper n 2)\n      #f))\n",
  "  (and (> n 1)\n       (not (null? (keep (lambda (x) (not (zero? (modulo n x))))\n\
    \                         (range 2 n))))))\n", "  (cond\n    [(zero? n) false]\n\
    \    [(zero? (remainder n 2)) false]\n    [else\n     (cond\n       [(zero? (remainder\
    \ n 3)) false]\n       [else\n        (let loop ((i 5))\n          (if (> (* i\
    \ i) n)\n              true\n              (if (or (zero? (remainder n i))\n \
    \                     (zero? (remainder n (+ i 2))))\n                  false\n\
    \                  (loop (+ i 6)))))])]))\n", "  (if (= n 1) #f \n      (is_prime_helper\
    \ n 2)))\n", "  (if (= n 1) #f\n      (not (any (curryr < n) (range 2 n)))))\n",
  "  (if (< n 2)\n      #f\n      (if (for/and ([x (in-range 2 n)])\n            \
    \    (not (= (remainder n x) 0)))\n          #t\n          #f)))\n", "  (cond\n\
    \    [(< n 2) #f]\n    [(= n 2) #t]\n    [(even? n) #f]\n    [else\n     (let\
    \ loop ([i 3])\n       (cond\n         [(>= i n) #t]\n         [(= (remainder\
    \ n i) 0) #f]\n         [else (loop (+ i 2))]))]))\n", "  (is_prime-helper n 2))\n",
  "  (if (= n 2)\n      #t\n      (if (even? n)\n          #f\n          (let loop\
    \ ((k 3))\n            (if (= n k)\n                #t\n                (if (integer?\
    \ (/ n k))\n                    #f\n                    (loop (+ k 2))))))))\n",
  "  (if (= n 1)\n      #f\n      (let ((upper-bound (quotient n 2)))\n        (let\
    \ loop ((i 2))\n          (if (<= i upper-bound)\n              (if (= (remainder\
    \ n i) 0)\n                  #f\n                  (loop (+ i 1)))\n         \
    \     #t)))))\n", "  (define (is_prime_helper acc test)\n    (if (> test n)\n\
    \        #t\n        (if (= (modulo n test) 0)\n            #f\n            (is_prime_helper\
    \ (+ acc 1) (+ test 1)))))\n  (if (= n 1)\n      #f\n      (is_prime_helper 1\
    \ 2)))\n", "  (define (iter x)\n    (cond [(> n x) #t]\n          [(divides? x\
    \ n) #f]\n          [else (iter (+ x 1))]))\n  (iter 2))\n", "  (define (is_prime_helper\
    \ x)\n    (cond [(= x 1) true]\n          [(> (remainder n x) 0) (is_prime_helper\
    \ (- x 1))]\n          [else false]))\n  (is_prime_helper (- n 1)))\n", "  (define\
    \ (odd-primes n-minus-1 primes)\n    (cond\n      [(empty? primes) true]\n   \
    \   [(modulo n-minus-1 (first primes)) (odd-primes (- n-minus-1 2) (rest primes))]\n\
    \      [else false]))\n  (cond\n    [(< n 2) false]\n    [(= n 2) true]\n    [(=\
    \ (modulo n 2) 0) false]\n    [else (odd-primes (- n 1) (build-list (/ n 2) odd?))]))\n",
  "  (if (= n 1)\n      #f\n      (if (= n 2)\n          #t\n          (if (or (=\
    \ (remainder n 2) 0)\n                  (= (remainder n 3) 0)\n              \
    \    (= (remainder n 5) 0)\n                  (= (remainder n 7) 0))\n       \
    \       #f\n              (let loop ((d (+ 2 (+ (quotient n 8) 1))))\n       \
    \         (if (< d n)\n                    (if (= (remainder n d) 0)\n       \
    \                 #f\n                        (loop (+ d 4)))\n              \
    \      #t))))))\n", "  (if (and (> n 1)\n           (not (even? n)))\n      (define\
    \ (is_prime n p)\n        (if (or (= n p)\n                (= n 1))\n        \
    \    #t\n            (if (= (remainder n p) 0)\n                #f\n         \
    \       (is_prime n (+ p 2)))))\n      (is_prime n 3)))\n```\n\n### Problem 7\n\
    ```#lang racket\n", "  (let loop ((i 2))\n    (if (= n i) #t\n        (if (zero?\
    \ (modulo n i)) #f\n            (loop (+ i 1))))))\n", "  (if (< n 2)\n      #f\n\
    \      (is_prime-helper n 2)))\n", "  (define (divides a b)\n    (= (remainder\
    \ a b) 0))\n  (define (loop divisor)\n    (cond ((<= divisor (sqrt n))\n     \
    \      (if (divides n divisor)\n               #f\n               (loop (+ divisor\
    \ 1))))\n          (else #t)))\n  (if (= n 1)\n      #f\n      (loop 2)))\n",
  "  (cond\n    ((= n 1) #f)\n    ((= n 2) #t)\n    ((even? n) #f)\n    (else\n  \
    \   (for/and ([num (in-range (sub1 n) 2 -1)])\n       (not (zero? (modulo n num)))))))\n\
    ```\n\n```racket\n#lang racket\n", "  (define (prime-helper i)\n    (if (> i (sqrt\
    \ n))\n        #t\n        (if (zero? (modulo n i))\n            #f\n        \
    \    (prime-helper (+ i 1)))))\n  (if (= n 1)\n      #f\n      (prime-helper 2)))\n",
  "  (define (iter x acc)\n    (cond ((= x n) true)\n          ((= n (* acc acc))\
    \ false)\n          ((or (= n (* acc (modulo n acc)))\n               (= n (*\
    \ acc (modulo n acc) (modulo n acc)))) false)\n          (else (iter (+ x 1) (modulo\
    \ n x)))))\n  (iter 1 2))\n", "  (define (process num div)\n    (if (= num 1)\n\
    \        #f\n        (if (= n 1)\n            #f\n            (if (= n num)\n\
    \                #t\n                (if (= (modulo n div) 0)\n              \
    \      #f\n                    (process num (+ div 1)))))))\n  (process n 2))\n",
  "  (if (= n 2)\n      #t\n      (if (= n 1)\n          #f\n          (if (even?\
    \ n)\n              #f\n              (let* ((n_minus_one (- n 1))\n         \
    \            (n_minus_two (- n 2))\n                     (n_range (range n_minus_two\
    \ 2 -1)))\n                (map (lambda (i)\n                       (if (= (modulo\
    \ n i) 0)\n                           #f\n                           #t))\n  \
    \                   n_range))))))\n", "  (if (< n 2)\n      #f\n      (let loop\
    \ ((d 2))\n        (if (< d n)\n            (if (zero? (modulo n d))\n       \
    \         #f\n                (loop (+ d 1)))\n            #t))))\n", "  (cond\n\
    \    [(= n 1) #f]\n    [(even? n) #f]\n    [(= n 2) #t]\n    [(= n 3) #t]\n  \
    \  [else (is_prime_iter n (/ n 2))]))\n", "  (if (= n 1)\n      #f\n      (if\
    \ (= n 2)\n          #t\n          (is_prime-helper 3 n))))\n", "  (cond\n   \
    \ [(= n 1) false]\n    [(or (= n 0) (= n 2)) true]\n    [(integer? (sqrt n)) false]\n\
    \    [else\n     (define (div n d)\n       (if (= n d)\n           true\n    \
    \       (if (integer? (/ n d))\n               false\n               (div n (+\
    \ d 1)))))\n     (div n 2)]))\n", "  (define (check_divisors i)\n    (if (and\
    \ (> (* i i) n) (< (* i i) (* n n)))\n        #t\n        (if (and (< (* i i)\
    \ n) (< (* i i) (* n n)))\n            (check_divisors (+ i 1))\n            #f)))\n\
    \  (check_divisors 2))\n", "  (is_prime_divisible? 2 n))\n", "  (cond\n    [(=\
    \ n 1) #f]\n    [(= n 2) #t]\n    [(= (remainder n 2) 0) #f]\n    [else\n    \
    \ (for/and ([x (in-range 3 (+ (sqrt n) 1) 2)])\n       (not (= (remainder n x)\
    \ 0)))]))\n", "  (cond ((= n 1) #f)\n        ((= n 2) #t)\n        ((= n 3) #t)\n\
    \        ((even? n) #f)\n        (else\n         (let loop ((i 3))\n         \
    \  (cond ((&gt; i (sqrt n)) #t)\n                 ((divides? i n) #f)\n      \
    \           (else (loop (+ i 2))))))))\n", "  (is_prime_helper n 2))\n", "  (if\
    \ (= n 1) #f\n      (if (= n 2) #t\n          (if (= (remainder n 2) 0) #f\n \
    \             (let loop ((d 3))\n                (if (< (* d d) n)\n         \
    \           (if (= (remainder n d) 0) #f\n                        (loop (+ d 2)))\n\
    \                    #t))))))\n", "  (define (helper a b)\n    (cond\n      [(=\
    \ a b) #t]\n      [(zero? (modulo n a)) #f]\n      [else (helper (+ a 1) b)]))\n\
    \  (if (or (= n 1) (= n 0))\n      #f\n      (helper 2 n)))\n", "  (define (helper\
    \ m)\n    (cond\n      ((= m n) #t)\n      ((= (% n m) 0) #f)\n      (else (helper\
    \ (+ m 1)))))\n  (helper 2))\n", "  (define (no-divisors? n d)\n    (cond ((>\
    \ d (/ n 2)) #t)\n          ((= (modulo n d) 0) #f)\n          (else (no-divisors?\
    \ n (+ d 1)))))\n  (if (= n 1) #f\n      (no-divisors? n 2)))\n", "  (cond\n \
    \   [(= n 1) #f]\n    [(= n 2) #t]\n    [(= (modulo n 2) 0) #f]\n    [else (any\
    \ (lambda (x) (= (modulo n x) 0)) (range 3 (+ n 1) 2))]))\n", "  (cond ((= n 1)\
    \ #f)\n        ((= n 2) #t)\n        ((even? n) #f)\n        (else (odd-prime-check\
    \ n (/ n 2)))))\n", "  (define (is_prime n d)\n    (if (= d 1) #t\n        (if\
    \ (= (remainder n d) 0) #f\n            (is_prime n (- d 1)))))\n  (if (= n 1)\
    \ #f\n      (is_prime n (/ n 2))))\n", "  (or (= n 2)\n      (define (loop i)\n\
    \        (cond ((= i n) #t)\n              ((= (remainder n i) 0) #f)\n      \
    \        (else (loop (+ i 1)))))\n      (loop 2)))\n", "  (define (is_prime-helper\
    \ n i)\n    (cond ((= i 1) #t)\n          ((= (modulo n i) 0) #f)\n          (else\
    \ (is_prime-helper n (- i 1)))))\n  (if (<= n 1)\n      #f\n      (is_prime-helper\
    \ n (exact-floor (/ n 2)))))\n", "  (define (helper i)\n    (cond ((= i n) #t)\n\
    \          ((divides? i n) #f)\n          (else (helper (+ i 1)))))\n  (helper\
    \ 2))\n", "  (cond ((= n 1) #f)\n        ((= n 2) #t)\n        ((and (> n 2) (is_prime_recursion\
    \ n (/ n 2) #t)) #t)\n        (else #f)))\n", "  (define (is_divisible x)\n  \
    \  (if (= (remainder n x) 0)\n        true\n        false))\n  (define (is_prime_helper\
    \ x)\n    (if (= n x)\n        false\n        (if (is_divisible x)\n         \
    \   true\n            (is_prime_helper (+ x 1)))))\n  (if (< n 2)\n      false\n\
    \      (is_prime_helper 2)))\n", "  (if (or (= n 1) (= n 4))\n      #f\n     \
    \ (let ([bound (ceiling (sqrt n))])\n        (if (even? n)\n            #f\n \
    \           (for/and ([i (in-range 3 bound 2)])\n              (not (zero? (modulo\
    \ n i))))))))\n", "  (if (< n 2)\n      #f\n      (if (is_prime_aux n 2)\n   \
    \       #t\n          #f)))\n", "  (if (= n 1)\n      #f\n      (every (lambda\
    \ (x)\n               (not (= (remainder n x) 0)))\n             (iota 2 (- n\
    \ 1)))))\n", "  (cond [(= n 1) #f]\n        [(= n 2) #t]\n        [(= (remainder\
    \ n 2) 0) #f]\n        [else (for/and ([k (in-range 3 (+ 1 (floor (sqrt n))))])\n\
    \                  (not (= (remainder n k) 0)))]))\n", "  (define (is_prime_helper\
    \ candidate divisor)\n    (cond\n      [(> divisor (/ candidate 2)) #t]\n    \
    \  [(= (modulo candidate divisor) 0) #f]\n      [else (is_prime_helper candidate\
    \ (+ divisor 1))]))\n  (if (<= n 1)\n      #f\n      (is_prime_helper n 2)))\n",
  "  (if (= n 1)\n      #f\n      (and (> n 1)\n           (not (any (lambda (x) (zero?\
    \ (modulo n x)))\n                    (range 2 (sub1 n)))))))\n", "  (if (= n\
    \ 2)\n      #t\n      (if (= n 3)\n          #t\n          (if (= n 1)\n     \
    \         #f\n              (is_prime-helper 2 n)))))\n", "  (is_prime_acc 2 n))\n",
  "  (define (odds up-to)\n    (if (> up-to 2)\n        (cons up-to (odds (- up-to\
    \ 2)))\n        '()))\n  (define (divides? a b)\n    (= (remainder b a) 0))\n\
    \  (define (prime-check divs)\n    (cond\n      ((null? divs) #t)\n      ((<=\
    \ (car divs) (sqrt n))\n       (if (divides? (car divs) n)\n           #f\n  \
    \         (prime-check (cdr divs))))\n      (else #t)))\n  (cond\n    ((= n 2)\
    \ #t)\n    ((or (< n 2) (even? n)) #f)\n    (else (prime-check (odds n)))))\n",
  "  (if (< n 2)\n      #f\n      (let loop ((i 2))\n        (if (< i n)\n       \
    \     (if (zero? (modulo n i))\n                #f\n                (loop (+ i\
    \ 1)))\n            #t))))\n", "  (define (is_prime-helper cur-val)\n    (cond\
    \ ((> (* cur-val cur-val) n) true)\n          ((= (modulo n cur-val) 0) false)\n\
    \          (else (is_prime-helper (+ cur-val 1)))))\n  (if (= n 1) false (is_prime-helper\
    \ 2)))\n", "  (for/or ([d (in-range 2 (- n 1))])\n    (zero? (modulo n d))))\n",
  "  (if (= n 1)\n      #f\n      (if (= n 2)\n          #t\n          (if (zero?\
    \ (remainder n 2))\n              #f\n              (let ((i 3))\n           \
    \     (let loop ((i i))\n                  (if (<= i (sqrt n))\n             \
    \         (if (zero? (remainder n i))\n                          #f\n        \
    \                  (loop (+ i 2)))\n                      #t)))))))\n", "  (local\
    \ ((define (check i)\n            (if (= i n)\n                #t\n          \
    \      (if (= (remainder n i) 0)\n                    #f\n                   \
    \ (check (+ i 1))))))\n    (check 2)))\n```\n\n```scheme\n#lang racket\n", " \
    \ (let* ([i (exact-ceiling (/ n 2))]\n         [is-prime? (for/or ([j (in-range\
    \ 1 i)])\n                       (zero? (remainder n j)))])\n    (not is-prime?)))\n",
  "  (if (< n 2)\n      #f\n      (let divide (n 2)\n        (if (zero? (modulo n\
    \ divide))\n            #f\n            (if (= divide n)\n                #t\n\
    \                (divide (+ divide 1)))))))\n", "  (if (< n 2)\n      #f\n   \
    \   (not (any (lambda (x) (= (remainder n x) 0))\n                (range 2 (sqrt\
    \ n) 1)))))\n", "  (let ([i (sqrt n)])\n    (or (= i 1)\n        (let loop ([j\
    \ (floor i)])\n          (if (= j 1)\n              #t\n              (if (integer?\
    \ (/ n j))\n                  #f\n                  (loop (- j 1))))))))\n", " \
    \ (define (is_divisible? a b)\n    (= (remainder a b) 0))\n  (define (iter x n)\n\
    \    (cond ((< n x) #t)\n          ((is_divisible? n x) #f)\n          (else (iter\
    \ (+ x 1) n))))\n  (cond ((= n 1) #f)\n        ((= n 2) #t)\n        (else (iter\
    \ 2 n))))\n", "  (define (is_divisor d)\n    (= (remainder n d) 0))\n  (define\
    \ (divisors n)\n    (cons 1 (for/list ([i (in-range 2 (sqrt n))])\n          \
    \      (list i (if (is_divisor i) (/ n i) 0)))))\n  (if (= n 1) #f\n      (if\
    \ (find (compose is_divisor sqrt) (divisors n)) #f #t)))\n", "  (if (= n 1)\n\
    \      #f\n      (define (divides? n x)\n        (= (remainder x n) 0))\n    \
    \  (define (find-divisor n x)\n        (if (= x n)\n            #f\n         \
    \   (or (divides? n x)\n                (find-divisor n (+ x 1)))))\n      (not\
    \ (find-divisor n 2))))\n", "  (define (is_prime_help n sqrt_n)\n    (cond\n \
    \     [(= n 1) #f]\n      [(= n 2) #t]\n      [(= n 3) #t]\n      [(odd? n)\n\
    \       (if (zero? (remainder n 3))\n           #f\n           (is_prime_help\
    \ n (floor (sqrt (sub1 n)) 3)))]\n      [else #f]))\n  (is_prime_help n (floor\
    \ (sqrt n) 3)))\n", "  (define (is_divisible a b)\n    (= (remainder a b) 0))\n\
    \  (define (prime-test k)\n    (cond ((= k n) #t)\n          ((is_divisible n\
    \ k) #f)\n          (else (prime-test (+ k 1)))))\n  (if (<= n 1)\n      #f\n\
    \      (prime-test 2)))\n", "  (if (not (integer? n))\n      (error \"This function\
    \ requires an integer argument, you gave: ~a\" n)\n      (let ([divisors (range\
    \ 1 (add1 (quotient n 2)))])\n        (every (lambda (divisor) (not (= 0 (remainder\
    \ n divisor)))) divisors))))\n", "  (cond\n    [(= n 1) #f]\n    [(= n 2) #t]\n\
    \    [(= n 3) #t]\n    [(= n 4) #f]\n    [(= n 5) #t]\n    [(= n 6) #f]\n    [(=\
    \ n 7) #t]\n    [(= n 8) #f]\n    [(= n 9) #f]\n    [(= n 10) #f]\n    [(= n 11)\
    \ #t]\n    [(= n 12) #f]\n    [(= n 13) #t]\n    [(= n 14) #f]\n    [(= n 15)\
    \ #f]\n    [(= n 16) #f]\n    [(= n 17) #t]\n    [(= n 18) #f]\n    [(= n 19)\
    \ #t]\n    [(= n 20) #f]\n    [(= n 21) #f]\n    [(= n 22) #f]\n    [(= n 23)\
    \ #t]\n    [(= n 24) #f]\n    [(= n 25) #f]\n    [(= n 26) #f]\n    [(= n 27)\
    \ #f]\n    [(= n 28) #f]\n    [(= n 29) #t]\n    [(= n 30) #f]\n    [(= n 31)\
    \ #t]\n    [(= n 32) #f]\n    [(= n 33) #f]\n    [(= n 34) #f]\n    [(= n 35)\
    \ #f]\n    [(= n 36) #f]\n    [(= n 37) #t]\n    [(= n 38) #f]\n    [(= n 39)\
    \ #f]\n    [(= n 40) #f]\n    [(= n 41) #t]\n    [(= n 42) #f]\n    [(= n 43)\
    \ #t]\n    [(= n 44) #f]\n    [(= n 45) #f]\n    [(= n 46) #f]\n    [(= n 47)\
    \ #t]\n    [(= n 48) #f]\n    [(= n 49) #f]\n    [(= n 50) #f]\n    [(= n 51)\
    \ #", "  (cond [(<= n 1) #f]\n        [(= n 2) #t]\n        [(= (remainder n 2)\
    \ 0) #f]\n        [else (is_prime-helper n 3)]))\n", "  ;; Return true if n is\
    \ prime and false otherwise.\n  (define (__check_for_factors n divisor)\n    (cond\
    \ ((= n 1) (error \"1 is not prime.\"))\n          ((= n divisor) #t)\n      \
    \    ((= 0 (modulo n divisor)) #f)\n          (else (__check_for_factors n (+\
    \ divisor 1)))))\n  (__check_for_factors n 2))\n", "  (if (or (= n 1) (= n 4))\n\
    \      #f\n      (every (lambda (m)\n               (not (= (remainder n m) 0)))\n\
    \             (iota 2 (- n 1)))))\n", "  (if (= n 1)\n      #f\n      (if (= n\
    \ 2)\n          #t\n          (for/and ([k (in-range 2 n)])\n            (not\
    \ (= (remainder n k) 0))))))\n", "  (cond\n    [(= n 1) #f]\n    [(= n 2) #t]\n\
    \    [(even? n) #f]\n    [else (is_prime? n 3)]))\n", "  (define (is_divisor d)\n\
    \    (= (remainder n d) 0))\n  (if (<= n 1)\n      #f\n      (not (is_divisor\
    \ 2))))\n", "  (if (< n 2)\n      #f\n      (define (is_prime-helper n i)\n  \
    \      (if (<= i 1)\n            #t\n            (if (zero? (modulo n i))\n  \
    \              #f\n                (is_prime-helper n (- i 1)))))\n      (is_prime-helper\
    \ n (floor (/ n 2)))))\n", "  (if (< n 2) #f\n      (cond\n        ((= n 2) #t)\n\
    \        ((= n 3) #t)\n        ((= n 5) #t)\n        ((= n 7) #t)\n        ((or\
    \ (= (remainder n 2) 0)\n             (= (remainder n 3) 0)\n             (= (remainder\
    \ n 5) 0)\n             (= (remainder n 7) 0)) #f)\n        (else\n         (let\
    \ loop ((i 9) (w 3))\n           (if (< (* i i) n)\n               (if (or (=\
    \ (remainder n i) 0)\n                       (= (remainder n (+ i w)) 0)\n   \
    \                    (= (remainder n (- i w)) 0))\n                   #f\n   \
    \                (loop (+ i w) (+ w 2)))\n               #t))))))\n", "  (let\
    \ ((cur 2))\n    (define (check)\n      (if (= cur n) #t\n        (if (zero? (modulo\
    \ n cur)) #f\n          (begin (set! cur (+ cur 1)) (check)))))\n    (check)))\n",
  "  (is_prime_helper n 2))\n", "  (if (< n 2)\n      #f\n      (if (= n 2)\n    \
    \      #t\n          (if (or (even? n) (divides? n 5))\n              #f\n   \
    \           (if (or (divides? n 3) (divides? n 7))\n                  #t\n   \
    \               (prime-helper 11 (sqrt n) n))))))\n", "  (define (divides? d n)\n\
    \    (= (remainder n d) 0))\n  (define (ld n)\n    (define (ld-iter d n)\n   \
    \   (cond ((> (square d) n) n)\n            ((divides? d n) d)\n            (else\
    \ (ld-iter (+ d 1) n))))\n    (ld-iter 2 n))\n  (= (ld n) n))\n", "  (for/or ([i\
    \ (in-range 1 (+ n 1))]) (eq? (remainder n i) 0)))\n", "  (and\n   (not (= n 1))\n\
    \   (define (halt i)\n     (cond\n       [(= n i) true]\n       [(= (modulo n\
    \ i) 0) false]\n       [else (halt (+ i 1))]))\n   (halt 2)))\n", "  (define (helper\
    \ i)\n    (if (= i n)\n        #t\n        (if (= (remainder n i) 0)\n       \
    \     #f\n            (helper (+ i 1)))))\n  (helper 2))\n", "  (define (iter\
    \ i)\n    (cond ((= n 1) #f)\n          ((= i n) #t)\n          ((divides? i n)\
    \ #f)\n          (else (iter (+ i 1)))))\n  (iter 2))\n", "  (and (zero? (remainder\
    \ n 2))\n       (if (= n 2)\n           #t\n           (loop ([i 3])\n       \
    \      (if (zero? (remainder n i))\n                 #f\n                 (if\
    \ (< i (floor (/ n 2)))\n                     (loop (+ i 2))\n               \
    \      #t))))))\n", "  (define (helper m)\n    (if (= m 1)\n        #t\n     \
    \   (if (= (remainder n m) 0)\n            #f\n            (helper (- m 1)))))\n\
    \  (helper (exact-floor (/ n 2))))\n", "  (let ([i (add1 (quotient n 2))])\n \
    \   (let loop ([i i])\n      (cond\n        [(zero? (remainder n i)) #f]\n   \
    \     [(zero? (remainder i 2)) (loop (quotient i 2))]\n        [else #t]))))\n",
  "  (if (= n 1)\n      #f\n      (not (any (lambda (x) (zero? (modulo n x)))\n  \
    \              (range 2 n)))))\n", "  (and (> n 1)\n       (not (is_composite\
    \ n))))\n", "  (cond ((= n 1) #f)\n        ((= n 2) #t)\n        ((or (= n 3)\
    \ (= n 5) (= n 7)) #t)\n        ((or (= (modulo n 2) 0)\n             (= (modulo\
    \ n 3) 0)\n             (= (modulo n 5) 0)\n             (= (modulo n 7) 0)) #f)\n\
    \        (else #t)))\n", "  (cond ((< n 0) (error \"n must be non-negative\"))\n\
    \        ((= n 1) #f)\n        ((= n 2) #t)\n        ((and (= (remainder n 2)\
    \ 0) (= n 2)) #t)\n        ((and (= (remainder n 2) 0) (> n 2)) #f)\n        (else\
    \ (is_prime_recursive n 3))))\n", "  (define (check-for-factors m)\n    (cond\
    \ ((= m 1) '())\n          ((= (remainder n m) 0) (cons m (check-for-factors (-\
    \ m 1))))\n          (else (check-for-factors (- m 1)))))\n  (and (= n 1)\n  \
    \     (= (length (check-for-factors (floor (/ n 2)))) 0)))\n", "  (define (iterate\
    \ i)\n    (if (&gt; i (sqrt n)) #t\n        (if (= (modulo n i) 0) #f\n      \
    \      (iterate (+ i 1)))))\n  (if (= n 1) #f\n      (iterate 2)))\n", "  (define\
    \ (helper i)\n    (cond [(= i n) #t]\n          [(= (remainder n i) 0) #f]\n \
    \         [else (helper (+ i 1))]))\n  (if (<= n 1)\n      #f\n      (helper 2)))\n",
  "  (cond ((< n 2) #f)\n        ((= n 2) #t)\n        ((= (remainder n 2) 0) #f)\n\
    \        (else (or (= (remainder n 3) 0)\n                  (is_prime_helper n\
    \ 5)))))\n", "  (if (= n 1)\n      #f\n      (if (= n 2)\n          #t\n     \
    \     (if (even? n)\n              #f\n              (define (not_div_by_odd n\
    \ i)\n                (if (= n i)\n                    #t\n                  \
    \  (if (and (= (remainder n i) 0) (= n i))\n                        #t\n     \
    \                   (not_div_by_odd n (+ i 2)))))\n              (not_div_by_odd\
    \ n 3)))))\n", "  (define (divisible? x y)\n    (= (remainder x y) 0))\n  (define\
    \ (loop i)\n    (cond ((= i n) #t)\n          ((divisible? n i) #f)\n        \
    \  (else (loop (+ i 1)))))\n  (if (= n 1) #f (loop 2)))\n", "  (if (zero? n)\n\
    \      #f\n      (do ((i 2 (+ i 1)))\n          ((> i (sqrt n)) #t)\n        \
    \  (if (zero? (modulo n i))\n              #f))))\n\n", "  (if (= n 1)\n     \
    \ #f\n      (if (= n 2)\n          #t\n          (cond ((= (remainder n 2) 0)\
    \ #f)\n                ((= (remainder n 3) 0) #f)\n                ((= (remainder\
    \ n 5) 0) #f)\n                ((= (remainder n 7) 0) #f)\n                (else\
    \ #t)))))\n", "  (define (helper i)\n    (if (> i (sqrt n))\n        #t\n    \
    \    (if (= (modulo n i) 0)\n            #f\n            (helper (+ i 1)))))\n\
    \  (if (= n 1)\n      #f\n      (helper 2)))\n", "  (if (= n 1)\n      #f\n  \
    \    (is_prime-helper n (/ n 2))))\n", "  (cond [(= n 1) #f]\n        [(= n 2)\
    \ #t]\n        [(even? n) #f]\n        [else\n         (define (helper i)\n  \
    \         (if (= i n)\n               #t\n               (if (zero? (modulo n\
    \ i))\n                   #f\n                   (helper (+ i 1)))))\n       \
    \  (helper 3)]))\n\n", "  (define (helper k)\n    (if (= k 1)\n        #t\n  \
    \      (if (= (remainder n k) 0)\n            #f\n            (helper (- k 1)))))\n\
    \  (helper (- n 1)))\n", "  (not (or (even? n)\n           (member n (list 1 3\
    \ 5 7 9))\n           (any (lambda (x) (zero? (remainder n x)))\n            \
    \    (range 1 (sqrt n) 2)))))\n", "  (if (and (&gt; n 1) (= 1 (gcd n 2))) #t #f))\n",
  "  (is_prime_helper 2 n))\n", "  (if (or (= n 1) (= n 4))\n      #f\n      (define\
    \ (is_prime-help d)\n        (if (= d n)\n            #t\n            (if (and\
    \ (zero? (modulo n d)) (= d 2))\n                #f\n                (is_prime-help\
    \ (+ d 1)))))\n      (is_prime-help 2)))\n", "  (is_prime-helper n 2))\n", " \
    \ ;; Test against all numbers from 2 up to n-1.\n  (for/or ([x (in-range 2 (-\
    \ n 1))])\n    ;; Any number that is evenly divisible into n (a.k.a. the remainder\n\
    \    ;; is 0) is not prime.\n    (zero? (remainder n x))))\n", "  (if (and (integer?\
    \ n) (> n 1))\n      (not (exists (lambda (i) (zero? (modulo n i)))\n        \
    \           (range 2 n)))\n      false))\n\n", "  (and (<= 3 n)\n       (is_prime_helper\
    \ 2 n)))\n", "  (if (= n 1)\n      #f\n      (cond ((= (modulo n 2) 0) #f)\n \
    \           ((= (modulo n 3) 0) #f)\n            ((= (modulo n 5) 0) #f)\n   \
    \         ((= (modulo n 7) 0) #f)\n            (else #t))))\n", "  (for/or ([i\
    \ (in-range 1 (+ n 1))])\n    (not (zero? (modulo n i)))))\n", "  (let ((n-1 (-\
    \ n 1)))\n    (for/and ([i (in-range 2 n-1)]\n              #:when (= 0 (modulo\
    \ n i)))\n      #f)))\n", "  (define (is_divisor-of? divisor)\n    (= (remainder\
    \ n divisor) 0))\n  (define (iter i)\n    (if (< i n)\n        (if (is_divisor-of?\
    \ i)\n            #f\n            (iter (+ i 1)))\n        #t))\n  (if (= n 1)\n\
    \      #f\n      (iter 2)))\n", "  (cond ((< n 2) #f)\n        ((= n 2) #t)\n\
    \        ((= n 3) #t)\n        ((= n 4) #f)\n        ((= n 5) #t)\n        ((=\
    \ n 6) #f)\n        ((= n 7) #t)\n        ((= n 8) #f)\n        ((= n 9) #f)\n\
    \        ((= n 10) #f)\n        ((and (< n (sqrt n))\n              (not (is_prime\
    \ (floor (/ n 2)))))\n         #t)\n        (else #f)))\n", "  (define (is_prime_iter\
    \ i)\n    (cond ((= i n) #t)\n          ((= (% n i) 0) #f)\n          (else (is_prime_iter\
    \ (+ i 1)))))\n  (if (or (= n 1) (= n 0))\n      #f\n      (is_prime_iter 2)))\n",
  "  (cond [(= n 1) #f]\n        [(= n 2) #t]\n        [(= (remainder n 2) 0) #f]\n\
    \        [else (is_prime_helper n 3 (/ n 2))]))\n", "  (define (is_prime? n i)\n\
    \    (if (= i 2)\n        #t\n        (if (= (modulo n i) 0)\n            #f\n\
    \            (is_prime? n (- i 1)))))\n  (if (= n 1)\n      #f\n      (is_prime?\
    \ n (floor (/ n 2)))))\n", "  (define (is_prime-aux n divs)\n    (cond\n     \
    \ [(empty? divs) #t]\n      [(= (remainder n (first divs)) 0) #f]\n      [else\
    \ (is_prime-aux n (rest divs))]))\n  (is_prime-aux n (range 2 (ceiling (sqrt n)))))\n",
  "  (cond [(= n 1) false]\n        [(= n 2) true]\n        [(= (remainder n 2) 0)\
    \ false]\n        [else\n         (and (> n 1)\n              (for/and ([i (in-range\
    \ 3 (ceiling (sqrt n)) 2)])\n                (not (= (remainder n i) 0))))]))\n",
  "  (cond\n    [(= n 1) #f]\n    [(= n 2) #t]\n    [(= n 3) #t]\n    [(= n 4) #f]\n\
    \    [(= n 5) #t]\n    [(= n 6) #f]\n    [(= n 7) #t]\n    [(= n 8) #f]\n    [(=\
    \ n 9) #f]\n    [(= n 10) #f]\n    [(= n 11) #t]\n    [(= n 12) #f]\n    [(= n\
    \ 13) #t]\n    [(= n 14) #f]\n    [(= n 15) #f]\n    [(= n 16) #f]\n    [(= n\
    \ 17) #t]\n    [(= n 18) #f]\n    [(= n 19) #t]\n    [(= n 20) #f]\n    [(= n\
    \ 21) #f]\n    [(= n 22) #f]\n    [(= n 23) #t]\n    [(= n 24) #f]\n    [(= n\
    \ 25) #f]\n    [(= n 26) #f]\n    [(= n 27) #f]\n    [(= n 28) #f]\n    [(= n\
    \ 29) #t]\n    [(= n 30) #f]\n    [(= n 31) #t]\n    [(= n 32) #f]\n    [(= n\
    \ 33) #f]\n    [(= n 34) #f]\n    [(= n 35) #f]\n    [(= n 36) #f]\n    [(= n\
    \ 37) #t]\n    [(= n 38) #f]\n    [(= n 39) #f]\n    [(= n 40) #f]\n    [(= n\
    \ 41) #t]\n    [(= n 42) #f]\n    [(= n 43) #t]\n    [(= n 44) #f]\n    [(= n\
    \ 45) #f]\n    [(= n 46) #f]\n    [(= n 47) #t]\n    [(= n 48) #f]\n    [(= n\
    \ 49) #f]\n    [(= n 50) #f]\n    [(= n 51) #", "  (cond\n    [(= n 2) #t]\n \
    \   [(or (= n 1) (= n 0)) #f]\n    [(odd? n) #t]\n    [else (even? n)]))\n", " \
    \ (define (check-divisors d)\n    (cond ((< d n) (if (zero? (modulo n d)) #f (check-divisors\
    \ (+ d 1))))\n          (else #t)))\n  (if (= n 1) #f (check-divisors 2)))\n",
  "  (cond ((= n 1) #f)\n        ((= n 2) #t)\n        ((even? n) #f)\n        (else\n\
    \         (for/and ([i (in-range 3 (/ n 2) 2)])\n           (not (zero? (modulo\
    \ n i)))))))\n", "  (cond ((= n 2) #t)\n        ((= n 3) #t)\n        ((= n 5)\
    \ #t)\n        ((= n 7) #t)\n        ((= n 11) #t)\n        ((even? n) #f)\n \
    \       ((< n 2) #f)\n        (else (prime-test n))))\n", "  (define (is_divided\
    \ x)\n    (remainder n x))\n  (cond\n    [(= n 2) true]\n    [(= n 3) true]\n\
    \    [(<= n 1) false]\n    [(is_divided 2) false]\n    [(is_divided 3) false]\n\
    \    [else (define (helper i)\n            (cond\n              [(= i n) true]\n\
    \              [(is_divided i) false]\n              [else (helper (+ i 2))]))\n\
    \          (helper 5)]))\n", "  (cond ((= n 1) false)\n        ((= n 2) true)\n\
    \        ((even? n) false)\n        (else\n         (is_prime-helper 3 n))))\n",
  "  (cond [(<= n 1) #f]\n        [(= n 2) #t]\n        [(even? n) #f]\n        [else\n\
    \         (is_prime? n (sub1 (ceiling (/ n 2))))]))\n", "  (if (< n 3)\n     \
    \ (if (= n 2)\n          #t\n          #f)\n      (let loop ((i 2))\n        (if\
    \ (= n i)\n            #t\n            (if (= 0 (modulo n i))\n              \
    \  #f\n                (loop (+ i 1)))))))\n", "  (define (recur k)\n    (if (=\
    \ k 1)\n        #t\n        (if (= (remainder n k) 0)\n            #f\n      \
    \      (recur (- k 1)))))\n  (if (= n 1)\n      #f\n      (recur (- n 1))))\n\n",
  "  (cond [(= n 2) #t]\n        [(= n 3) #t]\n        [(even? n) #f]\n        [(=\
    \ (remainder n 3) 0) #f]\n        [else (is_prime-helper n 5)]))\n", "  (define\
    \ (prime? x y)\n    (cond ((= y 1) #t)\n          ((= (modulo x y) 0) #f)\n  \
    \        (else (prime? x (- y 1)))))\n  (prime? n (- n 1)))\n", "  (if (eq? n\
    \ 2)\n      #t\n      (define (divisible? x)\n        (if (eq? (* x x) n)\n  \
    \          #t\n            (if (&gt; (* x x) n)\n                #f\n        \
    \        (divisible? (+ x 1)))))\n      (not (divisible? 2))))\n", "  (define\
    \ (is_prime-helper n i)\n    (cond ((= i 1) true)\n          ((= (modulo n i)\
    \ 0) false)\n          (else (is_prime-helper n (- i 1)))))\n  (is_prime-helper\
    \ n (quotient n 2)))\n", "  (let ([num (quotient n 2)])\n    (if (= n 2)\n   \
    \     #t\n        (cond [(= n 0) #f]\n              [(= n 1) #f]\n           \
    \   [(even? n) #f]\n              [else\n               (define (check-divisor\
    \ k)\n                 (cond [(= k 0) #t]\n                       [(= (remainder\
    \ n k) 0) #f]\n                       [else (check-divisor (sub1 k))]))\n    \
    \           (check-divisor num)]))))\n", "  (if (or (= n 1) (= n 0)) #f\n    \
    \  (let loop ((i 2))\n        (if (> (* i i) n) #t\n            (if (zero? (modulo\
    \ n i)) #f\n                (loop (+ i 1)))))))\n", "  (define (iter test-num)\n\
    \    (cond ((= test-num 1) #t)\n          ((= (modulo n test-num) 0) #f)\n   \
    \       (else (iter (- test-num 1)))))\n  (iter (truncate (/ n 2))))\n", "  (define\
    \ (factors n)\n    (if (= n 1)\n        '(1)\n        (let loop ((i (quotient\
    \ n 2))\n                   (fs (list)))\n          (if (= i 0)\n            \
    \  (cons n fs)\n              (if (zero? (modulo n i))\n                  (loop\
    \ (- i 1) (cons i fs))\n                  (loop (- i 1) fs))))))\n  (= (length\
    \ (factors n)) 2))\n", "  (cond\n    [(= n 1)\n     #f]\n    [(= n 2)\n     #t]\n\
    \    [(< 1 (remainder n 2))\n     #f]\n    [(= (remainder n 2) 0)\n     #f]\n\
    \    [else\n     (for/and ([i (in-range 3 n (- 2))])\n       (not (zero? (remainder\
    \ n i))))]))\n", "  (define (check-divides? d)\n    (zero? (modulo n d)))\n  (define\
    \ (smallest-factor n d)\n    (if (check-divides? d)\n        d\n        (smallest-factor\
    \ n (+ d 1))))\n  (if (= n 1)\n      #f\n      (define sf (smallest-factor n 2))\n\
    \      (if (= sf n)\n          #t\n          #f)))\n", "  (define (helper i)\n\
    \    (cond ((= i n) #t)\n          ((= (remainder n i) 0) #f)\n          (else\
    \ (helper (+ i 1)))))\n  (if (= n 1)\n      #f\n      (helper 2)))\n", "  (define\
    \ (divides? x y)\n    (= 0 (modulo y x)))\n  (define (iter x)\n    (cond ((= x\
    \ n) #t)\n          ((divides? x n) #f)\n          (else (iter (+ x 1)))))\n \
    \ (cond ((= n 1) #f)\n        ((= n 2) #t)\n        (else (iter 2))))\n```\n\n\
    ## Chapter 4 Exercises\n\n### Designing Functions\n1. **Design a function that\
    \ takes three numbers and returns the sum of the squares of the two larger numbers.**\n\
    \n```racket\n#lang racket\n", "  (if (= n 1)\n      #f\n      (let loop ((test-divisor\
    \ (quotient n 2)))\n        (cond\n          ((<= test-divisor 1) #t)\n      \
    \    ((= (remainder n test-divisor) 0) #f)\n          (else (loop (- test-divisor\
    \ 1)))))))\n", "  (for/or ([i (in-range 1 (add1 (inexact->exact (sqrt n))))])\n\
    \    (equal? (remainder n i) 0)))\n", "  (let loop ((i 2))\n    (cond\n      ((and\
    \ (<= i (sqrt n)) (zero? (modulo n i)))\n       #f)\n      ((<= i (sqrt n))\n\
    \       (loop (+ i 1)))\n      (else\n       #t))))\n", "  (define (iter current)\n\
    \    (if (= current 1) true\n      (if (= (remainder n current) 0) false\n   \
    \       (iter (- current 1)))))\n  (iter (- n 1)))\n", "  (define (helper d)\n\
    \    (cond\n      [(= d n)\n       #t]\n      [(= (remainder n d) 0)\n       #f]\n\
    \      [else\n       (helper (+ d 1))]))\n  (cond\n    [(= n 1)\n     #f]\n  \
    \  [(= n 2)\n     #t]\n    [else\n     (helper 2)]))\n", "  (or (= n 2)\n    \
    \  (or (= n 3)\n          (or (= n 5)\n              (or (= n 7)\n           \
    \       (or (= n 11)\n                      (or (= n 13)\n                   \
    \       (or (= n 17)\n                              (or (= n 19)\n           \
    \                       (or (= n 23)\n                                      (or\
    \ (= n 29)\n                                          (or (= n 31)\n         \
    \                                     (or (= n 37)\n                         \
    \                         (or (= n 41)\n                                     \
    \                 (or (= n 43)\n                                             \
    \             (or (= n 47)\n                                                 \
    \             (or (= n 53)\n                                                 \
    \                 (or (= n 59)\n                                             \
    \                         (or (= n 61)\n                                     \
    \                                     (or (= n 67)\n                         \
    \                                                     (or (= n 71)\n         \
    \                                                                         (or\
    \ (= n 73)\n                                                                 \
    \                     (or (= n 79)\n                                         \
    \                                                 (or (= n 83)\n             \
    \                                                                            \
    \     (or (= n 89)\n                                                         \
    \                                         (or (= n 97)\n                     \
    \                                                                            \
    \     (and (< n 100)\n                                                       \
    \                                                    (even? n))))))))))))))))))))))))))\n",
  "  (cond\n    [(= n 1) false]\n    [(= n 2) true]\n    [(even? n) false]\n    [else\n\
    \     (define (factors n)\n       (range n))\n     (empty? (for/and ([i (factors\
    \ n)]) (if (= 0 (modulo n i)) false)))\n    ]))\n", "  (define (is_prime-helper\
    \ n current-divisor)\n    (if (= (* current-divisor current-divisor) n)\n    \
    \    #f\n        (if (or (= (remainder n current-divisor) 0)\n               \
    \ (&lt; current-divisor (/ n 2)))\n            #f\n            (is_prime-helper\
    \ n (+ current-divisor 1)))))\n  (is_prime-helper n 2))\n", "  (cond\n    [(=\
    \ n 1) #f]\n    [(= n 2) #t]\n    [(zero? (remainder n 2)) #f]\n    [else\n  \
    \   (define (loop counter)\n       (cond\n         [(= counter (floor (/ n 2)))\
    \ #t]\n         [(zero? (remainder n counter)) #f]\n         [else (loop (+ counter\
    \ 1))]))\n     (loop 3)]))\n\n", "  (define (is_divisor n div)\n    (cond [(=\
    \ n 1) #f]\n          [(= n div) #t]\n          [(zero? (modulo n div)) #f]\n\
    \          [else (is_divisor n (+ div 1))]))\n  (is_divisor n 2))\n", "  (if (=\
    \ 1 n)\n      #f\n      (if (= 2 n)\n          #t\n          (if (= n (floor (/\
    \ n 2)))\n              #f\n              (if (even? n)\n                  #f\n\
    \                  (let loop ((i 3))\n                    (if (< i (floor (/ n\
    \ 2)))\n                        (if (= 0 (modulo n i))\n                     \
    \       #f\n                            (loop (+ i 2)))\n                    \
    \    #t)))))))\n", "  (if (= (length (filter (lambda (x) (= (modulo n x) 0)) (range\
    \ 1 n))) 1)\n      #t\n      #f))\n", "  (define (divides? a b)\n    (= (remainder\
    \ b a) 0))\n  (cond ((< n 2)\n         #f)\n        ((or (= n 2) (= n 3))\n  \
    \       #t)\n        ((or (divides? 2 n) (divides? 3 n))\n         #f)\n     \
    \   (else\n         (define (iter x)\n           (cond ((> (* x x) n)\n      \
    \            #t)\n                 ((or (divides? x n) (divides? (+ x 1) n))\n\
    \                  #f)\n                 (else\n                  (iter (+ x 2)))))\n\
    \         (iter 5))))\n", "  (cond ((= n 1) #f)\n        ((= n 2) #t)\n      \
    \  ((is_even n) #f)\n        (else\n         (is_prime-iter n (+ n 1) (/ n 2)))))\n",
  "  (define (is_prime_helper n i)\n    (if (= i 1)\n        #t\n        (if (= (modulo\
    \ n i) 0)\n            #f\n            (is_prime_helper n (- i 1)))))\n  (if (=\
    \ n 1)\n      #f\n      (is_prime_helper n (- n 1))))\n\n", "  (cond ((= n 1)\
    \ #f)\n        ((= n 2) #t)\n        ((= (remainder n 2) 0) #f)\n        (else\
    \ (is_prime_helper n (/ n 2) 2))))\n", "  (let ([a (car (last (filter (lambda\
    \ (x) (= (modulo n x) 0)) (range 2 (add1 (sqrt n))))))])\n    (if (= a n)\n  \
    \      #t\n        #f)))\n", "  (let* ((factors (prime-factors n))\n         (num-factors\
    \ (length factors)))\n    (and (= 1 num-factors)\n         (= (first factors)\
    \ n))))\n", "  (define (is_prime-rec n i)\n    (if (= i 1)\n        #t\n     \
    \   (if (= (modulo n i) 0)\n            #f\n            (is_prime-rec n (- i 1)))))\n\
    \  (if (= n 1)\n      #f\n      (is_prime-rec n (- n 1))))\n", "  (define (is_prime-helper\
    \ n sqrt)\n    (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n      [(= n sqrt)\
    \ #t]\n      [(= (remainder n sqrt) 0) #f]\n      [else (is_prime-helper n (+\
    \ sqrt 1))]))\n  (is_prime-helper n 2))\n", "  (define (check x)\n    (cond [(=\
    \ x 1) #t]\n          [(= (modulo n x) 0) #f]\n          [else (check (- x 1))]))\n\
    \  (check (/ n 2)))\n", "  (cond\n    [(> n 1)\n     (define a 2)\n     (define\
    \ b (+ n 1))\n     (define (is-divisor a b)\n       (if (= a b)\n           #t\n\
    \           (if (= (remainder n a) 0)\n               #f\n               (is-divisor\
    \ (+ a 1) b))))\n     (is-divisor a b)]\n    [else\n     #f]))\n", "  (cond [(=\
    \ n 1) #f]\n        [(= n 2) #t]\n        [(= n 3) #t]\n        [(odd? n)\n  \
    \       (every (lambda (x)\n                  (not (= (modulo n x) 0)))\n    \
    \            (range 1 (integer-sqrt n)))]\n        [else\n         (every (lambda\
    \ (x)\n                  (not (= (modulo n x) 0)))\n                (range 2 (integer-sqrt\
    \ n)))]))\n", "  (define (prime? start)\n    (if (= start n)\n        #t\n   \
    \     (if (= (remainder n start) 0)\n            #f\n            (prime? (+ start\
    \ 1)))))\n  (if (= n 1)\n      #f\n      (prime? 2)))\n```\n\n[&#9650; back to\
    \ top](#Contents)\n\n---\n\n## Default Arguments\n\nA nice feature of Racket is\
    \ that we can set default values for function arguments. This means that we do\
    \ not need to pass in the argument when we call the function. (If we do pass in\
    \ the argument, it is used instead of the default value.)\n\nHere's a function\
    \ that calculates the slope between two points, using default values for x2 and\
    \ y2:\n\n```racket\n#lang racket\n", "  (define (divisor n)\n    (cond ((= n 1)\
    \ #f)\n          ((= n 2) #t)\n          ((= n 3) #t)\n          ((= n 5) #t)\n\
    \          ((= n 7) #t)\n          ((or (= (remainder n 2) 0)\n              \
    \ (= (remainder n 3) 0)\n               (= (remainder n 5) 0)\n              \
    \ (= (remainder n 7) 0)) #f)\n          (else (divisor (- n 1)))))\n  (divisor\
    \ n))\n", "  (if (= n 2)\n      #t\n      (if (= n 1)\n          #f\n        \
    \  (let loop ((i 2))\n            (if (> (* i i) n)\n                #t\n    \
    \            (if (= (modulo n i) 0)\n                    #f\n                \
    \    (loop (+ i 1))))))))\n", "  (and\n   (not (= n 1))\n   (not (and (< n 4)\n\
    \             (= n 2)))\n   (not (and (< n 9)\n             (= n 3)))\n   (not\
    \ (and (< n 25)\n             (or (= n 5)\n                 (= n 7))))\n   (not\
    \ (and (< n 49)\n             (or (= n 11)\n                 (= n 13)\n      \
    \           (= n 17)\n                 (= n 19)\n                 (= n 23))))\n\
    \   (not (and (< n 169)\n             (or (= n 29)\n                 (= n 31)\n\
    \                 (= n 37)\n                 (= n 41)\n                 (= n 43)\n\
    \                 (= n 47))))\n   (not (and (< n 289)\n             (or (= n 53)\n\
    \                 (= n 59)\n                 (= n 61)\n                 (= n 67)\n\
    \                 (= n 71)\n                 (= n 73)\n                 (= n 79)\n\
    \                 (= n 83)\n                 (= n 89)\n                 (= n 97))))\n\
    \   (not (and (< n 961)\n             (or (= n 101)\n                 (= n 103)\n\
    \                 (= n 107)\n                 (= n 109)\n                 (= n\
    \ 113)\n                 (= n 127)\n                 (= n 131)\n             \
    \    (= n 137)\n                 (= n 139)\n                 (= n 149)\n     \
    \            (= n 151)\n                 (= n 157)\n                 (= n 163)\n\
    \                 (= n 167)\n                 (= n 173)\n                 (= n\
    \ 179)\n                 (= n 181)\n                 (= n 191)\n             \
    \    (= n 193)\n                 (= n 197)\n                 (= n 199))))\n  \
    \ (not (and (< n 4913)\n             (or (= n 211)\n                 (= n 223)\n\
    \                 (= n 227)\n                 (= n 229)\n                 (= n\
    \ 233)\n                 (= n 239)\n                 (= n 241)\n             \
    \    (= n 251)\n                 (= n 257)\n                 (= n 263)\n     \
    \            (= n 269)\n                 (= n 271)\n                 (= n 277)\n\
    \                 (= n 281)\n                 (= n 283)\n                 (= n\
    \ 293)\n                 (= n 307)\n                 (= n 311)\n             \
    \    (= n 313)\n                 (= n 317)\n                 (= n 331)\n     \
    \            (= n", "  (define (is_prime-rec i)\n    (cond\n      [(= i 1) #t]\n\
    \      [(= (modulo n i) 0) #f]\n      [else (is_prime-rec (- i 1))]))\n  (if (and\
    \ (integer? n) (&gt; n 0))\n      (is_prime-rec (floor (/ n 2)))\n      #f))\n\
    </code>\n", "  (if (< n 2) #f\n      (if (even? n) #f\n          (define (go i)\n\
    \            (if (< i (/ n 2)) (if (evenly-divides? n i) #f (go (+ i 1))) #t))\n\
    \          (go 2))))\n", "  (cond\n    [(= n 1) #f]\n    [(= n 2) #t]\n    [(=\
    \ (modulo n 2) 0) #f]\n    [else (test_prime n 3)]))\n", "  (cond ((< n 2) #f)\n\
    \        ((= n 2) #t)\n        ((even? n) #f)\n        (else\n         (define\
    \ (smallest-divisor n)\n           (if (= n 1)\n               1\n           \
    \    (find-divisor n 2)))\n         (if (= (smallest-divisor n) n)\n         \
    \    #t\n             #f))))\n", "  (define (prime? factor n)\n    (cond\n   \
    \   [(= n 1) #f]\n      [(>= (* factor factor) n) #t]\n      [(= (remainder n\
    \ factor) 0) #f]\n      [else (prime? (+ factor 1) n)]))\n  (prime? 2 n))\n```\n\
    \n```\n#lang racket\n", "  (define (iter k)\n    (cond\n      [(= k 1) true]\n\
    \      [(= (modulo n k) 0) false]\n      [else (iter (- k 1))]))\n  (iter (quotient\
    \ n 2)))\n", "  (define (helper x)\n    (if (< x n)\n        (if (= (remainder\
    \ n x) 0)\n            #f\n            (helper (+ x 1)))\n        #t))\n  (helper\
    \ 2))\n", "  (if (= n 1) \n      #f\n      (define (is_prime-helper divisor)\n\
    \        (if (= divisor 1)\n            #t\n            (if (= (remainder n divisor)\
    \ 0)\n                #f\n                (is_prime-helper (- divisor 1)))))\n\
    \      (is_prime-helper (- n 1))))\n", "  (define (divisor x)\n    (define (find-divisor\
    \ y test-divisor)\n      (cond ((> (sqr test-divisor) y) y)\n            ((divides?\
    \ test-divisor y) test-divisor)\n            (else (find-divisor y (+ test-divisor\
    \ 1)))))\n    (find-divisor x 2))\n  (if (= n 1)\n      #f\n      (= n (divisor\
    \ n))))\n", "  (define (loop i)\n    (cond ((= i n) #t)\n          ((divides?\
    \ i n) #f)\n          (else (loop (+ i 1)))))\n  (cond ((= n 1) #f)\n        ((=\
    \ n 2) #t)\n        (else (loop 2))))\n", "  (if (= n 1)\n      #f\n      (if\
    \ (= n 2)\n          #t\n          (if (even? n)\n              #f\n         \
    \     (is_prime-helper n 3)))))\n", "  (cond\n    [(= n 1) #f]\n    [(= n 2) #t]\n\
    \    [(= (modulo n 2) 0) #f]\n    [else\n     (define (is-divisible-by-n? n divisor)\n\
    \       (cond\n         [(> n divisor) #f]\n         [(= (modulo n divisor) 0)\
    \ #t]\n         [else (is-divisible-by-n? n (+ divisor 1))]))\n     (is-divisible-by-n?\
    \ n 3)]))\n", "  (cond [(= n 2) #t]\n        [(= n 3) #t]\n        [(= n 4) #f]\n\
    \        [(or (= n 1)\n             (divides? n 2)\n             (divides? n 3))\
    \ #f]\n        [else (is_prime_helper n 5)]))\n", "  (let loop ((i 2))\n    (if\
    \ (> (* i i) n)\n        #t\n        (if (zero? (modulo n i))\n            #f\n\
    \            (loop (+ i 1))))))\n", "  (if (= n 1)\n      #f\n      (not (list-any\
    \ (lambda (x) (= (modulo n x) 0)) (range 1 n)))))\n", "  (cond ((> n 1) (is_prime_helper\
    \ n 2))\n        (else #f)))\n", "  (define (calc r)\n    (if (= r n)\n      \
    \  #t\n        (if (= (remainder n r) 0)\n            #f\n            (calc (+\
    \ r 1)))))\n  (if (= n 2)\n      #t\n      (if (= (remainder n 2) 0)\n       \
    \   #f\n          (calc 3))))\n", "  (if (= n 1)\n      #f\n      (if (= n 2)\n\
    \          #t\n          (and (= (modulo n 2) 1)\n               (not (member\
    \ (modulo n (range 3 n 2)) 0))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
