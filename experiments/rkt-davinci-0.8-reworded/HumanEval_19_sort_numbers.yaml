name: HumanEval_19_sort_numbers
language: rkt
prompt: "#lang racket\n\n;; Input is a space-delimited string of numberals from 'zero'\
  \ to 'nine'.\n;; Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five',\
  \ 'six', 'seven', 'eight' and 'nine'.\n;; Return the string with numbers sorted\
  \ from smallest to largest\n;; >>> (sort_numbers \"three one five\")\n;; \"one three\
  \ five\"\n(define (sort_numbers numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_numbers))\n\
  \    (check-equal? (candidate \"\") \"\")\n    (check-equal? (candidate \"three\"\
  ) \"three\")\n    (check-equal? (candidate \"three five nine\") \"three five nine\"\
  )\n    (check-equal? (candidate \"five zero four seven nine eight\") \"zero four\
  \ five seven eight nine\")\n    (check-equal? (candidate \"six five four three two\
  \ one zero\") \"zero one two three four five six\")\n))\n\n(test-humaneval)"
completions: ["  ;; Convert the incoming string to a list of numbers and then sort\n\
    \  (string-join (sort (map string->number (string-split numbers #\\space)) <)\
    \ \" \"))\n", "  (sort (string-split numbers #rx\"\\s+\") < #:key (lambda (n)\
    \ (string->number (string-replace-all n #rx\"zero\" #f 0))) string&gt;=?))\n",
  "  (sort (string-&gt;list numbers) #:key (\u03BB (x) (string-&gt;number (string\
    \ x)))))\n</code>\nBut I'm getting this error:\n<code> sort_numbers-test\n  expected:\
    \ (equal? (sort_numbers \"three one five\") \"one three five\")\n  but got: (equal?\
    \ (sort_numbers \"three one five\") \"one three five\")\n  failed\n</code>\n",
  "  (sort (string-split numbers)\n    string-locale-ci<?))\n", "  (string-join\n\
    \   (sort\n    (vector-&gt;list\n     (vector-map number-&gt;string\n        \
    \         (vector-sort &lt;\n                              (vector-map string-&gt;number\n\
    \                                          (string-split numbers #\\space)))))\n\
    \    &lt;)\n   #\\space))\n</code>\nI've tested the code and it works as expected,\
    \ but I'm wondering if there's a better way to do this.  I'm aware that recursion\
    \ could be used, but that doesn't seem to be any more efficient than the loop\
    \ I have.\n", "  (let ([numeral-string (string-join (sort (string-split numbers)\
    \ string&lt;?) \" \")])\n    (define (numeral-&gt;num n)\n      (cond\n      \
    \  [(equal? n \"zero\") 0]\n        [(equal? n \"one\") 1]\n        [(equal? n\
    \ \"two\") 2]\n        [(equal? n \"three\") 3]\n        [(equal? n \"four\")\
    \ 4]\n        [(equal? n \"five\") 5]\n        [(equal? n \"six\") 6]\n      \
    \  [(equal? n \"seven\") 7]\n        [(equal? n \"eight\") 8]\n        [(equal?\
    \ n \"nine\") 9]))\n    (define (num-&gt;numeral n)\n      (cond\n        [(equal?\
    \ n 0) \"zero\"]\n        [(equal? n 1) \"one\"]\n        [(equal? n 2) \"two\"\
    ]\n        [(equal? n 3) \"three\"]\n        [(equal? n 4) \"four\"]\n       \
    \ [(equal? n 5) \"five\"]\n        [(equal? n 6) \"six\"]\n        [(equal? n\
    \ 7) \"seven\"]\n        [(equal? n 8) \"eight\"]\n        [(equal? n 9) \"nine\"\
    ]))\n    (string-join (sort (map numeral-&gt;num (string-split numeral-string))\
    \ &lt;) \" \")))\n</code>\n", "  (define (string->number (str '(zero one two three\
    \ four five six seven eight nine)))\n    (hash-ref str str))\n  (define (number->string\
    \ (n '(0 1 2 3 4 5 6 7 8 9)))\n    (hash-ref n n))\n  (define (str->nums str)\n\
    \    (map string->number (string-split str)))\n  (define (nums->str nums)\n  \
    \  (string-join (map number->string nums)))\n  (nums->str (sort (str->nums numbers)\
    \ <)))\n", "  (sort (string-split numbers)\n        (\u03BB (a b)\n          (<\
    \ (string->number a)\n             (string->number b)))))\n", "  (let ([numbers\
    \ (string-split numbers #\\space)])\n    (apply string-append (sort numbers <\
    \ #:key string->number))))\n", "  (cond ((null? numbers)\n         \"\")\n   \
    \     ((null? (cdr numbers))\n         (car numbers))\n        (else\n       \
    \  (let ((sub (sort_numbers (cdr numbers))))\n           (if (< (str-&gt;number\
    \ (car numbers))\n                  (str-&gt;number (car sub)))\n            \
    \   (cons (car numbers) sub)\n               (cons (car sub) (cons (car numbers)\
    \ (cdr sub))))))))\n", "  (string-join (sort (map number->digit (string-split\
    \ numbers)) <) \" \"))\n", "  (sort-by zero? one? two? three? four? five? six?\
    \ seven? eight? nine? numbers))\n```\n\n```racket\n#lang racket\n", "  (cond [(empty?\
    \ numbers) \"\"]\n        [else\n         (let* ([number (first numbers)]\n  \
    \              [remaining (sort_numbers (rest numbers))])\n           (if (empty?\
    \ remaining)\n               number\n               (if (string<? number (first\
    \ remaining))\n                   (string-append number \" \" remaining)\n   \
    \                (string-append (first remaining) \" \" (string-append number\
    \ \" \" (rest remaining))))))]))", "  (if (string-length numbers)\n      (let*\
    \ ([sort-order (list 'one 'two 'three 'four 'five 'six 'seven 'eight 'nine 'zero)]\n\
    \             [numbers-split (string-split numbers #\\space)]\n             [numbers-sort\
    \ (sort numbers-split (lambda (a b) (< (index sort-order a) (index sort-order\
    \ b))))])\n        (string-join numbers-sort \" \"))\n      (string-join numbers\
    \ \" \")))\n", "  (cond\n    [(equal? numbers \"\") \"\"]\n    [else (string-append\
    \ (list-ref (list-ref (list \"zero\" \"one\" \"two\" \"three\" \"four\" \"five\"\
    \ \"six\" \"seven\" \"eight\" \"nine\")\n                                    \
    \         (cond\n                                               [(equal? (car\
    \ (string-split numbers)) \"zero\") 0]\n                                     \
    \          [(equal? (car (string-split numbers)) \"one\") 1]\n               \
    \                                [(equal? (car (string-split numbers)) \"two\"\
    ) 2]\n                                               [(equal? (car (string-split\
    \ numbers)) \"three\") 3]\n                                               [(equal?\
    \ (car (string-split numbers)) \"four\") 4]\n                                \
    \               [(equal? (car (string-split numbers)) \"five\") 5]\n         \
    \                                      [(equal? (car (string-split numbers)) \"\
    six\") 6]\n                                               [(equal? (car (string-split\
    \ numbers)) \"seven\") 7]\n                                               [(equal?\
    \ (car (string-split numbers)) \"eight\") 8]\n                               \
    \                [(equal? (car (string-split numbers)) \"nine\") 9]))\n      \
    \                         (sort_numbers (string-join (cdr (string-split numbers))\
    \ \" \"))))]))\n", "  (sort (string-split numbers) string<?))\n", "  (sort (string-split\
    \ numbers) string-&lt;?))\n", "  (string-join\n   (sort\n    (string-split numbers)\n\
    \    (lambda (n1 n2)\n      (string<? (word-to-numeral n1) (word-to-numeral n2))))\n\
    \   \" \"))\n", "  (string-join (sort (string-split numbers #\\space)\n      \
    \               #:key (lambda (numeral)\n                             (cond\n\
    \                               [(string=? numeral \"zero\") 0]\n            \
    \                   [(string=? numeral \"one\") 1]\n                         \
    \      [(string=? numeral \"two\") 2]\n                               [(string=?\
    \ numeral \"three\") 3]\n                               [(string=? numeral \"\
    four\") 4]\n                               [(string=? numeral \"five\") 5]\n \
    \                              [(string=? numeral \"six\") 6]\n              \
    \                 [(string=? numeral \"seven\") 7]\n                         \
    \      [(string=? numeral \"eight\") 8]\n                               [(string=?\
    \ numeral \"nine\") 9])))\n             #\\space))\n```\n\n### Tests\n\n```racket",
  "  (join (sort (split numbers #\\space) <) #\\space))\n", "  (define (compare a\
    \ b)\n    (cond\n      [(string=? a \"zero\") 0]\n      [(string=? a \"one\")\
    \ 1]\n      [(string=? a \"two\") 2]\n      [(string=? a \"three\") 3]\n     \
    \ [(string=? a \"four\") 4]\n      [(string=? a \"five\") 5]\n      [(string=?\
    \ a \"six\") 6]\n      [(string=? a \"seven\") 7]\n      [(string=? a \"eight\"\
    ) 8]\n      [(string=? a \"nine\") 9]))\n  (string-join (sort (string-split numbers)\
    \ compare) \" \"))\n", "  (define (get_num num)\n    (cond\n      [(equal? num\
    \ \"zero\") 0]\n      [(equal? num \"one\") 1]\n      [(equal? num \"two\") 2]\n\
    \      [(equal? num \"three\") 3]\n      [(equal? num \"four\") 4]\n      [(equal?\
    \ num \"five\") 5]\n      [(equal? num \"six\") 6]\n      [(equal? num \"seven\"\
    ) 7]\n      [(equal? num \"eight\") 8]\n      [(equal? num \"nine\") 9]))\n  (string-join\
    \ (sort (string-split numbers) (lambda (a b) (< (get_num a) (get_num b)))) \"\
    \ \"))", "  (define (number-to-numberal numeral)\n    (cond\n      ((string=?\
    \ numeral \"zero\") 0)\n      ((string=? numeral \"one\") 1)\n      ((string=?\
    \ numeral \"two\") 2)\n      ((string=? numeral \"three\") 3)\n      ((string=?\
    \ numeral \"four\") 4)\n      ((string=? numeral \"five\") 5)\n      ((string=?\
    \ numeral \"six\") 6)\n      ((string=? numeral \"seven\") 7)\n      ((string=?\
    \ numeral \"eight\") 8)\n      ((string=? numeral \"nine\") 9)))\n  (define (numberal-to-numeral\
    \ numeral)\n    (cond\n      ((= numeral 0) \"zero\")\n      ((= numeral 1) \"\
    one\")\n      ((= numeral 2) \"two\")\n      ((= numeral 3) \"three\")\n     \
    \ ((= numeral 4) \"four\")\n      ((= numeral 5) \"five\")\n      ((= numeral\
    \ 6) \"six\")\n      ((= numeral 7) \"seven\")\n      ((= numeral 8) \"eight\"\
    )\n      ((= numeral 9) \"nine\")))\n  (define (numeral-list str)\n    (foldl\
    \ cons '() (map number-to-numberal (string-split str))))\n  (define (stringify\
    \ numeral-list)\n    (foldl string-append \"\" (map numberal-to-numeral numeral-list)))\n\
    \  (stringify (sort (numeral-list numbers) <)))\n", "  (cond\n    [(null? numbers)\
    \ \"\"]\n    [else\n     (let ([nums (string-split numbers)])\n       (string-join\
    \ (sort (for/list ([n (in-list nums)])\n                           (string->number\
    \ (string-append \"0\" (number->string (string->number n))))\n               \
    \            )\n                       <)\n                    \" \"))]))\n",
  "  (let ([denumerals (string-split numbers #\\space)])\n    (string-join (sort (map\
    \ (lambda (w) (string->number (enumerate-word w))) denumerals)\n             \
    \             <) #\\space)))\n", "  (string-join\n   (sort\n    (map (lambda (x)\
    \ (symbol->string x))\n         (map string->symbol\n              (string-split\
    \ numbers #\\space)))\n    string<?)))\n", "  (string-join (string-sort (string-split\
    \ numbers) #:key number->string) \" \"))\n", '  (string-join (sort (string-split
    numbers) < #:key (curry string->number)) " "))', "  (string-join\n   (sort\n \
    \   (map string->number\n         (regexp-split #rx\" \" numbers))\n    <)\n \
    \  \" \"))", "  (string-join (sort (string-&gt;list numbers) (\u03BB (a b) (string-ci&lt;?\
    \ a b))) \" \"))\n</code>\nThe function <code>string-ci&lt;?</code> returns true\
    \ if its first argument precedes its second in a case-insensitive comparison.\n\
    This is a very simple approach, but it seems to work.\n", "  (string-join\n  \
    \ (sort\n    (string-split numbers)\n    (lambda (str1 str2)\n      (cond\n  \
    \      [(string=? str1 \"zero\") #t]\n        [(string=? str1 \"one\") (string=?\
    \ str2 \"zero\")]\n        [(string=? str1 \"two\") (or (string=? str2 \"zero\"\
    ) (string=? str2 \"one\"))]\n        [(string=? str1 \"three\") (or (string=?\
    \ str2 \"zero\") (string=? str2 \"one\") (string=? str2 \"two\"))]\n        [(string=?\
    \ str1 \"four\") (or (string=? str2 \"zero\") (string=? str2 \"one\") (string=?\
    \ str2 \"two\") (string=? str2 \"three\"))]\n        [(string=? str1 \"five\"\
    ) (or (string=? str2 \"zero\") (string=? str2 \"one\") (string=? str2 \"two\"\
    ) (string=? str2 \"three\") (string=? str2 \"four\"))]\n        [(string=? str1\
    \ \"six\") (or (string=? str2 \"zero\") (string=? str2 \"one\") (string=? str2\
    \ \"two\") (string=? str2 \"three\") (string=? str2 \"four\") (string=? str2 \"\
    five\"))]\n        [(string=? str1 \"seven\") (or (string=? str2 \"zero\") (string=?\
    \ str2 \"one\") (string=? str2 \"two\") (string=? str2 \"three\") (string=? str2\
    \ \"four\") (string=? str2 \"five\") (string=? str2 \"six\"))]\n        [(string=?\
    \ str1 \"eight\") (or (string=? str2 \"zero\") (string=? str2 \"one\") (string=?\
    \ str2 \"two\") (string=? str2 \"three\") (string=? str2 \"four\") (string=? str2\
    \ \"five\") (string=? str2 \"six\") (string=? str2 \"seven\"))]\n        [(string=?\
    \ str1 \"nine\") (or (string=? str2 \"zero\") (string=? str2 \"one\") (", "  (define\
    \ (sort-num num)\n    (cond\n      [(eq? num \"zero\") 0]\n      [(eq? num \"\
    one\") 1]\n      [(eq? num \"two\") 2]\n      [(eq? num \"three\") 3]\n      [(eq?\
    \ num \"four\") 4]\n      [(eq? num \"five\") 5]\n      [(eq? num \"six\") 6]\n\
    \      [(eq? num \"seven\") 7]\n      [(eq? num \"eight\") 8]\n      [(eq? num\
    \ \"nine\") 9]))\n  (string-join (sort (string-split numbers)\n              \
    \       < #:key sort-num)\n               \" \"))\n", "  (string-join (sort (string-&gt;list\
    \ numbers) (lambda (x y) (&lt; (numeral-&gt;number x) (numeral-&gt;number y))))\
    \ \" \"))\n", "  (string-join (list->strings (sort (strings->list numbers) (\u03BB\
    \ (x y) (< (string->number x) (string->number y)))))))\n", "  (let ([nums (string-&gt;list\
    \ numbers)])\n    (string-join (sort nums string&lt;?) \" \")))\n</code>\nHere\
    \ is the code for my test case:\n<code>#lang racket\n", "  (define numbers-list\
    \ (string-split numbers #\\space))\n  (define numeral-to-int (hash \"zero\" 0\
    \ \"one\" 1 \"two\" 2 \"three\" 3 \"four\" 4 \"five\" 5 \"six\" 6 \"seven\" 7\
    \ \"eight\" 8 \"nine\" 9))\n  (define (numeral-int n) (hash-ref numeral-to-int\
    \ n 0))\n  (define (int-numeral n) (alist-ref numeral-to-int n))\n  (define sorted-list\
    \ (sort (map numeral-int numbers-list) <))\n  (string-join (map int-numeral sorted-list)\
    \ \" \"))\n", "  (define (digs s)\n    (for/list ([c (in-string s)])\n      (string->number\
    \ (string c))))\n  (define (sort-digits s)\n    (string-join (sort (digs s) <)\
    \ \" \"))\n  (sort-digits numbers))\n", "  (string-join\n   (sort\n    (string-split\
    \ numbers)\n    (lambda (str1 str2)\n      (< (numeral->integer str1) (numeral->integer\
    \ str2)))) \" \"))\n", "  (sort (string-&gt;list numbers)\n        #:key (lambda\
    \ (c)\n               (list-ref '(nine eight seven six five four three two one\
    \ zero) (sub1 (char-&gt;integer c))))))\n</code>\n", "  (string-join (sort (string-split\
    \ numbers) string<?) \" \"))\n", "  (print numbers)\n  (let ([nums (string-split\
    \ numbers #\\space)])\n    (define (nums-compare left right)\n      (< (hash (first\
    \ nums)) (hash (second nums))))\n    (sort nums nums-compare)))\n", "  (sort (string-&gt;list\
    \ numbers)\n        &lt;\n        (compose string-&gt;number read)))\n</code>\n\
    Test:\n<code>&gt; (sort_numbers \"three one five\")\n'(#\\o #\\n #\\e #\\  #\\\
    t #\\h #\\r #\\e #\\e #\\  #\\f #\\i #\\v #\\e)\n</code>\nIt returns the sorted\
    \ output as a list of characters. What am I doing wrong?\n\n\nA:\n\n<code>sort</code>\
    \ expects a list of lists, but what you are passing is a list of characters. Try\
    \ this instead:\n<code>(define (sort_numbers numbers)\n  (sort (string-&gt;list\
    \ numbers)\n        &lt;\n        (compose string-&gt;number read)))\n</code>\n\
    Or, if you don't want to use <code>compose</code>:\n<code>(define (sort_numbers\
    \ numbers)\n  (sort (string-&gt;list numbers)\n        &lt;\n        (lambda (x)\
    \ (string-&gt;number (read x)))))\n</code>\n", "  (regexp-replace* #rx\"\\\\b(zero|nine|one|two|three|four|five|six|seven|eight)\\\
    \\b\" numbers\n      (hash 'zero 0 'nine 9 'one 1 'two 2 'three 3 'four 4 'five\
    \ 5 'six 6 'seven 7 'eight 8)\n      #:key (\u03BB (x) (match x ((\"zero\") 0)\n\
    \                            ((\"nine\") 9)\n                            ((\"\
    one\") 1)\n                            ((\"two\") 2)\n                       \
    \     ((\"three\") 3)\n                            ((\"four\") 4)\n          \
    \                  ((\"five\") 5)\n                            ((\"six\") 6)\n\
    \                            ((\"seven\") 7)\n                            ((\"\
    eight\") 8)\n                            (#f \"\")\n                         \
    \   ))))\n", "  (string-join (sort (string-split numbers) (lambda (a b) (< (number->string\
    \ (number-&gt;string a)) (number-&gt;string b)))) #\\space))\n</code>\nHowever,\
    \ this produces the error:\n<code>sort_numbers: expects argument of type &lt;number-&gt;string&gt;;\
    \ given one\n</code>\nI had thought that <code>string-split</code> would split\
    \ on spaces and return a list of strings that could be compared with <code>string&lt;?</code>.\n\
    What am I missing here?\n\n\nA:\n\nYou're missing that the list produced by <code>string-split</code>\
    \ is a list of strings. So the use of <code>number-&gt;string</code> isn't appropriate.\n\
    Also, the <code>&lt;</code> and <code>&gt;</code> functions don't work with strings.\
    \ You need to use <code>string&lt;?</code> instead.\nSo:\n<code>(define (sort_numbers\
    \ numbers)\n  (string-join (sort (string-split numbers) (lambda (a b) (string&lt;?\
    \ a b))) #\\space))\n</code>\nAlternatively, using SRFI-41 - \"A Scheme API for\
    \ testing characters and strings\":\n<code>(define (sort_numbers numbers)\n  (string-join\
    \ (sort (string-split numbers) (compose string-ci&lt;? string-normalize-nfd))\
    \ #\\space))\n</code>\n", "  (string-join\n   (sort\n    (map string->number\n\
    \         (split-string numbers \" \"))\n    <)\n   \" \"))\n", "  (cond [(string=?\
    \ numbers \"\") \"\"]\n        [else (string-append (sort_numbers (substring numbers\
    \ (string-index \" \" numbers)))\n                             (substring numbers\
    \ 0 (string-index \" \" numbers))\n                             \" \")]))\n",
  "  (string-join (sort (string-split numbers #\\space) <) #\\space))\n", "  (cond\
    \ [(empty? numbers) empty]\n        [else\n         (string-append (list->string\
    \ (list (list-ref (sort (map string->number (string-split numbers \" \")) <) 0)))\n\
    \                        (string-append \" \" (sort_numbers (substring numbers\
    \ (+ (string-length (list->string (list (list-ref (sort (map string->number (string-split\
    \ numbers \" \")) <) 0)))) 1))))]))\n", "  (define (string-&gt;number str)\n \
    \   (cond [(string=? str \"zero\") 0]\n          [(string=? str \"one\") 1]\n\
    \          [(string=? str \"two\") 2]\n          [(string=? str \"three\") 3]\n\
    \          [(string=? str \"four\") 4]\n          [(string=? str \"five\") 5]\n\
    \          [(string=? str \"six\") 6]\n          [(string=? str \"seven\") 7]\n\
    \          [(string=? str \"eight\") 8]\n          [(string=? str \"nine\") 9]))\n\
    \  (define (number-&gt;string num)\n    (cond [(= num 0) \"zero\"]\n         \
    \ [(= num 1) \"one\"]\n          [(= num 2) \"two\"]\n          [(= num 3) \"\
    three\"]\n          [(= num 4) \"four\"]\n          [(= num 5) \"five\"]\n   \
    \       [(= num 6) \"six\"]\n          [(= num 7) \"seven\"]\n          [(= num\
    \ 8) \"eight\"]\n          [(= num 9) \"nine\"]))\n  (number-&gt;string (sort\
    \ &lt; (map string-&gt;number (string-&gt;list numbers)))))\n</code>\nThis seems\
    \ pretty verbose, but I couldn't think of a cleaner way to do this with built-in\
    \ functions.\n\n\nA:\n\nHere's a solution using only <code>map</code> and <code>filter</code>.\n\
    First, I'll define a function <code>matches</code> that checks whether a given\
    \ string is a valid numeral, and if so, returns a list consisting of that string,\
    \ its index in the list of numerals and its value as an integer.\nI have used\
    \ <code>for/fold</code> to implement <code>matches</code> because I think it is\
    \ slightly more readable than a solution using only <code>filter</code>.\n<code>(define\
    \ numerals '(\"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\"\
    \ \"eight\" \"nine\"))\n", "  (number->word (word->number (string-&gt;list numbers))))\n",
  "  (define (word-&gt;number word)\n    (cond ((string=? word \"zero\") 0)\n    \
    \      ((string=? word \"one\") 1)\n          ((string=? word \"two\") 2)\n  \
    \        ((string=? word \"three\") 3)\n          ((string=? word \"four\") 4)\n\
    \          ((string=? word \"five\") 5)\n          ((string=? word \"six\") 6)\n\
    \          ((string=? word \"seven\") 7)\n          ((string=? word \"eight\"\
    ) 8)\n          ((string=? word \"nine\") 9)))\n  (define (number-&gt;word number)\n\
    \    (cond ((= number 0) \"zero\")\n          ((= number 1) \"one\")\n       \
    \   ((= number 2) \"two\")\n          ((= number 3) \"three\")\n          ((=\
    \ number 4) \"four\")\n          ((= number 5) \"five\")\n          ((= number\
    \ 6) \"six\")\n          ((= number 7) \"seven\")\n          ((= number 8) \"\
    eight\")\n          ((= number 9) \"nine\")))\n  (string-join\n   (map number-&gt;word\n\
    \        (sort &lt;\n              (map word-&gt;number\n                   (string-split\
    \ numbers))))\n   \" \"))\n</code>\nI'm not sure how the problem is supposed to\
    \ be solved. It seems to me like there is a lot of back and forth. I hope I've\
    \ understood the problem correctly.\n", "  (apply string-append (sort (string-split\
    \ numbers #\\space) (lambda (x y) (< (string->number x) (string->number y))))))\n",
  "  (define (string-&gt;number str)\n    (cond\n      [(string=? str \"zero\") 0]\n\
    \      [(string=? str \"one\") 1]\n      [(string=? str \"two\") 2]\n      [(string=?\
    \ str \"three\") 3]\n      [(string=? str \"four\") 4]\n      [(string=? str \"\
    five\") 5]\n      [(string=? str \"six\") 6]\n      [(string=? str \"seven\")\
    \ 7]\n      [(string=? str \"eight\") 8]\n      [(string=? str \"nine\") 9]))\n\
    \  (apply string-append\n         (map string-&gt;number (sort (string-&gt;list\
    \ numbers) &lt;))))\n</code>\n", "  (apply string-append\n         (map number->word\n\
    \              (sort <\n                    (map word->number\n              \
    \           (string-split numbers))))))\n", "  (string-join (sort string<? (string-split\
    \ numbers)) \" \"))\n", "  (string-join (sort (string-split numbers #\\space)\
    \ <) #\\space))\n", "  (define (numerals->numbers)\n    (for/list ((numerals (regexp-match*\
    \ #rx\"(zero|one|two|three|four|five|six|seven|eight|nine)\" numbers)))\n    \
    \  (string->number (match-string 1 numerals))))\n  (for/string ((number (sort\
    \ (numerals->numbers) <)))\n    (number->string number)))", "  (sort (string-split\
    \ numbers #\\space) #:key (lambda (str)\n         (match str\n               [\"\
    zero\" 0]\n               [\"one\" 1]\n               [\"two\" 2]\n          \
    \     [\"three\" 3]\n               [\"four\" 4]\n               [\"five\" 5]\n\
    \               [\"six\" 6]\n               [\"seven\" 7]\n               [\"\
    eight\" 8]\n               [\"nine\" 9]))))\n```\n\n### Prolog\n\n```prolog\n\
    % Prolog solution by ShreevatsaR\n% Main predicate: sort_numbers(Str, Sorted).\n\
    % Sorts a space separated list of natural numbers (from zero to nine) in Str,\n\
    % returning the sorted list in Sorted.\n% Example:\n% ?- sort_numbers(\"three\
    \ one five\", X).\n% X = \"one three five\".\n\ndigits([zero, one, two, three,\
    \ four, five, six, seven, eight, nine]).\nnumber_of_digits(N) :- digits(Digits),\
    \ length(Digits, N).\ndigit_of_digit(D, I) :- digits(Digits), nth0(I, Digits,\
    \ D).\ndigit_of_num(Num, Digit) :- number_of_digits(N), between(0, N, I), digit_of_digit(Digit,\
    \ I), Num is I.\n\nsort_numbers(Str, Sorted) :- split_string(Str, \" \", \"\"\
    , StrList), maplist(to_number, StrList, NumList), sort(0, @=<, NumList, SortedNumList),\
    \ maplist(to_digit, SortedNumList, SortedList), concat_atom(SortedList, \" \"\
    , Sorted).\n\nto_number(Digit, Num) :- digit_of_digit(Digit, Num).\nto_digit(Num,\
    \ Digit) :- digit_of_num(Num, Digit).\n```\n\n### Ruby\n\n```ruby\n# Ruby solution\
    \ by Stefan Kendall\n#\n# Numbers are sorted based on the index of the number\
    \ in\n# NUMBERS.\n#\n# Example:\n#   sort_numbers('three one five", "  (define\
    \ (convert)\n    (cond ((string=? numbers \"zero\") \"0\")\n          ((string=?\
    \ numbers \"one\") \"1\")\n          ((string=? numbers \"two\") \"2\")\n    \
    \      ((string=? numbers \"three\") \"3\")\n          ((string=? numbers \"four\"\
    ) \"4\")\n          ((string=? numbers \"five\") \"5\")\n          ((string=?\
    \ numbers \"six\") \"6\")\n          ((string=? numbers \"seven\") \"7\")\n  \
    \        ((string=? numbers \"eight\") \"8\")\n          ((string=? numbers \"\
    nine\") \"9\")))\n  (define (sort-by-words)\n    (if (null? numbers)\n       \
    \ (list)\n        (append (sort-by-words (remove (first numbers) numbers))\n \
    \               (list (first numbers)))))\n  (regexp-replace* #rx\" \" (apply\
    \ string (map convert (sort-by-words numbers))) \"\"))\n", "  (sort (string-split\
    \ numbers #\\space)\n        (\u03BB (x y) (< (number-from-numberal x) (number-from-numberal\
    \ y)))))\n", "  (string-join (sort (string-split numbers) <) \" \"))\n", "  (define\
    \ nums-to-nums '((\"zero\" . 0) (\"one\" . 1) (\"two\" . 2) (\"three\" . 3) (\"\
    four\" . 4) (\"five\" . 5) (\"six\" . 6) (\"seven\" . 7) (\"eight\" . 8) (\"nine\"\
    \ . 9)))\n  (string-join\n   (sort (map (lambda (num) (string-join (list (string-join\
    \ (list \"#\" (list-ref (list->string (list->list (list-ref (string-split numbers\
    \ \" \") (string->number num)))))) \" \")) (string-split (list-ref (string-split\
    \ numbers \" \") (string->number num)) \"\"))) (string-split (number->string (number->string\
    \ (apply min (map (lambda (num) (list-ref (cdr (assoc num nums-to-nums)) (assoc\
    \ num nums-to-nums))) (string-split numbers \" \"))))) \"\")) (lambda (a b) (<\
    \ (string->number (list-ref (string-split a \" \") 1)) (string->number (list-ref\
    \ (string-split b \" \") 1)))))\n   \" \"))\n", "  ;; convert string to list of\
    \ strings\n  (string-&gt;list numbers)\n  (for/list ([number (in-list numbers)])\n\
    \    (match number\n      [\"zero\" \"0\"]\n      [\"one\" \"1\"]\n      [\"two\"\
    \ \"2\"]\n      [\"three\" \"3\"]\n      [\"four\" \"4\"]\n      [\"five\" \"\
    5\"]\n      [\"six\" \"6\"]\n      [\"seven\" \"7\"]\n      [\"eight\" \"8\"]\n\
    \      [\"nine\" \"9\"]\n      [(error \"Invalid number\")])))\n</code>\nI am\
    \ getting the following error:\n<code>car: expected a pair, but received \"o\"\
    \n</code>\nI have checked DrRacket's section on for/list and it states \"Evaluates\
    \ expr for every value in seq, in order, and collects the results in a list\"\
    \ \nI'm a bit stumped on what is causing this error.\n\n\nA:\n\nYou have some\
    \ errors here:\n<code>(define (sort_numbers numbers)\n  ;; convert string to list\
    \ of strings\n  (string-&gt;list numbers) ;; &lt;&lt; This creates a list of characters\n\
    \  (for/list ([number (in-list numbers)]) ;; &lt;&lt; and now you pass a list\
    \ of characters as `numbers`\n    (match number\n      ...\n</code>\nYou're passing\
    \ a list of characters as the variable <code>numbers</code>, and trying to use\
    \ the values of that list as numbers. Obviously, those are not numbers, but characters,\
    \ hence the error message.\nA simple solution would be to use <code>string-split</code>\
    \ to separate the input string into a list of strings, eg:\n<code>(define (sort_numbers\
    \ numbers)\n  (for/list ([number (in-list (string-split numbers))])\n    (match\
    \ number\n      ...\n</code>\n", "  ;; getting a sequence of numberals\n  (define\
    \ (get-seq-num num)\n    (define (is-numeral? str)\n      (cond ((string=? str\
    \ \"zero\") #t)\n            ((string=? str \"one\") #t)\n            ((string=?\
    \ str \"two\") #t)\n            ((string=? str \"three\") #t)\n            ((string=?\
    \ str \"four\") #t)\n            ((string=? str \"five\") #t)\n            ((string=?\
    \ str \"six\") #t)\n            ((string=? str \"seven\") #t)\n            ((string=?\
    \ str \"eight\") #t)\n            ((string=? str \"nine\") #t)\n            (else\
    \ #f)))\n    (cond ((string=? num \"zero\") 0)\n          ((string=? num \"one\"\
    ) 1)\n          ((string=? num \"two\") 2)\n          ((string=? num \"three\"\
    ) 3)\n          ((string=? num \"four\") 4)\n          ((string=? num \"five\"\
    ) 5)\n          ((string=? num \"six\") 6)\n          ((string=? num \"seven\"\
    ) 7)\n          ((string=? num \"eight\") 8)\n          ((string=? num \"nine\"\
    ) 9)\n          (else -1)))\n  ;; getting a sequence of stringified numbers\n\
    \  (define (get-seq-str num)\n    (cond ((= num 0) \"zero\")\n          ((= num\
    \ 1) \"one\")\n          ((= num 2) \"two\")\n          ((= num 3) \"three\")\n\
    \          ((= num 4) \"four\")\n          ((= num 5) \"five\")\n          ((=\
    \ num 6) \"six\")\n          ((= num 7) \"seven\")\n          ((= num 8) \"eight\"\
    )\n          ((= num 9) \"nine\")\n          (else \" \")))\n  ;; getting a sequence\
    \ of numeral for sorting\n  (define (get-num-seq numbers)\n    (define (get-seq-num\
    \ num)\n      (define (is-numeral? str)\n        (cond ((string=? str \"zero\"\
    ) #t)\n              ((string=? str \"one\") #t)\n              ((string=", " \
    \ (sort (extract-numbers numbers) #&lt;))\n", "  (define numbers_list (string-&gt;list\
    \ numbers))\n  (for ([c (in-list numbers_list)])\n    (when (not (equal? c #\\\
    \ ))\n      (set! numbers_list (cons c numbers_list))))\n  (apply string-append\
    \ (sort numbers_list string&lt;?)))\n</code>\nI'm obviously new to Racket, but\
    \ is there a better way to do this?\nEdit: improved version\n<code>#lang racket\n",
  "  (apply string-append\n         (map (lambda (x) (number->string x))\n       \
    \       (sort (map string->number (string-split numbers)) <))))\n", "  (define\
    \ options '(zero one two three four five six seven eight nine))\n  (string-join\
    \ (sort (map string->number (string-split numbers #\\space)) <) #\\space))", " \
    \ (string-join (sort (string-split numbers #\\space)\n                     number-of-numerals)\
    \ #\\space))\n", "  (sort string-&lt;? (string-&gt;list numbers)))\n", "  (define\
    \ (intt str)\n    (cond [(equal? str \"zero\") 0]\n          [(equal? str \"one\"\
    ) 1]\n          [(equal? str \"two\") 2]\n          [(equal? str \"three\") 3]\n\
    \          [(equal? str \"four\") 4]\n          [(equal? str \"five\") 5]\n  \
    \        [(equal? str \"six\") 6]\n          [(equal? str \"seven\") 7]\n    \
    \      [(equal? str \"eight\") 8]\n          [(equal? str \"nine\") 9]))\n  (cond\
    \ [(equal? numbers \"\") \"\"]\n        [else (string-append (string-append (string-append\
    \ (sort_numbers (string-trim (substring numbers (string-indexof \" \" numbers))))\
    \ \" \") (string-trim (substring numbers 0 (string-indexof \" \" numbers)))) (string-trim\
    \ (substring numbers (+ (string-indexof \" \" numbers) 1) (string-length numbers))))]))",
  "  (string-join (sort (string-split numbers #\\space) <) #\\space))\n", "  (string-join\
    \ (sort (string-split numbers)\n                     (lambda (a b)\n         \
    \              (< (parse-number a) (parse-number b))))\n               \" \"))\n",
  "  (define numbers-list (string-&gt;list numbers))\n  (map string-&gt;number numbers-list))\n\
    </code>\nSo, this is a simple program that I was working on. I was going to make\
    \ a map function that would take a function and a list and then apply the function\
    \ to each element of the list. However, my function doesn't work because the map\
    \ function requires a list, and I'm giving it a string.\nSo, my question is this:\
    \ is there a way to change the string into a list of characters, or is there some\
    \ other way to apply a function to each element of a string?\n\n\nA:\n\nThe <code>map</code>\
    \ function does not require a list as its first argument, but rather a function\
    \ taking one argument. So it is sufficient to say:\n<code>(map string-&gt;number\
    \ (string-&gt;list numbers))\n</code>\nAlternatively, you can write:\n<code>(apply\
    \ map string-&gt;number (string-&gt;list numbers))\n</code>\nor even:\n<code>(apply\
    \ map string-&gt;number (string-split numbers #\\space))\n</code>\n", '  (string-join
    (sort (string-split numbers) string<?)))', "  (define (numeral-to-int numeral)\n\
    \    (cond [(string=? numeral \"zero\") 0]\n          [(string=? numeral \"one\"\
    ) 1]\n          [(string=? numeral \"two\") 2]\n          [(string=? numeral \"\
    three\") 3]\n          [(string=? numeral \"four\") 4]\n          [(string=? numeral\
    \ \"five\") 5]\n          [(string=? numeral \"six\") 6]\n          [(string=?\
    \ numeral \"seven\") 7]\n          [(string=? numeral \"eight\") 8]\n        \
    \  [(string=? numeral \"nine\") 9]))\n  (define (int-to-numeral n)\n    (cond\
    \ [(= n 0) \"zero\"]\n          [(= n 1) \"one\"]\n          [(= n 2) \"two\"\
    ]\n          [(= n 3) \"three\"]\n          [(= n 4) \"four\"]\n          [(=\
    \ n 5) \"five\"]\n          [(= n 6) \"six\"]\n          [(= n 7) \"seven\"]\n\
    \          [(= n 8) \"eight\"]\n          [(= n 9) \"nine\"]))\n  (define nums\
    \ (string-split numbers))\n  (define ints (map numeral-to-int nums))\n  (define\
    \ sorted-ints (quicksort ints))\n  (define (ints-to-string ints)\n    (if (null?\
    \ ints)\n        \"\"\n        (string-append (int-to-numeral (car ints)) \" \"\
    \ (ints-to-string (cdr ints)))))\n  (ints-to-string sorted-ints))\n", "  (string-join\n\
    \   (sort\n    (string-split numbers)\n    <\n    string<?\n    )\n   \" \"\n\
    \   )\n  )\n```\n\nThis solution is much shorter than mine and makes use of more\
    \ of the language's built-in functions.\n\n### The `#:key` keyword argument\n\n\
    The `#:key` keyword argument, when present, is called as a function to transform\
    \ each item as it is compared. For example, in sorting a list of lists by their\
    \ second elements, we could use the expression `(sort (list (list 'b 1) (list\
    \ 'a 2) (list 'd 3) (list 'c 4)) < #:key cadr)`. This passes the function `cadr`\
    \ as the key argument to `sort`. This function is called on each item in the list\
    \ prior to making the comparison. The result is that the list is sorted by the\
    \ second element of each item, so `sort` returns `'((b 1) (c 4) (a 2) (d 3))`.\n\
    \nThe `sort` function knows how to sort strings, but if we want to sort them using\
    \ a different representation, such as `string-ci<?`, we can use `#:key`. For example,\
    \ to sort strings case-insensitively, `(sort '(\"apple\" \"elephant\" \"dog\"\
    ) < #:key string-ci<? )` returns `'(\"apple\" \"dog\" \"elephant\")`.\n\n### Sorting\
    \ numbers\n\nThe `sort` function knows how to sort numbers, but if we want to\
    \ sort them using a different representation, such as characters, we can use `#:key`.\
    \ For example, to sort numbers as if they were strings, `(sort '(3 6 1) < #:key\
    \ number->string)` returns `'(1 3 6)`.\n\n### Sorting strings\n\nThe `sort` function\
    \ knows how to sort strings, but if we want to sort them using a different representation,\
    \ such as characters, we can use `#:key`. For example, to sort strings as if they\
    \ were lists of characters, `(sort '(\"apple\" \"elephant\" \"dog\") < #:key string->list)`\
    \ returns `'(\"apple\" \"dog\" \"elephant\")`.\n\nRacket's `sort` function also\
    \ has a variant that works", "  (define (number-to-int num)\n    (cond ((equal?\
    \ num \"zero\") 0)\n          ((equal? num \"one\") 1)\n          ((equal? num\
    \ \"two\") 2)\n          ((equal? num \"three\") 3)\n          ((equal? num \"\
    four\") 4)\n          ((equal? num \"five\") 5)\n          ((equal? num \"six\"\
    ) 6)\n          ((equal? num \"seven\") 7)\n          ((equal? num \"eight\")\
    \ 8)\n          ((equal? num \"nine\") 9)))\n  (define (int-to-number num)\n \
    \   (cond ((= num 0) \"zero\")\n          ((= num 1) \"one\")\n          ((= num\
    \ 2) \"two\")\n          ((= num 3) \"three\")\n          ((= num 4) \"four\"\
    )\n          ((= num 5) \"five\")\n          ((= num 6) \"six\")\n          ((=\
    \ num 7) \"seven\")\n          ((= num 8) \"eight\")\n          ((= num 9) \"\
    nine\")))\n  (string-join (map int-to-number (sort < (map number-to-int (string-split\
    \ numbers)))) \" \"))\n", "  (string-join\n   (sort (string-split numbers)\n \
    \        (lambda (a b)\n           (< (string->number (regexp-replace #rx\" [a-z]+\"\
    \ (string-capitalize a) \"\"))\n              (string->number (regexp-replace\
    \ #rx\" [a-z]+\" (string-capitalize b) \"\")))))\n   \" \"))\n", "  (sort numbers\n\
    \        string<?\n        (lambda (n)\n          (match n\n            [\"zero\"\
    \ 0]\n            [\"one\" 1]\n            [\"two\" 2]\n            [\"three\"\
    \ 3]\n            [\"four\" 4]\n            [\"five\" 5]\n            [\"six\"\
    \ 6]\n            [\"seven\" 7]\n            [\"eight\" 8]\n            [\"nine\"\
    \ 9]))))\n", "  (string-join\n   (sort\n    (string-split numbers)\n    #:key\
    \ number->string\n    #:cmp string<?\n    #:key number->string)\n   \" \"))\n\
    ```\n\n#### Testing\n\n```\n#lang racket\n", "  (define (convert n)\n    (cond\
    \ [(equal? n \"zero\")  0]\n          [(equal? n \"one\")   1]\n          [(equal?\
    \ n \"two\")   2]\n          [(equal? n \"three\") 3]\n          [(equal? n \"\
    four\")  4]\n          [(equal? n \"five\")  5]\n          [(equal? n \"six\"\
    )   6]\n          [(equal? n \"seven\") 7]\n          [(equal? n \"eight\") 8]\n\
    \          [(equal? n \"nine\")  9]))\n  (define (convertBack n)\n    (cond [(equal?\
    \ n 0)  \"zero\"]\n          [(equal? n 1)  \"one\"]\n          [(equal? n 2)\
    \  \"two\"]\n          [(equal? n 3)  \"three\"]\n          [(equal? n 4)  \"\
    four\"]\n          [(equal? n 5)  \"five\"]\n          [(equal? n 6)  \"six\"\
    ]\n          [(equal? n 7)  \"seven\"]\n          [(equal? n 8)  \"eight\"]\n\
    \          [(equal? n 9)  \"nine\"]))\n  (define (sort_numbers_helper xs)\n  \
    \  (if (empty? xs) empty\n        (let ([n (convert (first xs))])\n          (cons\
    \ (convertBack n) (sort_numbers_helper (rest xs))))))\n  (sort_numbers_helper\
    \ (string-split numbers #\\space)))\n", "  (sort (string-split numbers #\\space)\n\
    \        #:key (lambda (x) (number-to-string (read-symbol x)))\n        #:compare\
    \ string&lt;?))\n", "  (cond [(empty? numbers) numbers]\n        [else\n     \
    \    (sort (string->list numbers) #:key (\u03BB (x) (number-&gt;string (string-&gt;number\
    \ x))))]))\n</code>\n", "  (define (numeral->num n)\n    (cond ((string=? n \"\
    zero\") 0)\n          ((string=? n \"one\") 1)\n          ((string=? n \"two\"\
    ) 2)\n          ((string=? n \"three\") 3)\n          ((string=? n \"four\") 4)\n\
    \          ((string=? n \"five\") 5)\n          ((string=? n \"six\") 6)\n   \
    \       ((string=? n \"seven\") 7)\n          ((string=? n \"eight\") 8)\n   \
    \       ((string=? n \"nine\") 9)))\n  (string-join (sort (map numeral->num (string-split\
    \ numbers)) <) \" \"))\n", "  (string-join\n   (sort string<?\n         (map (lambda\
    \ (word)\n                (case word\n                  ('zero '0)\n         \
    \         ('one '1)\n                  ('two '2)\n                  ('three '3)\n\
    \                  ('four '4)\n                  ('five '5)\n                \
    \  ('six '6)\n                  ('seven '7)\n                  ('eight '8)\n \
    \                 ('nine '9)))\n              (string-split numbers)))\n   \"\
    \ \"))", "  (match numbers [($ \"zero\" xs) (sort_numbers xs)]\n             \
    \   [($ \"one\" xs) (sort_numbers xs)]\n                [($ \"two\" xs) (sort_numbers\
    \ xs)]\n                [($ \"three\" xs) (sort_numbers xs)]\n               \
    \ [($ \"four\" xs) (sort_numbers xs)]\n                [($ \"five\" xs) (sort_numbers\
    \ xs)]\n                [($ \"six\" xs) (sort_numbers xs)]\n                [($\
    \ \"seven\" xs) (sort_numbers xs)]\n                [($ \"eight\" xs) (sort_numbers\
    \ xs)]\n                [($ \"nine\" xs) (sort_numbers xs)]\n                [_\
    \ \"\"]))\n", "  (let ([digits '((zero . 0) (one . 1) (two . 2) (three . 3) (four\
    \ . 4) (five . 5) (six . 6) (seven . 7) (eight . 8) (nine . 9))])\n    (string-join\
    \ (sort (map (lambda (n) (cdr (assoc n digits))) (string-split numbers)) <) \"\
    \ \")))", "  (string-join\n   (sort\n    (string-split numbers #\\space)\n   \
    \ (\u03BB (a b) (string<? a b)))\n    #\\space))\n", "  (define (numsort lst)\n\
    \    (sort lst string<?))\n  (define (num-to-string num)\n    (let ([numword (cond\n\
    \                    [(= num 0) \"zero\"]\n                    [(= num 1) \"one\"\
    ]\n                    [(= num 2) \"two\"]\n                    [(= num 3) \"\
    three\"]\n                    [(= num 4) \"four\"]\n                    [(= num\
    \ 5) \"five\"]\n                    [(= num 6) \"six\"]\n                    [(=\
    \ num 7) \"seven\"]\n                    [(= num 8) \"eight\"]\n             \
    \       [(= num 9) \"nine\"])])\n      numword))\n  (define (string-to-num str)\n\
    \    (let ([num (cond\n                [(\"zero\" equal? str) 0]\n           \
    \     [(\"one\" equal? str) 1]\n                [(\"two\" equal? str) 2]\n   \
    \             [(\"three\" equal? str) 3]\n                [(\"four\" equal? str)\
    \ 4]\n                [(\"five\" equal? str) 5]\n                [(\"six\" equal?\
    \ str) 6]\n                [(\"seven\" equal? str) 7]\n                [(\"eight\"\
    \ equal? str) 8]\n                [(\"nine\" equal? str) 9])])\n      num))\n\
    \  (define (string-list-to-number-list strlist)\n    (map string-to-num strlist))\n\
    \  (define (number-list-to-string-list numlist)\n    (map num-to-string numlist))\n\
    \  (define (string-list-to-string strlist)\n    (string-join strlist))\n  (define\
    \ (string-to-string-list str)\n    (string-split str))\n  (define (string-to-number-list\
    \ str)\n    (string-list-to-number-list (string-to-string-list str)))\n  (define\
    \ (number-list-to-string numlist)\n    (string-list-to-string (number-list-to-string-list\
    \ numlist)))\n  (number-list-to-string (numsort (string-to-number-list numbers))))\n",
  "  (string-join (sort (string-split numbers) string<?)) \" \"))\n", "  (string-join\
    \ (sort (string-&gt;list numbers)\n                     &lt;\n               \
    \      string-&lt;?)\n               \" \"))\n", "  (string-join (sort (regexp-split\
    \ #rx\"\\s+\" numbers)\n                     (lambda (a b)\n                 \
    \      (< (string->number (string-trim a))\n                          (string->number\
    \ (string-trim b)))))\n               \" \"))\n", "  (map number->string\n   \
    \    (sort (map string->number\n                  (string-split numbers #\\space))\n\
    \             <)))\n", "  (cond [(string? numbers)\n         (string-join (sort-list\
    \ (string-split numbers)))]\n        [(list? numbers)\n         (string-join (sort-list\
    \ numbers))]))\n", "  (define (index_of str)\n    (cond ((string=? str \"zero\"\
    ) 0)\n          ((string=? str \"one\") 1)\n          ((string=? str \"two\")\
    \ 2)\n          ((string=? str \"three\") 3)\n          ((string=? str \"four\"\
    ) 4)\n          ((string=? str \"five\") 5)\n          ((string=? str \"six\"\
    ) 6)\n          ((string=? str \"seven\") 7)\n          ((string=? str \"eight\"\
    ) 8)\n          ((string=? str \"nine\") 9)))\n  (define (stringify n)\n    (cond\
    \ ((= n 0) \"zero\")\n          ((= n 1) \"one\")\n          ((= n 2) \"two\"\
    )\n          ((= n 3) \"three\")\n          ((= n 4) \"four\")\n          ((=\
    \ n 5) \"five\")\n          ((= n 6) \"six\")\n          ((= n 7) \"seven\")\n\
    \          ((= n 8) \"eight\")\n          ((= n 9) \"nine\")))\n  (define (stringify-list\
    \ list)\n    (define (iter l)\n      (if (null? l)\n          \"\"\n         \
    \ (string-append (stringify (car l)) \" \" (iter (cdr l)))))\n    (iter list))\n\
    \  (define (sort l)\n    (cond ((null? l) '())\n          ((null? (cdr l)) l)\n\
    \          (else (let ((pivot (car l))\n                       (others (cdr l)))\n\
    \                  (let ((left (filter (lambda (x) (< x pivot)) others))\n   \
    \                     (right (filter (lambda (x) (>= x pivot)) others)))\n   \
    \                 (append (sort left) (list pivot) (sort right)))))))\n  (define\
    \ (filter pred l)\n    (cond ((null? l) '())\n          ((pred (car l)) (cons\
    \ (car l) (filter pred (cdr l))))\n          (else (filter pred (cdr l)))))\n\
    \  (stringify-list (sort (map index_of (string-split numbers #\\space)))))", " \
    \ (sort (split numbers \" \") string<))\n", "  (define (word_to_number word)\n\
    \    (cond\n      [(equal? word \"zero\") 0]\n      [(equal? word \"one\") 1]\n\
    \      [(equal? word \"two\") 2]\n      [(equal? word \"three\") 3]\n      [(equal?\
    \ word \"four\") 4]\n      [(equal? word \"five\") 5]\n      [(equal? word \"\
    six\") 6]\n      [(equal? word \"seven\") 7]\n      [(equal? word \"eight\") 8]\n\
    \      [(equal? word \"nine\") 9]))\n  (define (number_to_word number)\n    (cond\n\
    \      [(equal? number 0) \"zero\"]\n      [(equal? number 1) \"one\"]\n     \
    \ [(equal? number 2) \"two\"]\n      [(equal? number 3) \"three\"]\n      [(equal?\
    \ number 4) \"four\"]\n      [(equal? number 5) \"five\"]\n      [(equal? number\
    \ 6) \"six\"]\n      [(equal? number 7) \"seven\"]\n      [(equal? number 8) \"\
    eight\"]\n      [(equal? number 9) \"nine\"]))\n  (define (map-string string fn)\n\
    \    (let loop ([s string] [acc '()])\n      (if (empty? s)\n          (list->string\
    \ (reverse acc))\n          (loop (rest s) (cons (fn (first s)) acc)))))\n  (let*\
    \ ([words (string-split numbers)]\n         [sorted (quicksort (for/list ([word\
    \ words]) (word_to_number word)))]\n         [result (map-string (list->string\
    \ (for/list ([number sorted]) (number_to_word number))) char-upcase)])\n    result))\n\
    ```\n\n```\n#lang racket\n", "  (define num-to-numeral\n    (make-hash\n     'zero\
    \ 0\n     'one 1\n     'two 2\n     'three 3\n     'four 4\n     'five 5\n   \
    \  'six 6\n     'seven 7\n     'eight 8\n     'nine 9))\n  (define numeral-to-num\n\
    \    (make-hash\n     0 'zero\n     1 'one\n     2 'two\n     3 'three\n     4\
    \ 'four\n     5 'five\n     6 'six\n     7 'seven\n     8 'eight\n     9 'nine))\n\
    \  (define nums (string-split numbers #\\space))\n  (define nums-as-nums (map\
    \ (lambda (x) (hash-ref num-to-numeral x 0)) nums))\n  (define sorted-nums (sort\
    \ nums-as-nums <))\n  (map (lambda (x) (hash-ref numeral-to-num x 'zero)) sorted-nums))\n",
  "  (string-join (sort (string-split numbers #\\space) string<?))\n  )\n", "  (define\
    \ (digits->numbers digits)\n    (map (lambda (s) (match s\n                  \
    \         [(list 'z e r o) 0]\n                           [(list 'o n e) 1]\n\
    \                           [(list 't w o) 2]\n                           [(list\
    \ 't h r e e) 3]\n                           [(list 'f o u r) 4]\n           \
    \                [(list 'f i v e) 5]\n                           [(list 's i x)\
    \ 6]\n                           [(list 's e v e n) 7]\n                     \
    \      [(list 'e i g h t) 8]\n                           [(list 'n i n e) 9]))\n\
    \           digits))\n  (display-line (map number->string (sort < (digits->numbers\
    \ (string->list numbers)))))\n  )\n", "  (define (numbers-&gt;list words)\n  \
    \  (apply string-&gt;list (map (lambda (x) (string-&gt;number (number-&gt;string\
    \ x))) (string-&gt;list words))))\n  (define (list-&gt;numbers lst)\n    (apply\
    \ list-&gt;string (map (lambda (x) (number-&gt;string x)) lst)))\n  (list-&gt;numbers\
    \ (sort numbers-&gt;list &lt;)))\n</code>\nI would like to use the definition\
    \ of <code>sort</code> as a guide on how to write my <code>sort-numbers</code>\
    \ function, but I am not sure how to get the same signature.\n\n\nA:\n\nWith no\
    \ knowledge of Racket, the first difference I notice between the two signatures\
    \ is that your <code>sort-numbers</code> takes a single argument, and the <code>sort</code>\
    \ takes two.\nI'm not an expert on functional programming, but I have to imagine\
    \ that when you have only one argument, you are passing in a single list/string\
    \ and having it sorted. I can't imagine a function that takes only one argument\
    \ that does not just manipulate that single argument in some way. In the case\
    \ of <code>sort</code>, you are passing in a list/string, and a comparison.\n\
    The <code>sort</code> function is using a key to determine how to compare the\
    \ items in the list, which allows it to do a secondary sort. The second argument\
    \ is the key function, and the first argument is the list that you are sorting.\n",
  "  (string-join (sort (string-&gt;list numbers) (lambda (x y) (&lt; (string-&gt;number\
    \ (string x)) (string-&gt;number (string y))))) \" \"))\n</code>\n", "  (define\
    \ (string-&gt;number-list string)\n    (map (lambda (word)\n           (cond ((equal?\
    \ word \"zero\") 0)\n                 ((equal? word \"one\") 1)\n            \
    \     ((equal? word \"two\") 2)\n                 ((equal? word \"three\") 3)\n\
    \                 ((equal? word \"four\") 4)\n                 ((equal? word \"\
    five\") 5)\n                 ((equal? word \"six\") 6)\n                 ((equal?\
    \ word \"seven\") 7)\n                 ((equal? word \"eight\") 8)\n         \
    \        ((equal? word \"nine\") 9)))\n         (string-split string #\\space)))\n\
    \  (define (number-list-&gt;string number-list)\n    (string-join (map number-&gt;string\
    \ number-list) \" \"))\n  (number-list-&gt;string (sort (string-&gt;number-list\
    \ numbers) &lt;)))\n</code>\n", "  (let* ([numbers (string-split numbers)]\n \
    \        [numbers (map (lambda (x) (string->number (string-replace \"zero\" \"\
    0\" x))) numbers)]\n         [numbers (map number->string numbers)])\n    (string-join\
    \ numbers \" \")))", "  (sort (string-&gt;list numbers) string&lt;=?))\n", " \
    \ (string-join (sort (string-&gt;list numbers) &lt;) \" \"))\n", "  (string-join\n\
    \   (sort\n    (map string->number\n         (string-split (regexp-replace* #rx\"\
    \\\\W+\" numbers \" \") #\\space))\n    <)\n   \" \"))\n", "  (cond\n    [(empty?\
    \ numbers)\n     '()]\n    [else\n     (build-list (length numbers)\n        \
    \         (lambda (i)\n                   (list-ref (sort (map string->number\
    \ (string-split numbers #\\space)) <) i)))]))\n", "  (let ([answer (map (\u03BB\
    \ (x) (cond [(string=? x \"zero\") 0]\n                                    [(string=?\
    \ x \"one\") 1]\n                                    [(string=? x \"two\") 2]\n\
    \                                    [(string=? x \"three\") 3]\n            \
    \                        [(string=? x \"four\") 4]\n                         \
    \           [(string=? x \"five\") 5]\n                                    [(string=?\
    \ x \"six\") 6]\n                                    [(string=? x \"seven\") 7]\n\
    \                                    [(string=? x \"eight\") 8]\n            \
    \                        [(string=? x \"nine\") 9]))\n                     (string-split\
    \ numbers #\\space))])\n    (string-join (map (\u03BB (x) (cond [(= x 0) \"zero\"\
    ]\n                                    [(= x 1) \"one\"]\n                   \
    \                 [(= x 2) \"two\"]\n                                    [(= x\
    \ 3) \"three\"]\n                                    [(= x 4) \"four\"]\n    \
    \                                [(= x 5) \"five\"]\n                        \
    \            [(= x 6) \"six\"]\n                                    [(= x 7) \"\
    seven\"]\n                                    [(= x 8) \"eight\"]\n          \
    \                          [(= x 9) \"nine\"]))\n                       (sort\
    \ (map number->string answer) <))\n              #\\space)))\n", "  (let ([number-order\
    \ '(\"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"\
    eight\" \"nine\")])\n    (string-join\n     (sort number-order <\n           (string-split\
    \ numbers #\\space))\n     #\\space)))\n```\n\n```racket\n#lang racket\n", " \
    \ (sort (parse_numbers numbers) <))\n", "  (let* ([nums (string-split numbers)]\n\
    \         [len (length nums)]\n         [sorted (sort (\u03BB (x y) (< (number-of-nums\
    \ x) (number-of-nums y))) nums)])\n    (if (= 1 len)\n        (string-join sorted)\n\
    \        (string-join sorted \" \"))))\n", "  (define (convert-to-number number)\n\
    \    (cond\n      ((string=? number \"zero\") 0)\n      ((string=? number \"one\"\
    ) 1)\n      ((string=? number \"two\") 2)\n      ((string=? number \"three\")\
    \ 3)\n      ((string=? number \"four\") 4)\n      ((string=? number \"five\")\
    \ 5)\n      ((string=? number \"six\") 6)\n      ((string=? number \"seven\")\
    \ 7)\n      ((string=? number \"eight\") 8)\n      ((string=? number \"nine\"\
    ) 9)))\n  (define (convert-to-string number)\n    (cond\n      ((= number 0) \"\
    zero\")\n      ((= number 1) \"one\")\n      ((= number 2) \"two\")\n      ((=\
    \ number 3) \"three\")\n      ((= number 4) \"four\")\n      ((= number 5) \"\
    five\")\n      ((= number 6) \"six\")\n      ((= number 7) \"seven\")\n      ((=\
    \ number 8) \"eight\")\n      ((= number 9) \"nine\")))\n  (string-join (map convert-to-string\
    \ (sort (map convert-to-number (string-split numbers \" \")) <)) \" \"))\n", " \
    \ (string-join\n   (sort\n    (string-split numbers #\\space)\n    (lambda (a\
    \ b)\n      (let ((digit-of-a (map-string-to-digit a))\n            (digit-of-b\
    \ (map-string-to-digit b)))\n        (< digit-of-a digit-of-b))))\n   #\\space))\n",
  "  (let* ((numbers (string-split numbers #\\space))\n         (numbers (map number->string\n\
    \                       (sort (map string->number numbers)\n                 \
    \            <))))\n    (string-join numbers #\\space)))", "  (sort (string-split\
    \ numbers) string<?))\n", "  (define (map-number number)\n    (case number\n \
    \     ('zero 0)\n      ('one 1)\n      ('two 2)\n      ('three 3)\n      ('four\
    \ 4)\n      ('five 5)\n      ('six 6)\n      ('seven 7)\n      ('eight 8)\n  \
    \    ('nine 9)))\n  (apply string-append\n         (for/list ([i (sort (map map-number\
    \ (string-split numbers)) <)])\n           (case i\n             (0 \"zero\")\n\
    \             (1 \"one\")\n             (2 \"two\")\n             (3 \"three\"\
    )\n             (4 \"four\")\n             (5 \"five\")\n             (6 \"six\"\
    )\n             (7 \"seven\")\n             (8 \"eight\")\n             (9 \"\
    nine\")))))\n", "  (let* ([numeral-&gt;-number (lambda (c) (hash-ref {'zero 0\
    \ 'one 1 'two 2 'three 3 'four 4 'five 5 'six 6 'seven 7 'eight 8 'nine 9} c))]\n\
    \         [sort-by-number (lambda (numbers) (sort (map numeral-&gt;-number (string-&gt;list\
    \ numbers)) &lt;))]\n         [number-&gt;-numeral (lambda (n) (hash-ref {0 'zero\
    \ 1 'one 2 'two 3 'three 4 'four 5 'five 6 'six 7 'seven 8 'eight 9 'nine} n))]\n\
    \         [sort-by-numeral (lambda (numbers) (map number-&gt;-numeral (sort numbers\
    \ &lt;)))]\n         [space-join (lambda (numbers) (string-join numbers \" \"\
    ))])\n    (space-join (sort-by-numeral (sort-by-number numbers)))))\n</code>\n\
    I feel this is much more lisp-like than the other answers, but I am not sure if\
    \ this is the best way to do it in racket.\nI would appreciate feedback on:\n\n\
    Using let* instead of let-values to create the local functions.\nUsing (string-join\
    \ ...) and (string-split ...) for strings, instead of (list-join ...) and (list-split\
    \ ...) for lists.\nUsing (map ...) to convert a list of characters to a list of\
    \ numbers, then converting back.\n\nEDIT:\nI found this example function in a\
    \ racket tutorial, and I find it easier to understand:\n<code>(define (sort-numbers-tutorial\
    \ numbers)\n  (apply string-append\n         (map string-&gt;number\n        \
    \      (sort (string-split numbers #\\space) &lt;))))\n</code>\nI find this easier\
    \ to understand than my own answer, but I do not like that it uses a lot of string\
    \ manipulation functions and the apply function.\nEDIT 2:\n\nI added a hash-ref\
    \ for both numbers->numeral and numeral->number.\nI changed \"sort\" to \"sort\"\
    \n\n\n\nA:\n\nI'm not familiar with racket, so I'll try to answer your general\
    \ questions\n", "  (sort numbers (lambda (x y)\n                  (< (number x)\
    \ (number y)))))\n", "  (string-join (sort (string-split numbers #\\space) string<?)))\n",
  "  (letrec ([num-map (make-hash)]\n           [number-&gt;num-numeric\n        \
    \    (lambda (number)\n              (hash-ref num-map number #f))]\n        \
    \   [num-numeric-&gt;number\n            (lambda (num-numeric)\n             \
    \ (hash-ref num-map num-numeric #f))]\n           [init-hash\n            (lambda\
    \ ()\n              (hash-set! num-map \"zero\" 0)\n              (hash-set! num-map\
    \ \"one\" 1)\n              (hash-set! num-map \"two\" 2)\n              (hash-set!\
    \ num-map \"three\" 3)\n              (hash-set! num-map \"four\" 4)\n       \
    \       (hash-set! num-map \"five\" 5)\n              (hash-set! num-map \"six\"\
    \ 6)\n              (hash-set! num-map \"seven\" 7)\n              (hash-set!\
    \ num-map \"eight\" 8)\n              (hash-set! num-map \"nine\" 9))]\n     \
    \      [numbers-&gt;numeric\n            (lambda (numbers)\n              (map\
    \ number-&gt;num-numeric (string-split numbers #\\space)))]\n           [numeric-&gt;numbers\n\
    \            (lambda (numeric)\n              (map num-numeric-&gt;number numeric))]\n\
    \           [sort-numbers\n            (lambda (numbers)\n              (let*\
    \ ([numeric (numbers-&gt;numeric numbers)]\n                     [sorted-numeric\
    \ (sort numeric &lt;)])\n                (string-join (numeric-&gt;numbers sorted-numeric)\
    \ #\\space)))])\n    (init-hash)\n    (sort-numbers numbers)))\n</code>\nThis\
    \ works fine in DrRacket, but the CodeEval tests fail due to timeouts. It seems\
    \ like the <code>sort</code> call is taking too long, but I don't know why. I've\
    \ tried replacing the <code>hash-ref</code> calls with <code>assoc</code> and\
    \ building a list at initialization, but the timeouts persist.\nAny suggestions\
    \ on how to improve the performance of", "  (display (sort (string-&gt;list numbers)\
    \ #:key (lambda (char) (char-&gt;integer char))))\n  (string-join (sort (string-&gt;list\
    \ numbers) #:key (lambda (char) (char-&gt;integer char))) \"\"))\n", "  (define\
    \ (number-to-value str)\n    (cond ((equal? str \"zero\") 0)\n          ((equal?\
    \ str \"one\") 1)\n          ((equal? str \"two\") 2)\n          ((equal? str\
    \ \"three\") 3)\n          ((equal? str \"four\") 4)\n          ((equal? str \"\
    five\") 5)\n          ((equal? str \"six\") 6)\n          ((equal? str \"seven\"\
    ) 7)\n          ((equal? str \"eight\") 8)\n          ((equal? str \"nine\") 9)))\n\
    \  (define (value-to-number value)\n    (cond ((= value 0) \"zero\")\n       \
    \   ((= value 1) \"one\")\n          ((= value 2) \"two\")\n          ((= value\
    \ 3) \"three\")\n          ((= value 4) \"four\")\n          ((= value 5) \"five\"\
    )\n          ((= value 6) \"six\")\n          ((= value 7) \"seven\")\n      \
    \    ((= value 8) \"eight\")\n          ((= value 9) \"nine\")))\n  (define (sort-helper\
    \ str)\n    (value-to-number (sort (map number-to-value (string-split str \" \"\
    )) <)))\n  (string-join (sort-helper numbers) \" \"))\n", "  (displayln numbers)\n\
    \  (string-join (sort (string-&gt;list numbers) string&lt;?) \" \"))\n", "  (string-join\n\
    \   (sort string&lt;?\n         (string-split numbers \" \"))\n   \" \"))\n",
  "  (string-join (sort (string-split numbers) (lambda (a b) (< (numeral-&gt;int a)\
    \ (numeral-&gt;int b)))) \" \"))\n", "  (sort (string-split numbers #\\space)\
    \ #:key (lambda (numeral) (number-from-words numeral))))\n", "  (apply string-append\
    \ (sort (string-split numbers #\\space) string<?)))\n\n", "  (define (get-position\
    \ numeral)\n    (cond [(equal? numeral \"zero\") 0]\n          [(equal? numeral\
    \ \"one\") 1]\n          [(equal? numeral \"two\") 2]\n          [(equal? numeral\
    \ \"three\") 3]\n          [(equal? numeral \"four\") 4]\n          [(equal? numeral\
    \ \"five\") 5]\n          [(equal? numeral \"six\") 6]\n          [(equal? numeral\
    \ \"seven\") 7]\n          [(equal? numeral \"eight\") 8]\n          [(equal?\
    \ numeral \"nine\") 9]))\n  (define (numeral-list)\n    (let loop ([numeral-string\
    \ numbers] [lst '()])\n      (cond [(empty? numeral-string) lst]\n           \
    \ [else (loop (rest numeral-string) (cons (get-position (first numeral-string))\
    \ lst))])))\n  (define (unparse-numeral numeral)\n    (cond [(= numeral 0) \"\
    zero\"]\n          [(= numeral 1) \"one\"]\n          [(= numeral 2) \"two\"]\n\
    \          [(= numeral 3) \"three\"]\n          [(= numeral 4) \"four\"]\n   \
    \       [(= numeral 5) \"five\"]\n          [(= numeral 6) \"six\"]\n        \
    \  [(= numeral 7) \"seven\"]\n          [(= numeral 8) \"eight\"]\n          [(=\
    \ numeral 9) \"nine\"]))\n  (define (numerals-unparse lst)\n    (let loop ([numerals\
    \ lst] [str \"\"])\n      (cond [(empty? numerals) str]\n            [else (loop\
    \ (rest numerals) (string-append str (unparse-numeral (first numerals)) \" \"\
    ))])))\n  (numerals-unparse (sort numeral-list <)))\n```\n## [Problem 9](https://www.codewars.com/kata/5b37a50642b27ebf2e000010)\
    \ - `difference-list`\n```racket\n#lang racket\n", "  (define (string-&gt;number\
    \ s)\n    (let-values ([(n x) (string-ci-&gt;number s)])\n      (if x n -1)))\n\
    \  (define (number-&gt;string n)\n    (number-&gt;string/ci n (not (string=? (substring\
    \ numbers 0 5) \"three\"))))\n  (define (string-&gt;&lt; s1 s2)\n    (&lt; (string-&gt;number\
    \ s1) (string-&gt;number s2)))\n  (define (string-&gt;&gt; s1 s2)\n    (&gt; (string-&gt;number\
    \ s1) (string-&gt;number s2)))\n  (string-join (sort (string-split numbers #\\\
    space) string-&gt;&lt;) #\\space))\n", "  (cond\n    ((or (equal? numbers \"\"\
    ) (equal? numbers \" \")) \"\")\n    ((equal? numbers \"zero\") \"zero\")\n  \
    \  ((equal? numbers \"one\") \"one\")\n    ((equal? numbers \"two\") \"two\")\n\
    \    ((equal? numbers \"three\") \"three\")\n    ((equal? numbers \"four\") \"\
    four\")\n    ((equal? numbers \"five\") \"five\")\n    ((equal? numbers \"six\"\
    ) \"six\")\n    ((equal? numbers \"seven\") \"seven\")\n    ((equal? numbers \"\
    eight\") \"eight\")\n    ((equal? numbers \"nine\") \"nine\")\n    ((equal? numbers\
    \ \"ten\") \"ten\")\n    ((equal? numbers \"eleven\") \"eleven\")\n    ((equal?\
    \ numbers \"twelve\") \"twelve\")\n    ((equal? numbers \"thirteen\") \"thirteen\"\
    )\n    ((equal? numbers \"fourteen\") \"fourteen\")\n    ((equal? numbers \"fifteen\"\
    ) \"fifteen\")\n    ((equal? numbers \"sixteen\") \"sixteen\")\n    ((equal? numbers\
    \ \"seventeen\") \"seventeen\")\n    ((equal? numbers \"eighteen\") \"eighteen\"\
    )\n    ((equal? numbers \"nineteen\") \"nineteen\")\n    ((equal? numbers \"twenty\"\
    ) \"twenty\")\n    ((equal? numbers \"thirty\") \"thirty\")\n    ((equal? numbers\
    \ \"forty\") \"forty\")\n    ((equal? numbers \"fifty\") \"fifty\")\n    ((equal?\
    \ numbers \"sixty\") \"sixty\")\n    ((equal? numbers \"seventy\") \"seventy\"\
    )\n    ((equal? numbers \"eighty\") \"eighty\")\n    ((equal? numbers \"ninety\"\
    ) \"ninety\")\n    ((equal? numbers \"hundred\") \"hundred\")\n    ((equal? numbers\
    \ \"thousand\") \"thousand\")\n    ((equal? numbers \"million\") \"million\")\n\
    \    ((equal? numbers \"billion\") \"billion\")\n    ((equal? numbers \"trillion\"\
    ) \"trillion\")\n    ((equal? numbers \"quadrillion\") \"quadrillion\")\n    ((equal?\
    \ numbers \"quintillion\") \"quintillion\")\n    ((equal? numbers \"sextillion\"\
    ) \"sextillion\")\n", "  (sort string<? (string-split numbers #\\space)))\n",
  "  (string-join (sort (string-split numbers) <) \" \"))\n", "  (string-join (sort\
    \ (string-split numbers #\\space) (lambda (x y) (< (word-&gt;number x) (word-&gt;number\
    \ y)))) #\\space))\n", "  (cond\n    [(equal? numbers \"\") \"\"]\n    [else (string-append\n\
    \           (first (sort (string-split numbers \" \") string<?))\n           \"\
    \ \"\n           (sort_numbers (substring (string-join (rest (string-split numbers\
    \ \" \")) \" \") 0 (- (string-length (string-join (rest (string-split numbers\
    \ \" \")) \" \")) 1))))]))\n", "  (define (sort-by-value numbers-list)\n    (sort\
    \ (for/list ([elm numbers-list])\n            (cons (string->number (string-join\
    \ (regexp-match* #rx\"\\d+\" elm))) elm))\n          <\n          #:key car))\n\
    \  (string-join (sort-by-value (string-split numbers #rx\"\\s+\"))))\n", "  (string-join\n\
    \   (sort\n    (string-split numbers #\\space)\n    (lambda (number1 number2)\n\
    \      (let ((number-one (number->string (string->number number1)))\n        \
    \    (number-two (number->string (string->number number2))))\n        (if (string-ci=?\
    \ number-one number-two)\n            #f\n            (string-ci<? number-one\
    \ number-two)))))\n   #\\space))\n```\n\n## Problem 3\n```#lang racket\n", " \
    \ (string-join (sort (string-split numbers #\\space) (\u03BB (a b) (andlt; (string->number\
    \ a) (string->number b)))) #\\space))\n```\n\n```\n#lang racket\n", "  (define\
    \ (pair-numerals-numbers pairs)\n    (map (lambda (pair)\n           (define digit\
    \ (first pair))\n           (define numeral (second pair))\n           (list numeral\
    \ digit))\n         pairs))\n  (define (sort-pairs-by-digit pairs)\n    (sort\
    \ pairs <\n          (lambda (a b)\n            (define (digit-pair pair)\n  \
    \            (second pair))\n            (define digit-a (digit-pair a))\n   \
    \         (define digit-b (digit-pair b))\n            (number<? digit-a digit-b))))\n\
    \  (define (digit-numerals-pairs pairs)\n    (map (lambda (pair)\n           (define\
    \ numeral (first pair))\n           (define digit (second pair))\n           (list\
    \ digit numeral))\n         pairs))\n  (define (sort-digit-numerals-pairs pairs)\n\
    \    (sort pairs <\n          (lambda (a b)\n            (define (numerals-pair\
    \ pair)\n              (second pair))\n            (define numerals-a (numerals-pair\
    \ a))\n            (define numerals-b (numerals-pair b))\n            (string<?\
    \ numerals-a numerals-b))))\n  (define (join-sorted-numerals-pairs pairs)\n  \
    \  (string-join (map (lambda (pair)\n                        (second pair))\n\
    \                      pairs)\n                 \" \"))\n  (define (pair-numerals-with-numbers\
    \ numerals)\n    (for/list ([numeral (in-list (string-split numerals))])\n   \
    \   (list numeral (numerals->number numeral))))\n  (define (numerals->number numeral)\n\
    \    (cond\n      [numeral \"zero\"] [numeral \"one\"] [numeral \"two\"] [numeral\
    \ \"three\"] [numeral \"four\"]\n      [numeral \"five\"] [numeral \"six\"] [numeral\
    \ \"seven\"] [numeral \"eight\"] [numeral \"nine\"]\n      [else (error \"Invalid\
    \ numeral.\")]))\n  (define (numerals-pairs (numerals-as-string))\n    (pair-numerals-with",
  "  (match (string-split numbers #\\space)\n    ((list) \"\")\n    ((list hd) hd)\n\
    \    ((list hd1 hd2)\n     (if (&lt; (number-&gt;string (car (regexp-match #rx\"\
    \\d+\" hd1)))\n            (number-&gt;string (car (regexp-match #rx\"\\d+\" hd2))))\n\
    \         (string-join (list hd1 hd2) #\\space)\n         (string-join (list hd2\
    \ hd1) #\\space)))\n    ((list hd1 hd2 hd3)\n     (string-join (list (string-append\
    \ (sort_numbers (string-join (list hd1 hd2) #\\space)) #\\space hd3)\n       \
    \                  (string-append (sort_numbers (string-join (list hd1 hd3) #\\\
    space)) #\\space hd2)\n                         (string-append (sort_numbers (string-join\
    \ (list hd2 hd3) #\\space)) #\\space hd1))\n                  #\\space))))\n</code>\n\
    \nI would like a review of the code for any problems. If there are problems, I\
    \ would also like a suggestion for possible solutions.\nI would also like to know\
    \ whether this can be solved in a better way.\n\n\n\nA:\n\nThere are two obvious\
    \ problems with your code:\n\nIt doesn't work for strings with more than three\
    \ items (your code crashes with a contract violation error).\nIt calls itself\
    \ recursively in a really inefficient way.\n\nThe second problem is the most serious,\
    \ because it produces a worst-case performance of <code>O(n^2)</code> (that's\
    \ the quadratic complexity that you were talking about).\nThe way to implement\
    \ this is by using a \"divide and conquer\" approach: in other words, first split\
    \ the input into two parts, then sort each part separately, and finally combine\
    \ the two sorted lists, in order to get the final result.\nIf you were using a\
    \ language that allows multiple assignment (like Python), the code would look\
    \ something like this:\n<code>def sort_numbers(numbers):\n    if len(numbers",
  "  (define (letter-&gt;num word)\n    (cond\n      [(string=? word \"zero\") 0]\n\
    \      [(string=? word \"one\") 1]\n      [(string=? word \"two\") 2]\n      [(string=?\
    \ word \"three\") 3]\n      [(string=? word \"four\") 4]\n      [(string=? word\
    \ \"five\") 5]\n      [(string=? word \"six\") 6]\n      [(string=? word \"seven\"\
    ) 7]\n      [(string=? word \"eight\") 8]\n      [(string=? word \"nine\") 9]))\n\
    \  (string-join\n   (map number-&gt;string\n        (sort (map letter-&gt;num\
    \ (string-split numbers #\\space)) &lt;))\n   \" \"))\n</code>\n", "  (define\
    \ (word->numeral word)\n    (cond\n      [(string=? word \"zero\") 0]\n      [(string=?\
    \ word \"one\") 1]\n      [(string=? word \"two\") 2]\n      [(string=? word \"\
    three\") 3]\n      [(string=? word \"four\") 4]\n      [(string=? word \"five\"\
    ) 5]\n      [(string=? word \"six\") 6]\n      [(string=? word \"seven\") 7]\n\
    \      [(string=? word \"eight\") 8]\n      [(string=? word \"nine\") 9]))\n \
    \ (define (numeral->word numeral)\n    (cond\n      [(= numeral 0) \"zero\"]\n\
    \      [(= numeral 1) \"one\"]\n      [(= numeral 2) \"two\"]\n      [(= numeral\
    \ 3) \"three\"]\n      [(= numeral 4) \"four\"]\n      [(= numeral 5) \"five\"\
    ]\n      [(= numeral 6) \"six\"]\n      [(= numeral 7) \"seven\"]\n      [(= numeral\
    \ 8) \"eight\"]\n      [(= numeral 9) \"nine\"]))\n  (define (sort-by-numeral\
    \ words)\n    (sort (map word->numeral words) <))\n  (apply string-append (map\
    \ numeral->word (sort-by-numeral (string-split numbers #\\space)))))\n", "  (define\
    \ lst-numbers (string-split numbers #\\space))\n  (define ordinals (map ord->int\
    \ lst-numbers))\n  (define sorted-ordinals (sort < ordinals))\n  (define sorted-numbers\
    \ (map int->ord sorted-ordinals))\n  (define (int->ord n)\n    (cond ((= n 0)\
    \ \"zero\")\n          ((= n 1) \"one\")\n          ((= n 2) \"two\")\n      \
    \    ((= n 3) \"three\")\n          ((= n 4) \"four\")\n          ((= n 5) \"\
    five\")\n          ((= n 6) \"six\")\n          ((= n 7) \"seven\")\n        \
    \  ((= n 8) \"eight\")\n          ((= n 9) \"nine\")))\n  (define (ord->int ord)\n\
    \    (cond ((string=? ord \"zero\") 0)\n          ((string=? ord \"one\") 1)\n\
    \          ((string=? ord \"two\") 2)\n          ((string=? ord \"three\") 3)\n\
    \          ((string=? ord \"four\") 4)\n          ((string=? ord \"five\") 5)\n\
    \          ((string=? ord \"six\") 6)\n          ((string=? ord \"seven\") 7)\n\
    \          ((string=? ord \"eight\") 8)\n          ((string=? ord \"nine\") 9)))\n\
    \  (string-join sorted-numbers #\\space))", "  (cond [(empty? numbers) \"\"]\n\
    \        [else (sort-in (first numbers) (sort_numbers (rest numbers)))]))\n",
  "  (define num-to-int (hash \"zero\" 0 \"one\" 1 \"two\" 2 \"three\" 3 \"four\"\
    \ 4 \"five\" 5 \"six\" 6 \"seven\" 7 \"eight\" 8 \"nine\" 9))\n  (define int-to-num\
    \ (hash 0 \"zero\" 1 \"one\" 2 \"two\" 3 \"three\" 4 \"four\" 5 \"five\" 6 \"\
    six\" 7 \"seven\" 8 \"eight\" 9 \"nine\"))\n  (define (number-at position)\n \
    \   (string-ref (list-ref (string-split numbers #\\space) position) 0))\n  (define\
    \ (swap position1 position2)\n    (list-set (string-split numbers #\\space) position1\
    \ (number-at position2))\n    (list-set (string-split numbers #\\space) position2\
    \ (number-at position1)))\n  (define (compare-and-swap position1 position2)\n\
    \    (if (&lt; (hash-ref num-to-int (number-at position1)) (hash-ref num-to-int\
    \ (number-at position2)))\n        (swap position1 position2)))\n  (define (sort-numbers-rec\
    \ position)\n    (compare-and-swap position (+ position 1))\n    (if (&lt; position\
    \ 8)\n        (sort-numbers-rec (+ position 1))))\n  (sort-numbers-rec 0)\n  (string-join\
    \ (string-split numbers #\\space) \" \"))\n</code>\nAnd here's my test code:\n\
    <code>#lang racket\n", "  (let ([numbers-list (string-split numbers)])\n    (string-join\
    \ (sort numbers-list (\u03BB (x y) (number-&lt; x y))) \" \")))\n", "  (string-join\
    \ (sort (map number->string (sort (map string->number (string-split numbers))\
    \ <)) <) \" \"))\n", "  (string-join\n   (sort\n    (list->vector\n     (string-split\
    \ numbers #:whitespace))\n    (lambda (x y)\n      (not (string<? x y))))\n  \
    \ \" \"))\n", "  (define (translate-numeral numeral)\n    (cond ((string=? numeral\
    \ \"zero\") \"0\")\n          ((string=? numeral \"one\") \"1\")\n          ((string=?\
    \ numeral \"two\") \"2\")\n          ((string=? numeral \"three\") \"3\")\n  \
    \        ((string=? numeral \"four\") \"4\")\n          ((string=? numeral \"\
    five\") \"5\")\n          ((string=? numeral \"six\") \"6\")\n          ((string=?\
    \ numeral \"seven\") \"7\")\n          ((string=? numeral \"eight\") \"8\")\n\
    \          ((string=? numeral \"nine\") \"9\")))\n  (define (translate-numerals\
    \ numerals)\n    (let ([numerals-list (string-split numerals)])\n      (string-join\
    \ (map translate-numeral numerals-list) \" \")))\n  (define (sort-numerals numerals)\n\
    \    (let ([numerals-list (string-split numerals)])\n      (string-join (quicksort\
    \ (map string->number numerals-list)) \" \")))\n  (define (quicksort lst)\n  \
    \  (if (null? lst)\n        '()\n        (let ([pivot (car lst)]\n           \
    \   [rest (cdr lst)])\n          (append (quicksort (filter (lambda (x) (< x pivot))\
    \ rest))\n                  (list pivot)\n                  (quicksort (filter\
    \ (lambda (x) (>= x pivot)) rest))))))\n  (define (filter pred lst)\n    (if (null?\
    \ lst)\n        '()\n        (if (pred (car lst))\n            (cons (car lst)\
    \ (filter pred (cdr lst)))\n            (filter pred (cdr lst)))))\n  (sort-numerals\
    \ (translate-numerals numbers)))\n", "  (string-join (sort (map (\u03BB (num)\
    \ (let ((n (string->number num)))\n                                          (if\
    \ (number? n) (number->string n) num)))\n                               (string-split\
    \ numbers #\\space))\n                      <)\n               #\\space))\n```\n\
    \n## Other solutions\n\n* None, so far.", "  (sort (string-split numbers #\\space)\n\
    \        string<?))\n", "  (define number-to-digit\n    '(\"zero\" \"one\" \"\
    two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\"))\n  (sort\
    \ (string-split numbers #\\space)\n        (\u03BB (x y) (< (vector-ref number-to-digit\
    \ x)\n                    (vector-ref number-to-digit y)))))\n", "  (sort (string-&gt;list\
    \ numbers)\n        (lambda (a b) (string&lt;? (number-&gt;string a) (number-&gt;string\
    \ b)))))\n", "  (let loop ([words (string-split numbers)]\n             [nums\
    \ '()])\n    (cond\n      [(empty? words) (string-join (reverse nums) \" \")]\n\
    \      [(equal? (first words) \"zero\") (loop (rest words) (cons \"zero\" nums))]\n\
    \      [(equal? (first words) \"one\") (loop (rest words) (cons \"one\" nums))]\n\
    \      [(equal? (first words) \"two\") (loop (rest words) (cons \"two\" nums))]\n\
    \      [(equal? (first words) \"three\") (loop (rest words) (cons \"three\" nums))]\n\
    \      [(equal? (first words) \"four\") (loop (rest words) (cons \"four\" nums))]\n\
    \      [(equal? (first words) \"five\") (loop (rest words) (cons \"five\" nums))]\n\
    \      [(equal? (first words) \"six\") (loop (rest words) (cons \"six\" nums))]\n\
    \      [(equal? (first words) \"seven\") (loop (rest words) (cons \"seven\" nums))]\n\
    \      [(equal? (first words) \"eight\") (loop (rest words) (cons \"eight\" nums))]\n\
    \      [(equal? (first words) \"nine\") (loop (rest words) (cons \"nine\" nums))]\n\
    \      [else (loop (rest words) nums)])))\n```\n\n## Testing\n\n[![CircleCI](https://circleci.com/gh/mishajw/codewars-solutions.svg?style=svg)](https://circleci.com/gh/mishajw/codewars-solutions)\n\
    \nTests are automatically run by [CircleCI](https://circleci.com/gh/mishajw/codewars-solutions)\
    \ each time a commit is pushed to GitHub.", "  (string-join (sort (regexp-split\
    \ #rx\" \" numbers)\n                     <)\n               \" \"))\n", "  (define\
    \ (numeral->num numeral)\n    (match numeral\n      [('zero) 0]\n      [('one)\
    \ 1]\n      [('two) 2]\n      [('three) 3]\n      [('four) 4]\n      [('five)\
    \ 5]\n      [('six) 6]\n      [('seven) 7]\n      [('eight) 8]\n      [('nine)\
    \ 9]))\n  (define (num->numeral num)\n    (match num\n      [0 'zero]\n      [1\
    \ 'one]\n      [2 'two]\n      [3 'three]\n      [4 'four]\n      [5 'five]\n\
    \      [6 'six]\n      [7 'seven]\n      [8 'eight]\n      [9 'nine]))\n  (define\
    \ (sort-numbers input)\n    (cond\n      [(empty? input) empty]\n      [else\n\
    \       (let ([min (min (first input) (rest input))])\n         (cons min (sort-numbers\
    \ (remove min input))))]))\n  (string-join (map num->numeral (sort-numbers (map\
    \ numeral->num numbers))) \" \"))\n", "  (define (number->int number)\n    (cond\n\
    \      [(equal? number \"zero\") 0]\n      [(equal? number \"one\") 1]\n     \
    \ [(equal? number \"two\") 2]\n      [(equal? number \"three\") 3]\n      [(equal?\
    \ number \"four\") 4]\n      [(equal? number \"five\") 5]\n      [(equal? number\
    \ \"six\") 6]\n      [(equal? number \"seven\") 7]\n      [(equal? number \"eight\"\
    ) 8]\n      [(equal? number \"nine\") 9]))\n  (define (int->number number)\n \
    \   (cond\n      [(equal? number 0) \"zero\"]\n      [(equal? number 1) \"one\"\
    ]\n      [(equal? number 2) \"two\"]\n      [(equal? number 3) \"three\"]\n  \
    \    [(equal? number 4) \"four\"]\n      [(equal? number 5) \"five\"]\n      [(equal?\
    \ number 6) \"six\"]\n      [(equal? number 7) \"seven\"]\n      [(equal? number\
    \ 8) \"eight\"]\n      [(equal? number 9) \"nine\"]))\n  (apply string-append\
    \ (map int->number (sort < (map number->int (string-split numbers))))))\n", " \
    \ (format \"~a\" (sort numbers (lambda (s1 s2)\n                             \
    \  (string<? s1 s2)))))\n", "  (define (sort-helper xs nums)\n    (cond\n    \
    \  [(empty? xs) nums]\n      [else (sort-helper (rest xs) (map (lambda (y) (if\
    \ (not (equal? (first xs) y)) y)) nums))]))\n  (map (lambda (x) (define smallest\
    \ (sort-helper numbers x))\n              (if (empty? smallest) x (first smallest)))\
    \ (list 'zero 'one 'two 'three 'four 'five 'six 'seven 'eight 'nine)))\n```\n\n\
    ### Algorithm - Classical:\n\n```#lang racket\n", "  (define (numeric-value numeral)\n\
    \    (cond\n      ((string=? numeral \"zero\") 0)\n      ((string=? numeral \"\
    one\") 1)\n      ((string=? numeral \"two\") 2)\n      ((string=? numeral \"three\"\
    ) 3)\n      ((string=? numeral \"four\") 4)\n      ((string=? numeral \"five\"\
    ) 5)\n      ((string=? numeral \"six\") 6)\n      ((string=? numeral \"seven\"\
    ) 7)\n      ((string=? numeral \"eight\") 8)\n      ((string=? numeral \"nine\"\
    ) 9)))\n  (apply string-append\n    (map number->string\n      (sort <\n     \
    \   (map numeric-value\n          (string-split numbers))))))\n```\n\n## Test\
    \ cases\n```racket", "  (define mapping (hash \"one\" 1 \"two\" 2 \"three\" 3\
    \ \"four\" 4 \"five\" 5 \"six\" 6 \"seven\" 7 \"eight\" 8 \"nine\" 9))\n  (define\
    \ string->number (lambda (str) (hash-ref mapping str \"not a valid numberal\"\
    )))\n  (define number->string (lambda (num) (hash-ref (invert mapping) num \"\
    not a valid numberal\")))\n  (define get-all-strings\n    (lambda (numbers)\n\
    \      (if (empty? numbers)\n          '()\n          (cons (string->number (first\
    \ numbers)) (get-all-strings (rest numbers))))))\n  (define get-string-from-all-numbers\n\
    \    (lambda (numbers)\n      (if (empty? numbers)\n          '()\n          (cons\
    \ (number->string (first numbers)) (get-string-from-all-numbers (rest numbers))))))\n\
    \  (define sort-numberals\n    (lambda (numbers)\n      (get-string-from-all-numbers\
    \ (sort (get-all-strings numbers) <))))\n  (sort-numberals (string-split numbers\
    \ #\\space)))\n```\n\n## Grouped-by-Sum\n```racket\n#lang racket\n", "  (string-join\
    \ (sort (string-split numbers #\\space)\n                     string<?\n     \
    \                ;; string<? isn't good enough for the task, since it sorts numbers\n\
    \                     ;; lexicographically, which would mean that \"one\" comes\
    \ before \"ten\".\n                     ;; So, we need a compare function that\
    \ ignores leading zeros.\n                     (\u03BB (x y) (number<? (string->number\
    \ x) (string->number y))))\n               #\\space))\n", "  (apply string-append\n\
    \         (map number->word (sort (map word->number (string-split numbers)) <))))\n",
  "  (string-join (sort (string-split numbers) string<? #:key word->number) \" \"\
    ))\n", "  (apply string-append\n         (map number->string\n              (sort\
    \ (map string->number (string-split numbers)) <))))\n", "  (string-join (sort\
    \ (string-split numbers #\\space)\n                     <\n                  \
    \   string<?\n                     )\n               #\\space))\n```\n\n```Racket\n\
    #lang racket\n", "  (string-join\n   (sort\n    (map string->number\n        \
    \ (regexp-split #rx\" \" numbers))\n    <)\n   \" \"))\n", "  (let ([numbers-list\
    \ (string-split numbers #\\space)])\n    (string-join (sort (map number->numeral\
    \ numbers-list) string<? ) #\\space)))\n", "  (let ([nums (number->numeral (string->number\
    \ numbers))])\n    (string-join (sort nums <) \" \")))\n", "  (string-join (sort\
    \ (string-split numbers #\\space) string<?)))\n", "  (string-join (sort (string-split\
    \ numbers) string<? #:key\n                     (lambda (c)\n                \
    \       (cond ((equal? c \"zero\") 0)\n                             ((equal? c\
    \ \"one\") 1)\n                             ((equal? c \"two\") 2)\n         \
    \                    ((equal? c \"three\") 3)\n                             ((equal?\
    \ c \"four\") 4)\n                             ((equal? c \"five\") 5)\n     \
    \                        ((equal? c \"six\") 6)\n                            \
    \ ((equal? c \"seven\") 7)\n                             ((equal? c \"eight\"\
    ) 8)\n                             ((equal? c \"nine\") 9))))\n              \
    \ \" \"))\n```\n\n## [Sort Numbers In Descending Order](https://www.codewars.com/kata/sort-numbers-in-descending-order)\n\
    \nYour task is to make a function that can take any non-negative integer as a\
    \ argument and return it with its digits in descending order. Essentially, rearrange\
    \ the digits to create the highest possible number.\n\nExamples:\n\n```racket\n\
    Input: 21445 Output: 54421\n\nInput: 145263 Output: 654321\n\nInput: 1254859723\
    \ Output: 9875543221\n```\n\n```racket\n#lang racket\n", "  (sort < (regexp-split\
    \ #rx\"\\s+\" numbers)))\n", "  (cond\n    ((string=? numbers \"zero\") \"zero\"\
    )\n    ((string=? numbers \"one\") \"one\")\n    ((string=? numbers \"two\") \"\
    two\")\n    ((string=? numbers \"three\") \"three\")\n    ((string=? numbers \"\
    four\") \"four\")\n    ((string=? numbers \"five\") \"five\")\n    ((string=?\
    \ numbers \"six\") \"six\")\n    ((string=? numbers \"seven\") \"seven\")\n  \
    \  ((string=? numbers \"eight\") \"eight\")\n    ((string=? numbers \"nine\")\
    \ \"nine\")\n    ((string=? numbers \"\") \"\")\n    (else (apply string (sort\
    \ (map (lambda (n) (cond\n                                       ((string=? n\
    \ \"zero\") 0)\n                                       ((string=? n \"one\") 1)\n\
    \                                       ((string=? n \"two\") 2)\n           \
    \                            ((string=? n \"three\") 3)\n                    \
    \                   ((string=? n \"four\") 4)\n                              \
    \         ((string=? n \"five\") 5)\n                                       ((string=?\
    \ n \"six\") 6)\n                                       ((string=? n \"seven\"\
    ) 7)\n                                       ((string=? n \"eight\") 8)\n    \
    \                                   ((string=? n \"nine\") 9)\n              \
    \                         (else (error \"Invalid input\"))))\n               \
    \                     (string-split numbers #\\space)))))))\n", "  (sort (string-&gt;list\
    \ numbers)\n        (\u03BB (x y)\n          (&lt; (string-&gt;number (symbol-&gt;string\
    \ x))\n             (string-&gt;number (symbol-&gt;string y))))))\n", "  (string-join\n\
    \   (string-split (string-trim numbers)\n                 #:whitespace #t\n  \
    \               #:regex? #f)\n   #\\space))\n", "  (let ((table (list '(\"zero\"\
    \ 0)\n                     '(\"one\" 1)\n                     '(\"two\" 2)\n \
    \                    '(\"three\" 3)\n                     '(\"four\" 4)\n    \
    \                 '(\"five\" 5)\n                     '(\"six\" 6)\n         \
    \            '(\"seven\" 7)\n                     '(\"eight\" 8)\n           \
    \          '(\"nine\" 9))))\n    (string-join\n     (map (lambda (number)\n  \
    \          (find number (lambda (entry)\n                           (= (cadr entry)\
    \ number))\n                 table))\n          (sort (map (lambda (number)\n\
    \                       (cadr (find number (lambda (entry)\n                 \
    \                           (string=? (car entry) number))\n                 \
    \                table)))\n                     (string-split numbers))\n    \
    \            <))\n     \" \")))\n", "  ;; Convert the numbers to corresponding\
    \ integer\n  (define (num-to-int numeral)\n    (cond ((equal? numeral \"zero\"\
    ) 0)\n          ((equal? numeral \"one\") 1)\n          ((equal? numeral \"two\"\
    ) 2)\n          ((equal? numeral \"three\") 3)\n          ((equal? numeral \"\
    four\") 4)\n          ((equal? numeral \"five\") 5)\n          ((equal? numeral\
    \ \"six\") 6)\n          ((equal? numeral \"seven\") 7)\n          ((equal? numeral\
    \ \"eight\") 8)\n          ((equal? numeral \"nine\") 9)))\n  ;; Sort the numbers\n\
    \  (sort (map num-to-int (split numbers #\\space)) <)\n  ;; Convert sorted numbers\
    \ back to numeral string\n  (define (int-to-num n)\n    (cond ((equal? n 0) \"\
    zero\")\n          ((equal? n 1) \"one\")\n          ((equal? n 2) \"two\")\n\
    \          ((equal? n 3) \"three\")\n          ((equal? n 4) \"four\")\n     \
    \     ((equal? n 5) \"five\")\n          ((equal? n 6) \"six\")\n          ((equal?\
    \ n 7) \"seven\")\n          ((equal? n 8) \"eight\")\n          ((equal? n 9)\
    \ \"nine\")))\n  (map int-to-num (sort (map num-to-int (split numbers #\\space))\
    \ <)))\n", "  (format \"~a\" (sort (string-&gt;list numbers) (compose &lt; string-&gt;number))))\n\
    </code>\nI am getting the error :\n<code>application: not a procedure;\n expected\
    \ a procedure that can be applied to arguments\n  given: '1\n  arguments...:\n\
    \   \"three one five\"\n</code>\nAny idea what I am doing wrong?\n\n\nA:\n\n<code>string-&gt;number</code>\
    \ expects a string, but you're applying it to characters. <code>sort</code> applies\
    \ its procedure to the list of items, not to the entire list.\nThis does what\
    \ you want:\n<code>(define (sort_numbers numbers)\n  (format \"~a\" (sort (string-&gt;list\
    \ numbers) (compose &lt; string-&gt;number string))))\n</code>\n", "  (string-join\
    \ (sort (string-split numbers #\\space) <) #\\space))\n", "  (define (word_to_num\
    \ word)\n    (cond [(equal? word \"zero\") 0]\n          [(equal? word \"one\"\
    ) 1]\n          [(equal? word \"two\") 2]\n          [(equal? word \"three\")\
    \ 3]\n          [(equal? word \"four\") 4]\n          [(equal? word \"five\")\
    \ 5]\n          [(equal? word \"six\") 6]\n          [(equal? word \"seven\")\
    \ 7]\n          [(equal? word \"eight\") 8]\n          [(equal? word \"nine\"\
    ) 9]))\n  (define (num_to_word num)\n    (cond [(equal? num 0) \"zero\"]\n   \
    \       [(equal? num 1) \"one\"]\n          [(equal? num 2) \"two\"]\n       \
    \   [(equal? num 3) \"three\"]\n          [(equal? num 4) \"four\"]\n        \
    \  [(equal? num 5) \"five\"]\n          [(equal? num 6) \"six\"]\n          [(equal?\
    \ num 7) \"seven\"]\n          [(equal? num 8) \"eight\"]\n          [(equal?\
    \ num 9) \"nine\"]))\n  (string-join (map num_to_word (sort (map word_to_num (string-split\
    \ numbers)) <)) \" \"))\n", "  (string-join\n   (sort\n    (map\n     (lambda\
    \ (numeral)\n       (string->number (list->string (list-&gt;words numeral))))\n\
    \     (list-&gt;words numbers))\n    &lt;)\n   \" \"))\n</code>\nI am not sure\
    \ I am using a proper solution, so I would appreciate any advice. \n", "  (cond\
    \ ((equal? numbers \"\") \"\")\n        ((equal? numbers \"zero\") \"zero\")\n\
    \        ((equal? numbers \"one\") \"one\")\n        ((equal? numbers \"two\"\
    ) \"two\")\n        ((equal? numbers \"three\") \"three\")\n        ((equal? numbers\
    \ \"four\") \"four\")\n        ((equal? numbers \"five\") \"five\")\n        ((equal?\
    \ numbers \"six\") \"six\")\n        ((equal? numbers \"seven\") \"seven\")\n\
    \        ((equal? numbers \"eight\") \"eight\")\n        ((equal? numbers \"nine\"\
    ) \"nine\")\n        ((and (equal? (substring numbers 0 5) \"three\") (equal?\
    \ (substring numbers 5 1) \" \")) (string-append \"three \" (sort_numbers (substring\
    \ numbers 6 (string-length numbers)))))\n        ((and (equal? (substring numbers\
    \ 0 3) \"one\") (equal? (substring numbers 3 1) \" \")) (string-append \"one \"\
    \ (sort_numbers (substring numbers 4 (string-length numbers)))))\n        ((and\
    \ (equal? (substring numbers 0 4) \"five\") (equal? (substring numbers 4 1) \"\
    \ \")) (string-append \"five \" (sort_numbers (substring numbers 5 (string-length\
    \ numbers)))))\n        (else (string-append (sort_numbers (substring numbers\
    \ 1 (string-length numbers))) (substring numbers 0 1)))))\n", "  (string-join\
    \ (sort (string-split numbers #\\space) #:key (compose string->number number->string))\
    \ #\\space))\n", "  (string-join\n   (list->string\n    (sort\n     (list->string\
    \ numbers)\n     (lambda (x y)\n       (< (string->number x) (string->number y)))))))\n",
  "  (string-join (list->string (sort (string->list numbers) <)) \" \"))\n", "  (let\
    \ ((nums (sort (string-split numbers #\\space) string&lt;?)))\n    (apply string-join\
    \ nums) ))\n</code>\n", "  (define (numerals n)\n    (cond ((= n 0) \"zero\")\n\
    \          ((= n 1) \"one\")\n          ((= n 2) \"two\")\n          ((= n 3)\
    \ \"three\")\n          ((= n 4) \"four\")\n          ((= n 5) \"five\")\n   \
    \       ((= n 6) \"six\")\n          ((= n 7) \"seven\")\n          ((= n 8) \"\
    eight\")\n          ((= n 9) \"nine\")))\n  (string-join (sort (map string->number\
    \ (string-split numbers #\\space)) <) \" \"))\n```\n\n## Setup\n\nGo through the\
    \ setup instructions for JavaScript to install the necessary\ndependencies:\n\n\
    http://exercism.io/languages/javascript/installation\n\n## Running the test suite\n\
    \nThe provided test suite uses [Jasmine](https://jasmine.github.io/).\nYou can\
    \ install it by opening a terminal window and running the\nfollowing command:\n\
    \n```sh\nnpm install -g jasmine\n```\n\nRun the test suite from the exercise directory\
    \ with:\n\n```sh\njasmine wordy.spec.js\n```\n\nIn many test suites all but the\
    \ first test have been marked \"pending\".\nOnce you get a test passing, activate\
    \ the next one by changing `xit` to `it`.\n\n## Source\n\nShree Lakshmi [https://www.shree-lakshmi.com/recursion-demystified/](https://www.shree-lakshmi.com/recursion-demystified/)\n\
    \n## Submitting Incomplete Solutions\n\nIt's possible to submit an incomplete\
    \ solution so you can see how others have\ncompleted the exercise.", "  (string-join\n\
    \   (sort\n    (string-split numbers #\\space)\n    (lambda (a b)\n      (< (string->number\
    \ a) (string->number b))))\n   #\\space))\n", "  (string-join (sort (string-split\
    \ numbers #\\space)\n                     (\u03BB (a b)\n                    \
    \   (< (number-to-number-string (number-to-number a))\n                      \
    \    (number-to-number-string (number-to-number b)))))\n                \" \"\
    ))\n", "  (sort (split numbers #\\space)\n        >\n        (lambda (s1 s2)\n\
    \          (string<? (number-&gt;string (string-&gt;number s1))\n            \
    \        (number-&gt;string (string-&gt;number s2))))))\n", "  (define (numeral-&gt;int\
    \ [numeral 'zero])\n    (case numeral\n      [(zero) 0]\n      [(one) 1]\n   \
    \   [(two) 2]\n      [(three) 3]\n      [(four) 4]\n      [(five) 5]\n      [(six)\
    \ 6]\n      [(seven) 7]\n      [(eight) 8]\n      [(nine) 9]))\n  (define (my-join\
    \ [xs '()]) xs)\n  (define (my-join [xs (list el)]) el)\n  (define (my-join [xs\
    \ (list el rest ...)])\n    (string-append el \" \" (my-join rest)))\n  (string-join\
    \ (map numeral-&gt;int (string-split numbers #\\space)) #\\space))\n</code>\n\
    I would be happy if someone could give me an advice. And I hope this question\
    \ won't violate the rules of stack overflow.\n\n\nA:\n\nYou have several problems:\n\
    \nYou're redefining a function in the same scope. This is not allowed.\nThe <code>&lt;name&gt;-&gt;int</code>\
    \ function is not complete: it only covers the numbers <code>zero</code> to <code>nine</code>.\
    \ Instead of rewriting the same code over and over again, use a <code>cond</code>\
    \ expression instead.\nThere's no need to define <code>my-join</code>, since there's\
    \ already <code>string-join</code>.\nThere's no need to define your own sorting\
    \ algorithm, since there's already <code>sort</code>.\n\n<code>(define (sort-numbers\
    \ numbers)\n  (define (numeral-&gt;int numeral)\n    (cond\n      [(zero?) 0]\n\
    \      [(one?) 1]\n      [(two?) 2]\n      [(three?) 3]\n      [(four?) 4]\n \
    \     [(five?) 5]\n      [(six?) 6]\n      [(seven?) 7]\n      [(eight?) 8]\n\
    \      [(nine?) 9]))\n  (string-join (sort numeral-&gt;int (string-split numbers\
    \ #\\space)) #\\space))\n</code>\nI've also changed the name of the", "  (define\
    \ (numeral-&gt;num numeral)\n    (cond\n      [(string=? numeral \"zero\") 0]\n\
    \      [(string=? numeral \"one\") 1]\n      [(string=? numeral \"two\") 2]\n\
    \      [(string=? numeral \"three\") 3]\n      [(string=? numeral \"four\") 4]\n\
    \      [(string=? numeral \"five\") 5]\n      [(string=? numeral \"six\") 6]\n\
    \      [(string=? numeral \"seven\") 7]\n      [(string=? numeral \"eight\") 8]\n\
    \      [(string=? numeral \"nine\") 9]))\n  (define (num-&gt;numeral num)\n  \
    \  (cond\n      [(= num 0) \"zero\"]\n      [(= num 1) \"one\"]\n      [(= num\
    \ 2) \"two\"]\n      [(= num 3) \"three\"]\n      [(= num 4) \"four\"]\n     \
    \ [(= num 5) \"five\"]\n      [(= num 6) \"six\"]\n      [(= num 7) \"seven\"\
    ]\n      [(= num 8) \"eight\"]\n      [(= num 9) \"nine\"]))\n  (string-join (map\
    \ num-&gt;numeral (sort (map numeral-&gt;num (string-split numbers #\\space))))\
    \ #\\space))\n</code>\nI have plenty of working experience in Java and Python,\
    \ and some in C, and I'm used to having to do everything right on the first try,\
    \ and having to be as succinct as possible. \nThis is my first time doing a coding\
    \ challenge in a functional language, and this is my first time ever writing Racket,\
    \ so I'd appreciate any feedback, but especially on anything that's not obvious\
    \ to someone who's used to imperative languages.\n\n\nA:\n\nStyle\nYou're using\
    \ plenty of <code>cond</code>'s, and they're quite long, so I would suggest to\
    \ use <code>case</code>'s instead:\n<code>(define (numeral-&gt;num numeral)\n\
    \  (case numeral\n    ((zero) 0)\n    ((one) 1)\n    ((two) 2)\n    ((three) 3)\n\
    \    ((four) 4)\n    ((five)", "  (apply string-append (sort (string-split numbers)\
    \ string<?)))\n", "  (let ([nums (string-split numbers #\\space)])\n    (let ([nums\
    \ (sort nums string<? #:key (lambda (num) (string->number (number-name->number\
    \ num))))])\n      (string-join nums #\\space))))\n", "  (define numeral-to-number\
    \ '((zero . 0) (one . 1) (two . 2) (three . 3) (four . 4) (five . 5) (six . 6)\
    \ (seven . 7) (eight . 8) (nine . 9)))\n  (define (number-to-numeral n)\n    (define\
    \ number-to-numeral-alist '((0 . zero) (1 . one) (2 . two) (3 . three) (4 . four)\
    \ (5 . five) (6 . six) (7 . seven) (8 . eight) (9 . nine)))\n    (if (assoc n\
    \ number-to-numeral-alist)\n        (cdr (assoc n number-to-numeral-alist))\n\
    \        \"no such number\"))\n  (string-join\n   (map number-to-numeral\n   \
    \     (sort (map cdr (map (lambda (n) (assoc n numeral-to-number)) (string-split\
    \ numbers))) <))\n   \" \"))\n", "  (let* ([numbers (string-split numbers \" \"\
    )]\n         [sorted-numbers (sort numbers sort-by-numerals)]\n         [result\
    \ (string-join sorted-numbers \" \")])\n    result))\n", "  (apply string-append\
    \ (sort (string-&gt;list numbers) string&lt;?)))\n", "  (cond ((equal? numbers\
    \ \"\") \"\")\n        ((equal? numbers \"zero\") \"zero\")\n        ((equal?\
    \ numbers \"one\") \"one\")\n        ((equal? numbers \"two\") \"two\")\n    \
    \    ((equal? numbers \"three\") \"three\")\n        ((equal? numbers \"four\"\
    ) \"four\")\n        ((equal? numbers \"five\") \"five\")\n        ((equal? numbers\
    \ \"six\") \"six\")\n        ((equal? numbers \"seven\") \"seven\")\n        ((equal?\
    \ numbers \"eight\") \"eight\")\n        ((equal? numbers \"nine\") \"nine\")\n\
    \        ((string-contains? numbers \"zero\") (string-append \"zero \" (sort_numbers\
    \ (string-replace* numbers \"zero\" \"\"))))\n        ((string-contains? numbers\
    \ \"one\") (string-append \"one \" (sort_numbers (string-replace* numbers \"one\"\
    \ \"\"))))\n        ((string-contains? numbers \"two\") (string-append \"two \"\
    \ (sort_numbers (string-replace* numbers \"two\" \"\"))))\n        ((string-contains?\
    \ numbers \"three\") (string-append \"three \" (sort_numbers (string-replace*\
    \ numbers \"three\" \"\"))))\n        ((string-contains? numbers \"four\") (string-append\
    \ \"four \" (sort_numbers (string-replace* numbers \"four\" \"\"))))\n       \
    \ ((string-contains? numbers \"five\") (string-append \"five \" (sort_numbers\
    \ (string-replace* numbers \"five\" \"\"))))\n        ((string-contains? numbers\
    \ \"six\") (string-append \"six \" (sort_numbers (string-replace* numbers \"six\"\
    \ \"\"))))\n        ((string-contains? numbers \"seven\") (string-append \"seven\
    \ \" (sort_numbers (string-replace* numbers \"seven\" \"\"))))\n        ((string-contains?\
    \ numbers \"eight\") (string-append \"eight \" (sort_numbers (string-replace*\
    \ numbers \"eight\" \"\"))))\n        ((string-contains? numbers \"nine\") (string-append\
    \ \"nine \" (sort_numbers (string-replace* numbers \"nine\" \"\"))))\n       \
    \ (else \"ERROR\")))\n", "  (cond\n    [(empty? numbers) #f]\n    [else (cond\n\
    \            [(string=? (first numbers) \"zero\")  \"0\"]\n            [(string=?\
    \ (first numbers) \"one\")   \"1\"]\n            [(string=? (first numbers) \"\
    two\")   \"2\"]\n            [(string=? (first numbers) \"three\") \"3\"]\n  \
    \          [(string=? (first numbers) \"four\")  \"4\"]\n            [(string=?\
    \ (first numbers) \"five\")  \"5\"]\n            [(string=? (first numbers) \"\
    six\")   \"6\"]\n            [(string=? (first numbers) \"seven\") \"7\"]\n  \
    \          [(string=? (first numbers) \"eight\") \"8\"]\n            [(string=?\
    \ (first numbers) \"nine\")  \"9\"]\n            [else \"\"])]\n    (sort_numbers\
    \ (rest numbers))))\n```\n\n```racket\n#lang racket\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
