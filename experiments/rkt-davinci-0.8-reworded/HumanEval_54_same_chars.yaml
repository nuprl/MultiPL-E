name: HumanEval_54_same_chars
language: rkt
prompt: "#lang racket\n\n;; Check if two words have the same characters.\n;; >>> (same_chars\
  \ \"eabcdzzzz\" \"dddzzzzzzzddeddabc\")\n;; #t\n;; >>> (same_chars \"abcd\" \"dddddddabc\"\
  )\n;; #t\n;; >>> (same_chars \"dddddddabc\" \"abcd\")\n;; #t\n;; >>> (same_chars\
  \ \"eabcd\" \"dddddddabc\")\n;; #f\n;; >>> (same_chars \"abcd\" \"dddddddabce\"\
  )\n;; #f\n;; >>> (same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\")\n;; #f\n(define\
  \ (same_chars s0 s1)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate same_chars))\n\
  \    (check-equal? (candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\") #t)\n    (check-equal?\
  \ (candidate \"abcd\" \"dddddddabc\") #t)\n    (check-equal? (candidate \"dddddddabc\"\
  \ \"abcd\") #t)\n    (check-equal? (candidate \"eabcd\" \"dddddddabc\") #f)\n  \
  \  (check-equal? (candidate \"abcd\" \"dddddddabcf\") #f)\n    (check-equal? (candidate\
  \ \"eabcdzzzz\" \"dddzzzzzzzddddabc\") #f)\n    (check-equal? (candidate \"aabb\"\
  \ \"aaccc\") #f)\n))\n\n(test-humaneval)"
completions: ["  (let ([d0 (char-counts s0)]\n        [d1 (char-counts s1)])\n   \
    \ (same-counts d0 d1)))\n", "  (let ((chars (string->list s0)))\n    (for/and\
    \ ([c (in-list chars)])\n             (or (char=? c #\\z)\n                 (string-contains\
    \ s1 c)))))\n", "  (and (string=? s0 s1)\n       (= (length s0) (length s1))))\n",
  "  (string=? (sort (string-&gt;list s0)) (sort (string-&gt;list s1))))\n", "  (define\
    \ s0-set (string-&gt;set s0))\n  (define s1-set (string-&gt;set s1))\n  (and (subset?\
    \ s0-set s1-set)\n       (subset? s1-set s0-set)))\n", "  (let ([s0 (string-&gt;list\
    \ s0)]\n        [s1 (string-&gt;list s1)])\n    (and\n     (for/and ([c0 s0])\n\
    \       (for/or ([c1 s1])\n         (char=? c0 c1)))\n     (for/and ([c1 s1])\n\
    \       (for/or ([c0 s0])\n         (char=? c0 c1))))))\n", "  (define (same-chars-impl\
    \ s0 s1)\n    (cond [(and (empty? s0) (empty? s1)) #t]\n          [(and (empty?\
    \ s0) (not (empty? s1))) #f]\n          [(and (not (empty? s0)) (empty? s1)) #f]\n\
    \          [(and (char=? (first s0) (first s1)) (same-chars-impl (rest s0) (rest\
    \ s1))) #t]\n          [(and (char=? (first s0) (first s1)) (not (same-chars-impl\
    \ (rest s0) (rest s1)))) #f]\n          [(and (not (char=? (first s0) (first s1)))\
    \ (same-chars-impl (rest s0) (rest s1))) #t]\n          [(and (not (char=? (first\
    \ s0) (first s1))) (not (same-chars-impl (rest s0) (rest s1)))) #f]))\n  (same-chars-impl\
    \ (string->list s0) (string->list s1)))\n```\n\n```racket\n#lang racket\n", " \
    \ (let loop ([s0 s0] [s1 s1])\n    (match s0\n      [(list)\n       (equal? s0\
    \ s1)]\n      [(cons c0 r0)\n       (match s1\n         [(list)\n          #f]\n\
    \         [(cons c1 r1)\n          (if (equal? c0 c1)\n              (loop r0\
    \ r1)\n              (loop (cons c0 r0) r1))]\n         [else\n          #f])]\n\
    \      [else\n       #f])))\n", "  (null? (list-difference (string->list s0) (string->list\
    \ s1)))\n  )\n", "  (equal? (list->string (sort (string->list s0)))\n        \
    \  (list->string (sort (string->list s1)))))\n", "  (define (occurrences-map l)\n\
    \    (foldl (lambda (a b)\n             (if (not (hash-has-key? b a))\n      \
    \           (hash-set! b a 1)\n                 (hash-set! b a (+ 1 (hash-ref\
    \ b a)))))\n           (make-hash)\n           l))\n  (define (all-zeros? m)\n\
    \    (define (is-zero? a) (= a 0))\n    (foldl (lambda (a b) (and b (is-zero?\
    \ a)))\n           #t\n           (hash-values m)))\n  (all-zeros? (hash-subtract\
    \ (occurrences-map (string->list s0))\n                             (occurrences-map\
    \ (string->list s1)))))", "  (same-chars s0 s1 '()))\n", "  (eq? (sort s0 string&lt;?)\
    \ (sort s1 string&lt;?)))\n", "  (cond [(and (string? s0) (string? s1))\n    \
    \     (string=? (sort s0) (sort s1))]\n        [else (error 'same_chars \"need\
    \ two strings\")]))\n", "  (let ((counts (make-hash)))\n    (for ([c (in-string\
    \ s0)])\n      (hash-update! counts c add1 0))\n    (for ([c (in-string s1)])\n\
    \      (hash-update! counts c sub1 0))\n    (for/and ([c (in-hash counts)])\n\
    \      (= (hash-ref counts c) 0))))\n", "  (define (same_chars-count-chars s0)\n\
    \    (if (null? s0) '()\n        (let ((char (car s0))\n              (count (count\
    \ (car s0) s0)))\n          (cons (cons char count) (same_chars-count-chars (remove\
    \ char s0))))))\n  (define (same_chars-same-chars chars0 chars1)\n    (if (or\
    \ (null? chars0) (null? chars1)) #t\n        (let ((char0 (car chars0))\n    \
    \          (char1 (car chars1)))\n          (and (equal? (car char0) (car char1))\n\
    \               (equal? (cdr char0) (cdr char1))\n               (same_chars-same-chars\
    \ (cdr chars0) (cdr chars1))))))\n  (same_chars-same-chars (same_chars-count-chars\
    \ s0) (same_chars-count-chars s1)))\n", "  (letrec ([s0-chars (string->list s0)]\n\
    \           [s1-chars (string->list s1)]\n           [diff (difference s0-chars\
    \ s1-chars)])\n    (if (null? diff)\n        #t\n        #f)))\n", "  (let ((chars\
    \ (list-set (string->list s0))))\n    (for ([c (in-list (string->list s1))])\n\
    \      (when (member c chars)\n        (set! chars (remove c chars))))\n    (empty?\
    \ chars)))\n", "  (same_chars? (string->list s0) (string->list s1)))\n", "  (let\
    \ lp ([s0 (string->list s0)]\n           [s1 (string->list s1)])\n    (cond [(or\
    \ (null? s0) (null? s1)) #t]\n          [(char=? (car s0) (car s1)) (lp (cdr s0)\
    \ (cdr s1))]\n          [(member (car s0) s1) (lp (cdr s0) (remq (car s0) s1))]\n\
    \          [else #f])))\n```\n\nSimilar, but a little bit trickier is `same_chars/string`\
    \ that takes\nthe first word to be a string and the second word to be a list of\n\
    characters.\n\n```racket"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
