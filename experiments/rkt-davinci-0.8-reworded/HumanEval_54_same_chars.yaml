name: HumanEval_54_same_chars
language: rkt
prompt: "#lang racket\n\n;; Check if two words have the same characters.\n;; >>> (same_chars\
  \ \"eabcdzzzz\" \"dddzzzzzzzddeddabc\")\n;; #t\n;; >>> (same_chars \"abcd\" \"dddddddabc\"\
  )\n;; #t\n;; >>> (same_chars \"dddddddabc\" \"abcd\")\n;; #t\n;; >>> (same_chars\
  \ \"eabcd\" \"dddddddabc\")\n;; #f\n;; >>> (same_chars \"abcd\" \"dddddddabce\"\
  )\n;; #f\n;; >>> (same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\")\n;; #f\n(define\
  \ (same_chars s0 s1)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate same_chars))\n\
  \    (check-equal? (candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\") #t)\n    (check-equal?\
  \ (candidate \"abcd\" \"dddddddabc\") #t)\n    (check-equal? (candidate \"dddddddabc\"\
  \ \"abcd\") #t)\n    (check-equal? (candidate \"eabcd\" \"dddddddabc\") #f)\n  \
  \  (check-equal? (candidate \"abcd\" \"dddddddabcf\") #f)\n    (check-equal? (candidate\
  \ \"eabcdzzzz\" \"dddzzzzzzzddddabc\") #f)\n    (check-equal? (candidate \"aabb\"\
  \ \"aaccc\") #f)\n))\n\n(test-humaneval)"
completions: ["  (let ([d0 (char-counts s0)]\n        [d1 (char-counts s1)])\n   \
    \ (same-counts d0 d1)))\n", "  (let ((chars (string->list s0)))\n    (for/and\
    \ ([c (in-list chars)])\n             (or (char=? c #\\z)\n                 (string-contains\
    \ s1 c)))))\n", "  (and (string=? s0 s1)\n       (= (length s0) (length s1))))\n",
  "  (string=? (sort (string-&gt;list s0)) (sort (string-&gt;list s1))))\n", "  (define\
    \ s0-set (string-&gt;set s0))\n  (define s1-set (string-&gt;set s1))\n  (and (subset?\
    \ s0-set s1-set)\n       (subset? s1-set s0-set)))\n", "  (let ([s0 (string-&gt;list\
    \ s0)]\n        [s1 (string-&gt;list s1)])\n    (and\n     (for/and ([c0 s0])\n\
    \       (for/or ([c1 s1])\n         (char=? c0 c1)))\n     (for/and ([c1 s1])\n\
    \       (for/or ([c0 s0])\n         (char=? c0 c1))))))\n", "  (define (same-chars-impl\
    \ s0 s1)\n    (cond [(and (empty? s0) (empty? s1)) #t]\n          [(and (empty?\
    \ s0) (not (empty? s1))) #f]\n          [(and (not (empty? s0)) (empty? s1)) #f]\n\
    \          [(and (char=? (first s0) (first s1)) (same-chars-impl (rest s0) (rest\
    \ s1))) #t]\n          [(and (char=? (first s0) (first s1)) (not (same-chars-impl\
    \ (rest s0) (rest s1)))) #f]\n          [(and (not (char=? (first s0) (first s1)))\
    \ (same-chars-impl (rest s0) (rest s1))) #t]\n          [(and (not (char=? (first\
    \ s0) (first s1))) (not (same-chars-impl (rest s0) (rest s1)))) #f]))\n  (same-chars-impl\
    \ (string->list s0) (string->list s1)))\n```\n\n```racket\n#lang racket\n", " \
    \ (let loop ([s0 s0] [s1 s1])\n    (match s0\n      [(list)\n       (equal? s0\
    \ s1)]\n      [(cons c0 r0)\n       (match s1\n         [(list)\n          #f]\n\
    \         [(cons c1 r1)\n          (if (equal? c0 c1)\n              (loop r0\
    \ r1)\n              (loop (cons c0 r0) r1))]\n         [else\n          #f])]\n\
    \      [else\n       #f])))\n", "  (null? (list-difference (string->list s0) (string->list\
    \ s1)))\n  )\n", "  (equal? (list->string (sort (string->list s0)))\n        \
    \  (list->string (sort (string->list s1)))))\n", "  (define (occurrences-map l)\n\
    \    (foldl (lambda (a b)\n             (if (not (hash-has-key? b a))\n      \
    \           (hash-set! b a 1)\n                 (hash-set! b a (+ 1 (hash-ref\
    \ b a)))))\n           (make-hash)\n           l))\n  (define (all-zeros? m)\n\
    \    (define (is-zero? a) (= a 0))\n    (foldl (lambda (a b) (and b (is-zero?\
    \ a)))\n           #t\n           (hash-values m)))\n  (all-zeros? (hash-subtract\
    \ (occurrences-map (string->list s0))\n                             (occurrences-map\
    \ (string->list s1)))))", "  (same-chars s0 s1 '()))\n", "  (eq? (sort s0 string&lt;?)\
    \ (sort s1 string&lt;?)))\n", "  (cond [(and (string? s0) (string? s1))\n    \
    \     (string=? (sort s0) (sort s1))]\n        [else (error 'same_chars \"need\
    \ two strings\")]))\n", "  (let ((counts (make-hash)))\n    (for ([c (in-string\
    \ s0)])\n      (hash-update! counts c add1 0))\n    (for ([c (in-string s1)])\n\
    \      (hash-update! counts c sub1 0))\n    (for/and ([c (in-hash counts)])\n\
    \      (= (hash-ref counts c) 0))))\n", "  (define (same_chars-count-chars s0)\n\
    \    (if (null? s0) '()\n        (let ((char (car s0))\n              (count (count\
    \ (car s0) s0)))\n          (cons (cons char count) (same_chars-count-chars (remove\
    \ char s0))))))\n  (define (same_chars-same-chars chars0 chars1)\n    (if (or\
    \ (null? chars0) (null? chars1)) #t\n        (let ((char0 (car chars0))\n    \
    \          (char1 (car chars1)))\n          (and (equal? (car char0) (car char1))\n\
    \               (equal? (cdr char0) (cdr char1))\n               (same_chars-same-chars\
    \ (cdr chars0) (cdr chars1))))))\n  (same_chars-same-chars (same_chars-count-chars\
    \ s0) (same_chars-count-chars s1)))\n", "  (letrec ([s0-chars (string->list s0)]\n\
    \           [s1-chars (string->list s1)]\n           [diff (difference s0-chars\
    \ s1-chars)])\n    (if (null? diff)\n        #t\n        #f)))\n", "  (let ((chars\
    \ (list-set (string->list s0))))\n    (for ([c (in-list (string->list s1))])\n\
    \      (when (member c chars)\n        (set! chars (remove c chars))))\n    (empty?\
    \ chars)))\n", "  (same_chars? (string->list s0) (string->list s1)))\n", "  (let\
    \ lp ([s0 (string->list s0)]\n           [s1 (string->list s1)])\n    (cond [(or\
    \ (null? s0) (null? s1)) #t]\n          [(char=? (car s0) (car s1)) (lp (cdr s0)\
    \ (cdr s1))]\n          [(member (car s0) s1) (lp (cdr s0) (remq (car s0) s1))]\n\
    \          [else #f])))\n```\n\nSimilar, but a little bit trickier is `same_chars/string`\
    \ that takes\nthe first word to be a string and the second word to be a list of\n\
    characters.\n\n```racket", "  (if (equal? (make-array)\n              (array-diff-eqv\n\
    \               (string->list/set s0)\n               (string->list/set s1)))\n\
    \      #t\n      #f))\n", "  (cond [(string=? s0 s1) #t]\n        [(or (empty?\
    \ s0) (empty? s1)) #f]\n        [else (let* ([c0 (string-ref s0 0)]\n        \
    \             [c1 (string-ref s1 0)]\n                     [rest-s0 (substring\
    \ s0 1 (string-length s0))]\n                     [rest-s1 (substring s1 1 (string-length\
    \ s1))])\n                (cond [(char=? c0 c1) (same_chars rest-s0 rest-s1)]\n\
    \                      [else (and (same_chars s0 rest-s1)\n                  \
    \               (same_chars rest-s0 s1))]))]))\n", "  (define (has-chars s chars)\n\
    \    (cond\n      [(empty? chars) #t]\n      [(member (first chars) s) (has-chars\
    \ s (rest chars))]\n      [else #f]))\n  (has-chars (list->set s0) (list->set\
    \ s1)))\n\n", "  (cond\n    [(null? s0) (null? s1)]\n    [(null? s1) #f]\n   \
    \ [(and (char=? (car s0) (car s1))\n          (same_chars (cdr s0) (cdr s1)))]\n\
    \    [else (same_chars s0 (cdr s1))]))\n", "  (every (curry equal? 1) (map count\
    \ (chars s0) (chars s1))))\n", "  (and (same-chars-helper s0 s1)\n       (same-chars-helper\
    \ s1 s0)))\n", "  (define (helper s0 s1)\n    (cond\n      ((string=? s0 \"\"\
    ) s1)\n      ((string=? s1 \"\") \"\")\n      ((string-contains s1 (string-take\
    \ s0 1))\n       (helper (string-drop s0 1) (string-delete s1 (string-take s0\
    \ 1))))\n      (else (helper (string-drop s0 1) s1))))\n  (string=? \"\" (helper\
    \ s0 s1)))\n", "  (define s0-char-counts (char-counts s0))\n  (define s1-char-counts\
    \ (char-counts s1))\n  (and (char-counts-subset? s0-char-counts s1-char-counts)\n\
    \       (char-counts-subset? s1-char-counts s0-char-counts)))\n", "  (letrec ([inner\
    \ (lambda (s0 s1)\n                   (cond [(equal? s0 \"\") (equal? s1 \"\"\
    )]\n                         [(and (not (equal? s0 \"\")) (not (equal? s1 \"\"\
    )))\n                          (let* ([c0 (string-ref s0 0)]\n               \
    \                  [rest0 (substring s0 1 (string-length s0))]\n             \
    \                    [rest1 (substring s1 1 (string-length s1))])\n          \
    \                  (cond [(equal? c0 (string-ref s1 0))\n                    \
    \               (inner rest0 rest1)]\n                                  [else\
    \ (inner (string-append c0 rest0) s1)]))]\n                         [else #f]))])\n\
    \    (inner s0 s1)))\n", "  (define s0-char-counts (chars-to-counts s0))\n  (define\
    \ s1-char-counts (chars-to-counts s1))\n  (equal? s0-char-counts s1-char-counts))\n",
  "  (define (same-chars? lst0 lst1)\n    (cond\n      [(and (null? lst0) (null? lst1))\n\
    \       #t]\n      [(or (null? lst0) (null? lst1))\n       #f]\n      [(member\
    \ (car lst0) lst1)\n       (same-chars? (cdr lst0) (filter (lambda (c) (not (=\
    \ c (car lst0)))) lst1))]\n      [else\n       #f]))\n  (same-chars? (string->list\
    \ s0) (string->list s1)))\n", "  (or (and (substring? s0 s1) (substring? s1 s0))\n\
    \      (and (substring? s1 s0) (substring? s0 s1))))\n", "  (cond [(empty? s0)\n\
    \         (empty? s1)]\n        [(empty? s1)\n         (empty? s0)]\n        [else\n\
    \         (define c0 (first s0))\n         (define c1 (first s1))\n         (define\
    \ n0 (count c0 s0))\n         (define n1 (count c1 s1))\n         (cond [(zero?\
    \ n0) (same_chars (rest s0) s1)]\n               [(zero? n1) (same_chars s0 (rest\
    \ s1))]\n               [(= n0 n1) (same_chars (rest s0) (rest s1))]\n       \
    \        [else #f])]))\n", "  (and (same-chars-help s0 s1) (same-chars-help s1\
    \ s0)))\n", "  (define (occurs s x)\n    (cond\n      [(empty? s) #f]\n      [(equal?\
    \ (first s) x) #t]\n      [else (occurs (rest s) x)]))\n  (and (andmap (curry\
    \ occurs s0) s1)\n       (andmap (curry occurs s1) s0)))\n", "  (equal? (sort\
    \ (string->list s0) string<?=)\n          (sort (string->list s1) string<?=)))\n",
  "  (define (len s)\n    (string-length s))\n  (define (c s i)\n    (string-ref s\
    \ i))\n  (define (mem c s i j)\n    (if (> i j)\n        #f\n        (if (= c\
    \ (c s i))\n            #t\n            (mem c s (+ i 1) j))))\n  (define (rm_char\
    \ c s i j)\n    (if (> i j)\n        (substring s 0 i)\n        (if (= c (c s\
    \ i))\n            (rm_char c s (+ i 1) j)\n            (string-set! s i (c s\
    \ (+ i 1)))\n            (rm_char c s (+ i 1) j))))\n  (define (check s0 s1)\n\
    \    (if (string=? s0 \"\")\n        #t\n        (if (mem (c s0 0) s1 0 (- (len\
    \ s1) 1))\n            (check (rm_char (c s0 0) s1 0 (- (len s1) 1)) (rm_char\
    \ (c s0 0) s0 0 (- (len s0) 1)))\n            #f)))\n  (if (= (len s0) (len s1))\n\
    \      (check s0 s1)\n      #f))\n", "  (define (count-chars-in-string s)\n  \
    \  (count_characters (string->list s)))\n  (define (count_characters lst)\n  \
    \  (cond\n      [(empty? lst) '()]\n      [else (cons (cons (first lst) (count\
    \ (first lst) (rest lst)))\n                  (count_characters (remove (first\
    \ lst) (rest lst))))]))\n  (define (remove x lst)\n    (cond\n      [(empty? lst)\
    \ '()]\n      [(eq? x (first lst)) (remove x (rest lst))]\n      [else (cons (first\
    \ lst) (remove x (rest lst)))]))\n  (define (count x lst)\n    (cond\n      [(empty?\
    \ lst) 0]\n      [(eq? x (first lst)) (+ 1 (count x (rest lst)))]\n      [else\
    \ (count x (rest lst))]))\n  (define (same-number-of-occurrences x y)\n    (eq?\
    \ (cdr (assoc x xs)) (cdr (assoc x ys))))\n  (define (same-chars-of-strings xs\
    \ ys)\n    (cond\n      [(empty? xs) #t]\n      [(empty? ys) #f]\n      [(same-number-of-occurrences\
    \ (first xs) (first ys))\n       (same-chars-of-strings (rest xs) (rest ys))]\n\
    \      [else #f]))\n  (define xs (count-chars-in-string s0))\n  (define ys (count-chars-in-string\
    \ s1))\n  (same-chars-of-strings xs ys))\n", "  (and (eq? (length s0) (length\
    \ s1))\n       (every (lambda (c) (andmap (lambda (cc) (contains (string c) cc))\
    \ (list s0 s1))) (list->string s0))))\n", "  (define (counts l)\n    (let loop\
    \ ([l l] [counts (make-hash)])\n      (if (null? l)\n          counts\n      \
    \    (let ([c (hash-ref counts (car l) 0)])\n            (hash-set! counts (car\
    \ l) (+ c 1))\n            (loop (cdr l) counts)))))\n  (let ([c0 (counts (string->list\
    \ s0))]\n        [c1 (counts (string->list s1))])\n    (hash-for-each\n     (lambda\
    \ (k n)\n       (let ([m (hash-ref c1 k 0)])\n         (if (not (= n m))\n   \
    \          (error \"Different character count\")\n             (hash-remove! c1\
    \ k))))\n     c0)\n    (hash-empty? c1)))\n", "  (define (remaining-chars-of char-list)\n\
    \    (for/fold ([remaining (list)]\n               [already-seen (list)])\n  \
    \      ([c (in-list char-list)])\n      (cond [(member c already-seen) remaining]\n\
    \            [else (cons c already-seen)])))\n  (and (equal? (length s0) (length\
    \ s1))\n       (equal? (remaining-chars-of s0) (remaining-chars-of s1))))", " \
    \ (cond\n    [(empty? s0) (empty? s1)]\n    [(or (empty? s1) (not (char=? (first\
    \ s0) (first s1)))) #f]\n    [else (same_chars (rest s0) (rest s1))]))\n", " \
    \ (cond\n    [(empty? s0)\n     (string=? s0 s1)]\n    [(string-contains s1 (string-ref\
    \ s0 0))\n     (same_chars (string-drop s0 1) (string-drop s1 (string-index s1\
    \ (string-ref s0 0))))]\n    [else\n     #f]))\n", "  (andmap\n   (\u03BB (c)\
    \ (positive? (count c s0)))\n   (unique (string-&gt;list s1))))\n", "  (or (and\
    \ (eq? s0 null) (eq? s1 null))\n      (and (not (eq? s0 null)) (not (eq? s1 null))\n\
    \           (and (char=? (string-ref s0 0) (string-ref s1 0))\n              \
    \  (or (same_chars (substring s0 1 (string-length s0)) s1)\n                 \
    \   (same_chars s0 (substring s1 1 (string-length s1))))))))\n", "  ;; return\
    \ true if the characters in s0 make up the characters in s1\n  (and (andmap (curry\
    \ char-set=? s0) s1)\n       (andmap (curry char-set=? s1) s0)))\n", "  (define\
    \ (same_chars_iter str0 str1 hash)\n    (if (string-empty? str0)\n        hash\n\
    \        (let* ([c (string-ref str0 0)]\n               [hash (hash-update hash\
    \ c (add1 (hash-ref hash c 0)))])\n          (same_chars_iter (substring str0\
    \ 1) str1 hash))))\n  (let* ([hash (same_chars_iter s0 s1 (make-hash))]\n    \
    \     [hash (same_chars_iter s1 s0 hash)])\n    (hash-for-each (lambda (k v)\n\
    \                     (if (= v 0)\n                         (error 'same_chars\
    \ \"Nope.\")))\n                   hash)\n    #t))\n", "  (cond\n    [(string=?\
    \ s0 s1) #t]\n    [(string=? s0 \"\") #f]\n    [(string=? s1 \"\") #f]\n    [(string-contains?\
    \ s1 (string-ref s0 0))\n     (same_chars (substring s0 1) (substring s1 (string-index\
    \ s1 (string-ref s0 0)) #t))]\n    [else #f]))\n", "  (cond\n    [(= (string-length\
    \ s0) 0) #t]\n    [(string-contains s1 (string-ref s0 0))\n     (same_chars (substring\
    \ s0 1) (string-replace s1 (string-ref s0 0) \"\"))]\n    [else #f]))\n", "  (let\
    \ ([t (c-tally s0)])\n    (equal? t (c-tally s1))))\n", "  (define s0-chars (list->set\
    \ (string->list s0)))\n  (define s1-chars (list->set (string->list s1)))\n  (set=?\
    \ s0-chars s1-chars))\n", "  (define (count c l)\n    (if (null? l)\n        0\n\
    \        (+ (if (char=? c (car l)) 1 0)\n           (count c (cdr l)))))\n  (and\
    \ (for/and ([c (in-string s0)])\n            (= (count c s0) (count c s1)))\n\
    \       (for/and ([c (in-string s1)])\n            (= (count c s0) (count c s1)))))\n",
  "  (cond [(empty? s0) (empty? s1)]\n        [(empty? s1) (empty? s0)]\n        [else\n\
    \         (let ([c0 (first s0)]\n               [c1 (first s1)])\n           (cond\
    \ [(char=? c0 c1)\n                  (same_chars (rest s0) (rest s1))]\n     \
    \            [(and (char-ci=? c0 c1)\n                       (same_chars (rest\
    \ s0) s1))\n                  #t]\n                 [(and (char-ci=? c1 c0)\n\
    \                       (same_chars s0 (rest s1)))\n                  #t]\n  \
    \               [else #f]))]))\n```\n\nAfter we finished the function, we got\
    \ another problem. To check the performance of our function, we need a long string.\
    \ The problem is, it is very inconvenient for us to input a long string in REPL.\
    \ So we developed another function to generate a random string.\n\n```racket",
  "  (define (chars s)\n    (list->string (sort < (string->list s))))\n  (equal? (chars\
    \ s0) (chars s1)))\n</code>\nExplanation:\n\nThe function <code>chars</code> converts\
    \ the string into a list of characters and sorts it.\n<code>same_chars</code>\
    \ performs the check by sorting the two strings and comparing them.\nI use <code>equal?</code>\
    \ instead of <code>string=?</code> because it takes into account the length of\
    \ the strings and <code>sort</code> is not stable.\n\n", "  (letrec ([dictionary\
    \ (make-hash)]\n           [same-char? (lambda (c)\n                         (hash-set!\
    \ dictionary c\n                                    (add1 (hash-ref dictionary\
    \ c 0)))\n                         (hash-ref dictionary c 0))]\n           [same-chars?\
    \ (lambda (s0 s1)\n                          (and (andmap (same-char? s0) s0)\n\
    \                               (andmap (same-char? s1) s1)))]\n           [same-chars-pair?\
    \ (lambda (pair)\n                               (apply same-chars? pair))])\n\
    \    (apply same-chars-pair? (sort (list s0 s1) string<?))))\n", "  (define (count\
    \ c str)\n    (cond\n      [(empty? str) 0]\n      [(= c (first str)) (+ 1 (count\
    \ c (rest str)))]\n      [else (count c (rest str))]))\n  (and (= (count #\\a\
    \ s0) (count #\\a s1))\n       (= (count #\\b s0) (count #\\b s1))\n       (=\
    \ (count #\\c s0) (count #\\c s1))\n       (= (count #\\d s0) (count #\\d s1))\n\
    \       (= (count #\\e s0) (count #\\e s1))\n       (= (count #\\f s0) (count\
    \ #\\f s1))\n       (= (count #\\g s0) (count #\\g s1))\n       (= (count #\\\
    h s0) (count #\\h s1))\n       (= (count #\\i s0) (count #\\i s1))\n       (=\
    \ (count #\\j s0) (count #\\j s1))\n       (= (count #\\k s0) (count #\\k s1))\n\
    \       (= (count #\\l s0) (count #\\l s1))\n       (= (count #\\m s0) (count\
    \ #\\m s1))\n       (= (count #\\n s0) (count #\\n s1))\n       (= (count #\\\
    o s0) (count #\\o s1))\n       (= (count #\\p s0) (count #\\p s1))\n       (=\
    \ (count #\\q s0) (count #\\q s1))\n       (= (count #\\r s0) (count #\\r s1))\n\
    \       (= (count #\\s s0) (count #\\s s1))\n       (= (count #\\t s0) (count\
    \ #\\t s1))\n       (= (count #\\u s0) (count #\\u s1))\n       (= (count #\\\
    v s0) (count #\\v s1))\n       (= (count #\\w s0) (count #\\w s1))\n       (=\
    \ (count #\\x s0) (count #\\x s1))", "  (define (in-both acc c)\n    (define (helper\
    \ acc1 c1)\n      (if (= c1 c)\n          (cons (string-append c1 acc1) acc1)\n\
    \          acc1))\n    (foldl helper acc s0))\n  (define (is-in-both acc1 c1)\n\
    \    (filter (lambda (cs)\n              (string-contains? cs c1))\n         \
    \   acc1))\n  (define (remove-from-both acc2 c2)\n    (map (lambda (cs)\n    \
    \       (string-remove c2 cs))\n         acc2))\n  (define (helper-do-both acc3\
    \ c3)\n    (remove-from-both (is-in-both acc3 c3) c3))\n  (define (helper-all-both\
    \ acc4 c4)\n    (remove-from-both (in-both acc4 c4) c4))\n  (define (helper1 acc5)\n\
    \    (foldl helper-do-both acc5 s1))\n  (define (helper2 acc6)\n    (foldl helper-all-both\
    \ acc6 s0))\n  (define res7 (helper2 (list \"\")))\n  (if (or (= 0 (length res7))\
    \ (= 0 (length (helper1 res7))))\n      #f\n      #t))\n", "  (and (same-chars/help\
    \ (string->list s0) (string->list s1))\n       (same-chars/help (string->list\
    \ s1) (string->list s0))))\n", "  (and (equal? (length s0) (length s1))\n    \
    \   (not (or (string-ci<? s0 s1)\n                (string-ci<? s1 s0)))))\n",
  "  (define (sc s0 s1 count-list)\n    (cond\n      [(null? s0) count-list]\n   \
    \   [(null? s1) count-list]\n      [else\n       (let ((ch (car s0))\n       \
    \      (cindex (index ch count-list)))\n         (if (= cindex -1)\n         \
    \    (sc (cdr s0) s1 (cons (cons ch 1) count-list))\n             (sc (cdr s0)\
    \ s1 (substitute-nth cindex\n                                            (cons\
    \ ch\n                                                  (add1 (cdr (nth cindex\
    \ count-list))))\n                                            count-list))))]))\n\
    \  (let ((c0 (sc s0 s1 '()))\n        (c1 (sc s1 s0 '())))\n    (let loop ((c0\
    \ c0) (c1 c1))\n      (cond\n        [(null? c0) #t]\n        [(null? c1) #f]\n\
    \        [(char=? (caar c0) (caar c1))\n         (if (= (cdar c0) (cdar c1))\n\
    \             (loop (cdr c0) (cdr c1))\n             #f)]\n        [else #f]))))\n",
  "  ;; Check if string s contains n copies of c.\n  (define (string-contains-n-copies\
    \ c n s)\n    (and (= n (count c s))\n         (cond ((empty? s) #t)\n       \
    \        ((equal? c (first s)) (string-contains-n-copies c (- n 1) (rest s)))\n\
    \               (else #f))))\n  (let ((len0 (string-length s0))\n        (len1\
    \ (string-length s1)))\n    (cond ((or (< len0 len1) (= len0 len1))\n        \
    \   (string-contains-n-copies (first s0) len0 s1))\n          (else (string-contains-n-copies\
    \ (first s1) len1 s0)))))\n", "  (let ((l0 (string->list s0))\n        (l1 (string->list\
    \ s1)))\n    (and (equal? (sort l0) (sort l0))\n         (equal? (sort l1) (sort\
    \ l1)))))\n", "  (define (same-chars-iter s0 s1 acc)\n    (cond ((and (string=?\
    \ s0 \"\") (string=? s1 \"\")) acc)\n          ((and (string=? s0 \"\") (not (string=?\
    \ s1 \"\"))) #f)\n          ((and (not (string=? s0 \"\")) (string=? s1 \"\"))\
    \ #f)\n          ((and (member (string-ref s0 0) acc) (member (string-ref s1 0)\
    \ acc))\n           (same-chars-iter (substring s0 1) (substring s1 1) acc))\n\
    \          ((and (member (string-ref s0 0) acc) (not (member (string-ref s1 0)\
    \ acc)))\n           (same-chars-iter (substring s0 1) (substring s1 1) acc))\n\
    \          ((and (not (member (string-ref s0 0) acc)) (member (string-ref s1 0)\
    \ acc))\n           (same-chars-iter (substring s0 1) (substring s1 1) acc))\n\
    \          ((and (not (member (string-ref s0 0) acc)) (not (member (string-ref\
    \ s1 0) acc)))\n           (same-chars-iter (substring s0 1) (substring s1 1)\
    \ (string-append acc (list (string-ref s0 0)))))\n          ))\n  (same-chars-iter\
    \ s0 s1 \"\"))\n", "  (andmap char=? (map sort (list s0 s1))))\n", "  (or\n  \
    \ (equal? s0 s1)\n   (eq? (count_chars s0) (count_chars s1))))\n", "  (cond [(string=?\
    \ s0 s1) #t]\n        [(not (string=? s0 \"\"))\n         (if (string-index s1\
    \ (string-ref s0 0))\n             (same_chars (substring s0 1) (string-replace\
    \ s1 (string-ref s0 0) \"\"))\n             #f)]\n        [else #f]))\n</code>\n",
  "  (and (= (string-length s0) (string-length s1))\n       (let loop ([s0 s0] [s1\
    \ s1])\n         (cond\n           [(string=? s0 \"\") #t]\n           [(string-contains?\
    \ s1 (string-ref s0 0))\n            (loop (string-tail s0 1)\n              \
    \    (string-remove (string-ref s0 0) s1))]\n           [else #f]))))\n", "  (define\
    \ (inner s0 s1)\n    (if (empty? s0) #t\n        (if (string-index s1 (substring\
    \ s0 0 1))\n            (inner (substring s0 1) (string-replace s1 (substring\
    \ s0 0 1) \"\"))\n            #f)))\n  (if (string=? (string-normalize-spaces\
    \ s0) \"\") #t\n      (if (string=? (string-normalize-spaces s1) \"\") #t\n  \
    \        (inner s0 s1))))\n", "  (let ([c0 (string->list s0)]\n        [c1 (string->list\
    \ s1)])\n    (cond\n      [(string=? s0 s1) #t]\n      [(or (empty? c0) (empty?\
    \ c1)) #f]\n      [(char=? (car c0) (car c1)) (same_chars (string-append (cdr\
    \ c0) \"\") (string-append (cdr c1) \"\"))]\n      [else (same_chars (string-append\
    \ c0 \"\") (string-append (cdr c1) \"\"))])))\n", "  (define (convert-string-to-char-counter\
    \ s)\n    (define (count-char-occurrences s)\n      (if (string-empty? s)\n  \
    \        '()\n          (cons (list (string-ref s 0) (string-count s (string-ref\
    \ s 0)))\n                (count-char-occurrences (string-drop s (string-count\
    \ s (string-ref s 0)))))))\n    (count-char-occurrences s))\n  (define (compare-two-char-counts\
    \ l0 l1)\n    (or (null? l0)\n        (and (equal? (car l0) (car l1))\n      \
    \       (compare-two-char-counts (cdr l0) (cdr l1)))))\n  (compare-two-char-counts\
    \ (convert-string-to-char-counter s0) (convert-string-to-char-counter s1)))\n",
  "  (define (helper s0 s1 dict)\n    (if (string-empty? s0)\n        (string-null?\
    \ s1)\n        (if (string-null? s1)\n            #f\n            (if (assoc s0\
    \ dict)\n                (if (string-null? (cdr (assoc s0 dict)))\n          \
    \          (helper (substring s0 1) s1 dict)\n                    (if (string-null?\
    \ (cdr (assoc s0 dict)))\n                        (helper (substring s0 1) s1\
    \ dict)\n                        (helper (substring s0 1) (substring s1 1) (update-dict\
    \ s0 s1 dict))))\n                (helper (substring s0 1) s1 (add-dict s0 s1\
    \ dict))))))\n  (helper s0 s1 (make-dict)))\n", "  (define (char-count word)\n\
    \    (hash-for-each (\u03BB (k v) (printf \"~a: ~a~n\" k v)) (char-count-hash\
    \ word)))\n  (define (char-count-hash word)\n    (let ([table (make-hash)])\n\
    \      (for ([c (in-string word)])\n        (hash-update table c add1 0))\n  \
    \    table))\n  (let ([t0 (char-count-hash s0)]\n        [t1 (char-count-hash\
    \ s1)])\n    (hash-for-each (\u03BB (k v)\n                    (when (not (hash-ref\
    \ t1 k 0))\n                      (error \"~a not in t1\" k)))\n             \
    \       t0)\n    (hash-for-each (\u03BB (k v)\n                    (when (not\
    \ (hash-ref t0 k 0))\n                      (error \"~a not in t0\" k)))\n   \
    \                 t1)\n    (hash-for-each (\u03BB (k v)\n                    (when\
    \ (< (hash-ref t0 k 0) (hash-ref t1 k 0))\n                      (error \"~a:\
    \ t0: ~a is not >= t1: ~a\" k (hash-ref t0 k 0) (hash-ref t1 k 0))))\n       \
    \             t0)\n    (hash-for-each (\u03BB (k v)\n                    (when\
    \ (< (hash-ref t1 k 0) (hash-ref t0 k 0))\n                      (error \"~a:\
    \ t1: ~a is not >= t0: ~a\" k (hash-ref t1 k 0) (hash-ref t0 k 0))))\n       \
    \             t1)\n    #t))\n", "  (and (same-chars s0 s1)\n       (same-chars\
    \ s1 s0)))\n", "  (equal? (string-sort s0) (string-sort s1)))\n", "  (equal? (sort\
    \ (string->list s0) <)\n          (sort (string->list s1) <)))\n", "  (cond\n\
    \    [(empty? s0) (empty? s1)]\n    [(empty? s1) #f]\n    [else\n     (let ([char\
    \ (first s0)])\n       (and (char=? char (first s1))\n            (same_chars\
    \ (rest s0) (string-remove char s1))))]))\n", "  (cond\n    [(empty? s0) (empty?\
    \ s1)]\n    [(empty? s1) (empty? s0)]\n    [else (and (contains? s1 (first s0))\n\
    \               (same_chars (rest s0) (remove (first s0) s1)))]))\n", "  (or (char-count-compare\
    \ s0 s1)\n      (char-count-compare s1 s0)))\n", "  (and (not (string-contains\
    \ \"abcd\" \"e\"))\n       (not (string-contains \"abcd\" \"e\"))))\n", "  (define\
    \ (is_member c xs)\n    (cond\n      [(empty? xs) #f]\n      [(char=? c (first\
    \ xs)) #t]\n      [else (is_member c (rest xs))]))\n  (define (same-helper s0\
    \ s1)\n    (cond\n      [(empty? s0) (zero? (string-length s1))]\n      [(is_member\
    \ (first s0) s1) (same-helper (rest s0) (string-remove (first s0) s1))]\n    \
    \  [else #f]))\n  (same-helper s0 s1))\n", "  (define (inner s0 s1)\n    (cond\n\
    \      ((and (string-empty? s0) (string-empty? s1)) #t)\n      ((or (string-empty?\
    \ s0) (string-empty? s1)) #f)\n      ((string-match (regexp (regexp-quote (string-take\
    \ s0 1))) s1)\n       (inner (string-drop s0 1) (string-drop s1 (add1 (string-match\
    \ (regexp (regexp-quote (string-take s0 1))) s1)))))\n      (else #f)))\n  (inner\
    \ s0 s1))\n```\n\n### [Solutions](https://github.com/sol-prog/F-exercises/blob/master/same_chars.fsx)\n\
    \n\n\n#### [Problem 4](https://www.reddit.com/r/dailyprogrammer/comments/pkw2m/2112012_challenge_3_easy/)\
    \ \n\nYou will be given two strings, A and B. Print one line: 1 if string B occurs\
    \ at the end of string A. Otherwise, print 0.\n\n```\n#lang racket\n", "  (define\
    \ (same_chars_0 s0 s1)\n    (cond [(empty? s0) true]\n          [(empty? s1) false]\n\
    \          [(string=? (first s0) (first s1)) (same_chars_0 (rest s0) (rest s1))]\n\
    \          [else (same_chars_0 (rest s0) s1)]))\n  (define (same_chars_1 s0 s1)\n\
    \    (cond [(empty? s0) false]\n          [(empty? s1) true]\n          [(string=?\
    \ (first s0) (first s1)) (same_chars_1 (rest s0) (rest s1))]\n          [else\
    \ (same_chars_1 (rest s0) s1)]))\n  (cond [(or (string-empty? s0) (string-empty?\
    \ s1)) (string=? s0 s1)]\n        [(string&lt;=? s0 s1) (same_chars_0 s0 s1)]\n\
    \        [else (same_chars_1 s0 s1)]))\n</code>\n", "  (let ((ls0 (string->list\
    \ s0))\n        (ls1 (string->list s1)))\n    (let loop ((ls0 ls0)\n         \
    \      (ls1 ls1))\n      (cond ((and (null? ls0) (null? ls1)) #t)\n          \
    \  ((or (null? ls0) (null? ls1)) #f)\n            ((char=? (car ls0) (car ls1))\
    \ (loop (cdr ls0) (cdr ls1)))\n            ((member (car ls0) ls1) (loop (cdr\
    \ ls0)\n                                          (remove (car ls0) ls1)))\n \
    \           (else #f)))))\n", "  (not (or (not (equal? (string-length s0) (string-length\
    \ s1)))\n           (ormap (lambda (x) (not (string-contains? s1 x))) (string->list\
    \ s0)))))\n", "  (cond\n    [(or (empty? s0) (empty? s1)) true]\n    [(char=?\
    \ (string-ref s0 0) (string-ref s1 0))\n     (same_chars (substring s0 1) (substring\
    \ s1 1))]\n    [else (same_chars (substring s0 1) s1)]))\n", "  (equal? (sort\
    \ (string->list s0) <)\n          (sort (string->list s1) <)))\n", "  (cond\n\
    \    [(empty? s0) (empty? s1)]\n    [(empty? s1) #f]\n    [else\n     (let* ([a\
    \ (first s0)]\n            [b (first s1)]\n            [s0 (rest s0)]\n      \
    \      [s1 (rest s1)])\n       (or (char=? a b)\n           (same_chars (string\
    \ (list a) s0) s1)\n           (same_chars s0 (string (list b) s1))))]))\n", " \
    \ (and (equal? (sort s0) (sort s1))\n       (not (or (string-suffix? \"e\" s0)\n\
    \                (string-suffix? \"e\" s1)))))\n", "  (define (count-char-in-string\
    \ s c)\n    (cond\n      [(empty? s) 0]\n      [(equal? (first s) c) (+ 1 (count-char-in-string\
    \ (rest s) c))]\n      [else (count-char-in-string (rest s) c)]))\n  (define (same-chars?\
    \ s)\n    (cond\n      [(empty? s) #t]\n      [(= (count-char-in-string s0 (first\
    \ s))\n          (count-char-in-string s1 (first s)))\n       (same-chars? (rest\
    \ s))]\n      [else #f]))\n  (same-chars? (list->set (append s0 s1))))", "  (and\
    \ (string=? (sort s0) (sort s1))\n       (and (>= (string-length s0) (string-length\
    \ s1))\n            (>= (string-length s1) (string-length s0)))))\n", "  (and\
    \ (every (lambda (c) (contains s0 c)) s1)\n       (every (lambda (c) (contains\
    \ s1 c)) s0)))\n", "  (and (set= (string->list s0) (string->list s1))\n      \
    \ (= (string-length s0) (string-length s1))))\n", "  (and (= (string-length s0)\
    \ (string-length s1))\n       (for/and ([char (in-string s0)])\n             \
    \   (member char s1))))\n", "  (letrec ([count (lambda (s c) (if (empty? s) 0\
    \ (+ (equal? (first s) c) (count (rest s) c))))])\n    (andmap (cut equal? (count\
    \ s0) (count s1)) (range (char->integer #\\a) (char->integer #\\z)))))\n", " \
    \ (if (or (zero? (string-length s0))\n          (zero? (string-length s1)))\n\
    \      #t\n      (if (char=? (string-ref s0 0) (string-ref s1 0))\n          (same_chars\
    \ (substring s0 1) (substring s1 1))\n          (same_chars (substring s0 1) s1))))\n",
  "  (and (equal? (sort (string->list s0)) (sort (string->list s1))) #t))\n", "  (and\
    \ (= (length s0) (length s1))\n       (set= (string->list s0) (string->list s1))))\n",
  "  (define (same_chars-iter char-map0 char-map1)\n    (cond [(and (hash-empty? char-map0)\
    \ (hash-empty? char-map1)) true]\n          [(and (hash-empty? char-map0) (not\
    \ (hash-empty? char-map1))) false]\n          [(and (not (hash-empty? char-map0))\
    \ (hash-empty? char-map1)) false]\n          [else (let ([char (hash-first char-map0)])\n\
    \                  (same_chars-iter (hash-remove char-map0 char)\n           \
    \                        (hash-remove char-map1 char)))]))\n  (same_chars-iter\
    \ (hash-ref (string->char-count-map s0) #f 0)\n                   (hash-ref (string->char-count-map\
    \ s1) #f 0)))\n", "  (define (same_char_counts c0 c1)\n    (and (not (equal? (length\
    \ c0) (length c1)))\n         (equal? (sort (map char-&gt;integer c0) &lt;)\n\
    \                 (sort (map char-&gt;integer c1) &lt;))))\n  (let* ([c0 (count\
    \ s0)]\n         [c1 (count s1)])\n    (and (same_char_counts c0 c1)\n       \
    \  (same_char_counts c1 c0))))\n</code>\n<code>count</code> from <code>plai</code>\
    \ just counts the number of occurrences of each character in a string:\n<code>#lang\
    \ racket\n", "  (define (has-all? s0 s1)\n    (let ((result #t))\n      (for ((c\
    \ s0))\n        (when (not (string-contains s1 c))\n          (set! result #f)))\n\
    \      result))\n  (has-all? s0 s1)\n  (has-all? s1 s0))\n", "  (cond [(equal?\
    \ (list-set s0) (list-set s1)) #t]\n        [else #f]))\n", "  (and (string=?\
    \ (sort s0) (sort s1))\n       (equal? (string-length s0) (string-length s1))))\n",
  "  (let ([count0 (string-&gt;list s0)]\n        [count1 (string-&gt;list s1)])\n\
    \    (every (\u03BB (x) (= (count (string-&gt;list s0) x) (count (string-&gt;list\
    \ s1) x))) count0)))\n", "  (let ([s0 (string-&gt;list s0)]\n        [s1 (string-&gt;list\
    \ s1)])\n    (cond [(null? s0) (null? s1)]\n          [(null? s1) #f]\n      \
    \    [else (or (member (car s0) s1)\n                    (same_chars (cdr s0)\
    \ s1))])))\n</code>\nFor the most part, I think this is the most obvious way to\
    \ solve the problem. Maybe I'm not seeing the super-simple way to solve this problem,\
    \ but I think this is likely the best way. \nAs to why I chose <code>cdr</code>\
    \ and <code>car</code> instead of <code>first</code> and <code>rest</code>, that\
    \ is a personal preference. <code>car</code> and <code>cdr</code> are so much\
    \ clearer on their intent. I don't have to think about what they do. \n", "  (define\
    \ (loop s0 s1)\n    (cond\n      [(empty? s0)\n       (empty? s1)]\n      [(empty?\
    \ s1)\n       #f]\n      [else\n       (and (member (first s0) s1)\n         \
    \   (loop (rest s0)\n                  (remove (first s0) s1)))]))\n  (loop (string->list\
    \ s0)\n        (string->list s1)))\n</code>\n", "  (and (= (string-length s0)\
    \ (string-length s1))\n       (every string=? (sort (string->list s0))\n     \
    \                (sort (string->list s1)))))\n\n", "  (cond ((equal? s0 \"\")\
    \ (not (equal? s1 \"\")))\n        ((equal? s1 \"\") (not (equal? s0 \"\")))\n\
    \        ((not (equal? (take-right s0 1) \"\"))\n         (member (take-right\
    \ s0 1) s1))\n        (else\n         (and (member (take-right s0 1) s1)\n   \
    \           (same_chars (take s0 -1)\n                          (drop s1 (index\
    \ (take-right s0 1) s1)))))))\n", "  (define (same_chars0 s0 s1)\n    (if (zero?\
    \ (string-length s0))\n        #t\n        (if (not (string-contains s1 (string-ref\
    \ s0 0)))\n            #f\n            (same_chars0 (substring s0 1) (string-delete\
    \ (string-ref s0 0) s1)))))\n  (same_chars0 s0 s1))\n", "  (not (not (equal?\n\
    \             (sorted-string s0)\n             (sorted-string s1)))))\n", "  (let\
    \ ([s0 (string-&gt;list s0)]\n        [s1 (string-&gt;list s1)])\n    (and (=\
    \ (length s0) (length s1))\n         (letrec ([find-char (lambda (c s0 s1)\n \
    \                              (cond [(empty? s0)\n                          \
    \            #f]\n                                     [(or (eq? c (first s0))\n\
    \                                          (eq? c (first s1)))\n             \
    \                         (find-char c (rest s0) (rest s1))]\n               \
    \                      [else #f]))])\n           (find-char (first s0) (rest s0)\
    \ (rest s1))))))\n</code>\nMy question is: why doesn't <code>check-expect</code>\
    \ work with <code>same_chars</code>?\n\n\nA:\n\nThe problem is that <code>check-expect</code>\
    \ needs to <code>eval</code> the expression passed as the first argument, but\
    \ the expression you're passing only works when evaluated in the scope of the\
    \ <code>let</code>. It's a scope issue. The simplest fix is to use <code>equal?</code>\
    \ instead of <code>eq?</code> for the comparison, because that allows the <code>list</code>\
    \ to be <code>eval</code>ed outside of the <code>let</code> scope. The other fix\
    \ is to make the <code>let</code> form a <code>letrec</code> so the entire expression\
    \ works in <code>check-expect</code>'s scope:\n<code>(define (same_chars s0 s1)\n\
    \  (letrec ([s0 (string-&gt;list s0)]\n           [s1 (string-&gt;list s1)]\n\
    \           [find-char (lambda (c s0 s1)\n                        (cond [(empty?\
    \ s0)\n                               #f]\n                              [(or\
    \ (eq? c (first s0))\n                                   (eq? c (first s1)))\n\
    \                               (find-char c (rest s0) (rest s1))]\n         \
    \                     [else #f]))])\n    (and (= (length s0) (length", "  (cond\n\
    \    [(string=? \"\" s0)\n     (string=? \"\" s1)]\n    [(string=? \"\" s1)\n\
    \     (string=? \"\" s0)]\n    [else\n     (cond\n       [(not (string-contains\
    \ s0 (string-ref s1 0))) #f]\n       [else\n        (same_chars (string-remove\
    \ s0 (string-ref s1 0))\n                    (string-remove s1 (string-ref s1\
    \ 0)))])]))\n", "  (and (same-chars-aux s0 (string->list s1))\n       (same-chars-aux\
    \ s1 (string->list s0))))\n", "  ;; TODO: implement me.\n  )\n", "  (and (string=?\
    \ (sorted-string s0) (sorted-string s1))\n       (= (string-length s0) (string-length\
    \ s1))))\n", "  (and (andmap (lambda (c) (>= (count c s0) (count c s1))) (explode\
    \ s1))\n       (andmap (lambda (c) (>= (count c s1) (count c s0))) (explode s0))))\n",
  "  (and (= (string-length s0) (string-length s1))\n       (not (null? (for/and ([c\
    \ (in-string s0)])\n                       (if (string-contains s1 c)\n      \
    \                     (string-remove c s1)\n                           #f))))))\n",
  "  (cond ((equal? (string-length s0) 0)\n         (equal? (string-length s1) 0))\n\
    \        ((string-contains? s1 (string-ref s0 0))\n         (same_chars (substring\
    \ s0 1)\n                     (substring s1 0 (- (string-length s1) 1))))\n  \
    \      (else #f)))\n\n", "  (let loop ([d0 (make-hash)] [d1 (make-hash)])\n  \
    \  (cond\n      [(empty? s0) (equal? (hash-count d0) (hash-count d1))]\n     \
    \ [(empty? s1) (equal? (hash-count d0) (hash-count d1))]\n      [else\n      \
    \ (let ([c0 (char-downcase (string-ref s0 0))]\n             [c1 (char-downcase\
    \ (string-ref s1 0))])\n         (cond\n           [(= c0 c1)\n            (let\
    \ ([d0 (hash-update d0 c0 add1 0)]\n                  [d1 (hash-update d1 c1 add1\
    \ 0)])\n              (loop (string-drop s0 1) (string-drop s1 1)))]\n       \
    \    [else\n            (or (hash-has-key? d0 c1) (hash-has-key? d1 c0))]))])))\n",
  "  (let ([m0 (make-hasheq)]\n        [m1 (make-hasheq)])\n    (for ([c s0])\n  \
    \    (hash-set! m0 c (add1 (hash-ref m0 c 0))))\n    (for ([c s1])\n      (hash-set!\
    \ m1 c (add1 (hash-ref m1 c 0))))\n    (for ([(c n) (in-hash m0)])\n      (unless\
    \ (= n (hash-ref m1 c 0))\n        (return #f)))\n    #t))\n", "  ;; accumulate\
    \ a list of the counts of each character seen.\n  (define (accumulate-chars s)\n\
    \    (define (chars str)\n      (if (empty? str)\n          '()\n          (cons\
    \ (first str) (chars (rest str)))))\n    (define (count-chars str counts)\n  \
    \    (if (empty? str)\n          counts\n          (count-chars (rest str)\n \
    \                      (accumulate-char (first str) counts))))\n    (define (accumulate-char\
    \ c counts)\n      (if (null? counts)\n          (list (list c 1))\n         \
    \ (cond ((equal? c (caar counts))\n                 (cons (list c (+ 1 (cdar counts)))\
    \ (cdr counts)))\n                (else (cons (list c 1) counts)))))\n    (count-chars\
    \ (chars s) '()))\n  (define (same-chars? counts0 counts1)\n    (if (or (null?\
    \ counts0) (null? counts1))\n        (equal? counts0 counts1)\n        (and (equal?\
    \ (car counts0) (car counts1))\n             (same-chars? (cdr counts0) (cdr counts1)))))\n\
    \  (same-chars? (accumulate-chars s0) (accumulate-chars s1)))", "  (define (same-chars-iter\
    \ s0 s1 counts)\n    (cond\n      [(empty? s0) (all-zero? counts)]\n      [(empty?\
    \ s1) #f]\n      [else\n       (let ([c0 (first s0)]\n             [c1 (first\
    \ s1)])\n         (same-chars-iter (rest s0) (rest s1)\n                     \
    \     (update-counts counts c0 c1)))]))\n  (same-chars-iter s0 s1 (make-empty-counts)))\n",
  "  (equal? (sort (string->list s0) <)\n          (sort (string->list s1) <)))\n",
  "  (and\n   (andmap (lambda (c) (memq c s0)) s1)\n   (andmap (lambda (c) (memq c\
    \ s1)) s0)))\n", "  (define s0-chars (string->list s0))\n  (define s1-chars (string->list\
    \ s1))\n  (cond\n    [(empty? s0-chars) (empty? s1-chars)]\n    [(empty? s1-chars)\
    \ #f]\n    [else\n     (let ([c0 (first s0-chars)]\n           [c1 (first s1-chars)])\n\
    \       (cond\n         [(equal? c0 c1)\n          (same_chars (string (rest s0-chars))\n\
    \                      (string (rest s1-chars)))]\n         [else\n          (or\
    \ (same_chars (string (rest s0-chars)) s1)\n              (same_chars s0 (string\
    \ (rest s1-chars))))]))]))\n", "  (define (same-chars-iter s0 s1)\n    (if (zero?\
    \ (length s0))\n        (if (zero? (length s1))\n            #t\n            #f)\n\
    \        (let ([c (string-ref s0 0)])\n          (if (regexp-match (regexp (format\
    \ \"[~a]\" c)) s1)\n              (same-chars-iter (substring s0 1) (regexp-replace\
    \ (regexp (format \"[~a]\" c)) s1 \"\"))\n              #f))))\n  (same-chars-iter\
    \ s0 s1))\n", "  (cond\n    [(or (empty? s0) (empty? s1)) (and (empty? s0) (empty?\
    \ s1))]\n    [else (or (same_chars (rest s0) s1)\n              (and (char=? (first\
    \ s0) (first s1))\n                   (same_chars (rest s0) (rest s1))))]))\n",
  "  (cond\n    [(and (empty? s0) (empty? s1)) #t]\n    [(empty? s0) #f]\n    [(empty?\
    \ s1) #f]\n    [(equal? (first s0) (first s1)) (same_chars (rest s0) (rest s1))]\n\
    \    [else (same_chars (rest s0) s1)]))", "  (cond [(string=? s0 s1) #t]\n   \
    \     [(string=? (sort-string s0) (sort-string s1)) #t]\n        [else #f]))\n\
    ```\n\n#### Alternative Solution\n\nA much simpler solution for this is:\n\n```racket\n\
    #lang racket\n", "  (define (same_chars_iter s0 s1)\n    (cond [(null? s0) (null?\
    \ s1)]\n          [(eq? (first s0) (first s1)) (same_chars_iter (rest s0) (rest\
    \ s1))]\n          [else (and (member (first s0) (rest s1))\n                \
    \     (same_chars_iter (rest s0) (remove (first s0) s1)))]))\n  (same_chars_iter\
    \ (string->list s0) (string->list s1)))\n", "  (let loop ([s0 s0] [s1 s1])\n \
    \   (match (list s0 s1)\n      [(list #\"\" #\"\") #t]\n      [(list #\"\" s1)\n\
    \       (char-set-empty? (char-set-difference (string->char-set s1)\n        \
    \                                     (string->char-set s0)))]\n      [(list s0\
    \ #\"\")\n       (char-set-empty? (char-set-difference (string->char-set s0)\n\
    \                                             (string->char-set s1)))]\n     \
    \ [(list (string-take s0 1)\n             (string-take s1 1))\n       (loop (string-drop\
    \ s0 1)\n             (string-drop s1 1))]\n      [(list (string-take s0 1)\n\
    \             (string-drop s1 1))\n       (and (char-set-contains? (string->char-set\
    \ s1)\n                                (string-ref s0 0))\n            (loop (string-drop\
    \ s0 1)\n                  (string-drop s1 1)))]\n      [(list (string-drop s0\
    \ 1)\n             (string-take s1 1))\n       (and (char-set-contains? (string->char-set\
    \ s0)\n                                (string-ref s1 0))\n            (loop (string-drop\
    \ s0 1)\n                  (string-drop s1 1)))]\n      [_ #f])))\n", "  (define\
    \ (same-chars-h s0 s1)\n    (if (string-empty? s0)\n        (not (string-empty?\
    \ s1))\n        (if (member (string-ref s0 0) s1)\n            (same-chars-h (string-tail\
    \ s0) (string-remove (string-ref s0 0) s1))\n            #f)))\n  (same-chars-h\
    \ s0 s1))\n", "  (cond\n    [(empty? s0) (empty? s1)]\n    [(empty? s1) #f]\n\
    \    [else\n     (and (member (first s0) s1)\n          (same_chars (rest s0)\
    \ (substring s1 0 (length s1))))]))\n", "  ;; sorts the two strings\n  (set! s0\
    \ (string-sort s0))\n  (set! s1 (string-sort s1))\n  ;; if they are the same,\
    \ then both strings are the same\n  (string=? s0 s1))\n", "  (and (= (length s0)\
    \ (length s1))\n       (equal? (sort (string->list s0)) (sort (string->list s1)))))\n",
  "  (let loop ([s0 s0] [s1 s1])\n    (if (and (zero? (string-length s0)) (zero? (string-length\
    \ s1)))\n        #t\n        (let ([needle (string-take s0 1)])\n          (if\
    \ (string-contains s1 needle)\n              (loop (string-drop s0 1) (string-drop\
    \ s1 (string-index s1 needle)))\n              #f)))))\n</code>\n", "  (define\
    \ (sc chars s)\n    (if (empty? s)\n        (empty? chars)\n        (let ([c (first\
    \ s)])\n          (if (contains-char? chars c)\n              (sc (remove-char\
    \ c chars) (rest s))\n              #f))))\n  (sc (string->list s0) s1))\n", " \
    \ (define (char-match t0 t1)\n    (or (and (char=? (car t0) (car t1))\n      \
    \       (char-match (cdr t0) (cdr t1)))\n        (and (char=? (car t0) (car t1))\n\
    \             (char-match (cdr t0) t1))\n        (and (char=? (car t0) (car t1))\n\
    \             (char-match t0 (cdr t1)))\n        (and (char=? (car t0) (car t1))\n\
    \             #t)))\n  (or (char-match (string->list s0) (string->list s1))\n\
    \      (char-match (string->list s1) (string->list s0))))\n", "  (local [(define\
    \ s0-cnt (char-counts s0))\n          (define s1-cnt (char-counts s1))]\n    (and\
    \ (= (string-length s0) (string-length s1))\n         (for/and ([(c0 c0-n) s0-cnt]\n\
    \                   [(c1 c1-n) s1-cnt])\n           (equal? c0 c1)\n         \
    \  (equal? c0-n c1-n)))))\n", "  (define (same_chars_iter s0 s1)\n    (cond\n\
    \      [(empty? s0) true]\n      [(and (char=? (first s0) (first s1))\n      \
    \      (same_chars_iter (rest s0) (remove (first s0) s1)))\n       true]\n   \
    \   [else false]))\n  (same_chars_iter s0 s1))\n", "  (define (char-count s)\n\
    \    (for/fold ([counters (make-hash)])\n               ([c (in-string s)])\n\
    \      (hash-update counters c (\u03BB (n) (add1 n)) 1)))\n  (define cc0 (char-count\
    \ s0))\n  (define cc1 (char-count s1))\n  (andmap (\u03BB (key) (equal? (hash-ref\
    \ cc0 key 1) (hash-ref cc1 key 1)))\n          (hash-keys cc0)))\n```\n\n```racket\n\
    #lang racket\n", "  (define (same_chars-substring xs ys)\n    (let ([x (first\
    \ xs)]\n          [y (first ys)])\n      (cond [(empty? xs) #t]\n            [(empty?\
    \ ys) #f]\n            [(and (equal? x y)\n                  (same_chars-substring\
    \ (rest xs) (rest ys)))]\n            [(same_chars-substring xs (rest ys))])))\n\
    \  (same_chars-substring (string->list s0) (string->list s1)))\n", "  (define\
    \ (count c s)\n    (cond [(empty? s) 0]\n          [(char=? c (first s)) (+ 1\
    \ (count c (rest s)))]\n          [else (count c (rest s))]))\n  (cond [(or (empty?\
    \ s0) (empty? s1))\n         (equal? s0 s1)]\n        [(char=? (first s0) (first\
    \ s1))\n         (same_chars (rest s0) (rest s1))]\n        [(> (count (first\
    \ s0) s1) 0)\n         (same_chars (rest s0) s1)]\n        [(> (count (first s1)\
    \ s0) 0)\n         (same_chars s0 (rest s1))]\n        [else #f]))", "  (define\
    \ (helper chr ls)\n    (cond ((null? ls) 0)\n          ((eq? chr (car ls)) (+\
    \ 1 (helper chr (cdr ls))))\n          (else (helper chr (cdr ls)))))\n  (and\
    \ (eq? (string-length s0) (string-length s1))\n       (null? (remove* s0 '() (string->list\
    \ s1)))\n       (eq? (helper #\\a s0) (helper #\\a s1))\n       (eq? (helper #\\\
    b s0) (helper #\\b s1))\n       (eq? (helper #\\c s0) (helper #\\c s1))\n    \
    \   (eq? (helper #\\d s0) (helper #\\d s1))\n       (eq? (helper #\\e s0) (helper\
    \ #\\e s1))\n       (eq? (helper #\\f s0) (helper #\\f s1))\n       (eq? (helper\
    \ #\\g s0) (helper #\\g s1))\n       (eq? (helper #\\h s0) (helper #\\h s1))\n\
    \       (eq? (helper #\\i s0) (helper #\\i s1))\n       (eq? (helper #\\j s0)\
    \ (helper #\\j s1))\n       (eq? (helper #\\k s0) (helper #\\k s1))\n       (eq?\
    \ (helper #\\l s0) (helper #\\l s1))\n       (eq? (helper #\\m s0) (helper #\\\
    m s1))\n       (eq? (helper #\\n s0) (helper #\\n s1))\n       (eq? (helper #\\\
    o s0) (helper #\\o s1))\n       (eq? (helper #\\p s0) (helper #\\p s1))\n    \
    \   (eq? (helper #\\q s0) (helper #\\q s1))\n       (eq? (helper #\\r s0) (helper\
    \ #\\r s", "  (let ((freq0 (get-freq s0))\n        (freq1 (get-freq s1)))\n  \
    \  (and (freq-entry-equal? freq0 freq1)\n         (freq-entry-equal? freq1 freq0))))\n",
  "  (let ([ss0 (string->list s0)]\n        [ss1 (string->list s1)])\n    (and (every\
    \ (lambda (c) (member c ss1)) ss0)\n         (every (lambda (c) (member c ss0))\
    \ ss1))))\n", "  (define (same_chars_internal s0 s1)\n    (if (string-null? s0)\n\
    \        s1\n        (if (string-null? s1)\n            s0\n            (let ([c0\
    \ (string-ref s0 0)]\n                  [c1 (string-ref s1 0)])\n            \
    \  (if (char=? c0 c1)\n                  (same_chars_internal (substring s0 1)\
    \ (substring s1 1))\n                  (same_chars_internal s0 (substring s1 1)))))))\n\
    \  (and (= (string-length s0) (string-length s1))\n       (string=? (same_chars_internal\
    \ s0 s1) \"\")))", "  (and (every (flip string-contains? s0) (string->list s1))\n\
    \       (every (flip string-contains? s1) (string->list s0))))\n", "  (equal?\
    \ (string-sort s0) (string-sort s1)))\n", "  (cond\n    [(empty? s0) (empty? s1)]\n\
    \    [(empty? s1) #f]\n    [else\n     (if (eq? (first s0) (first s1))\n     \
    \    (same_chars (rest s0) (rest s1))\n         (same_chars (rest s0) s1))]))\n",
  "  (define (helper s0 s1)\n    (match s0\n      ['() s1]\n      [(cons c0 s0)\n\
    \       (let ([s1 (string-remove c0 s1)])\n         (if (zero? (string-length\
    \ s1))\n             #f\n             (helper s0 s1)))]))\n  (helper (string->list\
    \ s0) s1))\n", "  (define (same_chars_helper s0 s1)\n    (cond\n      [(empty?\
    \ s0) (and (empty? s1) #t)]\n      [(empty? s1) #f]\n      [else (define (contains?\
    \ chr s)\n              (cond\n                [(empty? s) #f]\n             \
    \   [(char=? chr (first s)) #t]\n                [else (contains? chr (rest s))]))\n\
    \            (and (contains? (first s0) s1)\n                 (same_chars_helper\
    \ (rest s0) (rest s1)))]))\n  (same_chars_helper (string->list s0) (string->list\
    \ s1)))\n", "  (cond [(empty? s0)\n         (empty? s1)]\n        [(empty? s1)\n\
    \         (empty? s0)]\n        [else\n         (and\n          (let ([c (first\
    \ s0)])\n            (and (member c s1)\n                 (remove c s1)))\n  \
    \        (same_chars (rest s0) (rest s1)))]))\n", "  (and (equal? (string-length\
    \ s0) (string-length s1))\n       (for/and ([c (in-string s0)])\n            \
    \    (string-contains s1 c))))\n", "  (and (andmap (lambda (c) (andmap (lambda\
    \ (d) (equal? c d)) s1)) s0)\n       (andmap (lambda (c) (andmap (lambda (d) (equal?\
    \ c d)) s0)) s1)))\n", "  (let ([d (make-hash)])\n    (for ([i (in-range (string-length\
    \ s0))])\n      (hash-update! d (string-ref s0 i) add1 0))\n    (for ([i (in-range\
    \ (string-length s1))])\n      (hash-update! d (string-ref s1 i) sub1 0))\n  \
    \  (every? (lambda (k v) (= v 0)) d)))\n", "  (define (same? s0 s1)\n    (cond\n\
    \      [(equal? \"\" s0) #t]\n      [(equal? \"\" s1) #f]\n      [(member (string-ref\
    \ s0 0) s1) (same? (substring s0 1) (remove (string-ref s0 0) s1))]\n      [else\
    \ #f]))\n  (and (same? s0 s1) (same? s1 s0)))\n", "  (letrec ([count-char (lambda\
    \ (c chars)\n                         (if (char=? c #\\\") 0 (add1 (count-char\
    \ c (cdr chars)))))])\n    (define (helper as bs)\n      (cond [(empty? as) (and\
    \ (empty? bs) #t)]\n            [(member (car as) bs) (helper (cdr as) (remove\
    \ (car as) bs))]\n            [else #f]))\n    (let ([a (map (lambda (c) (cons\
    \ c (count-char c s0))) s0)]\n          [b (map (lambda (c) (cons c (count-char\
    \ c s1))) s1)])\n      (helper a b))))\n", "  (define (cmp x y) (cond\n      \
    \              [(< x y) 't]\n                    [(> x y) 'f]\n              \
    \      [else (cmp (add1 x) (add1 y))]))\n  (define (same-p x y)\n    (if (null?\
    \ x)\n        (if (null? y)\n            #t\n            #f)\n        (if (null?\
    \ y)\n            #f\n            (let ([x (car x)]\n                  [y (car\
    \ y)])\n              (cond\n               [(eq? x y)\n                (same-p\
    \ (cdr x) (cdr y))]\n               [(equal? (cmp x y) 't)\n                (same-p\
    \ (cdr x) y)]\n               [(equal? (cmp x y) 'f)\n                (same-p\
    \ x (cdr y))]\n               [else #f])))))\n  (same-p (string->list s0) (string->list\
    \ s1)))\n", "  (equal? (sort s0) (sort s1)))\n", "  (equal?\n   (sort (list->set\
    \ (string->list s0)) string<? #:key char->integer)\n   (sort (list->set (string->list\
    \ s1)) string<? #:key char->integer)))\n</code>\n", "  (let loop ([s0 s0] [s1\
    \ s1])\n    (if (or (equal? s0 \"\") (equal? s1 \"\"))\n        #t\n        (if\
    \ (char=? (string-ref s0 0) (string-ref s1 0))\n            (loop (substring s0\
    \ 1) (substring s1 1))\n            (loop (substring s0 1) s1)))))\n", "  (let\
    \ ([l0 (string-&gt;list s0)]\n        [l1 (string-&gt;list s1)])\n    (and (=\
    \ (length l0) (length l1))\n         (equal? (sort l0 &lt;=?) (sort l1 &lt;=?)))))\n",
  "  (and (andmap (lambda (c) (string-contains s0 c)) (string->list s1))\n       (andmap\
    \ (lambda (c) (string-contains s1 c)) (string->list s0))))\n", "  (equal? (sort\
    \ s0 <) (sort s1 <)))\n", "  (define (get_char_freq s)\n    (let loop ([s s] [acc\
    \ '()])\n      (cond [(string-empty? s) acc]\n            [else (loop (substring\
    \ s 1)\n                        (let ([m (member (string-ref s 0) acc)])\n   \
    \                       (if m\n                              (cons (cons (car\
    \ m) (+ 1 (cdr m)))\n                                    (remove (car m) acc))\n\
    \                              (cons (cons (string-ref s 0) 1) acc))))])))\n \
    \ (define (cmp-freq f0 f1)\n    (cond [(null? f0) #t]\n          [(null? f1) #f]\n\
    \          [(char=? (car (car f0)) (car (car f1)))\n           (and (= (cdr (car\
    \ f0)) (cdr (car f1)))\n                (cmp-freq (cdr f0) (cdr f1)))]\n     \
    \     [else #f]))\n  (cmp-freq (get_char_freq s0) (get_char_freq s1)))\n", " \
    \ (andmap\n   (lambda (c)\n     (>= (count c s0) (count c s1)))\n   (remdup (append\
    \ s0 s1))))\n", "  (define (same-chars? sl)\n    (if (null? sl)\n        #t\n\
    \        (let ([c (car sl)])\n          (and (member c s0)\n               (same-chars?\
    \ (cdr sl))))))\n  (same-chars? (string->list s1)))\n", "  (cond\n    [(string=?\
    \ s0 s1) #t]\n    [(string=? s0 \"\") #f]\n    [(string=? s1 \"\") #f]\n    [(char=?\
    \ (string-ref s0 0) (string-ref s1 0))\n     (same_chars (substring s0 1) (substring\
    \ s1 1))]\n    [else (or (same_chars (substring s0 1) s1)\n              (same_chars\
    \ s0 (substring s1 1)))]))\n", "  (and (every (curry string-contains? s0) s1)\n\
    \       (every (curry string-contains? s1) s0)))\n", "  (cond\n    [(empty? s0)\
    \ (empty? s1)]\n    [(empty? s1) #f]\n    [else\n     (define c0 (first s0))\n\
    \     (define n (count c0 s0))\n     (define n1 (count c0 s1))\n     (and (= n\
    \ n1)\n          (same_chars (remove* c0 n s0) (remove* c0 n1 s1)))]))\n", " \
    \ (define (is-match? c)\n    (andmap (lambda (c1) (char=? c c1)) s1))\n  (andmap\
    \ is-match? s0))\n", "  (let ([cs0 (string->list s0)]\n        [cs1 (string->list\
    \ s1)])\n    (and (andmap (lambda (c) (member c cs1)) cs0)\n         (andmap (lambda\
    \ (c) (member c cs0)) cs1))))\n", "  (cond\n    [(and (equal? (count s0) (count\
    \ s1)) (equal? (sort s0) (sort s1))) #t]\n    [else #f]))\n", "  (define (helper\
    \ s0 s1)\n    (cond ((and (empty? s0) (empty? s1)) #t)\n          ((empty? s0)\
    \ #f)\n          ((member (first s0) s1) (helper (rest s0) (string-remove (first\
    \ s0) s1)))\n          (else #f)))\n  (helper (string->list s0) (string->list\
    \ s1)))\n", "  (define (helper s)\n    (hash (for/fold ([table (make-hash)])\n\
    \            ([c (in-string s)])\n            (hash-update table c add1 0))))\n\
    \  (define (hash-difference hash1 hash2)\n    (for/hash ([k (in-hash hash1)]\n\
    \               [v1 (in-hash hash1)]\n               [v2 (in-hash hash2 #f)])\n\
    \      (if (and v1 v2)\n          (if (zero? (- v1 v2))\n              (hash-remove\
    \ hash1 k)\n              (hash-ref hash1 k (- v1 v2)))\n          (hash-ref hash1\
    \ k v1))))\n  (define (hash-is-empty? hash)\n    (for/and ([k (in-hash hash)])\n\
    \      (hash-ref hash k 0)))\n  (hash-is-empty? (hash-difference (helper s0) (helper\
    \ s1))))\n", "  (let loop ([l0 (string->list s0)] [l1 (string->list s1)])\n  \
    \  (cond\n      [(and (empty? l0) (empty? l1)) #t]\n      [(empty? l0) #f]\n \
    \     [(empty? l1) #f]\n      [(= (first l0) (first l1)) (loop (rest l0) (rest\
    \ l1))]\n      [else (loop (rest l0) l1)])))\n", "  (define (same-chars-by-hash\
    \ s)\n    (let ([h (make-hash)])\n      (for ([c (in-string s)])\n        (hash-update!\
    \ h c add1 1))\n      h))\n  (hash-equal? (same-chars-by-hash s0) (same-chars-by-hash\
    \ s1)))\n```\n\n## Solutions\n\nIf you want to see a solution, type `(list-solutions)`:\n\
    \n```racket\n#lang racket\n", "  (cond ((and (equal? s0 \"\") (equal? s1 \"\"\
    )) #t)\n        ((equal? s0 \"\") (not (contains? s1 (substring s0 0 1))))\n \
    \       ((equal? s1 \"\") (not (contains? s0 (substring s1 0 1))))\n        ((not\
    \ (contains? s0 (substring s1 0 1))) #f)\n        ((not (contains? s1 (substring\
    \ s0 0 1))) #f)\n        (else (same_chars (delete (substring s0 0 1) s0)\n  \
    \                        (delete (substring s1 0 1) s1)))))\n", "  (equal? (string-sort\
    \ s0) (string-sort s1)))\n", "  (or\n   (and (= (string-length s0) (string-length\
    \ s1))\n        (string=? s0 s1))\n   (let ([ls0 (string->list s0)]\n        \
    \ [ls1 (string->list s1)])\n     (and\n      (member (car ls0) ls1)\n      (same_chars\
    \ (string (cdr ls0)) (string (remove (car ls0) ls1)))))))\n</code>\n", "  (define\
    \ (same-chars-counter a)\n    (for/fold ([cnt (make-hash)]) ([c (in-string a)])\n\
    \      (hash-update cnt c add1 0)))\n  (equal? (same-chars-counter s0) (same-chars-counter\
    \ s1)))\n\n\n", "  (set! s0 (string-&gt;list s0))\n  (set! s1 (string-&gt;list\
    \ s1))\n  (for ([a s0])\n    (if (not (member a s1))\n        (return #f)))\n\
    \  #t)\n", "  (let loop ([s0 s0] [s1 s1])\n    (if (or (string=? s0 \"\") (string=?\
    \ s1 \"\"))\n        #t\n        (if (string-contains s0 (string-ref s1 0))\n\
    \            (loop (string-remove s0 (string-ref s1 0))\n                  (string-remove\
    \ s1 (string-ref s1 0)))\n            #f))))\n\n", "  (define u0 (for/list ([ch\
    \ s0]) (hash ch)))\n  (define u1 (for/list ([ch s1]) (hash ch)))\n  (equal? u0\
    \ u1))\n", "  (and\n   (andmap (lambda (c) (and (char-set=? (string-index c s0)\
    \ (string-index c s1))) #t)\n           s0)\n   (andmap (lambda (c) (and (char-set=?\
    \ (string-index c s0) (string-index c s1))) #t)\n           s1)))\n", "  (let\
    \ ([set0 (list->set (string->list s0))]\n        [set1 (list->set (string->list\
    \ s1))])\n    (equal? set0 set1)))\n", "  (equal? (sort s0 string<? ) (sort s1\
    \ string<? )))\n", "  (and (list=? (list-of-chars s0) (list-of-chars s1))\n  \
    \     (list=? (list-of-chars s1) (list-of-chars s0))))\n", "  (if (or (empty?\
    \ s0) (empty? s1))\n      (null? s0)\n      (same_chars-2 s0 s1)))\n", "  (cond\n\
    \    [(and (string=? \"\" s0) (string=? \"\" s1)) #t]\n    [(string=? \"\" s0)\
    \ #f]\n    [(string=? \"\" s1) #f]\n    [(string-member (string-ref s0 0) s1)\n\
    \     (same_chars (string-drop s0 1) (string-delete (string-ref s0 0) s1))]\n\
    \    [else #f]))\n", "  (define (in_s0 x)\n    (string-index s0 x))\n  (define\
    \ (in_s1 x)\n    (string-index s1 x))\n  (define (not-in_s0 x)\n    (not (in_s0\
    \ x)))\n  (define (not-in_s1 x)\n    (not (in_s1 x)))\n  (cond\n    [(empty? s0)\
    \ (string=? s0 s1)]\n    [(empty? s1) (string=? s0 s1)]\n    [(not-in_s0 (string-ref\
    \ s1 0)) #f]\n    [(not-in_s1 (string-ref s0 0)) #f]\n    [else (same_chars (filter\
    \ not-in_s0 s0) (filter not-in_s1 s1))]))\n", "  (and (equal? (sort s0 <) (sort\
    \ s1 <))\n       (= (string-length s0) (string-length s1))))\n", "  (letrec ([len\
    \ (string-length s0)]\n           [c0 (string->list s0)]\n           [c1 (string->list\
    \ s1)]\n           [c0-count (list-count c0)]\n           [c1-count (list-count\
    \ c1)])\n    (and (equal? len (string-length s1))\n         (let ([diff (for/fold\
    \ ([diff 0]) ([c (in-list c0-count)])\n                      (add1 diff (abs (-\
    \ (cdr c) (cdr (assoc (car c) c1-count))))))])\n           (zero? diff)))))\n",
  "  (define (counter lst)\n    (for/fold ([ret (make-hash)])\n              ([i lst])\n\
    \              (hash-update ret i add1 0)))\n  (define (same? h1 h2)\n    (for/and\
    \ ([k (hash-keys h1)])\n             (eq? (hash-ref h1 k) (hash-ref h2 k))))\n\
    \  (same? (counter (string->list s0)) (counter (string->list s1))))\n```\n\n###\
    \ 5\n\n```racket\n#lang racket\n", "  (not\n   (cond\n     [(< (string-length\
    \ s0) (string-length s1))\n      (cond\n        [(string-contains s1 s0)\n   \
    \      (not (string-contains (substring s1 0 (- (string-length s1) (string-length\
    \ s0))) s0))]\n        [else #t])]\n     [(> (string-length s0) (string-length\
    \ s1))\n      (cond\n        [(string-contains s0 s1)\n         (not (string-contains\
    \ (substring s0 0 (- (string-length s0) (string-length s1))) s1))]\n        [else\
    \ #t])]\n     [else #t])))\n", "  (or (equal? s0 s1)\n      (not (string-contains-ci?\
    \ s0 s1))\n      (not (string-contains-ci? s1 s0))))\n", "  (if (or (empty? s0)\
    \ (empty? s1)) #t\n      (if (member (first s0) s1)\n          (same_chars (rest\
    \ s0) (remove (first s0) s1))\n          #f)))\n", "  (define (count-chars s)\n\
    \    (for/fold ([counts (hash)]) ([ch (in-string s)])\n      (hash-update counts\
    \ ch add1 0)))\n  (define (char-counts x y)\n    (for/and ([ch (in-hash x)])\n\
    \      (= (hash-ref x ch) (hash-ref y ch))))\n  (let ([chars0 (count-chars s0)]\n\
    \        [chars1 (count-chars s1)])\n    (char-counts chars0 chars1)))\n", " \
    \ (define (same-chars-iter s0 s1)\n    (cond ((empty? s0) #t)\n          ((empty?\
    \ s1) #f)\n          ((char=? (first s0) (first s1)) (same-chars-iter (rest s0)\
    \ (rest s1)))\n          (else (same-chars-iter s0 (rest s1)))))\n  (same-chars-iter\
    \ s0 s1))\n", "  (equal? (sort (string->list s0) char<?=)\n          (sort (string->list\
    \ s1) char<?=)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
