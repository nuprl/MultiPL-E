name: HumanEval_104_unique_digits
language: rkt
prompt: "#lang racket\n\n;; Given a list of positive integers x. return a sorted list\
  \ of all \n;; elements that hasn't any even digit.\n;; Note: Returned list should\
  \ be sorted in increasing order.\n;; For example:\n;; >>> (unique_digits (list 15\
  \ 33 1422 1))\n;; (list 1 15 33)\n;; >>> (unique_digits (list 152 323 1422 10))\n\
  ;; (list )\n(define (unique_digits x)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate unique_digits))\n\
  \    (check-equal? (candidate (list 15 33 1422 1)) (list 1 15 33))\n    (check-equal?\
  \ (candidate (list 152 323 1422 10)) (list ))\n    (check-equal? (candidate (list\
  \ 12345 2033 111 151)) (list 111 151))\n    (check-equal? (candidate (list 135 103\
  \ 31)) (list 31 135))\n))\n\n(test-humaneval)"
completions: ["  (define (all-odd? n)\n    (cond\n      ((= n 0) #t)\n      ((odd?\
    \ (remainder n 10)) (all-odd? (quotient n 10)))\n      (else #f)))\n  (define\
    \ (helper ls result)\n    (cond\n      ((null? ls) result)\n      ((all-odd? (car\
    \ ls)) (helper (cdr ls) (append result (list (car ls)))))\n      (else (helper\
    \ (cdr ls) result))))\n  (sort < (helper x '())))\n", "  (sort\n   (filter (lambda\
    \ (y)\n\t     (andmap (lambda (z)\n\t\t       (odd? z))\n\t\t     (string->list\
    \ (number->string y))))\n\t   x)\n   <))", "  (remove even? (remove zero? (remove\
    \ odd? (remove zero? (remove even? (remove odd? (remove zero? (remove even? (remove\
    \ odd? (remove zero? (remove even? (remove odd? (map string->number (map number->string\
    \ x))))))))))))))\n", "  (define (is_unique_digit? y)\n    (cond\n      [(eq?\
    \ y 0) #t]\n      [(not (even? (remainder y 10))) (is_unique_digit? (quotient\
    \ y 10))]\n      [else #f]))\n  (filter is_unique_digit? x))\n", "  (filter (lambda\
    \ (n)\n            (not (exists (lambda (c)\n                           (even?\
    \ (char->integer c)))\n                         (number->string n))))\n      \
    \    (sort x <)))", "  (define (has_even_digit n)\n    (cond\n      [(= n 0) #f]\n\
    \      [(even? (remainder n 10)) #t]\n      [else (has_even_digit (quotient n\
    \ 10))]))\n  (sort x (lambda (a b) (< a b))))", "  (filter (lambda (x) (not (has_even_digit\
    \ x))) (sort x <)))\n", "  (sort (filter (lambda (n)\n                  (zero?\
    \ (remainder (string->number (number->string n)) 2)))\n                x)\n  \
    \      <))", "  (filter\n   (lambda (n)\n     (filter (lambda (d) (odd? d))\n\
    \             (string->list (number->string n))))\n   x))\n", "    (define (isEven\
    \ x)\n        (eq? (remainder x 2) 0))\n    (define (evenDigits? x)\n        (cond\n\
    \            [(and (list? x) (empty? x)) #t]\n            [(and (list? x) (isEven\
    \ (car x))) (evenDigits? (cdr x))]\n            [(and (list? x) (not (isEven (car\
    \ x)))) #f]\n            [(evenDigits? (car x)) (evenDigits? (cdr x))]\n     \
    \       [else #f]))\n    (cond\n        [(and (list? x) (empty? x)) (list)]\n\
    \        [(evenDigits? (car x)) (unique_digits (cdr x))]\n        [else (append\
    \ (list (car x)) (unique_digits (cdr x)))]))\n", "    (sort (remove (lambda (n)\n\
    \                    (even? (remainder n 10)))\n                  x)\n       \
    \   <))", "  (cond\n    ((null? x) '())\n    ((has_even_digit? (car x)) (unique_digits\
    \ (cdr x)))\n    (else (cons (car x) (unique_digits (cdr x))))))\n", "  (unique_digits_helper\
    \ (unique_digits_helper2 x)))\n", "  (for/list ([n x]\n             #:when (even?\
    \ (remainder n 10)))\n    n))\n```\n\nUsing the `for/list` macro we can create\
    \ a list of all the items in\n*x* that satisfies the `#:when` condition (remainder\
    \ of *n* with 10 is\neven). The *x* list is given by the *n* variable and the\n\
    `(remainder n 10)` is the *k* variable in the above example.\n\nThe `for/list`\
    \ macro creates a list of each item in *x* that satisfies\nthe `#:when` condition\
    \ and is the same as:\n\n``` #lang racket", "  (filter (lambda (n)\n         \
    \   (not (has-even-digit? n)))\n          (sort x <)))", "  (define (has_even?\
    \ i)\n    (cond ((= i 0) #f)\n          ((even? (remainder i 10)) #t)\n      \
    \    (else (has_even? (quotient i 10)))))\n  (define (sort lst)\n    (if (null?\
    \ lst)\n        lst\n        (let* ((div (quotient (length lst) 2))\n        \
    \       (ltl (sort (take lst div)))\n               (rtr (sort (drop lst div))))\n\
    \          (merge ltl rtr))))\n  (define (merge l1 l2)\n    (cond ((null? l1)\
    \ l2)\n          ((null? l2) l1)\n          ((< (car l1) (car l2))\n         \
    \  (cons (car l1) (merge (cdr l1) l2)))\n          (else\n           (cons (car\
    \ l2) (merge l1 (cdr l2))))))\n  (define (filter lst)\n    (cond ((null? lst)\
    \ '())\n          ((has_even? (car lst)) (filter (cdr lst)))\n          (else\
    \ (cons (car lst) (filter (cdr lst))))))\n  (sort (filter x)))", "    (define\
    \ (is-even? x)\n        (or (equal? (modulo x 10) 0)\n            (equal? (modulo\
    \ x 10) 2)\n            (equal? (modulo x 10) 4)\n            (equal? (modulo\
    \ x 10) 6)\n            (equal? (modulo x 10) 8)))\n    (define (has-even? x)\n\
    \        (cond ((equal? (modulo x 10) 0) (is-even? x))\n              ((null?\
    \ x) #f)\n              (else (has-even? (quotient x 10)))))\n    (define (helper\
    \ x ret)\n        (cond ((null? x) ret)\n              ((has-even? (car x)) (helper\
    \ (cdr x) ret))\n              (else (helper (cdr x) (append ret (list (car x)))))))\n\
    \    (helper x (list)))\n", "  (filter (lambda (n)\n            (zero? (modulo\
    \ n 2)))\n          x))", "  (cond [(empty? x) '()]\n        [else (if (even-digit?\
    \ (first x))\n                 (unique_digits (rest x))\n                 (append\
    \ (list (first x))\n                         (unique_digits (rest x))))]))\n",
  "  (define (helper x)\n    (if (empty? x) '()\n    (if (even? (remainder (car x)\
    \ 10)) (helper (cdr x))\n     (cons (car x) (helper (cdr x))))))\n  (sort < (helper\
    \ x)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
