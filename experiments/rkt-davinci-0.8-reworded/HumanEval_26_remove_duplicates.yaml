name: HumanEval_26_remove_duplicates
language: rkt
prompt: "#lang racket\n\n;; From a list of integers, remove all elements that occur\
  \ more than once.\n;; Keep order of elements left the same as in the input.\n;;\
  \ >>> (remove_duplicates (list 1 2 3 2 4))\n;; (list 1 3 4)\n(define (remove_duplicates\
  \ numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate remove_duplicates))\n\
  \    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate (list\
  \ 1 2 3 4)) (list 1 2 3 4))\n    (check-equal? (candidate (list 1 2 3 2 4 3 5))\
  \ (list 1 4 5))\n))\n\n(test-humaneval)"
completions: ["  (let loop ([numbers numbers]\n             [list-so-far '()])\n \
    \   (cond [(empty? numbers) list-so-far]\n          [(member (first numbers) list-so-far)\
    \ (loop (rest numbers) list-so-far)]\n          [else (loop (rest numbers) (cons\
    \ (first numbers) list-so-far))])))\n", "  (define (remove_duplicates' numbers\
    \ list-so-far)\n    (if (null? numbers)\n        list-so-far\n        (if (member\
    \ (car numbers) list-so-far)\n            (remove_duplicates' (cdr numbers) list-so-far)\n\
    \            (remove_duplicates' (cdr numbers) (cons (car numbers) list-so-far)))))\n\
    \  (remove_duplicates' numbers (list)))\n```\n\nThe solution above has a lot of\
    \ common elements with the previous one:\n\n```racket", "  (local ((define already-seen\
    \ (list)))\n    (for/list ([x numbers])\n      (if (memq x already-seen)\n   \
    \       (void)\n          (set! already-seen (cons x already-seen))\n        \
    \  x))))\n```\n\n```racket\n#lang racket\n", "    (let ((result (list)))\n   \
    \     (for ((i numbers))\n            (if (not (member i result))\n          \
    \      (set! result (cons i result))))\n        (reverse result)))\n", "  (define\
    \ (is_in-list l v)\n    (cond\n      [(empty? l) #f]\n      [(equal? (first l)\
    \ v) #t]\n      [else (is_in-list (rest l) v)]))\n  (define (remove-duplicates-rec\
    \ result l)\n    (cond\n      [(empty? l) result]\n      [(is_in-list result (first\
    \ l)) (remove-duplicates-rec result (rest l))]\n      [else (remove-duplicates-rec\
    \ (append result (list (first l))) (rest l))]))\n  (remove-duplicates-rec '()\
    \ numbers))\n```\n\n9. `count_change`\n\n```racket\n#lang racket\n", "  (delete-duplicates\
    \ (delete-duplicates numbers)))\n", "  (let ((unique (make-hash)))\n    (for ([n\
    \ numbers])\n      (cond [(hash-ref unique n #f) (hash-remove! unique n)]\n  \
    \          [else (hash-set! unique n #t)]))\n    (hash-keys unique)))\n", "  (cond\n\
    \    [(empty? numbers) empty]\n    [(member (first numbers) (rest numbers)) (remove_duplicates\
    \ (rest numbers))]\n    [else (cons (first numbers) (remove_duplicates (rest numbers)))]))\n\
    ```\n\n```haskell\n-- Haskell\n\n-- From a list of integers, remove all elements\
    \ that occur more than once.\n-- Keep order of elements left the same as in the\
    \ input.\n-- >>> removeDuplicates [1, 2, 3, 2, 4]\n-- [1, 3, 4]\nremoveDuplicates\
    \ :: (Eq a) => [a] -> [a]\nremoveDuplicates [] = []\nremoveDuplicates (x:xs) =\
    \ \n  if x `elem` xs\n  then removeDuplicates xs\n  else x : removeDuplicates\
    \ xs\n```\n\n## Closing remarks\n\nI hope this post clarified why, in my opinion,\
    \ Python is a language best suited for beginners, but not for experienced programmers,\
    \ who are more likely to benefit from a language that provides a higher level\
    \ of expressiveness (and not necessarily only a functional one).", "  (define\
    \ (do-remove-duplicates numbers result)\n    (cond\n      [(empty? numbers)\n\
    \       (reverse result)]\n      [(member (first numbers) result)\n       (do-remove-duplicates\
    \ (rest numbers) result)]\n      [else\n       (do-remove-duplicates (rest numbers)\
    \ (cons (first numbers) result))]))\n  (do-remove-duplicates numbers (list)))\n\
    \n", "  (remove-duplicates-impl numbers '()))\n", "  (cond\n    [(empty? numbers)\
    \ '()]\n    [(member (first numbers) (rest numbers)) (remove_duplicates (rest\
    \ numbers))]\n    [else (cons (first numbers) (remove_duplicates (rest numbers)))]))\n",
  "  (foldl\n   (lambda (elem list-to-append-to)\n     (cond\n       [(member elem\
    \ list-to-append-to) list-to-append-to]\n       [else (append list-to-append-to\
    \ (list elem))]))\n   (list)\n   numbers))\n", "  (foldl (lambda (item result)\n\
    \           (if (member item result)\n               result\n               (cons\
    \ item result)))\n         '()\n         numbers))\n", "  (letrec ([remove_duplicates\
    \ (lambda (numbers)\n                                (let ([head (car numbers)]\n\
    \                                      [tail (cdr numbers)])\n               \
    \                   (cond [(empty? tail) numbers]\n                          \
    \              [(member head tail) (remove_duplicates tail)]\n               \
    \                         [else (cons head (remove_duplicates tail))])))])\n \
    \   (remove_duplicates numbers)))\n", "  (filter (lambda (number)\n          \
    \  (eq? 1 (count (equal? number) numbers)))\n          numbers))\n", "  (local\
    \ [(define (remove_duplicates numbers seen)\n            (cond [(empty? numbers)\
    \ '()]\n                  [(member (first numbers) seen)\n                   (remove_duplicates\
    \ (rest numbers) seen)]\n                  [else (cons (first numbers)\n     \
    \                         (remove_duplicates (rest numbers)\n                \
    \                                 (cons (first numbers) seen)))]))]\n    (remove_duplicates\
    \ numbers '())))\n", "  (define (remove-helper numbers seen-before)\n    (cond\n\
    \      [(empty? numbers) '()]\n      [(member (first numbers) seen-before) (remove-helper\
    \ (rest numbers) seen-before)]\n      [else (cons (first numbers) (remove-helper\
    \ (rest numbers) (cons (first numbers) seen-before)))]))\n  (remove-helper numbers\
    \ '()))\n", "  (for/list ([n (in-list numbers)] #:when (count (in-list numbers)\
    \ n) == 1)\n    n))\n", "  (for/list ([n numbers]\n             #:when (not (member\
    \ n (rest numbers))))\n    n))\n", "  (define (add-if-needed element list)\n \
    \   (if (member element list)\n        list\n        (cons element list)))\n \
    \ (accumulate add-if-needed '() numbers))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
