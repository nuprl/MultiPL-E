name: HumanEval_153_Strongest_Extension
language: rkt
prompt: "#lang racket\n\n;; You will be given the name of a class (a string) and a\
  \ list of extensions.\n;; The extensions are to be used to load additional classes\
  \ to the class. The\n;; strength of the extension is as follows: Let CAP be the\
  \ number of the uppercase\n;; letters in the extension's name, and let SM be the\
  \ number of lowercase letters \n;; in the extension's name, the strength is given\
  \ by the fraction CAP - SM. \n;; You should find the strongest extension and return\
  \ a string in this \n;; format: ClassName.StrongestExtensionName.\n;; If there are\
  \ two or more extensions with the same strength, you should\n;; choose the one that\
  \ comes first in the list.\n;; For example, if you are given \"Slices\" as the class\
  \ and a list of the\n;; extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then\
  \ you should\n;; return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest\
  \ extension \n;; (its strength is -1).\n;; Example:\n;; >>> (Strongest_Extension\
  \ \"my_class\" (list \"AA\" \"Be\" \"CC\"))\n;; \"my_class.AA\"\n(define (Strongest_Extension\
  \ class_name extensions)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate Strongest_Extension))\n\
  \    (check-equal? (candidate \"Watashi\" (list \"tEN\" \"niNE\" \"eIGHt8OKe\"))\
  \ \"Watashi.eIGHt8OKe\")\n    (check-equal? (candidate \"Boku123\" (list \"nani\"\
  \ \"NazeDa\" \"YEs.WeCaNe\" \"32145tggg\")) \"Boku123.YEs.WeCaNe\")\n    (check-equal?\
  \ (candidate \"__YESIMHERE\" (list \"t\" \"eMptY\" \"nothing\" \"zeR00\" \"NuLl__\"\
  \ \"123NoooneB321\")) \"__YESIMHERE.NuLl__\")\n    (check-equal? (candidate \"K\"\
  \ (list \"Ta\" \"TAR\" \"t234An\" \"cosSo\")) \"K.TAR\")\n    (check-equal? (candidate\
  \ \"__HAHA\" (list \"Tab\" \"123\" \"781345\" \"-_-\")) \"__HAHA.123\")\n    (check-equal?\
  \ (candidate \"YameRore\" (list \"HhAas\" \"okIWILL123\" \"WorkOut\" \"Fails\" \"\
  -_-\")) \"YameRore.okIWILL123\")\n    (check-equal? (candidate \"finNNalLLly\" (list\
  \ \"Die\" \"NowW\" \"Wow\" \"WoW\")) \"finNNalLLly.WoW\")\n    (check-equal? (candidate\
  \ \"_\" (list \"Bb\" \"91245\")) \"_.Bb\")\n    (check-equal? (candidate \"Sp\"\
  \ (list \"671235\" \"Bb\")) \"Sp.671235\")\n))\n\n(test-humaneval)"
completions: ["  (let ((best-extension \"\")\n        (best-strength 0))\n    (for\
    \ ([e extensions])\n      (let* ([caps (length (regexp-match* #rx\"[A-Z]\" e))]\n\
    \             [smalls (length (regexp-match* #rx\"[a-z]\" e))]\n             [strength\
    \ (/ caps smalls)])\n        (if (&gt; strength best-strength)\n            (begin\n\
    \              (set! best-extension e)\n              (set! best-strength strength)))))\n\
    \    (format \"~a.~a\" class_name best-extension)))\n", "  (define (is_cap c)\n\
    \    (char-upper-case? c))\n  (define (is_lower c)\n    (char-lower-case? c))\n\
    \  (define (calc_strength s)\n    (let ([caps (regexp-match #rx\"[A-Z]\" s)]\n\
    \          [smalls (regexp-match #rx\"[a-z]\" s)])\n      (- (length caps) (length\
    \ smalls))))\n  (define (max_class_ext s)\n    (apply max s))\n  (define (class_extension_strength\
    \ class extension)\n    (/ (calc_strength extension) (calc_strength class)))\n\
    \  (define (class_extension_strengths l)\n    (map (lambda (extension)\n     \
    \      (class_extension_strength class_name extension))\n         l))\n  (define\
    \ (max_class_extension_strength l)\n    (max_class_ext (class_extension_strengths\
    \ l)))\n  (define (max_class_extension_strength_index l)\n    (list-index (max_class_extension_strength\
    \ l)\n                (class_extension_strengths l)))\n  (define (list-index pred\
    \ l)\n    (let loop ([i 0] [l l])\n      (cond\n        [(empty? l) #f]\n    \
    \    [(pred (first l)) i]\n        [else (loop (+ i 1) (rest l))])))\n  (define\
    \ (max_class_extension l)\n    (list-ref l (max_class_extension_strength_index\
    \ l)))\n  (string-append class_name \".\" (max_class_extension extensions)))\n",
  "  (define cap (/ (length (regexp-match? #rx\"[A-Z]\" class_name))\n           \
    \      (length class_name)))\n  (define sm (/ (length (regexp-match? #rx\"[a-z]\"\
    \ class_name))\n                (length class_name)))\n  (define (strength e)\n\
    \    (define cap-strength (/ (length (regexp-match? #rx\"[A-Z]\" e))\n       \
    \                     (length e)))\n    (define sm-strength (/ (length (regexp-match?\
    \ #rx\"[a-z]\" e))\n                           (length e)))\n    (- cap-strength\
    \ sm-strength))\n  (define (strongest_extension extensions)\n    (cond ((null?\
    \ extensions)\n           \"\")\n          ((= (strength (car extensions)) (strength\
    \ (cadr extensions)))\n           (strongest_extension (cdr extensions)))\n  \
    \        (else (car extensions))))\n  (string-append class_name \".\" (strongest_extension\
    \ extensions)))\n", "  (define (strength word)\n    (define (helper word)\n  \
    \    (cond\n        [(empty? word) 0]\n        [(char-upper-case? (first word))\n\
    \         (+ 1 (helper (rest word)))]\n        [(char-lower-case? (first word))\n\
    \         (- (helper (rest word)))])\n    )\n    (helper word)\n  )\n  (define\
    \ (helper extension)\n    (if (null? extension)\n        \"\"\n        (let ([new_extension\
    \ (string-append class_name \".\" (car extension))])\n          (let ([tmp (helper\
    \ (cdr extension))])\n            (if (> (strength (car extension)) (strength\
    \ (string-suffix tmp \".\")))\n                new_extension\n               \
    \ tmp)))))\n  (helper extensions))", "  (cond [(empty? extensions) \n        \
    \ (error \"extensions must not be empty\")]\n        [(and (symbol? (car extensions))\n\
    \              (not (string? (car extensions))))\n         (error \"extensions\
    \ must be strings\")]\n        [(and (string? (car extensions))\n            \
    \  (string? class_name))\n         (let ([strongest_ext (car extensions)]\n  \
    \             [strongest_ext_strength (Strongest_Extension_Strength \n       \
    \                                 (car extensions))])\n           (define (loop\
    \ exts strongest_ext strongest_ext_strength)\n             (cond [(empty? exts)\n\
    \                    (string-append class_name \".\" strongest_ext)]\n       \
    \            [(and (string? (car exts))\n                         (> (Strongest_Extension_Strength\
    \ (car exts))\n                            strongest_ext_strength))\n        \
    \            (loop (cdr exts) (car exts) \n                          (Strongest_Extension_Strength\
    \ (car exts)))]\n                   [else\n                    (loop (cdr exts)\
    \ strongest_ext strongest_ext_strength)]))\n           (loop (cdr extensions)\
    \ strongest_ext strongest_ext_strength))]\n        [else\n         (error \"class_name\
    \ must be a string and extensions must be a list of strings\")]))\n", "  (define\
    \ (count_upper string)\n    (cond [(empty? string) 0]\n          [(char-upper-case?\
    \ (car string)) (+ 1 (count_upper (cdr string)))]\n          [else (count_upper\
    \ (cdr string))]))\n  (define (count_lower string)\n    (cond [(empty? string)\
    \ 0]\n          [(char-lower-case? (car string)) (+ 1 (count_lower (cdr string)))]\n\
    \          [else (count_lower (cdr string))]))\n  (define (calc_strength-extension\
    \ extension)\n    (- (count_upper extension) (count_lower extension)))\n  (define\
    \ (find_strongest_extension extensions)\n    (cond [(empty? extensions) \"\"]\n\
    \          [(empty? (cdr extensions)) (car extensions)]\n          [(< (calc_strength-extension\
    \ (car extensions))\n              (calc_strength-extension (cadr extensions)))\n\
    \           (find_strongest_extension (cdr extensions))]\n          [else (find_strongest_extension\
    \ (cons (car extensions) (cddr extensions)))]))\n  (string-append class_name \"\
    .\" (find_strongest_extension extensions)))\n", "  (define (n_uppercase string)\n\
    \    (foldl + 0 (map (lambda (c) (if (char-upper-case? c) 1 0)) string)))\n  (define\
    \ (n_lowercase string)\n    (foldl + 0 (map (lambda (c) (if (char-lower-case?\
    \ c) 1 0)) string)))\n  (define (strength string)\n    (- (n_uppercase string)\
    \ (n_lowercase string)))\n  (define (strongest_extension_string_aux curr_string\
    \ strongest_string)\n    (if (null? curr_string) strongest_string\n        (let\
    \ ((curr_strength (strength (car curr_string)))\n              (strongest_strength\
    \ (strength strongest_string)))\n          (if (< curr_strength strongest_strength)\n\
    \              (strongest_extension_string_aux (cdr curr_string) (car curr_string))\n\
    \              (strongest_extension_string_aux (cdr curr_string) strongest_string)))))\n\
    \  (string-append class_name \".\" (strongest_extension_string_aux extensions\
    \ (car extensions))))\n", "  (if (null? extensions)\n      (string-append class_name\
    \ \".\" \"\")\n      (if (null? (cdr extensions))\n          (string-append class_name\
    \ \".\" (list-ref extensions 0))\n          (let* ([extensions-minus-first (cdr\
    \ extensions)]\n                 [strongest-tail (Strongest_Extension class_name\
    \ extensions-minus-first)]\n                 [strongest-extension (extract-extension-name\
    \ strongest-tail)]\n                 [strength-of-head (strength (list-ref extensions\
    \ 0))]\n                 [strength-of-tail (strength strongest-extension)])\n\
    \            (if (> strength-of-head strength-of-tail)\n                (string-append\
    \ class_name \".\" (list-ref extensions 0))\n                strongest-tail)))))\n",
  "  (let ([exts (sort extensions strongest-to-weakest)])\n    (string-append class_name\
    \ \".\" (first exts))))\n", "  (string-append class_name \".\" (car (argmax (for/list\
    \ ([extension extensions])\n                                              (apply/infix\
    \ - (count extension #\\A #\\Z) (count extension #\\a #\\z)))\n              \
    \                              (list extensions)))))\n", "  (let ([ext_strength\
    \ (lambda (ext)\n                        (/ (- (count (regexp-replace* (string->list\
    \ ext)\n                                                      #rx\"[a-z]\")\n\
    \                                    #\\A)\n                              (count\
    \ (regexp-replace* (string->list ext)\n                                      \
    \                #rx\"[A-Z]\")\n                                    #\\a))\n \
    \                          (length ext)))])\n    (string-append class_name\n \
    \                  \".\"\n                   (match (argmin (ext_strength)\n \
    \                                 extensions)\n                          ((? (number?\
    \ n)) \n                           (error \"All extensions have the same strength.\"\
    ))\n                          ((? string?)\n                           it)))))\n\
    ```\n\n## Teht\xE4v\xE4 7\n\nLuo funktio `(find_string s l)`, joka palauttaa `#t`,\
    \ jos luetellussa \n`l`-muodossa olevassa luettelossa on v\xE4hint\xE4\xE4n yksi\
    \ merkkijono, joka on \nsamanlainen kuin annettu merkkijono `s`.\n\n```racket\n\
    #lang racket\n", "  (define (strongest_extension_recur e1 e2)\n    (let ([cap1\
    \ (for/fold ([caps 0]) ([e (string->list e1)])\n                  (if (char-uppercase?\
    \ e) (add1 caps) caps))]\n          [sm1 (for/fold ([sms 0]) ([e (string->list\
    \ e1)])\n                  (if (char-lowercase? e) (add1 sms) sms))]\n       \
    \   [cap2 (for/fold ([caps 0]) ([e (string->list e2)])\n                  (if\
    \ (char-uppercase? e) (add1 caps) caps))]\n          [sm2 (for/fold ([sms 0])\
    \ ([e (string->list e2)])\n                  (if (char-lowercase? e) (add1 sms)\
    \ sms))])\n      (if (> (/ cap1 sm1) (/ cap2 sm2)) e1 e2)))\n  (define (strongest_extension_core\
    \ exts strongest)\n    (if (null? exts)\n        (string-append class_name \"\
    .\" strongest)\n        (strongest_extension_core (cdr exts)\n               \
    \                   (strongest_extension_recur (car exts)\n                  \
    \                                           strongest))))\n  (strongest_extension_core\
    \ extensions (car extensions)))\n", "  (cond [(empty? extensions) \"\"]\n    \
    \    [else\n         (define current_extension (first extensions))\n         (define\
    \ rest_extensions (rest extensions))\n         (define strength_current_extension\
    \ (strength current_extension))\n         (define strongest_rest_extensions (Strongest_Extension\
    \ class_name rest_extensions))\n         (define strength_strongest_rest_extensions\
    \ (strength strongest_rest_extensions))\n         (cond [(> strength_current_extension\
    \ strength_strongest_rest_extensions)\n                (string-append class_name\
    \ \".\" current_extension)]\n               [else\n                (string-append\
    \ class_name \".\" strongest_rest_extensions)])]])\n", "  (define (s_extension_strength\
    \ extension)\n    (define (cap_count s)\n      (if (string-empty? s)\n       \
    \   0\n          (if (char-upper-case? (string-ref s 0))\n              (+ 1 (cap_count\
    \ (substring s 1)))\n              (cap_count (substring s 1)))))\n    (define\
    \ (sm_count s)\n      (if (string-empty? s)\n          0\n          (if (char-lower-case?\
    \ (string-ref s 0))\n              (+ 1 (sm_count (substring s 1)))\n        \
    \      (sm_count (substring s 1)))))\n    (- (cap_count extension) (sm_count extension)))\n\
    \  (define (strongest_extension_string extensions strongest_extension_string_so_far)\n\
    \    (if (null? extensions)\n        strongest_extension_string_so_far\n     \
    \   (if (> (s_extension_strength (car extensions)) (s_extension_strength strongest_extension_string_so_far))\n\
    \            (strongest_extension_string (cdr extensions) (car extensions))\n\
    \            (strongest_extension_string (cdr extensions) strongest_extension_string_so_far))))\n\
    \  (string-append class_name \".\" (strongest_extension_string extensions (car\
    \ extensions))))", "  (let ([class_name (string->symbol class_name)])\n    (define\
    \ (strength sym)\n      (let ([s (symbol->string sym)])\n        (/ (- (count\
    \ (compose char-upcase? char-alphabetic?) s) \n              (count (compose char-downcase?\
    \ char-alphabetic?) s))\n           1.0)))\n    (string-append\n     (symbol->string\
    \ class_name)\n     \".\"\n     (symbol->string\n      (first\n       (argmax\
    \ strength extensions))))))\n", "  (cond\n    [(empty? extensions) (error \"There\
    \ is no extension to load\")]\n    [(empty? (cdr extensions)) (string-append class_name\
    \ \".\" (car extensions))]\n    [else\n     (let ([x (car extensions)]\n     \
    \      [y (car (cdr extensions))])\n       (if (> (extension-strength x) (extension-strength\
    \ y))\n           (Strongest_Extension class_name (cons x (cdr (cdr extensions))))\n\
    \           (Strongest_Extension class_name (cons y (cdr (cdr extensions))))))]))\n",
  "  ;; Your code here.\n  (define strength-of-extension\n    (lambda (extension)\n\
    \      (let* ([CAP (for/fold ([acc 0]) ([c (in-string extension)])\n         \
    \         (if (char-upper-case? c) (add1 acc) acc))]\n             [SM (for/fold\
    \ ([acc 0]) ([c (in-string extension)])\n                  (if (char-lower-case?\
    \ c) (add1 acc) acc))])\n        (/ CAP SM))))\n  (string-append class_name \"\
    .\"\n                 (car\n                  (sort extensions\n             \
    \           (lambda (ext1 ext2)\n                          (< (strength-of-extension\
    \ ext1)\n                             (strength-of-extension ext2)))))))\n</code>\n\
    There is a lot of stuff going on in this code. For example, I've used <code>for/fold</code>\
    \ to count the number of upper-case letters and the number of lower-case letters.\
    \ I've used <code>let*</code> to bind the values for the number of upper-case\
    \ letters and the number of lower-case letters to make the code a bit more readable.\
    \ I've also used <code>string-append</code> and <code>string-ref</code> to manipulate\
    \ strings (in Racket, a string is a list of characters). Finally, I've used <code>sort</code>\
    \ to sort the extensions according to the strength of each extension.\nThis is\
    \ a simple algorithm and it works fine. However, I'd like to make it more functional.\
    \ There are still a few <code>lambda</code>s in the code and I'd like to make\
    \ my use of <code>let*</code> unnecessary. I've heard that <code>let*</code> is\
    \ not necessarily a good thing since it makes it easy to write code that is not\
    \ referentially transparent. So, I think that maybe I should be able to use a\
    \ list comprehension (or something similar) to make this program more \"functional\"\
    .\nI'd appreciate any feedback on this code. I'd also appreciate suggestions for\
    \ how I can improve the code.\n\n\nA:\n\nThe first change I would make is to have\
    \ a more declarative name for the main function:\n<code>(define (strongest-extension\
    \ class-name extensions", "  (let\n    ([cap (string-length (regexp-replace* #rx\"\
    [^A-Z]\" (string-join extensions \"\") \"\"))]\n     [sm (string-length (regexp-replace*\
    \ #rx\"[^a-z]\" (string-join extensions \"\") \"\"))])\n    (let ([st (+ cap sm)])\n\
    \      (string-append class_name \".\"\n                     (car (sort (string-split\
    \ extensions)\n                                (\u03BB (x y)\n               \
    \                   (string-ci<=?\n                                    (string-upcase\
    \ x)\n                                    (string-upcase y)))))))))\n```\n\n```racket\n\
    #lang racket\n", "  (cond\n    [(null? extensions) (error \"No extensions to choose\
    \ from\")]\n    [(null? (cdr extensions)) (string-append class_name \".\" (car\
    \ extensions))]\n    [else (string-append class_name \".\" (Strongest_Extension_Helper\
    \ class_name extensions))]))\n", "  (let ((ext (car extensions)))\n    (letrec\
    \ ((strength \n              (lambda (ext)\n                (let ((CAP (length\
    \ (regexp-match* #rx\"A-Z\" ext)))\n                      (SM (length (regexp-match*\
    \ #rx\"a-z\" ext))))\n                  (- CAP SM))))\n             (extensions-strength\n\
    \              (lambda (extensions)\n                (cond [(null? extensions)\
    \ '()]\n                      [else (cons (cons (car extensions) (strength (car\
    \ extensions)))\n                                  (extensions-strength (cdr extensions)))]))))\n\
    \      (let ((str (sort (extensions-strength extensions)\n                   \
    \    (lambda (x y) (> (cdr x) (cdr y))))))\n        (string-append class_name\
    \ \".\" (car (car str)))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
