name: HumanEval_72_will_it_fly
language: rkt
prompt: "#lang racket\n\n;; Write a function that returns #t if the object q will\
  \ fly, and #f otherwise.\n;; The object q will fly if it's balanced (it is a palindromic\
  \ list) and the sum of its elements is less than or equal the maximum possible weight\
  \ w.\n;; Example:\n;; >>> (will_it_fly (list 1 2) 5)\n;; #f\n;; # 1+2 is less than\
  \ the maximum possible weight, but it's unbalanced.\n;; >>> (will_it_fly (list 3\
  \ 2 3) 1)\n;; #f\n;; # it's balanced, but 3+2+3 is more than the maximum possible\
  \ weight.\n;; >>> (will_it_fly (list 3 2 3) 9)\n;; #t\n;; # 3+2+3 is less than the\
  \ maximum possible weight, and it's balanced.\n;; >>> (will_it_fly (list 3) 5)\n\
  ;; #t\n;; # 3 is less than the maximum possible weight, and it's balanced.\n(define\
  \ (will_it_fly q w)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate will_it_fly))\n\
  \    (check-equal? (candidate (list 3 2 3) 9) #t)\n    (check-equal? (candidate\
  \ (list 1 2) 5) #f)\n    (check-equal? (candidate (list 3) 5) #t)\n    (check-equal?\
  \ (candidate (list 3 2 3) 1) #f)\n    (check-equal? (candidate (list 1 2 3) 6) #f)\n\
  \    (check-equal? (candidate (list 5) 5) #t)\n))\n\n(test-humaneval)"
completions: ["  (and (= q (reverse q))\n       (<= (apply + q) w)))\n```", "  (define\
    \ (balance? q)\n    (if (null? q)\n        #t\n        (cond ((equal? (car q)\
    \ (car (reverse q)))\n               (balance? (cdr q)))\n              (else\
    \ #f))))\n  (define (sum-list list)\n    (cond ((null? list) 0)\n          (else\
    \ (+ (car list) (sum-list (cdr list))))))\n  (if (and (balance? q)\n         \
    \  (<= (sum-list q) w))\n      #t\n      #f))\n", "  (letrec ([l (length q)]\n\
    \           [half (ceiling (/ l 2))]\n           [tail (list-ref q (- l 1))]\n\
    \           [front (list-ref q 0)])\n    (define (check-length)\n      (if (=\
    \ l 1)\n          #t\n          (if (= l 2)\n              (if (= tail front)\n\
    \                  #t\n                  #f)\n              (if (check-length)\n\
    \                  (if (= front tail)\n                      (check-length)\n\
    \                      #f)\n                  #f))))\n    (define (check-sum)\n\
    \      (if (= l 1)\n          (if (&lt;= (car q) w)\n              #t\n      \
    \        #f)\n          (if (&lt;= (+ (car q) (check-sum)) w)\n              #t\n\
    \              #f)))\n    (and (check-length) (check-sum))))\n", "  (cond [(empty?\
    \ q) #t]\n        [(>= (apply + q) w) #f]\n        [else (and (palindrome? q)\
    \ (will_it_fly (cdr q) w))]))\n", "  (and (balanced? q)\n       (<= (apply + q)\
    \ w)))\n", "  (and (balanced? q)\n       (<= (apply + q) w)))\n", "  (and (balanced\
    \ q)\n       (<= (sum q) w)))\n", "  (and (balanced? q) (<= (sum-list q) w)))\n",
  "  (and (balanced q)\n       (<= (sum q) w)))\n", "  (and (balanced? q)\n      \
    \ (<= (sum-of-all q) w)))\n", "  (cond\n    [(empty? q) false]\n    [(eq? (first\
    \ q) (last q)) (will_it_fly (rest (butlast q)) w)]\n    [else false]))\n", " \
    \ (and\n   (= (sum q) (accumulate + 0 q))\n   (<= (sum q) w)))\n", "  (and (balanced\
    \ q) (&lt;= (sum q) w)))\n", "  (and (balanced? q) (<= (sum q) w)))\n", "  (and\
    \ (balanced? q)\n       (<= (sum q) w)))\n", "    (if (empty? q)\n        #t\n\
    \        (if (< (sum (first q) (last q)) w)\n            (if (equal? (first q)\
    \ (last q))\n                (if (will_it_fly (rest (rest q)) w)\n           \
    \         #t\n                    #f)\n                #f)\n            #f)))\n",
  "  (and (balanced? q)\n       (<= (sum q) w)))\n", "  (cond\n    ((null? q) #t)\n\
    \    ((= (car q) (cadr q)) (will_it_fly (cdr q) w))\n    (else (false))))\n",
  "  (let loop ([q q] [w w])\n    (if (null? q) #t\n      (let* ([h (car q)] [t (cdr\
    \ q)])\n        (if (> (+ h (car t)) w) #f\n          (loop t (- w h)))))))\n",
  "  (and (<= (sum q) w) (is_palindrome q)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
