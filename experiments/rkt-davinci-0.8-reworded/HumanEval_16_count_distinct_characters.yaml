name: HumanEval_16_count_distinct_characters
language: rkt
prompt: "#lang racket\n\n;; Given a string, find out how many distinct characters\
  \ (regardless of case) does it consist of\n;; >>> (count_distinct_characters \"\
  xyzXYZ\")\n;; 3\n;; >>> (count_distinct_characters \"Jerry\")\n;; 4\n(define (count_distinct_characters\
  \ string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_distinct_characters))\n\
  \    (check-equal? (candidate \"\") 0)\n    (check-equal? (candidate \"abcde\")\
  \ 5)\n    (check-equal? (candidate \"abcdecadeCADE\") 5)\n    (check-equal? (candidate\
  \ \"aaaaAAAAaaaa\") 1)\n    (check-equal? (candidate \"Jerry jERRY JeRRRY\") 5)\n\
  ))\n\n(test-humaneval)"
completions: ["  (list-length (remove-duplicates (list->set (string->list (string-downcase\
    \ string))))))\n", "  (length (remq #f (map char-alphabetic? (string->list string)))))\n",
  "  (define (count_distinct_characters_iter string iter result)\n    (if (equal?\
    \ iter (string-length string))\n        result\n        (if (member (string-ref\
    \ string iter) result)\n            (count_distinct_characters_iter string (+\
    \ iter 1) result)\n            (count_distinct_characters_iter string (+ iter\
    \ 1) (cons (string-ref string iter) result)))))\n  (count_distinct_characters_iter\
    \ string 0 '()))\n", "  (set! string (map char-downcase string))\n  (length (remove-duplicates\
    \ string)))\n", "  (length (remove-duplicates (string-upcase string))))\n", " \
    \ (foldr (lambda (chr acc)\n           (if (list-contains? (list-map string-upcase\
    \ acc) (string-upcase chr))\n               acc\n               (cons chr acc)))\n\
    \         '()\n         string))\n", "  (length (unique-case-insensitive-items\
    \ string)))\n", "  (length (remove-duplicates (string-&gt;list (string-downcase\
    \ string)))))\n", "  (length (unique-chars string)))\n", "  (cond\n    [(null?\
    \ string) 0]\n    [(member (car string) (cdr string)) (count_distinct_characters\
    \ (cdr string))]\n    [else (+ 1 (count_distinct_characters (cdr string)))]))\n",
  "  (cond\n    [(null? string) 0]\n    [(member (string-upcase (string-ref string\
    \ 0)) (string-upcase (rest string)))\n     (count_distinct_characters (rest string))]\n\
    \    [else (+ 1 (count_distinct_characters (rest string)))]))\n", "  (length (remove-duplicates\
    \ (string-&gt;list (string-upcase string)))))\n", "  (count (string-downcase string)))\n\
    </code>\nTest:\n<code>&gt; (count_distinct_characters \"xyzXYZ\")\n3\n&gt; (count_distinct_characters\
    \ \"Jerry\")\n4\n</code>\n", "  (hash-set-count (string-hash string)))\n", " \
    \ (length (remove-duplicates (string-&gt;list (string-downcase string)))))\n",
  "    (length (hash-set-count (map char-upcase string))))\n\n", "  (count_distinct_characters_helper\
    \ (string-downcase string) (char->integer #\\a) (char->integer #\\z)))\n", " \
    \ (define (count-char string ans)\n    (if (empty? string)\n        ans\n    \
    \    (if (member (string-upper-case (first string)) ans)\n            (count-char\
    \ (rest string) ans)\n            (count-char (rest string) (cons (string-upper-case\
    \ (first string)) ans)))))\n  (count-char string '()))\n", "  (define (charcount\
    \ string)\n    (cond\n      [(empty? string) empty]\n      [else (hash (string-downcase\
    \ (first string)) (cons (first string) (charcount (rest string))))]))\n  (hash-count\
    \ (charcount string)))\n", "  (foldl\n   (lambda (s c)\n     (cond\n       [(not\
    \ (member? c s)) (append s (list c))]\n       [else s]))\n   '()\n   (string->list\
    \ string)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
