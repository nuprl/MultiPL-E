name: HumanEval_57_monotonic
language: rkt
prompt: "#lang racket\n\n;; Return #t is list elements are monotonically increasing\
  \ or decreasing.\n;; >>> (monotonic (list 1 2 4 20))\n;; #t\n;; >>> (monotonic (list\
  \ 1 20 4 10))\n;; #f\n;; >>> (monotonic (list 4 1 0 -10))\n;; #t\n(define (monotonic\
  \ l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate monotonic))\n\
  \    (check-equal? (candidate (list 1 2 4 10)) #t)\n    (check-equal? (candidate\
  \ (list 1 2 4 20)) #t)\n    (check-equal? (candidate (list 1 20 4 10)) #f)\n   \
  \ (check-equal? (candidate (list 4 1 0 -10)) #t)\n    (check-equal? (candidate (list\
  \ 4 1 1 0)) #t)\n    (check-equal? (candidate (list 1 2 3 2 5 60)) #f)\n    (check-equal?\
  \ (candidate (list 1 2 3 4 5 60)) #t)\n    (check-equal? (candidate (list 9 9 9\
  \ 9)) #t)\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? l)\n         #t]\n        [(= (length l) 1)\n    \
    \     #t]\n        [(equal? (first l) (second l))\n         (monotonic (rest l))]\n\
    \        [(> (first l) (second l))\n         (and (>= (first l) (third l))\n \
    \             (monotonic (rest l)))]\n        [(< (first l) (second l))\n    \
    \     (and (<= (first l) (third l))\n              (monotonic (rest l)))]))",
  "  (and (and (or (null? (cdr l))\n                (and (< (car l) (cadr l))\n  \
    \                   (monotonic (cdr l))))\n            (not (list? (cdr l))))\n\
    \       #t))\n", "  (local [(define (mono_aux l acc)\n            (cond [(empty?\
    \ l) acc]\n                  [(empty? (rest l)) acc]\n                  [(or (=\
    \ (first l) (second l))\n                       (= (first l) (- (second l) 1))\n\
    \                       (= (first l) (+ (second l) 1)))\n                   (mono_aux\
    \ (rest l) acc)]\n                  [else false]))]\n    (mono_aux l true)))\n",
  "  (cond\n    ((null? l) #t)\n    ((null? (cdr l)) #t)\n    ((< (car l) (cadr l))\
    \ (monotonic (cdr l)))\n    ((> (car l) (cadr l)) (monotonic (cdr l)))\n    (else\
    \ #f)))\n", "  (if (null? l) #t\n      (let ([head (car l)]\n            [tail\
    \ (cdr l)])\n        (or (and (null? tail) #t)\n            (and (monotonic tail)\n\
    \                 (or (and (>= head (car tail)) #t)\n                     (and\
    \ (<= head (car tail)) #t)))))))\n</code>\nI tried to use tail recursion in my\
    \ solution. My first solution didn't use tail recursion and it had good performance,\
    \ but I wasn't happy with the implementation. I really want to learn how to write\
    \ tail recursive functions.\nI know there are two other ways to implement <code>monotonic</code>\
    \ as a fold function. I wrote that function as well and it runs in \\$\\mathcal{O}(n)\\\
    $. However, I decided to use tail recursion instead, which is \\$\\mathcal{O}(n)\\\
    $ in space and time.\nDoes the implementation seem correct and idiomatic Racket?\n\
    \n\nA:\n\nHere's a tail-recursive solution with the same \\$\\mathcal{O}(n)\\\
    $ time complexity:\n<code>(define (monotonic l)\n  (define (mono l ascending)\n\
    \    (if (null? l) #t\n        (if (null? (cdr l)) #t\n            (if (if ascending\
    \ (&gt;= (car l) (cadr l)) (&lt;= (car l) (cadr l)))\n                (mono (cdr\
    \ l) ascending)\n                #f))))\n  (if (null? l) #t\n      (mono (cdr\
    \ l) (&gt; (car l) (cadr l)))))\n</code>\nSince we need to check a pair of elements\
    \ to determine whether the elements of the list are ascending or descending, we\
    \ use <code>ascending</code> to signal the desired direction. When we encounter\
    \ a pair of elements that are inconsistent with the direction, we immediately\
    \ return <code>#f</code>.\n", "  (let ((opn (cut > <)))\n    (and (opn (car l)\
    \ (cadr l))\n         (every (cut opn <>) l))))\n", "  (cond [(empty? l) #t]\n\
    \        [(empty? (rest l)) #t]\n        [(> (first l) (second l))\n         (and\
    \ (not (member (first l) (rest l)))\n              (monotonic (rest l)))]\n  \
    \      [(< (first l) (second l))\n         (and (not (member (first l) (rest l)))\n\
    \              (monotonic (rest l)))]\n        [else #f]))\n", "  (cond\n    [(null?\
    \ l) #t]\n    [(not (null? (cdr l)))\n     (cond\n       [(< (car l) (cadr l))\n\
    \        (and (monotonic (cdr l))\n             (monotonic (cons (cadr l) (cddr\
    \ l))))]\n       [(> (car l) (cadr l))\n        (and (monotonic (cdr l))\n   \
    \          (monotonic (cons (cadr l) (cddr l))))]\n       [else #f])]\n    [else\
    \ #t]))\n", "  (if (empty? l) #t\n      (let loop ([l (rest l)] [c (first l)])\n\
    \        (if (empty? l) #t\n            (let ([n (first l)])\n              (if\
    \ (<= c n) (loop (rest l) n) #f))))))", "  (cond [(null? l) #t]\n        [(null?\
    \ (cdr l)) #t]\n        [(and (>= (car l) (cadr l)) (monotonic (cdr l))) #t]\n\
    \        [(and (<= (car l) (cadr l)) (monotonic (cdr l))) #t]\n        [else #f]))\n",
  "  (cond [(empty? l) #t]\n        [(and (not (empty? (rest l)))\n              (or\
    \ (= (first l) (first (rest l)))\n                  (> (first l) (first (rest\
    \ l)))))\n         (monotonic (rest l))]\n        [else #f]))\n", "  (cond\n \
    \   ((null? l) #t)\n    ((and (null? (cdr l)) (null? (cddr l))) #t)\n    ((and\
    \ (null? (cdr l)) (not (null? (cddr l))))\n     (let ((trend (if (< (car l) (cadr\
    \ l)) 'increasing 'decreasing)))\n       (foldl\n        (lambda (x acc)\n   \
    \       (and\n           (if (eq? trend 'increasing) (< x acc) (> x acc))\n  \
    \         acc))\n        #t (cdr l))))\n    (else\n     (let ((trend (if (< (car\
    \ l) (cadr l)) 'increasing 'decreasing)))\n       (foldl\n        (lambda (x acc)\n\
    \          (and\n           (if (eq? trend 'increasing) (< x acc) (> x acc))\n\
    \           acc))\n        #t l)))))\n", "  (and (cond\n        [(null? l) #t]\n\
    \        [(null? (cdr l)) #t]\n        [(< (car l) (cadr l)) (monotonic (cdr l))]\n\
    \        [(> (car l) (cadr l)) (monotonic (cdr l))]\n        [else #f])\n    \
    \   #t))\n", "  (cond [(null? l) #t]\n        [(< (car l) (cadr l)) (monotonic\
    \ (cdr l))]\n        [(> (car l) (cadr l)) (monotonic (cdr l))]\n        [else\
    \ #f]))\n", "  (cond [(null? l) #t]\n        [(null? (cdr l)) #t]\n        [(=\
    \ (car l) (cadr l))\n         (monotonic (cdr l))]\n        [(and (> (car l) (cadr\
    \ l)) (not (any-negative? (cdr l))))\n         (monotonic (cdr l))]\n        [(and\
    \ (< (car l) (cadr l)) (not (any-positive? (cdr l))))\n         (monotonic (cdr\
    \ l))]\n        [else #f]))\n", "  (or (or (accumulate-increasing l) (accumulate-decreasing\
    \ l)) #f))\n", "  (cond ((empty? l) #t)\n        ((and (empty? (rest l)) #t) #t)\n\
    \        ((and (equal? (rest l) (empty)) #t) #t)\n        ((and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (", "  (cond ((null? l) #t)\n        ((null? (cdr l)) #t)\n      \
    \  ((> (car l) (cadr l)) (and (equal? (cddr l) (cdr l)) (monotonic (cdr l))))\n\
    \        ((< (car l) (cadr l)) (and (equal? (cddr l) (cdr l)) (monotonic (cdr\
    \ l))))\n        (else #f)))\n", "  (or (define (increasing ls)\n        (if (null?\
    \ (cdr ls))\n            #t\n            (if (&lt; (car ls) (cadr ls))\n     \
    \           (increasing (cdr ls))\n                #f)))\n      (define (decreasing\
    \ ls)\n        (if (null? (cdr ls))\n            #t\n            (if (&gt; (car\
    \ ls) (cadr ls))\n                (decreasing (cdr ls))\n                #f)))\n\
    \      (or (increasing l) (decreasing l))))\n</code>\nI can run tests with <code>check-expect</code>\
    \ and <code>check-within</code> but I want to go a step further and create a testbed\
    \ function which runs monotonic on all three of my test cases. \n<code>(check-expect\
    \ (monotonic (list 1 2 4 20)) #t)", "  (define (asc? l)\n    (cond [(empty? l)\
    \ #t]\n          [(empty? (rest l)) #t]\n          [(< (first l) (first (rest\
    \ l))) (asc? (rest l))]\n          [else #f]))\n  (define (desc? l)\n    (cond\
    \ [(empty? l) #t]\n          [(empty? (rest l)) #t]\n          [(> (first l) (first\
    \ (rest l))) (desc? (rest l))]\n          [else #f]))\n  (cond [(asc? l) #t]\n\
    \        [(desc? l) #t]\n        [else #f]))\n", "  (and (not (null? l))\n   \
    \    (cond ((null? (cdr l)) #t)\n             ((< (car l) (cadr l)) (monotonic\
    \ (cdr l)))\n             ((> (car l) (cadr l)) (monotonic (cdr l)))\n       \
    \      (else #f))))\n", "  (letrec ([cmp-list (lambda (l a)\n                \
    \       (cond\n                         [(null? l) #t]\n                     \
    \    [(< a (car l)) (cmp-list (cdr l) (car l))]\n                         [(>\
    \ a (car l)) (cmp-list (cdr l) (car l))]\n                         [else #f]))])\n\
    \    (cmp-list (cdr l) (car l))))\n", "  (cond\n    [(empty? l) (error \"empty\
    \ list\")]\n    [(empty? (rest l)) #t]\n    [(> (first l) (second l)) (for-all\
    \ (lambda (x y) (< x y)) l)]\n    [(< (first l) (second l)) (for-all (lambda (x\
    \ y) (> x y)) l)]\n    [else #f]))\n", "  (define (monotonic-int l direction)\n\
    \    (cond [(empty? l) true]\n          [(and (>= (car l) (cadr l))\n        \
    \        (= direction 'increasing))\n           (monotonic-int (cdr l) direction)]\n\
    \          [(and (<= (car l) (cadr l))\n                (= direction 'decreasing))\n\
    \           (monotonic-int (cdr l) direction)]\n          [else false]))\n  (cond\
    \ [(empty? l) true]\n        [(= (car l) (cadr l)) (monotonic-int (cdr l) 'equal)]\n\
    \        [(> (car l) (cadr l)) (monotonic-int (cdr l) 'decreasing)]\n        [else\
    \ (monotonic-int (cdr l) 'increasing)]))\n", "  (cond [(empty? l) #t]\n      \
    \  [(empty? (rest l)) #t]\n        [(> (first l) (second l))\n         (andmap\
    \ (lambda (x y) (> x y)) (rest l) (rest (rest l)))]\n        [(< (first l) (second\
    \ l))\n         (andmap (lambda (x y) (< x y)) (rest l) (rest (rest l)))]\n  \
    \      [else #f]))\n", "  (cond ((empty? l) #t)\n        ((equal? (list-ref l\
    \ 0) (list-ref l 1))\n         (monotonic (rest l)))\n        ((> (list-ref l\
    \ 0) (list-ref l 1))\n         (and (monotonic (rest l))\n              (not (member\
    \ (list-ref l 1) (rest l)))))\n        ((< (list-ref l 0) (list-ref l 1))\n  \
    \       (and (monotonic (rest l))\n              (not (member (list-ref l 1) (rest\
    \ l)))))))\n```\n\n```\n#lang racket\n", "  (cond\n    [(empty? l) #t]\n    [(empty?\
    \ (rest l)) #t]\n    [(or (or (> (first l) (second l)) (< (first l) (second l)))\n\
    \         (monotonic (rest l))) #t]\n    [else #f]))\n```\n\n```Racket\n#lang\
    \ racket\n", "  (if (or (null? l) (null? (cdr l)))\n      #t\n      (let* ([x\
    \ (car l)]\n             [y (cadr l)]\n             [r (monotonic (cdr l))])\n\
    \        (if (not r)\n            #f\n            (let ([z (car (cdr l))])\n \
    \             (if (and (<= x y) (>= y z))\n                  #t\n            \
    \      #f))))))\n```\n\n```racket\n#lang racket\n", "  (cond\n    [(null? l) #t]\n\
    \    [(null? (cdr l)) #t]\n    [(> (car l) (cadr l))\n     (and (<= (car l) (car\
    \ (cdr l))) (monotonic (cdr l)))]\n    [(< (car l) (cadr l))\n     (and (>= (car\
    \ l) (car (cdr l))) (monotonic (cdr l)))]\n    [else #f]))", "  (cond [(empty?\
    \ l) #t]\n        [(empty? (rest l)) #t]\n        [(> (first l) (second l))\n\
    \         (cond [(< (first l) (last l)) #f]\n               [else (monotonic (rest\
    \ l))])]\n        [(< (first l) (second l))\n         (cond [(> (first l) (last\
    \ l)) #f]\n               [else (monotonic (rest l))])]\n        [else (monotonic\
    \ (rest l))]))\n", "  (cond [(empty? l) #t]\n        [(empty? (rest l)) #t]\n\
    \        [(or (< (first l) (second l)) (> (first l) (second l)))\n         (and\
    \ (monotonic (rest l)) #t)]\n        [else #f]))\n", "  (let loop ([L l] [lt?\
    \ (lambda (x y) (< x y))])\n    (if (null? (cdr L))\n        #t\n        (let\
    \ ([a (car L)]\n              [b (cadr L)])\n          (if (lt? a b)\n       \
    \       (loop (cdr L) lt?)\n              (if (lt? b a)\n                  (loop\
    \ (cdr L) (lambda (x y) (< y x)))\n                  #f))))))\n", "  (monotonic-helper\
    \ l #f))\n", "  (cond [(null? l) #t]\n        [(null? (cdr l)) #t]\n        [(positive?\
    \ (- (car l) (cadr l))) (monotonic (cdr l))]\n        [(negative? (- (car l) (cadr\
    \ l))) (monotonic (cdr l))]\n        [else #f]))\n", "  (cond\n    [(null? l)\
    \ #t]\n    [(null? (cdr l)) #t]\n    [(> (car l) (cadr l)) (monotonic (cdr l))]\n\
    \    [(< (car l) (cadr l)) (monotonic (cdr l))]\n    [else #f]))\n", "  (cond\
    \ ((or (empty? l) (empty? (rest l))) #t)\n        ((and (< (first l) (second l))\
    \ (monotonic (rest l))) #t)\n        ((and (> (first l) (second l)) (monotonic\
    \ (rest l))) #t)\n        (else #f)))\n", "  (cond\n    [(empty? l) #t]\n    [(empty?\
    \ (rest l)) #t]\n    [(> (first l) (second l)) (and (monotonic (rest l)) (> (first\
    \ l) (second l)))]\n    [(< (first l) (second l)) (and (monotonic (rest l)) (<\
    \ (first l) (second l)))]\n    [else #f]))\n", "  (if (or (empty? l) (empty? (rest\
    \ l)))\n      #t\n      (if (< (first l) (second l))\n          (if (monotonic\
    \ (rest l))\n              #t\n              #f)\n          (if (monotonic (rest\
    \ l))\n              #t\n              #f))))\n", "  (cond\n    [(empty? l) #t]\n\
    \    [(or (positive? (difference (first l) (second l)))\n         (negative? (difference\
    \ (first l) (second l))))\n     (and (monotonic (rest l)) #t)]\n    [else #f]))\n",
  "  (letrec ([monotonic-helper (lambda (l prev)\n                              (if\
    \ (null? l)\n                                  #t\n                          \
    \        (let ([curr (car l)])\n                                    (if (and (not\
    \ (eq? prev '()))\n                                             (or (eq? prev\
    \ '+)\n                                                 (eq? prev '-))\n     \
    \                                        (or (and (eq? prev '+)\n            \
    \                                          (< curr (car prev)))\n            \
    \                                     (and (eq? prev '-)\n                   \
    \                                   (> curr (car prev)))))\n                 \
    \                       #f\n                                        (monotonic-helper\
    \ (cdr l)\n                                                          (cond\n \
    \                                                           [(> curr (car prev))\
    \ '+]\n                                                            [(< curr (car\
    \ prev)) '-]\n                                                            [else\
    \ (car prev)]))))))])\n    (monotonic-helper (cdr l)\n                      (cond\n\
    \                        [(> (car l) (car (cdr l))) '+]\n                    \
    \    [(< (car l) (car (cdr l))) '-]\n                        [else '()]))))\n",
  "  (cond [(empty? l) #t]\n        [(not (or (positive? (first l)) (negative? (first\
    \ l)))) #f]\n        [(equal? (first l) (second l)) (monotonic (rest l))]\n  \
    \      [(and (positive? (first l))\n              (positive? (first (rest l))))\
    \ (monotonic (rest l))]\n        [(and (negative? (first l))\n              (negative?\
    \ (first (rest l)))) (monotonic (rest l))]\n        [else #f]))\n", "  (cond\n\
    \    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(< (first l) (second l))\n\
    \     (and (monotonic (rest l))\n          (or (even? (length l))\n          \
    \    (< (second l) (last l))))]\n    [(> (first l) (second l))\n     (and (monotonic\
    \ (rest l))\n          (or (even? (length l))\n              (> (second l) (last\
    \ l))))]\n    [else #f]))", "  (cond [(empty? l) #t]\n        [(empty? (rest l))\
    \ #t]\n        [(or (or (< (first l) (second l))\n                 (> (first l)\
    \ (second l)))\n             (monotonic (rest l))) #t]\n        [else #f]))\n",
  "  (or (monotonic-increasing l)\n      (monotonic-decreasing l)))\n", "  (cond ((null?\
    \ l) #t)\n        ((null? (cdr l)) #t)\n        ((and (>= (car l) (cadr l))\n\
    \              (monotonic (cdr l))) #t)\n        ((and (<= (car l) (cadr l))\n\
    \              (monotonic (cdr l))) #t)\n        (else #f)))\n", "  (cond\n  \
    \  [(empty? l)\n     #t]\n    [(empty? (rest l))\n     #t]\n    [(= (first l)\
    \ (second l))\n     (monotonic (rest l))]\n    [(< (first l) (second l))\n   \
    \  (and (monotonic (rest l))\n          (<= (first l) (second l)))]\n    [(> (first\
    \ l) (second l))\n     (and (monotonic (rest l))\n          (>= (first l) (second\
    \ l)))]))\n```\n\n---\n\n### `(search-for-prime x l)`\n\nWrite a function that\
    \ takes a number and a list of numbers and returns the\nindex of the first number\
    \ in the list greater than or equal to the input\nnumber.\n\n```racket\n#lang\
    \ racket\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(or\
    \ (or (and (not (> (first l) (second l)))\n                 (monotonic (rest l)))\n\
    \            (and (not (< (first l) (second l)))\n                 (monotonic\
    \ (rest l)))))]\n    [else #f]))\n", "  (if (null? l)\n      #t\n      (let ((val\
    \ (car l))\n            (rest (cdr l)))\n        (if (null? rest)\n          \
    \  #t\n            (let ((next-val (car rest))\n                  (next-rest (cdr\
    \ rest)))\n              (if (= val next-val)\n                  (monotonic next-rest)\n\
    \                  (if (> val next-val)\n                      (and (monotonic\
    \ rest) (positive? val))\n                      (and (monotonic rest) (negative?\
    \ val)))))))))\n", "  (cond ((or (null? l) (null? (cdr l))) #t)\n        ((> (car\
    \ l) (cadr l))\n         (and (monotonic (cdr l))\n              (apply <= (cdr\
    \ l))))\n        ((< (car l) (cadr l))\n         (and (monotonic (cdr l))\n  \
    \            (apply >= (cdr l))))\n        (else #f)))\n", "  (cond\n    [(empty?\
    \ l)\n     #t]\n    [(empty? (rest l))\n     #t]\n    [(= (second l) (first l))\n\
    \     (monotonic (rest l))]\n    [(> (second l) (first l))\n     (if (monotonic\
    \ (rest l))\n         #t\n         #f)]\n    [(< (second l) (first l))\n     (if\
    \ (monotonic (rest l))\n         #t\n         #f)]))\n", "  (cond\n    [(empty?\
    \ l)\n     #t]\n    [(or (and (equal? (first l) (first (rest l))) #t)\n      \
    \   (and (equal? (first l) (first (rest l))) #f))\n     (monotonic (rest l))]\n\
    \    [(< (first l) (first (rest l)))\n     (if (equal? #t (monotonic (rest l)))\n\
    \         #t\n         #f)]\n    [(> (first l) (first (rest l)))\n     (if (equal?\
    \ #t (monotonic (rest l)))\n         #t\n         #f)]))\n", "  (cond [(empty?\
    \ l) #t]\n        [(and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and", "  (cond\n\
    \    [(null? l) #t]\n    [(or (null? (cdr l)) (null? (cddr l))) #t]\n    [(< (car\
    \ l) (cadr l))\n     (and (monotonic (cdr l)) (not (memq #f (map (lambda (x y)\
    \ (<= x y)) (cdr l) (cddr l)))))\n     ]\n    [(> (car l) (cadr l))\n     (and\
    \ (monotonic (cdr l)) (not (memq #f (map (lambda (x y) (>= x y)) (cdr l) (cddr\
    \ l)))))\n     ]\n    [else #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(= (length\
    \ l) 1) #t]\n    [(> (first l) (second l)) (monotonic (rest l))]\n    [(< (first\
    \ l) (second l)) (monotonic (rest l))]\n    [else #f]))\n", "  (cond [(null? l)\
    \ #t]\n        [(null? (cdr l)) #t]\n        [(eq? (car l) (cadr l)) (monotonic\
    \ (cdr l))]\n        [(< (car l) (cadr l))\n         (and (monotonic (cdr l))\
    \ (not (member #f (map > (rest l) (cdr l)))))\n         ]\n        [(> (car l)\
    \ (cadr l))\n         (and (monotonic (cdr l)) (not (member #f (map < (rest l)\
    \ (cdr l)))))\n         ]))\n", "  (local [(define (monotonic-iter lo hi lst)\n\
    \            (cond [(empty? lst) #t]\n                  [(<= lo hi) (monotonic-iter\
    \ lo hi (rest lst))]\n                  [else #f]))]\n    (monotonic-iter (first\
    \ l) (first l) (rest l))))\n</code>\n", "  (define (monotonic-helper l delta)\n\
    \    (cond ((null? l) #t)\n          ((null? (cdr l)) #t)\n          ((= delta\
    \ 0)\n           (monotonic-helper (cdr l) (- (car l) (cadr l))))\n          ((=\
    \ delta (- (car l) (cadr l)))\n           (monotonic-helper (cdr l) delta))\n\
    \          (else #f)))\n  (monotonic-helper l 0))\n```\n\n## Exercise 5.46\n\n\
    > Design a `fold-tree` that is like the foldl procedure but traverses the structure\
    \ of a binary tree in some order.\n\nI choose to traverse left, root, right.\n\
    \n```scheme\n#lang racket\n", "  (cond\n    [(or (null? l) (null? (cdr l)))\n\
    \     #t]\n    [(< (cadr l) (car l))\n     (monotonic (cdr l))]\n    [(> (cadr\
    \ l) (car l))\n     (monotonic (cdr l))]\n    [else\n     #f]))\n", "  (if (null?\
    \ l)\n      #t\n      (define (monotonic? prev l)\n        (if (null? l)\n   \
    \         #t\n            (if (or (< (car l) prev) (> (car l) prev))\n       \
    \         #f\n                (monotonic? (car l) (cdr l)))))\n      (monotonic?\
    \ (car l) (cdr l))))\n", "  (cond\n    [(null? l) #t]\n    [(null? (cdr l)) #t]\n\
    \    [(monotonic (cdr l))\n     (if (< (car l) (cadr l)) #t (if (> (car l) (cadr\
    \ l)) #t #f))]\n    [else #f]))\n", "  (cond\n    [(null? l) #t]\n    [(null?\
    \ (cdr l)) #t]\n    [(> (car l) (cadr l)) (and (not (memq #f (map (lambda (x y)\
    \ (or (> x y) #f)) (cdr l) (cddr l)))) #t)]\n    [(< (car l) (cadr l)) (and (not\
    \ (memq #f (map (lambda (x y) (or (< x y) #f)) (cdr l) (cddr l)))) #t)]\n    [else\
    \ #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(= (length l) 1) #t]\n    [(<\
    \ (first l) (second l))\n     (monotonic (rest l))]\n    [(> (first l) (second\
    \ l))\n     (monotonic (rest l))]\n    [else #f]))\n", "  (or (monotonic-increasing\
    \ l)\n      (monotonic-decreasing l)))\n", "  (define (monotonic-helper l direction)\n\
    \    (cond\n      ((empty? l) #t)\n      ((= (first l) (second l)) (monotonic-helper\
    \ (rest l) #f))\n      ((and (not (direction?)) (equal? direction #f)) #f)\n \
    \     ((< (first l) (second l)) (monotonic-helper (rest l) #t))\n      ((> (first\
    \ l) (second l)) (monotonic-helper (rest l) #f))\n      (else #f)))\n  (if (&lt;=\
    \ (length l) 1) #t\n      (monotonic-helper l #f)))\n</code>\nor the following,\
    \ based on the first example\n<code>#lang racket\n", "  (cond\n    [(empty? l)\
    \ #t]\n    [(equal? (rest l) '()) #t]\n    [(and (<= (first l) (second l)) (monotonic\
    \ (rest l))) #t]\n    [(and (>= (first l) (second l)) (monotonic (rest l))) #t]\n\
    \    [else #f]))\n", "  (define (helper-diff l p)\n    (cond\n      [(empty? l)\
    \ #t]\n      [(= p (- (first l) (second l))) (helper-diff (rest l) p)]\n     \
    \ [else #f]))\n  (if (empty? l)\n      #t\n      (or (helper-diff (rest l) (-\
    \ (first l) (second l)))\n          (helper-diff (rest l) (- (second l) (first\
    \ l))))))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(positive?\
    \ (sub1 (rest l))) #t]\n    [(negative? (sub1 (rest l))) #t]\n    [else #f]))\n",
  "  (letrec ([f (lambda (l)\n                (cond\n                  [(empty? l)\
    \ #t]\n                  [(or (or (zero? (car l))\n                          \
    \ (neg? (car l)))\n                       (zero? (cadr l))\n                 \
    \      (neg? (cadr l)))\n                   (f (cdr l))]\n                  [(>\
    \ (car l) (cadr l))\n                   (letrec ([s (lambda (x)\n            \
    \                     (cond\n                                   [(empty? x) #t]\n\
    \                                   [(> (car x) (cadr x)) (s (cdr x))]\n     \
    \                              [else #f]))])\n                     (s (cdr l)))]\n\
    \                  [(< (car l) (cadr l))\n                   (letrec ([p (lambda\
    \ (x)\n                                 (cond\n                              \
    \     [(empty? x) #t]\n                                   [(< (car x) (cadr x))\
    \ (p (cdr x))]\n                                   [else #f]))])\n           \
    \          (p (cdr l)))]\n                  [else #f])))]\n    (f l)))\n", " \
    \ (cond\n    ((empty? l) #t)\n    ((equal? (count l) 1) #t)\n    ((and (monotonic\
    \ (rest l))\n          (or (> (first l) (second l))\n              (< (first l)\
    \ (second l))))\n     #t)\n    (else #f)))\n", "  (or (monotonic-increasing l)\n\
    \      (monotonic-decreasing l)))\n", "  (if (null? l)\n      #t\n      (define\
    \ (inc? x) (if (null? x) #t (if (> (car x) (cadr x)) #f (inc? (cdr x)))))\n  \
    \    (define (dec? x) (if (null? x) #t (if (< (car x) (cadr x)) #f (dec? (cdr\
    \ x)))))\n      (or (inc? l) (dec? l))))\n", "  (if (or (empty? l) (empty? (rest\
    \ l)))\n      #t\n      (let ([new-l (rest l)])\n        (and (cond [(> (first\
    \ l) (first new-l)) (positive? (less? (first l) (first new-l)))]\n           \
    \        [(< (first l) (first new-l)) (positive? (less? (first new-l) (first l)))]\n\
    \                   [else (monotonic new-l)])\n             (monotonic new-l)))))\n",
  "  (cond ((null? l) #t)\n        ((null? (cdr l)) #t)\n        ((monotonic-direction\
    \ (car l) (cadr l))\n         (and (monotonic (cdr l))\n              (monotonic-direction\
    \ (car l) (car (cdr l)))))\n        (else #f)))\n", "  (cond ((null? l) #t)\n\
    \        ((or (= (length l) 1) (= (length l) 2)) #t)\n        ((> (car l) (cadr\
    \ l)) (and (monotonic (cdr l)) (or (= (cadr l) (- (car l) 1)) #f)))\n        ((<\
    \ (car l) (cadr l)) (and (monotonic (cdr l)) (or (= (cadr l) (+ (car l) 1)) #f)))\n\
    \        (else #f)))\n", "  (cond [(empty? l) #t]\n        [(equal? (length l)\
    \ 1) #t]\n        [(> (first l) (second l))\n         (if (monotonic (cdr l))\n\
    \             #t\n             #f)]\n        [(< (first l) (second l))\n     \
    \    (if (monotonic (cdr l))\n             #t\n             #f)]\n        [else\
    \ #f]))\n```\n\n### 3.12\n\n```scheme\n#lang racket\n", "  (or (increasing? l)\
    \ (decreasing? l)))\n", "  (if (&lt; (length l) 2)\n      #t\n      (let ((diff\
    \ (diff-list l)))\n        (or (all-positive? diff)\n            (all-negative?\
    \ diff)))))\n", "  (cond\n    ((= (length l) 1) #t)\n    ((= (length l) 2)\n \
    \    (if (> (car l) (cadr l))\n         #t\n         #f))\n    (else\n     (if\
    \ (> (car l) (cadr l))\n         (monotonic (cdr l))\n         (monotonic (cons\
    \ (car l) (cdr (cdr l))))))))\n", "  (cond ((empty? l) #t)\n        ((empty? (rest\
    \ l)) #t)\n        ((< (first l) (second l)) (monotonic (rest l)))\n        ((>\
    \ (first l) (second l)) (monotonic (rest l)))\n        (else #f)))\n", "  (cond\
    \ [(empty? l)\n         true]\n        [(null? (cdr l))\n         true]\n    \
    \    [(> (car l) (cadr l))\n         (and (monotonic (cdr l))\n              (>\
    \ (car l) (cadr l)))]\n        [(< (car l) (cadr l))\n         (and (monotonic\
    \ (cdr l))\n              (< (car l) (cadr l)))]\n        [else false]))\n", " \
    \ (if (null? l)\n      #t\n      (let* ([rest (cdr l)]\n             [increasing?\
    \ (apply < l)])\n        (if (null? rest)\n            #t\n            (and (if\
    \ increasing? < > (car l) (car rest))\n                 (monotonic rest))))))\n",
  "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(or (= (first l)\
    \ (second l))\n         (zero? (sub1 (first l) (second l))))\n     (monotonic\
    \ (rest l))]\n    [else #f]))\n", "  (define (increasing e1 e2)\n    (<= e1 e2))\n\
    \  (define (decreasing e1 e2)\n    (>= e1 e2))\n  (if (null? l)\n      #t\n  \
    \    (let* ([op (if (null? (cdr l))\n                    (lambda (e1 e2)\n   \
    \                   #t)\n                    (cond\n                      [(increasing\
    \ (car l) (cadr l))\n                       increasing]\n                    \
    \  [(decreasing (car l) (cadr l))\n                       decreasing]\n      \
    \                [else\n                       (lambda (e1 e2)\n             \
    \            #f)]))]\n             [op-result (op (car l) (cadr l))])\n      \
    \  (if op-result\n            (monotonic (cdr l))\n            #f))))\n", "  (if\
    \ (null? l)\n      #t\n      (let ((rest (cdr l)))\n      (if (null? rest)\n \
    \         #t\n          (let ((fst (car l))\n                (snd (car rest)))\n\
    \            (let ((difference (- fst snd)))\n              (if (= difference\
    \ 0)\n                  (monotonic rest)\n                  (if (< difference\
    \ 0)\n                      (and (negative? difference) (monotonic rest))\n  \
    \                    (and (positive? difference) (monotonic rest))))))))))\n",
  "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(and (<= (first\
    \ l) (second l)) (monotonic (rest l))) #t]\n    [(and (>= (first l) (second l))\
    \ (monotonic (rest l))) #t]\n    [else #f]))\n", "  (cond\n    ((null? l) #t)\n\
    \    ((= (count l) 1) #t)\n    ((= (count l) 2)\n     (if (= (car l) (cadr l))\n\
    \         #t\n         #f))\n    (else\n     (let ([v (car l)])\n       (and (monotonic\
    \ (cdr l))\n            (cond\n              ((< v (cadr l)) #t)\n           \
    \   ((> v (cadr l)) #t)\n              (else #f)))))))\n", "  (define (monotonic-helper\
    \ l increasing)\n    (cond ((null? l) #t)\n          ((= (length l) 1) #t)\n \
    \         ((= (car l) (cadr l)) (monotonic-helper (cdr l) increasing))\n     \
    \     ((increasing (car l) (cadr l))\n           (monotonic-helper (cdr l) (lambda\
    \ (a b) (> a b))))\n          ((increasing (cadr l) (car l))\n           (monotonic-helper\
    \ (cdr l) (lambda (a b) (< a b))))\n          (else #f)))\n  (monotonic-helper\
    \ l (lambda (a b) (> a b))))\n", "  (cond [(empty? l) #t]\n        [(empty? (rest\
    \ l)) #t]\n        [(< (first l) (second l)) (monotonic (rest l))]\n        [(>\
    \ (first l) (second l)) (monotonic (rest l))]\n        [else #f]))\n", "  (cond\n\
    \    [(null? l) #t]\n    [(null? (cdr l)) #t]\n    [(= (car l) (cadr l)) (monotonic\
    \ (cdr l))]\n    [(and (> (car l) (cadr l)) (monotonic (cdr l))) #t]\n    [(and\
    \ (< (car l) (cadr l)) (monotonic (cdr l))) #t]\n    [else #f]))\n```", "  (cond\n\
    \    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(< (first l) (second l))\
    \ (monotonic (rest l))]\n    [(> (first l) (second l)) (monotonic (rest l))]\n\
    \    [else #f]))\n\n", "  (and (not (null? l))\n       (define (monotonic-loop\
    \ first rest increasing)\n         (cond ((null? rest) #t)\n               ((null?\
    \ (cdr rest)) #t)\n               ((and increasing (= first (car rest)))\n   \
    \             (monotonic-loop (car rest) (cdr rest) increasing))\n           \
    \    ((and (not increasing) (= first (car rest)))\n                (monotonic-loop\
    \ (car rest) (cdr rest) increasing))\n               ((and increasing (> first\
    \ (car rest)))\n                (monotonic-loop (car rest) (cdr rest) #f))\n \
    \              ((and (not increasing) (< first (car rest)))\n                (monotonic-loop\
    \ (car rest) (cdr rest) #t))\n               (else #f)))\n       (monotonic-loop\
    \ (car l) (cdr l) #t)))\n", "  (cond\n    [(empty? l) #t]\n    [(equal? (length\
    \ l) 1) #t]\n    [(= (first l) (second l)) (monotonic (rest l))]\n    [(< (first\
    \ l) (second l))\n     (and (monotonic (rest l))\n          (all (lambda (x) (<\
    \ (first l) x)) (rest l)))]\n    [(> (first l) (second l))\n     (and (monotonic\
    \ (rest l))\n          (all (lambda (x) (> (first l) x)) (rest l)))]))\n", " \
    \ (and (not (empty? l))\n       (monotonic-core (second l) (list (first l)) (rest\
    \ l))))\n", "  (or (increasing? l) (decreasing? l)))\n", "  (cond\n    [(null?\
    \ l) #t]\n    [(null? (cdr l)) #t]\n    [(< (car l) (cadr l)) (monotonic (cdr\
    \ l))]\n    [(> (car l) (cadr l)) (monotonic (cdr l))]\n    [else #f]))\n", " \
    \ (cond ((empty? l) true)\n        ((and (empty? (rest l)) true) true)\n     \
    \   ((> (car l) (cadr l)) (and (monotonic (rest l)) true))\n        ((< (car l)\
    \ (cadr l)) (and (monotonic (rest l)) true))\n        (else false)))\n", "  (cond\n\
    \    ((null? l) #t)\n    ((null? (cdr l)) #t)\n    ((< (car l) (cadr l)) (monotonic\
    \ (cdr l)))\n    ((> (car l) (cadr l)) (monotonic (cdr l)))\n    (else #f)))\n",
  "  (cond ((null? l) #t)\n        ((null? (cdr l)) #t)\n        ((and (< (car l)\
    \ (cadr l))\n              (monotonic (cdr l))) #t)\n        ((and (> (car l)\
    \ (cadr l))\n              (monotonic (cdr l))) #t)\n        (else #f)))\n", " \
    \ (cond\n    [(empty? l) #t]\n    [(and (zero? (length l)) (monotonic (rest l)))\
    \ #t]\n    [(or (equal? (first l) (second l))\n         (and (positive? (sub1\
    \ (first l) (second l)))\n              (monotonic (rest l)))\n         (and (negative?\
    \ (sub1 (first l) (second l)))\n              (monotonic (rest l)))) #t]\n   \
    \ [else #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n\
    \    [(and (or (and (< (first l) (second l)) (monotonic (rest l)))\n         \
    \     (and (> (first l) (second l)) (monotonic (rest l)))))]\n    [else #f]))\n",
  "  (or\n   (monotonic-increasing l)\n   (monotonic-decreasing l)))\n", "  (cond\n\
    \    [(empty? l) true]\n    [(empty? (rest l)) true]\n    [(> (first l) (second\
    \ l)) (monotonic (rest l))]\n    [(< (first l) (second l)) (monotonic (rest l))]\n\
    \    [else false]))\n", "  (cond\n    [(empty? l) #t]\n    [(or (positive? (first\
    \ l)) (negative? (first l))) #f]\n    [else (and\n            (andmap (lambda\
    \ (x) (and (positive? x) (positive? (last l)))) (rest l))\n            (andmap\
    \ (lambda (x) (and (negative? x) (negative? (last l)))) (rest l)))]))\n", "  (cond\
    \ [(empty? l) #t]\n        [(and (empty? (rest l)) #t)]\n        [(or (< (first\
    \ l) (second l))\n             (> (first l) (second l)))\n         (monotonic\
    \ (rest l))]\n        [else #f]))\n", "  (cond [(empty? l) #t]\n        [(empty?\
    \ (rest l)) #t]\n        [(< (first l) (second l))\n         (and (monotonic (rest\
    \ l))\n              (or (empty? (rest (rest l)))\n                  (< (second\
    \ l) (third l))))]\n        [(> (first l) (second l))\n         (and (monotonic\
    \ (rest l))\n              (or (empty? (rest (rest l)))\n                  (>\
    \ (second l) (third l))))]\n        [else #f]))\n", "  (cond\n    [(null? l) #t]\n\
    \    [(null? (cdr l)) #t]\n    [(> (car l) (cadr l))\n     (and (monotonic (cdr\
    \ l)) (monotonic-reverse (cdr l)))]\n    [(< (car l) (cadr l))\n     (and (monotonic\
    \ (cdr l)) (monotonic (cdr l)))]\n    [else #f]))\n", "  (cond [(empty? l) #t]\n\
    \        [(empty? (rest l)) #t]\n        [(< (first l) (second l))\n         (and\
    \ (monotonic (rest l)) (equal? (first l) (- (second l) 1)))]\n        [(> (first\
    \ l) (second l))\n         (and (monotonic (rest l)) (equal? (first l) (+ (second\
    \ l) 1)))]\n        [else (error \"two numbers are equal\")]))\n```\n### Exercise\
    \ 1.3\n\n```racket\n#lang racket\n", "  (cond\n    ((null? l) #t)\n    ((null?\
    \ (cdr l)) #t)\n    ((and (negative? (apply - (cdr l)))\n          (apply < (cdr\
    \ l)))\n     (monotonic (cdr l)))\n    ((and (positive? (apply - (cdr l)))\n \
    \         (apply > (cdr l)))\n     (monotonic (cdr l)))\n    (else #f)))\n", " \
    \ (define (same-sign? a b)\n    (if (&lt; a 0)\n        (&lt; b 0)\n        (&gt;\
    \ b 0)))\n  (define (iter l last)\n    (if (null? l)\n        #t\n        (let\
    \ ([x (car l)])\n          (if (same-sign? x last)\n              (iter (cdr l)\
    \ x)\n              #f))))\n  (if (null? l)\n      #t\n      (iter (cdr l) (car\
    \ l))))\n</code>\nOf course this can be done with a single if:\n<code>#lang racket\n",
  "  (let loop ([l l] [previous (car l)] [mono #t])\n    (cond\n      [(null? l) mono]\n\
    \      [(and mono (or (and (number? previous) (number? (car l)) (positive? (-\
    \ previous (car l))))\n                     (and (number? previous) (number? (car\
    \ l)) (negative? (- previous (car l))))))\n       (loop (cdr l) (car l) mono)]\n\
    \      [else #f])))\n", "  (cond\n    [(null? l) #t]\n    [(null? (cdr l)) #t]\n\
    \    [(or (or (and (< (car l) (cadr l)) (monotonic (cdr l)))\n              (and\
    \ (> (car l) (cadr l)) (monotonic (cdr l)))))]\n    [else #f]))\n", "  (if (null?\
    \ l) #t\n      (if (null? (cdr l)) #t\n          (if (< (car l) (cadr l))\n  \
    \            (monotonic (cdr l))\n              (if (> (car l) (cadr l))\n   \
    \               (monotonic (cdr l))\n                  #f)))))\n```\n\n## Generic\
    \ Programming\n\n### Variadic Functions\n\nYou can implement a function that takes\
    \ a variable number of arguments as follows:\n\n```racket", "  (cond\n    [(null?\
    \ l) #t]\n    [(null? (cdr l)) #t]\n    [(= (car l) (cadr l)) (monotonic (cdr\
    \ l))]\n    [(> (car l) (cadr l))\n     (and (>= (car l) (caddr l)) (monotonic\
    \ (cdr l)))]\n    [(< (car l) (cadr l))\n     (and (<= (car l) (caddr l)) (monotonic\
    \ (cdr l)))]))\n", "  (and (not (null? l))\n       (let* ([first (car l)]\n  \
    \            [rest (cdr l)])\n         (if (null? rest)\n             #t\n   \
    \          (let ([second (car rest)])\n               (if (< first second)\n \
    \                  (if (eq? (monotonic rest) #t)\n                       #t\n\
    \                       #f)\n                   (if (eq? (monotonic rest) #t)\n\
    \                       #t\n                       #f)))))))\n", "  (cond\n  \
    \  [(null? l) true]\n    [(null? (cdr l)) true]\n    [(< (car l) (cadr l)) (monotonic\
    \ (cdr l))]\n    [(> (car l) (cadr l)) (monotonic (cdr l))]\n    [else false]))\n\
    ```\n\n``` #lang racket\n", "  (cond [(null? l) #t]\n        [(null? (cdr l))\
    \ #t]\n        [(and (< (car l) (cadr l)) (monotonic (cdr l))) #t]\n        [(and\
    \ (> (car l) (cadr l)) (monotonic (cdr l))) #t]\n        [else #f]))\n```\n\n\
    ```racket\n#lang racket\n", "  (cond\n    [(null? l) #t]\n    [(null? (cdr l))\
    \ #t]\n    [(and\n      (= (car l) (- (cadr l) 1))\n      (monotonic (cdr l)))\
    \ #t]\n    [(and\n      (= (car l) (+ (cadr l) 1))\n      (monotonic (cdr l)))\
    \ #t]\n    [else #f]))\n", "  (and (not (empty? l))\n       (let* ([first (first\
    \ l)]\n              [tail (rest l)])\n         (cond [(empty? tail) #t]\n   \
    \            [(> first (first tail)) (and (monotonic tail) #t)]\n            \
    \   [(< first (first tail)) (and (monotonic tail) #t)]\n               [else #f]))))\n",
  "  (and (not (null? l))\n       (or (monotonic2 l '<= #t)\n           (monotonic2\
    \ l '>= #t))))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n\
    \    [(< (first l) (second l)) (and (monotonic (rest l)) #t)]\n    [(> (first\
    \ l) (second l)) (and (monotonic (rest l)) #t)]\n    [else #f]))\n", "  (if (null?\
    \ l)\n      #t\n      (or (null? (cdr l))\n          (let ([l1 (car l)]\n    \
    \            [l2 (cadr l)])\n            (and (monotonic (cdr l))\n          \
    \       (or (< l1 l2)\n                     (> l1 l2)))))))", "  (cond\n    [(empty?\
    \ l) #t]\n    [(or (= (first l) (second l))\n         (and (= (first l) (second\
    \ l)) (monotonic (rest l))))]\n    [(or (< (first l) (second l))\n         (and\
    \ (< (first l) (second l)) (monotonic (rest l))))]\n    [else #f]))\n", "  (if\
    \ (null? l)\n      #t\n      (let ((dir\n             (cond ((> (car l) (cadr\
    \ l))\n                    -1)\n                   ((< (car l) (cadr l))\n   \
    \                 1)\n                   (else\n                    0))))\n  \
    \      (and (= dir 0)\n             (monotonic (cdr l))))))\n", "  (define (mono-list\
    \ l ascending)\n    (if (null? l)\n        #t\n        (let ([x (car l)]\n   \
    \           [xs (cdr l)])\n          (if (null? xs)\n              #t\n      \
    \        (let ([y (car xs)])\n                (if (eq? ascending #t)\n       \
    \             (if (> x y)\n                        #f\n                      \
    \  (mono-list xs ascending))\n                    (if (< x y)\n              \
    \          #f\n                        (mono-list xs ascending))))))))\n  (mono-list\
    \ l #t))\n```\n\n```racket\n#lang racket\n", "  (or\n   (and\n    (empty? (cdr\
    \ l))\n    #t)\n   (and\n    (or\n     (and\n      (not (empty? (cdr l)))\n  \
    \    (empty? (cddr l)))\n     (and\n      (not (empty? (cdr l)))\n      (not (empty?\
    \ (cddr l)))\n      (<= (car l) (cadr l))\n      (>= (cadr l) (caddr l))))\n \
    \   (monotonic (cdr l)))))\n", "  (cond [(empty? l)\n         #t]\n        [(or\
    \ (null? (cdr l))\n             (empty? (cdr l)))\n         #t]\n        [(and\
    \ (or (and (positive? (cdr l))\n                       (positive? (car l)))\n\
    \                  (and (negative? (cdr l))\n                       (negative?\
    \ (car l))))\n              (monotonic (cdr l)))\n         #t]\n        [else\n\
    \         #f]))\n", "  (define (helper l prev direction)\n    (if (null? l)\n\
    \        #t\n        (if (eq? direction 'up)\n            (if (> (car l) prev)\n\
    \                (helper (cdr l) (car l) direction)\n                #f)\n   \
    \         (if (< (car l) prev)\n                (helper (cdr l) (car l) direction)\n\
    \                #f))))\n  (if (null? l)\n      #t\n      (helper (cdr l) (car\
    \ l) (if (> (car l) (cadr l)) 'down 'up))))\n", "  (cond [(null? l) #t]\n    \
    \    [(null? (cdr l)) #t]\n        [(> (car l) (cadr l)) (every < (cdr l))]\n\
    \        [(< (car l) (cadr l)) (every > (cdr l))]\n        [else #f]))\n", " \
    \ (cond\n    [(empty? l) #t]\n    [(or (and (positive? (first l))\n          \
    \    (negative? (second l)))\n         (and (negative? (first l))\n          \
    \    (positive? (second l)))) #f]\n    [else (monotonic (rest l))]))\n", "  (cond\
    \ [(empty? l) #t]\n        [(empty? (rest l)) #t]\n        [(> (first l) (second\
    \ l)) (monotonic-decreasing (rest l))]\n        [(< (first l) (second l)) (monotonic-increasing\
    \ (rest l))]\n        [else #f]))\n", "  (and (or (null? (cdr l))\n          \
    \ (and (eq? (first l) (second l))\n                (monotonic (cdr l))))\n   \
    \    (and (null? (cddr l))\n            (eq? (first l) (second l)))))\n", "  (or\
    \ (or (null? l) (null? (cdr l)))\n      (if (and (pair? l) (pair? (cdr l)))\n\
    \          (let* ([a (car l)]\n                 [b (car (cdr l))])\n         \
    \   (if (< a b)\n                (monotonic (cdr l))\n                (if (= a\
    \ b)\n                    #t\n                    (monotonic (cdr l)))))\n   \
    \       #f)))\n", "  (if (null? l)\n      #t\n      (define (mono l incr)\n  \
    \      (cond ((null? l) #t)\n              ((null? (cdr l)) #t)\n            \
    \  ((incr (car l) (cadr l)) (mono (cdr l) incr))\n              (else #f)))\n\
    \      (let ((head (car l)))\n        (cond ((< head (cadr l)) (mono l <))\n \
    \             ((> head (cadr l)) (mono l >))\n              (else #t)))))\n",
  "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(empty? (rest (rest\
    \ l))) #t]\n    [else\n     (let*\n         ([x (first l)]\n          [y (first\
    \ (rest l))]\n          [m (if (> x y) #t #f)]\n          [z (first (rest (rest\
    \ l)))]\n          [test\n           (cond\n             [(= (abs (- x y)) (abs\
    \ (- y z))) #t]\n             [else #f])])\n       (if test\n           (monotonic\
    \ (rest l))\n           #f))]))\n", "  (if (null? l)\n      #t\n      (cond\n\
    \        [(null? (cdr l)) #t]\n        [(> (car l) (cadr l))\n         (if (not\
    \ (monotonic (cdr l)))\n             #f\n             #t)]\n        [(< (car l)\
    \ (cadr l))\n         (if (not (monotonic (cdr l)))\n             #f\n       \
    \      #t)]\n        [else #f])))\n", "  (cond\n    [(empty? l) #t]\n    [(empty?\
    \ (rest l)) #t]\n    [(and (positive? (difference (first l) (second l)))\n   \
    \       (monotonic (rest l))) #t]\n    [(and (negative? (difference (first l)\
    \ (second l)))\n          (monotonic (rest l))) #t]\n    [else #f]))\n```\n\n\
    ## Homework\n\n**Due Thursday:**\n\n* Write a function `pairs` that returns all\
    \ pairings from a list. For example:\n\n```\n>>> (pairs (list 1 2 3))\n'((1 2)\
    \ (1 3) (2 3))\n```\n\n**Due Tuesday:**\n\n* Write a function that returns #t\
    \ if the list is a palindrome (reads the same backwards as forwards) and #f otherwise.\
    \ For example:\n\n```\n>>> (palindrome (list 1 2 1))\n#t\n>>> (palindrome (list\
    \ 1 2 3))\n#f\n```\n\n* Write a function that returns the first element of a list\
    \ (or #f if the list is empty). For example:\n\n```\n>>> (first (list 1 2 3))\n\
    1\n>>> (first (list))\n#f\n```\n\n* Write a function that returns the nth element\
    \ of a list (or #f if the list is empty). For example:\n\n```\n>>> (nth (list\
    \ 1 2 3) 2)\n3\n>>> (nth (list 1 2 3) 3)\n#f\n```\n\n* Write a function that returns\
    \ a list of all the elements of a list except the first. For example:\n\n```\n\
    >>> (rest (list 1 2 3))\n'(2 3)\n>>> (rest (list 1))\n'()\n```\n\n* Write a function\
    \ that returns the number of elements in a list. For example:\n\n```\n>>> (count\
    \ (list 1 2 3))\n3\n>>> (count (list))\n0\n```\n\n**Due Thursday:**\n\n* Write\
    \ a function that returns #t if a list is a set and #f otherwise. For example:\n\
    \n```\n>>> (set? (list", "  (define (monotonic-iter l previous)\n    (if (null?\
    \ l)\n        #t\n        (if (<= previous (car l))\n            (monotonic-iter\
    \ (cdr l) (car l))\n            #f)))\n  (if (null? l)\n      #t\n      (monotonic-iter\
    \ (cdr l) (car l))))\n", "  (define (iter l inc)\n    (if (empty? l)\n       \
    \ #t\n        (let ([e (first l)])\n          (if (or (and (positive? e) (negative?\
    \ inc))\n                  (and (negative? e) (positive? inc)))\n            \
    \  #f\n              (iter (rest l) e)))))\n  (if (empty? l)\n      #t\n     \
    \ (iter (rest l) (first l))))\n", "  (cond ((null? l) #t)\n        ((null? (cdr\
    \ l)) #t)\n        ((and (< (car l) (cadr l)) (monotonic (cdr l))) #t)\n     \
    \   ((and (> (car l) (cadr l)) (monotonic (cdr l))) #t)\n        (else #f)))\n",
  "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(or (> (first l)\
    \ (second l))\n         (< (first l) (second l)))\n     (monotonic (rest l))]\n\
    \    [else #f]))\n", "  (define (loop lst dir)\n    (cond ((null? lst) #t)\n \
    \         ((or (and (positive? dir) (< (car lst) (cadr lst)))\n              \
    \ (and (negative? dir) (> (car lst) (cadr lst))))\n           (loop (cdr lst)\
    \ dir))\n          (else #f)))\n  (if (null? l) #t\n      (let ((first-diff (-\
    \ (car l) (cadr l))))\n        (cond ((> first-diff 0) (loop (cdr l) 1))\n   \
    \           ((< first-diff 0) (loop (cdr l) -1))\n              (else #t)))))",
  "  (cond ((or (null? l)\n             (null? (cdr l)))\n         #t)\n        ((<\
    \ (car l) (cadr l))\n         (and (monotonic (cdr l))\n              #t))\n \
    \       ((> (car l) (cadr l))\n         (and (monotonic (cdr l))\n           \
    \   #t))\n        (else #f)))\n", "  (and (not (null? l)) (not (null? (cdr l)))\n\
    \       (cond\n         [(< (car l) (cadr l)) (monotonic (cdr l))]\n         [(>\
    \ (car l) (cadr l)) (monotonic (cdr l))]\n         [else #f])))\n", "  (match\
    \ l\n    ('() #t)\n    ([x] #t)\n    ([x y . rest]\n     (and\n      ;; Only recur\
    \ if we are increasing or decreasing\n      (or (> x y) (< x y))\n      (monotonic\
    \ (cons y rest))))))\n```\n\n```racket\n#lang racket\n", "  (cond\n    [(empty?\
    \ l) #t]\n    [(= (length l) 1) #t]\n    [(> (first l) (second l)) (monotonic\
    \ (rest l))]\n    [(< (first l) (second l)) (monotonic (rest l))]\n    [else #f]))\n",
  "  (cond\n    [(or (null? l) (null? (cdr l))) #t]\n    [(and (= (first l) (first\
    \ (cdr l)))\n          (monotonic (cdr l))) #t]\n    [(and (< (first l) (first\
    \ (cdr l)))\n          (increasing? (cdr l))) #t]\n    [(and (> (first l) (first\
    \ (cdr l)))\n          (decreasing? (cdr l))) #t]\n    [else #f]))\n", "  (cond\
    \ [(empty? l) #t]\n        [(= (second l) (first l))\n         (monotonic (rest\
    \ l))]\n        [(> (second l) (first l))\n         (and (monotonic (rest l))\n\
    \              (every < (rest l) (rest (rest l))))]\n        [(< (second l) (first\
    \ l))\n         (and (monotonic (rest l))\n              (every > (rest l) (rest\
    \ (rest l))))]))", "  (or (monotonic-increasing l)\n      (monotonic-decreasing\
    \ l)))\n", "  (cond [(empty? l) #t]\n        [(monotonic-aux (first l) 'incr (rest\
    \ l)) #t]\n        [(monotonic-aux (first l) 'decr (rest l)) #t]\n        [else\
    \ #f]))\n", "  (if (null? l)\n      #t\n      (let ((cdr (cdr l)))\n        (if\
    \ (null? cdr)\n            #t\n            (if (&lt; (car l) (car cdr))\n    \
    \            (monotonic cdr)\n                (monotonic (reverse l)))))))\n</code>\n\
    When we call <code>monotonic</code> on a list of numbers that are monotonically\
    \ increasing, the call returns immediately; when we call it on a list of numbers\
    \ that are not monotonically increasing, we reverse the list and call <code>monotonic</code>\
    \ on it.\n", "  (if (empty? l)\n      #t\n      (if (null? (cdr l))\n        \
    \  #t\n          (if (> (first l) (second l))\n              (and (monotonic (cdr\
    \ l))\n                   #t)\n              (and (monotonic (cdr l))\n      \
    \             #t)))))\n", "  (cond [(null? l)\n         #t]\n        [(null? (cdr\
    \ l))\n         #t]\n        [(null? (cddr l))\n         (or (positive? (- (cadr\
    \ l) (car l)))\n             (negative? (- (cadr l) (car l))))]\n        [else\n\
    \         (or (and (positive? (- (cadr l) (car l)))\n                  (monotonic\
    \ (cdr l)))\n             (and (negative? (- (cadr l) (car l)))\n            \
    \      (monotonic (cdr l))))]))\n", "  (let loop ([mylist l] [x 0])\n    (cond\n\
    \      [(empty? mylist) #t]\n      [(<= (first mylist) x) #f]\n      [else (loop\
    \ (rest mylist) (first mylist))])))\n", "  (cond\n    [(null? l) #t]\n    [(<\
    \ (cadr l) (car l)) \n     (and (null? (cddr l)) #t)]\n    [(> (cadr l) (car l))\
    \ \n     (and (null? (cddr l)) #t)]\n    [else (monotonic (cdr l))]))\n```\n\n\
    ## 2.14\n\n``` #lang racket\n", "  (if (null? l)\n      #t\n      (let ((first\
    \ (car l))\n            (rest (cdr l)))\n        (if (null? rest)\n          \
    \  #t\n            (let ((second (car rest)))\n              (if (eq? first second)\n\
    \                  (monotonic rest)\n                  (and\n                \
    \   (if (gt? first second)\n                       (every (lambda (e) (lt? first\
    \ e)) rest)\n                       (every (lambda (e) (gt? first e)) rest))\n\
    \                   (monotonic rest))))))))\n", "  (cond\n    [(null? l) #t]\n\
    \    [(equal? (length l) 1) #t]\n    [(or (or (and (> (car l) (cadr l)) (monotonic\
    \ (cdr l)))\n             (and (< (car l) (cadr l)) (monotonic (cdr l))))\n  \
    \       #t) #t]\n    [else #f]))\n", "  (define (helper l)\n    (if (null? (cdr\
    \ l))\n        #t\n        (if (if (> (car l) (cadr l)) #t #f)\n            (if\
    \ (> (car l) (cadr l))\n                (helper (cdr l))\n                #f)\n\
    \            (if (< (car l) (cadr l))\n                (helper (cdr l))\n    \
    \            #f))))\n  (helper l))\n", "  (monotonic-helper l 'increasing))\n",
  "  (define (monotonic-helper ls increasing)\n    (cond [(empty? ls) #t]\n      \
    \    [(empty? (rest ls)) #t]\n          [(> (first ls) (second ls)) (monotonic-helper\
    \ (rest ls) #f)]\n          [(< (first ls) (second ls)) (monotonic-helper (rest\
    \ ls) #t)]\n          [(= (first ls) (second ls)) (monotonic-helper (rest ls)\
    \ increasing)]\n          [else (and increasing (not increasing))]))\n  (monotonic-helper\
    \ l 'decreasing))", "  (cond\n    [(empty? l)\n     #t]\n    [(not (empty? (rest\
    \ l)))\n     (and\n      (if (> (first l) (second l))\n          (<= (first l)\
    \ (first (rest l)))\n          (>= (first l) (first (rest l))))\n      (monotonic\
    \ (rest l)))]\n    [else\n     #t]))\n", "  (cond ((empty? l) #t)\n        ((or\
    \ (and (positive? (second l)) (> (second l) (first l)))\n             (and (negative?\
    \ (second l)) (< (second l) (first l))))\n         (monotonic (rest l)))\n   \
    \     (else #f)))\n", "  (if (null? l)\n      #t\n      (let ((rest (cdr l)))\n\
    \        (if (null? rest)\n            #t\n            (let ((compare-op (if (>\
    \ (car l) (car rest))\n                                  -\n                 \
    \                 +)))\n              (if (apply compare-op (car l) (car rest))\n\
    \                  (monotonic rest)\n                  #f))))))\n```\n\n```racket\n\
    #lang racket\n", "  (cond ((null? l) #t)\n        ((or (and (null? (cdr l)) #t)\
    \ (and (null? (cddr l)) #t))\n         #t)\n        ((and (< (car l) (cadr l))\
    \ (monotonic (cdr l))) #t)\n        ((and (> (car l) (cadr l)) (monotonic (cdr\
    \ l))) #t)\n        (else #f)))\n", "  (if (null? l)\n      #t\n      (if (null?\
    \ (cdr l))\n          #t\n          (let ([c (cons (car l) (cdr l))])\n      \
    \      (cond\n              [(< (car c) (cadr c)) (and (monotonic (cdr c)) #t)]\n\
    \              [(> (car c) (cadr c)) (and (monotonic (cdr c)) #t)]\n         \
    \     [else #f])))))\n\n", "  (cond ((or (null? l) (null? (cdr l))) #t)\n    \
    \    ((> (car l) (cadr l))\n         (and (<= (car l) (car (cdr l))) (monotonic\
    \ (cdr l))))\n        ((< (car l) (cadr l))\n         (and (>= (car l) (car (cdr\
    \ l))) (monotonic (cdr l))))\n        (else (error \"Error in calling monotonic:\
    \ unexpected input\"))))\n\n", "  (cond [(null? l) #t]\n        [(null? (cdr l))\
    \ #t]\n        [(null? (cddr l)) #t]\n        [else\n         (and (case (list\
    \ (car l) (cadr l) (caddr l))\n                [(list x y z) (and (> x y) (> y\
    \ z))]\n                [(list x y z) (and (< x y) (< y z))])\n              (monotonic\
    \ (cdr l)))]))\n", "  (define (rec l acc)\n    (if (null? l)\n        #t\n   \
    \     (if (or (and (= acc '+)\n                     (< (car l) (cadr l)))\n  \
    \              (and (= acc '-)\n                     (> (car l) (cadr l))))\n\
    \            (rec (cdr l) acc)\n            #f)))\n  (if (null? l)\n      #t\n\
    \      (let ((e1 (car l))\n            (e2 (cadr l)))\n        (rec (cdr l) (if\
    \ (< e1 e2) '+ '-)))))\n", "  (and (not (null? l))\n       (let ((increasing?\n\
    \              (for/and ([i l] [j (in-list (cdr l))])\n                (<= i j))))\n\
    \         (or increasing?\n             (for/and ([i l] [j (in-list (cdr l))])\n\
    \               (>= i j))))))\n", "  (or (increasing l) (decreasing l)))\n", " \
    \ (cond\n    [(empty? l) (error \"empty list\")]\n    [(empty? (rest l)) #t]\n\
    \    [(or (positive? (sub1 (first l)) (first (rest l)))\n         (negative? (sub1\
    \ (first l)) (first (rest l))))\n     (monotonic (rest l))]\n    [else #f]))\n",
  "  (define (helper l increasing)\n    (cond [(empty? l) #t]\n          [(and increasing\n\
    \                (apply < (rest l)))\n           (helper (rest l) increasing)]\n\
    \          [(and (not increasing)\n                (apply > (rest l)))\n     \
    \      (helper (rest l) increasing)]\n          [else #f]))\n  (cond [(empty?\
    \ l) #t]\n        [(= (length l) 1) #t]\n        [(> (first l) (second l))\n \
    \        (helper (rest l) #f)]\n        [(< (first l) (second l))\n         (helper\
    \ (rest l) #t)]\n        [else #f]))\n", "  (cond\n    [(empty? l) true]\n   \
    \ [(= (length l) 1) true]\n    [(> (cadr l) (car l)) (monotonic (cdr l))]\n  \
    \  [(< (cadr l) (car l)) (monotonic (cdr l))]\n    [else false]))\n", "  (cond\
    \ ((null? l) #t)\n        ((null? (cdr l)) #t)\n        ((< (car l) (cadr l))\
    \ (monotonic (cdr l)))\n        ((> (car l) (cadr l)) (monotonic (cdr l)))\n \
    \       (else #f)))\n", "  (or (monotonic-1 l + 1)\n      (monotonic-1 l - 1)))\n",
  "  (cond\n    [(empty? l)\n     #t]\n    [(or (empty? (cdr l))\n         (and (positive?\
    \ (sub1 (car l)))\n              (negative? (sub1 (cadr l)))))\n     (monotonic\
    \ (cdr l))]\n    [(or (positive? (sub1 (car l)))\n         (negative? (sub1 (cadr\
    \ l))))\n     #f]\n    [else\n     (monotonic (cdr l))]))\n", "  (cond\n    ((empty?\
    \ l) #t)\n    ((empty? (rest l)) #t)\n    ((< (first l) (second l)) (monotonic\
    \ (rest l)))\n    ((> (first l) (second l)) (monotonic (rest l)))\n    (else #f)))\n",
  "  (cond [(null? l) #t]\n        [(null? (cdr l)) #t]\n        [(or (= (car l) (cadr\
    \ l))\n             (and (and (positive? (car l)) (positive? (cadr l)))\n    \
    \              (not (positive? (- (car l) (cadr l))))))\n         (monotonic (cdr\
    \ l))]\n        [else #f]))\n", "  (cond [(empty? l) #t]\n        [(empty? (rest\
    \ l)) #t]\n        [(> (first l) (second l))\n         (monotonic-decreasing (rest\
    \ l))]\n        [(< (first l) (second l))\n         (monotonic-increasing (rest\
    \ l))]\n        [else #f]))\n", "  (cond\n    [(empty? l) true]\n    [(empty?\
    \ (rest l)) true]\n    [(or (and (positive? (first l)) (positive? (sub1 (first\
    \ l))))\n         (and (negative? (first l)) (negative? (sub1 (first l)))))\n\
    \     (monotonic (rest l))]\n    [else false]))\n", "  (and (or (increasing l)\
    \ (decreasing l)) #t))\n", "  (cond [(empty? l) #t]\n        [(empty? (rest l))\
    \ #t]\n        [(> (first l) (second l)) (and (monotonic (rest l)) (>= (first\
    \ l) (first (rest l))))]\n        [(< (first l) (second l)) (and (monotonic (rest\
    \ l)) (<= (first l) (first (rest l))))]\n        [else (and (monotonic (rest l))\
    \ (= (first l) (first (rest l))))]))\n", "  (cond [(null? l)\n         #t]\n \
    \       [(null? (cdr l))\n         #t]\n        [(or (> (car l) (cadr l))\n  \
    \           (< (car l) (cadr l)))\n         (monotonic (cdr l))]\n        [else\n\
    \         #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n\
    \    [(> (first l) (second l))\n     (and (monotonic (rest l))\n          (<=\
    \ (first l) (second l)))]\n    [(< (first l) (second l))\n     (and (monotonic\
    \ (rest l))\n          (>= (first l) (second l)))]\n    [else #f]))\n", "  (or\
    \ (monotonic-inc l) (monotonic-dec l)))\n", "  (cond ((null? l) #t)\n        ((null?\
    \ (cdr l)) #t)\n        ((and (< (car l) (cadr l))\n              (monotonic (cdr\
    \ l))) #t)\n        ((and (> (car l) (cadr l))\n              (monotonic (cdr\
    \ l))) #t)\n        (else #f)))\n", "  (let ([dir (monotonic-dir l)])\n    (if\
    \ (eq? dir '()) #f #t)))\n", "  (let ([d (+ 1 -1)])\n    (andmap (lambda (x y)\
    \ (or (and (< x y) (<= d 1))\n                              (and (> x y) (<= d\
    \ -1))))\n            l)))\n", "  (define (monotonic-iter l dir)\n    (if (null?\
    \ l)\n        #t\n        (let ((x (car l))\n              (y (cadr l)))\n   \
    \       (if (and (not (null? y))\n                   (not (eq? dir 0))\n     \
    \              (or (and (> x y) (eq? dir 1))\n                       (and (< x\
    \ y) (eq? dir -1))))\n              #f\n              (monotonic-iter (cdr l)\
    \ (if (null? dir) (- x y) dir))))))\n  (monotonic-iter l 0))\n", "  (cond\n  \
    \  ((null? l) #t)\n    ((null? (cdr l)) #t)\n    ((and (eq? (car l) (car (cdr\
    \ l))) #t)\n     (monotonic (cdr l)))\n    ((and (not (eq? (car l) (car (cdr l))))\n\
    \          (or (and (> (car l) (car (cdr l))) #t)\n              (and (< (car\
    \ l) (car (cdr l))) #t)))\n     (monotonic (cdr l)))\n    (else #f)))\n", "  (cond\n\
    \    [(empty? l) #t]\n    [(= (length l) 1) #t]\n    [(= (length l) 2) (apply\
    \ < l)]\n    [else\n     (cond\n       [(< (first l) (second l))\n        (and\
    \ (apply < l) (monotonic (rest l)))]\n       [(> (first l) (second l))\n     \
    \   (and (apply > l) (monotonic (rest l))))])]))\n", "  (cond [(empty? l) #t]\n\
    \        [(empty? (rest l)) #t]\n        [(< (first l) (second l))\n         (and\
    \ (monotonic (rest l)) (not (cons? (member (first l) (rest l)))))\n         ]\n\
    \        [(> (first l) (second l))\n         (and (monotonic (rest l)) (not (cons?\
    \ (member (first l) (rest l)))))\n         ]\n        [else #f]))\n", "  (cond\n\
    \    [(empty? l) empty?]\n    [(= (second l) (first l)) (monotonic (rest l))]\n\
    \    [(> (second l) (first l))\n     (and (monotonic (rest l)) (or (or (empty?\
    \ (rest l)) (> (third l) (second l))) #f))]\n    [(< (second l) (first l))\n \
    \    (and (monotonic (rest l)) (or (or (empty? (rest l)) (< (third l) (second\
    \ l))) #f))]))", "  (match l\n    [(cons hd tl)\n     (define (go l prev acc)\n\
    \       (match l\n         [(cons hd tl)\n          (define diff (- hd prev))\n\
    \          (define acc (and acc (= diff (abs diff))))\n          (go tl hd acc)]\n\
    \         [() acc]))\n     (go tl hd #t)]\n    [() #t]))\n", "  (if (empty? l)\n\
    \      #t\n      (if (= (second l) (first l))\n          (monotonic (rest l))\n\
    \          (if (= (second l) (+ (first l) 1))\n              (monotonic (rest\
    \ l))\n              (if (= (second l) (- (first l) 1))\n                  (monotonic\
    \ (rest l))\n                  #f)))))\n", "  (cond ((null? l) #t)\n        ((null?\
    \ (cdr l)) #t)\n        ((> (car l) (cadr l)) (monotonic (cdr l)))\n        ((<\
    \ (car l) (cadr l)) (monotonic (cdr l)))\n        (else #f)))\n", "  (cond ((null?\
    \ l) #t)\n        ((null? (cdr l)) #t)\n        ((equal? (car l) (cadr l))\n \
    \        (monotonic (cdr l)))\n        ((and (< (car l) (cadr l)) (monotonic (cdr\
    \ l))) #t)\n        ((and (> (car l) (cadr l)) (monotonic (cdr l))) #t)\n    \
    \    (else #f)))\n```\n\n```racket\n#lang racket\n", "  (cond ((or (empty? l)\
    \ (empty? (rest l))) #t)\n        ((< (first l) (second l)) (and (monotonic (rest\
    \ l)) #t))\n        ((> (first l) (second l)) (and (monotonic (rest l)) #t))\n\
    \        (else #f)))\n", "  (cond\n    ((null? l) #t)\n    ((null? (cdr l)) #t)\n\
    \    ((> (car l) (cadr l)) (monotonic-dec l))\n    ((< (car l) (cadr l)) (monotonic-inc\
    \ l))))\n", "  (cond ((null? l) #t)\n        ((null? (cdr l)) #t)\n        ((and\
    \ (< (car l) (cadr l)) (monotonic (cdr l))) #t)\n        ((and (> (car l) (cadr\
    \ l)) (monotonic (cdr l))) #t)\n        (else #f)))\n", "  (cond\n    ((null?\
    \ l)\n     #t)\n    ((null? (cdr l))\n     #t)\n    ((> (car l) (cadr l))\n  \
    \   (if (null? (cddr l))\n         #t\n         (every < (cdr l))))\n    ((< (car\
    \ l) (cadr l))\n     (if (null? (cddr l))\n         #t\n         (every > (cdr\
    \ l))))\n    (else\n     #f)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
