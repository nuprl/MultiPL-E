name: HumanEval_134_check_if_last_char_is_a_letter
language: rkt
prompt: "#lang racket\n\n;; Create a function that returns #t if the last character\n\
  ;; of a given string is an alphabetical character and is not\n;; a part of a word,\
  \ and #f otherwise.\n;; Note: \"word\" is a group of characters separated by space.\n\
  ;; Examples:\n;; >>> (check_if_last_char_is_a_letter \"apple pie\")\n;; #f\n;; >>>\
  \ (check_if_last_char_is_a_letter \"apple pi e\")\n;; #t\n;; >>> (check_if_last_char_is_a_letter\
  \ \"apple pi e \")\n;; #f\n;; >>> (check_if_last_char_is_a_letter \"\")\n;; #f\n\
  (define (check_if_last_char_is_a_letter txt)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_if_last_char_is_a_letter))\n\
  \    (check-equal? (candidate \"apple\") #f)\n    (check-equal? (candidate \"apple\
  \ pi e\") #t)\n    (check-equal? (candidate \"eeeee\") #f)\n    (check-equal? (candidate\
  \ \"A\") #t)\n    (check-equal? (candidate \"Pumpkin pie \") #f)\n    (check-equal?\
  \ (candidate \"Pumpkin pie 1\") #f)\n    (check-equal? (candidate \"\") #f)\n  \
  \  (check-equal? (candidate \"eeeee e \") #f)\n    (check-equal? (candidate \"apple\
  \ pie\") #f)\n    (check-equal? (candidate \"apple pi e \") #f)\n))\n\n(test-humaneval)"
completions: ["  (if (null? txt)\n      #f\n      (if (string-ci=? (string-tail txt\
    \ (sub1 (string-length txt))) \" \")\n          #f\n          (if (char-alphabetic?\
    \ (string-ref txt (sub1 (string-length txt))))\n              #t\n           \
    \   #f))))\n```", "  (and (not (string=? txt \"\"))\n       (not (string-contains\
    \ txt #\\space))\n       (char-alphabetic? (string-ref txt (- (string-length txt)\
    \ 1)))))\n", "  (cond\n    [(null? txt) #f]\n    [(and\n      (char-alphabetic?\
    \ (string-ref txt (sub1 (string-length txt))))\n      (and\n        (not (null?\
    \ (substring txt (sub1 (string-length txt)) (string-length txt))))\n        (string=?\
    \ (substring txt (sub1 (string-length txt)) (string-length txt)) \" \")))\n  \
    \   #t]\n    [else #f]))\n", "  (if (or (string=? txt \"\")\n          (string=?\
    \ (substring txt (- (string-length txt) 1) (string-length txt)) \" \"))\n    \
    \  #f\n      (char-alphabetic? (string-ref txt (- (string-length txt) 1)))))\n",
  "  (cond\n    [(empty? txt) #f]\n    [(and (char-alphabetic? (last-char txt))\n\
    \          (or (empty? (rest txt))\n              (not (char-alphabetic? (last-char\
    \ (rest txt))))))\n     #t]\n    [else\n     (check_if_last_char_is_a_letter (rest\
    \ txt))]))\n```\n\n### \uCC38\uACE0\n* [How to check whether a character is a\
    \ letter or a digit in a string in Racket? - Stack Overflow](https://stackoverflow.com/questions/32014976/how-to-check-whether-a-character-is-a-letter-or-a-digit-in-a-string-in-racket)\n\
    * [racket - Checking if a string is a word - Stack Overflow](https://stackoverflow.com/questions/28269634/checking-if-a-string-is-a-word)\n\
    * [4.4.4 String Operations](https://docs.racket-lang.org/reference/strings.html)\n\
    * [6.8.6 String Constants](https://docs.racket-lang.org/reference/constants.html#%28part._.String_Constants%29)\n\
    * [racket - Why char-alphabetic? doesn't work? - Stack Overflow](https://stackoverflow.com/questions/30331061/why-char-alphabetic-doesnt-work)\n\
    * [7.4.4 Constants](https://docs.racket-lang.org/reference/constants.html)\n*\
    \ [6.3.2 List Operations](https://docs.racket-lang.org/reference/pairs.html#%28part._.List_Operations%29)\n\
    * [6.3.3 List Constants](https://docs.racket-lang.org/reference/constants.html#%28part._.List_Constants%29)\n\
    * [racket - How to split a string based on a delimiter - Stack Overflow](https://stackoverflow.com/questions/22985938/how-to-split-a-string-",
  "  (and (char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n       (not\
    \ (char-whitespace? (string-ref txt (- (string-length txt) 1))))))\n", "  (cond\
    \ ((string=? txt \"\")\n         #f)\n        ((alpha? (substring txt (sub1 (string-length\
    \ txt))))\n         (cond ((= (string-length txt) 1)\n                #t)\n  \
    \             ((and (alpha? (substring txt (sub1 (sub1 (string-length txt)))))\
    \ (not (char=? (string-ref txt (sub1 (string-length txt))) #\\space)))\n     \
    \           #f)\n               (else\n                #t)))\n        (else\n\
    \         #f)))\n", "  (cond\n    [(empty? txt) #f]\n    [(char-alphabetic? (last-char\
    \ txt))\n     (if (empty? (string-before-last txt))\n         #t\n         (check_if_last_char_is_a_letter\
    \ (string-before-last txt)))]\n    [else #f]))\n</code>\nI've written this code,\
    \ and it works fine, but I'm not sure if I'm  writing it the \"right\" way. The\
    \ description of the problem says that \"word\" is a group of characters separated\
    \ by space, and I'm wondering if I'm allowed to use the string-before-last function\
    \ or if that's considered a built-in function, and therefore not allowed.\nThanks\
    \ for any help!\n\n\nA:\n\nI'm not sure I understand this question. It seems you\
    \ are asking if you are allowed to use a built-in function. The answer is yes,\
    \ of course. This is not a question of whether you are allowed, but whether you\
    \ can use the built-in function to solve the problem. In this case you can, so\
    \ yes.\n", "  (or\n   (empty? txt)\n   (and\n    (alphabetic? (last-char txt))\n\
    \    (not (alphabetic? (last-char (string-drop-right txt 1)))))))\n", "  (and\
    \ (not (empty? txt))\n       (alphabetical? (substring txt -1))\n       (and (alphabetical?\
    \ (substring txt -2 -1))\n            (space? (substring txt -3 -2)))))\n", " \
    \ (if (zero? (string-length txt))\n      #f\n      (let ((last-char (string-ref\
    \ txt (- (string-length txt) 1))))\n        (and (char-alphabetic? last-char)\n\
    \             (not (string-contains txt last-char))))))\n", "  (if (string=? txt\
    \ \"\")\n      #f\n      (if (string-ref txt (sub1 (string-length txt)))\n   \
    \       (if (or (string=? (string-ref txt (sub1 (string-length txt))) \" \")\n\
    \                  (string=? (string-ref txt (sub1 (string-length txt))) \"\\\
    n\"))\n              #f\n              #t)\n          #f)))\n```\n\n<a name=\"\
    ex-32\"></a>\n\n## Exercise 3.2\n\nWrite a function that takes in a real number\
    \ and returns a list\ncontaining the digits of the given number.\n\n``` #lang\
    \ racket\n", "  (cond\n    [(string=? txt \"\") #f]\n    [(string-contains txt\
    \ #\\ ) #f]\n    [(string-contains txt #\\- ) #f]\n    [(string-contains txt #\\\
    . ) #f]\n    [(string-contains txt #\\, ) #f]\n    [(string-contains txt #\\;\
    \ ) #f]\n    [(string-contains txt #\\: ) #f]\n    [(string-contains txt #\\!\
    \ ) #f]\n    [(string-contains txt #\\? ) #f]\n    [(string-contains txt #\\&\
    \ ) #f]\n    [(string-contains txt #\\@ ) #f]\n    [(string-contains txt #\\#\
    \ ) #f]\n    [(string-contains txt #\\$ ) #f]\n    [(string-contains txt #\\%\
    \ ) #f]\n    [(string-contains txt #\\* ) #f]\n    [(string-contains txt #\\(\
    \ ) #f]\n    [(string-contains txt #\\) ) #f]\n    [(string-contains txt #\\+\
    \ ) #f]\n    [(string-contains txt #\\' ) #f]\n    [(string-contains txt #\\_\
    \ ) #f]\n    [(string-contains txt #\\= ) #f]\n    [(string-contains txt #\\~\
    \ ) #f]\n    [(string-contains txt #\\` ) #f]\n    [(string-contains txt #\\{\
    \ ) #f]\n    [(string-contains txt #\\} ) #f]\n    [(string-contains txt #\\[\
    \ ) #f]\n    [(string-contains txt #\\] ) #f]\n    [(string-contains txt #\\\\\
    \ ) #f]\n    [(string-contains txt #\\| ) #f]\n    [(string-contains txt #\\<\
    \ ) #f]\n    [(string-contains txt #\\> ) #f]\n    [(string-contains txt #\\/\
    \ ) #f]\n    [(string-contains", "  (define (word-break? ch) (or (char=? ch #\\\
    space) (char=? ch #\\tab)))\n  (define (letter? ch) (or (char-alphabetic? ch)\
    \ (char-numeric? ch)))\n  (define (not-word-break? ch) (not (word-break? ch)))\n\
    \  (define (find-last-char-not-word-break txt)\n    (if (= (string-length txt)\
    \ 0) (void)\n      (let ((ch (string-ref txt (- (string-length txt) 1))))\n  \
    \      (if (not-word-break? ch) (void)\n          (find-last-char-not-word-break\
    \ (substring txt 0 (- (string-length txt) 1)))))))\n  (define (has-non-word-break?\
    \ txt)\n    (let ((ch (string-ref txt (- (string-length txt) 1))))\n      (and\
    \ (letter? ch) (not-word-break? ch))))\n  (let ((txt (string-trim txt)))\n   \
    \ (if (= (string-length txt) 0) #f\n      (let ((ch (string-ref txt (- (string-length\
    \ txt) 1))))\n        (if (not-word-break? ch) (has-non-word-break? txt)\n   \
    \       (and (has-non-word-break? txt) (check_if_last_char_is_a_letter (substring\
    \ txt 0 (- (string-length txt) 1)))))))))\n```\n\n### Convert a List to a String\n\
    \n```\n#lang racket\n", "  (cond\n    [(empty? txt) #f]\n    [(char-alphabetic?\
    \ (last-char txt)) (and (char-alphabetic? (last-char txt))\n                 \
    \                            (not (char-whitespace? (first-char (rest-string txt)))))\
    \ ]\n    [else (check_if_last_char_is_a_letter (rest-string txt))]))\n", "  (let\
    \ ([len (string-length txt)])\n    (cond [(= 0 len) #f]\n          [(char-alphabetic?\
    \ (string-ref txt (- len 1)))\n           (or (= 1 len)\n               (not (char-alphabetic?\
    \ (string-ref txt (- len 2)))))\n           ]\n          [else #f])))\n\n\n",
  "    (if (= (string-length txt) 0) #f\n        (if (string-contains \"abcdefghijklmnopqrstuvwxyz\"\
    \ (string-ref txt (- (string-length txt) 1))) #t\n            #f)))\n", "  (cond\n\
    \    [(empty? txt) #f]\n    [(char-alphabetic? (last-char txt))\n     (or (empty?\
    \ (rest txt))\n         (not (char-alphabetic? (last-char (rest txt)))))\n   \
    \  ]\n    [else (check_if_last_char_is_a_letter (rest txt))]))\n", "  (define\
    \ (check i)\n    (if (and (positive? i)\n             (not (char-alphabetic? (string-ref\
    \ txt (- i 1)))))\n        (check (- i 1))\n        (char-alphabetic? (string-ref\
    \ txt (- i 1)))))\n  (and (not (equal? (string-length txt) 0))\n       (check\
    \ (string-length txt))))\n```\n\n-----\n\n### Problem 9\n\nCreate a function that\
    \ receives a list of numbers, and returns a list of numbers with all of the even\
    \ numbers doubled and all of the odd numbers with 1 added to it.\n\n```racket\n\
    #lang racket\n", "  (not (or (empty? txt) (char-whitespace? (last-char txt)))))\n",
  "  (cond\n    [(empty? txt) #f]\n    [(and (char-alphabetic? (last-char txt))\n\
    \          (not (substring? (substring txt 0 (sub1 (string-length txt)))\n   \
    \                        \" \")))\n     #t]\n    [else #f]))", "  (cond\n    [(string=?\
    \ txt \"\") false]\n    [(not (char-alphabetic? (string-ref txt (- (string-length\
    \ txt) 1)))) false]\n    [(not (char-whitespace? (string-ref txt (- (string-length\
    \ txt) 2)))) false]\n    [else true]))\n```", "  (if (= 0 (string-length txt))\n\
    \      #f\n      (let* ([chars-reversed (reverse (string->list txt))]\n      \
    \       [n (length chars-reversed)]\n             [first-char (list-ref chars-reversed\
    \ 0)])\n        (if (letter? first-char)\n            (if (= 1 n)\n          \
    \      #t\n                (let* ([second-char (list-ref chars-reversed 1)])\n\
    \                  (if (letter? second-char)\n                      #f\n     \
    \                 #t)))\n            #f))))", "  ;; get the last character\n \
    \ (define last-char (string-ref txt (- (string-length txt) 1)))\n  ;; check if\
    \ it is alpha character\n  (and (char-alphabetic? last-char)\n       ;; check\
    \ if this character is the last character of a word\n       (not (char-space?\
    \ last-char))))\n", "  (cond ((null? txt) #f)\n        ((char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1)))\n         (if (= (string-length txt) 1)\n  \
    \           #t\n             (if (char-alphabetic? (string-ref txt (- (string-length\
    \ txt) 2)))\n                 #f\n                 #t)))\n        (else #f)))\n",
  "  (let ((last-char (string-ref txt (- (string-length txt) 1))))\n    (and\n   \
    \  (char-alphabetic? last-char)\n     (not (member last-char (string->list (word-at-point)))))))\n",
  "  (define (checker txt)\n    (cond ((string=? txt \"\")\n           #f)\n     \
    \     ((char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n       \
    \    (if (or (char-whitespace? (string-ref txt (- (string-length txt) 2)))\n \
    \                  (string=? txt (string-copy (string-ref txt (- (string-length\
    \ txt) 1)))))\n               #t\n               #f))\n          (else\n     \
    \      #f)))\n  (checker txt))\n", "  (define (check-sub-str sub-str)\n    (cond\n\
    \      [(empty? sub-str) #f]\n      [(char-alphabetic? (first sub-str)) #t]\n\
    \      [else (check-sub-str (rest sub-str))]))\n  (if (empty? txt)\n      #f\n\
    \      (check-sub-str (substring txt -1))))\n", "  (cond\n    [(empty? txt) #f]\n\
    \    [(alphabetic? (last-char txt))\n     (and\n       (alphabetic? (last-char\
    \ txt))\n       (not\n         (and\n           (alphabetic? (last-char (butlast\
    \ txt)))\n           (not (empty? (butlast txt))))))]\n    [else #f]))\n```\n\n\
    ```scheme\n#lang racket\n", "  (if (string=? txt \"\")\n      #f\n      (if (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n\t  (if (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 2)))\n\t      #f\n\t      #t)\n\t  #f)))\n", "  (local\
    \ [(define (non-word-char? c)\n            (or (char-alphabetic? c)\n        \
    \        (char-whitespace? c)))\n          (define (last-char txt)\n         \
    \   (string-ref txt (sub1 (string-length txt))))]\n    (and (string-length txt)\n\
    \         (non-word-char? (last-char txt)))))\n", "  (and (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1)))\n       (not (string-contains txt \" \"))))\n",
  "  (let ([lst (string-&gt;list txt)])\n    (cond\n      [(null? lst) false]\n  \
    \    [(alphabetic? (car lst)) (check_if_last_char_is_a_letter (list-&gt;string\
    \ (cdr lst)))]\n      [(char-whitespace? (car lst)) (check_if_last_char_is_a_letter\
    \ (list-&gt;string (cdr lst)))]\n      [else (alphabetic? (car lst))])))\n</code>\n\
    But when I tried this, it didn't work.\nI got this output:\n<code>Welcome to DrRacket,\
    \ version 6.7 [3m].\nLanguage: racket [custom]; memory limit: 1024 MB.\nracket@[my\
    \ macbook pro]:~/Desktop$ racket -f seventh.rkt \n#&lt;void&gt;\nracket@[my macbook\
    \ pro]:~/Desktop$ \n</code>\nI don't know what's wrong with my code. What's wrong\
    \ with it?\nI am using DrRacket, version 6.7.\n\n\nA:\n\nYou are not calling the\
    \ function anywhere.\nTry adding a call to it in the bottom of the file:\n<code>(check_if_last_char_is_a_letter\
    \ \"abc\")\n</code>\n", "  (and\n   (char-alphabetic? (last-char txt))\n   (not\
    \ (word-char? (last-char txt)))\n   )\n  )\n", "  (cond [(empty? txt) false]\n\
    \        [(not (string? txt)) (error \"Input is not a string.\")]\n        [(string=?\
    \ (substring txt -1) \" \") false]\n        [(string=? (substring txt -1) \"\"\
    ) false]\n        [(char-alphabetic? (string-ref txt (- (string-length txt) 1)))\
    \ true]\n        [else false]))\n", "  (define (check_aux txt prev)\n    (cond\n\
    \      [(empty? txt) #f]\n      [(and (letter? (first txt)) (not (letter? prev)))\
    \ #t]\n      [else (check_aux (rest txt) (first txt))]))\n  (check_aux txt (first\
    \ txt)))\n```\n\n## Problem 4\n\n```racket\n#lang racket\n", "  (cond\n    [(=\
    \ (string-length txt) 0) #f]\n    [(= (string-length txt) 1) (char-alphabetic?\
    \ (string-ref txt 0))]\n    [(char-alphabetic? (string-ref txt (sub1 (string-length\
    \ txt))))\n     (and (char-alphabetic? (string-ref txt (- (string-length txt)\
    \ 2)))\n          #f)]\n    [else (char-alphabetic? (string-ref txt (sub1 (string-length\
    \ txt))))]))\n", "  (let ([str (string-trim txt)])\n    (cond\n      [(string=?\
    \ str \"\") #f]\n      [(char-alphabetic? (string-ref str (- (string-length str)\
    \ 1)))\n       (if (char-alphabetic? (string-ref str (- (string-length str) 2)))\n\
    \           #f\n           #t)]\n      [else #f])))", "  (string-split (string-trim\
    \ txt) #\\space))\n", "  (string-alphabetic? (string-ref txt (- (string-length\
    \ txt) 1))))\n</code>\nEDIT\nHere is a version that behaves like the example shows.\n\
    <code>#lang racket\n", "  (let ((last (string-&gt;list (string-reverse txt))))\n\
    \    (and (char-alphabetic? (car last))\n         (char-whitespace? (car (cdr\
    \ last))))))\n</code>\nQuestion: Is there a way to accomplish this in a more concise\
    \ way?\n\n\nA:\n\nBoth your method and of user1035010's method are excellent.\
    \  I don't think there is a way to accomplish the task any better.\n", "  (string-ci=?\
    \ \"e\" (string-trim-both txt)))\n```\n\n### Problem 6\n```racket\n#lang racket\n",
  "  (if (= (string-length txt) 0)\n      #f\n      (let ([last-char (string-ref txt\
    \ (- (string-length txt) 1))])\n        (and (char-alphabetic? last-char)\n  \
    \           (not (string-contains txt \" \"))))))\n", "  ; your code here\n  )\n",
  "  (and\n   (and\n    (and\n     (and\n      (and\n       (and\n        (and\n \
    \        (and\n          (and\n           (and\n            (and\n           \
    \  (and\n              (and\n               (and\n                (and\n     \
    \            (and\n                  (and\n                   (and\n         \
    \           (and\n                     (and\n                      (and\n    \
    \                   (and\n                        (and\n                     \
    \    (and\n                          (and\n                           (and\n \
    \                           (and\n                             (and\n        \
    \                      (and\n                               (and\n           \
    \                     (and\n                                 (and\n          \
    \                        (and\n                                   (and\n     \
    \                               (and\n                                     (and\n\
    \                                      (and\n                                \
    \       (and\n                                        (and\n                 \
    \                        (and\n                                          (and\n\
    \                                           (and\n                           \
    \                 (and\n                                             (and\n  \
    \                                            (and\n                          \
    \                     (and\n                                                (and\n\
    \                                                 (and\n                     \
    \                             (and\n                                         \
    \          (and\n                                                    (and\n  \
    \                                                   (and\n                   \
    \                                   (and\n                                   \
    \                    (and\n                                                  \
    \      (and\n                                                         (and\n \
    \                                                         (and\n             \
    \                                              (and\n                        \
    \                                    (and\n                                  \
    \                           (and\n                                           \
    \                   (and\n                                                   \
    \            (and\n                                                          \
    \      (and\n                                                                \
    \ (and\n                                                                  (and\n\
    \                                                                   (and\n   \
    \                                                                 (and\n     \
    \                                                                (and\n      \
    \                                                                (and\n      \
    \                                                                 (and\n     \
    \                                                                   (and\n   \
    \                                                                      (and\n\
    \                                                                          (and\n\
    \                                                                           (and\n\
    \                                                                            (and\n\
    \                                                                            \
    \ (and\n                                                                     \
    \         (and\n                                                             \
    \                  (and\n                                                    \
    \                            (and\n                                          \
    \                                       (and\n                               \
    \                                                   (and\n                   \
    \                                                                (and\n      \
    \                                                                            \
    \  (and\n                                                                    \
    \                 (and\n                                                     \
    \                                 (and\n                                     \
    \                                                  (and\n                    \
    \                                                                    (and\n  \
    \                                                                            \
    \           (and", "  (and (not (empty? txt))\n       (or (char-alphabetic? (last-char\
    \ txt))\n           (not (member (last-char txt) '(\" \" \".\" \",\" \"-\" \"\
    '\"))))))\n\n", "  (and (not (equal? txt \"\"))\n       (or (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n           (not (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 2)))))))\n", "  (cond\n    [(string=?\
    \ txt \"\") #f]\n    [(string-index txt #\\space (string-length txt)) #f]\n  \
    \  [(and (string-index txt #\\space 0) (char-alphabetic? (string-ref txt (string-length\
    \ txt)))) #t]\n    [else #f]))", "  (and (not (empty? txt))\n       (and (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n            (or (empty? (regexp-match\
    \ #rx\"[[:space:]]+\" txt))\n                (eq? (string-length (regexp-match\
    \ #rx\"[[:space:]]+\" txt))\n                     (- (string-length txt) 1))))))\n",
  "  (cond\n    [(string=? \"\" txt) #f]\n    [(= (sub1 (string-length txt)) (string-index-right\
    \ txt #\\  (string-length txt))) #f]\n    [(string-index-right txt #\\  (string-length\
    \ txt))\n     (string-alphabetic? (string-ref txt (sub1 (string-index-right txt\
    \ #\\  (string-length txt)))))\n     ]\n    [else (string-alphabetic? (string-ref\
    \ txt (sub1 (string-length txt))))]))", "  (if (null? txt)\n      #f\n      (if\
    \ (and (alphabetic? (last-char txt))\n               (not (alphabetic? (second-last-char\
    \ txt))))\n          #t\n          #f)))\n", "  (cond\n    ((empty? txt) #f)\n\
    \    ((and (char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n   \
    \       (not (any #t (map char-whitespace? (string->list txt)))))\n     #t)\n\
    \    (else #f)))\n", "  (let ([last-char (string-ref txt (sub1 (string-length\
    \ txt)))])\n    (and (char-alphabetic? last-char)\n         (or (not (char-alphabetic?\
    \ (string-ref txt (sub1 (sub1 (string-length txt))))))\n             (char-whitespace?\
    \ (string-ref txt (sub1 (sub1 (string-length txt)))))))))\n", "  (not (or (empty?\
    \ txt)\n           (or (symbol? (string-last txt))\n               (string-contains\
    \ txt #\\ ))\n           (and (= 1 (string-length txt))\n                (not\
    \ (char-alphabetic? (string-last txt)))))))\n</code>\n", "  (cond\n    [(empty?\
    \ txt) #f]\n    [(char-alphabetic? (last-char txt))\n     (or (empty? (rest (string-&gt;list\
    \ txt)))\n         (and (not (char-alphabetic? (last-char (rest (string-&gt;list\
    \ txt)))))\n              (not (char-alphabetic? (last-char (rest (rest (string-&gt;list\
    \ txt))))))))]\n    [else #f]))\n</code>\nI'm using DrRacket. When I enter the\
    \ above code in and run it, it works. But if I enter one of the examples in <code>check_if_last_char_is_a_letter</code>\
    \ fails with an error.\nFor example, entering:\n<code>(check_if_last_char_is_a_letter\
    \ \"apple pie\")\n</code>\nresults in\n<code>rest: contract violation\n  expected:\
    \ (listof any/c)\n  given: \"e\"\n  in: (rest (string-&gt;list txt))\n</code>\n\
    And entering:\n<code>(check_if_last_char_is_a_letter \"apple pi e\")\n</code>\n\
    results in\n<code>last-char: contract violation\n  expected: (or/c (listof any/c)\
    \ (string? . -1))\n  given: \"e\"\n  in: (last-char (rest (string-&gt;list txt)))\n\
    </code>\n\nSo my question is, why is this happening?\n\n\nA:\n\n<code>string-&gt;list</code>\
    \ converts a string to a list of characters, not a list of strings.\nE.g. <code>(string-&gt;list\
    \ \"a\")</code> returns <code>'(#\\a)</code> -- the list <code>(#\\a)</code> --\
    \ not <code>'(\"a\")</code>.\nSo <code>(rest (string-&gt;list txt))</code> returns\
    \ <code>'(#\\a #\\p #\\p #\\l #\\e #\\ )</code>, not <code>'(\"apple \")</code>.\
    \ \nSince", "  (if (and (not (empty? txt)) \n           (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1))))\n      (if (string-contains txt #\\space)\n\
    \          #f\n          #t)\n      #f))\n", "  (and (not (empty? txt))\n    \
    \   (not (char-whitespace? (last-char txt)))\n       (not (char-word? (last-char\
    \ txt)))\n       (char-alphabetic? (last-char txt))))\n```\n\n## Problem 17\n\
    ```#lang racket\n", "  (define (is_letter? ch)\n    (and (&gt;= ch #\\a) (&lt;=\
    \ ch #\\z)))\n  (and (string? txt)\n       (&gt; (string-length txt) 0)\n    \
    \   (or (not (is_letter? (string-ref txt (- (string-length txt) 1))))\n      \
    \     (is_letter? (string-ref txt (- (string-length txt) 2))))))\n</code>\n",
  "  (if (string=? txt \"\")\n      #f\n      (let ((last-char (string-ref txt (-\
    \ (string-length txt) 1))))\n        (and (char-alphabetic? last-char)\n     \
    \        (char-whitespace? last-char)))))\n", "  (cond\n    [(empty? txt) #f]\n\
    \    [(and (alphabetic? (string-ref txt (sub1 (string-length txt))))\n       \
    \   (string-match \" \" (string-trim-right txt)))\n     #t]\n    [else #f]))\n",
  "  (let* ([last-char (last-char txt)]\n         [is-letter? (is-letter? last-char)])\n\
    \    (not (or (is-empty? txt)\n             (is-whitespace? last-char)\n     \
    \        (not is-letter?)))))\n```\n\n``` #lang racket", "  (or\n   (string-empty?\
    \ txt)\n   (not (char-alphabetic? (string-ref txt (- (string-length txt) 1))))\n\
    \   (char-whitespace? (string-ref txt (- (string-length txt) 2)))))\n", "  (let\
    \ ((len (string-length txt)))\n    (and (> len 0)\n         (char-alphabetic?\
    \ (string-ref txt (- len 1)))\n         (or (not (char-alphabetic? (string-ref\
    \ txt (- len 2))))\n             (not (char-alphabetic? (string-ref txt (- len\
    \ 3))))))))\n```\n\n```racket\n#lang racket\n", "  (and (not (empty? txt))\n \
    \      (and (char-alphabetic? (last-char txt))\n            (not (char-alphabetic?\
    \ (last-char (substring txt 0 (- (string-length txt) 1))))))))\n", "  (let ((len\
    \ (string-length txt)))\n    (if (= len 0)\n        #f\n        (if (= (char-alphabetic?\
    \ (string-ref txt (- len 1))) #t)\n            (if (= (char-alphabetic? (string-ref\
    \ txt (- len 2))) #t)\n                #f\n                #t)\n            #f))))\n",
  "  (cond\n    [(string=? \"\" txt) #f]\n    [(char-alphabetic? (string-ref txt (-\
    \ (string-length txt) 1)))\n     (cond\n       [(string-suffix? \" \" txt) #f]\n\
    \       [else #t])]\n    [else #f]))\n", "  (cond\n    [(string-empty? txt) #f]\n\
    \    [(and (char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n   \
    \       (not (string-contains? txt #\\space)))]\n    [else #f]))\n", "  (if (=\
    \ (string-length txt) 0)\n      #f\n      (if (string-contains-substring? txt\
    \ \" \")\n          (if (and (= (string-length (substring txt (sub1 (string-length\
    \ txt)))) 1)\n                   (char-alphabetic? (string-ref txt (sub1 (string-length\
    \ txt)))))\n              #t\n              #f)\n          (if (char-alphabetic?\
    \ (string-ref txt (sub1 (string-length txt))))\n              #t\n           \
    \   #f))))\n", "  (define (is-letter? c)\n    (and (char-alphabetic? c)\n    \
    \     (not (char-whitespace? c))))\n  (cond\n    [(null? txt) #f]\n    [(empty?\
    \ (rest txt)) #f]\n    [(is-letter? (last-char txt)) #t]\n    [else (check_if_last_char_is_a_letter\
    \ (rest txt))]))\n", "  (and (not (empty? txt))\n       (char-alphabetic? (last-char\
    \ txt))\n       (or (empty? (substring txt 0 -1))\n           (not (char-alphabetic?\
    \ (substring txt -2 -1))))))", "  (cond [(empty? txt) false]\n        [(string-ref\
    \ txt (- (string-length txt) 1))\n         (char-alphabetic? (string-ref txt (-\
    \ (string-length txt) 1)))]\n        [else false]))\n", "  ;; your code goes here\n\
    \  )\n", "  (and (alphabetic? (string-ref txt (- (string-length txt) 1)))\n  \
    \     (not (string-contains (string-trim txt) \" \"))))\n", "  ;; Write your code\
    \ here.\n  (cond\n    [(empty? txt) #f]\n    [(string-empty? (string-trim txt))\
    \ #f]\n    [(not (string-upcase-first-char? (substring txt (sub1 (string-length\
    \ txt))))) #f]\n    [else #t]))\n", "  (string-alphabetic? (string-ref txt (-\
    \ (string-length txt) 1))))\n", "  (cond\n    [(empty? txt) #f]\n    [(char-alphabetic?\
    \ (last-char txt))\n     (or (char-whitespace? (second-last-char txt))\n     \
    \    (check_if_last_char_is_a_letter (substring txt 0 (- (string-length txt) 1))))]\n\
    \    [else #f]))\n", "  (cond\n    [(empty? txt) #f]\n    [(and (char-alphabetic?\
    \ (last-char txt))\n          (not (char-alphabetic? (last-char (butlast txt)))))\
    \ #t]\n    [else #f]))\n", "  (if (empty? txt)\n      #f\n      (let ([ch (last-char\
    \ txt)])\n        (and (alphabetic? ch)\n             (not (element-of-string?\
    \ ch \"applepie\"))))))\n", "  (let loop ((txt txt) (length (string-length txt)))\n\
    \    (if (= length 0)\n        #f\n        (if (and (char-alphabetic? (string-ref\
    \ txt (- length 1)))\n                 (not (string-contains txt \" \")))\n  \
    \          #t\n            (loop (substring txt 0 (- length 1)) (- length 1))))))\n",
  "  (define (is_last_char_a_letter txt)\n    (if (= (string-length txt) 0)\n    \
    \    #f\n        (if (or (= (string-ref txt (- (string-length txt) 1)) #\\e)\n\
    \                (= (string-ref txt (- (string-length txt) 1)) #\\i)\n       \
    \         (= (string-ref txt (- (string-length txt) 1)) #\\n)\n              \
    \  (= (string-ref txt (- (string-length txt) 1)) #\\o)\n                (= (string-ref\
    \ txt (- (string-length txt) 1)) #\\u))\n            #t\n            #f)))\n \
    \ (is_last_char_a_letter txt))\n", "  (if (string=? txt \"\") #f\n      (if (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n          (if (not (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 2))))\n              #t #f)\n       \
    \   #f)))\n", "  (cond [(empty? txt) #f]\n        [(empty? (rest txt)) #f]\n \
    \       [(and (string-ci=? (rest (reverse txt)) \" \")\n              (string-ci=?\
    \ (rest (reverse (reverse txt))) \" \")) #f]\n        [(string-ci=? (rest (reverse\
    \ txt)) \" \") #t]\n        [else #f]))\n", "  (define (count-spaces str count)\n\
    \    (cond\n      [(string=? str \"\") count]\n      [(char=? (string-ref str\
    \ 0) #\\space) (count-spaces (substring str 1) (+ count 1))]\n      [else (count-spaces\
    \ (substring str 1) count)]))\n  (let ([count-of-spaces (count-spaces txt 0)])\n\
    \    (if (and (char-alphabetic? (string-ref txt (- (string-length txt) 1))) (=\
    \ (string-length txt) (+ count-of-spaces 1)))\n        #t\n        #f)))\n", " \
    \ (cond ((string=? txt \"\") #f)\n        ((= (string-length txt) 1)\n       \
    \  (if (string-alphabetic? (string-trim-both (string-trim-right txt) #\\space))\n\
    \             #t\n             #f))\n        ((not (string-alphabetic? (string-trim-both\
    \ (string-trim-right txt) #\\space)))\n         (check_if_last_char_is_a_letter\
    \ (string-trim-right txt)))\n        (else #t)))\n", "  (cond\n    [(empty? txt)\
    \ #f]\n    [(not (char-alphabetic? (last-char txt))) #f]\n    [(space? (first-char\
    \ (but-last txt))) #t]\n    [else #f]))\n", "  (if (&gt; (string-length txt) 0)\n\
    \      (if (string-ci=? (substring txt -1) (string-downcase (substring txt -1)))\n\
    \          (check_if_last_char_is_a_letter (substring txt 0 -1))\n          #t)\n\
    \      #f))\n", "  (cond [(empty? txt) false]\n        [(letter? (last-char txt))\
    \ true]\n        [else false]))\n", "  ;; return #t if txt is empty\n  (if (string=?\
    \ txt \"\")\n      #t\n      ;; return #f if last character is not a letter\n\
    \      (if (not (char-alphabetic? (string-ref txt (- (string-length txt) 1))))\n\
    \          #f\n          ;; make sure last character is a letter,\n          ;;\
    \ then check if last character is not a part of a word\n          (if (string-contains?\
    \ txt \" \")\n              #t\n              #f))))\n", "    (if (empty? txt)\n\
    \        #f\n        (if (empty? (rest txt))\n            (if (char-alphabetic?\
    \ (first txt))\n                #t\n                #f)\n            (if (char-alphabetic?\
    \ (first txt))\n                (if (char-whitespace? (first (rest txt)))\n  \
    \                  #t\n                    #f)\n                (check_if_last_char_is_a_letter\
    \ (rest txt))))))\n", "  (cond\n    [(string=? txt \"\") #f]\n    [(and (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n          (not (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 2)))))\n     #t]\n    [else #f]))\n",
  "  (regexp-match? (regexp \" *[[:alpha:]] *$\") txt))\n", "  (define (check txt)\n\
    \    (if (string-null? txt)\n        #f\n        (if (and (char-alphabetic? (string-ref\
    \ txt 0))\n                 (not (string-any (lambda (c)\n                   \
    \                 (not (char-alphabetic? c)))\n                              \
    \    (string-trim-both txt #\\space))))\n            #t\n            (check (string-tail\
    \ txt 1)))))\n  (check txt))", "  (and (not (empty? txt))\n       (or (and (char-alphabetic?\
    \ (last-char txt))\n                (not (string-has-substring? txt \" \")))\n\
    \           (and (not (char-alphabetic? (last-char txt)))\n                (not\
    \ (string-has-substring? txt \" \"))\n                (string-has-substring? txt\
    \ \" \")))))", "  (cond ((string=? txt \"\") #f)\n        ((char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1)))\n         (if (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 2)))\n             #f\n             #t))\n      \
    \  (else #f)))\n", "  (define (check_if_last_char_is_a_letter_iter txt)\n    (if\
    \ (char-alphabetic? (string-ref txt (sub1 (string-length txt))))\n        (if\
    \ (string-null? (string-trim txt))\n            #f\n            (if (string-null?\
    \ (string-trim (string-tail txt 1)))\n                #t\n                (check_if_last_char_is_a_letter_iter\
    \ (string-trim (string-tail txt 1)))))\n        #f))\n  (check_if_last_char_is_a_letter_iter\
    \ txt))", "  (and (not (empty? txt))\n       (and (alpha? (last-char txt))\n \
    \           (not (alpha? (last-char (string-drop-right txt 1)))))))\n", "  (or\
    \ (char-alphabetic? (string-ref txt (sub1 (string-length txt))))\n      (char-alphabetic?\
    \ (string-ref txt (sub1 (string-length txt))))))\n", "  (if (= 0 (string-length\
    \ txt))\n      #f\n      (let ([last-char (substring txt (- (string-length txt)\
    \ 1) (string-length txt))])\n        (if (not (alphabetic? last-char))\n     \
    \       #f\n            (let ([pre-last-char (substring txt (- (string-length\
    \ txt) 2) (- (string-length txt) 1))])\n              (if (alphabetic? pre-last-char)\n\
    \                  #f\n                  #t))))))\n```\n### Hints\n* Use `string-length`\
    \ to get the length of a string\n* Use `substring` to get a piece of a string\
    \ by specifying the starting index and the length\n* Use `alphabetic?` to check\
    \ if a string is an alphabetical character\n\n## Solution\n\n```racket\n#lang\
    \ racket\n", "  (cond\n    ((string=? txt \"\") #f)\n    ((= (string-length txt)\
    \ 1) (char-alphabetic? (string-ref txt 0)))\n    ((char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1)))\n     (if (char-alphabetic? (string-ref txt\
    \ (- (string-length txt) 2)))\n         #f\n         #t))\n    (else #f)))\n",
  "  (and (char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n       (not\
    \ (char-alphabetic? (string-ref txt (- (string-length txt) 2))))))\n", "  (cond\n\
    \    [(string=? txt \"\") #f]\n    [(string-ref txt (- (string-length txt) 1))\
    \ (char-alphabetic? (string-ref txt (- (string-length txt) 1)))]\n    [else #f]))\n",
  "  (cond\n    [(empty? txt)\n     #f]\n    [(and (char-alphabetic? (last txt))\n\
    \          (char-whitespace? (second-to-last txt)))\n     #t]\n    [else\n   \
    \  #f]))\n", "  (if (or (= (string-length txt) 0) (char-alphabetic? (substring\
    \ txt -1)))\n      #f\n      #t\n  )\n)\n```\n\n```racket\n#lang racket\n", " \
    \ (if (string=? txt \"\")\n      #f\n      (and (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1)))\n           (not (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 2)))))))", "  (let ((len (string-length txt)))\n\
    \    (and (> len 0)\n         (regexp-match* #rx\"^[a-zA-Z]\" (substring txt (-\
    \ len 1)))\n         (regexp-match* #rx\"^[a-zA-Z] $\" (substring txt (- len 2))))))",
  "  (cond\n    [(empty? txt) #f]\n    [(char-alphabetic? (last-char txt))\n     (if\
    \ (char-whitespace? (last-char (substring txt 0 (- (string-length txt) 1))))\n\
    \         #t\n         #f)]\n    [else #f]))\n", "  (if (= (string-length txt)\
    \ 0)\n      #f\n      (let* ([str (string-trim txt)]\n             [str (string-trim\
    \ (string-append str \" \"))]\n             [last-char (string-ref str (- (string-length\
    \ str) 1))])\n        (char-alphabetic? last-char))))", "  (cond\n    [(empty?\
    \ txt) #f]\n    [(symbol? (last-char txt)) #t]\n    [else #f]))\n", "  (if (empty?\
    \ txt)\n      #f\n      (let ((last-char (last-char txt)))\n        (char-alphabetic?\
    \ last-char))))\n", "  (cond\n    [(equal? 0 (string-length txt)) #f]\n    [(equal?\
    \ #\\space (string-ref txt (- (string-length txt) 1)))\n     (check_if_last_char_is_a_letter\
    \ (substring txt 0 (- (string-length txt) 1)))]\n    [(char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1))) #t]\n    [else #f]))\n```\n\n```racket\n#lang\
    \ racket\n", "  (if (string=? txt \"\")\n      #f\n      (if (or (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n              (char-whitespace?\
    \ (string-ref txt (- (string-length txt) 1))))\n          #f\n          #t)))\n",
  "  (char-alphabetic?\n   (string-ref\n    (regexp-replace* #rx\"\\\\b.$\" txt \"\
    \")\n    (sub1 (string-length txt)))))\n", "  ; exaustive tests\n  (cond \n  \
    \  [(equal? \"\" txt) #f] ; Case if txt is the empty string\n    [(equal? \" \"\
    \ (string-ref txt (- (string-length txt) 1))) #f] ; Case if txt ends with a space\
    \ character\n    [(equal? #\\_ (string-ref txt (- (string-length txt) 1))) #f]\
    \ ; Case if txt ends with a _ character\n    [(equal? #\\e (string-ref txt (-\
    \ (string-length txt) 1))) #t] ; Case if txt ends with an e character\n    [(equal?\
    \ #\\l (string-ref txt (- (string-length txt) 1))) #t] ; Case if txt ends with\
    \ an l character\n    [(equal? #\\t (string-ref txt (- (string-length txt) 1)))\
    \ #t] ; Case if txt ends with an t character\n    [else #f] ; Default case, when\
    \ a character is not e, l or t\n  )\n)\n", "  (if (string=? \"\" txt)\n      #f\n\
    \      (if (char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n   \
    \       (if (char-whitespace? (string-ref txt (- (string-length txt) 2)))\n  \
    \            #t\n              #f)\n          #f)))\n", "  (not (or (empty? txt)\n\
    \           (in-word? (last-char txt)))))\n", "  (if (empty? txt)\n      #f\n\
    \      (if (char-alphabetic? (last-char txt))\n          (if (char-whitespace?\
    \ (second-last-char txt))\n              #t\n              #f)\n          #f)))\n",
  "  (let* ([xt (string-trim txt)]\n         [xtl (string-length xt)])\n    (if (or\
    \ (= 0 xtl) (string-alphabetic? (string-trim txt -1)))\n        #f\n        #t)))\n",
  "  (letrec ([txt-str (string->list txt)]\n           [last-char (last txt-str)])\n\
    \    (cond [(empty? txt-str) #f]\n          [(and (char-alphabetic? last-char)\n\
    \                (not (member last-char (string->list \"!@#$%^&*()_+-=`~[]{}|:;'<>?,./\\\
    \"\")))) #t]\n          [else #f])))\n", "    (cond\n      [(string=? (string-take\
    \ txt 1) \" \") #f]\n      [(string=? (string-take txt 1) \"\") #f]\n      [(string=?\
    \ (string-take txt -1) \" \") #f]\n      [(string=? (string-take txt -1) \"\"\
    ) #f]\n      [(string=? (string-take txt -1) (string-take txt 1)) #f]\n      [(char-alphabetic?\
    \ (string-ref txt -1)) #t]\n      [else #f]))", "  (and (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1)))\n       (or (char-whitespace? (string-ref txt\
    \ (- (string-length txt) 2)))\n           (= 0 (string-length txt)))))", "  (and\n\
    \   (char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n   (not (char-whitespace?\
    \ (string-ref txt (- (string-length txt) 2))))))\n", "  (cond [(string=? txt \"\
    \")\n         #f]\n        [(and (char-alphabetic? (string-ref txt (- (string-length\
    \ txt) 1)))\n              (not (char-alphabetic? (string-ref txt (- (string-length\
    \ txt) 2)))))\n         #t]\n        [else\n         #f]))\n", "  (if (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n      (begin\n        (if (and\
    \ (&gt; (string-length txt) 1) (char-alphabetic? (string-ref txt (- (string-length\
    \ txt) 2))))\n            #f\n            #t))\n      #f))\n</code>\nThe key is\
    \ that <code>begin</code> is a way to group expressions. In this case, I'm putting\
    \ the predicate with the \"base case\" in the <code>begin</code>, and that way,\
    \ the result is #t if and only if the predicate is #t and the \"base case\" is\
    \ #t.\nThe predicate is a simple character comparison and is #t if the string\
    \ length is greater than 1 and the second-to-last character is also alphabetic.\
    \ If so, we return #f; otherwise, we return #t.\n", "  (local [(define (helper\
    \ txt is-word)\n            (cond\n              [(empty? txt) (and is-word #f)]\n\
    \              [(empty? (rest txt))\n               (and is-word (char-alphabetic?\
    \ (first txt)))]\n              [(char-alphabetic? (first txt))\n            \
    \   (helper (rest txt) #t)]\n              [(char-whitespace? (first txt))\n \
    \              (helper (rest txt) #f)]\n              [else (helper (rest txt)\
    \ is-word)]))]\n    (helper txt #f)))\n", "  (if (string=? txt \"\")\n      #f\n\
    \      (if (and (char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n\
    \               (or (not (char-alphabetic? (string-ref txt (- (string-length txt)\
    \ 2))))\n                   (string=? (string-ref txt (- (string-length txt) 2))\
    \ \" \")))\n          #t\n          #f)))\n", "  (cond\n    [(empty? txt) #f]\n\
    \    [(letter? (last-char txt))\n     (if (empty? (rest-of-string txt))\n    \
    \     #t\n         (check_if_last_char_is_a_letter (rest-of-string txt)))]\n \
    \   [else (check_if_last_char_is_a_letter (rest-of-string txt))]))\n", "  (define\
    \ (check_if_last_char_is_a_letter_iter txt)\n    (cond ((empty? txt) #f)\n   \
    \       ((empty? (rest txt)) #f)\n          ((and (= (first txt) #\\space) (alphabetic?\
    \ (second txt))) #t)\n          (else (check_if_last_char_is_a_letter_iter (rest\
    \ txt)))))\n  (check_if_last_char_is_a_letter_iter txt))\n", "  (if (null? txt)\
    \ #f\n      (if (or (char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n\
    \              (string-member (string-ref txt (- (string-length txt) 1)) \"!@#$%^&*()_-=+.,?'\\\
    \";:][\")) #t\n          #f)))\n", "  (and (not (empty? txt))\n       (alphabetic?\
    \ (last-char txt))\n       (not (alphabetic? (last-char (string-drop-right txt\
    \ 1))))))\n", "  (if (string=? \"\" txt)\n      #f\n      (if (member (string-ref\
    \ txt (- (string-length txt) 1)) (list #\\e #\\p #\\i))\n          #t\n      \
    \    #f)))\n", "  (let ([chars (string->list txt)])\n    (if (zero? (count chars))\
    \ #f\n        (let ([last-char (last chars)])\n          (if (alphabetic? last-char)\n\
    \              (if (empty? (rest (string-tokenize txt))) #t #f)\n            \
    \  #f)))))\n```\n\n```racket\n#lang racket\n", "  (cond\n    [(empty? txt) #f]\n\
    \    [(char-alphabetic? (last-char txt)) #t]\n    [else (check_if_last_char_is_a_letter\
    \ (substring txt 0 (- (string-length txt) 1)))])\n  )\n", "  (cond\n    [(empty?\
    \ txt) #f]\n    [(alphabetic? (last-char txt))\n     (if (char=? (last-char txt)\
    \ #\\space)\n         #f\n         #t)]\n    [else #f]))\n```\n\n```racket\n#lang\
    \ racket\n", "  (if (string=? txt \"\")\n      #f\n      (if (string-alphabetic?\
    \ (substring txt (- (string-length txt) 1) (string-length txt)))\n\t  (if (string-alphabetic?\
    \ (substring txt (- (string-length txt) 2) (- (string-length txt) 1)))\n\t   \
    \   #f\n\t      #t)\n\t  #f)))", "  (regexp-match? \"\\\\w\\\\z\" txt))\n", " \
    \ (let ([txt (string-&gt;list txt)])\n    (and (char-alphabetic? (list-ref txt\
    \ (- (length txt) 1)))\n         (not (member (list-ref txt (- (length txt) 2))\
    \ '(#\\space)))\n         (not (member (list-ref txt (- (length txt) 3)) '(#\\\
    space)))\n         (not (member (list-ref txt (- (length txt) 4)) '(#\\space)))\n\
    \         (not (member (list-ref txt (- (length txt) 5)) '(#\\space)))\n     \
    \    (not (member (list-ref txt (- (length txt) 6)) '(#\\space)))\n         (not\
    \ (member (list-ref txt (- (length txt) 7)) '(#\\space)))\n         (not (member\
    \ (list-ref txt (- (length txt) 8)) '(#\\space)))\n         (not (member (list-ref\
    \ txt (- (length txt) 9)) '(#\\space)))\n         (not (member (list-ref txt (-\
    \ (length txt) 10)) '(#\\space)))\n         (not (member (list-ref txt (- (length\
    \ txt) 11)) '(#\\space)))\n         (not (member (list-ref txt (- (length txt)\
    \ 12)) '(#\\space)))\n         (not (member (list-ref txt (- (length txt) 13))\
    \ '(#\\space)))\n         (not (member (list-ref txt (- (length txt) 14)) '(#\\\
    space)))\n         (not (member (list-ref txt (- (length txt) 15)) '(#\\space)))\n\
    \         (not (member (list-ref txt (- (length txt) 16)) '(#\\space)))\n    \
    \     (not (member (list-ref txt (- (length txt) 17)) '(#\\space)))\n        \
    \ (not (member (list-ref txt (- (length txt) 18)) '(#\\space)))\n         (not\
    \ (member (list-ref txt (- (length txt) 19)) '(#\\space)))\n         (not (member\
    \ (list-ref txt (- (length txt) 20)) '(", "  (define (extract-last-char str)\n\
    \    (if (string-length str)\n        (list-ref str (- (string-length str) 1))\n\
    \        \"\"))\n  (and (and (and (and (and (and (and (and (and (and (and (and\n\
    \  (and (and (and (and (and (and (and (and (and (and (and (and (and\n  (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and\n  (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and\n  (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and\n  (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and\n  (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and\n  (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and\n  (and (and (and (and (and (and (and (and (and (and (and (and (and\n \
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and\n  (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and\n  (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and\n  (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and\n  (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and\n  (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and\n  (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and\n  (and (and (and (and (and (and (and (and (and (and (", "  (regexp-match?\
    \ #rx\"^[A-Za-z]+[^A-Za-z0-9]+$\" txt))\n", "  (if (empty? txt)\n      #f\n  \
    \    (and (= (last-char txt) #\\e)\n           (not (member? (last-char txt) (chars\
    \ (list-of-words txt)))))))\n", "  (if (empty? txt)\n      #f\n      (if (char-alphabetic?\
    \ (last-char txt))\n          (if (char-alphabetic? (last-char (substring txt\
    \ 0 (- (string-length txt) 1))))\n              #f\n              #t)\n      \
    \    #f)))\n", "  (cond ((empty? txt) false)\n        ((not (char-alphabetic?\
    \ (last-char txt))) false)\n        ((char-alphabetic? (last-char txt)) true)))\n",
  "  (if (string=? \"\" txt)\n      #f\n      (if (char-alphabetic? (string-ref txt\
    \ (- (string-length txt) 1)))\n          (if (char-whitespace? (string-ref txt\
    \ (- (string-length txt) 2)))\n              #t\n              #f)\n         \
    \ #f)))\n", "  (if (string=? \"\" txt)\n      #f\n      (and (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n           (or (string=? \"\" (string-trim\
    \ txt))\n               (not (char-alphabetic? (string-ref txt (- (string-length\
    \ txt) 2))))))))\n", "  ;; returns #t if the last character\n  ;; of txt is an\
    \ alphabetical character and is not\n  ;; a part of a word, and #f otherwise.\n\
    \  (cond\n    [(empty? txt) #f]\n    [(char-alphabetic? (last-char txt))\n   \
    \  (and\n       (not (char-whitespace? (first-char txt)))\n       (not (char-whitespace?\
    \ (last-char txt))))]\n    [else #f]))\n</code>\nwhich works as expected, except\
    \ for the empty string case.\nFor this case I get the following error message:\n\
    <code>&gt; (check_if_last_char_is_a_letter \"\")\n. char-alphabetic?: expects\
    \ argument of type &lt;char&gt;; given: \"\"\n</code>\nHow do I make <code>char-alphabetic?</code>\
    \ work with the empty string?\n\n\nA:\n\nI would have taken a slightly different\
    \ approach, separating two concerns:\n<code>(define (char-is-letter? c)\n  (and\
    \ (char-alphabetic? c)\n       (not (char-whitespace? c))))\n", "  (cond\n   \
    \ [(empty? txt) #f]\n    [(and\n       (char-alphabetic? (string-ref txt (sub1\
    \ (string-length txt))))\n       (or (empty? (string-drop-right txt 1))\n    \
    \       (char-whitespace? (string-ref txt (sub1 (string-length (string-drop-right\
    \ txt 1)))))))\n     #t]\n    [else #f]))\n```\n\n### 15. Implement a function\
    \ that takes a list of strings as its parameter and prints the longest string\
    \ that can be made by concatenating its elements.\n```#lang racket\n", "  (and\
    \ (and (not (null? txt))\n            (char-alphabetic? (string-ref txt (- (string-length\
    \ txt) 1))))\n       (not (or (space? (string-ref txt (- (string-length txt) 2)))\n\
    \                (space? (string-ref txt (- (string-length txt) 1)))))))\n", " \
    \ (if (empty? txt)\n      #f\n      (if (letter? (last-char txt))\n          (if\
    \ (or (letter? (last-char (butlast txt)))\n                  (char=? (last-char\
    \ (butlast txt)) #\\ ))\n              #f\n              #t)\n          #f)))\n",
  "  (if (empty? txt)\n      #f\n      (if (is-alphabetic-char (last-char txt))\n\
    \          (if (char=? (last-char txt) #\\space)\n              #f\n         \
    \     #t)\n          #f)))\n", "  (cond ((empty? txt) #f)\n        ((alphabetic?\
    \ (last-char txt))\n         (or (empty? (rest txt))\n             (space? (second-last-char\
    \ txt))))\n        (else #f)))\n", "  (regexp-match #rx\"([a-zA-Z][^a-zA-Z]*)$\"\
    \ txt))\n", "  (define (is_letter? x)\n    (char-alphabetic? x))\n  (define (is_a_word?\
    \ x)\n    (string-contains x #\\space))\n  (define (last-char x)\n    (string-ref\
    \ x (- (string-length x) 1)))\n  (cond ((string=? txt \"\") #f)\n        ((is_letter?\
    \ (last-char txt))\n         (and (is_letter? (last-char txt))\n             \
    \ (not (is_a_word? txt))))\n        (else #f)))\n", "  (if (empty? txt)\n    \
    \  #f\n      (if (string-contains? txt \" \")\n          (check_if_last_char_is_a_letter\
    \ (string-drop-right txt 1))\n          (char-alphabetic? (string-ref txt (sub1\
    \ (string-length txt)))))))\n", "  (cond\n    [(empty? txt) #f]\n    [(char-alphabetic?\
    \ (last-char txt))\n     (not (char-alphabetic? (second-last-char txt)))]\n  \
    \  [else #f]))", "  (cond\n    [(string=? \"\" txt) #f]\n    [(and (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n          (string-whitespace? (string-ref\
    \ txt (- (string-length txt) 2)))) #t]\n    [else #f]))\n", "  (cond\n    [(empty?\
    \ txt) (error \"Invalid input\")]\n    [(and (char-alphabetic? (last-char txt))\n\
    \          (char-whitespace? (string-ref txt (- (string-length txt) 2)))) #t]\n\
    \    [else #f]))\n", "  (cond\n    [(not (string? txt)) #f]\n    [(empty? txt)\
    \ #f]\n    [(char-alphabetic? (last-char txt))\n     (and (not (char-alphabetic?\
    \ (last-char (substring txt 0 (- (string-length txt) 1)))))\n          (not (char-whitespace?\
    \ (last-char (substring txt 0 (- (string-length txt) 1))))))]\n    [else #f]))\n",
  "  (let ([txt (string-trim txt)])\n    (if (string-empty? txt)\n        #f\n   \
    \     (let ([last-char (string-last-index txt)])\n          (let ([last-char-is-alpha\
    \ (string-alphabetic? (string-ref txt last-char))])\n            (let ([char-before-last\
    \ (string-ref txt (- last-char 1))])\n              (and last-char-is-alpha (not\
    \ (string-alphabetic? char-before-last)))))))))\n```\n\n[Let expression](https://docs.racket-lang.org/reference/let.html)\
    \ was used to simplify the code.\nLet expression is a way to define local variables.\n\
    \n>  A `let` expression binds a set of variables and then evaluates an expression\
    \ whose evaluation depends on the variables\u2019 values.\n\nIn the code above,\
    \ all variables defined are local to the function.\nLet expression is also used\
    \ to define intermediate variables.\n\n### Exercise 6\n\n```racket\n#lang racket\n",
  "  (define (afterSpace? chr)\n    (and (char-alphabetic? chr) (not (char-whitespace?\
    \ chr))))\n  (and (not (string-null? txt)) (afterSpace? (string-ref txt (- (string-length\
    \ txt) 1)))))\n</code>\nI think that it can be improved. Any suggestions?\nNote\
    \ that this is not the solution to my assignment. I figured out the solution,\
    \ now I'd like to see the differences with my code.\n\n\nA:\n\nI would use <code>string-split</code>\
    \ for this:\n<code>(define (check-if-last-char-is-a-letter txt)\n  (let ((last-word\
    \ (last (string-split txt #\\space))))\n    (or (= 1 (string-length last-word))\n\
    \        (char-whitespace? (string-ref last-word 0)))))\n</code>\nIt's a lot simpler,\
    \ I think.\n", "  (define words (string-split txt))\n  (define last-word (last\
    \ words))\n  (define last-char (substring last-word (- (string-length last-word)\
    \ 1) (string-length last-word)))\n  (if (and (char-alphabetic? (string->char last-char))\n\
    \           (not (string-contains txt last-char)))\n      #t\n      #f))\n", " \
    \ (if (empty? txt)\n      #f\n      (or\n       (char-alphabetic? (last-char txt))\n\
    \       (check_if_last_char_is_a_letter (substring txt 0 (- (string-length txt)\
    \ 1))))))\n", "  (if (null? txt)\n      #f\n      (if (and (char-alphabetic? (string-ref\
    \ txt (sub1 (string-length txt))))\n               (or (null? (string-ref txt\
    \ (sub1 (string-length txt))))\n                   (not (char-alphabetic? (string-ref\
    \ txt (sub1 (string-length txt)))))))\n          #t\n          #f)))\n", "  (if\
    \ (string=? txt \"\")\n      #f\n      (if (and (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1)))\n               (not (string-contains txt \"\
    \ \")))\n          #t\n          #f)))\n", "  (define (is_letter? ch)\n    (or\
    \ (char-alphabetic? ch) (char-numeric? ch)))\n  (cond [(empty? txt) false]\n \
    \       [(empty? (rest txt)) false]\n        [(is_letter? (last txt)) false]\n\
    \        [else true]))\n", "  (if (string=? txt \"\") #f\n      (if (string-ref\
    \ txt (sub1 (string-length txt)))\n          (if (char-alphabetic? (string-ref\
    \ txt (sub1 (string-length txt))))\n              (if (string-ref txt (sub1 (string-length\
    \ txt)))\n                  (or (string-ref txt (sub1 (string-length txt)))\n\
    \                      #f)\n                  #f))\n          #f)))\n", "  (if\
    \ (string=? \"\" txt)\n      #f\n      (if (alphabetic? (string-ref txt (- (string-length\
    \ txt) 1)))\n          (if (or (alphabetic? (string-ref txt (- (string-length\
    \ txt) 2)))\n                  (space? (string-ref txt (- (string-length txt)\
    \ 2))))\n              #f\n              #t)\n          #f)))\n</code>\nRunning\
    \ this as a script produces\n<code>/home/abhi/racket/racket-5.1.1/bin/racket\n\
    Welcome to Racket v5.1.1.\n&gt; (check_if_last_char_is_a_letter \"apple pie\"\
    )\n#f\n&gt; (check_if_last_char_is_a_letter \"apple pi e\")\n#t\n&gt; (check_if_last_char_is_a_letter\
    \ \"apple pi e \")\n#f\n&gt; (check_if_last_char_is_a_letter \"\")\n#f\n&gt; ^C\n\
    \n&gt;&gt;&gt; Process /home/abhi/racket/racket-5.1.1/bin/racket finished\n</code>\n",
  "  (cond\n    [(empty? txt) #f]\n    [(char-alphabetic? (last-char txt))\n     (and\n\
    \       (char-alphabetic? (last-char txt))\n       (not (any? char-alphabetic?\
    \ (string-&gt;list txt))))]\n    [else #f]))\n", "  (and (not (empty? txt))\n\
    \       (and (char-alphabetic? (last-char txt))\n            (not (member (last-char\
    \ txt) (regexp-match* #rx\"\\w\" txt))))))\n", "  (if (null? txt)\n      #f\n\
    \      (if (last-char-in-word? txt)\n          #f\n          (if (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n              #t\n            \
    \  #f))))\n", "  (let ([last-char (string-ref txt (sub1 (string-length txt)))])\n\
    \    (and\n     (char-alphabetic? last-char)\n     (or (not (char-alphabetic?\
    \ (string-ref txt (sub1 (sub1 (string-length txt))))))\n         (not (string-contains\
    \ txt \" \"))))))\n```\n\n# Exercise 1B:\n```racket\n#lang racket\n", "  (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1))))\n</code>\ni have tried to load\
    \ this code with raco exe\n<code>raco exe C:\\Users\\admin\\Desktop\\3.rkt\n</code>\n\
    And I got this error:\n<code>raco exe: #f: bad syntax in: #f\n</code>\nI tried\
    \ to make it work on DrRacket but after running the program I got this error:\n\
    <code>read-syntax: expects a string for the second argument, got: #f\n  context...:\n\
    \   /C:/Program Files/Racket/collects/drracket/private/drracket-contract.rkt:124:3\n\
    \   /C:/Program Files/Racket/collects/drracket/private/drracket-contract.rkt:313:0:\
    \ string-&gt;input-port\n   /C:/Program Files/Racket/collects/drracket/private/drracket-contract.rkt:313:0:\
    \ read-syntax\n   /C:/Program Files/Racket/collects/drracket/private/drracket-contract.rkt:313:0:\
    \ read-syntax/read-syntax/read-syntax\n   /C:/Program Files/Racket/collects/drracket/private/drracket-contract.rkt:313:0:\
    \ read-syntax/read-syntax\n   /C:/Program Files/Racket/collects/drracket/private/drracket-contract.rkt:313:0:\
    \ read-syntax\n   /C:/Program Files/Racket/collects/drracket/private/contracts.rkt:220:0:\
    \ read-syntax\n   /C:/Program Files/Racket/collects/drracket/private/contracts.rkt:231:0:\
    \ contract-eval/eval-module-body\n   /C:/Program Files/Racket/collects/drracket/private/contracts.rkt:231:0:\
    \ contract-eval\n   /C:/Program Files/Racket/collects/drracket/private/contracts.rkt:230:0",
  "  (cond\n    [(string=? txt \"\") #f]\n    [(char-alphabetic? (string-ref txt (-\
    \ (string-length txt) 1)))\n     (and (not (memq (string-ref txt (- (string-length\
    \ txt) 2))\n                            '(#\\  #\\)))\n          (not (memq (string-ref\
    \ txt (- (string-length txt) 3))\n                            '(#\\  #\\))))]\n\
    \    [else #f]))\n", "  (let ([last-char (string-ref txt (sub1 (string-length\
    \ txt)))])\n    (and (char-alphabetic? last-char)\n         (char-space? (string-ref\
    \ txt (sub1 (string-length txt)))))))\n", "  (not (empty? (regexp-match #rx\"\\\
    w$\" txt))))\n</code>\n", "  (and (not (empty? txt))\n       (not (char-whitespace?\
    \ (last-char txt)))\n       (char-alphabetic? (last-char txt))\n       (let ([words\
    \ (string-tokenize txt #\\space)])\n         (not (member (last words) (string-tokenize\
    \ (rest-string txt) #\\space))))))\n```\n\n```racket", "  (let* ([last_char (string-ref\
    \ txt (- (string-length txt) 1))]\n         [is_letter? (char-alphabetic? last_char)])\n\
    \    (and is_letter?\n         (not (string-contains txt last_char)))))\n", " \
    \ (not (equal?\n         (string-length txt)\n         (string-length (string-trim\
    \ txt)))))\n", "  (let ((last-char (last-char txt)))\n    (cond\n      [(&gt;\
    \ (string-length txt) 0)\n       (cond\n         [(char-alphabetic? last-char)\n\
    \          (cond\n            [(last-char-has-space-before? txt)\n           \
    \  #t]\n            [else\n             #f])]\n         [else\n          #f])]\n\
    \      [else\n       #f])))\n", "  (cond\n    [(empty? txt) #f]\n    [(empty?\
    \ (rest txt)) (char-alphabetic? (first txt))]\n    [(char-alphabetic? (first txt))\
    \ (check_if_last_char_is_a_letter (rest txt))]\n    [else #f]))\n", "  (if (string=?\
    \ txt \"\")\n      #f\n      (if (or (string=? (substring txt (- (string-length\
    \ txt) 1) (string-length txt)) \" \")\n              (string=? (substring txt\
    \ (- (string-length txt) 1) (string-length txt)) \"\\t\"))\n          (check_if_last_char_is_a_letter\
    \ (substring txt 0 (- (string-length txt) 1)))\n          (and (and (>= (char->integer\
    \ (string-ref txt (- (string-length txt) 1))) (char->integer #\\a))\n        \
    \            (<= (char->integer (string-ref txt (- (string-length txt) 1))) (char->integer\
    \ #\\z)))\n               (check_if_last_char_is_a_letter (substring txt 0 (-\
    \ (string-length txt) 1)))))))\n", "  (cond\n    [(equal? txt \"\") #f]\n    [(and\
    \ (char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n          (not\
    \ (word? (string-ref txt (- (string-length txt) 1)) txt))) #t]\n    [else #f]))\n",
  "  (define (lastc txt)\n    (cond [(empty? txt) \"\"]\n          [else (lastc (rest\
    \ txt))]))\n  (define (is_letter? c)\n    (and (char-alphabetic? c) (not (char-whitespace?\
    \ c))))\n  (is_letter? (lastc txt)))\n```\n\n## Question 4\n```#lang racket\n",
  "  (cond [(zero? (string-length txt)) #f]\n        [(char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1)))\n         (not (char-whitespace? (string-ref\
    \ txt (- (string-length txt) 2))))]\n        [else #f]))", "  (let* ([txt (string-trim\
    \ txt)]\n         [len (string-length txt)])\n    (and (> len 0)\n         (char-alphabetic?\
    \ (string-ref txt (- len 1)))\n         (and (< len 2)\n              (not (char-alphabetic?\
    \ (string-ref txt 0)))))))\n", "  (and (not (equal? (last txt) 'space))\n    \
    \   (not (equal? (last txt) 'newline))\n       (not (equal? (last txt) 'tab))\n\
    \       (not (equal? (last txt) \"\"))\n       (not (equal? (last txt) 'eof))\n\
    \       (not (equal? (last txt) 'ellipsis))\n       (not (equal? (last txt) 'paragraph-separator))\n\
    \       (not (equal? (last txt) 'line-feed))\n       (not (equal? (last txt) 'carriage-return))\n\
    \       (not (equal? (last txt) 'page-separator))\n       (not (equal? (last txt)\
    \ 'space))\n       (char-alphabetic? (string-ref txt (- (string-length txt) 1)))))\n",
  "  (and (and (not (empty? txt))\n            (char-alphabetic? (last-char txt)))\n\
    \       (or (empty? (rest txt))\n           (or (space? (last-char (rest txt)))\n\
    \               (not (space? (last-char (rest txt))))))))\n", "  (if (&gt; (string-length\
    \ txt) 0)\n      (and (char-alphabetic? (string-ref txt (- (string-length txt)\
    \ 1)))\n           (not (char-whitespace? (string-ref txt (- (string-length txt)\
    \ 1)))))\n      #f))\n</code>\nYour solution is recursive, which is good, but\
    \ you can use <code>char-alphabetic?</code> to check if the last character is\
    \ a letter. Also, it's not clear to me what you're trying to do with <code>string-upper-case?</code>\
    \ since you're passing the lowercase <code>'z'</code> to it.\n", "  (define (is_word?\
    \ txt)\n    (local [(define (is_word? cntr)\n              (cond [(>= cntr (string-length\
    \ txt)) #f]\n                    [(char-alphabetic? (string-ref txt cntr)) #t]\n\
    \                    [else (is_word? (+ cntr 1))]))]\n      (is_word? 0)))\n \
    \ (and\n   (string? txt)\n   (is_word? txt)\n   (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1)))))\n```\n\n### Problem 2.\n\n```#lang racket\n",
  "  (let* ([str (string-&gt;list txt)]\n         [last (last str)])\n    (and last\n\
    \         (char-alphabetic? last)\n         (not (char-whitespace? last)))))\n\
    </code>\n", "  ; Your code goes here\n  )", "  (cond [(empty? txt) #f]\n     \
    \   [(or (equal? (substring txt -1) \" \")\n             (equal? (substring txt\
    \ -1) \".\")) #f]\n        [else (char-alphabetic? (substring txt -1))]))\n",
  "  (define (last-char txt)\n    (string-ref txt (- (string-length txt) 1)))\n  (define\
    \ (is-letter? ch)\n    (char-alphabetic? ch))\n  (define (is-last-char-letter?\
    \ txt)\n    (is-letter? (last-char txt)))\n  (define (is-a-word? txt)\n    (string-contains\
    \ txt #\\space))\n  (define (is-last-char-not-a-word? txt)\n    (and (not (is-a-word?\
    \ txt))\n         (is-last-char-letter? txt)))\n  (is-last-char-not-a-word? txt))\n\
    ```\n\n```racket\n#lang racket\n", "  (if (empty? txt) #f\n      (if (is-letter\
    \ (last-char txt))\n          (check_if_last_char_is_a_letter (rest-string txt))\n\
    \          (if (not (is-letter (first-char txt)))\n              (check_if_last_char_is_a_letter\
    \ (rest-string txt))\n              #f))))\n", "  (and (not (empty? txt))\n  \
    \     (and (char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n   \
    \         (not (char-alphabetic? (string-ref txt (- (string-length txt) 2)))))))\n",
  "  (if (string=? txt \"\")\n      #f\n      (if (string-ci=? (substring txt -1)\
    \ \" \")\n          #f\n          (string-any-char-set-contains (char-set-complement\n\
    \                                         (char-set 'alpha))\n               \
    \                         (substring txt -1)))))\n", "  (cond\n    [(and (not\
    \ (string=? (string-ref txt (sub1 (string-length txt))) \" \"))\n          (char-alphabetic?\
    \ (string-ref txt (sub1 (string-length txt)))))\n     #t]\n    [else #f]))\n</code>\n\
    I tried to do it without using <code>string-length</code> or <code>string-ref</code>,\
    \ but the only thing I could come up with was using <code>string-&gt;list</code>,\
    \ which didn't feel appropriate for this problem. I had to use <code>string-length</code>\
    \ in order to know the index of the last character.\nI saw this example in a book\
    \ on Clojure, and I felt like trying to solve it in Scheme.\n\n\nA:\n\nThis is\
    \ one possible solution:\n<code>(define (check-if-last-char-is-a-letter str)\n\
    \  (and\n   (not (string-empty? str))\n   (or\n    (char-alphabetic? (string-ref\
    \ str (sub1 (string-length str))))\n    (not (char-whitespace? (string-ref str\
    \ (sub1 (string-length str))))))))\n</code>\n", "  (cond\n    [(empty? txt) false]\n\
    \    [(char-alphabetic? (first (last txt)))\n     (if (char-whitespace? (first\
    \ (last txt))) false true)]\n    [else false]))\n", "  (if (string=? txt \"\"\
    ) #f\n      (if (string-contains? txt \" \")\n          (check_if_last_char_is_a_letter\
    \ (string-drop-right txt 1))\n          (if (char-alphabetic? (string-ref txt\
    \ (sub1 (string-length txt)))) #t #f))))\n", "  (cond\n    [(empty? txt) #f]\n\
    \    [(word? (last-char txt)) #f]\n    [else (alpha? (last-char txt))]))", " \
    \ (let ([char-list (string->list txt)])\n    (cond \n      [(empty? char-list)\
    \ #f]\n      [(and (char-alphabetic? (last char-list))\n            (not (char-alphabetic?\
    \ (second-to-last char-list)))) #t]\n      [else #f])))", "  (let* ([words (string-split\
    \ txt \" \")]\n         [len (length words)]\n         [last (substring (list-ref\
    \ words (- len 1)) (- (string-length (list-ref words (- len 1))) 1) (string-length\
    \ (list-ref words (- len 1))))])\n    (regexp-match #rx\"[a-zA-Z]\" last)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
