name: HumanEval_105_by_length
language: rkt
prompt: "#lang racket\n\n;; Given a list of integers, sort the integers that are between\
  \ 1 and 9 inclusive,\n;; reverse the resulting list, and then replace each digit\
  \ by its corresponding name from\n;; \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
  , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n;; For example:\n;; >>> (by_length (list\
  \ 2 1 1 4 5 8 2 3))\n;; (list \"Eight\" \"Five\" \"Four\" \"Three\" \"Two\" \"Two\"\
  \ \"One\" \"One\")\n;; If the list is empty, return an empty list:\n;; >>> (by_length\
  \ (list ))\n;; (list )\n;; If the list has any strange number ignore it:\n;; >>>\
  \ (by_length (list 1 -1 55))\n;; (list \"One\")\n(define (by_length arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate by_length))\n\
  \    (check-equal? (candidate (list 2 1 1 4 5 8 2 3)) (list \"Eight\" \"Five\" \"\
  Four\" \"Three\" \"Two\" \"Two\" \"One\" \"One\"))\n    (check-equal? (candidate\
  \ (list )) (list ))\n    (check-equal? (candidate (list 1 -1 55)) (list \"One\"\
  ))\n    (check-equal? (candidate (list 1 -1 3 2)) (list \"Three\" \"Two\" \"One\"\
  ))\n    (check-equal? (candidate (list 9 4 8)) (list \"Nine\" \"Eight\" \"Four\"\
  ))\n))\n\n(test-humaneval)"
completions: ["  (let ([revarr (reverse (filter (lambda (x) (and (<= 1 x) (<= x 9)))\
    \ (sort arr <)))])\n    (if (empty? revarr)\n        '()\n        (map (lambda\
    \ (x) (string-append (number->string x) \" \")) revarr))))\n", "  (cond ((empty?\
    \ arr) empty)\n        ((positive? (first arr))\n         (let* ((sorted-arr (sort\
    \ arr <))\n                (reversed-arr (reverse sorted-arr))\n             \
    \   (digits-arr (filter-map number->string reversed-arr))\n                (digits-names\
    \ (map string->number-name digits-arr)))\n           digits-names))\n        (else\
    \ (by_length (rest arr)))))\n", "  (cond\n    [(empty? arr) (list)]\n    [(or\
    \ (< (first arr) 1) (> (first arr) 9)) (by_length (rest arr))]\n    [else (append\
    \ (list (number->string (first arr))) (by_length (rest arr)))]))\n```\n\n5.\n\n\
    ```#lang racket\n", "  (define (solve arr)\n    (cond [(empty? arr) empty]\n \
    \         [(and (<= 1 (first arr)) (<= (first arr) 9))\n           (cons (first\
    \ arr) (solve (rest arr)))]\n          [else (solve (rest arr))]))\n  (define\
    \ (to-name number)\n    (cond [(= number 1) \"One\"]\n          [(= number 2)\
    \ \"Two\"]\n          [(= number 3) \"Three\"]\n          [(= number 4) \"Four\"\
    ]\n          [(= number 5) \"Five\"]\n          [(= number 6) \"Six\"]\n     \
    \     [(= number 7) \"Seven\"]\n          [(= number 8) \"Eight\"]\n         \
    \ [(= number 9) \"Nine\"]))\n  (map to-name (reverse (solve arr))))", "  (define\
    \ (helper arr1)\n    (cond [(empty? arr1) empty]\n          [(> (first arr1) 0)\
    \ (cons (first arr1) (helper (rest arr1)))]\n          [else (helper (rest arr1))]))\n\
    \  (define (sorter lst)\n    (cond [(empty? lst) empty]\n          [(< (first\
    \ lst) (first (rest lst)))\n           (cons (first lst) (sorter (rest lst)))]\n\
    \          [else (cons (first (rest lst)) (sorter (cons (first lst) (rest (rest\
    \ lst)))))]))\n  (define (to-string number)\n    (cond [(= number 1) \"One\"]\n\
    \          [(= number 2) \"Two\"]\n          [(= number 3) \"Three\"]\n      \
    \    [(= number 4) \"Four\"]\n          [(= number 5) \"Five\"]\n          [(=\
    \ number 6) \"Six\"]\n          [(= number 7) \"Seven\"]\n          [(= number\
    \ 8) \"Eight\"]\n          [(= number 9) \"Nine\"]))\n  (cond [(empty? arr) empty]\n\
    \        [else (define x (sorter (helper arr)))\n              (cond [(empty?\
    \ x) empty]\n                    [else (cons (to-string (first x)) (by_length\
    \ (rest x)))])]))", "  (for/list ([i (sort (list-ref arr 0) < #:key (lambda (x)\
    \ (if (and (<= 1 x) (<= x 9)) x 0)))])\n    (cond [(= i 1) \"One\"]\n        \
    \  [(= i 2) \"Two\"]\n          [(= i 3) \"Three\"]\n          [(= i 4) \"Four\"\
    ]\n          [(= i 5) \"Five\"]\n          [(= i 6) \"Six\"]\n          [(= i\
    \ 7) \"Seven\"]\n          [(= i 8) \"Eight\"]\n          [(= i 9) \"Nine\"])))\n\
    ```\n\n```#lang racket", "  (apply append (for/list ([x (sort (filter (\u03BB\
    \ (x) (and (<= 1 x) (<= x 9))) arr))\n                                 #:descending?)])\n\
    \                  (list (cond\n                         [(= x 1) \"One\"]\n \
    \                        [(= x 2) \"Two\"]\n                         [(= x 3)\
    \ \"Three\"]\n                         [(= x 4) \"Four\"]\n                  \
    \       [(= x 5) \"Five\"]\n                         [(= x 6) \"Six\"]\n     \
    \                    [(= x 7) \"Seven\"]\n                         [(= x 8) \"\
    Eight\"]\n                         [(= x 9) \"Nine\"]\n                      \
    \   ))))\n", "  (cond ((null? arr) '())\n        ((not (is-a-number (car arr)))\
    \ (by_length (cdr arr)))\n        ((and (&lt;= (car arr) 9) (&gt;= (car arr) 1))\n\
    \         (define (is-in-list? elem lst)\n           (cond ((null? lst) #f)\n\
    \                 ((equal? elem (car lst)) #t)\n                 (else (is-in-list?\
    \ elem (cdr lst)))))\n         (define (insert-in-order num lst)\n           (cond\
    \ ((null? lst) (list num))\n                 ((&lt; num (car lst)) (cons num lst))\n\
    \                 (else (cons (car lst) (insert-in-order num (cdr lst))))))\n\
    \         (if (is-in-list? (car arr) (by_length (cdr arr)))\n             (by_length\
    \ (cdr arr))\n             (insert-in-order (car arr) (by_length (cdr arr)))))\n\
    \        (else (by_length (cdr arr)))))\n", "  (for/list ([num (in-list (quicksort\
    \ arr))]\n             #:when (in-range? 1 num 9))\n    (num->str num)))\n", " \
    \ (cond\n    [(empty? arr) '()]\n    [(empty? (remove (lambda (x) (< x 1)\n  \
    \                             (lambda (x) (> x 9)))\n                     arr))\
    \ '()]\n    [else (map string->number\n               (remove (lambda (x) (< x\
    \ 1)\n                                (lambda (x) (> x 9)))\n                \
    \       arr))]))\n", "    (map-values (lambda (x) (string-join x \" \")) (reverse\
    \ (map-values (lambda (x) (list-ref '(\"One\" \"Two\" \"Three\" \"Four\" \"Five\"\
    \ \"Six\" \"Seven\" \"Eight\" \"Nine\") (- x 1))) (filter (lambda (x) (and (>=\
    \ x 1) (<= x 9))) arr)))))\n", "  (cond\n    [(empty? arr) arr]\n    [(member\
    \ (first arr) '(1 2 3 4 5 6 7 8 9))\n     (append (by_length (rest arr)) (list\
    \ (first arr)))]\n    [else (by_length (rest arr))]))\n", "  (define (sort arr)\n\
    \    (cond ((null? arr) (list))\n          ((empty? (cdr arr)) (list (car arr)))\n\
    \          (else (filter (lambda (x) (>= x (car arr))) (cdr arr)))))\n  (reverse\
    \ (map (lambda (x) (number->string x 'upcase)) (sort arr))))\n", "  (cond [(empty?\
    \ arr) (list)]\n        [(member (first arr) (list 1 2 3 4 5 6 7 8 9))\n     \
    \    (define (first-9-elements lst)\n           (cond [(empty? lst) empty]\n \
    \                [(member (first lst) (list 1 2 3 4 5 6 7 8 9))\n            \
    \      (cons (first lst) (first-9-elements (rest lst)))]\n                 [else\
    \ (first-9-elements (rest lst))]))\n         (define (without-9-elements lst)\n\
    \           (cond [(empty? lst) empty]\n                 [(member (first lst)\
    \ (list 1 2 3 4 5 6 7 8 9))\n                  (without-9-elements (rest lst))]\n\
    \                 [else (cons (first lst) (without-9-elements (rest lst)))]))\n\
    \         (define (to-names lst)\n           (cond [(empty? lst) empty]\n    \
    \             [else (cons (list-ref (list \"One\" \"Two\" \"Three\" \"Four\" \"\
    Five\" \"Six\" \"Seven\" \"Eight\" \"Nine\") (- (first lst) 1))\n            \
    \                 (to-names (rest lst)))]))\n         (define (reverse lst)\n\
    \           (cond [(empty? lst) empty]\n                 [else (append (reverse\
    \ (rest lst)) (list (first lst)))]))\n         (reverse (to-names (merge (sort\
    \ (first-9-elements arr) <) (sort (first-9-elements arr) >))\n               \
    \            (to-names (without-9-elements arr)))))\n        [else (cons (first\
    \ arr) (by_length (rest arr)))]))\n", "  (define (check x) (and (>= x 1) (<= x\
    \ 9)))\n  (define (convert x)\n    (cond\n      [(= x 1) \"One\"]\n      [(= x\
    \ 2) \"Two\"]\n      [(= x 3) \"Three\"]\n      [(= x 4) \"Four\"]\n      [(=\
    \ x 5) \"Five\"]\n      [(= x 6) \"Six\"]\n      [(= x 7) \"Seven\"]\n      [(=\
    \ x 8) \"Eight\"]\n      [(= x 9) \"Nine\"]))\n  (map convert (reverse (sort (filter\
    \ check arr) <))))\n", "  (local [(define (translate x)\n            (cond\n \
    \             [(= x 1) \"One\"]\n              [(= x 2) \"Two\"]\n           \
    \   [(= x 3) \"Three\"]\n              [(= x 4) \"Four\"]\n              [(= x\
    \ 5) \"Five\"]\n              [(= x 6) \"Six\"]\n              [(= x 7) \"Seven\"\
    ]\n              [(= x 8) \"Eight\"]\n              [(= x 9) \"Nine\"]))]\n  \
    \  (map translate (reverse (sort (filter\n                                   \
    \  (lambda (x)\n                                       (and (<= 1 x) (<= x 9)))\n\
    \                                     arr)\n                                 \
    \ #:key\n                                  (lambda (x) x)))))\n", "  (cond [(null?\
    \ arr) '()]\n        [(and (<= 1 (car arr)) (<= (car arr) 9))\n         (append\
    \ (list (number->string (car arr))) (by_length (cdr arr)))]\n        [else (by_length\
    \ (cdr arr))]))\n", "  (define (digit-to-string x)\n    (cond\n      [(= x 1)\
    \ \"One\"]\n      [(= x 2) \"Two\"]\n      [(= x 3) \"Three\"]\n      [(= x 4)\
    \ \"Four\"]\n      [(= x 5) \"Five\"]\n      [(= x 6) \"Six\"]\n      [(= x 7)\
    \ \"Seven\"]\n      [(= x 8) \"Eight\"]\n      [(= x 9) \"Nine\"]\n      [else\
    \ \"\"]))\n  (if (empty? arr)\n      '()\n      (reverse (map digit-to-string\
    \ (sort (filter (lambda (x) (and (>= x 1) (<= x 9))) arr))))))\n", "  (cond\n\
    \    [(null? arr) empty]\n    [(not (integer? (car arr))) (by_length (cdr arr))]\n\
    \    [(> (car arr) 9) (by_length (cdr arr))]\n    [(< (car arr) 1) (by_length\
    \ (cdr arr))]\n    [else (append (by_length (cdr arr)) (list (translate (car arr))))]))\n",
  "  (define (transform l)\n    (cond ((= l 1) \"One\")\n          ((= l 2) \"Two\"\
    )\n          ((= l 3) \"Three\")\n          ((= l 4) \"Four\")\n          ((=\
    \ l 5) \"Five\")\n          ((= l 6) \"Six\")\n          ((= l 7) \"Seven\")\n\
    \          ((= l 8) \"Eight\")\n          ((= l 9) \"Nine\")))\n  (define (filter\
    \ arr)\n    (cond ((not (list? arr)) empty)\n          ((and (>= (car arr) 1)\
    \ (<= (car arr) 9)) (cons (car arr) (filter (cdr arr))))\n          (else (filter\
    \ (cdr arr)))))\n  (define (reverse arr)\n    (define (iter arr acc)\n      (cond\
    \ ((not (list? arr)) acc)\n            (else (iter (cdr arr) (cons (car arr) acc)))))\n\
    \    (iter arr empty))\n  (map transform (reverse (filter arr))))\n```\n\n###\
    \ Exercises\n\n#### 1.\n* Write a program that given an array of integers, returns\
    \ the reverse of the array. You can assume that the array has at least one element.\n\
    * Write a program that given an array of integers, prints the elements of the\
    \ array in ascending order.\n* Write a program that given an array of integers,\
    \ prints the elements of the array in descending order.\n* Write a program that\
    \ given two arrays of integers, prints all the elements in the intersection of\
    \ the two arrays.\n* Write a program that given two arrays of integers, prints\
    \ all the elements in the union of the two arrays.\n* Write a program that given\
    \ two arrays of integers, prints all the elements in the first array that are\
    \ not in the second array.\n* Write a program that given two arrays of integers,\
    \ prints all the elements in the second array that are not in the first array.\n\
    * Write a program that given an array of integers and an integer, prints all the\
    \ elements in the array that are greater than the given integer.\n* Write a program\
    \ that given an array of integers and an integer, prints all the elements in the\
    \ array that are less than the given integer.\n* Write a program that given an\
    \ array of integers and an integer, prints all the elements in the array that\
    \ are", "  (if (empty? arr) (list)\n      (let ([sorted (filter (lambda (x) (and\
    \ (>= x 1) (<= x 9))) (sort arr <))])\n        (map (lambda (x) (list-ref '(\"\
    One\" \"Two\" \"Three\" \"Four\" \"Five\" \"Six\" \"Seven\" \"Eight\" \"Nine\"\
    ) (- x 1))) (reverse sorted)))))\n", "  (cond [(empty? arr) empty]\n        [(not\
    \ (member (first arr) (list 1 2 3 4 5 6 7 8 9)))\n         (by_length (rest arr))]\n\
    \        [else (append (by_length (rest arr)) (list (first arr)))]))\n", "  (map\n\
    \   (lambda (n)\n     (cond\n       [(= n 1) \"One\"]\n       [(= n 2) \"Two\"\
    ]\n       [(= n 3) \"Three\"]\n       [(= n 4) \"Four\"]\n       [(= n 5) \"Five\"\
    ]\n       [(= n 6) \"Six\"]\n       [(= n 7) \"Seven\"]\n       [(= n 8) \"Eight\"\
    ]\n       [(= n 9) \"Nine\"]))\n   (reverse (sort (filter (lambda (n)\n      \
    \                      (and (>= n 1) (<= n 9)))\n                          arr)))))\n",
  "  (filter (lambda (n) (and (&lt;= n 9) (&gt;= n 1))) arr))\n", "  (cond [(empty?\
    \ arr) empty]\n        [(and (<= 1 (first arr)) (<= (first arr) 9))\n        \
    \ (cons (list->string (list->symbol (symbol->string (number->string (first arr)))))\n\
    \               (by_length (rest arr)))]\n        [else (by_length (rest arr))]))",
  "  (cond\n    [(= (length arr) 0) (list)]\n    [else\n     (let* ([aa (filter (lambda\
    \ (x) (and (<= x 9) (>= x 1))) arr)]\n            [bb (reverse aa)]\n        \
    \    [cc (map (lambda (x) (list-ref '(\"One\" \"Two\" \"Three\" \"Four\" \"Five\"\
    \ \"Six\" \"Seven\" \"Eight\" \"Nine\") (- x 1))) bb)])\n       cc)]))\n", " \
    \ (reverse (map number->string (sort arr (lambda (x y) (< x y))))))\n", "  (cond\n\
    \    [(empty? arr) empty]\n    [(< 1 (first arr) 9)\n     (cons (number->string\
    \ (first arr)) (by_length (rest arr)))]\n    [else (by_length (rest arr))]))\n",
  "  (for/list ([i (in-range 1 9)])\n    (define (word-for-digit num)\n      (cond\
    \ [(= num 1) \"One\"]\n            [(= num 2) \"Two\"]\n            [(= num 3)\
    \ \"Three\"]\n            [(= num 4) \"Four\"]\n            [(= num 5) \"Five\"\
    ]\n            [(= num 6) \"Six\"]\n            [(= num 7) \"Seven\"]\n      \
    \      [(= num 8) \"Eight\"]\n            [(= num 9) \"Nine\"]))\n    (word-for-digit\
    \ i)))", "  (cond [(empty? arr) (list)]\n        [(empty? (filter (\u03BB (x)\
    \ (or (< x 1) (> x 9))) arr))\n         (reverse (map (\u03BB (x) (cond\n    \
    \                           [(= x 1) \"One\"]\n                              \
    \ [(= x 2) \"Two\"]\n                               [(= x 3) \"Three\"]\n    \
    \                           [(= x 4) \"Four\"]\n                             \
    \  [(= x 5) \"Five\"]\n                               [(= x 6) \"Six\"]\n    \
    \                           [(= x 7) \"Seven\"]\n                            \
    \   [(= x 8) \"Eight\"]\n                               [(= x 9) \"Nine\"]))\n\
    \                         (sort arr (\u03BB (x y) (< x y)))))]\n        [else\n\
    \         (reverse (map (\u03BB (x) (cond\n                               [(=\
    \ x 1) \"One\"]\n                               [(= x 2) \"Two\"]\n          \
    \                     [(= x 3) \"Three\"]\n                               [(=\
    \ x 4) \"Four\"]\n                               [(= x 5) \"Five\"]\n        \
    \                       [(= x 6) \"Six\"]\n                               [(=\
    \ x 7) \"Seven\"]\n                               [(= x 8) \"Eight\"]\n      \
    \                         [(= x 9) \"Nine\"]))\n                         (sort\
    \ (filter (\u03BB (x) (or (< x 1) (> x 9))) arr) (\u03BB (x y) (< x y)))))])\n\
    \  )\n", "  (for/list ((i (in-list (sort (filter (lambda (x) (and (<= 1 x) (<=\
    \ x 9))) arr) &lt;)))\n             (s (match i\n                     [1 \"One\"\
    ]\n                     [2 \"Two\"]\n                     [3 \"Three\"]\n    \
    \                 [4 \"Four\"]\n                     [5 \"Five\"]\n          \
    \           [6 \"Six\"]\n                     [7 \"Seven\"]\n                \
    \     [8 \"Eight\"]\n                     [9 \"Nine\"])))\n    s))\n</code>\n\
    Try it online!\n", "  (cond [(empty? arr) '()]\n        [(and (<= 1 (first arr))\
    \ (>= 9 (first arr)))\n         (cons (number->string (first arr)) (by_length\
    \ (rest arr)))]\n        [else (by_length (rest arr))]))\n", "  (letrec ([sort-and-rev\
    \ (lambda (lst)\n                           (define (sort-and-rev-helper lst acc)\n\
    \                             (cond [(empty? lst) acc]\n                     \
    \              [(cons? (car lst)) (sort-and-rev-helper (cdr lst) (cons (car lst)\
    \ acc))]\n                                   [(and (<= 1 (car lst)) (<= (car lst)\
    \ 9)) (sort-and-rev-helper (cdr lst) (cons (car lst) acc))]\n                \
    \                   [else (sort-and-rev-helper (cdr lst) acc)]))\n           \
    \                (sort-and-rev-helper lst '()))]\n         [replace-num-with-word\
    \ (lambda (lst)\n                                  (define (replace-num-with-word-helper\
    \ lst acc)\n                                    (cond [(empty? lst) acc]\n   \
    \                                       [(cons? (car lst)) (replace-num-with-word-helper\
    \ (cdr lst) (cons (car lst) acc))]\n                                         \
    \ [else (replace-num-with-word-helper (cdr lst) (cons (cond [(= 1 (car lst)) \"\
    One\"]\n                                                                     \
    \                           [(= 2 (car lst)) \"Two\"]\n                      \
    \                                                                          [(=\
    \ 3 (car lst)) \"Three\"]\n                                                  \
    \                                              [(= 4 (car lst)) \"Four\"]\n  \
    \                                                                            \
    \                  [(= 5 (car lst)) \"Five\"]\n                              \
    \                                                                  [(= 6 (car\
    \ lst)) \"Six\"]\n                                                           \
    \                                     [(= 7 (car lst)) \"Seven\"]\n          \
    \                                                                            \
    \          [(= 8 (car lst)) \"Eight\"]\n                                     \
    \                                                           [(= 9 (car lst)) \"\
    Nine\"]) acc)])]))\n                                  (replace-num-with-word-helper\
    \ lst '()))])\n    (replace-num-with-word (sort-and-rev arr))))\n", "  (define\
    \ dic '((\"One\" . 1) (\"Two\" . 2) (\"Three\" . 3) (\"Four\" . 4) (\"Five\" .\
    \ 5) (\"Six\" . 6) (\"Seven\" . 7) (\"Eight\" . 8) (\"Nine\" . 9)))\n  (apply\
    \ append (map (lambda (x) (list (string-ref (car (filter (lambda (c) (= (cdr c)\
    \ x)) dic))))) (reverse (filter (lambda (x) (and (>= x 1) (<= x 9))) arr)))))",
  "  (for/list ([x (in-list (sort (filter (lambda (x) (or (= x 1) (= x 2) (= x 3)\
    \ (= x 4) (= x 5) (= x 6) (= x 7) (= x 8) (= x 9))) arr) <))])\n    (cond [(=\
    \ x 1) \"One\"]\n          [(= x 2) \"Two\"]\n          [(= x 3) \"Three\"]\n\
    \          [(= x 4) \"Four\"]\n          [(= x 5) \"Five\"]\n          [(= x 6)\
    \ \"Six\"]\n          [(= x 7) \"Seven\"]\n          [(= x 8) \"Eight\"]\n   \
    \       [(= x 9) \"Nine\"])))\n", "  (cond [(empty? arr) empty]\n        [(< (first\
    \ arr) 1) (by_length (rest arr))]\n        [(> (first arr) 9) (by_length (rest\
    \ arr))]\n        [else (append (by_length (rest arr)) (list (numbers-to-strings\
    \ (first arr))))]))", "  (cond\n    [(empty? arr) (list)]\n    [(<= 1 (first arr)\
    \ 9)\n     (append (by_length (rest arr)) (list (number->string (first arr))))]\n\
    \    [else (by_length (rest arr))]))\n", "  (if (empty? arr)\n      (list)\n \
    \     (let ((convert-to-word\n             (lambda (x)\n               (if (=\
    \ x 1) \"One\"\n                   (if (= x 2) \"Two\"\n                     \
    \  (if (= x 3) \"Three\"\n                           (if (= x 4) \"Four\"\n  \
    \                             (if (= x 5) \"Five\"\n                         \
    \          (if (= x 6) \"Six\"\n                                       (if (=\
    \ x 7) \"Seven\"\n                                           (if (= x 8) \"Eight\"\
    \n                                               (if (= x 9) \"Nine\"\n      \
    \                                             #f)))))))))))\n            (from-1-to-9\
    \ (lambda (x)\n                           (and (>= x 1) (<= x 9)))))\n       \
    \ (map convert-to-word\n             (sort arr from-1-to-9)))))\n", "  (if (equal?\
    \ arr '())\n      '()\n      (sort arr #:key (\u03BB (i) (cond ((<= i 0) 0)\n\
    \                                   ((<= i 9) i)\n                           \
    \        (else 10))))))\n```\n\n``` #lang racket\n", "    (define (nonneg? n)\n\
    \        (if (< n 0)\n            #f\n            (if (> n 9)\n              \
    \  #f\n                #t)))\n    (define (reversed arr)\n        (define (reversed-helper\
    \ rev lst)\n            (if (null? lst)\n                rev\n               \
    \ (reversed-helper (cons (car lst) rev) (cdr lst))))\n        (reversed-helper\
    \ '() arr))\n    (define (num-to-string num)\n        (cond ((equal? num 1) \"\
    One\")\n            ((equal? num 2) \"Two\")\n            ((equal? num 3) \"Three\"\
    )\n            ((equal? num 4) \"Four\")\n            ((equal? num 5) \"Five\"\
    )\n            ((equal? num 6) \"Six\")\n            ((equal? num 7) \"Seven\"\
    )\n            ((equal? num 8) \"Eight\")\n            ((equal? num 9) \"Nine\"\
    )))\n    (define (result arr)\n        (define (result-helper lst)\n         \
    \   (if (null? lst)\n                '()\n                (cons (num-to-string\
    \ (car lst)) (result-helper (cdr lst)))))\n        (result-helper (reversed (remove-duplicates\
    \ (sort (filter nonneg? arr) <)))))\n    (result arr))", "  (define (sort-lt lhs\
    \ rhs) (< (length lhs) (length rhs)))\n  (define (convert-num num)\n    (cond\n\
    \      [(= num 1) \"One\"]\n      [(= num 2) \"Two\"]\n      [(= num 3) \"Three\"\
    ]\n      [(= num 4) \"Four\"]\n      [(= num 5) \"Five\"]\n      [(= num 6) \"\
    Six\"]\n      [(= num 7) \"Seven\"]\n      [(= num 8) \"Eight\"]\n      [(= num\
    \ 9) \"Nine\"]\n      [else \"\"]))\n  (define (filter-range arr)\n    (filter\
    \ (lambda (val) (and (>= val 1) (<= val 9))) arr))\n  (define (mapper arr)\n \
    \   (map convert-num arr))\n  (mapper (reverse (sort (filter-range arr) sort-lt))))\n",
  "  (cond\n    [(empty? arr) (list)]\n    [(< (length arr) 2) arr]\n    [else (by_length\
    \ (sort arr <))]))\n", "  (if (empty? arr)\n      (list)\n      (if (and (<= 1\
    \ (car arr)) (<= (car arr) 9))\n          (cons (num->str (car arr)) (by_length\
    \ (cdr arr)))\n          (by_length (cdr arr)))))\n", "    (map (lambda (x)\n\
    \        (cond [(= x 1) \"One\"]\n            [(= x 2) \"Two\"]\n            [(=\
    \ x 3) \"Three\"]\n            [(= x 4) \"Four\"]\n            [(= x 5) \"Five\"\
    ]\n            [(= x 6) \"Six\"]\n            [(= x 7) \"Seven\"]\n          \
    \  [(= x 8) \"Eight\"]\n            [(= x 9) \"Nine\"]))\n         (reverse (sort\
    \ (filter (lambda (x) (and (>= x 1) (<= x 9))) arr)))))", "  (cond\n    [(empty?\
    \ arr)\n     (list)]\n    [(number? (car arr))\n     (if (and (>= (car arr) 1)\
    \ (<= (car arr) 9))\n         (append (by_length (cdr arr)) (list (car arr)))\n\
    \         (by_length (cdr arr)))]\n    [else\n     (by_length (cdr arr))]))\n",
  "  (cond\n    [(empty? arr) (list)]\n    [(and (>= (first arr) 1) (<= (first arr)\
    \ 9))\n     (cons (digit-to-word (first arr)) (by_length (rest arr)))]\n    [else\
    \ (by_length (rest arr))]))\n", "  (if (empty? arr)\n      (list)\n      (\n \
    \      let ((valid-numbers (remove (lambda (e) (not (and (<= 1 e) (<= e 9))))\
    \ arr)))\n         (\n          let ((sorted-numbers (sort valid-numbers <)))\n\
    \            (\n             let ((reversed-numbers (reverse sorted-numbers)))\n\
    \               (\n                let ((string-numbers (map (lambda (e) (number->string\
    \ e)) reversed-numbers)))\n                  (\n                   let ((capitalized-numbers\
    \ (map (lambda (e) (string-capitalize e)) string-numbers)))\n                \
    \     (\n                      map (lambda (e) (if (equal? e \"One\") \"One\"\
    \ e)) capitalized-numbers\n                      )\n                     )\n \
    \                 )\n               )\n            )\n           )\n         )\n\
    \       )\n      )\n  )\n", "  (for/list ([digit (in-range 10)])\n           \
    \ (cond\n              [(zero? (count (in-range 1 10) (lambda (x) (= digit x))))\
    \ \"\"]\n              [else (string-&gt;symbol (format \"~a\" digit))])))\n</code>\n\
    but I'm not sure how to actually translate it into a list of numbers. The problem\
    \ is that <code>string-&gt;symbol</code> takes a string as an argument, but <code>format</code>\
    \ returns a string. So I'm stuck.\nAny ideas?\n\n\nA:\n\nIf you have a string\
    \ <code>\"1\"</code> and you want to convert it to the number <code>1</code>,\
    \ you can use <code>string-&gt;number</code>.\nHowever, your problem is a little\
    \ bit more complicated, because you have a list of strings, such as <code>'(\"\
    1\" \"5\" \"3\")</code> and you need to generate a new list of numbers, such as\
    \ <code>'(1 5 3)</code>. Fortunately, this is a very common task and there is\
    \ an easy way to do it:\n<code>(map string-&gt;number '(\"1\" \"5\" \"3\"))\n\
    =&gt; '(1 5 3)\n</code>\n<code>map</code> is a procedure that applies a given\
    \ function to each element of a list, and generates a new list with the results.\n\
    With that in mind, I hope you can figure out how to solve your problem.\n", " \
    \ (local ((define (sort lst)\n            (if (null? lst)\n                lst\n\
    \                (let ([sorted-tail (sort (cdr lst))])\n                  (if\
    \ (< (car lst) (car sorted-tail))\n                      (cons (car lst) sorted-tail)\n\
    \                      (cons (car sorted-tail) (sort (cons (car lst) (cdr sorted-tail)))))))))\n\
    \    (sort (reverse (map (\u03BB (x) (cond [(= x 1) \"One\"]\n               \
    \                       [(= x 2) \"Two\"]\n                                  \
    \    [(= x 3) \"Three\"]\n                                      [(= x 4) \"Four\"\
    ]\n                                      [(= x 5) \"Five\"]\n                \
    \                      [(= x 6) \"Six\"]\n                                   \
    \   [(= x 7) \"Seven\"]\n                                      [(= x 8) \"Eight\"\
    ]\n                                      [(= x 9) \"Nine\"]\n                \
    \                      [else #f]))\n                         (filter (\u03BB (x)\
    \ (>= x 1) (<= x 9)) arr))))))\n```\n\n### By Length 2\n\n```#lang racket\n",
  "  (letrec ([sort (lambda (arr acc)\n                   (cond [(empty? arr) acc]\n\
    \                         [(member (first arr) '(1 2 3 4 5 6 7 8 9))\n       \
    \                   (sort (rest arr) (cons (first arr) acc))]\n              \
    \           [else (sort (rest arr) acc)]))]\n           [reverse (lambda (arr\
    \ acc)\n                      (cond [(empty? arr) acc]\n                     \
    \       [else (reverse (rest arr) (cons (first arr) acc))]))]\n           [name\
    \ (lambda (num)\n                   (cond [(= num 1) \"One\"]\n              \
    \           [(= num 2) \"Two\"]\n                         [(= num 3) \"Three\"\
    ]\n                         [(= num 4) \"Four\"]\n                         [(=\
    \ num 5) \"Five\"]\n                         [(= num 6) \"Six\"]\n           \
    \              [(= num 7) \"Seven\"]\n                         [(= num 8) \"Eight\"\
    ]\n                         [(= num 9) \"Nine\"]))])\n    (reverse (sort arr '())\n\
    \             (lambda (arr acc)\n               (cond [(empty? arr) acc]\n   \
    \                  [else (reverse (rest arr) (cons (name (first arr)) acc))])))))\n",
  "  (for/list ((i (in-list (sort (filter number? arr) <))))\n    (number->string\
    \ i)))\n", "  (match arr\n    ['() '()]\n    [(list n rest ...)\n     (let ([num-to-word\
    \ (list \"One\" \"Two\" \"Three\" \"Four\" \"Five\" \"Six\" \"Seven\" \"Eight\"\
    \ \"Nine\")])\n       (let ([nums (filter (lambda (n) (member n (build-list 10\
    \ (lambda (i) i)))) (list n rest ...))])\n         (list->vector (reverse (map\
    \ (lambda (n) (vector-ref num-to-word n)) (sort nums (lambda (x y) (< x y))))))))]))\n",
  "  (reverse (map (lambda (n) (cond\n                            ((= n 1) \"One\"\
    )\n                            ((= n 2) \"Two\")\n                           \
    \ ((= n 3) \"Three\")\n                            ((= n 4) \"Four\")\n      \
    \                      ((= n 5) \"Five\")\n                            ((= n 6)\
    \ \"Six\")\n                            ((= n 7) \"Seven\")\n                \
    \            ((= n 8) \"Eight\")\n                            ((= n 9) \"Nine\"\
    )))\n               (sort (filter (lambda (n) (and (>= n 1) (<= n 9))) arr) <))))\n",
  "  (define nums (sort arr <))\n  (define names (map number->name nums))\n  (reverse\
    \ names))\n", "  (map number->string\n       (reverse\n        (sort\n       \
    \  (filter (lambda (x) (and (>= x 1) (<= x 9))) arr)\n         <))))\n```\n\n\
    `by_length`\uB97C \uC0AC\uC6A9\uD558\uB294 \uBB38\uC81C\uB294 \uB450 \uAC00\uC9C0\
    \uAC00 \uC788\uB2E4.\n\n```racket\n#lang racket\n", "  (cond\n    [(empty? arr)\
    \ (list)]\n    [(and (<= 1 (first arr)) (<= (first arr) 9))\n     (cons (number->string\
    \ (first arr)) (by_length (rest arr)))]\n    [else (by_length (rest arr))]))\n",
  "    (map word-number-to-string (reverse (integers-between arr))))\n", "  (define\
    \ (num->name n)\n    (cond ((= n 1) \"One\")\n          ((= n 2) \"Two\")\n  \
    \        ((= n 3) \"Three\")\n          ((= n 4) \"Four\")\n          ((= n 5)\
    \ \"Five\")\n          ((= n 6) \"Six\")\n          ((= n 7) \"Seven\")\n    \
    \      ((= n 8) \"Eight\")\n          ((= n 9) \"Nine\")))\n  (define (sort-filter\
    \ lst)\n    (filter (lambda (n)\n              (and (<= 1 n) (<= n 9)))\n    \
    \        (sort lst <)))\n  (map num->name (reverse (sort-filter arr))))\n```\n\
    \n## Hints:\n\n* You are not allowed to use the built-in functions `sort`, `filter`,\
    \ `reverse`, or `map` (or `member`, `append`, or any similar functions). You must\
    \ write your own functions.\n* The function `sort` returns the list with the elements\
    \ sorted in ascending order. It is defined as:\n```racket", "    (cond ((null?\
    \ arr) (list))\n          ((or (< (car arr) 1) (> (car arr) 9)) (by_length (cdr\
    \ arr)))\n          (else\n           (append (by_length (cdr arr)) (list (car\
    \ arr))))))", "  (map string-&gt;number\n       (for/list ([i (in-list (quicksort\
    \ (filter (\u03BB (x) (and (&lt;= 1 x) (&lt;= x 9))) arr)))])\n         (number-&gt;string\
    \ i))))\n", "  (cond ((null? arr) empty)\n        ((or (not (integer? (car arr)))\n\
    \             (< (car arr) 1)\n             (> (car arr) 9))\n         (by_length\
    \ (cdr arr)))\n        (else (append (by_length (cdr arr)) (list (car arr))))))",
  "  (if (null? arr) (list)\n      (let ([sorted-list (sort arr (\u03BB (x y) (< x\
    \ y)))]\n            [filtered-list (for/list ([x sorted-list]\n             \
    \                         #:when (and (>= x 1) (<= x 9))) x)])\n        (for/list\
    \ ([x (reverse filtered-list)])\n          (cond\n            [(= x 1) \"One\"\
    ]\n            [(= x 2) \"Two\"]\n            [(= x 3) \"Three\"]\n          \
    \  [(= x 4) \"Four\"]\n            [(= x 5) \"Five\"]\n            [(= x 6) \"\
    Six\"]\n            [(= x 7) \"Seven\"]\n            [(= x 8) \"Eight\"]\n   \
    \         [(= x 9) \"Nine\"])))))\n", "  (if (null? arr)\n      '()\n      (begin\
    \ (displayln (length arr))\n             (map (lambda (x)\n                  \
    \  (cond ((equal? x 1) \"One\")\n                          ((equal? x 2) \"Two\"\
    )\n                          ((equal? x 3) \"Three\")\n                      \
    \    ((equal? x 4) \"Four\")\n                          ((equal? x 5) \"Five\"\
    )\n                          ((equal? x 6) \"Six\")\n                        \
    \  ((equal? x 7) \"Seven\")\n                          ((equal? x 8) \"Eight\"\
    )\n                          ((equal? x 9) \"Nine\")))\n                  (reverse\
    \ (sort arr #:key (lambda (x) x)))))))", "  (cond [(empty? arr) (list)]\n    \
    \    [(> (first arr) 9) (by_length (rest arr))]\n        [(< (first arr) 1) (by_length\
    \ (rest arr))]\n        [else (append (by_length (rest arr)) (list (number->string\
    \ (first arr))))]))\n", "  (define (num->name n)\n    (cond ((= n 1) \"One\")\n\
    \          ((= n 2) \"Two\")\n          ((= n 3) \"Three\")\n          ((= n 4)\
    \ \"Four\")\n          ((= n 5) \"Five\")\n          ((= n 6) \"Six\")\n     \
    \     ((= n 7) \"Seven\")\n          ((= n 8) \"Eight\")\n          ((= n 9) \"\
    Nine\")))\n  (if (empty? arr)\n      (list)\n      (map num->name (reverse (sort\
    \ (filter (lambda (x) (and (<= 1 x) (<= x 9))) arr))))))\n", "  (reverse\n   (for/list\
    \ ([num (in-list (sort (filter (lambda (x) (or (= x 1) (= x 2) (= x 3) (= x 4)\
    \ (= x 5) (= x 6) (= x 7) (= x 8) (= x 9))) arr)))]\n              #:when (and\
    \ (>= num 1) (<= num 9)))\n     (cond\n       [(= num 1) \"One\"]\n       [(=\
    \ num 2) \"Two\"]\n       [(= num 3) \"Three\"]\n       [(= num 4) \"Four\"]\n\
    \       [(= num 5) \"Five\"]\n       [(= num 6) \"Six\"]\n       [(= num 7) \"\
    Seven\"]\n       [(= num 8) \"Eight\"]\n       [(= num 9) \"Nine\"]))))", "  (cond\
    \ [(empty? arr) empty]\n        [(list? (first arr)) (cons (by_length (first arr))\
    \ (by_length (rest arr)))]\n        [(and (>= (first arr) 1) (<= (first arr) 9))\n\
    \         (cons (number->string (first arr)) (by_length (rest arr)))]\n      \
    \  [else (by_length (rest arr))]))\n", "  (cond ((null? arr) '())\n        ((or\
    \ (< (car arr) 1) (> (car arr) 9)) (by_length (cdr arr)))\n        (else (cons\
    \ (list-ref (list \"One\" \"Two\" \"Three\" \"Four\" \"Five\" \"Six\" \"Seven\"\
    \ \"Eight\" \"Nine\") (car arr))\n                    (by_length (cdr arr))))))\n",
  "  (cond [(empty? arr) empty]\n        [(number? (first arr))\n         (cond [(and\
    \ (<= 1 (first arr)) (<= (first arr) 9))\n                (cons (by_length (rest\
    \ arr)) (list (number->string (first arr))))]\n               [else (by_length\
    \ (rest arr))])]\n        [else empty]))", " (local ((define range (list 1 2 3\
    \ 4 5 6 7 8 9))\n         (define dict (cons (cons '1 \"One\")\n             \
    \               (cons (cons '2 \"Two\")\n                                  (cons\
    \ (cons '3 \"Three\")\n                                        (cons (cons '4\
    \ \"Four\")\n                                              (cons (cons '5 \"Five\"\
    )\n                                                    (cons (cons '6 \"Six\"\
    )\n                                                          (cons (cons '7 \"\
    Seven\")\n                                                                (cons\
    \ (cons '8 \"Eight\")\n                                                      \
    \                (cons (cons '9 \"Nine\")\n                                  \
    \                                          empty))))))))))\n   (if (null? arr)\n\
    \       (list)\n       (reverse (map (lambda (x) (if (and (>= x 1) (<= x 9))\n\
    \                                     (dict x)\n                             \
    \        empty))\n                      (sort arr <))))))\n```\n\n```\nTests:\n\
    \n> (by_length (list 2 1 1 4 5 8 2 3))\n'(\"Eight\" \"Five\" \"Four\" \"Three\"\
    \ \"Two\" \"Two\" \"One\" \"One\")\n> (by_length (list ))\n'()\n> (by_length (list\
    \ 1 -1 55))\n'(\"One\")\n> (by_length (list 1 0 -1 55))\n'(\"One\")\n```\n\n##\
    \ Part 4\n\n```\n#lang racket\n", "  (let ([sorted (sort arr (\u03BB (x y) (<\
    \ x y)))]\n        [rev (reverse sorted)])\n    (cond [(empty? rev) '()]\n   \
    \       [(= 0 (modulo (first rev) 1)) (cons (digit-to-name (first rev)) (by_length\
    \ (rest rev)))]\n          [else (by_length (rest rev))])))\n", "  (cond\n   \
    \ [(empty? arr) (list)]\n    [(or (= 1 (car arr)) (= 2 (car arr)) (= 3 (car arr))\
    \ (= 4 (car arr)) (= 5 (car arr)) (= 6 (car arr)) (= 7 (car arr)) (= 8 (car arr))\
    \ (= 9 (car arr)))\n      (reverse (map (lambda (x) (number->string x)) (sort\
    \ (filter (lambda (x) (not (string? x))) arr))))]\n    [else\n      (reverse (map\
    \ (lambda (x) (number->string x)) (sort (filter (lambda (x) (not (string? x)))\
    \ arr))))]))\n", "  (map (lambda (x)\n         (cond\n           [(= x 1) \"One\"\
    ]\n           [(= x 2) \"Two\"]\n           [(= x 3) \"Three\"]\n           [(=\
    \ x 4) \"Four\"]\n           [(= x 5) \"Five\"]\n           [(= x 6) \"Six\"]\n\
    \           [(= x 7) \"Seven\"]\n           [(= x 8) \"Eight\"]\n           [(=\
    \ x 9) \"Nine\"]))\n       (reverse (sort (filter (lambda (x) (and (>= x 1) (<=\
    \ x 9))) arr)))))\n", "  (define nums (map (\u03BB (x) (cond ((= x 1) \"One\"\
    )\n                                  ((= x 2) \"Two\")\n                     \
    \             ((= x 3) \"Three\")\n                                  ((= x 4)\
    \ \"Four\")\n                                  ((= x 5) \"Five\")\n          \
    \                        ((= x 6) \"Six\")\n                                 \
    \ ((= x 7) \"Seven\")\n                                  ((= x 8) \"Eight\")\n\
    \                                  ((= x 9) \"Nine\")))\n                   (list-sort\
    \ < (filter (\u03BB (x) (and (<= x 9) (>= x 1))) arr))))\n  (reverse nums))\n",
  "  (cond [(null? arr) (list)]\n        [(member (car arr) (list 1 2 3 4 5 6 7 8\
    \ 9))\n         (cons (name-of-digit (car arr)) (by_length (cdr arr)))]\n    \
    \    [else (by_length (cdr arr))]))\n", "  (local [(define (digit-to-word n)\n\
    \            (cond\n              [(equal? n 1) \"One\"]\n              [(equal?\
    \ n 2) \"Two\"]\n              [(equal? n 3) \"Three\"]\n              [(equal?\
    \ n 4) \"Four\"]\n              [(equal? n 5) \"Five\"]\n              [(equal?\
    \ n 6) \"Six\"]\n              [(equal? n 7) \"Seven\"]\n              [(equal?\
    \ n 8) \"Eight\"]\n              [(equal? n 9) \"Nine\"]))]\n    (for/list ([x\
    \ (in-list (sort (filter (lambda (n) (and (<= 1 n) (<= n 9))) arr) <))])\n   \
    \   (digit-to-word x))))\n", "  (reverse\n   (map string-upcase\n        (map\
    \ symbol->string\n             (map (lambda (x) (list (string->symbol (number->string\
    \ x))))\n                  (sort arr (lambda (x y) (< x y))))))))", "  (map (lambda\
    \ (x)\n         (case x\n           [1 \"One\"]\n           [2 \"Two\"]\n    \
    \       [3 \"Three\"]\n           [4 \"Four\"]\n           [5 \"Five\"]\n    \
    \       [6 \"Six\"]\n           [7 \"Seven\"]\n           [8 \"Eight\"]\n    \
    \       [9 \"Nine\"]))\n       (reverse (sort (remove (lambda (x) (not (and (<=\
    \ 1 x) (<= x 9)))) arr)))))", "  (cond\n    [(empty? arr) '()]\n    [(< (first\
    \ arr) 1) (by_length (rest arr))]\n    [(> (first arr) 9) (by_length (rest arr))]\n\
    \    [else (cons (number->string (first arr)) (by_length (rest arr)))]))", " \
    \ (cond [(empty? arr) (list)]\n        [(positive? (first arr)) (by_length (rest\
    \ arr))]\n        [(= (first arr) 1) (cons \"One\" (by_length (rest arr)))]\n\
    \        [(= (first arr) 2) (cons \"Two\" (by_length (rest arr)))]\n        [(=\
    \ (first arr) 3) (cons \"Three\" (by_length (rest arr)))]\n        [(= (first\
    \ arr) 4) (cons \"Four\" (by_length (rest arr)))]\n        [(= (first arr) 5)\
    \ (cons \"Five\" (by_length (rest arr)))]\n        [(= (first arr) 6) (cons \"\
    Six\" (by_length (rest arr)))]\n        [(= (first arr) 7) (cons \"Seven\" (by_length\
    \ (rest arr)))]\n        [(= (first arr) 8) (cons \"Eight\" (by_length (rest arr)))]\n\
    \        [(= (first arr) 9) (cons \"Nine\" (by_length (rest arr)))]\n        [else\
    \ (by_length (rest arr))]))\n", "    (if (empty? arr)\n        '()\n        (list-ref\
    \ (list (list-ref (list \"One\" \"Two\" \"Three\" \"Four\" \"Five\" \"Six\" \"\
    Seven\" \"Eight\" \"Nine\") (- (list-ref (sort (filter (lambda (x) (<= x 9) (filter\
    \ (lambda (x) (>= x 1) arr)) <) 9) 1) 10)) 0)))\n)", "  (cond\n    [(empty? arr)\
    \ empty]\n    [(empty? (filter (lambda (x) (and (integer? x) (>= x 1) (<= x 9)))\
    \ arr)) empty]\n    [else (reverse (map (lambda (x) (list-ref (list \"One\" \"\
    Two\" \"Three\" \"Four\" \"Five\" \"Six\" \"Seven\" \"Eight\" \"Nine\") (- x 1)))\
    \ (sort (filter (lambda (x) (and (integer? x) (>= x 1) (<= x 9))) arr))))]))\n",
  "  (reverse (map (lambda (x) (cond [(= x 1) \"One\"] [(= x 2) \"Two\"] [(= x 3)\
    \ \"Three\"] [(= x 4) \"Four\"] [(= x 5) \"Five\"] [(= x 6) \"Six\"] [(= x 7)\
    \ \"Seven\"] [(= x 8) \"Eight\"] [(= x 9) \"Nine\"])) (sort (filter (lambda (x)\
    \ (and (>= x 1) (<= x 9))) arr) <))))\n", "  (apply append\n         (for/list\
    \ ([x (sort arr #:key (\u03BB (x) (remainder x 10)))]\n                     #:when\
    \ (and (integer? x)\n                                 (or (= x 1) (= x 2) (= x\
    \ 3) (= x 4) (= x 5) (= x 6) (= x 7) (= x 8) (= x 9))))\n           (reverse (for/list\
    \ ([x (number->string x)])\n                      (string-&gt;symbol x))))))\n\
    </code>\n", "  (match arr\n    [(list) empty]\n    [(list (? integer? x) ...)\n\
    \     (map (lambda (n)\n            (match n\n              [1 \"One\"]\n    \
    \          [2 \"Two\"]\n              [3 \"Three\"]\n              [4 \"Four\"\
    ]\n              [5 \"Five\"]\n              [6 \"Six\"]\n              [7 \"\
    Seven\"]\n              [8 \"Eight\"]\n              [9 \"Nine\"]))\n        \
    \  (reverse (sort (filter (lambda (x) (and (>= x 1) (<= x 9))) arr)) <))]))\n",
  "  (map (lambda (x)\n         (cond [(= x 1) \"One\"]\n               [(= x 2) \"\
    Two\"]\n               [(= x 3) \"Three\"]\n               [(= x 4) \"Four\"]\n\
    \               [(= x 5) \"Five\"]\n               [(= x 6) \"Six\"]\n       \
    \        [(= x 7) \"Seven\"]\n               [(= x 8) \"Eight\"]\n           \
    \    [(= x 9) \"Nine\"]))\n       (sort arr <)\n       (reverse arr)))\n", " \
    \ (map (lambda (i)\n         (cond\n           [(= i 1) \"One\"]\n           [(=\
    \ i 2) \"Two\"]\n           [(= i 3) \"Three\"]\n           [(= i 4) \"Four\"\
    ]\n           [(= i 5) \"Five\"]\n           [(= i 6) \"Six\"]\n           [(=\
    \ i 7) \"Seven\"]\n           [(= i 8) \"Eight\"]\n           [(= i 9) \"Nine\"\
    ]))\n       (reverse (sort (filter (lambda (i) (and (<= 1 i) (<= i 9))) arr)))))\n",
  "  (for/list ([e (in-list (sort arr #:key (\u03BB (e) (if (< e 10) e 0))))])\n \
    \   (match e\n      [1 \"One\"]\n      [2 \"Two\"]\n      [3 \"Three\"]\n    \
    \  [4 \"Four\"]\n      [5 \"Five\"]\n      [6 \"Six\"]\n      [7 \"Seven\"]\n\
    \      [8 \"Eight\"]\n      [9 \"Nine\"]\n      [else \"\"])))\n", "  (cond ((empty?\
    \ arr) (list))\n        ((<= 1 (first arr) 9) (map by_length (reverse (sort (remove\
    \ (first arr) arr) <))))\n        (else (by_length (rest arr)))))\n", "  (cond\
    \ [(empty? arr) (list)]\n        [(or (> (first arr) 9) (< (first arr) 1)) (by_length\
    \ (rest arr))]\n        [else (append (by_length (rest arr)) (list (first arr)))]))\n",
  "  (cond\n    [(empty? arr) empty]\n    [(not (between/c 1 9 (first arr))) (by_length\
    \ (rest arr))]\n    [else (cons (by_length (filter (lambda (x) (between/c 1 9\
    \ x)) (sort (append arr (list (first arr))) <)))\n                (by_length (filter\
    \ (lambda (x) (not (between/c 1 9 x))) (rest arr))))]))\n", "  (cond [(empty?\
    \ arr) (list)]\n        [(< (first arr) 1) (by_length (rest arr))]\n        [(>\
    \ (first arr) 9) (by_length (rest arr))]\n        [else (append (by_length (rest\
    \ arr)) (list (first arr)))]))\n", "  (if (= 0 (length arr))\n      (list)\n \
    \     (reverse (list->string (list->integer (sort (list->integer (list->string\
    \ (list 1 2 3 4 5 6 7 8 9)))))))))\n", "  (apply append\n         (for/list ((i\
    \ (in-range 1 10)))\n           (reverse\n            (map number->string\n  \
    \               (filter (lambda (n) (= i n))\n                         arr))))))\n",
  "  (match arr\n    ('() '())\n    ((cons hd tl) (match hd\n                    \
    \ (1 (cons \"One\" (by_length tl)))\n                     (2 (cons \"Two\" (by_length\
    \ tl)))\n                     (3 (cons \"Three\" (by_length tl)))\n          \
    \           (4 (cons \"Four\" (by_length tl)))\n                     (5 (cons\
    \ \"Five\" (by_length tl)))\n                     (6 (cons \"Six\" (by_length\
    \ tl)))\n                     (7 (cons \"Seven\" (by_length tl)))\n          \
    \           (8 (cons \"Eight\" (by_length tl)))\n                     (9 (cons\
    \ \"Nine\" (by_length tl)))\n                     (else (by_length tl))))))",
  "  (cond\n    [(null? arr)\n     '()]\n    [(and (number? (car arr))\n         \
    \ (<= 1 (car arr))\n          (<= (car arr) 9))\n     (cons (number->string (car\
    \ arr))\n           (by_length (cdr arr)))]\n    [else\n     (by_length (cdr arr))]))\n",
  "    (cond\n        [(empty? arr) '()]\n        [(< (first arr) 1) (by_length (rest\
    \ arr))]\n        [(> (first arr) 9) (by_length (rest arr))]\n        [else\n\
    \            (cons (cond [(= (first arr) 1) \"One\"]\n                       \
    \ [(= (first arr) 2) \"Two\"]\n                        [(= (first arr) 3) \"Three\"\
    ]\n                        [(= (first arr) 4) \"Four\"]\n                    \
    \    [(= (first arr) 5) \"Five\"]\n                        [(= (first arr) 6)\
    \ \"Six\"]\n                        [(= (first arr) 7) \"Seven\"]\n          \
    \              [(= (first arr) 8) \"Eight\"]\n                        [(= (first\
    \ arr) 9) \"Nine\"])\n                  (by_length (rest arr)))]))", "  (for/list\
    \ ([n (in-list (sort (filter (lambda (x) (and (<= 1 x) (<= x 9))) arr)) <)])\n\
    \    (cond\n      [(= n 1) \"One\"]\n      [(= n 2) \"Two\"]\n      [(= n 3) \"\
    Three\"]\n      [(= n 4) \"Four\"]\n      [(= n 5) \"Five\"]\n      [(= n 6) \"\
    Six\"]\n      [(= n 7) \"Seven\"]\n      [(= n 8) \"Eight\"]\n      [(= n 9) \"\
    Nine\"])))\n", "  (if (empty? arr)\n      (list)\n      (map (lambda (d) (cond\
    \ [(equal? d 1) \"One\"]\n                             [(equal? d 2) \"Two\"]\n\
    \                             [(equal? d 3) \"Three\"]\n                     \
    \        [(equal? d 4) \"Four\"]\n                             [(equal? d 5) \"\
    Five\"]\n                             [(equal? d 6) \"Six\"]\n               \
    \              [(equal? d 7) \"Seven\"]\n                             [(equal?\
    \ d 8) \"Eight\"]\n                             [(equal? d 9) \"Nine\"]))\n  \
    \         (reverse (sort (filter (lambda (e) (and (<= e 9) (>= e 1))) arr))))))\n",
  "  (letrec ([normalize (lambda (arr)\n                        (if (null? arr)\n\
    \                            arr\n                            (if (and (integer?\
    \ (car arr))\n                                     (<= 1 (car arr))\n        \
    \                             (<= (car arr) 9))\n                            \
    \    (cons (car arr) (normalize (cdr arr)))\n                                (normalize\
    \ (cdr arr)))))])\n    (reverse (map (lambda (x)\n                    (cond\n\
    \                      [(equal? x 1) \"One\"]\n                      [(equal?\
    \ x 2) \"Two\"]\n                      [(equal? x 3) \"Three\"]\n            \
    \          [(equal? x 4) \"Four\"]\n                      [(equal? x 5) \"Five\"\
    ]\n                      [(equal? x 6) \"Six\"]\n                      [(equal?\
    \ x 7) \"Seven\"]\n                      [(equal? x 8) \"Eight\"]\n          \
    \            [(equal? x 9) \"Nine\"]))\n                  (normalize arr)))))\n",
  "  (for/list ([digit (sort < (filter number? arr))])\n    (cond [(= digit 1) \"\
    One\"]\n          [(= digit 2) \"Two\"]\n          [(= digit 3) \"Three\"]\n \
    \         [(= digit 4) \"Four\"]\n          [(= digit 5) \"Five\"]\n         \
    \ [(= digit 6) \"Six\"]\n          [(= digit 7) \"Seven\"]\n          [(= digit\
    \ 8) \"Eight\"]\n          [(= digit 9) \"Nine\"])))\n", "  (map number->word\n\
    \       (reverse\n        (sort arr\n              (lambda (x y)\n           \
    \     (and (and (<= 1 x 9) (<= 1 y 9))\n                     (< x y)))))))\n",
  "  (let ([filtered-arr (filter range-1-9? arr)])\n    (reverse\n     (map (lambda\
    \ (number)\n            (number->word number))\n          filtered-arr))))\n",
  "  (map (lambda (x)\n         (cond [(= x 1) \"One\"]\n               [(= x 2) \"\
    Two\"]\n               [(= x 3) \"Three\"]\n               [(= x 4) \"Four\"]\n\
    \               [(= x 5) \"Five\"]\n               [(= x 6) \"Six\"]\n       \
    \        [(= x 7) \"Seven\"]\n               [(= x 8) \"Eight\"]\n           \
    \    [(= x 9) \"Nine\"]))\n       (reverse (sort arr (lambda (x y) (< x y))))))",
  "  (map (lambda (x)\n         (cond\n           [(eq? x 1) \"One\"]\n          \
    \ [(eq? x 2) \"Two\"]\n           [(eq? x 3) \"Three\"]\n           [(eq? x 4)\
    \ \"Four\"]\n           [(eq? x 5) \"Five\"]\n           [(eq? x 6) \"Six\"]\n\
    \           [(eq? x 7) \"Seven\"]\n           [(eq? x 8) \"Eight\"]\n        \
    \   [(eq? x 9) \"Nine\"]))\n       (reverse (sort (filter (lambda (x) (and (<=\
    \ x 9) (>= x 1))) arr) <))))\n", "  (if (empty? arr)\n      (list)\n      (map\
    \ string->symbol\n           (reverse\n            (sort (filter (lambda (x) (and\
    \ (>= x 1) (<= x 9))) arr) <)))))\n", "  (cond\n    [(null? arr) (list)]\n   \
    \ [(not (positive? (car arr))) (by_length (cdr arr))]\n    [(not (negative? (car\
    \ arr))) (by_length (cdr arr))]\n    [(= (car arr) 1) (cons \"One\" (by_length\
    \ (cdr arr)))]\n    [(= (car arr) 2) (cons \"Two\" (by_length (cdr arr)))]\n \
    \   [(= (car arr) 3) (cons \"Three\" (by_length (cdr arr)))]\n    [(= (car arr)\
    \ 4) (cons \"Four\" (by_length (cdr arr)))]\n    [(= (car arr) 5) (cons \"Five\"\
    \ (by_length (cdr arr)))]\n    [(= (car arr) 6) (cons \"Six\" (by_length (cdr\
    \ arr)))]\n    [(= (car arr) 7) (cons \"Seven\" (by_length (cdr arr)))]\n    [(=\
    \ (car arr) 8) (cons \"Eight\" (by_length (cdr arr)))]\n    [(= (car arr) 9) (cons\
    \ \"Nine\" (by_length (cdr arr)))]\n    [else (by_length (cdr arr))]))", "  (let\
    \ ([map (make-hasheq)])\n    (hash-set! map 1 \"One\")\n    (hash-set! map 2 \"\
    Two\")\n    (hash-set! map 3 \"Three\")\n    (hash-set! map 4 \"Four\")\n    (hash-set!\
    \ map 5 \"Five\")\n    (hash-set! map 6 \"Six\")\n    (hash-set! map 7 \"Seven\"\
    )\n    (hash-set! map 8 \"Eight\")\n    (hash-set! map 9 \"Nine\")\n    (for/list\
    \ ([x (in-list (sort (filter number? arr) <))])\n      (hash-ref map x))))\n```\n\
    \n```racket\n#lang racket\n", "  (define (transform arr)\n    (for/list ([x arr])\n\
    \      (cond\n        [(= x 1) \"One\"]\n        [(= x 2) \"Two\"]\n        [(=\
    \ x 3) \"Three\"]\n        [(= x 4) \"Four\"]\n        [(= x 5) \"Five\"]\n  \
    \      [(= x 6) \"Six\"]\n        [(= x 7) \"Seven\"]\n        [(= x 8) \"Eight\"\
    ]\n        [(= x 9) \"Nine\"]\n        [else x])))\n  (transform (reverse (sort\
    \ (filter (lambda (x) (and (>= x 1) (<= x 9))) arr)))))", "  (reverse (list->string\
    \ (list->number (list-sort (lambda (x y) (< x y))\n                          \
    \                         (filter (lambda (x) (<= x 9) (<= 1 x))\n           \
    \                                                arr))))))\n", "  (cond\n    [(empty?\
    \ arr) (list)]\n    [(number? (first arr))\n      (if (and (<= 1 (first arr))\
    \ (<= (first arr) 9))\n        (append (by_length (rest arr)) (list (num-to-string\
    \ (first arr))))\n        (by_length (rest arr)))]\n    [else (by_length (rest\
    \ arr))]))\n", "  (if (null? arr)\n      '()\n      (let* ([sorted-arr (sort arr\
    \ (lambda (a b) (< a b)))]\n             [filtered-arr (filter sorted-arr (lambda\
    \ (n) (and (>= n 1) (<= n 9))))]\n             [reversed-arr (reverse filtered-arr)])\n\
    \        (map reversed-arr (lambda (n) (list-ref (list \"One\" \"Two\" \"Three\"\
    \ \"Four\" \"Five\" \"Six\" \"Seven\" \"Eight\" \"Nine\") n))))))\n", "  (cond\
    \ [(empty? arr) empty]\n        [(not (between? (first arr) 1 9)) (by_length (rest\
    \ arr))]\n        [else (append (by_length (rest arr)) (list (get_name (first\
    \ arr))))]))\n", "  (reverse\n   (map string->number\n        (map (lambda (x)\n\
    \               (cond\n                 ((= x 1) \"One\")\n                 ((=\
    \ x 2) \"Two\")\n                 ((= x 3) \"Three\")\n                 ((= x\
    \ 4) \"Four\")\n                 ((= x 5) \"Five\")\n                 ((= x 6)\
    \ \"Six\")\n                 ((= x 7) \"Seven\")\n                 ((= x 8) \"\
    Eight\")\n                 ((= x 9) \"Nine\")))\n             (sort arr <)))))",
  "  (reverse (map (lambda (el)\n                  (cond\n                    ((=\
    \ el 1) \"One\")\n                    ((= el 2) \"Two\")\n                   \
    \ ((= el 3) \"Three\")\n                    ((= el 4) \"Four\")\n            \
    \        ((= el 5) \"Five\")\n                    ((= el 6) \"Six\")\n       \
    \             ((= el 7) \"Seven\")\n                    ((= el 8) \"Eight\")\n\
    \                    ((= el 9) \"Nine\")))\n                (sort arr (lambda\
    \ (a b) (< a b))))))\n", "  (let ([aux (sort arr (lambda (x y) (< x y)))])\n \
    \   (reverse\n     (map\n      (lambda (x)\n        (cond\n          [(= x 1)\
    \ \"One\"]\n          [(= x 2) \"Two\"]\n          [(= x 3) \"Three\"]\n     \
    \     [(= x 4) \"Four\"]\n          [(= x 5) \"Five\"]\n          [(= x 6) \"\
    Six\"]\n          [(= x 7) \"Seven\"]\n          [(= x 8) \"Eight\"]\n       \
    \   [(= x 9) \"Nine\"]\n          [else \"\"]))\n      aux))))\n", "  (define\
    \ (sort l)\n    (if (= (length l) 1)\n        l\n        (append (sort (filter\
    \ (lambda (e) (> e (car l))) l))\n                (list (car l))\n           \
    \     (sort (filter (lambda (e) (< e (car l))) l)))))\n  (define (num2str num)\n\
    \    (cond ((= num 1) \"One\")\n          ((= num 2) \"Two\")\n          ((= num\
    \ 3) \"Three\")\n          ((= num 4) \"Four\")\n          ((= num 5) \"Five\"\
    )\n          ((= num 6) \"Six\")\n          ((= num 7) \"Seven\")\n          ((=\
    \ num 8) \"Eight\")\n          ((= num 9) \"Nine\")))\n  (define (helper l)\n\
    \    (if (empty? l)\n        '()\n        (cons (num2str (car l)) (helper (cdr\
    \ l)))))\n  (helper (sort (filter (lambda (e) (< 1 e 9)) arr))))\n", "  (map (lambda\
    \ (n)\n         (cond [(= n 1) \"One\"]\n               [(= n 2) \"Two\"]\n  \
    \             [(= n 3) \"Three\"]\n               [(= n 4) \"Four\"]\n       \
    \        [(= n 5) \"Five\"]\n               [(= n 6) \"Six\"]\n              \
    \ [(= n 7) \"Seven\"]\n               [(= n 8) \"Eight\"]\n               [(=\
    \ n 9) \"Nine\"]))\n       (reverse (filter (lambda (n) (and (>= n 1) (<= n 9)))\
    \ arr))))\n", "  (cond\n    [(empty? arr) (list)]\n    [(number? (first arr))\n\
    \     (let-values ([(list1 list2) (partition (lambda (x) (> x 0) (> x 9)) arr)])\n\
    \       (reverse\n        (map\n         (lambda (x)\n           (cond\n     \
    \        [(= x 1) \"One\"]\n             [(= x 2) \"Two\"]\n             [(= x\
    \ 3) \"Three\"]\n             [(= x 4) \"Four\"]\n             [(= x 5) \"Five\"\
    ]\n             [(= x 6) \"Six\"]\n             [(= x 7) \"Seven\"]\n        \
    \     [(= x 8) \"Eight\"]\n             [(= x 9) \"Nine\"]))\n         (quicksort\
    \ list1))))]\n    [else (by_length (rest arr))]))", "  (cond\n    [(empty? arr)\
    \ empty]\n    [(< (first arr) 1)\n     (cons (cond\n             [(= (first arr)\
    \ 1) \"One\"]\n             [(= (first arr) 2) \"Two\"]\n             [(= (first\
    \ arr) 3) \"Three\"]\n             [(= (first arr) 4) \"Four\"]\n            \
    \ [(= (first arr) 5) \"Five\"]\n             [(= (first arr) 6) \"Six\"]\n   \
    \          [(= (first arr) 7) \"Seven\"]\n             [(= (first arr) 8) \"Eight\"\
    ]\n             [(= (first arr) 9) \"Nine\"])\n           (by_length (rest arr)))]\n\
    \    [else (by_length (rest arr))]))\n", "    (define first-element (list-ref\
    \ arr 0))\n    (cond [(= (length arr) 0) (list)]\n          [(or (= first-element\
    \ -1) (>= first-element 10)) (by_length (rest arr))]\n          [else (cons (word-to-number\
    \ first-element) (by_length (rest arr)))]))\n", "  (map number->string\n     \
    \  (reverse\n        (sort (filter (lambda (n) (and (&lt;= 1 n) (&lt;= n 9)))\
    \ arr)\n              &lt;))))\n</code>\n", "  (define (digits-between-1-and-9?\
    \ arr)\n    (cond [(null? arr) '()]\n          [(< 1 (car arr) 9) (cons (car arr)\
    \ (digits-between-1-and-9? (cdr arr)))]\n          [else (digits-between-1-and-9?\
    \ (cdr arr))]))\n  (define (sort arr)\n    (cond [(null? arr) '()]\n         \
    \ [(null? (cdr arr)) arr]\n          [(> (car arr) (cadr arr)) (cons (cadr arr)\
    \ (cons (car arr) (cddr arr)))]\n          [else (cons (car arr) (sort (cdr arr)))]))\n\
    \  (define (replace arr)\n    (cond [(null? arr) '()]\n          [(equal? 1 (car\
    \ arr)) (cons \"One\" (replace (cdr arr)))]\n          [(equal? 2 (car arr)) (cons\
    \ \"Two\" (replace (cdr arr)))]\n          [(equal? 3 (car arr)) (cons \"Three\"\
    \ (replace (cdr arr)))]\n          [(equal? 4 (car arr)) (cons \"Four\" (replace\
    \ (cdr arr)))]\n          [(equal? 5 (car arr)) (cons \"Five\" (replace (cdr arr)))]\n\
    \          [(equal? 6 (car arr)) (cons \"Six\" (replace (cdr arr)))]\n       \
    \   [(equal? 7 (car arr)) (cons \"Seven\" (replace (cdr arr)))]\n          [(equal?\
    \ 8 (car arr)) (cons \"Eight\" (replace (cdr arr)))]\n          [(equal? 9 (car\
    \ arr)) (cons \"Nine\" (replace (cdr arr)))]\n          [else (replace (cdr arr))]))\n\
    \  (define (reverse arr)\n    (cond [(null? arr) '()]\n          [else (append\
    \ (reverse (cdr arr)) (list (car arr)))]))\n  (reverse (replace (sort (digits-between-1-and-9?\
    \ arr)))))\n", "  (cond\n    [(empty? arr) '()]\n    [(equal? (length arr) 1)\
    \ (make-result (car arr))]\n    [else (append (by_length (filter (lambda (x) (<\
    \ x (car arr))) arr))\n                 (make-result (car arr))\n            \
    \     (by_length (filter (lambda (x) (> x (car arr))) arr)))]))\n", "  (let* ((arr-filtered\
    \ (filter (lambda (x) (and (<= 1 x) (<= x 9))) arr))\n         (arr-sorted (sort\
    \ arr-filtered <))\n         (reversed (reverse arr-sorted)))\n    (map\n    \
    \ (lambda (x)\n       (if (= x 1)\n           \"One\"\n           (if (= x 2)\n\
    \               \"Two\"\n               (if (= x 3)\n                   \"Three\"\
    \n                   (if (= x 4)\n                       \"Four\"\n          \
    \             (if (= x 5)\n                           \"Five\"\n             \
    \              (if (= x 6)\n                               \"Six\"\n         \
    \                      (if (= x 7)\n                                   \"Seven\"\
    \n                                   (if (= x 8)\n                           \
    \            \"Eight\"\n                                       \"Nine\")))))))))\n\
    \     reversed)))\n", "  (cond [(empty? arr) empty]\n        [(< (first arr) 1)\
    \ (by_length (rest arr))]\n        [(> (first arr) 9) (by_length (rest arr))]\n\
    \        [else (append (reverse (list (number->string (first arr)))) (by_length\
    \ (rest arr)))]))\n", "  (define (digit-name num)\n    (cond [(= num 1) \"One\"\
    ]\n          [(= num 2) \"Two\"]\n          [(= num 3) \"Three\"]\n          [(=\
    \ num 4) \"Four\"]\n          [(= num 5) \"Five\"]\n          [(= num 6) \"Six\"\
    ]\n          [(= num 7) \"Seven\"]\n          [(= num 8) \"Eight\"]\n        \
    \  [(= num 9) \"Nine\"]))\n  (define (valid? num)\n    (and (<= 1 num) (<= num\
    \ 9)))\n  (define (to-names arr)\n    (if (empty? arr)\n        (list)\n     \
    \   (cons (digit-name (first arr)) (to-names (rest arr)))))\n  (reverse (to-names\
    \ (sort (filter valid? arr) <))))\n", "  (cond\n    [(empty? arr) empty]\n   \
    \ [(not (number? (first arr))) (by_length (rest arr))]\n    [(and (<= 1 (first\
    \ arr)) (<= (first arr) 9))\n     (append (by_length (rest arr)) (list (number->string\
    \ (first arr))))]\n    [else (by_length (rest arr))]))\n", "  (define (digits\
    \ str)\n    (cond\n      [(eq? str 1) \"One\"]\n      [(eq? str 2) \"Two\"]\n\
    \      [(eq? str 3) \"Three\"]\n      [(eq? str 4) \"Four\"]\n      [(eq? str\
    \ 5) \"Five\"]\n      [(eq? str 6) \"Six\"]\n      [(eq? str 7) \"Seven\"]\n \
    \     [(eq? str 8) \"Eight\"]\n      [(eq? str 9) \"Nine\"]\n      [else \"Error\"\
    ]))\n  (for/list ([i (in-list (sort (filter (lambda (a) (and (<= a 9) (>= a 1)))\
    \ arr) >))])\n    (digits i)))\n", "  (cond ((null? arr) '())\n        ((< (car\
    \ arr) 1) (by_length (cdr arr)))\n        ((> (car arr) 9) (by_length (cdr arr)))\n\
    \        (else (cons (number->string (car arr)) (by_length (cdr arr))))))\n",
  "  (reverse (map (lambda (x)\n                   (cond [(equal? x 1) \"One\"]\n\
    \                         [(equal? x 2) \"Two\"]\n                         [(equal?\
    \ x 3) \"Three\"]\n                         [(equal? x 4) \"Four\"]\n        \
    \                 [(equal? x 5) \"Five\"]\n                         [(equal? x\
    \ 6) \"Six\"]\n                         [(equal? x 7) \"Seven\"]\n           \
    \              [(equal? x 8) \"Eight\"]\n                         [(equal? x 9)\
    \ \"Nine\"]))\n                 (sort (filter (lambda (x)\n                  \
    \                (and (>= x 1) (<= x 9)))\n                                arr)))))\n",
  "  (cond [(empty? arr) empty]\n        [(empty? (remove (lambda (x) (< x 1)) arr))\n\
    \         (map number->string\n              (reverse (filter (lambda (x) (<=\
    \ x 9)) (sort arr <)) )) ]\n        [else empty]))\n", "  (cond\n    [(empty?\
    \ arr) '()]\n    [(<= 1 (first arr) 9) (cons (number->name (first arr)) (by_length\
    \ (rest arr)))]\n    [else (by_length (rest arr))]))\n", "  (cond [(null? arr)\
    \ '()]\n        [(number? (car arr)) (by_length (cdr arr))]\n        [(and (<=\
    \ 1 (car arr)) (<= (car arr) 9))\n         (append (by_length (cdr arr))\n   \
    \              (list (by_length_aux (car arr))))]\n        [else (by_length (cdr\
    \ arr))]))\n", "  (let ([dict (make-hash)])\n    (hash-set! dict 1 \"One\")\n\
    \    (hash-set! dict 2 \"Two\")\n    (hash-set! dict 3 \"Three\")\n    (hash-set!\
    \ dict 4 \"Four\")\n    (hash-set! dict 5 \"Five\")\n    (hash-set! dict 6 \"\
    Six\")\n    (hash-set! dict 7 \"Seven\")\n    (hash-set! dict 8 \"Eight\")\n \
    \   (hash-set! dict 9 \"Nine\")\n    (reverse (map (lambda (num)\n           \
    \         (hash-ref dict num \"Not found\"))\n                  (sort (filter\
    \ (lambda (num) (and (>= num 1) (<= num 9))) arr) <)))))\n", "  (define (num-to-str\
    \ num)\n    (cond\n      [(= num 1) \"One\"]\n      [(= num 2) \"Two\"]\n    \
    \  [(= num 3) \"Three\"]\n      [(= num 4) \"Four\"]\n      [(= num 5) \"Five\"\
    ]\n      [(= num 6) \"Six\"]\n      [(= num 7) \"Seven\"]\n      [(= num 8) \"\
    Eight\"]\n      [(= num 9) \"Nine\"]\n      [else \"\"]))\n  (cond\n    [(empty?\
    \ arr) empty]\n    [(< (first arr) 1) (by_length (rest arr))]\n    [(> (first\
    \ arr) 9) (by_length (rest arr))]\n    [else (cons (num-to-str (first arr)) (by_length\
    \ (rest arr)))]))\n", "  (map num-to-string (reverse (sort (filter num-between-1-and-9?\
    \ arr) <))))\n", "    (map (lambda (x) (string-append \"\\\"\" (string-append\
    \ (cond\n                                        [(= x 1) \"One\"]\n         \
    \                               [(= x 2) \"Two\"]\n                          \
    \              [(= x 3) \"Three\"]\n                                        [(=\
    \ x 4) \"Four\"]\n                                        [(= x 5) \"Five\"]\n\
    \                                        [(= x 6) \"Six\"]\n                 \
    \                       [(= x 7) \"Seven\"]\n                                \
    \        [(= x 8) \"Eight\"]\n                                        [(= x 9)\
    \ \"Nine\"]\n                                        [else \"\"]) \"\\\"\"))\n\
    \                                    )\n        (reverse (sort (filter (lambda\
    \ (x) (and (<= x 9) (>= x 1))) arr) >))\n        )\n    )\n", "  (define (d2n\
    \ i)\n    (cond\n      [(= i 1) \"One\"]\n      [(= i 2) \"Two\"]\n      [(= i\
    \ 3) \"Three\"]\n      [(= i 4) \"Four\"]\n      [(= i 5) \"Five\"]\n      [(=\
    \ i 6) \"Six\"]\n      [(= i 7) \"Seven\"]\n      [(= i 8) \"Eight\"]\n      [(=\
    \ i 9) \"Nine\"]\n      [else i]))\n  (map d2n (sort < (filter (lambda (i) (and\
    \ (>= i 1) (<= i 9))) arr))))\n```\n\n```\n#lang racket\n", "  (define all-numbers\
    \ '(1 2 3 4 5 6 7 8 9))\n  (define all-names '(One Two Three Four Five Six Seven\
    \ Eight Nine))\n  (define (arr-numbers l1 l2)\n    (filter\n     (lambda (x) (member\
    \ x l1))\n     l2))\n  (define (arr-names l1 l2)\n    (map\n     (lambda (x) (list-ref\
    \ l2 x))\n     l1))\n  (arr-names\n   (arr-numbers arr all-numbers)\n   all-names))",
  "  (define (digits->names lst)\n    (map (lambda (n)\n           (if (= n 1) \"\
    One\"\n               (if (= n 2) \"Two\"\n                   (if (= n 3) \"Three\"\
    \n                       (if (= n 4) \"Four\"\n                           (if\
    \ (= n 5) \"Five\"\n                               (if (= n 6) \"Six\"\n     \
    \                              (if (= n 7) \"Seven\"\n                       \
    \                (if (= n 8) \"Eight\"\n                                     \
    \      (if (= n 9) \"Nine\"\n                                               \"\
    Unknow\"))))))))))\n         lst))\n  (digits->names (reverse (sort (filter (lambda\
    \ (n) (and (>= n 1) (<= n 9))) arr)))))\n", "  (match arr\n    ['() '()]\n   \
    \ [(cons head (cons x arr))\n     (if (and (>= head 1) (<= head 9))\n        \
    \ (cons (word head) (by_length arr))\n         (by_length arr))]))\n", "  (let\
    \ ([len (length arr)])\n    (cond [(eq? len 0) arr]\n          [else\n       \
    \    (let ([sorted (sort (lambda (x y) (< x y)) arr)])\n             (map (lambda\
    \ (x)\n                    (cond [(eq? x 1) \"One\"]\n                       \
    \   [(eq? x 2) \"Two\"]\n                          [(eq? x 3) \"Three\"]\n   \
    \                       [(eq? x 4) \"Four\"]\n                          [(eq?\
    \ x 5) \"Five\"]\n                          [(eq? x 6) \"Six\"]\n            \
    \              [(eq? x 7) \"Seven\"]\n                          [(eq? x 8) \"\
    Eight\"]\n                          [(eq? x 9) \"Nine\"]\n                   \
    \       [else #f]))\n                  (reverse sorted))))]))\n", "  (define (to_str\
    \ i)\n    (cond\n      [(= i 1) \"One\"]\n      [(= i 2) \"Two\"]\n      [(= i\
    \ 3) \"Three\"]\n      [(= i 4) \"Four\"]\n      [(= i 5) \"Five\"]\n      [(=\
    \ i 6) \"Six\"]\n      [(= i 7) \"Seven\"]\n      [(= i 8) \"Eight\"]\n      [(=\
    \ i 9) \"Nine\"]\n      [else \"\"]))\n  (map to_str (reverse (sort (filter (lambda\
    \ (x) (and (<= 1 x) (<= x 9))) arr)))))\n", "  (map number->word (reverse (sort\
    \ (filter (lambda (x) (between? x 1 9)) arr) <))))\n", "  (map (lambda (x)\n \
    \         (cond\n            [(= x 1) \"One\"]\n            [(= x 2) \"Two\"]\n\
    \            [(= x 3) \"Three\"]\n            [(= x 4) \"Four\"]\n           \
    \ [(= x 5) \"Five\"]\n            [(= x 6) \"Six\"]\n            [(= x 7) \"Seven\"\
    ]\n            [(= x 8) \"Eight\"]\n            [(= x 9) \"Nine\"]))\n       (reverse\
    \ (sort (filter (lambda (x)\n                                 (and (>= x 1) (<=\
    \ x 9)))\n                              arr)))))\n```\n\n### 015. Maximum\n\n\
    Find the maximum integer in a list.\n\n- [x] Solve with Racket\n\n```racket\n\
    #lang racket\n", "  (reverse (map (lambda (x)\n                  (cond\n     \
    \               [(= x 1) \"One\"]\n                    [(= x 2) \"Two\"]\n   \
    \                 [(= x 3) \"Three\"]\n                    [(= x 4) \"Four\"]\n\
    \                    [(= x 5) \"Five\"]\n                    [(= x 6) \"Six\"\
    ]\n                    [(= x 7) \"Seven\"]\n                    [(= x 8) \"Eight\"\
    ]\n                    [(= x 9) \"Nine\"]\n                    [else \"Not a number\
    \ between 1 and 9 inclusive\"]))\n                (remove-duplicates (sort (filter\
    \ (lambda (x)\n                                                   (and (>= x 1)\
    \ (<= x 9)))\n                                                 arr)))))\n  )\n",
  "  (cond\n    [(empty? arr) (list)]\n    [(< (first arr) 1) (by_length (rest arr))]\n\
    \    [(> (first arr) 9) (by_length (rest arr))]\n    [else (append (by_length\
    \ (rest arr)) (list (show (first arr))))]))\n", "  (define (digits lst)\n    (cond\n\
    \      [(null? lst) '()]\n      [(= 1 (length lst)) (list (car lst))]\n      [else\
    \ (append (digits (car lst)) (digits (cdr lst)))]))\n  (define (str-digit d)\n\
    \    (cond\n      [(= 1 d) \"One\"]\n      [(= 2 d) \"Two\"]\n      [(= 3 d) \"\
    Three\"]\n      [(= 4 d) \"Four\"]\n      [(= 5 d) \"Five\"]\n      [(= 6 d) \"\
    Six\"]\n      [(= 7 d) \"Seven\"]\n      [(= 8 d) \"Eight\"]\n      [(= 9 d) \"\
    Nine\"]\n      [else \"\"]))\n  (define (filter d lst)\n    (cond\n      [(null?\
    \ lst) '()]\n      [(= d (car lst)) (cons d (filter d (cdr lst)))]\n      [else\
    \ (filter d (cdr lst))]))\n  (define (sort lst)\n    (cond\n      [(null? lst)\
    \ '()]\n      [else (cons (filter (car lst) lst) (sort (remv (car lst) lst)))]))\n\
    \  (define (str-sort lst)\n    (cond\n      [(null? lst) '()]\n      [else (cons\
    \ (str-digit (car lst)) (str-sort (cdr lst)))]))\n  (define (remv n lst)\n   \
    \ (cond\n      [(null? lst) '()]\n      [(= n (car lst)) (remv n (cdr lst))]\n\
    \      [else (cons (car lst) (remv n (cdr lst)))]))\n  (define (rev lst)\n   \
    \ (cond\n      [(null? lst) '()]\n      [else (append (rev (cdr lst)) (list (car\
    \ lst)))]))\n  (cond\n    [(null? arr) '()]\n    [else (rev (str-sort (sort (digits\
    \ arr))))]))", "  (if (empty? arr)\n      (list)\n      (reverse\n       (map\
    \ (\u03BB (n)\n              (cond\n                [(= n 1) \"One\"]\n      \
    \          [(= n 2) \"Two\"]\n                [(= n 3) \"Three\"]\n          \
    \      [(= n 4) \"Four\"]\n                [(= n 5) \"Five\"]\n              \
    \  [(= n 6) \"Six\"]\n                [(= n 7) \"Seven\"]\n                [(=\
    \ n 8) \"Eight\"]\n                [(= n 9) \"Nine\"]\n                [else \"\
    \"]))\n            (sort\n             (filter (\u03BB (n)\n                 \
    \      (and (<= 1 n) (<= n 9)))\n                     arr))))))\n", "  (for/list\
    \ ([a (sort arr < #:key (curry digit-to-string))])\n    (if (< 1 a 9)\n      \
    \  (number->string a)\n        \"*\")))", "  (define (solve arr)\n    (cond\n\
    \      [(empty? arr) '()]\n      [(> (first arr) 9) (solve (rest arr))]\n    \
    \  [(< (first arr) 1) (solve (rest arr))]\n      [else (cons (first arr) (solve\
    \ (rest arr)))]))\n  (define (get-key n)\n    (cond\n      [(eq? n 1) \"One\"\
    ]\n      [(eq? n 2) \"Two\"]\n      [(eq? n 3) \"Three\"]\n      [(eq? n 4) \"\
    Four\"]\n      [(eq? n 5) \"Five\"]\n      [(eq? n 6) \"Six\"]\n      [(eq? n\
    \ 7) \"Seven\"]\n      [(eq? n 8) \"Eight\"]\n      [(eq? n 9) \"Nine\"]))\n \
    \ (map get-key (reverse (solve arr))))\n", "  (filter (lambda (x) (and (<= x 9)\
    \ (>= x 1))) arr))\n", "  (map string-number->name (reverse (sort (filter (lambda\
    \ (x) (<= x 9) (<= 1 x)) arr) <))))\n", "  (map word-name\n       (reverse\n \
    \       (sort arr\n              (lambda (x y) (< x y))))))\n", "  (cond\n   \
    \ [(null? arr) (list)]\n    [(invalid-num? (car arr)) (by_length (cdr arr))]\n\
    \    [else (append (by_length (cdr arr)) (list (to-num (car arr))))]))\n", " \
    \ (reverse (map number->word\n                (sort arr\n                    \
    \  (lambda (x y)\n                        (< x y)))))\n  )\n", "  (let ([ordered\
    \ (sort arr <)])\n    (map\n     (lambda (x)\n       (cond\n         [(= x 1)\
    \ \"One\"]\n         [(= x 2) \"Two\"]\n         [(= x 3) \"Three\"]\n       \
    \  [(= x 4) \"Four\"]\n         [(= x 5) \"Five\"]\n         [(= x 6) \"Six\"\
    ]\n         [(= x 7) \"Seven\"]\n         [(= x 8) \"Eight\"]\n         [(= x\
    \ 9) \"Nine\"]\n         [else x]))\n     ordered)))\n", "  (for/list ([num (reverse\
    \ (sort arr (\u03BB (x y) (<= x y)))))\n              :when (and (>= num 1) (<=\
    \ num 9))]\n             #:when (positive? num)\n             #:break (positive?\
    \ num)\n             #:else false)\n  (map number->string num)))\n", "  (cond\n\
    \    [(empty? arr) empty]\n    [(empty? (remove (lambda (x) (and (<= 1 x) (<=\
    \ x 9))) arr)) empty]\n    [else\n     (replace\n      (reverse\n       (sort\
    \ (remove (lambda (x) (and (<= 1 x) (<= x 9))) arr) <))\n      (list \"One\" \"\
    Two\" \"Three\" \"Four\" \"Five\" \"Six\" \"Seven\" \"Eight\" \"Nine\"))]))",
  "  (map\n   (lambda (num)\n     (cond\n       [(= num 1) \"One\"]\n       [(= num\
    \ 2) \"Two\"]\n       [(= num 3) \"Three\"]\n       [(= num 4) \"Four\"]\n   \
    \    [(= num 5) \"Five\"]\n       [(= num 6) \"Six\"]\n       [(= num 7) \"Seven\"\
    ]\n       [(= num 8) \"Eight\"]\n       [(= num 9) \"Nine\"]))\n   (reverse (sort\
    \ (filter (lambda (num) (and (>= num 1) (<= num 9))) arr)))))\n", "  (if (empty?\
    \ arr)\n      '()\n      (cond\n        [(member (car arr) '(1 2 3 4 5 6 7 8 9))\
    \ (append (by_length (cdr arr)) (list (car arr)))]\n        [else (by_length (cdr\
    \ arr))])))\n", "  (define (by_length_helper helper-arr)\n    (cond\n      [(=\
    \ (length helper-arr) 0) (list)]\n      [(member (first helper-arr) (list 1 2\
    \ 3 4 5 6 7 8 9))\n       (append (by_length_helper (rest helper-arr)) (list (first\
    \ helper-arr)))]\n      [else (by_length_helper (rest helper-arr))]))\n  (reverse\
    \ (map number->string (by_length_helper arr))))", "  (reverse (map number->word\
    \ (filter number? (sort arr <)))))\n", "  (local [;; Converts an integer to the\
    \ equivalent string.\n          (define (int-to-str n)\n            (cond [(=\
    \ n 1) \"One\"]\n                  [(= n 2) \"Two\"]\n                  [(= n\
    \ 3) \"Three\"]\n                  [(= n 4) \"Four\"]\n                  [(= n\
    \ 5) \"Five\"]\n                  [(= n 6) \"Six\"]\n                  [(= n 7)\
    \ \"Seven\"]\n                  [(= n 8) \"Eight\"]\n                  [(= n 9)\
    \ \"Nine\"]))\n          ;; Given a list of integers, returns the same list with\
    \ all the integers\n          ;; converted to the equivalent string.\n       \
    \   (define (convert-all lst)\n            (if (null? lst)\n                null\n\
    \                (cons (int-to-str (car lst)) (convert-all (cdr lst)))))\n   \
    \       ;; Given a list of integers, returns all the integers between 1 and 9.\n\
    \          (define (filter-1-9 lst)\n            (cond [(null? lst) null]\n  \
    \                [(and (<= 1 (car lst)) (<= (car lst) 9)) (cons (car lst) (filter-1-9\
    \ (cdr lst)))]\n                  [else (filter-1-9 (cdr lst))]))\n          ;;\
    \ Given a list of integers, sorts them by length.\n          (define (sort-by-length\
    \ lst)\n            (local [(define (insert x lst)\n                      (cond\
    \ [(null? lst) (list x)]\n                            [(= x (car lst)) (cons x\
    \ lst)]\n                            [(< x (car lst)) (cons x lst)]\n        \
    \                    [else (cons (car lst) (insert x (cdr lst)))]))]\n       \
    \       (if (null? lst)\n                  null\n                  (insert (car\
    \ lst) (sort-by-length (cdr lst))))))])\n  (convert-all (sort-by-length (filter-1-9\
    \ arr))))\n", "  (map\n   (\u03BB (x)\n     (cond\n       [(= x 1) \"One\"]\n\
    \       [(= x 2) \"Two\"]\n       [(= x 3) \"Three\"]\n       [(= x 4) \"Four\"\
    ]\n       [(= x 5) \"Five\"]\n       [(= x 6) \"Six\"]\n       [(= x 7) \"Seven\"\
    ]\n       [(= x 8) \"Eight\"]\n       [(= x 9) \"Nine\"]))\n   (reverse (sort\
    \ (filter (\u03BB (x) (and (<= 1 x) (<= x 9))) arr)))))\n", "  (define (help arr)\n\
    \    (cond [(empty? arr) (list)]\n          [(= (first arr) 1) (append (list \"\
    One\") (help (rest arr)))]\n          [(= (first arr) 2) (append (list \"Two\"\
    ) (help (rest arr)))]\n          [(= (first arr) 3) (append (list \"Three\") (help\
    \ (rest arr)))]\n          [(= (first arr) 4) (append (list \"Four\") (help (rest\
    \ arr)))]\n          [(= (first arr) 5) (append (list \"Five\") (help (rest arr)))]\n\
    \          [(= (first arr) 6) (append (list \"Six\") (help (rest arr)))]\n   \
    \       [(= (first arr) 7) (append (list \"Seven\") (help (rest arr)))]\n    \
    \      [(= (first arr) 8) (append (list \"Eight\") (help (rest arr)))]\n     \
    \     [(= (first arr) 9) (append (list \"Nine\") (help (rest arr)))]\n       \
    \   [else (help (rest arr))]))\n  (reverse (help arr)))\n", "  (let ([len (length\
    \ arr)])\n    (cond\n      [(eq? 0 len) (list)]\n      [else\n       (let ([numbers-and-names\n\
    \              (apply append\n                     (for/list ([n (in-list arr)])\n\
    \                       (let ([number->name\n                              (lambda\
    \ (n)\n                                (cond\n                               \
    \   [(eq? n 1) \"One\"]\n                                  [(eq? n 2) \"Two\"\
    ]\n                                  [(eq? n 3) \"Three\"]\n                 \
    \                 [(eq? n 4) \"Four\"]\n                                  [(eq?\
    \ n 5) \"Five\"]\n                                  [(eq? n 6) \"Six\"]\n    \
    \                              [(eq? n 7) \"Seven\"]\n                       \
    \           [(eq? n 8) \"Eight\"]\n                                  [(eq? n 9)\
    \ \"Nine\"]\n                                  [else '()]))]\n               \
    \          (if (and (<= 1 n) (<= n 9))\n                             (list n (number->name\
    \ n))\n                             '())))])\n             [names (map second\
    \ numbers-and-names)]\n             [sorted-names (sort names <)])\n         (list->vector\
    \ (reverse sorted-names))))])))\n```", "  (for/list ((x (sort arr #:key (compose\
    \ (lambda (x) (- 10 x))\n                                         (guard (lambda\
    \ (x)\n                                                  (and (integer? x)\n \
    \                                                      (not (negative? x))\n \
    \                                                      (<= x 9))))))))\n    (integer->string\
    \ x)))\n", "  (define (name n)\n    (cond\n      [(= n 1) \"One\"]\n      [(=\
    \ n 2) \"Two\"]\n      [(= n 3) \"Three\"]\n      [(= n 4) \"Four\"]\n      [(=\
    \ n 5) \"Five\"]\n      [(= n 6) \"Six\"]\n      [(= n 7) \"Seven\"]\n      [(=\
    \ n 8) \"Eight\"]\n      [(= n 9) \"Nine\"]))\n  (map name (reverse (sort (filter\
    \ (lambda (x) (<= 1 x 9)) arr)))))\n", "  (define aa (filter number? arr))\n \
    \ (define sarr (sort aa <))\n  (define (name x)\n    (cond\n      [(= x 1) \"\
    One\"]\n      [(= x 2) \"Two\"]\n      [(= x 3) \"Three\"]\n      [(= x 4) \"\
    Four\"]\n      [(= x 5) \"Five\"]\n      [(= x 6) \"Six\"]\n      [(= x 7) \"\
    Seven\"]\n      [(= x 8) \"Eight\"]\n      [(= x 9) \"Nine\"]))\n  (define (to_name\
    \ arr)\n    (cond\n      [(null? arr) arr]\n      [else (cons (name (car arr))\
    \ (to_name (cdr arr)))]))\n  (reverse (to_name sarr)))\n", "  (cond\n    [(empty?\
    \ arr)\n     empty]\n    [(<= 1 (first arr) 9)\n     (cons (number->string (first\
    \ arr)) (by_length (rest arr)))]\n    [else\n     (by_length (rest arr))]))\n",
  "  (map (\u03BB (n) (cond [(= n 1) \"One\"]\n                     [(= n 2) \"Two\"\
    ]\n                     [(= n 3) \"Three\"]\n                     [(= n 4) \"\
    Four\"]\n                     [(= n 5) \"Five\"]\n                     [(= n 6)\
    \ \"Six\"]\n                     [(= n 7) \"Seven\"]\n                     [(=\
    \ n 8) \"Eight\"]\n                     [(= n 9) \"Nine\"]))\n       (reverse\
    \ (sort arr (\u03BB (a b) (< a b))))))\n```\n\n```racket\n#lang racket\n", " \
    \ (define (sort arr)\n    (cond [(empty? arr) '()]\n          [(< (first arr)\
    \ 10) (cons (first arr) (sort (rest arr)))]\n          [else (sort (rest arr))]))\n\
    \  (define (reverse arr)\n    (cond [(empty? arr) '()]\n          [else (append\
    \ (reverse (rest arr)) (list (first arr)))]))\n  (define (convert arr)\n    (cond\
    \ [(empty? arr) '()]\n          [(= (first arr) 1) (cons \"One\" (convert (rest\
    \ arr)))]\n          [(= (first arr) 2) (cons \"Two\" (convert (rest arr)))]\n\
    \          [(= (first arr) 3) (cons \"Three\" (convert (rest arr)))]\n       \
    \   [(= (first arr) 4) (cons \"Four\" (convert (rest arr)))]\n          [(= (first\
    \ arr) 5) (cons \"Five\" (convert (rest arr)))]\n          [(= (first arr) 6)\
    \ (cons \"Six\" (convert (rest arr)))]\n          [(= (first arr) 7) (cons \"\
    Seven\" (convert (rest arr)))]\n          [(= (first arr) 8) (cons \"Eight\" (convert\
    \ (rest arr)))]\n          [(= (first arr) 9) (cons \"Nine\" (convert (rest arr)))]\n\
    \          [else (convert (rest arr))]))\n  (convert (reverse (sort arr))))\n",
  "  (reverse (map (\u03BB (x) (case x\n                       [(1) \"One\"]\n   \
    \                    [(2) \"Two\"]\n                       [(3) \"Three\"]\n \
    \                      [(4) \"Four\"]\n                       [(5) \"Five\"]\n\
    \                       [(6) \"Six\"]\n                       [(7) \"Seven\"]\n\
    \                       [(8) \"Eight\"]\n                       [(9) \"Nine\"\
    ]))\n                 (sort (filter (\u03BB (x) (and (<= 1 x) (<= x 9))) arr)\
    \ <))))\n```\n\n```shell\n> (by_length (list 2 1 1 4 5 8 2 3))\n'(\"Eight\" \"\
    Five\" \"Four\" \"Three\" \"Two\" \"Two\" \"One\" \"One\")\n> (by_length (list\
    \ ))\n'()\n> (by_length (list 1 -1 55))\n'(\"One\")\n```\n\n## 3.3.3.3 splittest\n\
    \n```racket\n#lang racket\n", "  (cond [(null? arr) '()]\n        [(and (<= 1\
    \ (car arr)) (<= (car arr) 9))\n         (cons (list->string (list->symbol (string-append\
    \ \"digit-\" (integer->string (car arr)))))\n               (by_length (cdr arr)))]\n\
    \        [else (by_length (cdr arr))]))\n", "  (if (null? arr)\n      (list)\n\
    \      (cond\n        [(and (or (= (car arr) 1) (= (car arr) 2) (= (car arr) 3)\
    \ (= (car arr) 4) (= (car arr) 5) (= (car arr) 6) (= (car arr) 7) (= (car arr)\
    \ 8) (= (car arr) 9))\n              (or (not (or (= (car arr) 1) (= (car arr)\
    \ 2) (= (car arr) 3) (= (car arr) 4) (= (car arr) 5) (= (car arr) 6) (= (car arr)\
    \ 7) (= (car arr) 8) (= (car arr) 9))) (= (car arr) 1)))\n          (cons (cond\n\
    \                  [(= (car arr) 1) \"One\"]\n                  [(= (car arr)\
    \ 2) \"Two\"]\n                  [(= (car arr) 3) \"Three\"]\n               \
    \   [(= (car arr) 4) \"Four\"]\n                  [(= (car arr) 5) \"Five\"]\n\
    \                  [(= (car arr) 6) \"Six\"]\n                  [(= (car arr)\
    \ 7) \"Seven\"]\n                  [(= (car arr) 8) \"Eight\"]\n             \
    \     [(= (car arr) 9) \"Nine\"])\n                (by_length (cdr arr)))]\n \
    \       [else (by_length (cdr arr))])))\n", "  (define (digit->word)\n    (cond\n\
    \      ((= 0 i) \"Zero\")\n      ((= 1 i) \"One\")\n      ((= 2 i) \"Two\")\n\
    \      ((= 3 i) \"Three\")\n      ((= 4 i) \"Four\")\n      ((= 5 i) \"Five\"\
    )\n      ((= 6 i) \"Six\")\n      ((= 7 i) \"Seven\")\n      ((= 8 i) \"Eight\"\
    )\n      ((= 9 i) \"Nine\")))\n  (for/list ([i (in-list (filter (lambda (i)\n\
    \                                   (and (<= 1 i) (<= i 9)))\n               \
    \                  arr))])\n            (digit->word)))\n", "  (let ([r (cond\
    \ \n          [(= (length arr) 0) arr]\n          [(member (length arr) (list\
    \ 1 2 3 4 5 6 7 8 9)) arr]\n          [else (list (first arr))])])\n    (map (lambda\
    \ (n) (list-ref '(\"One\" \"Two\" \"Three\" \"Four\" \"Five\" \"Six\" \"Seven\"\
    \ \"Eight\" \"Nine\") (- n 1))) (reverse (sort r <)))))", "  (cond\n    [(empty?\
    \ arr) (list)]\n    [(empty? (rest arr))\n     (if (= 1 (first arr))\n       \
    \  (list \"One\")\n         (list))]\n    [else\n     (let ([start\n         \
    \   (remove (lambda (x) (not (= x 1))) arr)])\n       (let ([end\n           \
    \   (reverse\n               (map number->string (sort (remove (lambda (x) (not\
    \ (= x 1) (= x 2) (= x 3) (= x 4) (= x 5) (= x 6) (= x 7) (= x 8) (= x 9))) start))))])\n\
    \         end))]))\n", "  (cond [(empty? arr) empty]\n        [(not (num? (first\
    \ arr))) (by_length (rest arr))]\n        [(< (first arr) 1) (by_length (rest\
    \ arr))]\n        [(> (first arr) 9) (by_length (rest arr))]\n        [else (append\
    \ (by_length (rest arr)) (list (number->string (first arr))))]))\n", "    (cond\
    \ ((= (length arr) 0) '())\n          ((= (length arr) 1) (list\n            \
    \                    (cond ((= (car arr) 1) \"One\")\n                       \
    \               ((= (car arr) 2) \"Two\")\n                                  \
    \    ((= (car arr) 3) \"Three\")\n                                      ((= (car\
    \ arr) 4) \"Four\")\n                                      ((= (car arr) 5) \"\
    Five\")\n                                      ((= (car arr) 6) \"Six\")\n   \
    \                                   ((= (car arr) 7) \"Seven\")\n            \
    \                          ((= (car arr) 8) \"Eight\")\n                     \
    \                 ((= (car arr) 9) \"Nine\"))))\n          (else (reverse\n  \
    \                (map\n                    (lambda (el)\n                    \
    \  (cond ((= el 1) \"One\")\n                            ((= el 2) \"Two\")\n\
    \                            ((= el 3) \"Three\")\n                          \
    \  ((= el 4) \"Four\")\n                            ((= el 5) \"Five\")\n    \
    \                        ((= el 6) \"Six\")\n                            ((= el\
    \ 7) \"Seven\")\n                            ((= el 8) \"Eight\")\n          \
    \                  ((= el 9) \"Nine\")))\n                    (reverse (sort (filter\
    \ (lambda (el) (and (<= el 9) (>= el 1))) arr)))))))))", "  (cond [(null? arr)\
    \ '()]\n        [(<= 1 (car arr) 9) (cons (number->string (car arr)) (by_length\
    \ (cdr arr)))]\n        [else (by_length (cdr arr))]))\n", "    (cond\n      \
    \  [(empty? arr) empty]\n        [(not (integer? (car arr))) (by_length (cdr arr))]\n\
    \        [(< (car arr) 1) (by_length (cdr arr))]\n        [(> (car arr) 9) (by_length\
    \ (cdr arr))]\n        [else (append (list (convert-to-string (car arr))) (by_length\
    \ (cdr arr)))]))\n    ", "  (map (lambda (x)\n         (cond ((= x 1) \"One\"\
    )\n               ((= x 2) \"Two\")\n               ((= x 3) \"Three\")\n    \
    \           ((= x 4) \"Four\")\n               ((= x 5) \"Five\")\n          \
    \     ((= x 6) \"Six\")\n               ((= x 7) \"Seven\")\n               ((=\
    \ x 8) \"Eight\")\n               ((= x 9) \"Nine\")))\n       (reverse (sort\
    \ (filter (lambda (x)\n                                (and (<= 1 x) (<= x 9)))\n\
    \                              arr)\n                      <))))\n```\n* [Test\
    \ File](./test/test_1.rkt)\n\n### 2. Given two lists with N integers each, do\
    \ the following two tasks:\n```#lang racket\n", '  (filter number? arr))', " \
    \ (map (lambda (x)\n         (if (equal? x 1)\n             \"One\"\n        \
    \     (if (equal? x 2)\n                 \"Two\"\n                 (if (equal?\
    \ x 3)\n                     \"Three\"\n                     (if (equal? x 4)\n\
    \                         \"Four\"\n                         (if (equal? x 5)\n\
    \                             \"Five\"\n                             (if (equal?\
    \ x 6)\n                                 \"Six\"\n                           \
    \      (if (equal? x 7)\n                                     \"Seven\"\n    \
    \                                 (if (equal? x 8)\n                         \
    \                \"Eight\"\n                                         (if (equal?\
    \ x 9)\n                                             \"Nine\"\n              \
    \                               \"Not in the list!\"))))))))))\n       (reverse\
    \ (sort (filter (lambda (x) (and (>= x 1) (<= x 9))) arr) <))))", "  (for/list\
    \ ([i (in-list (sort (filter (\u03BB (x) (and (>= x 1) (<= x 9))) arr) <))])\n\
    \    (cond ((= i 1) \"One\")\n          ((= i 2) \"Two\")\n          ((= i 3)\
    \ \"Three\")\n          ((= i 4) \"Four\")\n          ((= i 5) \"Five\")\n   \
    \       ((= i 6) \"Six\")\n          ((= i 7) \"Seven\")\n          ((= i 8) \"\
    Eight\")\n          ((= i 9) \"Nine\"))))\n", "  (cond [(empty? arr) empty]\n\
    \        [(number? (first arr))\n         (append\n          (by_length (rest\
    \ arr))\n          (list (number->string (first arr))))]\n        [else\n    \
    \     (by_length (rest arr))]))\n```\n\n```racket\n#lang racket\n", "  (cond [(empty?\
    \ arr) empty]\n        [(and (integer? (first arr))\n              (or (= (first\
    \ arr) 1) (= (first arr) 2) (= (first arr) 3) (= (first arr) 4) (= (first arr)\
    \ 5) (= (first arr) 6) (= (first arr) 7) (= (first arr) 8) (= (first arr) 9)))\n\
    \          (append (by_length (rest arr)) (list (number->string (first arr))))]\n\
    \        [else (by_length (rest arr))]))", "  (if (null? arr)\n      '()\n   \
    \   (let ([ar (sort arr <)])\n        (map (lambda (x) (if (and (<= 1 x) (<= x\
    \ 9))\n                             (list-ref (list \"One\" \"Two\" \"Three\"\
    \ \"Four\" \"Five\" \"Six\" \"Seven\" \"Eight\" \"Nine\") (- x 1))\n         \
    \                    '())) ar))))", "  (cond [(empty? arr)\n         empty]\n\
    \        [(member (first arr) (list 1 2 3 4 5 6 7 8 9))\n         (append (by_length\
    \ (rest arr)) (list (translate (first arr))))]\n        [else\n         (by_length\
    \ (rest arr))]))\n", "  (let ((digits (map (\u03BB (x) (if (and (<= 1 x) (<= x\
    \ 9)) x)) arr)))\n    (define (is_digit x) (and (<= 1 x) (<= x 9)))\n    (define\
    \ (to_name x)\n      (if (= x 1) \"One\"\n          (if (= x 2) \"Two\"\n    \
    \          (if (= x 3) \"Three\"\n                  (if (= x 4) \"Four\"\n   \
    \                   (if (= x 5) \"Five\"\n                          (if (= x 6)\
    \ \"Six\"\n                              (if (= x 7) \"Seven\"\n             \
    \                     (if (= x 8) \"Eight\"\n                                \
    \      (if (= x 9) \"Nine\" x)))))))))))\n    (cond ((null? digits) (list))\n\
    \          (else (map to_name (reverse (sort digits <)))))))\n", "  (define (reverse-numbers\
    \ numbers)\n    (map string->number (reverse (map number->string numbers))))\n\
    \  (define (sort-numbers numbers)\n    (define (between? number)\n      (and (>=\
    \ number 1) (<= number 9)))\n    (sort numbers (lambda (a b)\n               \
    \     (and (between? a) (between? b) (< a b)))))\n  (define (numbers-to-strings\
    \ numbers)\n    (map number->string numbers))\n  (define (numbers-to-names numbers)\n\
    \    (define (number-to-name number)\n      (cond ((= number 1) \"One\")\n   \
    \         ((= number 2) \"Two\")\n            ((= number 3) \"Three\")\n     \
    \       ((= number 4) \"Four\")\n            ((= number 5) \"Five\")\n       \
    \     ((= number 6) \"Six\")\n            ((= number 7) \"Seven\")\n         \
    \   ((= number 8) \"Eight\")\n            ((= number 9) \"Nine\")))\n    (map\
    \ number-to-name numbers))\n  (numbers-to-names (reverse-numbers (sort-numbers\
    \ (map string->number arr)))))", "  (define (number->name n)\n    (cond ((= n\
    \ 1) \"One\")\n          ((= n 2) \"Two\")\n          ((= n 3) \"Three\")\n  \
    \        ((= n 4) \"Four\")\n          ((= n 5) \"Five\")\n          ((= n 6)\
    \ \"Six\")\n          ((= n 7) \"Seven\")\n          ((= n 8) \"Eight\")\n   \
    \       ((= n 9) \"Nine\")))\n  (define (in-range? n)\n    (and (&lt;= 1 n) (&lt;=\
    \ n 9)))\n  (define (sort-filter arr)\n    (sort arr (lambda (a b) (&lt; a b))))\n\
    \  (define (apply-name arr)\n    (map number->name arr))\n  (define (filter-in-range\
    \ arr)\n    (filter in-range? arr))\n  (apply-name (sort-filter (filter-in-range\
    \ arr))))\n</code>\n", "  (define (output val)\n    (cond\n      [(= val 1) \"\
    One\"]\n      [(= val 2) \"Two\"]\n      [(= val 3) \"Three\"]\n      [(= val\
    \ 4) \"Four\"]\n      [(= val 5) \"Five\"]\n      [(= val 6) \"Six\"]\n      [(=\
    \ val 7) \"Seven\"]\n      [(= val 8) \"Eight\"]\n      [(= val 9) \"Nine\"]))\n\
    \  (if (null? arr)\n      (list)\n      (if (and (<= 1 (car arr)) (<= (car arr)\
    \ 9))\n          (reverse (map output (sort (filter (lambda (n) (and (<= 1 n)\
    \ (<= n 9))) arr))))\n          (by_length (cdr arr)))))\n", "  (define (dig_to_str\
    \ n)\n    (cond [(= n 1) \"One\"]\n          [(= n 2) \"Two\"]\n          [(=\
    \ n 3) \"Three\"]\n          [(= n 4) \"Four\"]\n          [(= n 5) \"Five\"]\n\
    \          [(= n 6) \"Six\"]\n          [(= n 7) \"Seven\"]\n          [(= n 8)\
    \ \"Eight\"]\n          [(= n 9) \"Nine\"]\n          [else \"\" ]))\n  (cond\
    \ [(empty? arr) empty]\n        [(member (first arr) (list 1 2 3 4 5 6 7 8 9))\n\
    \         (append (by_length (rest arr)) (list (dig_to_str (first arr))))]\n \
    \       [else (by_length (rest arr))]))\n", "  (if (equal? arr '())\n      '()\n\
    \      (cond [(and (&lt;= 1 (car arr)) (&lt;= (car arr) 9))\n             (cons\
    \ (number-&gt;string (car arr)) (by_length (cdr arr)))]\n            [else (by_length\
    \ (cdr arr))])))\n", "  (apply append\n         (for/list ([num (in-list (sort\
    \ (filter (lambda (x) (and (>= x 1) (<= x 9))) arr)))])\n           (list (cond\n\
    \                    ((= num 1) \"One\")\n                    ((= num 2) \"Two\"\
    )\n                    ((= num 3) \"Three\")\n                    ((= num 4) \"\
    Four\")\n                    ((= num 5) \"Five\")\n                    ((= num\
    \ 6) \"Six\")\n                    ((= num 7) \"Seven\")\n                   \
    \ ((= num 8) \"Eight\")\n                    ((= num 9) \"Nine\"))))))\n", " \
    \ (filter odd? arr))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
