name: HumanEval_89_encrypt
language: rkt
prompt: "#lang racket\n\n;; Create a function encrypt that takes a string as an argument\
  \ and\n;; returns a string encrypted with the alphabet being rotated. \n;; The alphabet\
  \ should be rotated in a manner such that the letters \n;; shift down by two multiplied\
  \ to two places.\n;; For example:\n;; >>> (encrypt \"hi\")\n;; \"lm\"\n;; >>> (encrypt\
  \ \"asdfghjkl\")\n;; \"ewhjklnop\"\n;; >>> (encrypt \"gf\")\n;; \"kj\"\n;; >>> (encrypt\
  \ \"et\")\n;; \"ix\"\n(define (encrypt s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encrypt))\n\
  \    (check-equal? (candidate \"hi\") \"lm\")\n    (check-equal? (candidate \"asdfghjkl\"\
  ) \"ewhjklnop\")\n    (check-equal? (candidate \"gf\") \"kj\")\n    (check-equal?\
  \ (candidate \"et\") \"ix\")\n    (check-equal? (candidate \"faewfawefaewg\") \"\
  jeiajeaijeiak\")\n    (check-equal? (candidate \"hellomyfriend\") \"lippsqcjvmirh\"\
  )\n    (check-equal? (candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
  ) \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\n    (check-equal? (candidate\
  \ \"a\") \"e\")\n))\n\n(test-humaneval)"
completions: ["  (map (lambda (c) (char-downcase (rotate-char c (- (* 2 2))))) s))\n",
  "  (let ((map (build-map s)))\n    (map (lambda (x) (map-get map x '())) s)))\n",
  "  (for/list ([i (in-list s)])\n    (integer->char (modulo (+ (char->integer i)\
    \ 4) 26) )))", "  (let\n      ;; create an encryption table\n      ((table\n \
    \       (make-encrypt-table)\n        ))\n    (if (string? s)\n        (build-string\
    \ s table)\n        s)))\n", "  (cond [(string=? s \"\") \"\"]\n        [else\
    \ (string-append (string (rotate-letter (string-ref s 0)))\n                 \
    \            (encrypt (substring s 1)))]))\n", "  (define (encrypt-sub s acc)\n\
    \    (if (string-empty? s)\n        acc\n        (encrypt-sub (substring s 1 (string-length\
    \ s))\n                     (string-append acc\n                             \
    \       (char-downcase (string-ref s 0))\n                                   \
    \ (char-upcase (string-ref s 0))))))\n  (encrypt-sub s \"\"))\n", "  (define (helper\
    \ s len)\n    (if (&lt;= len 0)\n        \"\"\n        (if (char-numeric? (string-ref\
    \ s 0))\n            (string-&gt;number\n             (string (char-&gt;integer\
    \ (string-ref s 0))))\n            (string (char-&gt;integer (string-ref s 0)))\n\
    \            (+ 2 (* 2 2))\n            (string-append (helper (substring s 1)\
    \ (- len 1))))))\n  (helper s (string-length s)))\n</code>\nQuestion:\nThe function\
    \ encrypt is not working. Any suggestions?\n\n\nA:\n\nI would do it with a generator\
    \ instead of recursion. I would also not over-complicate things by trying to work\
    \ with individual characters, because then you need to deal with when you move\
    \ past the last character of the alphabet, etc. Instead I would simply go with\
    \ a shift number and the index of the character:\n<code>(define (shift str shift-num)\n\
    \  (for/list ([i (in-range (string-length str))])\n    (integer-&gt;char (+ shift-num\
    \ (char-&gt;integer (string-ref str i))))))\n</code>\nI get:\n<code>(shift \"\
    ABCDE\" 2)\n=&gt; '#(\"CDEFG\")\n</code>\n", "  (if (null? s)\n      \"\"\n  \
    \    (if (= #\\a (char-downcase (car s)))\n          (string-append (encrypt (cdr\
    \ s)) #\\b)\n          (if (= #\\b (char-downcase (car s)))\n              (string-append\
    \ (encrypt (cdr s)) #\\c)\n              (if (= #\\y (char-downcase (car s)))\n\
    \                  (string-append (encrypt (cdr s)) #\\a)\n                  (if\
    \ (= #\\z (char-downcase (car s)))\n                      (string-append (encrypt\
    \ (cdr s)) #\\b)\n                      (string-append (encrypt (cdr s))\n   \
    \                                  (char-downcase (car s)))))))))\n", "  (let\
    \ loop ([s s]\n             [lst (string->list s)])\n    (if (null? lst)\n   \
    \     (list->string s)\n        (begin\n          (set-car! s (+ (car lst) 2))\n\
    \          (loop s (cdr lst))))))\n", "  (let loop ([ls s] [rs '()])\n    (cond\
    \ [(null? ls) (list->string (reverse rs))]\n          [else (loop (cdr ls)\n \
    \                     (cons (alphabet (alphabet (car ls))) rs))])))\n", "  (map\
    \ (lambda (c)\n         (define new-char (add1 (add1 c)))\n         (if (&gt;\
    \ new-char #\\z)\n             (sub1 new-char)\n           new-char))\n      \
    \ s))\n</code>\nThis does not work and I'm not sure why. When I run it in DrRacket\
    \ it says:\n<code>Welcome to DrRacket, version 6.7 [3m].\nLanguage: racket, with\
    \ debugging; memory limit: 128 MB.\n\n&gt; (define (encrypt s)\n    (map (lambda\
    \ (c)\n           (define new-char (add1 (add1 c)))\n           (if (&gt; new-char\
    \ #\\z)\n               (sub1 new-char)\n             new-char))\n         s))\n\
    &gt; (encrypt \"hi\")\n. . .: map: expects type &lt;a b&gt; as 2nd argument, given:\
    \ #\\h; other arguments were: #&lt;procedure:...ypt$encrypt$lambda&gt;\n  Type\
    \ Checker: type mismatch\n   expected: (All (a b) (Listof a))\n   given: String\n\
    \   in: (map (encrypt$encrypt$lambda) s)\n   context...:\n    /Users/allen/code/codeschool/functional-javascript/functional.rkt:2:2:\
    \ add1\n    /Users/allen/code/codeschool/functional-javascript/functional.rkt:2:2:\
    \ encrypt$encrypt$lambda\n    /Users/allen/code/codeschool/functional-javascript/functional.rkt:1:0:\
    \ encrypt\n  [,bt for context]\n\n&gt; \n</code>\nWhat is the issue here? How\
    \ do I make it work?\n\n\nA:\n\nThe <code>add1</code> function is only defined\
    \ for numbers and not characters, so your function fails when it hits a character\
    \ (since it throws an error at the <code>add1</code> call).\nYou can use <code>char-&gt;integer</code>\
    \ and <code>integer-&gt;char</code> to convert between them:\n<code>(define (encrypt\
    \ s)\n", "  (let ([table (make-hash)])\n    (for ([i (in-range 26)])\n      (hash-set!\
    \ table (string-ref \"abcdefghijklmnopqrstuvwxyz\" i)\n                (string-ref\
    \ \"cdefghijklmnopqrstuvwxyzab\" i)))\n    (string-map (lambda (c) (hash-ref table\
    \ c #f)) s)))\n", "  (define (helper s i)\n    (if (eq? i (string-length s))\n\
    \        \"\"\n        (begin\n          (string-append (string (string-ref s\
    \ i)) (helper s (+ i 1)))\n          )\n        )\n    )\n  (helper s 0)\n  )\n",
  "  (define (replace-with-encryption f s)\n    (cond ((eq? (string-length s) 0) \"\
    \")\n          ((char=? #\\a (string-ref s 0)) \"c\")\n          ((char=? #\\\
    b (string-ref s 0)) \"d\")\n          ((char=? #\\c (string-ref s 0)) \"e\")\n\
    \          ((char=? #\\d (string-ref s 0)) \"f\")\n          ((char=? #\\e (string-ref\
    \ s 0)) \"g\")\n          ((char=? #\\f (string-ref s 0)) \"h\")\n          ((char=?\
    \ #\\g (string-ref s 0)) \"i\")\n          ((char=? #\\h (string-ref s 0)) \"\
    j\")\n          ((char=? #\\i (string-ref s 0)) \"k\")\n          ((char=? #\\\
    j (string-ref s 0)) \"l\")\n          ((char=? #\\k (string-ref s 0)) \"m\")\n\
    \          ((char=? #\\l (string-ref s 0)) \"n\")\n          ((char=? #\\m (string-ref\
    \ s 0)) \"o\")\n          ((char=? #\\n (string-ref s 0)) \"p\")\n          ((char=?\
    \ #\\o (string-ref s 0)) \"q\")\n          ((char=? #\\p (string-ref s 0)) \"\
    r\")\n          ((char=? #\\q (string-ref s 0)) \"s\")\n          ((char=? #\\\
    r (string-ref s 0)) \"t\")\n          ((char=? #\\s (string-ref s 0)) \"u\")\n\
    \          ((char=? #\\t (string-ref s 0)) \"v\")\n          ((char=? #\\u (string-ref\
    \ s 0)) \"w\")\n          ((char=? #\\v (string-ref s 0)) \"x\")\n          ((char=?\
    \ #\\w (string-ref s 0)) \"y\")\n          ((char=? #\\x (string-ref s 0)) \"\
    z\")\n          ((char=? #\\y (string-ref s 0)) \"a\")\n          ((char=?", " \
    \ (for/list ([i (in-range (string-length s))])\n    (string-ref (rotate-string\
    \ s (* 2 i)) i)))\n", "  (for/fold ([acc \"\"]) ([ch (in-string s)])\n    (string-append\
    \ acc (encrypt-char ch))))\n", "  (build-string (string-length s)\n          \
    \      (lambda (n)\n                  (let ([cc (string-ref s n)])\n         \
    \           (if (and (&lt;= #\\a cc) (&lt;= cc #\\z))\n                      \
    \  (+ cc (* 2 2))\n                      cc)))))\n</code>\nThis is the step1.rkt\
    \ file\n<code>#lang racket", "  (if (null? s) \"\"\n    (let ([char (car s)])\n\
    \      (string-append (encrypt (cdr s))\n\t\t     (rotate-char-1 char 2 'a)))))\n",
  "  (define (shift-one s)\n    (define a '#\\a)\n    (define (shift-one-char c)\n\
    \      (if (and (&lt;= a c) (&lt;= c '#\\z))\n          (+ c 2)\n          c))\n\
    \    (string-map shift-one-char s))\n  (shift-one s))\n", "  (string-map (lambda\
    \ (x)\n                (int->char (+ x (* 2 2))))\n              s))\n</code>\n\
    However, I'm getting this error:\n<code>string-map: contract violation\n  expected:\
    \ string?\n  given: #&lt;procedure:exn:fail:contract&gt;\n  argument position:\
    \ 1st\n  other arguments...:\n   \"string-map\"\n</code>\nIf I try this:\n<code>#lang\
    \ racket\n", "  (string-append\n   (substring s 0 1)\n   (substring s 3 1)\n \
    \  (substring s 1 1)\n   (substring s 5 1)\n   (substring s 2 1)\n   (substring\
    \ s 6 1)\n   (substring s 4 1)))\n", "  (if (empty? s)\n      \"\"\n      (string-append\
    \ (list->string (list (integer->char (+ (char->integer (string-ref s 0)) 2))))\
    \ (encrypt (substring s 1)))))\n", "  (local [(define alphabet \"abcdefghijklmnopqrstuvwxyz\"\
    )\n          (define (rotate c)\n            (let [(index (string-index alphabet\
    \ c))]\n              (if (= index 26)\n                  #\\a\n             \
    \     (string-ref alphabet (+ 2 index)))))\n          (define (encrypt-helper\
    \ s)\n            (if (empty? s) empty\n                (cons (rotate (first s))\
    \ (encrypt-helper (rest s)))))\n          ]\n    (string->list (encrypt-helper\
    \ (string->list s)))))\n", "  (let ([c (string->list s)])\n    (list->string (map\
    \ (lambda (c)\n                         (if (char-alphabetic? c)\n           \
    \                  (let ([n (char->integer c)])\n                            \
    \   (integer->char (modulo (+ n (* 2 2)) 26)))\n                             c))\n\
    \                       c))))\n", "  (string-append\n   (substring s 1)\n   (substring\
    \ s 0 1)))\n", "  (map (lambda (c) (rotate-char c 2)) s))\n", "  (cond\n    [(empty?\
    \ s) (make-string 0)]\n    [else\n     (string-append\n      (string-append\n\
    \       (string (char (modulo (+ (- (char-downcase (first s)) 97) 8) 26)))\n \
    \      (string (char (modulo (+ (- (char-downcase (first s)) 97) 10) 26))))\n\
    \      (encrypt (rest s)))]))\n", "  (letrec ([new-s s]\n           [inc (index-of\
    \ new-s)]\n           [index (lambda (x) (modulo (+ (* 2 x) 2) 26))])\n    (cond\
    \ [(empty? s) (void)]\n          [else (append (list-ref \"abcdefghijklmnopqrstuvwxyz\"\
    \ (index inc))\n                        (encrypt (rest s)))])))\n", "  (string-append\n\
    \   (string-append (string-append (string-append (string-take s 0)\n\t\t\t\t\t\
    \       (string-drop s (+ 2 (string-length s))))\n\t\t\t\t (string-take s 0))\n\
    \t\t  (string-drop s (+ 2 (string-length s))))\n   (string-append (string-append\
    \ (string-append (string-take s 1)\n\t\t\t\t\t       (string-drop s (+ 2 (string-length\
    \ s))))\n\t\t\t\t (string-take s 1))\n\t\t  (string-drop s (+ 2 (string-length\
    \ s))))))\n  ", "  (cond\n    [(equal? (string-length s) 0) \"\"]\n    [else\n\
    \     (string-append\n      (char-&gt;string\n       (modulo (+ (char-&gt;integer\
    \ (string-ref s 0)) 8) 128))\n      (encrypt (substring s 1)))]))\n</code>\n",
  "  (if (equal? s \"\")\n      \"\"\n      (string-append (string-append (string-append\
    \ (substring s 0 1)\n                                                   (substring\
    \ s 1 2))\n                                    (substring s 2 3))\n          \
    \           (encrypt (substring s 3)))))\n", "  (string-append\n   (map\n    (lambda\
    \ (c)\n      (if (char-alphabetic? c)\n          (if (>= c #\\l)\n           \
    \   (char (+ (char-downcase c) 2))\n            (char (- (char-downcase c) 24)))\n\
    \        c))\n    s)))\n", "  (string-join (map\n                (lambda (x) (string\
    \ (+ 2 (* 2 (char->integer x)))))\n                (string->list s))\n       \
    \        \"\"))\n", "  (define (lookup c)\n    (string-ref (string-append \"abcdefghijklmnopqrstuvwxyz\"\
    \n                               \"abcdefghijklmnopqrstuvwxyz\")\n           \
    \     (+ (modulo (- (string-ref s c) 97) 26) 8)))\n  (string-map lookup (build-list\
    \ (string-length s)\n                                 (lambda (c) c))))\n", " \
    \ (cond\n    [(empty? s) \"\"]\n    [else\n     (string-append (string (alphabet-rotate\
    \ (char->integer (string-ref s 0)) 2))\n\t\t    (encrypt (substring s 1)))]))\n",
  "  (local ((define (rotate n x)\n             (if (= n 0) x\n               (rotate\
    \ (- n 1) (list (cdr x) (car x))))))\n    (for/list ([c s])\n      (rotate (*\
    \ 2 2) c))))\n", "  (regexp-replace*\n   #rx\"[a-z]\"\n   s\n   (\u03BB (s)\n\
    \     (let* ([s-ch (string-&gt;char s)]\n            [s-ch-code (+ s-ch (* 2 2))])\n\
    \       (if (and (&lt;= (char-&gt;integer #\\a) s-ch-code)\n                (&lt;=\
    \ s-ch-code (char-&gt;integer #\\z)))\n           (integer-&gt;char s-ch-code)\n\
    \         s-ch)))))\n</code>\n", "  (cond\n    [(empty? s) \"\"]\n    [else\n\
    \     (define new-chr (+ 2 (* 2 (char->integer (string-ref s 0)))))\n     (string-append\
    \ (integer->char new-chr) (encrypt (substring s 1)))]))\n", "  ;; We need to first\
    \ figure out the length of the string. Since the\n  ;; string is a list, we can\
    \ use the length function.\n  (let ((len (length s)))\n    ;; Create a new list\
    \ of the same length of the passed string.\n    (let ((lst (make-list len)))\n\
    \      ;; Fill the list with the same string, but in this case, the\n      ;;\
    \ characters are changed to numbers from 0 to 25.\n      (for ([i (in-range len)])\n\
    \        (set! (list-ref lst i) (char->integer (string-ref s i))))\n      ;; Map\
    \ the list so that each element has two subtracted, and then\n      ;; multiplied\
    \ by two.\n      (let ((result (map (lambda (x) (- (* 2 x) 2)) lst)))\n      \
    \  ;; For each integer in the new list, change them back to\n        ;; characters,\
    \ and append them to a new string.\n        (for ([i (in-range len)])\n      \
    \    (set! s (string-append s (integer->char (list-ref result i))))\n        \
    \  (set! s (substring s len)))\n        ;; Return the string, but only the last\
    \ len characters, since\n        ;; the first len characters are the original\
    \ string.\n        s))))\n", "  (define (rotate)\n    (define (change-char n)\n\
    \      (cond\n        ((< n 65) (+ n 130))\n        ((> n 90) (- n 90))\n    \
    \    (else (modulo (+ n 8) 26))))\n    (define (recur s)\n      (cond\n      \
    \  ((empty? s) empty)\n        (else (cons (change-char (char->integer (first\
    \ s)))\n                    (recur (rest s))))))\n    (recur s))\n  (integer->char\
    \ (rotate)))\n", "  (let ([str_ls (string->list s)])\n    (list->string (map (lambda\
    \ (x) (if (&lt;= x #\\a) (+ x (+ 2 2)) (+ x (- 2 2)))) str_ls))))", "  (string-append\
    \ (string-append s s)))\n", "  (map (lambda (c)\n         (integer->char (+ c\
    \ (* 2 2))))\n       (string->list s)))\n```\n\n### Sample solution 2\n\n```racket\n\
    #lang racket\n", "  (let ([s (string->list s)])\n    (map char-downcase s)))\n",
  "  (let ([alphabet (string->list \"abcdefghijklmnopqrstuvwxyz\")])\n    (list->string\n\
    \     (map\n      (lambda (x)\n        (list-ref alphabet (+ x (* 2 2))))\n  \
    \    (map char->integer (string->list s))))))\n```\n\n```racket\n#lang racket\n",
  "  (define (int-of-char c)\n    (- (char->integer c) (char->integer #\\a)))\n  (define\
    \ (char-of-int n)\n    (integer->char (+ (char->integer #\\a) n)))\n  (define\
    \ (convert-char c)\n    (cond\n      [(char=? c #\\a) (char-of-int 2)]\n     \
    \ [(char=? c #\\b) (char-of-int 4)]\n      [(char=? c #\\c) (char-of-int 6)]\n\
    \      [(char=? c #\\d) (char-of-int 8)]\n      [(char=? c #\\e) (char-of-int\
    \ 10)]\n      [(char=? c #\\f) (char-of-int 12)]\n      [(char=? c #\\g) (char-of-int\
    \ 14)]\n      [(char=? c #\\h) (char-of-int 16)]\n      [(char=? c #\\i) (char-of-int\
    \ 18)]\n      [(char=? c #\\j) (char-of-int 20)]\n      [(char=? c #\\k) (char-of-int\
    \ 22)]\n      [(char=? c #\\l) (char-of-int 24)]\n      [(char=? c #\\m) (char-of-int\
    \ 26)]\n      [(char=? c #\\n) (char-of-int 28)]\n      [(char=? c #\\o) (char-of-int\
    \ 30)]\n      [(char=? c #\\p) (char-of-int 32)]\n      [(char=? c #\\q) (char-of-int\
    \ 34)]\n      [(char=? c #\\r) (char-of-int 36)]\n      [(char=? c #\\s) (char-of-int\
    \ 38)]\n      [(char=? c #\\t) (char-of-int 40)]\n      [(char=? c #\\u) (char-of-int\
    \ 42)]\n      [(char=? c #\\v) (char-of-int 44)]\n      [(char=? c #\\w) (char-of-int\
    \ 46)]\n     ", "  (map\n   (lambda (x)\n     (define n (- x 97))\n     (define\
    \ (n-minus-two x)\n       (if (= x 0)\n           24\n           (if (= x 1)\n\
    \               25\n               (- x 2))))\n     (define x2 (+ 97 (n-minus-two\
    \ n)))\n     (number->string x2))\n   (string->list s)))\n", "  (define (rotate\
    \ s)\n    (let ([l (string->list s)])\n      (reverse (rest (reverse (rest l))))))\n\
    \  (define (last-two s)\n    (define (rotate s)\n      (let ([l (string->list\
    \ s)])\n\t(reverse (rest (reverse (rest l))))))\n    (list-ref (rotate s) (- (string-length\
    \ s) 2)))\n  (define (two-more s)\n    (string-append s (string-append (string\
    \ (last-two s)) (string (last-two s)))))\n  (define (do-encrypt s)\n    (string-append\n\
    \     (map (lambda (i)\n\t    (list-ref (rotate (two-more s)) (- i 1)))\n\t  (string->list\
    \ s))))\n  (do-encrypt s))\n", "  (build-string (string-length s)\n          \
    \      (lambda (i)\n                  (let* ((ch (string-ref s i))\n         \
    \                (normalized-i (modulo (+ i (* 2 2)) 26)))\n                 \
    \   (integer->char (+ normalized-i (char->integer #\\a)))))))", "  (define (helper\
    \ c)\n    (if (char=? c #\\a)\n        #\\c\n        (if (char=? c #\\b)\n   \
    \         #\\d\n            (if (char=? c #\\c)\n                #\\e\n      \
    \          (if (char=? c #\\d)\n                    #\\f\n                   \
    \ (if (char=? c #\\e)\n                        #\\g\n                        (if\
    \ (char=? c #\\f)\n                            #\\h\n                        \
    \    (if (char=? c #\\g)\n                                #\\i\n             \
    \                   (if (char=? c #\\h)\n                                    #\\\
    j\n                                    (if (char=? c #\\i)\n                 \
    \                       #\\k\n                                        (if (char=?\
    \ c #\\j)\n                                            #\\l\n                \
    \                            (if (char=? c #\\k)\n                           \
    \                     #\\m\n                                                (if\
    \ (char=? c #\\l)\n                                                    #\\n\n\
    \                                                    (if (char=? c #\\m)\n   \
    \                                                     #\\o\n                 \
    \                                       (if (char=? c #\\n)\n                \
    \                                            #\\p\n                          \
    \                                  (if (char=? c #\\o)\n                     \
    \                                           #\\q\n                           \
    \                                     (if (char=? c #\\p)\n                  \
    \                                                  #\\r\n                    \
    \                                                (if (char=? c #\\q)\n       \
    \                                                                 #\\s\n     \
    \                                                                   (if (char=?\
    \ c #\\r)\n                                                                  \
    \          #\\t\n                                                            \
    \                (if (char=? c #\\s)\n                                       \
    \                                         #\\u\n                             \
    \                                                   (if (char=? c #\\t)\n    \
    \                                                                            \
    \    #\\v\n                                                                  \
    \                  (if (char=? c #\\u)\n                                     \
    \                                                   #\\w\n                   \
    \                                                                     (if (char=?\
    \ c #\\v)\n                                                                  \
    \                          #\\x\n                                            \
    \                                                (if (char=? c #\\w)\n       \
    \                                         ", "    (define (map f l)\n        (if\
    \ (null? l)\n            (quote ())\n            (cons (f (car l)) (map f (cdr\
    \ l)))))\n    (define (shift-char c)\n        (integer->char (+ (char->integer\
    \ c) 4)))\n    (list->string (map shift-char (string->list s))))\n```\n\nWhen\
    \ we try to run the code with the `(encrypt \"hi\")` function,\nwe get the following\
    \ error:\n\n```racket\nWelcome to DrRacket, version 6.7 [3m].\nLanguage: racket\
    \ [custom]; memory limit: 128 MB.\n\"(encrypt \\\"hi\\\")\"", "  (define (plus-two\
    \ x)\n    (cond ((< x 122) (+ x 2))\n          (else (- x 24))))\n  (map plus-two\
    \ (string->list s)))\n", "  (for/fold ([s (string->list s)])\n            ([c\
    \ (in-list s)])\n            (string-append (list c)\n                       \
    \    (cond\n                             [(char=? c #\\a) #\\c]\n            \
    \                 [(char=? c #\\b) #\\d]\n                             [(char=?\
    \ c #\\c) #\\e]\n                             [(char=? c #\\d) #\\f]\n       \
    \                      [(char=? c #\\e) #\\g]\n                             [(char=?\
    \ c #\\f) #\\h]\n                             [(char=? c #\\g) #\\i]\n       \
    \                      [(char=? c #\\h) #\\j]\n                             [(char=?\
    \ c #\\i) #\\k]\n                             [(char=? c #\\j) #\\l]\n       \
    \                      [(char=? c #\\k) #\\m]\n                             [(char=?\
    \ c #\\l) #\\n]\n                             [(char=? c #\\m) #\\o]\n       \
    \                      [(char=? c #\\n) #\\p]\n                             [(char=?\
    \ c #\\o) #\\q]\n                             [(char=? c #\\p) #\\r]\n       \
    \                      [(char=? c #\\q) #\\s]\n                             [(char=?\
    \ c #\\r) #\\t]\n                             [(char=? c #\\s) #\\u]\n       \
    \                      [(char=? c #\\t) #\\v]\n                             [(char=?\
    \ c #\\u) #\\w]\n                             [(char=? c #\\v) #\\x]\n       \
    \                      [(char=? c #\\w) #\\y]\n                             [(char=?\
    \ c #\\x) #\\z]\n                             [(char=? c #\\y) #\\a]\n       \
    \                      [(char=? c #\\z) #\\b]\n                             [else\
    \ \"\"])))\n  )", "  (cond [(empty? s) empty]\n        [else (cons (rotate-char\
    \ (first s))\n                    (encrypt (rest s)))]))\n", '  (string-append
    s s))', "  (define (rotate str)\n    (string-append (substring str 2) (substring\
    \ str 0 2)))\n  (apply string (map (lambda (c)\n                       (cond ((and\
    \ (&lt;= #\\a c) (&lt;= c #\\z)) (char-downcase (rotate c)))\n               \
    \              ((and (&lt;= #\\A c) (&lt;= c #\\Z)) (char-upcase (rotate c)))\n\
    \                             (else c)))\n                     s)))\n</code>\n",
  "  (define (helper s result-string)\n    (if (string=? s \"\")\n        result-string\n\
    \        (helper (substring s 1 (string-length s))\n                (string-append\
    \ result-string \n                               (string (integer->char\n    \
    \                                    (+ (char->integer (string-ref s 0))\n   \
    \                                        (* 2 2))))))))\n  (helper s \"\"))\n",
  "  (string-join\n   (map\n    (lambda (x) (string (modulo (+ x (- (char->integer\
    \ #\\a) 2) (* (char->integer x) 2)) 26) (+ (char->integer #\\a) 2)))\n    (string->list\
    \ s))))\n", "  (for/list ([ch (in-string s)])\n    (let ((ch-code (char->integer\
    \ ch)))\n      (when (and (<= 97 ch-code) (<= ch-code 110))\n        (set! ch-code\
    \ (+ ch-code 2)))\n      (when (> ch-code 110)\n        (set! ch-code (- ch-code\
    \ 24)))\n      (integer->char ch-code))))\n", "  (map (lambda (c)\n         (if\
    \ (= c #\\z)\n             #\\a\n             (if (= c #\\y)\n               \
    \  #\\z\n                 (char (+ c 2)))))\n       s))\n</code>\nBut I get an\
    \ error <code>bad syntax</code> in <code>racket</code> and <code>unbound identifier\
    \ in module</code> in <code>drracket</code>.\nHow can I fix it?\n\n\nA:\n\n<code>char</code>\
    \ is a special form, not a function. As such, you can't apply it like a function\
    \ and you can't use it like a value, which is what <code>map</code> expects. The\
    \ <code>integer-&gt;char</code> function is the correct one to use for what you're\
    \ trying to do.\nAlso, you need to use <code>string-&gt;list</code> and <code>list-&gt;string</code>\
    \ to turn a string into a list of characters, map over the list, and then turn\
    \ the resulting list back into a string.\n", "  (map (lambda (c) (+ (- c 32) (*\
    \ 2 2))) s))\n", "  (map (lambda (x) (if (&lt; x 97) (+ x 24) x))\n       (map\
    \ (lambda (x) (if (&lt; x 123) (+ x 2) x))\n            (map char-&gt;integer\
    \ s))))\n", "  (string-map\n   (lambda (c)\n     (if (char-alpha? c)\n       \
    \  (let* ([a (char->integer 'a)]\n                [z (char->integer 'z)]\n   \
    \             [c (char->integer c)]\n                [d (- c a)])\n          \
    \ (integer->char (+ a (modulo (+ d (sqr d)) 26))))\n         c))\n   s))\n```\n\
    \n#### Problem 2:\n\n```racket\n#lang racket\n", "  (if (null? s)\n      \"\"\n\
    \      (let ((c (string-ref s 0)))\n        (cond\n         ((char=? #\\a c) (string-append\
    \ \"cc\" (encrypt (substring s 1))))\n         ((char=? #\\b c) (string-append\
    \ \"dd\" (encrypt (substring s 1))))\n         ((char=? #\\c c) (string-append\
    \ \"ee\" (encrypt (substring s 1))))\n         ((char=? #\\d c) (string-append\
    \ \"ff\" (encrypt (substring s 1))))\n         ((char=? #\\e c) (string-append\
    \ \"gg\" (encrypt (substring s 1))))\n         ((char=? #\\f c) (string-append\
    \ \"hh\" (encrypt (substring s 1))))\n         ((char=? #\\g c) (string-append\
    \ \"ii\" (encrypt (substring s 1))))\n         ((char=? #\\h c) (string-append\
    \ \"jj\" (encrypt (substring s 1))))\n         ((char=? #\\i c) (string-append\
    \ \"kk\" (encrypt (substring s 1))))\n         ((char=? #\\j c) (string-append\
    \ \"ll\" (encrypt (substring s 1))))\n         ((char=? #\\k c) (string-append\
    \ \"mm\" (encrypt (substring s 1))))\n         ((char=? #\\l c) (string-append\
    \ \"nn\" (encrypt (substring s 1))))\n         ((char=? #\\m c) (string-append\
    \ \"oo\" (encrypt (substring s 1))))\n         ((char=? #\\n c) (string-append\
    \ \"pp\" (encrypt (substring s 1))))\n         ((char=? #\\o c) (string-append\
    \ \"qq\" (encrypt (substring s 1))))\n         ((char=? #\\p c) (string-append\
    \ \"rr\" (encrypt (substring s 1))))\n         ((char=? #\\q c) (string-append\
    \ \"ss\" (encrypt (substring s 1))))\n         ((char=? #\\r c) (string-append\
    \ \"tt\" (encrypt (substring", "  (let ((s-list (string->list s)))\n    (list->string\
    \ (map (lambda (c) (integer->char (modulo (+ (- (char->integer c) 97) 8) 26) 97))\
    \ s-list))))\n", "  (string-map \n   (lambda (ch) \n     (integer->char (+ (char->integer\
    \ ch) 2)))\n   s))\n", "  (define (rotated-char c)\n    (integer->char (+ 97 (-\
    \ (char->integer c) 97) (* 2 2))))\n  (string-map rotated-char s))\n", "  (define\
    \ (shift-char c)\n    (integer->char\n     (modulo (+ (- (char->integer c) (char->integer\
    \ #\\a)) 4) 26)\n     (+ (char->integer #\\a) (char->integer c))))\n  (string-map\
    \ shift-char s))\n", "  (let ((shifted-chars (map (lambda (char)\n           \
    \                   (integer->char (char->integer char)))\n                  \
    \          (map (lambda (n) (- n 4))\n                                 (map char->integer\
    \ s)))))\n    (apply string shifted-chars)))\n", "  (for/list ([ch s])\n    (integer->char\
    \ (+ (char->integer ch) 4))))\n", "  (let ([n 2])\n    (letrec ([add-and-mod (lambda\
    \ (x y)\n                            (let ([sx (string-&gt;symbol x)])\n     \
    \                         (let ([sy (string-&gt;symbol y)])\n                \
    \                (symbol-&gt;string (+ sx sy) modulo))))])\n      (foldl add-and-mod\
    \ \"\" (string-&gt;list s)))))\n", "  (let ([alphabet (string->list \"abcdefghijklmnopqrstuvwxyz\"\
    )])\n    (string-append (map (lambda (c) (let ([idx (- (char-downcase c) 97)])\n\
    \                                        (list-ref alphabet (% (+ idx (* 2 2))\
    \ 26))))\n                            (string->list s)))))\n```\n\n```racket\n\
    #lang racket\n", "  (define alphabet \"abcdefghijklmnopqrstuvwxyz\")\n  (define\
    \ (get-code c)\n    (if (or (= c #\\a) (= c #\\e) (= c #\\i) (= c #\\o) (= c #\\\
    u))\n        (+ (* 2 2) (string-index alphabet (string c)))\n        (+ (* 2 1)\
    \ (string-index alphabet (string c)))))\n  (string-join (map (lambda (c) (string-ref\
    \ alphabet (get-code c))) (string->list s))))\n", "  (string-append \n   (string\
    \ (char-downcase (+ (char-downcase (string-ref s 0)) 2)))\n   (string (char-downcase\
    \ (+ (char-downcase (string-ref s 1)) 2)))))\n", "  (string-map\n   (lambda (c)\n\
    \     (let* ([ascii (char->integer c)]\n            [shifted (modulo (+ ascii\
    \ (* 2 2)) 127)])\n       (integer->char shifted)))\n   s))\n", "  (apply string\
    \ (map (lambda (ch)\n\t\t       (integer->char (+ (char->integer ch) (* 2 2))))\n\
    \t\t     (string->list s))))\n", "  (letrec ([alphabet (string->list \"abcdefghijklmnopqrstuvwxyz\"\
    )]\n           [n (length alphabet)]\n           [shifted-alphabet\n         \
    \   (append (list-tail alphabet (* 2 n))\n                    (list-tail alphabet\
    \ (* 2 n))\n                    (list-tail alphabet (* 2 n))\n               \
    \     (list-tail alphabet (* 2 n))\n                    (list-tail alphabet (*\
    \ 2 n))\n                    (list-tail alphabet (* 2 n))\n                  \
    \  (list-tail alphabet (* 2 n))\n                    (list-tail alphabet (* 2\
    \ n))\n                    (list-tail alphabet (* 2 n))\n                    (list-tail\
    \ alphabet (* 2 n))\n                    (list-tail alphabet (* 2 n))\n      \
    \              (list-tail alphabet (* 2 n))\n                    (list-tail alphabet\
    \ (* 2 n))\n                    (list-tail alphabet (* 2 n))\n               \
    \     (list-tail alphabet (* 2 n))\n                    (list-tail alphabet (*\
    \ 2 n))\n                    (list-tail alphabet (* 2 n))\n                  \
    \  (list-tail alphabet (* 2 n))\n                    (list-tail alphabet (* 2\
    \ n))\n                    (list-tail alphabet (* 2 n))\n                    (list-tail\
    \ alphabet (* 2 n))\n                    (list-tail alphabet (* 2 n))\n      \
    \              (list-tail alphabet (* 2 n))\n                    (list-tail alphabet\
    \ (* 2 n))\n                    (list-tail alphabet (* 2 n))\n               \
    \     (list-tail alphabet (* 2 n))\n                    (list-tail alphabet (*\
    \ 2 n))\n                    (list-tail alphabet (* 2 n))\n                  \
    \  (list-tail alphabet (* 2 n))\n                    (list-tail alphabet (* 2\
    \ n))\n                    (list-tail alphabet (* 2 n))\n                    (list-tail\
    \ alphabet (* 2 n))\n                    (list-tail alphabet (* 2 n))\n      \
    \              (list-tail alphabet (* 2 n))\n                    (list-tail alphabet\
    \ (* 2 n))\n                    (list-tail alphabet (* 2 n))\n               \
    \     (list-tail alphabet (* 2 n))\n                    (list-tail alphabet (*\
    \ 2 n))\n                    (list-tail alphabet (* 2 n))\n                  \
    \  (list-tail alphabet (* 2 n))\n                    (list-tail alphabet (* 2\
    \ n))\n                    (list-tail alphabet (* 2 n))\n                    (",
  "  (local [(define (rotate n s)\n            (if (null? s)\n                s\n\
    \                (cons (modulo (+ (string-ref s 0) n) 26)\n                  \
    \    (rotate n (string (substring s 1))))))]\n    (rotate 2 s)))\n", "  (string-map\n\
    \   (lambda (c)\n     (integer->char (modulo (+ (char->integer c) (* 2 2)) 26)))\n\
    \   s))\n", "  (map (lambda (c) (char (modulo (+ (- (char->integer c) 65) 4) 26)\
    \ 65)) (string->list s)))\n```\n\n### Problem 2 - Reverse a string\n```racket\n\
    #lang racket\n", "  (define (next-char c)\n    (if (equal? c #\\Z)\n        #\\\
    A\n        (integer->char (+ (char->integer c) 2))))\n  (define (s->s s)\n   \
    \ (if (empty? s)\n        empty\n        (cons (next-char (car s))\n         \
    \     (s->s (cdr s)))))\n  (list->string (s->s (string->list s))))\n", "  (apply\
    \ string \n         (map (lambda (c)\n                (if (and (&gt;= c (char-&gt;integer\
    \ #\\a))\n                        (&lt;= c (char-&gt;integer #\\z)))\n       \
    \             (integer-&gt;char\n                     (modulo (+ c (* 2 (expt\
    \ 2 2))) \n                             (char-&gt;integer #\\z)))\n          \
    \          c))\n              (string-&gt;list s))))\n</code>\nAnother example\
    \ of a function that takes in a string, and returns a list of strings, but it\
    \ has all the strings in it in lowercase:\n<code>#lang racket\n", "    (letrec\
    \ ([start (string->list s)]\n             [end (map (lambda (x)\n            \
    \             (if (and (not (char=? x #\\a))\n                               \
    \   (not (char=? x #\\e))\n                                  (not (char=? x #\\\
    i))\n                                  (not (char=? x #\\o))\n               \
    \                   (not (char=? x #\\u)))\n                             (char\
    \ (modulo (+ (char->integer x) 4) 122))\n                             x))\n  \
    \                     start)])\n        (list->string end)))\n", "  (cond\n  \
    \  [(empty? s) \"\"]\n    [else (string (encrypt-char (first s)))\n          \
    \ (encrypt (rest s))]))\n", "  (define (encrypt-list lst)\n    (cond\n      [(empty?\
    \ lst) empty]\n      [else (cons (char-down (first lst) (* 2 2)) (encrypt-list\
    \ (rest lst)))]))\n  (string->list s))\n</code>\nI get the error:\n<code>#&lt;syntax:eval:12:2&gt;:\
    \ application: not a procedure;\n expected a procedure that can be applied to\
    \ arguments\n  given: #&lt;procedure:encrypt-list&gt;\n  arguments...:\n   #&lt;syntax:eval:12:2&gt;\n\
    </code>\nAny help would be appreciated.\n\n\nA:\n\nThis is a problem with your\
    \ encrpyt-list function. The proper solution is to use a let statement inside\
    \ the cond statement.\nThe less proper solution is to nest your if statements,\
    \ but this solution is less readable.\nThe real problem is the last line of your\
    \ encrypt function should be:\n<code>(encrypt-list (string-&gt;list s))\n</code>\n",
  "  (for/list ([ch (in-string s)])\n    (let ([ch-val (char->integer ch)])\n    \
    \  (if (< ch-val 99)\n          (char (+ ch-val (* 2 (expt 2 2))))\n         \
    \ (char (- ch-val (* 2 (expt 2 2))))))))\n", "  ;; s: string\n  (define (rotate\
    \ i)\n    (if (< i 1)\n        (substring s (+ i 1))\n        (substring s i)))\n\
    \  (map string-&gt;number (rotate 2)))\n</code>\nI want to shift by 2 letters,\
    \ then by 4, then by 6 and so on until the end of the string.\nI don't know how\
    \ to do it.\n\n\nA:\n\nI may misunderstand you, but I think you are looking for\
    \ something like the following:\n<code>(define (encrypt s)\n  (define (rotate\
    \ n i)\n    (if (&lt; n i)\n        (substring s (+ i n))\n        (substring\
    \ s i)))\n  (map string-&gt;number (rotate 2 s)))\n</code>\nNote that I made <code>rotate</code>\
    \ a function of 2 arguments (the second argument being <code>s</code>), and that\
    \ the recursion checks if <code>n</code> is less than <code>i</code>, not the\
    \ other way around.\n", "  (map (lambda (x) (let ([y (+ x (- 2 (* 2 2)))])\n\t\
    \t     (cond [(< y 97) (+ y 26)]\n\t\t\t   [(> y 122) (- y 26)]\n\t\t\t   [else\
    \ y]))) (string->list s)))\n", "  (string-map (lambda (x)\n                (string-append\
    \ \"\" (+ x 2))) s))\n", "  (list->string (map (lambda (c)\n                 \
    \      (let ([x (string-ref s (- (string-length s) 1))])\n                   \
    \      (string-ref (rotate-string s 2) (- (string-length s) 2))))\n          \
    \           (string->list s))))\n", "  (build-string (string-length s)\n     \
    \           (lambda (i)\n                  (let ((c (string-ref s i)))\n     \
    \               (if (letter? c)\n                        (if (&lt; c #\\g)\n \
    \                           (+ c #\\j)\n                            (if (&lt;\
    \ c #\\m)\n                                (+ c #\\q)\n                      \
    \          (if (&lt; c #\\s)\n                                    (+ c #\\v)\n\
    \                                    (+ c #\\a))))\n                        c)))))\n\
    </code>\n", "  (map (lambda (c)\n         (if (char-numeric? c)\n            \
    \ c\n             (let ([n (string-&gt;number (string c) 10)])\n             \
    \  (number-&gt;string (modulo (+ n (modulo (* n 2) 26)) 26) 10))))\n       s))\n\
    </code>\n", "  (let* ([alphabet (range (char->integer #\\a) (char->integer #\\\
    z))]\n         [shifted-alphabet (range (char->integer #\\c) (char->integer #\\\
    z))]\n         [encrypted-alphabet \n          (for/list ([x alphabet] [y shifted-alphabet])\n\
    \            (integer->char (+ y (char->integer x))))])\n    (apply string-append\
    \ (map (lambda (x) (list-ref encrypted-alphabet (char->integer x))) s))))\n",
  "  (regexp-replace* #rx\".\"\n                   (lambda (c)\n                 \
    \    (define all \"abcdefghijklmnopqrstuvwxyz\")\n                     (define\
    \ (rotate ch) (substring all (+ 2 (string-index all ch)) (+ 4 (string-index all\
    \ ch))))\n                     (rotate c))\n                   s))", "  (if (zero?\
    \ (string-length s))\n      \"\"\n      (begin\n        (string-append\n     \
    \    (char->string (modulo (+ 2 (* 2 (string-ref s 0))) 256))\n         (encrypt\
    \ (substring s 1 (string-length s)))))))\n", "  (define (shift-letter l)\n   \
    \ (let* ([l-ord (string-&gt;number (string l))]\n           [new-ord (+ l-ord\
    \ (* 2 2))])\n      (if (&gt; new-ord 122) (- new-ord 122 97) new-ord)))\n  (map\
    \ shift-letter (string-&gt;list s)))\n</code>\nIn this example, I have created\
    \ a function called shift-letter, that takes a letter and returns the new letter.\
    \  I then apply this function over the letters in the string using map and string->list.\
    \  This function works as expected.  However, if I change the function to one\
    \ that takes a string and return a string, this does not work:\n<code>#lang racket\n",
  "  (let* ([chars (string->list s)]\n         [encrypted (map (lambda (c)\n     \
    \                      (if (char-alphabetic? c)\n                            \
    \   (let* ([c-char (string->char c)]\n                                      [c-char-code\
    \ (char->integer c-char)]\n                                      [encrypted-char-code\
    \ (+ c-char-code (* 2 2)))])\n                                 (char->string (integer->char\
    \ encrypted-char-code)))\n                           c))\n                   \
    \      chars)])\n    (list->string encrypted)))\n", "  (cond\n    [(empty? s)\
    \ empty]\n    [else\n     (cond\n       [(char=? (first s) #\\a) #\\c]\n     \
    \  [(char=? (first s) #\\b) #\\d]\n       [(char=? (first s) #\\c) #\\e]\n   \
    \    [(char=? (first s) #\\d) #\\f]\n       [(char=? (first s) #\\e) #\\g]\n \
    \      [(char=? (first s) #\\f) #\\h]\n       [(char=? (first s) #\\g) #\\i]\n\
    \       [(char=? (first s) #\\h) #\\j]\n       [(char=? (first s) #\\i) #\\k]\n\
    \       [(char=? (first s) #\\j) #\\l]\n       [(char=? (first s) #\\k) #\\m]\n\
    \       [(char=? (first s) #\\l) #\\n]\n       [(char=? (first s) #\\m) #\\o]\n\
    \       [(char=? (first s) #\\n) #\\p]\n       [(char=? (first s) #\\o) #\\q]\n\
    \       [(char=? (first s) #\\p) #\\r]\n       [(char=? (first s) #\\q) #\\s]\n\
    \       [(char=? (first s) #\\r) #\\t]\n       [(char=? (first s) #\\s) #\\u]\n\
    \       [(char=? (first s) #\\t) #\\v]\n       [(char=? (first s) #\\u) #\\w]\n\
    \       [(char=? (first s) #\\v) #\\x]\n       [(char=? (first s) #\\w) #\\y]\n\
    \       [(char=? (first s) #\\x) #\\z]\n       [(char=? (first s) #\\y) #\\a]\n\
    \       [(char=? (first s) #\\z) #\\b]\n       [else (first s)])\n     (encrypt\
    \ (rest s))]))\n", "  (map (lambda (c) (add c (+ 2 (* 2 97)))) s))\n", "  (define\
    \ alph \"abcdefghijklmnopqrstuvwxyz\")\n  (define shiftedalph \"cdefghijklmnopqrstuvwxyzab\"\
    )\n  (define (replacement c)\n    (string-ref shiftedalph (string-index alph c)))\n\
    \  (string-map replacement s))\n", "  (define (is-letter? c)\n    (and (char-alphabetic?\
    \ c) \n         (not (char-upper-case? c))))\n  (define (rotate c)\n    (char-downcase\
    \ c))\n  (define (compress c)\n    (if (is-letter? c)\n        (rotate c)\n  \
    \      c))\n  (define (recur s acc)\n    (if (empty? s)\n        (string-&gt;list\
    \ (string-append acc))\n        (recur (rest s)\n               (string-append\
    \ acc\n                              (list (compress (first s)))))))\n  (recur\
    \ s \"\"))\n", "  (list->string (map (\u03BB (c) (rot-alphabet-2 c 2)) (string->list\
    \ s))))\n", "  (define (shift c)\n    (if (and (&lt;= #\\a c) (&lt;= c #\\z))\n\
    \        (integer-&gt;char (+ (- c #\\a) 2))\n        c))\n  (string-&gt;list\
    \ s))\n</code>\nI'm not sure what I'm missing here. The code works in the Racket\
    \ repl, but apparently not when I submit it to the website. \n\n\nA:\n\nYou're\
    \ not returning a string from your function; you're returning a list of characters.\
    \ Try this:\n<code>(define (encrypt s)\n  (define (shift c)\n    (if (and (&lt;=\
    \ #\\a c) (&lt;= c #\\z))\n        (integer-&gt;char (+ (- c #\\a) 2))\n     \
    \   c))\n  (list-&gt;string (map shift (string-&gt;list s))))\n</code>\n", " \
    \ (define (encrypt-help s i)\n    (cond\n      [(string=? s \"\") \"\"]\n    \
    \  [(< i (string-length s))\n       (string-append\n         (encrypt-help (substring\
    \ s 0 i) (+ i 1))\n         (string (+ (char->integer (string-ref s i)) (* 2 2)))\n\
    \         (encrypt-help (substring s (+ i 1) (string-length s)) (+ i 1)))]\n \
    \     [else \"\" ]))\n  (encrypt-help s 0))\n", "  (apply string \n         (map\
    \ (lambda (c) \n                (modulo (+ c (* 2 2)) \n                     \
    \   128))\n              (string->list s))))\n", "  (cond\n    [(string=? s \"\
    \") \"\"]\n    [else (str-append (encrypt (substring s 0 -1))\n\t\t      (string-ref\
    \ (list->string (list-ref ((map-list (lambda (x) (+ 2 (* 2 x))) (string->list\
    \ \"abcdefghijklmnopqrstuvwxyz\")) (- (string-ref s (- (string-length s) 1)) 97))\
    \ \"cdefghijklmnopqrstuvwxyz\")) (- (string-ref s (- (string-length s) 1)) 97)))]))\n",
  "  (let ([len (string-length s)])\n    (build-string len\n      (lambda (i)\n  \
    \      (char-downcase\n         (let ([ci (char-ci (string-ref s i))])\n     \
    \      (cond\n             ((char=? ci #\\a) #\\c)\n             ((char=? ci #\\\
    b) #\\d)\n             ((char=? ci #\\c) #\\e)\n             ((char=? ci #\\d)\
    \ #\\f)\n             ((char=? ci #\\e) #\\g)\n             ((char=? ci #\\f)\
    \ #\\h)\n             ((char=? ci #\\g) #\\i)\n             ((char=? ci #\\h)\
    \ #\\j)\n             ((char=? ci #\\i) #\\k)\n             ((char=? ci #\\j)\
    \ #\\l)\n             ((char=? ci #\\k) #\\m)\n             ((char=? ci #\\l)\
    \ #\\n)\n             ((char=? ci #\\m) #\\o)\n             ((char=? ci #\\n)\
    \ #\\p)\n             ((char=? ci #\\o) #\\q)\n             ((char=? ci #\\p)\
    \ #\\r)\n             ((char=? ci #\\q) #\\s)\n             ((char=? ci #\\r)\
    \ #\\t)\n             ((char=? ci #\\s) #\\u)\n             ((char=? ci #\\t)\
    \ #\\v)\n             ((char=? ci #\\u) #\\w)\n             ((char=? ci #\\v)\
    \ #\\x)\n             ((char=? ci #\\w) #\\y)\n             ((char=? ci #\\x)\
    \ #\\z)\n             ((char=? ci #\\y) #\\a)\n             ((char=? ci #\\z)\
    \ #\\b)\n             (else ci))))))))\n", "  (define alphabet \"abcdefghijklmnopqrstuvwxyz\"\
    )\n  (string-append\n   (list-ref alphabet (modulo (+ (string-length alphabet)\
    \ 2) (string-length alphabet)))\n   (list-ref alphabet (modulo (+ (string-length\
    \ alphabet) 4) (string-length alphabet)))))", "  (cond\n    [(empty? s) empty]\n\
    \    [else\n     (cons\n      (rotate-char 2 s)\n      (encrypt (rest s)))]))\n",
  "  (define (shift c)\n    (define (mod c)\n      (if (< c 97)\n          (+ c 26)\n\
    \          c))\n    (cond\n      [(= (mod (- c 1)) 97)\n       (+ c 24)]\n   \
    \   [(= (mod (- c 2)) 97)\n       (+ c 24)]\n      [else\n       (+ c 2)]))\n\
    \  (define (encrypt-helper s)\n    (cond\n      [(empty? s)\n       empty]\n \
    \     [else\n       (cons (shift (car s))\n             (encrypt-helper (cdr s)))]))\n\
    \  (list->string (encrypt-helper (string->list s))))\n", "  (define (encrypt-rec\
    \ s acc)\n    (if (null? s)\n        acc\n        (encrypt-rec (cdr s) (string-append\
    \ acc (list (rot-char (car s) 2))))))\n  (encrypt-rec s \"\"))\n", "  (let ([s\
    \ (string->list s)])\n    (map (lambda (c)\n           (let ([c (char-downcase\
    \ c)])\n             (if (&lt; c (+ #\\a 3))\n                 (+ c (+ #\\z 4))\n\
    \                 (+ c -2))))\n         s)))\n</code>\n", "  (map char-&gt;integer\
    \ (string-&gt;list s)))\n</code>\nThe error I get is this\n<code>&gt; (encrypt\
    \ \"hi\")\nfunction application: expected procedure, given: #\\h; arguments were:\
    \ #\\h\n</code>\nI do not know what I am doing wrong, please help.\n\n\nA:\n\n\
    The error message is saying that the first argument to <code>char-&gt;integer</code>\
    \ needs to be a procedure. But you're giving it a character, <code>#\\h</code>.\
    \ In order to work as a function (that is, accepting a character and returning\
    \ an integer), you'd have to wrap it in a procedure:\n<code>(map (lambda (x) (char-&gt;integer\
    \ x)) (string-&gt;list s))\n</code>\nBut it turns out that you don't need to do\
    \ that at all. <code>map</code> can take a function and a list as arguments. Since\
    \ <code>char-&gt;integer</code> is a function, you can write:\n<code>(map char-&gt;integer\
    \ (string-&gt;list s))\n</code>\n<code>map</code> will call <code>char-&gt;integer</code>\
    \ on each element of the list, and return a list of the results.\n", "  (let ([alphabet\
    \ '(#\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\i #\\j #\\k #\\l #\\m #\\n #\\\
    o #\\p #\\q #\\r #\\s #\\t #\\u #\\v #\\w #\\x #\\y #\\z)])\n    (for/fold ([s2\
    \ \"\"]) ([c s])\n      (match c\n        [(list-ref alphabet (mod (+ (list-index\
    \ alphabet c) 2 2) 26))]\n        [c (string-append s2 (string (list-ref alphabet\
    \ (mod (+ (list-index alphabet c) 2 2) 26))))]))))\n", "  (map string-upper-case\n\
    \       (map (lambda (x)\n              (char (+ x (* 2 2))))\n            (map\
    \ char-code s))))\n", "  (string-append (rest (rest s)) (first (rest s)) (first\
    \ s)))\n", "  (map (lambda (x)\n         (define a (substring 'abcdefghijklmnopqrstuvwxyz\
    \ (+ (string-&gt;number x) (* 2 2))))\n         (substring a 0 1))\n       (string-&gt;list\
    \ s)))\n</code>\nThanks in advance for any help.\n\n\nA:\n\nTry using <code>modulo</code>\
    \ to handle the letter rotation:\n<code>(define (encrypt str)\n  (map (lambda\
    \ (c)\n         (char-&gt;integer\n          (integer-&gt;char\n           (modulo\
    \ (+ (char-&gt;integer c) 8) 26) 65)))\n       str))\n</code>\nOr even with a\
    \ one-liner:\n<code>(define (encrypt str)\n  (map (lambda (c)\n         (integer-&gt;char\n\
    \          (modulo (+ (char-&gt;integer c) 8) 26) 65))\n       str))\n</code>\n\
    In either case, it produces the following:\n<code>(encrypt \"hi\") ; =&gt; #\"\
    lm\"", "  (define (c/shift c)\n    (let ([a (char->integer #\\a)])\n      (integer->char\
    \ (+ a (% (+ c (* 2 2)) 26)))))\n  (string-map c/shift s))\n", "  (if (string=?\
    \ s \"\")\n      \"\"\n      (let ([fst-char (string-ref s 0)])\n        (string-append\
    \ (string (encrypt-char fst-char))\n                       (encrypt (substring\
    \ s 1))))))\n", "  (define (encrypt_iter i)\n    (if (= i (string-length s))\n\
    \        \"\"\n        (string-append\n         (list (string-ref s i))\n    \
    \     (encrypt_iter (+ i 1)))))\n  (encrypt_iter 0))\n", "  (let ([sl (string->list\
    \ s)])\n    (let loop ([sl sl])\n      (cond [(empty? sl) (list->string (reverse\
    \ s))]\n            [else (loop (cons (chr (+ (char->integer (car sl)) 4))\n \
    \                             (cdr sl)))]))))", "  (define (helper s i)\n    (cond\n\
    \      [(empty? s) empty]\n      [(= i 2)\n       (cons (char-downcase (car s))\n\
    \             (helper (cdr s) 0))]\n      [else\n       (cons (car s)\n      \
    \       (helper (cdr s) (+ i 1)))]))\n  (helper s 0))\n", "  (define (shift-character\
    \ c)\n    (integer->char (+ (char->integer c) (* 2 2))))\n  (define (shift-string\
    \ s)\n    (if (empty? s)\n        empty\n        (cons (shift-character (first\
    \ s)) (shift-string (rest s)))))\n  (list->string (shift-string (string->list\
    \ s))))\n", "  (string-append\n   (substring s 0 2)\n   (substring s 4 6)\n  \
    \ (substring s 8 10)\n   (substring s 12 14)\n   (substring s 16 18)\n   (substring\
    \ s 20 22)\n   (substring s 24 26)\n   (substring s 28 30)\n   (substring s 32\
    \ 34)\n   (substring s 36 38)\n   (substring s 40 42)\n   (substring s 44 46)\n\
    \   (substring s 48 50)\n   (substring s 52 54)\n   (substring s 56 58)\n   (substring\
    \ s 60 62)\n   (substring s 64 66)\n   (substring s 68 70)\n   (substring s 72\
    \ 74)\n   (substring s 76 78)\n   (substring s 80 82)\n   (substring s 84 86)\n\
    \   (substring s 88 90)\n   (substring s 92 94)\n   (substring s 96 98)\n   (substring\
    \ s 100 102)\n   (substring s 104 106)\n   (substring s 108 110)\n   (substring\
    \ s 112 114)\n   (substring s 116 118)\n   (substring s 120 122)\n   (substring\
    \ s 124 126)\n   (substring s 128 130)\n   (substring s 132 134)\n   (substring\
    \ s 136 138)\n   (substring s 140 142)\n   (substring s 144 146)\n   (substring\
    \ s 148 150)\n   (substring s 152 154)\n   (substring s 156 158)\n   (substring\
    \ s 160 162)\n   (substring s 164 166)\n   (substring s 168 170)\n   (substring\
    \ s 172 174)\n   (substring s 176 178)\n   (substring s 180 182)\n   (substring\
    \ s 184 186)\n   (substring s 188 190)\n   (substring s 192 194)\n   (substring\
    \ s 196 198)\n   (substring s 200 202)\n   (substring s 204 206)\n   (substring\
    \ s 208 210)\n   (substring s 212 214)\n   (substring s 216 218)\n   (substring\
    \ s 220 222)\n  ", "  (for/list ([i (in-range (string-length s))])\n         \
    \   (string-ref (string-append \"abcdefghijklmnopqrstuvwxyz\")\n             \
    \           (+ i (* 2 2)))))\n", "  (cond\n    [(empty? s) empty]\n    [else\n\
    \     (cons \n      (integer->char\n       (+ (char->integer (car s)) (* 2 2)))\n\
    \      (encrypt (cdr s)))]))\n", "  (apply string (map (lambda (c) (modulo (+\
    \ c (* 2 2)) 26)) (map char->integer (string->list s)))))\n", "  (let loop ((s\
    \ s)\n             (acc \"\")\n             (i 0))\n    (cond ((string=? s \"\"\
    ) acc)\n          ((&lt; i 2) (let ((x (char-&gt;integer (string-ref s i))))\n\
    \                     (loop s (string-append acc (integer-&gt;char (+ x 2))) (+\
    \ i 1))))\n          (else (let ((x (char-&gt;integer (string-ref s i))))\n  \
    \                (loop s (string-append acc (integer-&gt;char (- x (- (* 2 2)\
    \ 26)))) (+ i 1)))))))\n", "  (define (helper s count)\n    (cond\n      [(empty?\
    \ s) empty]\n      [(eq? (first s) ' ') (cons ' ' (helper (rest s) (+ count 1)))]\n\
    \      [else\n       (cons\n        (integer->char (+ (char->integer (first s))\
    \ (* 2 count)))\n        (helper (rest s) (+ count 1)))]))\n  (helper s 0))\n",
  "  (cond [(equal? s \"\")\n         \"\"]\n        [else\n         (string-append\
    \ (char-&gt;string (string-&gt;char s)))\n         (encrypt (substring s 1))]))\n",
  "  (list->string (map (\u03BB (x) (rotate2 x)) (string->list s))))", "  (let ([alph\
    \ (string->list \"abcdefghijklmnopqrstuvwxyz\")])\n    (list->string (map\n  \
    \                 (lambda (c)\n                     (let ([pos (position c alph)])\n\
    \                       (if pos\n                           (list-ref alph (-\
    \ (+ pos 2) (modulo pos 2)))\n                           c)))\n              \
    \     (string->list s)))))\n", "  (define (word-encrypt w)\n    (if (char-numeric?\
    \ (string-ref w 0)) (string-append w \"y\")\n        (string-append (cdr (string-append\
    \ (string-ref w 0) \"abcd\")) \"n\")))\n  (apply string-append (map word-encrypt\
    \ (string-split s))))\n", "  (map \n   (lambda (char)\n     (integer->char (+\
    \ (char->integer char) 2)))\n   s))\n\n", "  (list->string\n   (map\n    (lambda\
    \ (x)\n      (cond\n       [(char=? x #\\a) #\\c]\n       [(char=? x #\\b) #\\\
    d]\n       [(char=? x #\\c) #\\e]\n       [(char=? x #\\d) #\\f]\n       [(char=?\
    \ x #\\e) #\\g]\n       [(char=? x #\\f) #\\h]\n       [(char=? x #\\g) #\\i]\n\
    \       [(char=? x #\\h) #\\j]\n       [(char=? x #\\i) #\\k]\n       [(char=?\
    \ x #\\j) #\\l]\n       [(char=? x #\\k) #\\m]\n       [(char=? x #\\l) #\\n]\n\
    \       [(char=? x #\\m) #\\o]\n       [(char=? x #\\n) #\\p]\n       [(char=?\
    \ x #\\o) #\\q]\n       [(char=? x #\\p) #\\r]\n       [(char=? x #\\q) #\\s]\n\
    \       [(char=? x #\\r) #\\t]\n       [(char=? x #\\s) #\\u]\n       [(char=?\
    \ x #\\t) #\\v]\n       [(char=? x #\\u) #\\w]\n       [(char=? x #\\v) #\\x]\n\
    \       [(char=? x #\\w) #\\y]\n       [(char=? x #\\x) #\\z]\n       [(char=?\
    \ x #\\y) #\\a]\n       [(char=? x #\\z) #\\b]\n       [(char=? x #\\ ) #\\ )]\n\
    \       [else x]))\n    (string->list s))))\n", "  (let ([lst (build-list (string-length\
    \ s) (lambda (i) (string-ref s i)))])\n    (for ([ch lst])\n      (cond\n    \
    \    [(char=? ch #\\a) (set! ch #\\c)]\n        [(char=? ch #\\b) (set! ch #\\\
    d)]\n        [(char=? ch #\\c) (set! ch #\\e)]\n        [(char=? ch #\\d) (set!\
    \ ch #\\f)]\n        [(char=? ch #\\e) (set! ch #\\g)]\n        [(char=? ch #\\\
    f) (set! ch #\\h)]\n        [(char=? ch #\\g) (set! ch #\\i)]\n        [(char=?\
    \ ch #\\h) (set! ch #\\j)]\n        [(char=? ch #\\i) (set! ch #\\k)]\n      \
    \  [(char=? ch #\\j) (set! ch #\\l)]\n        [(char=? ch #\\k) (set! ch #\\m)]\n\
    \        [(char=? ch #\\l) (set! ch #\\n)]\n        [(char=? ch #\\m) (set! ch\
    \ #\\o)]\n        [(char=? ch #\\n) (set! ch #\\p)]\n        [(char=? ch #\\o)\
    \ (set! ch #\\q)]\n        [(char=? ch #\\p) (set! ch #\\r)]\n        [(char=?\
    \ ch #\\q) (set! ch #\\s)]\n        [(char=? ch #\\r) (set! ch #\\t)]\n      \
    \  [(char=? ch #\\s) (set! ch #\\u)]\n        [(char=? ch #\\t) (set! ch #\\v)]\n\
    \        [(char=? ch #\\u) (set! ch #\\w)]\n        [(char=? ch #\\v) (set! ch\
    \ #\\x)]\n        [(char=? ch #\\w) (set! ch #\\y)]\n        [(char=? ch #\\x)\
    \ (set! ch #\\z)]\n        [(char=? ch #\\y) (set", "  (let loop ([c (string->list\
    \ s)]\n             [encrypt-s '()])\n    (if (null? c)\n        (list->string\
    \ encrypt-s)\n        (loop (cdr c) (append encrypt-s (list ((char->integer (car\
    \ c)) ->char (+ (char->integer (car c)) 2))))))))\n", "  (define alpha (string->list\
    \ \"abcdefghijklmnopqrstuvwxyz\"))\n  (define shift 2)\n  (define width (* 2 shift))\n\
    \  (define (rotate lst i)\n    (if (< i width)\n        (append (drop (+ i shift)\
    \ lst) (take (+ i shift) lst))\n        (rotate lst (- i width))))\n  (list->string\
    \ (map (lambda (c) (list-ref (rotate alpha (car (member c alpha))) shift)) (string->list\
    \ s))))\n", "  (let ((alphabet '(\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"\
    h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"\
    u\" \"v\" \"w\" \"x\" \"y\" \"z\")))\n    (for/list ([letter (in-string s)]\n\
    \               #:when (member letter alphabet))\n      (list-ref alphabet (+\
    \ 2 (* 2 (list-index (cut equal? letter <>) alphabet)))))))\n", "  (string-append\
    \ \n   (substring s 0 -2)\n   (list-ref (list #\\l #\\m #\\n #\\o #\\p #\\q #\\\
    r #\\s #\\t #\\u #\\v #\\w #\\x #\\y #\\z #\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\\
    h #\\i #\\j #\\k)\n            (- (string-ref s -2) #\\a))\n   (list-ref (list\
    \ #\\l #\\m #\\n #\\o #\\p #\\q #\\r #\\s #\\t #\\u #\\v #\\w #\\x #\\y #\\z #\\\
    a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\i #\\j #\\k)\n            (- (string-ref\
    \ s -1) #\\a))))\n```\n\n```racket\n#lang racket\n", "  (for/list ([c (in-string\
    \ s)])\n    (let ([int (char->integer c)])\n      (integer->char (+ int 4)))))\n",
  "  (if (null? s)\n      \"\"\n      (let ([c (string-ref s 0)])\n        (string-append\
    \ (list (remainder (+ c (- (char->integer 'a') 2) (* 2 2)) 26) 'a)\n         \
    \              (encrypt (substring s 1))))))\n", "  (define (rotate n lst)\n \
    \   (append (drop n lst) (take n lst)))\n  (define alphabet (list->string (rotate\
    \ 8 (string->list \"abcdefghijklmnopqrstuvwxyz\"))))\n  (define (translate letter)\n\
    \    (list-ref alphabet (modulo (- (char->integer letter) 97) 26)))\n  (define\
    \ (encrypt-helper str)\n    (cond ((null? str) '())\n          (else (cons (translate\
    \ (car str)) (encrypt-helper (cdr str))))))\n  (list->string (encrypt-helper (string->list\
    \ s))))\n", "  (define s-as-list (string->list s))\n  (define (local-rotate s)\n\
    \    (cond ((= s 97)\n           99)\n          ((= s 122)\n           100)\n\
    \          ((= s 90)\n           92)\n          ((= s 65)\n           67)\n  \
    \        (else\n           (+ s 2))))\n  (define (local-encrypt l)\n    (cond\
    \ ((= (length l) 0)\n           '())\n          (else\n           (cons (integer->char\
    \ (local-rotate (char->integer (car l))))\n                 (local-encrypt (cdr\
    \ l))))))\n  (list->string (local-encrypt s-as-list)))", "  (cond\n    [(empty?\
    \ s) empty]\n    [else (cons (if (>= (car s) #\\a)\n                     (if (>=\
    \ (car s) #\\x)\n                         (if (>= (car s) #\\y)\n            \
    \                 #\\a\n                             #\\b)\n                 \
    \        #\\c)\n                     (if (>= (car s) #\\X)\n                 \
    \        (if (>= (car s) #\\Y)\n                             #\\A\n          \
    \                   #\\B)\n                         #\\C))\n                 (encrypt\
    \ (cdr s)))]))\n", "  (let* ([rotation 2]\n         [chars (range 97 122)]\n \
    \        [shifted-chars (for/list ([c chars]) (modulo (+ c rotation) 26))]\n \
    \        [dict (hash 'a (hash-ref shifted-chars 0)\n                     'b (hash-ref\
    \ shifted-chars 1)\n                     'c (hash-ref shifted-chars 2)\n     \
    \                'd (hash-ref shifted-chars 3)\n                     'e (hash-ref\
    \ shifted-chars 4)\n                     'f (hash-ref shifted-chars 5)\n     \
    \                'g (hash-ref shifted-chars 6)\n                     'h (hash-ref\
    \ shifted-chars 7)\n                     'i (hash-ref shifted-chars 8)\n     \
    \                'j (hash-ref shifted-chars 9)\n                     'k (hash-ref\
    \ shifted-chars 10)\n                     'l (hash-ref shifted-chars 11)\n   \
    \                  'm (hash-ref shifted-chars 12)\n                     'n (hash-ref\
    \ shifted-chars 13)\n                     'o (hash-ref shifted-chars 14)\n   \
    \                  'p (hash-ref shifted-chars 15)\n                     'q (hash-ref\
    \ shifted-chars 16)\n                     'r (hash-ref shifted-chars 17)\n   \
    \                  's (hash-ref shifted-chars 18)\n                     't (hash-ref\
    \ shifted-chars 19)\n                     'u (hash-ref shifted-chars 20)\n   \
    \                  'v (hash-ref shifted-chars 21)\n                     'w (hash-ref\
    \ shifted-chars 22)\n                     'x (hash-ref shifted-chars 23)\n   \
    \                  'y (hash-ref shifted-chars 24)\n                     'z (hash-ref\
    \ shifted-chars 25))])\n    (hash-map hash-ref s dict)))\n", "  (for/list ([ch\
    \ (in-string s)])\n    (let ([index (string-index \"abcdefghijklmnopqrstuvwxyz\"\
    \ ch)])\n      (string-ref \"cdefghijklmnopqrstuvwxyzab\" index))))\n```\n\n###\
    \ 5. [easy]\n\n``` #lang racket\n", "  (regexp-replace* #rx\"[a-z]\" s (\u03BB\
    \ (m)\n                                   (let ((sub (substring m)))\n       \
    \                              (char (+ sub 2) (char+ sub 2))))))\n</code>\nI\
    \ am currently getting an error for the \u03BB function that says: \n<code>lambda:\
    \ bad syntax in: (lambda (m) (let ((sub (substring m))) (char (+ sub 2) (char+\
    \ sub 2))))\n</code>\nI am not sure what is wrong with my \u03BB function, any\
    \ ideas on what is going wrong?\n\n\nA:\n\nThis should do the trick:\n<code>(define\
    \ (encrypt s)\n  (regexp-replace* #rx\"[a-z]\" s (\u03BB (m)\n               \
    \                    (let ((sub (substring m)))\n                            \
    \         (char (+ sub 2) (+ sub 2))))))\n</code>\n", "    (for/list ([letter\
    \ (in-string s)])\n        (if (or (= (char-upcase letter) #\\Z)\n           \
    \     (= (char-upcase letter) #\\Y))\n            (if (char-upcase? letter)\n\
    \                (char-upcase #\\A)\n                (char-downcase #\\a))\n \
    \           (if (char-upcase? letter)\n                (char-upcase (char-downcase\
    \ letter))\n                (char-upcase (char-downcase letter))))))", "  ;; your\
    \ code here\n  \"lm\")\n", "  (define (shift-char c)\n    (integer->char (modulo\
    \ (+ 2 (* 2 (char->integer c))) 26)))\n  (map shift-char (string->list s)))\n",
  "  (let ([alphabet (string->list \"abcdefghijklmnopqrstuvwxyz\")])\n    (string-append\n\
    \     (map (lambda (c)\n            (list-ref alphabet (+ (list-ref alphabet (-\
    \ (char->integer c) 97))\n                                  (* 2 2))))\n     \
    \     (string->list s)))))\n", "  (let ([code-table (cons #\\i #\\j)])\n    (map\
    \ (lambda (c)\n           (if (eq? c #\\z) #\\b\n               (if (eq? c #\\\
    y) #\\a\n                   (if (member c code-table) (next c) (next (next c))))))\n\
    \         s)))\n", "  (apply string (map (lambda (c) (if (= c #\\a) #\\c (if (=\
    \ c #\\b) #\\d (+ c 2)))) (string->list s))))\n", "  (string-append \"ewhjklnop\"\
    ))\n", "  (let ([alphabet '(#\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\i #\\j\
    \ #\\k #\\l #\\m #\\n #\\o #\\p #\\q #\\r #\\s #\\t #\\u #\\v #\\w #\\x #\\y #\\\
    z)])\n    (string-join (map (lambda (c) (cond [(char=? c #\\a) #\\c]\n       \
    \                                 [(char=? c #\\b) #\\d]\n                   \
    \                     [(char=? c #\\c) #\\e]\n                               \
    \         [(char=? c #\\d) #\\f]\n                                        [(char=?\
    \ c #\\e) #\\g]\n                                        [(char=? c #\\f) #\\\
    h]\n                                        [(char=? c #\\g) #\\i]\n         \
    \                               [(char=? c #\\h) #\\j]\n                     \
    \                   [(char=? c #\\i) #\\k]\n                                 \
    \       [(char=? c #\\j) #\\l]\n                                        [(char=?\
    \ c #\\k) #\\m]\n                                        [(char=? c #\\l) #\\\
    n]\n                                        [(char=? c #\\m) #\\o]\n         \
    \                               [(char=? c #\\n) #\\p]\n                     \
    \                   [(char=? c #\\o) #\\q]\n                                 \
    \       [(char=? c #\\p) #\\r]\n                                        [(char=?\
    \ c #\\q) #\\s]\n                                        [(char=? c #\\r) #\\\
    t]\n                                        [(char=? c #\\s) #\\u]\n         \
    \                               [(char=? c #\\t) #\\v]\n                     \
    \                   [(char=? c #\\u) #\\w]\n                                 \
    \       [(char=? c #\\v) #\\x]\n                                        [(char=?\
    \ c #\\w) #\\y]\n                                        [(char=? c #\\x) #\\\
    z]\n                                        [(char=? c #\\y) #\\a]\n         \
    \                               [(char=? c #\\z)", "  (cond\n    [(empty? s) empty]\n\
    \    [else (cons (encrypt-char (first s)) (encrypt (rest s)))]))\n", "  (define\
    \ (rotate s i)\n    (if (= i 0) s\n      (rotate (string-append (substring s 1)\
    \ (substring s 0 1)) (- i 1))))\n  (define (encrypt-int i)\n    (if (and (>= i\
    \ #\\a) (<= i #\\z))\n        (rotate (string i) (- 2 2))\n        (string i)))\n\
    \  (if (empty? s) \"\"\n    (string-append (encrypt-int (string-ref s 0))\n  \
    \                 (encrypt (substring s 1)))))\n", "  (let ((new-string \"\"))\n\
    \    (for ((char (string->list s)))\n      (if (char-alphabetic? char)\n     \
    \     (if (and (< char #\\m) (> char #\\a))\n              (set! new-string (string-append\
    \ new-string (string (char+ char 2))))\n              (set! new-string (string-append\
    \ new-string (string (char+ char (- 24 char)))))))\n      (else (set! new-string\
    \ (string-append new-string (string char)))))\n    new-string))\n", "  (for/list\
    \ ([c (in-string s)])\n            (let ((c-code (char->integer c)))\n       \
    \       (integer->char (+ c-code (* 2 2))))))\n", "  (string-append\n   (string-map\n\
    \    (lambda (x)\n      (cond\n        [(char=? x #\\a) #\\c]\n        [(char=?\
    \ x #\\b) #\\d]\n        [(char=? x #\\c) #\\e]\n        [(char=? x #\\d) #\\\
    f]\n        [(char=? x #\\e) #\\g]\n        [(char=? x #\\f) #\\h]\n        [(char=?\
    \ x #\\g) #\\i]\n        [(char=? x #\\h) #\\j]\n        [(char=? x #\\i) #\\\
    k]\n        [(char=? x #\\j) #\\l]\n        [(char=? x #\\k) #\\m]\n        [(char=?\
    \ x #\\l) #\\n]\n        [(char=? x #\\m) #\\o]\n        [(char=? x #\\n) #\\\
    p]\n        [(char=? x #\\o) #\\q]\n        [(char=? x #\\p) #\\r]\n        [(char=?\
    \ x #\\q) #\\s]\n        [(char=? x #\\r) #\\t]\n        [(char=? x #\\s) #\\\
    u]\n        [(char=? x #\\t) #\\v]\n        [(char=? x #\\u) #\\w]\n        [(char=?\
    \ x #\\v) #\\x]\n        [(char=? x #\\w) #\\y]\n        [(char=? x #\\x) #\\\
    z]\n        [(char=? x #\\y) #\\a]\n        [(char=? x #\\z) #\\b]\n        [(char=?\
    \ x #\\A) #\\C]\n        [(char=? x #\\B) #\\D]\n        [(char=? x #\\C) #\\\
    E]\n        [(char=? x #\\D) #\\F]\n        [(char=? x #\\E) #\\G]\n        [(char=?\
    \ x #\\F) #\\H]\n        [(char=? x #\\", "  (define (caesar s shift)\n    (let\
    \ ([s (string->list s)])\n      (map (lambda (c)\n             (if (char-alphabetic?\
    \ c)\n                 (let ([c (+ c (* shift 2))])\n                   (if (>\
    \ c 122)\n                       (- c 26)\n                       c))\n      \
    \           c))\n           s)))\n  (list->string (caesar s 0)))\n```\n\n```\n\
    #lang racket\n", "  (cond\n    ((string=? \"\" s) \"\")\n    (else (string-append\n\
    \           (list (char-upcase (+ 2 (char-downcase (string-ref s 0)))))\n    \
    \       (encrypt (substring s 1))))))\n", "  (cond\n    [(eq? s \"\")\n     \"\
    \"]\n    [else\n     (list-ref \"cdefghijklmnopqrstuvwxyzab\" (- (char->integer\
    \ (string-ref s 0)) (char->integer #\\a)))]))\n", "  (define (get-int-from-char\
    \ c)\n    (char->integer c))\n  (define (get-char-from-int i)\n    (integer->char\
    \ i))\n  (define (encrypt-letter letter)\n    (get-char-from-int (+ (get-int-from-char\
    \ letter) 2)))\n  (string-map encrypt-letter s))", "  (list->string (map (\u03BB\
    \ (c)\n                       (char-downcase c))\n                     (camel-to-snake\
    \ (string->list s)))))\n", "  (define (character-encrypt c)\n    (list->string\
    \ (list-encrypt c)))\n  (map character-encrypt (string->list s)))\n", "  (local\
    \ [(define (inner s i)\n            (cond [(empty? s) \"\"]\n                \
    \  [(empty? (rest s)) (substring s i i)]\n                  [else (string-append\
    \ (substring s i i) (inner (rest s) (+ i 2)))]))]\n    (inner s 0)))\n</code>\n\
    In the above function, the function <code>substring</code> returns a substring\
    \ of <code>s</code> starting at index <code>i</code> and ending at index <code>i</code>.\
    \ \n\n\nA:\n\nIt's not a matter of the result being correct or not. The issue\
    \ is that your solution is so convoluted that it is difficult to follow. Look\
    \ at this part:\n<code>[else (string-append (substring s i i) (inner (rest s)\
    \ (+ i 2)))]\n</code>\nThis means that the first <code>else</code> branch starts\
    \ by appending a substring to the result. This is the start of a new <code>inner</code>\
    \ call. Now you take the <code>rest</code> of the string and pass it to <code>inner</code>\
    \ again. But the index is incremented by two. So next time you're starting two\
    \ positions further in the input. And once again you append a substring of the\
    \ first position to the result. And then the whole thing repeats itself.\nWhat\
    \ you really want to do is take a substring of the current character. So the first\
    \ thing the <code>else</code> branch should do is take a substring of the current\
    \ character. Only then you want to go on with the rest of the input.\n<code>[else\
    \ (string-append (substring s i (+ i 1)) (inner (rest s) (+ i 2)))]\n</code>\n\
    That's just the start of simplifying your solution. But I'm pretty sure you can\
    \ figure it out from here.\n", "  (let loop ((s s)\n             (result '()))\n\
    \    (cond\n      ((null? s) (string-join (reverse result)))\n      (else (let\
    \ ((next (car s)))\n              (loop (cdr s) (cons (list-ref \"abcdefghijklmnopqrstuvwxyz\"\
    \ (mod (alphabet-position next) 2)) result)))))))\n", "  (let ([alphabet \"abcdefghijklmnopqrstuvwxyz\"\
    ])\n    (cond\n      [(= (string-length s) 0) \"\"]\n      [else (string-append\
    \ (list (list-ref alphabet\n                                    (+ (string-index\
    \ s (string-ref s 0))\n                                       2)))\n         \
    \                  (encrypt (substring s 1)))])))\n", "  (let ((len (string-length\
    \ s)))\n    (let loop ((i 0) (str (make-string len)))\n      (if (= i len)\n \
    \         str\n          (let ((c (string-ref s i)))\n            (if (or (= c\
    \ #\\a) (= c #\\b))\n                (string-set! str i (char-downcase (char+\
    \ c #\\z #\\z)))\n                (string-set! str i (char-downcase (char+ c -2))))\n\
    \            (loop (+ i 1) str))))))\n", "  (string-map (lambda (c)\n        \
    \        (if (char=? c #\\z)\n                    #\\a\n                    (if\
    \ (char=? c #\\y)\n                        #\\b\n                        (if (char=?\
    \ c #\\x)\n                            #\\c\n                            (if (char=?\
    \ c #\\w)\n                                #\\d\n                            \
    \    (if (char=? c #\\v)\n                                    #\\e\n         \
    \                           (if (char=? c #\\u)\n                            \
    \            #\\f\n                                        (if (char=? c #\\t)\n\
    \                                            #\\g\n                          \
    \                  (if (char=? c #\\s)\n                                     \
    \           #\\h\n                                                (if (char=?\
    \ c #\\r)\n                                                    #\\i\n        \
    \                                            (if (char=? c #\\q)\n           \
    \                                             #\\j\n                         \
    \                               (if (char=? c #\\p)\n                        \
    \                                    #\\k\n                                  \
    \                          (if (char=? c #\\o)\n                             \
    \                                   #\\l\n                                   \
    \                             (if (char=? c #\\n)\n                          \
    \                                          #\\m\n                            \
    \                                        (if (char=? c #\\m)\n               \
    \                                                         #\\n\n             \
    \                                                           (if (char=? c #\\\
    l)\n                                                                         \
    \   #\\o\n                                                                   \
    \         (if (char=? c #\\k)\n                                              \
    \                                  #\\p\n                                    \
    \                                            (if (char=? c #\\j)\n           \
    \                                                                         #\\\
    q\n                                                                          \
    \          (if (char=? c #\\i)\n                                             \
    \                                           #\\r\n                           \
    \                                                             (if (char=? c #\\\
    h)\n                                                                         \
    \                   #\\s\n                                                   \
    \                                         (if (char=? c #\\g)\n              \
    \                                                                            \
    \      #\\t\n                                                                \
    \                                (if (char=? c #\\f)\n                       \
    \                                                                            \
    \ #\\u\n                                                                     \
    \                               (if (char=? c #\\e)", "  (define (get-char c)\n\
    \    (cond\n      [(and (and (>= c 97) (<= c 122)) (and (>= (+ c (* 2 2)) 122)))\
    \ (- (+ c (* 2 2)) 26)]\n      [(and (and (>= c 97) (<= c 122)) (and (<= (+ c\
    \ (* 2 2)) 122))) (+ c (* 2 2))]\n      [(and (and (>= c 65) (<= c 90)) (and (>=\
    \ (+ c (* 2 2)) 90))) (- (+ c (* 2 2)) 26)]\n      [(and (and (>= c 65) (<= c\
    \ 90)) (and (<= (+ c (* 2 2)) 90))) (+ c (* 2 2))]\n      [else #f]))\n  (define\
    \ (get-letter l)\n    (cond\n      [(char=? l #\\a) #\\c]\n      [(char=? l #\\\
    b) #\\d]\n      [(char=? l #\\c) #\\e]\n      [(char=? l #\\d) #\\f]\n      [(char=?\
    \ l #\\e) #\\g]\n      [(char=? l #\\f) #\\h]\n      [(char=? l #\\g) #\\i]\n\
    \      [(char=? l #\\h) #\\j]\n      [(char=? l #\\i) #\\k]\n      [(char=? l\
    \ #\\j) #\\l]\n      [(char=? l #\\k) #\\m]\n      [(char=? l #\\l) #\\n]\n  \
    \    [(char=? l #\\m) #\\o]\n      [(char=? l #\\n) #\\p]\n      [(char=? l #\\\
    o) #\\q]\n      [(char=? l #\\p) #\\r]\n      [(char=? l #\\q) #\\s]\n      [(char=?\
    \ l #\\r) #\\t]\n      [(char=? l #\\s) #\\u]\n      [(char=? l #\\t) #\\v]\n\
    \      [(char=? l #\\u) #\\w]\n      [(char=? l #\\v) #\\x]\n     ", "  (define\
    \ alphabet (string->list \"abcdefghijklmnopqrstuvwxyz\"))\n  (define (char-to-int\
    \ c)\n    (sub1 (find c alphabet)))\n  (define (int-to-char n)\n    (list-ref\
    \ alphabet n))\n  (define (rotate n c)\n    (modulo (+ n (char-to-int c)) 26))\n\
    \  (define (encrypted-char c)\n    (int-to-char (rotate (* 2 2) c)))\n  (define\
    \ (encrypted-string-aux c acc)\n    (if (null? c)\n        (list->string (reverse\
    \ acc))\n        (encrypted-string-aux (cdr c) (cons (encrypted-char (car c))\
    \ acc))))\n  (encrypted-string-aux (string->list s) null))\n", "  (string-map\
    \ (lambda (c) (+ c (* 2 2))) s))\n", "  (define (helper c n)\n    (if (= c n)\n\
    \        #\\a\n        (helper (+ c 1) n)))\n  (define (enc s)\n    (if (= (string-length\
    \ s) 0)\n        (list)\n        (cons\n         (helper (+ (string-ref s 0) (string-ref\
    \ s 0)) #\\z)\n         (enc (substring s 1)))))\n  (bytes->string/utf-8 (enc\
    \ s)))", "  (list->string (map (lambda (c)\n\t\t       (if (and (<= #\\a c) (<=\
    \ c #\\z))\n\t\t\t   (+ c (* 2 2))\n\t\t\t   c))\n\t\t     (string->list s))))\n",
  "  (cond\n    [(string=? s \"\") \"\"]\n    [else (string-append\n            (list\
    \ (alphabet-rotate (string-ref s 0) (+ 2 (* 2 1))))\n            (encrypt (substring\
    \ s 1)))]))\n", "  (let ([lst (string->list s)])\n    (string-join\n     (map\n\
    \      (lambda (c)\n        (if (char-numeric? c)\n            c\n           \
    \ (integer->char (+ c (* 2 2)))))\n      lst)\n     \"\")))\n", "  (define (bounds?\
    \ c)\n    (let ((low (char->integer #\\a))\n          (high (char->integer #\\\
    z)))\n      (and (>= (char->integer c) low)\n           (<= (char->integer c)\
    \ high))))\n  (define (rotate c)\n    (let ((base (char->integer #\\a)))\n   \
    \   (integer->char (+ base (% (+ (- (char->integer c) base) 4) 26))))\n  (list->string\
    \ (map rotate (filter bounds? (string->list s)))))\n", "  (string-append (substring\
    \ s 2) (substring s 0 2)))\n", "  (cond\n    [(string=? s \"\") \"\"]\n    [else\
    \ (append (list (encrypt-char (string-ref s 0))) (encrypt (substring s 1)))]))\n",
  "  (cond\n    [(empty? s) empty]\n    [else (cons (rotate-char (first s) (* 2 2))\
    \ (encrypt (rest s)))]))\n", "  (cond ((string=? \"\" s) \"\")\n        (else\
    \ (cons (shift-char (string-ref s 0)) (encrypt (substring s 1))))))\n", "  (define\
    \ alpha (string->list \"abcdefghijklmnopqrstuvwxyz\"))\n  (define (encrypt-helper\
    \ s alpha)\n    (cond\n      ((null? s) \"\")\n      ((= (car s) #\\ ) (cons #\\\
    \  (encrypt-helper (cdr s) alpha)))\n      (else (cons (list-ref alpha (+ (* 2\
    \ 2) (list-index-of (car s) alpha)))\n                 (encrypt-helper (cdr s)\
    \ alpha)))))\n  (list->string (encrypt-helper (string->list s) alpha)))\n", " \
    \ (string-append (string-drop s 2) (string-take s 2)))\n", "  (string-append (string-downcase\
    \ (string-take s 1))\n\t\t (string-append (char-to-string (+ (string-ref s 1)\
    \ 2))\n\t\t\t\t(char-to-string (+ (string-ref s 2) 4)))))\n", "  (string-map (lambda\
    \ (c)\n                (if (char-alphabetic? c)\n                    (if (or (char=?\
    \ c #\\a) (char=? c #\\A))\n                        (if (char-lower-case? c)\n\
    \                            #\\y\n                            #\\Y)\n       \
    \                 (if (char=? c #\\b)\n                            (if (char-lower-case?\
    \ c)\n                                #\\z\n                                #\\\
    Z)\n                            (if (char-lower-case? c)\n                   \
    \             (char+ c (- #\\c #\\a))\n                                (char+\
    \ c (- #\\C #\\A)))))\n                    c))\n               s))\n", "  (define\
    \ (rotate l1 l2)\n    (if (null? l1)\n        l2\n        (rotate (cdr l1) (cons\
    \ (car l1) l2))))\n  (rotate (list->string s) '()))\n", "  (map (lambda (c)\n\
    \         (if (in-range? c #\\a #\\z)\n             (number->char (+ (char->number\
    \ c) 2))\n             c))\n       s))\n", "  (list->string\n   (rotate-letter\n\
    \    (string->list s) 2)))\n", "  (map (lambda (x)\n         (let ((y (+ x (*\
    \ 2 2))))\n           (if (&gt; y 122)\n               (- y 26)\n            \
    \   y))) s))\n</code>\nI'm not sure if I've misunderstood the question or if I'm\
    \ missing something. Any help is appreciated!\n\n\nA:\n\n<code>map</code> takes\
    \ a procedure and a list of arguments and applies the procedure to each argument\
    \ in the list. So, the result is a list of the results of applying the procedure\
    \ to each argument. \n<code>(map string-&gt;number '(\"1\" \"2\" \"3\")) -&gt;\
    \ '(1 2 3)\n</code>\nSince your <code>encrypt</code> procedure accepts a string\
    \ and applies <code>map</code> to it, it will produce a list of numbers. But you\
    \ can't compare a list to a string in the way you're doing.\n<code>(= '(\"2\"\
    ) \"2\") -&gt; error\n</code>\nYou could, for example, first convert the string\
    \ to a list of characters before using <code>map</code> on it.\n<code>(define\
    \ (encrypt s)\n  (map (lambda (x)\n         (let ((y (+ x (* 2 2))))\n       \
    \    (if (&gt; y 122)\n               (- y 26)\n               y))) (string-&gt;list\
    \ s)))\n</code>\nOr, you could use the built-in <code>string-map</code> procedure,\
    \ which is like <code>map</code> but works on strings instead of lists.\n<code>(define\
    \ (encrypt s)\n  (string-map (lambda (x)\n                (let ((y (+ x (* 2 2))))\n\
    \                  (if (&gt; y 122)\n                      (- y 26)\n        \
    \              y))) s))\n</code>\n", "  (define (offset-char c)\n    (let ((n\
    \ (char->integer c)))\n      (integer->char (+ n (* 2 2)))))\n  (string-map offset-char\
    \ s))\n", "  (map (lambda (c)\n         (let ([c (char-downcase c)])\n       \
    \    (if (or (char=? c #\\z) (char=? c #\\y))\n               (char-downcase\n\
    \                (char-add c (- #\\b)))\n               (char-downcase\n     \
    \           (char-add c #\\2)))))\n       s))\n", "  (map \n   (lambda (x)\n \
    \    (string (+ x (- ?a 2) (* 2 2))\n            (modulo (+ x (- ?a 2) (* 2 2))\
    \ 26)))\n   s))\n", "  (define (change-char c)\n    (let ([a (- c 97)])\n    \
    \  (if (< a 24) (add1 (add1 (add1 a))) (modulo a 24))))\n  (for/list ([c (in-string\
    \ s)])\n    (integer->char (change-char (char->integer c)))))", "  (for/list ([c\
    \ (in-string s)])\n    (let ([c (char-downcase c)])\n      (cond\n        [(char-alphabetic?\
    \ c) (char (+ c (* 2 2)))]\n        [else c]))))\n", "  (string-map\n   (lambda\
    \ (c)\n     (char-downcase c))\n   (map-string\n    (lambda (c)\n      (char+\
    \ c (* 2 2)))\n    s)))\n```\n\n```racket\n#lang racket\n", "  (cond\n    [(null?\
    \ s) '()]\n    [else (cons (encrypt-char (car s)) (encrypt (cdr s)))]))\n", " \
    \ (for/list ([x (in-string s)])\n    (integer->char (+ (char->integer x) (* 2\
    \ 2)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
