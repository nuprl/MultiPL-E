name: HumanEval_13_greatest_common_divisor
language: rkt
prompt: "#lang racket\n\n;; Return a greatest common divisor of two integers a and\
  \ b\n;; >>> (greatest_common_divisor 3 5)\n;; 1\n;; >>> (greatest_common_divisor\
  \ 25 15)\n;; 5\n(define (greatest_common_divisor a b)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate greatest_common_divisor))\n\
  \    (check-equal? (candidate 3 7) 1)\n    (check-equal? (candidate 10 15) 5)\n\
  \    (check-equal? (candidate 49 14) 7)\n    (check-equal? (candidate 144 60) 12)\n\
  ))\n\n(test-humaneval)"
completions: ["  (cond\n    [(= a 0) b]\n    [(= b 0) a]\n    [(= a b) a]\n    [(<\
    \ a b) (greatest_common_divisor (- b a) a)]\n    [else (greatest_common_divisor\
    \ a (- b a))]))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor (modulo\
    \ b a) a)))\n```\n\n##### `test.rkt`\n\n```racket\n#lang racket\n", "  (cond [(=\
    \ a 0) b]\n        [(= b 0) a]\n        [(< a b) (greatest_common_divisor a (-\
    \ b a))]\n        [else (greatest_common_divisor (- a b) b)]))\n", "  (if (= b\
    \ 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (define\
    \ (gcd-helper a b)\n    (if (= b 0)\n        a\n        (gcd-helper b (remainder\
    \ a b))))\n  (gcd-helper (abs a) (abs b)))\n", "  (if (= b 0)\n      a\n     \
    \ (greatest_common_divisor b (modulo a b))))\n", "  (define (divisor a b)\n  \
    \  (cond ((< a b) (divisor b a))\n          ((= a b) a)\n          ((= (remainder\
    \ a b) 0) b)\n          (else (divisor b (remainder a b)))))\n  (divisor a b))\n",
  "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", " \
    \ (cond\n    [(zero? b) a]\n    [else (greatest_common_divisor b (modulo a b))]))\n\
    ```\n\n**Usage**\n\n```racket\n#lang racket\n", "  (let loop ([a a] [b b])\n \
    \   (if (= b 0)\n        a\n        (loop b (- a (* (quotient a b) b))))))\n",
  "  (define (gcd a b)\n    (cond ((or (= a 0) (= b 0)) 0)\n          ((= a b) a)\n\
    \          ((> a b) (gcd (- a b) b))\n          (else (gcd a (- b a)))))\n  (let\
    \ ((a-abs (abs a))\n        (b-abs (abs b)))\n    (gcd a-abs b-abs)))\n", "  (cond\n\
    \    [(zero? b) a]\n    [else (greatest_common_divisor b (modulo a b))]))\n",
  "  (cond\n    [(> a b) (greatest_common_divisor a (- a b))]\n    [(> b a) (greatest_common_divisor\
    \ (- b a) b)]\n    [else a]))\n", "  (let ([abs_a (abs a)]\n        [abs_b (abs\
    \ b)])\n    (cond\n      [(> abs_a abs_b) (gcd abs_b abs_a)]\n      [(= abs_a\
    \ abs_b) abs_a]\n      [else (gcd (- abs_a abs_b) abs_b)])))\n```\n\n```racket\n\
    #lang racket\n", "  (define (rec a b)\n    (if (= b 0)\n        a\n        (rec\
    \ b (modulo a b))))\n  (rec (abs a) (abs b)))\n", "  (cond\n    [(= a 0) b]\n\
    \    [(= b 0) a]\n    [(= a b) a]\n    [(> a b) (greatest_common_divisor (- a\
    \ b) b)]\n    [else (greatest_common_divisor a (- b a))]))\n", "  (let ([r (modulo\
    \ a b)])\n    (if (= r 0)\n        b\n        (greatest_common_divisor b r))))\n",
  "  (cond [(= b 0) a]\n        [else (greatest_common_divisor b (modulo a b))]))\n",
  "  (cond ((< a b) (greatest_common_divisor b a))\n        ((= b 0) a)\n        (else\
    \ (greatest_common_divisor b (% a b)))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (let* ([range (range 0 (+ 1 (min a b)))])\n    (last\
    \ (filter (lambda (n) (zero? (modulo a n))\n                                 \
    \ (zero? (modulo b n)))\n                  range))))\n", "  (if (= b 0)\n    \
    \  a\n      (greatest_common_divisor b (modulo a b))))\n", "  (if (= a 0)\n  \
    \    b\n      (greatest_common_divisor (modulo b a) a)))\n", "  (if (= b 0)\n\
    \      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (if (= a 0)\n\
    \      b\n      (greatest_common_divisor (modulo b a) a)))\n", "  (cond ((zero?\
    \ b) a)\n        (else (greatest_common_divisor b (modulo a b)))))\n```\n\n```\n\
    #lang racket\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (define (greatest_common_divisor-iter r0 r1)\n    (if (= r1 0)\n\
    \        r0\n        (greatest_common_divisor-iter r1 (remainder r0 r1))))\n \
    \ (if (&lt; a b)\n      (greatest_common_divisor-iter b a)\n      (greatest_common_divisor-iter\
    \ a b)))\n</code>\nPython (no <code>if</code> statement):\n<code># Return a greatest\
    \ common divisor of two integers a and b\n# &gt;&gt;&gt; greatest_common_divisor(3,\
    \ 5)\n# 1\n# &gt;&gt;&gt; greatest_common_divisor(25, 15)\n# 5\ndef greatest_common_divisor(a,\
    \ b):\n    r0, r1 = (a, b) if a &gt; b else (b, a)\n    while r1 != 0:\n     \
    \   r0, r1 = r1, r0 % r1\n    return r0\n</code>\n", "  (cond\n    [(= a 0) b]\n\
    \    [(= b 0) a]\n    [(< a b) (greatest_common_divisor b a)]\n    [else (greatest_common_divisor\
    \ (- a b) b)]))\n", "  (if (= a 0) b\n      (greatest_common_divisor (- b (modulo\
    \ b a)) a)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n```\n\n``` #lang scala\n// Return a greatest common divisor of two\
    \ integers a and b\n// >>> greatestCommonDivisor(3, 5)\n// 1\n// >>> greatestCommonDivisor(25,\
    \ 15)\n// 5\ndef greatestCommonDivisor(a: Int, b: Int): Int =\n  if (b == 0) a\n\
    \  else greatestCommonDivisor(b, a % b)\n```\n\n``` #lang scala\n// Return a greatest\
    \ common divisor of two integers a and b\n// >>> greatestCommonDivisor(3, 5)\n\
    // 1\n// >>> greatestCommonDivisor(25, 15)\n// 5\ndef greatestCommonDivisor(a:\
    \ Int, b: Int): Int = {\n  @tailrec\n  def gcd(a: Int, b: Int): Int =\n    if\
    \ (b == 0) a\n    else gcd(b, a % b)\n  gcd(a, b)\n}\n```\n\n``` #lang scala\n\
    // Return a greatest common divisor of two integers a and b\n// >>> greatestCommonDivisor(3,\
    \ 5)\n// 1\n// >>> greatestCommonDivisor(25, 15)\n// 5\ndef greatestCommonDivisor(a:\
    \ Int, b: Int): Int = {\n  @tailrec\n  def gcd(a: Int, b: Int): Int =\n    if\
    \ (b == 0) a\n    else gcd(b, a % b)\n  if (a < b) gcd(b, a)\n  else gcd(a, b)\n\
    }\n```\n\n``` #lang scala\n// Return a greatest common divisor of two integers\
    \ a and b\n// >>> greatestCommonDivisor(3, 5)\n// 1\n// >>> greatestCommonDivisor(25,\
    \ 15)\n// 5\ndef greatestCommonDivisor(a: Int, b: Int): Int = {\n  @tailrec\n\
    \  def gcd(a: Int, b: Int): Int =\n    if (b == 0) a", "  (if (= b 0)\n      a\n\
    \      (greatest_common_divisor b (modulo a b))))\n", "  (cond\n    [(= a 0) b]\n\
    \    [(= b 0) a]\n    [(> a b) (greatest_common_divisor (- a b) b)]\n    [else\
    \ (greatest_common_divisor a (- b a))]))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (let ([b (abs b)])\n    (let loop ([a (abs a)])\n \
    \     (if (= a 0)\n          b\n          (loop (modulo b a))))))\n", "  (if (=\
    \ b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (if (=\
    \ b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (if (=\
    \ a 0)\n      b\n      (greatest_common_divisor (modulo b a) a)))\n```\n\n```\n\
    #lang racket\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor\n   \
    \    (modulo b a)\n       a)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (% a b))))\n", "  (let loop ((a a) (b b))\n    (if (= b 0)\n        a\n  \
    \      (loop b (modulo a b)))))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor\
    \ (modulo b a) a)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (cond\n    [(= a 0) b]\n    [(= b 0) a]\n    [(> a\
    \ b) (greatest_common_divisor (- a b) b)]\n    [else (greatest_common_divisor\
    \ a (- b a))]))\n", "  (cond\n    [(zero? b) a]\n    [else (greatest_common_divisor\
    \ b (modulo a b))]))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= a 0) b\n      (greatest_common_divisor (modulo\
    \ b a) a)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (% a\
    \ b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n```\n\n```racket\n#lang racket\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (cond ((= b 0) a)\n        (else (greatest_common_divisor\
    \ b (modulo a b)))))\n", "  (cond\n    [(= b 0) a]\n    [else (greatest_common_divisor\
    \ b (modulo a b))]))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n```\n\nOr if you're using `#lang sicp`:\n\n```scheme", " \
    \ (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", " \
    \ (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", " \
    \ (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", " \
    \ (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", " \
    \ (greatest_common_divisor_helper a b 0))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (define (helper a b)\n    (cond\n      [(= a 0) b]\n\
    \      [(= b 0) a]\n      [(> a b) (helper (- a b) b)]\n      [else (helper a\
    \ (- b a))]))\n  (helper (abs a) (abs b)))\n", "  (cond [(= b 0) a]\n        [else\
    \ (greatest_common_divisor b (modulo a b))]))\n", "  (if (= 0 b)\n      a\n  \
    \    (greatest_common_divisor b (modulo a b))))\n", "  (if (= b 0)\n      a\n\
    \      (greatest_common_divisor b (modulo a b))))\n", "  (if (= b 0)\n      a\n\
    \      (greatest_common_divisor b (modulo a b))))\n", "  (define (gcd a b)\n \
    \   (if (= b 0)\n        a\n        (gcd b (remainder a b))))\n  (if (< a b)\n\
    \      (gcd b a)\n      (gcd a b)))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor\n\
    \       (- b (% a b))\n       a)))\n", "  (cond\n    [(= a 0) b]\n    [(= b 0)\
    \ a]\n    [(> a b) (greatest_common_divisor (- a b) b)]\n    [else (greatest_common_divisor\
    \ a (- b a))]))\n", "  (cond\n    [(= a 0) b]\n    [(= b 0) a]\n    [(> a b) (greatest_common_divisor\
    \ (- a b) b)]\n    [else (greatest_common_divisor a (- b a))]))\n", "  (if (=\
    \ 0 b)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (if (=\
    \ 0 (remainder b a))\n      a\n      (greatest_common_divisor b (remainder b a))))\n\
    ```\n\n```\n#lang racket\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (define (helper a b)\n    (if (= b 0)\n        a\n\
    \        (helper b (modulo a b))))\n  (cond\n    [(= a 0) b]\n    [(= b 0) a]\n\
    \    [else (helper a b)]))\n", "  (cond ((< a b) (greatest_common_divisor b a))\n\
    \        ((= a b) a)\n        ((= b 0) a)\n        (else (greatest_common_divisor\
    \ b (- a b)))))\n", "  (cond\n    [(zero? b) a]\n    [else (greatest_common_divisor\
    \ b (modulo a b))]))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (let loop ([a (abs a)] [b (abs b)])\n    (cond\n  \
    \    [(zero? b) a]\n      [else (loop b (modulo a b))])))\n", "  (begin\n    (define\
    \ (helper a b)\n      (if (= b 0)\n          a\n          (helper b (modulo a\
    \ b))))\n    (if (&lt; a b)\n        (helper b a)\n        (helper a b))))\n",
  "  (cond ((= b 0) a)\n        (else (greatest_common_divisor b (% a b)))))\n", " \
    \ (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", " \
    \ (cond ((= b 0) a)\n        (else (greatest_common_divisor b (% a b)))))\n",
  "  (cond\n    [(> a b) (greatest_common_divisor (- a b) b)]\n    [(< a b) (greatest_common_divisor\
    \ a (- b a))]\n    [else a]))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (cond\n    [(> b a)\n     (greatest_common_divisor\
    \ b a)]\n    [(= b 0)\n     a]\n    [else\n     (greatest_common_divisor b (-\
    \ a b))]))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n```\n\n## 7. \u0420\u0430\u0446\u0438\u043E\u043D\u0430\u043B\u044C\
    \u043D\u044B\u0435 \u0447\u0438\u0441\u043B\u0430\n\n\u041F\u043E\u0434\u0440\u043E\
    \u0431\u043D\u0435\u0435 \u043E \u0440\u0430\u0446\u0438\u043E\u043D\u0430\u043B\
    \u044C\u043D\u044B\u0445 \u0447\u0438\u0441\u043B\u0430\u0445 \u043C\u043E\u0436\
    \u043D\u043E \u043F\u043E\u0447\u0438\u0442\u0430\u0442\u044C [\u0442\u0443\u0442\
    ](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE).\n\
    \n\u0420\u0430\u0446\u0438\u043E\u043D\u0430\u043B\u044C\u043D\u044B\u0435 \u0447\
    \u0438\u0441\u043B\u0430 \u043C\u043E\u0436\u043D\u043E \u0437\u0430\u043F\u0438\
    \u0441\u0430\u0442\u044C \u0434\u0432\u0443\u043C\u044F \u0441\u043F\u043E\u0441\
    \u043E\u0431\u0430\u043C\u0438. \u041F\u0435\u0440\u0432\u044B\u0439 \u0438\u0437\
    \ \u043D\u0438\u0445 \u0432 \u0432\u0438\u0434\u0435 \u0434\u0440\u043E\u0431\u0438\
    \ ```n / m```, \u0433\u0434\u0435 n \u0438 m - \u0446\u0435\u043B\u044B\u0435\
    \ \u0447\u0438\u0441\u043B\u0430. \u0414\u0440\u0443\u0433\u043E\u0439 \u0441\u043F\
    \u043E\u0441\u043E\u0431 \u0437\u0430\u043F\u0438\u0441\u0438 \u0434\u0440\u043E\
    \u0431\u0438 - \u0432 \u0432\u0438\u0434\u0435 \u0447\u0438\u0441\u043B\u0438\u0442\
    \u0435\u043B\u044F (numerator) \u0438 \u0437\u043D\u0430\u043C\u0435\u043D\u0430\
    \u0442\u0435\u043B\u044F (denominator), \u043A\u043E\u0442\u043E\u0440\u044B\u0435\
    \ \u043C\u043E\u0436\u043D\u043E \u043F\u0440\u0435\u0434\u0441\u0442\u0430\u0432\
    \u0438\u0442\u044C \u0432 \u0432\u0438\u0434\u0435 \u043F\u0430\u0440\u044B. \u0421\
    \u043E\u0437\u0434\u0430\u0439\u0442\u0435 \u0441\u0442\u0440\u0443\u043A\u0442\
    \u0443\u0440\u0443 \u0434\u0430\u043D\u043D\u044B\u0445 \u0440\u0430\u0446\u0438\
    \u043E\u043D\u0430\u043B\u044C\u043D\u043E\u0433\u043E \u0447\u0438\u0441\u043B\
    \u0430 \u0438 \u043D\u0430\u043F\u0438\u0448\u0438", "  (if (= b 0)\n      a\n\
    \      (greatest_common_divisor b (modulo a b))))\n", "  (if (= b 0)\n      a\n\
    \      (greatest_common_divisor b (modulo a b))))\n", "  (if (= b 0)\n      a\n\
    \      (greatest_common_divisor b (modulo a b))))\n", "  (if (= b 0)\n      a\n\
    \      (greatest_common_divisor b (modulo a b))))\n", "  (if (= b 0)\n      a\n\
    \      (greatest_common_divisor b (modulo a b))))\n", "  (let loop ([a a] [b b])\n\
    \    (if (= b 0)\n        a\n        (loop b (modulo a b)))))\n", "  (cond [(=\
    \ a 0) b]\n        [(= b 0) a]\n        [(> a b) (greatest_common_divisor (- a\
    \ b) b)]\n        [else (greatest_common_divisor a (- b a))]))\n", "  (define\
    \ (divides? a b)\n    (= (remainder b a) 0))\n  (define (find-divisor n test-divisor)\n\
    \    (cond ((> (square test-divisor) n) n)\n          ((divides? test-divisor\
    \ n) test-divisor)\n          (else (find-divisor n (+ test-divisor 1)))))\n \
    \ (define (gcd a b)\n    (if (= b 0)\n        a\n        (gcd b (remainder a b))))\n\
    \  (gcd (abs a) (abs b)))\n", "  (define (recursive a b)\n    (if (= b 0)\n  \
    \      a\n        (recursive b (modulo a b))))\n  (recursive (abs a) (abs b)))\n",
  "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n```\n\
    \n```racket\n#lang racket\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (cond\n    [(= a 0) b]\n    [(= b 0) a]\n    [(< a\
    \ b) (greatest_common_divisor a (- b a))]\n    [else (greatest_common_divisor\
    \ (- a b) b)]))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b\
    \ (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (cond ((= a 0)\n         b)\n        ((= b 0)\n   \
    \      a)\n        ((> a b)\n         (greatest_common_divisor (- a b) b))\n \
    \       (else\n         (greatest_common_divisor a (- b a)))))\n", "  (if (= b\
    \ 0)\n      a\n      (greatest_common_divisor b (% a b))))\n", "  (if (= b 0)\n\
    \      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (cond\n    ((equal?\
    \ a 0) b)\n    ((equal? b 0) a)\n    ((< a b) (greatest_common_divisor a (- b\
    \ a)))\n    ((> a b) (greatest_common_divisor (- a b) b))))\n", "  (cond\n   \
    \ [(= b 0) a]\n    [else (greatest_common_divisor b (modulo a b))]))\n", "  (if\
    \ (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (let\
    \ ([c (gcd a b)])\n    c))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor\
    \ (modulo b a) a)))\n", "  (define (euclid a b)\n    (if (= b 0)\n        a\n\
    \        (euclid b (modulo a b))))\n  (if (= a 0)\n      (abs b)\n      (if (=\
    \ b 0)\n          (abs a)\n          (euclid (abs a) (abs b)))))\n", "  (define\
    \ (loop a b)\n    (if (= b 0)\n        a\n        (loop b (modulo a b))))\n  (loop\
    \ (abs a) (abs b)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (let loop ([a a] [b b])\n    (if (= b 0)\n        a\n\
    \        (loop b (modulo a b)))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n```\n\n```scheme\n#lang racket\n", "  (cond\n    [(= a 0)\
    \ b]\n    [(= b 0) a]\n    [(> a b) (greatest_common_divisor (- a b) b)]\n   \
    \ [else (greatest_common_divisor a (- b a))]))\n", "  (letrec ([gcd (lambda (a\
    \ b)\n                  (if (= b 0)\n                      a\n               \
    \       (gcd b (remainder a b))))])\n    (gcd a b)))\n", "  (if (= b 0)\n    \
    \  a\n      (greatest_common_divisor b (modulo a b))))\n", "  (cond [(= a 0) b]\n\
    \        [(= b 0) a]\n        [(and (< a 0) (< b 0))\n         (greatest_common_divisor\
    \ (- a) (- b))]\n        [(and (< a 0) (> b 0))\n         (greatest_common_divisor\
    \ (- a) b)]\n        [(and (> a 0) (< b 0))\n         (greatest_common_divisor\
    \ a (- b))]\n        [(> a b)\n         (greatest_common_divisor (- a b) b)]\n\
    \        [else\n         (greatest_common_divisor a (- b a))]))\n", "  (cond\n\
    \    [(= a 0) b]\n    [(= b 0) a]\n    [(= a b) a]\n    [(> a b) (greatest_common_divisor\
    \ (- a b) b)]\n    [else (greatest_common_divisor a (- b a))]))\n", "  (if (=\
    \ b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n```\n\n```racket\n\
    #lang racket\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n```\n\nWe can see that the greatest common divisor of 3 and 5 is 1,\
    \ and 5 and 15 is 5.\n\n---\n\n## Modular arithmetic\n\nModular arithmetic is\
    \ a system of arithmetic for integers where numbers \"wrap around\" when reaching\
    \ a certain value\u2014the modulus.\n\n---\n\n## Modular arithmetic - Example\n\
    \nThe expression \"a modulo b\" can be read as \"the remainder of a divided by\
    \ b\", which is the integer remainder from dividing a by b.\n\nFor example, \"\
    11 modulo 5\" is equal to 1, because when 11 is divided by 5, the remainder is\
    \ 1.\n\n---\n\n## Modular arithmetic - Example\n\nThe expression \"17 modulo 12\"\
    \ is equal to 5, because when 17 is divided by 12, the remainder is 5.\n\n---\n\
    \n## Polymorphism\n\n*Polymorphism* is the ability to make a single interface\
    \ work with a variety of types.\n\nIn C++, Java and C#, polymorphism is achieved\
    \ by subclassing and overriding.\n\nIn Clojure and Haskell, it is achieved by\
    \ a combination of overloading and generics.\n\nBut in Racket, it is more pure\
    \ and elegant. The same function name can be used for same function with different\
    \ parameters. Racket can infer the type of the parameters and call the proper\
    \ function.\n\n---\n\n## Polymorphism - Example\n\n``` #lang racket\n", "  (if\
    \ (= a 0)\n      b\n      (greatest_common_divisor b (% a b))))\n", "  (if (=\
    \ b 0)\n      a\n      (greatest_common_divisor b (% a b))))\n", "  (define (gcd\
    \ a b)\n    (if (= b 0)\n        a\n        (gcd b (remainder a b))))\n  (gcd\
    \ (abs a) (abs b)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (define (gcd a b)\n    (cond ((= b 0) a)\n        \
    \  (else (gcd b (remainder a b)))))\n  (gcd (abs a) (abs b)))\n", "  (cond\n \
    \   [(> a b) (greatest_common_divisor (- a b) b)]\n    [(> b a) (greatest_common_divisor\
    \ a (- b a))]\n    [else a]))\n", "  (cond\n    [(= a 0) b]\n    [(= b 0) a]\n\
    \    [(< a b) (greatest_common_divisor (- b a) a)]\n    [else (greatest_common_divisor\
    \ (- a b) b)]))\n", "  (cond ((< a b) (greatest_common_divisor b a))\n       \
    \ ((= a 0) b)\n        ((= b 0) a)\n        (else (greatest_common_divisor (-\
    \ a b) b))))\n", "  (cond [(= a 0) b]\n        [(= b 0) a]\n        [(< a b) (greatest_common_divisor\
    \ a (- b a))]\n        [else (greatest_common_divisor (- a b) b)]))\n```\n\n###\
    \ 2.3\n\n```racket\n#lang racket\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= a 0) b\n      (greatest_common_divisor (modulo\
    \ b a) a)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (greatest_common_divisor_iter a b (- b 1)))\n", "  (cond [(=\
    \ a 0) b]\n        [(= b 0) a]\n        [(> a b) (greatest_common_divisor (- a\
    \ b) b)]\n        [else (greatest_common_divisor a (- b a))]))\n", "  (let loop\
    \ ([a a] [b b])\n    (if (= b 0)\n        a\n        (loop b (modulo a b)))))\n",
  "  (cond [(= a 0) b]\n        [(= b 0) a]\n        [(< a b) (greatest_common_divisor\
    \ a (- b a))]\n        [else (greatest_common_divisor (- a b) b)]))\n", "  (if\
    \ (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n</code>\n\
    However, the result for <code>(greatest_common_divisor 25 15)</code> is <code>10</code>.\
    \ What's wrong?\n<code>#lang racket\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (local [(define (gcd a b)\n            (if (= b 0)\n\
    \                a\n                (gcd b (remainder a b))))]\n    (gcd (abs\
    \ a) (abs b))))\n", "  (let ([[small large] (sort (list a b) <)])\n    (let loop\
    \ ([i 1])\n      (if (< (* i large) small)\n          (loop (+ i 1))\n       \
    \   (if (zero? (mod large i))\n              i\n              (loop (+ i 1)))))))\n",
  "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", " \
    \ (if (= b 0)\n      a\n      (greatest_common_divisor b (% a b))))\n", "  (cond\n\
    \    [(= a 0) b]\n    [(= b 0) a]\n    [(< a b) (greatest_common_divisor b (-\
    \ b a))]\n    [else (greatest_common_divisor a (- a b))]))\n", "  (define (greatest_common_divisor_iter\
    \ a b remainder)\n    (if (= remainder 0) b\n        (greatest_common_divisor_iter\
    \ b remainder\n                                      (modulo a b))))\n  (greatest_common_divisor_iter\
    \ a b (modulo a b)))\n", "  (if (= a 0) b\n      (greatest_common_divisor (modulo\
    \ b a) a)))\n", "  (define (gcd-iter a b d)\n    (cond ((zero? a) d)\n       \
    \   ((zero? b) d)\n          ((= (remainder a d) 0) d)\n          ((= (remainder\
    \ b d) 0) d)\n          (else (gcd-iter a b (- d 1)))))\n  (gcd-iter a b (min\
    \ a b)))\n", "  (cond [(zero? b) a]\n        [else (greatest_common_divisor b\
    \ (modulo a b))]))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (cond\n    [(= b 0) a]\n    [else (greatest_common_divisor\
    \ b (modulo a b))]))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (gcd b (remainder a b)))\n", "  (if (= b 0)\n     \
    \ a\n      (greatest_common_divisor b (modulo a b))))\n```\n\u0417\u0430\u043F\
    \u0443\u0441\u0442\u0438\u0442\u0435 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\
    \u043C\u0443 \u0438 \u0443\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044C, \u0447\
    \u0442\u043E \u0432\u0441\u0435 \u0442\u0435\u0441\u0442\u044B \u043F\u0440\u043E\
    \u0445\u043E\u0434\u044F\u0442.\n\n\u0412 \u044D\u0442\u043E\u0439 \u043B\u0430\
    \u0431\u043E\u0440\u0430\u0442\u043E\u0440\u043D\u043E\u0439 \u0440\u0430\u0431\
    \u043E\u0442\u0435 \u0432\u0430\u043C \u043D\u0435\u043E\u0431\u0445\u043E\u0434\
    \u0438\u043C\u043E \u0440\u0435\u0430\u043B\u0438\u0437\u043E\u0432\u0430\u0442\
    \u044C \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C \u0432\u044B\u0447\u0438\
    \u0441\u043B\u0435\u043D\u0438\u044F\n\u041D\u041E\u0414 \u043F\u043E \u0430\u043B\
    \u0433\u043E\u0440\u0438\u0442\u043C\u0443 \u0415\u0432\u043A\u043B\u0438\u0434\
    \u0430, \u043E\u0441\u043D\u043E\u0432\u0430\u043D\u043D\u043E\u043C\u0443 \u043D\
    \u0430 \u0432\u043E\u0437\u0432\u0435\u0434\u0435\u043D\u0438\u0438 \u0432 \u0441\
    \u0442\u0435\u043F\u0435\u043D\u044C \u0438 \u0438\u0437\u0432\u043B\u0435\u0447\
    \u0435\u043D\u0438\u0438\n\u043A\u0432\u0430\u0434\u0440\u0430\u0442\u043D\u043E\
    \u0433\u043E \u043A\u043E\u0440\u043D\u044F. \u041F\u0440\u0438 \u044D\u0442\u043E\
    \u043C \u0440\u0435\u0430\u043B\u0438\u0437\u043E\u0432\u0430\u0442\u044C \u0432\
    \u0441\u043F\u043E\u043C\u043E\u0433\u0430\u0442\u0435\u043B\u044C\u043D\u044B\
    \u0435 \u0444\u0443\u043D\u043A\u0446\u0438\u0438 `modular_power`\n\u0438 `modular_square_root`.\n\
    \n\u041F\u0440\u0438\u043C\u0435\u0440:\n```\n>>> (modular_power 5 3 7)\n4\n>>>\
    \ (modular_square_root 5 3 7)\n2\n>>> (greatest_common_divisor 25 15)\n5\n```\n\
    \n# \u0421\u0440\u043E\u043A\u0438 \u0441\u0434\u0430\u0447\u0438\n\n\u0414\u043E\
    : 31.05.2020\n\n# \u0421\u0438\u0441\u0442\u0435\u043C\u0430 \u043E\u0446\u0435\
    \u043D\u043A\u0438\n\n\u0417\u0430\u0434\u0430\u043D\u0438\u0435 \u043E\u0446\u0435\
    \u043D\u0438\u0432\u0430\u0435\u0442\u0441\u044F \u0432 3 \u0431\u0430\u043B\u043B\
    \u0430.\n\n# \u041A\u0430\u043A \u0441\u0434\u0430\u0432\u0430\u0442\u044C\n\n\
    1. \u0421\u043E\u0437\u0434\u0430\u0439\u0442\u0435", "  (cond\n    [(= b 0) a]\n\
    \    [else (greatest_common_divisor b (% a b))]))\n", "  (if (= b 0)\n      a\n\
    \      (greatest_common_divisor b (modulo a b))))\n```\n\n``` #lang scribble/lp2\n\
    ```\n\n``` #lang racket\n", "  (if (= 0 b)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n```\n\n```racket\n#lang racket\n", "  (if (= a 0)\n     \
    \ b\n      (greatest_common_divisor (modulo b a) a)))\n", "  (define (iter x y)\n\
    \    (cond ((< x y) (iter x (- y x)))\n          ((< y x) (iter (- x y) y))\n\
    \          (else x)))\n  (iter (abs a) (abs b)))\n", "  (if (= b 0)\n      a\n\
    \      (greatest_common_divisor b (modulo a b))))\n", "  (if (= b 0)\n      a\n\
    \      (greatest_common_divisor b (modulo a b))))\n", "  (cond\n    [(> a b) (greatest_common_divisor\
    \ (- a b) b)]\n    [(> b a) (greatest_common_divisor a (- b a))]\n    [else  \
    \ a]))\n```\n\n## Euclid\u2019s Algorithm\n\n```scheme", "  (let ((a (abs a))\n\
    \        (b (abs b)))\n    (cond\n      [(zero? b) a]\n      [else (greatest_common_divisor\
    \ b (remainder a b))])))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (cond\n    [(= a 0) b]\n    [(= b 0) a]\n    [(< a\
    \ b) (greatest_common_divisor a (- b a))]\n    [else (greatest_common_divisor\
    \ (- a b) b)]))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b\
    \ (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n```\n\n```racket\n#lang racket\n", "  (if (= b 0)\n     \
    \ a\n      (greatest_common_divisor b (modulo a b))))\n```\n\n### `is_prime.rkt`\n\
    \n```#lang racket\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n```\n\n### Testing\n\n```\nRacket 6.11-2018-03-28\nWelcome\
    \ to Racket v6.11.\n> (require \"greatest_common_divisor.rkt\")\n> (greatest_common_divisor\
    \ 3 5)\n1\n> (greatest_common_divisor 25 15)\n5\n```\n\n## References\n\n* [Racket\
    \ (programming language)](https://en.wikipedia.org/wiki/Racket_(programming_language))\n\
    * [Racket Documentation](https://docs.racket-lang.org/index.html)\n* [Math - Racket\
    \ Documentation](https://docs.racket-lang.org/reference/math.html)", "  (if (=\
    \ b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (if (=\
    \ a 0) b\n      (greatest_common_divisor (modulo b a) a)))\n", "  (if (= b 0)\n\
    \      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (define (gcd\
    \ a b)\n    (cond [(= b 0) a]\n          [else (gcd b (modulo a b))]))\n  (gcd\
    \ (abs a) (abs b)))\n", "  (let loop ([a a] [b b])\n    (if (= b 0)\n        a\n\
    \        (loop b (modulo a b)))))\n", "  (letrec ([gcd (lambda (a b)\n       \
    \           (if (= a 0)\n                      b\n                      (gcd (modulo\
    \ b a) a)))])\n    (gcd a b)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (cond\n    [(= a 0) b]\n    [(= b 0) a]\n    [(<= a\
    \ b) (greatest_common_divisor (- b a) a)]\n    [else (greatest_common_divisor\
    \ (- a b) b)]))\n", "  (if (= a 0) b\n      (greatest_common_divisor (modulo b\
    \ a) a)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (let loop ([a a] [b b])\n    (if (or (and (zero? a) (zero? b))\n\
    \            (and (zero? a) (not (zero? b)))\n            (and (not (zero? a))\
    \ (zero? b)))\n        0\n        (if (&lt; a b)\n            (loop (- b a) a)\n\
    \            (loop (- a b) b)))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (let ([lower (min a b)]\n        [upper (max a b)])\n\
    \    (cond\n      [(= upper 0) lower]\n      [else (greatest_common_divisor lower\
    \ (modulo upper lower))])))\n```\n\n## \uBCF5\uBA74\uAC00\uC655\n\n```racket\n\
    #lang racket\n", "  (cond\n    [(< a 0) (greatest_common_divisor (- a) b)]\n \
    \   [(< b 0) (greatest_common_divisor a (- b))]\n    [(< a b) (greatest_common_divisor\
    \ b a)]\n    [(= b 0) a]\n    [else (greatest_common_divisor (- a b) b)]))\n",
  "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
