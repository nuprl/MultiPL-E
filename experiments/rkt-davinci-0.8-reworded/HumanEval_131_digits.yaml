name: HumanEval_131_digits
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer n, return the product of the\
  \ odd digits.\n;; Return 0 if all digits are even.\n;; For example:\n;; >>> (digits\
  \ 1)\n;; 1\n;; >>> (digits 4)\n;; 0\n;; >>> (digits 235)\n;; 15\n(define (digits\
  \ n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digits))\n\
  \    (check-equal? (candidate 5) 5)\n    (check-equal? (candidate 54) 5)\n    (check-equal?\
  \ (candidate 120) 1)\n    (check-equal? (candidate 5014) 5)\n    (check-equal? (candidate\
  \ 98765) 315)\n    (check-equal? (candidate 5576543) 2625)\n    (check-equal? (candidate\
  \ 2468) 0)\n))\n\n(test-humaneval)"
completions: ["  (match n\n    [(0) 0]\n    [(? even? n) (digits (quotient n 10))]\n\
    \    [(? odd? n) (let ([n (quotient n 10)])\n                  (if (and (= n 0)\
    \ (odd? n)) 1 (* n (digits n))))]))\n", "  (cond [(and (= n 0) (&gt; (quotient\
    \ n 10) 0)) 0]\n        [(and (= n 0) (&lt; (quotient n 10) 0)) 0]\n        [(and\
    \ (&gt; (remainder n 10) 0) (= (quotient n 10) 0)) (remainder n 10)]\n       \
    \ [(and (&gt; (remainder n 10) 0) (&gt; (quotient n 10) 0)) (* (remainder n 10)\
    \ (digits (quotient n 10)))]\n        [(and (= (remainder n 10) 0) (&gt; (quotient\
    \ n 10) 0)) (digits (quotient n 10))]\n        [else 1]))\n\n</code>\nI keep getting\
    \ 1 no matter what the input.  I thought the recursion would go through the digits,\
    \ but obviously I am doing something wrong.  Thanks for the help!\n\n\nA:\n\n\
    This is one of the few times that it might be worth to go through each possible\
    \ value of the input. I'll do <code>1</code> and <code>2</code> as a sample and\
    \ you can try the rest of the numbers on your own.\nSample code:\n<code>(digits\
    \ 1)\n</code>\n<code>(and (= n 0) (&gt; (quotient n 10) 0))</code> is false\n\
    <code>(and (= n 0) (&lt; (quotient n 10) 0))</code> is false\n<code>(and (&gt;\
    \ (remainder n 10) 0) (= (quotient n 10) 0))</code> is true\n<code>(remainder\
    \ n 10)</code> is <code>1</code>\nSo you return <code>1</code>\nNow, let's try\
    \ <code>2</code>\n<code>(digits 2)\n</code>\n<code>(and (= n 0) (&gt; (quotient\
    \ n 10) 0))</code> is false\n<code>(and (= n 0) (&lt; (quotient n 10) 0))</code>\
    \ is false\n<code>(and (&gt; (remainder n 10) 0) (= (quotient n 10) 0))</code>",
  "  (if (= n 0)\n      0\n      (let ([digit (modulo n 10)])\n        (if (odd? digit)\n\
    \            (+ (* digit (digits (quotient n 10)))\n               (digits (quotient\
    \ n 10)))\n            (digits (quotient n 10))))))\n", "  (if (zero? n)\n   \
    \   1\n      (* n (digits (sub1 n)))))\n", "  (if (odd? n)\n      (* n (digits\
    \ (quotient n 10)))\n      (digits (quotient n 10))))\n", "  (if (even? n) 0 (*\
    \ n (digits (quotient n 10)))))\n</code>\nSo I've got this far. Would any recursion\
    \ experts point me in the right direction? Thank you.\n\n\nA:\n\nWell, one thing\
    \ you'll find out about recursion is that the first thing you should do is consider\
    \ the base case. As I understand it, the base case for this problem is when <code>n</code>\
    \ is less than 10. \nThe other thing you need to think about is the recursive\
    \ case. In this case, it's going to be when <code>n</code> is greater than 10.\
    \ If that's the case, then you'll want to find the product of the odd digits by\
    \ making a recursive call. However, you'll also want to multiply whatever you\
    \ get back by <code>n</code> modulo 10.\nSo then, we just need to put these two\
    \ things together. Here's my attempt at an implementation:\n<code>(define (odd-digit-product\
    \ n)\n  (if (&lt; n 10)\n      (if (odd? n) n 0)\n      (* (odd-digit-product\
    \ (quotient n 10)) (modulo n 10))))\n</code>\nDoes that get you started?\n", " \
    \ (if (= n 0)\n      0\n      (if (odd? (remainder n 10))\n          (* (digits\
    \ (quotient n 10)) (remainder n 10))\n          (digits (quotient n 10)))))\n",
  "  (if (= 0 n) 0\n      (let* ([d (remainder n 10)]\n             [r (quotient n\
    \ 10)])\n        (if (odd? d) (* d (digits r))\n            (digits r)))))\n",
  "  (let loop ((n n) (d 0))\n    (cond ((negative? n) d)\n          ((zero? (modulo\
    \ n 2)) (loop (quotient n 10) d))\n          (else (loop (quotient n 10) (+ d\
    \ (remainder n 10)))))))\n", "  (if (zero? n)\n      0\n      (let* ([n (remainder\
    \ n 10)]\n             [n (if (odd? n) n 0)])\n        (+ n (digits (quotient\
    \ n 10))))))\n", "  (define (prod-odds lst)\n    (cond\n      [(null? lst) 0]\n\
    \      [(odd? (car lst))\n       (* (car lst) (prod-odds (cdr lst)))]\n      [else\
    \ (prod-odds (cdr lst))]))\n  (prod-odds (list->digits n)))\n", "  (if (odd? n)\n\
    \      (if (zero? (modulo n 10))\n          0\n          (* n (digits (quotient\
    \ n 10))))\n      (digits (quotient n 10))))", "  (cond ((zero? n) 0)\n      \
    \  ((even? (remainder n 10)) (digits (quotient n 10)))\n        (else (* (remainder\
    \ n 10) (digits (quotient n 10))))))", "  (cond [(= n 0) 0]\n        [(odd? (remainder\
    \ n 10))\n         (* (remainder n 10) (digits (quotient n 10)))]\n        [else\
    \ (digits (quotient n 10))]))\n```\n\n```racket\n#lang racket\n", "  (cond\n \
    \   [(empty? n) 0]\n    [(even? (first n)) (digits (rest n))]\n    [else (* (first\
    \ n) (digits (rest n)))]))\n```\n\n```", "  (if (= n 0)\n      0\n      (if (odd?\
    \ (remainder n 10))\n          (* (digits (quotient n 10)) (remainder n 10))\n\
    \          (digits (quotient n 10)))))\n", "  (if (even? n)\n      0\n      (*\
    \ n (digits (quotient n 10)))))\n", "  (if (odd? n)\n      (if (equal? n 1)\n\
    \          n\n          (* n (digits (- n 1))))\n      0))\n", "  (if (zero? n)\n\
    \      0\n      (if (even? (remainder n 10))\n          (digits (quotient n 10))\n\
    \          (* (remainder n 10) (digits (quotient n 10))))))\n", "  (cond [(= n\
    \ 0) 0]\n        [(odd? (remainder n 10)) (* (digits (quotient n 10)) (remainder\
    \ n 10))]\n        [else (digits (quotient n 10))]))\n", "  (if (equal? n 0)\n\
    \      0\n      (if (odd? (remainder n 10))\n          (* (digits (quotient n\
    \ 10)) (remainder n 10))\n          (digits (quotient n 10)))))\n", "  (cond ((=\
    \ n 0) 0)\n        ((even? (remainder n 10)) (digits (quotient n 10)))\n     \
    \   (else (* (remainder n 10) (digits (quotient n 10))))))\n```\nThis code loops\
    \ indefinitely when its input is 0, like so:\n```\n> (digits 0)\n0\n0\n0\n0\n\
    0\n^C\nuser break\n>\n```\nWrite a different version of the function that works\
    \ correctly for\nall positive integers. \n\n## 3A.\n```racket\n#lang racket\n",
  "  (cond [(= 0 n) 0]\n        [(odd? (remainder n 10))\n         (* (remainder n\
    \ 10) (digits (quotient n 10)))]\n        [else (digits (quotient n 10))]))\n",
  "  (cond\n    ((= n 0) 0)\n    ((odd? (modulo n 10))\n     (* (modulo n 10) (digits\
    \ (quotient n 10))))\n    (else (digits (quotient n 10)))))\n", "  (cond [(zero?\
    \ n) 0]\n        [(and (odd? n) (not (zero? n))) (* n (digits (quotient n 10)))]\n\
    \        [else (digits (quotient n 10))]))\n", "  (if (not (positive? n)) 0\n\
    \      (+ (* (quotient n 10) (modulo n 10))\n         (digits (quotient n 10)))))",
  "  (define (loop n acc)\n    (cond [(zero? n) acc]\n          [(odd? (remainder\
    \ n 10)) (loop (quotient n 10) (* acc (remainder n 10)))]\n          [else (loop\
    \ (quotient n 10) acc)]))\n  (loop n 1))", "  (let ((x (number->string n))\n \
    \       (product 1))\n    (for ([c (in-string x)])\n      (if (odd? (string->number\
    \ (string c)))\n          (set! product (* product (string->number (string c))))))\n\
    \    product))\n", "  (cond [(= n 0) 0]\n        [(odd? (remainder n 10)) (* (digits\
    \ (quotient n 10)) (remainder n 10))]\n        [else (digits (quotient n 10))]))\n\
    ```\n\n```text\n#lang racket\n", "  (cond\n    ((< n 10)\n     (if (odd? n) n\
    \ 0))\n    (else\n     (if (odd? (remainder n 10))\n       (* (digits (quotient\
    \ n 10)) (remainder n 10))\n       (digits (quotient n 10))))))", "  (cond\n \
    \   [(zero? n) 0]\n    [(odd? (modulo n 10)) (* (modulo n 10) (digits (quotient\
    \ n 10)))]\n    [else (digits (quotient n 10))]))", "  (cond ((zero? n) 0)\n \
    \       ((odd? n) (* n (digits (quotient n 10))))\n        (else (digits (quotient\
    \ n 10)))))\n", "  (if (= n 0)\n      0\n      (let* ([d (modulo n 10)]\n    \
    \         [r (digits (quotient n 10))])\n        (if (odd? d)\n            (*\
    \ d r)\n            r))))\n```\n\n```racket\n#lang racket\n", "  (if (&lt; n 10)\n\
    \      (if (odd? n) n 0)\n      (+ (* (remainder n 10) (digits (quotient n 10)))\n\
    \         (if (odd? n) n 0))))\n</code>\nIn Python:\n<code>#lang python\n\n# Given\
    \ a positive integer n, return the product of the odd digits.\n# Return 0 if all\
    \ digits are even.\n# For example:\n# &gt;&gt;&gt; digits(1)\n# 1\n# &gt;&gt;&gt;\
    \ digits(4)\n# 0\n# &gt;&gt;&gt; digits(235)\n# 15\ndef digits(n):\n    if n &lt;\
    \ 10:\n        if n % 2 == 1:\n            return n\n        else:\n         \
    \   return 0\n    else:\n        return (n % 10) * digits(n / 10) + (n if n %\
    \ 2 == 1 else 0)\n</code>\nThe Python program works as expected, but the Racket\
    \ program returns incorrect results. I'm not sure what I'm doing wrong. \n\n\n\
    A:\n\nYour <code>digits</code> procedure should be this way:\n<code>(define (digits\
    \ n)\n  (cond ((&lt; n 10)\n         (if (odd? n) n 0))\n        ((odd? n)\n \
    \        (+ (* (remainder n 10) (digits (quotient n 10))) n))\n        (else\n\
    \         (* (remainder n 10) (digits (quotient n 10))))))\n</code>\nWhen <code>n</code>\
    \ is smaller than 10, you need to return <code>n</code> if <code>n</code> is odd,\
    \ otherwise return 0. That's the <code>if</code> expression you already have.\n\
    If <code>n</code> is odd, you need to call <code>digits</code> recursively, adding\
    \ <code>n</code> to the result. This is the last <code>else</code> clause in the\
    \ <code>cond</code> expression.\nIf <code>n</code> is even, you need to call <code>digits</code>\
    \ recurs", "  (if (empty? n) 0\n      (digits-iter n 1)))\n", "  (cond ((not (positive?\
    \ n)) '())\n        ((odd? n) n)\n        (else '())))\n", "  (if (zero? n)\n\
    \      0\n      (if (odd? (remainder n 10))\n          (* (remainder n 10) (digits\
    \ (quotient n 10)))\n          (digits (quotient n 10)))))\n", "  (cond\n    [(even?\
    \ n) (digits (quotient n 10))]\n    [(zero? n) 0]\n    [else (* n (digits (quotient\
    \ n 10)))]))", "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 10)) (* (remainder\
    \ n 10) (digits (quotient n 10)))]\n    [else (digits (quotient n 10))]))", " \
    \ (if (zero? n) 0\n      (let ([current-digit (modulo n 10)])\n        (if (odd?\
    \ current-digit)\n            (* current-digit (digits (quotient n 10)))\n   \
    \         (digits (quotient n 10))))))\n", "  (define (helper n acc)\n    (cond\n\
    \      [(zero? n) acc]\n      [(even? (remainder n 10)) (helper (quotient n 10)\
    \ acc)]\n      [else (helper (quotient n 10) (* acc (remainder n 10)))]))\n  (helper\
    \ n 1))\n", "  (cond\n    [(= n 0) 0]\n    [(odd? (remainder n 10)) (* (digits\
    \ (quotient n 10)) (remainder n 10))]\n    [else (digits (quotient n 10))]))",
  "  (define (digits-iter answer n)\n    (if (= n 0)\n        answer\n        (if\
    \ (odd? (remainder n 10))\n            (digits-iter (* answer (remainder n 10))\
    \ (quotient n 10))\n            (digits-iter answer (quotient n 10)))))\n  (digits-iter\
    \ 1 n))\n", "  (if (zero? n)\n      0\n      (if (odd? (remainder n 10))\n   \
    \       (* (remainder n 10) (digits (quotient n 10)))\n          (digits (quotient\
    \ n 10)))))\n", "  (if (zero? n)\n      0\n      (let ([k (remainder n 10)])\n\
    \        (if (odd? k)\n            (* k (digits (quotient n 10)))\n          \
    \  (digits (quotient n 10))))))\n", "  (cond\n    [(= n 0) 0]\n    [(= (remainder\
    \ n 2) 1) (* (quotient n 10) (remainder n 10))]\n    [else (digits (quotient n\
    \ 10))]))\n", "  (cond\n    [(= 0 n) 0]\n    [(even? (modulo n 10)) (digits (quotient\
    \ n 10))]\n    [else (* (modulo n 10) (digits (quotient n 10)))]))\n", "  (if\
    \ (zero? n)\n      0\n      (if (odd? (remainder n 10))\n          (* (remainder\
    \ n 10) (digits (quotient n 10)))\n          (digits (quotient n 10)))))\n", " \
    \ (if (= n 0)\n      0\n      (+ (* (remainder n 10) (digits (quotient n 10)))\n\
    \         (if (odd? (remainder n 10))\n             (remainder n 10)\n       \
    \      0))))", "  (define (iter n acc)\n    (cond [(zero? n) acc]\n          [(odd?\
    \ (remainder n 10)) (iter (quotient n 10) (* acc (remainder n 10)))]\n       \
    \   [else (iter (quotient n 10) acc)]))\n  (iter n 1))", "  (cond\n    [(= n 0)\
    \ 0]\n    [(odd? (remainder n 10)) (* (digits (quotient n 10)) (remainder n 10))]\n\
    \    [else (digits (quotient n 10))]))\n", "  (cond\n    [(empty? n) 0]\n    [(odd?\
    \ (first n)) (* (first n) (digits (rest n)))]\n    [else (digits (rest n))]))\n\
    ```\n\n```\n#lang racket\n", "  (if (= n 0)\n      0\n      (if (odd? (remainder\
    \ n 10))\n          (* (remainder n 10) (digits (quotient n 10)))\n          (digits\
    \ (quotient n 10)))))\n```\n\n$> racket digits.rkt\n1\n0\n15\n\n## Copyright\n\
    \nBruno Sutic", "  (cond [(zero? n) 0]\n        [(odd? n) n]\n        [else (digits\
    \ (quotient n 10))]))", "  (if (null? n)\n      1\n      (if (odd? (car n))\n\
    \          (* (car n) (digits (cdr n)))\n          (digits (cdr n)))))\n", " \
    \ (if (= n 0)\n      0\n      (let ([d (modulo n 10)])\n        (if (odd? d)\n\
    \            (* d (digits (quotient n 10)))\n            (digits (quotient n 10))))))\n\
    ```\n\n```racket\n#lang racket\n", "  (cond [(= n 0) 1]\n        [(odd? n) (*\
    \ n (digits (quotient n 10)))]\n        [else (digits (quotient n 10))]))", " \
    \ (cond\n    ((= 0 n) 0)\n    ((and (= 1 (remainder n 2))\n          (= 0 (digits\
    \ (quotient n 10)))) n)\n    ((and (= 1 (remainder n 2))\n          (not (= 0\
    \ (digits (quotient n 10))))) (* n (digits (quotient n 10))))\n    ((and (= 0\
    \ (remainder n 2))\n          (= 0 (digits (quotient n 10)))) 0)\n    ((and (=\
    \ 0 (remainder n 2))\n          (not (= 0 (digits (quotient n 10))))) (digits\
    \ (quotient n 10)))))\n", "  (if (not (positive? n))\n      0\n      (if (= n\
    \ 0)\n          1\n          (* (odd? (remainder n 10))\n             (digits\
    \ (quotient n 10))))))\n", "  (cond\n    [(zero? n) 0]\n    [(odd? (modulo n 10))\
    \ (* (modulo n 10) (digits (quotient n 10)))]\n    [else (digits (quotient n 10))]))",
  "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 10)) (* (remainder n 10) (digits\
    \ (quotient n 10)))]\n    [else (digits (quotient n 10))]))\n", "  (cond [(odd?\
    \ n) (* n (digits (- n 10)))]\n        [(= n 0) 0]\n        [else (digits (/ n\
    \ 10))]))", "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 10))\n     (*\
    \ (remainder n 10) (digits (quotient n 10)))]\n    [else (digits (quotient n 10))]))\n\
    ```\n\n```racket\n#lang racket\n", "  (if (= n 0)\n      0\n      (cond\n    \
    \   ((odd? (remainder n 10)) (* (digits (quotient n 10)) (remainder n 10)))\n\
    \       (else (digits (quotient n 10))))))", "  (if (zero? n) 0\n      (if (odd?\
    \ (remainder n 10))\n          (* (remainder n 10) (digits (quotient n 10)))\n\
    \          (digits (quotient n 10)))))\n", "  (if (zero? n)\n      0\n      (if\
    \ (odd? (remainder n 10))\n          (* (remainder n 10) (digits (quotient n 10)))\n\
    \          (digits (quotient n 10)))))\n```\n\n### Run\n\n```racket\nracket odd-digits.rkt\n\
    ```\n\n### Test\n\n```racket\nraco test odd-digits.rkt\n```", "  (cond [(zero?\
    \ n) 0]\n        [(odd? n) (* n (digits (quotient n 10)))]\n        [else (digits\
    \ (quotient n 10))]))\n```\n\n**Answer 2**\n\n```racket\n#lang racket\n", "  (cond\n\
    \    [(and (empty? n) (= n 0)) 0]\n    [(odd? (first n)) * (digits (rest n))]\n\
    \    [else (digits (rest n))]))\n```", "  (cond\n    [(zero? n) 0]\n    [(odd?\
    \ (remainder n 10)) (* (remainder n 10) (digits (quotient n 10)))]\n    [else\
    \ (digits (quotient n 10))]))\n", "  (cond [(empty? n) 0]\n        [(odd? (first\
    \ n)) (* (first n) (digits (rest n)))]\n        [else (digits (rest n))]))", " \
    \ (if (zero? n)\n      0\n      (let* ([d (remainder n 10)]\n             [dodd?\
    \ (odd? d)]\n             [nrest (quotient n 10)])\n        (if (zero? nrest)\n\
    \            (if dodd? d 0)\n            (+ (if dodd? (* d (digits nrest)) 0)\n\
    \               (digits nrest))))))\n", "  (if (= n 0)\n      0\n      (let ([digit\
    \ (modulo n 10)])\n        (if (even? digit)\n            (digits (quotient n\
    \ 10))\n            (+ (* digit (digits (quotient n 10))) (if (odd? digit) digit\
    \ 0))))))", "  (if (zero? n)\n      0\n      (if (even? (remainder n 10))\n  \
    \        (digits (quotient n 10))\n          (* (remainder n 10) (digits (quotient\
    \ n 10))))))\n", "  (cond [(zero? n) 0]\n        [(odd? n) (odds (remainder n\
    \ 10) (divide n 10))]\n        [else (odds 0 (divide n 10))]))\n", "  (cond\n\
    \    [(= 0 n) 0]\n    [(odd? (remainder n 10)) (* (remainder n 10) (digits (quotient\
    \ n 10)))]\n    [else (digits (quotient n 10))]))\n", "  (if (= n 0)\n      0\n\
    \      (+ (* n (remainder n 10))\n         (if (odd? (remainder n 10)) 1 0)\n\
    \         (digits (quotient n 10)))))\n", "  (cond\n    [(zero? n) 0]\n    [(and\
    \ (odd? n) (not (zero? (quotient n 10)))) (* n (digits (quotient n 10)))]\n  \
    \  [(odd? n) n]\n    [else (digits (quotient n 10))]))\n", "  (cond\n    [(zero?\
    \ n) 0]\n    [(odd? (modulo n 10)) (* (modulo n 10) (digits (quotient n 10)))]\n\
    \    [else (digits (quotient n 10))]))\n", "  (define (iter n result)\n    (cond\
    \ [(equal? n 0) result]\n          [(odd? (remainder n 10)) (iter (quotient n\
    \ 10) (* result (remainder n 10)))]\n          [else (iter (quotient n 10) result)]))\n\
    \  (iter n 1))\n", "  (cond ((= n 0) 0)\n        ((odd? (remainder n 10)) (* (digits\
    \ (quotient n 10)) (remainder n 10)))\n        (else (digits (quotient n 10)))))\n",
  "  (if (= n 0)\n      0\n      (let* ([d (modulo n 10)]\n             [v (if (odd?\
    \ d) d 0)])\n        (+ (* v (digits (quotient n 10)))\n           (if (even?\
    \ d) 0 v)))))\n", "  (cond ((= n 0) 0)\n        ((= (remainder n 2) 1)\n     \
    \    (* (remainder n 10) (digits (quotient n 10))))\n        (else (digits (quotient\
    \ n 10)))))\n", "  (if (zero? n)\n      0\n      (if (odd? (remainder n 10))\n\
    \          (* (digits (quotient n 10)) (remainder n 10))\n          (digits (quotient\
    \ n 10)))))\n", "  (cond\n    [(or (eq? n 0) (eq? n 1)) n]\n    [(odd? n) (* (digits\
    \ (quotient n 10)) (remainder n 10))]\n    [else (digits (quotient n 10))]))\n",
  "  (local [(define (odd? x)\n            (and (not (zero? x))\n                \
    \ (zero? (remainder x 2))))]\n    (cond\n      [(zero? n) 0]\n      [(odd? n)\
    \ (* n (digits (quotient n 10)))]\n      [else (digits (quotient n 10))])))\n",
  "  (cond ((= n 0) 0)\n        ((even? (remainder n 10))\n         (digits (quotient\
    \ n 10)))\n        (else\n         (* (remainder n 10)\n            (digits (quotient\
    \ n 10))))))\n", "  (if (zero? n) 0\n      (if (odd? (remainder n 10))\n     \
    \     (* (remainder n 10) (digits (quotient n 10)))\n          (digits (quotient\
    \ n 10)))))\n", "  (if (= n 0)\n      0\n      (if (odd? (remainder n 10))\n \
    \         (* (remainder n 10) (digits (quotient n 10)))\n          (digits (quotient\
    \ n 10)))))\n", "  (if (zero? n)\n      0\n      (if (odd? (remainder n 10))\n\
    \          (* (remainder n 10) (digits (quotient n 10)))\n          (digits (quotient\
    \ n 10)))))\n", "  (cond\n    [(= n 0) 0]\n    [(odd? (remainder n 10)) (* (digits\
    \ (quotient n 10)) (remainder n 10))]\n    [else (digits (quotient n 10))]))\n",
  "  (if (= n 0) 0\n      (let ([last-digit (modulo n 10)])\n\t  (if (odd? last-digit)\n\
    \t      (* last-digit (digits (quotient n 10)))\n\t      (digits (quotient n 10))))))\n",
  "  (cond [(= n 0) 0]\n        [(odd? (remainder n 10))\n         (* (remainder n\
    \ 10) (digits (quotient n 10)))]\n        [else (digits (quotient n 10))]))\n",
  "  (cond [(even? n) 0]\n        [else (if (even? (remainder n 10)) (digits (quotient\
    \ n 10))\n                 (* (remainder n 10) (digits (quotient n 10))))]))\n",
  "  (let loop ((x n) (a 1))\n    (cond ((zero? x) a)\n          ((odd? x) (loop (quotient\
    \ x 10) (* a (remainder x 10))))\n          (else (loop (quotient x 10) a)))))\n\
    </code>\n", "  (if (zero? n)\n      0\n      (if (odd? (remainder n 10))\n   \
    \       (* (remainder n 10) (digits (quotient n 10)))\n          (digits (quotient\
    \ n 10)))))\n", "  (if (odd? n)\n      (* n (digits (quotient n 10)))\n      (if\
    \ (= n 0) 1 (digits (quotient n 10)))))\n", "  (if (&lt; n 10)\n      (if (odd?\
    \ n) n 0)\n      (let* ([digit (modulo n 10)]\n             [product (digits (quotient\
    \ n 10))])\n        (if (odd? digit)\n            (* digit product)\n        \
    \    product))))\n</code>\nIt's worth noting that the number of digits of a number\
    \ is bounded by the number's base logarithm, so this code runs in logarithmic\
    \ time, which is much more efficient than the linear time that your code runs\
    \ in.\n", "  (if (odd? n) n 0))\n", "  (if (zero? n)\n      0\n      (if (odd?\
    \ (remainder n 10))\n          (* (digits (quotient n 10)) (remainder n 10))\n\
    \          (digits (quotient n 10)))))\n", "  (if (odd? n)\n      n\n      0))\n",
  "  (cond\n    [(equal? (modulo n 10) 0) 0]\n    [(and (equal? (modulo n 10) 0) (not\
    \ (zero? n))) 0]\n    [(zero? n) 0]\n    [else (+ (* (modulo n 10) (digits (quotient\
    \ n 10)))\n             (if (odd? (modulo n 10))\n                 (* (digits\
    \ (quotient n 10)) (modulo n 10))\n                 0))]))", "  (if (= n 0) 0\n\
    \      (let ([remaining (quotient n 10)]\n            [digit (remainder n 10)])\n\
    \        (if (odd? digit) (* digit (digits remaining))\n            (digits remaining)))))\n",
  "  (if (even? n)\n      0\n      (foldl (lambda (base current)\n               (if\
    \ (even? current)\n                   base\n                   (* base current)))\n\
    \             1\n             (digits-of n))))\n", "  (if (= n 0)\n      0\n \
    \     (if (odd? (remainder n 10))\n          (* (remainder n 10) (digits (quotient\
    \ n 10)))\n          (digits (quotient n 10)))))", "  (define (digits-h n acc)\n\
    \    (cond\n      [(= n 0) acc]\n      [(odd? (remainder n 10)) (digits-h (quotient\
    \ n 10) (* (remainder n 10) acc))]\n      [else (digits-h (quotient n 10) acc)]))\n\
    \  (if (odd? n)\n      (digits-h n 1)\n      (digits-h n 0)))", "  (if (zero?\
    \ n)\n      0\n      (if (odd? (remainder n 10))\n          (* (remainder n 10)\
    \ (digits (quotient n 10)))\n          (digits (quotient n 10)))))\n", "  (cond\
    \ ((zero? n) 0)\n        ((odd? n) (* n (digits (quotient n 10))))\n        (else\
    \ (digits (quotient n 10)))))\n", "  (let loop ((n n) (sum 1))\n    (if (= n 0)\n\
    \        sum\n        (let ((digit (modulo n 10)))\n          (if (odd? digit)\n\
    \              (loop (quotient n 10) (* sum digit))\n              (loop (quotient\
    \ n 10) sum))))))", "  (if (zero? n)\n      0\n      (if (odd? (remainder n 10))\n\
    \          (* (digits (quotient n 10)) (remainder n 10))\n          (digits (quotient\
    \ n 10)))))", "  (cond\n    [(empty? n) 0]\n    [(odd? (first n)) (* (first n)\
    \ (digits (rest n)))]\n    [else (digits (rest n))]))\n", "  (if (zero? n)\n \
    \     0\n      (let ([remainder (modulo n 10)])\n        (if (odd? remainder)\n\
    \            (* remainder (digits (quotient n 10)))\n            (digits (quotient\
    \ n 10))))))", "  (if (equal? (remainder n 10) 0)\n      0\n      (* (remainder\
    \ n 10) (digits (quotient n 10)))))", "  (if (equal? n 0)\n      0\n      (if\
    \ (odd? (remainder n 10))\n          (* (digits (quotient n 10)) (remainder n\
    \ 10))\n          (digits (quotient n 10)))))", "  (define (iter product n)\n\
    \    (cond ((= n 0) product)\n          ((odd? (remainder n 10)) (iter (* product\
    \ (remainder n 10)) (quotient n 10)))\n          (else (iter product (quotient\
    \ n 10)))))\n  (iter 1 n))\n", "  (if (zero? n) 0\n      (let ((q (quotient n\
    \ 10))\n            (r (remainder n 10)))\n        (if (odd? r)\n            (*\
    \ r (digits q))\n            (digits q)))))", "  (cond ((zero? n) 0)\n       \
    \ ((even? (remainder n 10)) (digits (quotient n 10)))\n        (else (* (remainder\
    \ n 10) (digits (quotient n 10))))))\n", "  (define (loop acc n)\n    (cond\n\
    \      [(< n 1) acc]\n      [(= (remainder n 2) 1) (loop (* acc (remainder n 10))\
    \ (quotient n 10))]\n      [else (loop acc (quotient n 10))]))\n  (loop 1 n))\n\
    ```\n\n```racket\n#lang racket\n", "  (if (odd? n)\n      (if (zero? (quotient\
    \ n 10))\n          1\n          (* n (digits (quotient n 10))))\n      (digits\
    \ (quotient n 10))))\n```\n\n## 54.\n```racket\n#lang racket\n", "  (if (zero?\
    \ n)\n      0\n      (if (odd? (remainder n 10))\n          (* (remainder n 10)\
    \ (digits (quotient n 10)))\n          (digits (quotient n 10)))))\n", "  (if\
    \ (&lt; n 10)\n      (if (odd? n) n 0)\n      (+ (* (modulo n 10) (digits (quotient\
    \ n 10))) (if (odd? n) n 0))))\n", "  (cond ((= n 0) 0)\n        ((odd? (remainder\
    \ n 10)) (* (digits (quotient n 10)) (remainder n 10)))\n        (else (digits\
    \ (quotient n 10)))))\n", "  (if (= n 0)\n      0\n      (let ((q (/ n 10))\n\
    \            (r (modulo n 10)))\n        (if (even? r)\n            (digits q)\n\
    \            (+ (* r (digits q)) (digits q))))))\n```\n\nThis was my solution:\n\
    \n```racket\n#lang racket\n", "  (cond\n    ((= 0 n) 0)\n    ((odd? (remainder\
    \ n 10)) (* (digits (quotient n 10)) (remainder n 10)))\n    (else (digits (quotient\
    \ n 10)))))\n", "  (cond ((= n 0) 0)\n        ((odd? (remainder n 10)) (* (digits\
    \ (quotient n 10)) (remainder n 10)))\n        (else (digits (quotient n 10)))))",
  "  (if (= n 0)\n      0\n      (let ((d (remainder n 10)))\n        (if (odd? d)\n\
    \            (* d (digits (quotient n 10)))\n            (digits (quotient n 10))))))\n",
  "  (cond\n    [(= n 0) 0]\n    [(even? (remainder n 10)) (digits (quotient n 10))]\n\
    \    [else\n     (+ (* (remainder n 10) (digits (quotient n 10)))\n        (remainder\
    \ n 10))]))\n", "  (cond\n    [(odd? n) n]\n    [(= n 0) 1]\n    [else (* (digits\
    \ (quotient n 10)) (digits (remainder n 10)))]))\n", "  (if (zero? n)\n      0\n\
    \      (if (odd? (remainder n 10))\n          (* (remainder n 10) (digits (quotient\
    \ n 10)))\n          (digits (quotient n 10)))))\n", "  (if (zero? n)\n      0\n\
    \      (+ (* (remainder n 10) (odd? (remainder n 10)))\n         (digits (quotient\
    \ n 10)))))\n```\n\n**Exercise 17**\n\n```racket\n#lang racket\n", "  (if (or\
    \ (zero? n) (even? n))\n      0\n      (* n (digits (quotient n 10)))))\n", " \
    \ (cond [(= 0 n) 0]\n        [(odd? (remainder n 10)) (* (remainder n 10) (digits\
    \ (quotient n 10)))]\n        [else (digits (quotient n 10))]))\n", "  (if (zero?\
    \ n)\n      0\n      (let ([d (remainder n 10)])\n        (if (even? d)\n    \
    \        (digits (quotient n 10))\n            (* d (digits (quotient n 10)))))))\n",
  "  (if (zero? n)\n      0\n      (if (odd? (remainder n 10))\n          (* (digits\
    \ (quotient n 10)) (remainder n 10))\n          (digits (quotient n 10)))))",
  "  (if (= 0 n)\n      0\n      (let ([d (modulo n 10)])\n        (if (odd? d)\n\
    \            (* d (digits (quotient n 10)))\n            (digits (quotient n 10))))))\n",
  "  (if (zero? n)\n      0\n      (if (even? (remainder n 10))\n          (digits\
    \ (quotient n 10))\n          (* (remainder n 10) (digits (quotient n 10))))))\n",
  "  (cond [(empty? n)\n         0]\n        [(odd? (first n))\n         (* (first\
    \ n) (digits (rest n)))]\n        [else\n         (digits (rest n))]))\n", " \
    \ (if (zero? n)\n      0\n      (let ([d (remainder n 10)])\n        (if (even?\
    \ d)\n            (digits (quotient n 10))\n            (* d (digits (quotient\
    \ n 10)))))))\n", "  (cond [(zero? n) 0]\n        [(odd? n) (* n (digits (quotient\
    \ n 10)))]\n        [else (digits (quotient n 10))]))\n", "  (cond\n    [(zero?\
    \ n) 0]\n    [(odd? (remainder n 10))\n     (* (remainder n 10) (digits (quotient\
    \ n 10)))]\n    [else (digits (quotient n 10))]))\n", "  (if (= n 0)\n      0\n\
    \      (if (odd? (remainder n 10))\n          (* (digits (quotient n 10)) (remainder\
    \ n 10))\n          (digits (quotient n 10)))))\n", "  (cond ((not (pair? n))\
    \ (if (odd? n) n 0))\n        ((odd? (car n)) (* (car n) (digits (cdr n))))\n\
    \        (else (digits (cdr n)))))\n", "  (if (zero? n)\n      0\n      (let ([d\
    \ (remainder n 10)])\n        (if (even? d)\n            (digits (quotient n 10))\n\
    \            (* d (digits (quotient n 10)))))))\n```\n\n```racket\n#lang racket\n",
  "  (if (empty? n)\n      0\n      (if (odd? (first n))\n          (* (first n) (digits\
    \ (rest n)))\n          (digits (rest n)))))\n```\n\n```racket\n#lang racket\n",
  "  (digits-helper n 1))\n", "  (cond [(not (number? n)) \"Not a number\"]\n    \
    \    [(not (positive? n)) \"Not a positive number\"]\n        [(zero? n) 0]\n\
    \        [else (foldl * 1 (filter odd? (string->list (number->string n))))]))",
  "  (cond ((= n 0) 0)\n        ((odd? (remainder n 10))\n         (* (remainder n\
    \ 10) (digits (quotient n 10))))\n        (else (digits (quotient n 10)))))\n\
    ```\n\n## [Sum consecutive numbers](https://github.com/mvaldetaro/exercism-racket/blob/master/racket/series/series.rkt)\n\
    \n```racket\n#lang racket\n", "  (if (= n 0)\n      0\n      (let* ([d (modulo\
    \ n 10)]\n             [rest (quotient n 10)])\n        (if (odd? d)\n       \
    \     (* d (digits rest))\n            (digits rest)))))\n", "  (if (zero? n)\n\
    \      0\n      (if (odd? (remainder n 10))\n          (* (remainder n 10) (digits\
    \ (quotient n 10)))\n          (digits (quotient n 10)))))\n", "  (cond\n    [(zero?\
    \ n) 0]\n    [(odd? (modulo n 10)) (* (modulo n 10) (digits (quotient n 10)))]\n\
    \    [else (digits (quotient n 10))]))\n", "  (cond ((< n 10) (if (odd? n) n 0))\n\
    \        ((odd? (remainder n 10)) (* (digits (quotient n 10)) (remainder n 10)))\n\
    \        (else (digits (quotient n 10)))))\n", "  (if (zero? n)\n      0\n   \
    \   (if (odd? (remainder n 10))\n          (* (remainder n 10) (digits (quotient\
    \ n 10)))\n          (digits (quotient n 10)))))\n", "  (if (zero? n)\n      0\n\
    \      (let* ([d (remainder n 10)]\n             [result (if (odd? d)\n      \
    \                   (* d (digits (quotient n 10)))\n                         (digits\
    \ (quotient n 10)))])\n        result)))\n</code>\nbut it seems like a very strange\
    \ way to do it.\nThis is the solution I was thinking of, but it seems much more\
    \ complicated (I think because of the use of the list to hold the digits):\n<code>#lang\
    \ racket\n", "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 10)) (* (remainder\
    \ n 10) (digits (quotient n 10)))]\n    [else (digits (quotient n 10))]))\n",
  "  (if (zero? n)\n      0\n      (let* ([right (remainder n 10)]\n             [rest\
    \ (quotient n 10)])\n        (if (odd? right)\n            (if (zero? rest)\n\
    \                right\n                (* right (digits rest)))\n           \
    \ (digits rest)))))\n", "  (cond ((= n 0) 0)\n        ((odd? (remainder n 10))\
    \ (* (digits (quotient n 10)) (remainder n 10)))\n        (else (digits (quotient\
    \ n 10)))))\n", "  (cond [(even? n)\n         0]\n        [else\n         (+ n\n\
    \            (digits (quotient n 10)))]))\n", "  (define (iter n acc)\n    (cond\
    \ [(> n 10) (iter (quotient n 10) (+ acc (remainder n 10)))]\n          [(= n\
    \ 10) acc]\n          [else (if (odd? n) n acc)]))\n  (iter n 0))\n", "  (cond\
    \ [(zero? n) 0]\n        [(even? n) (digits (quotient n 10))]\n        [else (*\
    \ (remainder n 10) (digits (quotient n 10)))]))\n", "  (define (helper n acc)\n\
    \    (cond\n      [(= n 0) acc]\n      [(odd? (remainder n 10)) (helper (quotient\
    \ n 10) (* (remainder n 10) acc))]\n      [else (helper (quotient n 10) acc)]))\n\
    \  (helper n 1))\n```\n\n## Problem 4:\n\n```racket\n#lang racket\n", "  (if (=\
    \ n 0)\n      0\n      (if (odd? (remainder n 10))\n          (* (remainder n\
    \ 10) (digits (quotient n 10)))\n          (digits (quotient n 10)))))\n", " \
    \ (if (and (positive? n)\n           (odd? n))\n      (* n (digits (quotient n\
    \ 10)))\n      (if (not (positive? n))\n          0\n          (digits (quotient\
    \ n 10)))))\n", "  (if (equal? n 0)\n      0\n      (let* ([curr (remainder n\
    \ 10)]\n             [next (/ n 10)])\n        (if (or (zero? curr) (even? curr))\n\
    \            (digits next)\n            (* curr (digits next))))))\n", "  (cond\n\
    \    [(= n 0) 0]\n    [(= (remainder n 2) 1) (* (quotient n 10) (remainder n 10))]\n\
    \    [else (quotient n 10)]))\n", "  (cond [(zero? n) 0]\n        [(even? n) (digits\
    \ (quotient n 10))]\n        [else (* n (digits (quotient n 10)))]))\n", "  (define\
    \ (digs a b)\n    (cond ((zero? a) b)\n          ((odd? (remainder a 10))\n  \
    \         (digs (quotient a 10) (* b (remainder a 10))))\n          (else (digs\
    \ (quotient a 10) b))))\n  (digs n 1))\n", "  (if (zero? n)\n      0\n      (if\
    \ (odd? (remainder n 10))\n          (* (remainder n 10) (digits (quotient n 10)))\n\
    \          (digits (quotient n 10)))))\n", "  (if (zero? n)\n      0\n      (let*\
    \ ([first-digit (modulo n 10)]\n             [rest-of-digits (digits (quotient\
    \ n 10))])\n        (if (even? first-digit)\n            rest-of-digits\n    \
    \        (* first-digit rest-of-digits)))))\n", "  (cond\n    [(zero? n) 0]\n\
    \    [(odd? n) (* (remainder n 10) (digits (quotient n 10)))]\n    [else (digits\
    \ (quotient n 10))]))\n", "  (cond [(= 0 n) 0]\n        [(odd? (remainder n 10))\
    \ (+ (* (remainder n 10) (digits (quotient n 10))) (digits (quotient n 10)))]\n\
    \        [else (digits (quotient n 10))]))\n", "  (if (= n 0)\n      0\n     \
    \ (let* ([i (remainder n 10)]\n             [o (odd? i)])\n        (if o\n   \
    \         (* i (digits (quotient n 10)))\n            (digits (quotient n 10))))))",
  "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 10)) (* (remainder n 10) (digits\
    \ (quotient n 10)))]\n    [else (digits (quotient n 10))]))\n", "  (if (even?\
    \ n)\n      0\n      (* n (digits (quotient n 10)))))", "  (cond\n    [(zero?\
    \ n) 0]\n    [(odd? (remainder n 10))\n     (* (remainder n 10) (digits (quotient\
    \ n 10)))]\n    [else (digits (quotient n 10))]))\n", "  (define (loop n ret)\n\
    \    (cond [(empty? n) ret]\n          [(odd? (first n)) (loop (rest n) (* ret\
    \ (first n)))]\n          [else (loop (rest n) ret)]))\n  (loop (list->string\
    \ n) 1))\n", "  (local [(define (s-digit n)\n            (cond\n             \
    \ [(= n 0) 0]\n              [(odd? n) (* n (s-digit (/ n 10)))]\n           \
    \   [else (s-digit (/ n 10))]))]\n    (s-digit n)))\n```\n\n```scheme\n#lang racket\n",
  "  (foldl (\u03BB (odd-digits digit) (if (odd? digit) (* odd-digits digit) odd-digits))\
    \ 1 (string->list (number->string n))))\n", "  (cond ((= n 0) 0)\n        ((odd?\
    \ (remainder n 10)) (* (digits (quotient n 10)) (remainder n 10)))\n        (else\
    \ (digits (quotient n 10)))))\n", "  (local ((define (rec n acc)\n           \
    \ (cond\n              [(zero? n) 0]\n              [(odd? n) (rec (quotient n\
    \ 10) (+ (remainder n 10) acc))]\n              [else (rec (quotient n 10) acc)])))\n\
    \    (rec n 0)))\n```\n\n```scheme", "  (cond ((= n 0) 0)\n        ((odd? (remainder\
    \ n 10))\n         (* (remainder n 10) (digits (quotient n 10))))\n        (else\
    \ (digits (quotient n 10)))))", "  (define (iter n prod)\n    (cond\n      [(even?\
    \ n) (iter (quotient n 10) prod)]\n      [(= n 0) prod]\n      [else (iter (quotient\
    \ n 10) (* prod n))]))\n  (iter n 1))\n", "  (if (zero? n)\n      0\n      (+\
    \ (* (remainder n 10) (digits (quotient n 10)))\n         (if (odd? (remainder\
    \ n 10))\n             (* (remainder n 10) (digits (quotient n 10)))\n       \
    \      0))))\n```\n\n```Racket\n#lang racket\n", "  (define (prod-odds ds)\n \
    \   (cond [(null? ds) 1]\n          [(even? (car ds)) (prod-odds (cdr ds))]\n\
    \          [else (* (car ds) (prod-odds (cdr ds)))]))\n  (prod-odds (string->list\
    \ (number->string n))))\n", "  (define (helper result n)\n    (cond [(= n 0) result]\n\
    \          [(odd? (remainder n 10)) (helper (* result (remainder n 10)) (/ n 10))]\n\
    \          [else (helper result (/ n 10))]))\n  (helper 1 n))", "  (if (zero?\
    \ n)\n      0\n      (if (odd? (remainder n 10))\n          (* (digits (quotient\
    \ n 10)) (remainder n 10))\n          (digits (quotient n 10)))))\n", "  (if (zero?\
    \ n) 0 (if (odd? n) n 0)))\n", "  (if (= n 0) 0\n      (let ((last-digit (modulo\
    \ n 10))\n            (other-digits (digits (quotient n 10))))\n        (if (odd?\
    \ last-digit)\n            (* last-digit other-digits)\n            other-digits))))",
  "  (local ((define (iter n acc)\n            (cond [(= n 0) acc]\n             \
    \     [(odd? (remainder n 10)) (iter (quotient n 10) (* (remainder n 10) acc))]\n\
    \                  [else (iter (quotient n 10) acc)])))\n    (iter n 1)))\n",
  "  (cond\n    [(empty? n) 0]\n    [(odd? (first n))\n     (* (first n) (digits (rest\
    \ n)))]\n    [else (digits (rest n))]))\n", "  (if (and (zero? (remainder n 10))\n\
    \           (zero? (remainder n 100)))\n      0\n      (if (zero? (remainder n\
    \ 2))\n          (digits (quotient n 10))\n          (* (remainder n 10)\n   \
    \          (digits (quotient n 10))))))\n", "  (cond ((= n 0) 0)\n        ((=\
    \ n 1) 1)\n        ((odd? (remainder n 10)) (* (digits (quotient n 10)) (remainder\
    \ n 10)))\n        (else (digits (quotient n 10)))))\n", "  (if (not (positive?\
    \ n))\n      0\n      (cond ((not (remainder n 2)) (digits (quotient n 10)))\n\
    \            ((zero? n) 1)\n            (else (* (remainder n 10) (digits (quotient\
    \ n 10)))))))\n", "  (cond ((= n 0) 0)\n        ((= (remainder n 2) 1) (* (remainder\
    \ n 10) (digits (quotient n 10))))\n        (else (digits (quotient n 10)))))\n",
  "  (cond [(= n 0) 0]\n        [(odd? (remainder n 10)) (* (digits (quotient n 10))\
    \ (remainder n 10))]\n        [else (digits (quotient n 10))]))\n", "  (if (null?\
    \ n)\n      0\n      (let ((d (car n))\n            (r (digits (cdr n))))\n  \
    \      (if (odd? d)\n            (* d r)\n            r))))", "  (if (even? n)\n\
    \      0\n      (* n (digits (/ n 10)))))", "  (if (= n 0)\n      0\n      (if\
    \ (odd? (remainder n 10))\n          (* (remainder n 10) (digits (quotient n 10)))\n\
    \          (digits (quotient n 10)))))", "  (if (= n 0)\n      0\n      (let ([d\
    \ (modulo n 10)])\n        (if (odd? d)\n            (* d (digits (quotient n\
    \ 10)))\n            (digits (quotient n 10))))))\n", "  (cond\n    [(<= n 0)\
    \ 0]\n    [(odd? n) (* (remainder n 10) (digits (quotient n 10)))]\n    [else\
    \ (digits (quotient n 10))]))\n", "  (if (= n 0)\n      0\n      (let* ([d (modulo\
    \ n 10)]\n             [rest (quotient n 10)])\n        (if (odd? d)\n       \
    \     (if (= rest 0)\n                d\n                (* d (digits rest)))\n\
    \            (digits rest)))))\n", "  (cond\n    [(= n 0) 0]\n    [(= (remainder\
    \ n 2) 1) (* (quotient n 10) (digits (remainder n 10)))]\n    [else (digits (quotient\
    \ n 10))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
