name: HumanEval_147_get_max_triples
language: rkt
prompt: "#lang racket\n\n;; You are given a positive integer n. You have to create\
  \ an integer list a of length n.\n;; For each i (1 \u2264 i \u2264 n), the value\
  \ of a[i] = i * i - i + 1.\n;; Return the number of triples (a[i], a[j], a[k]) of\
  \ a where i < j < k, \n;; and a[i] + a[j] + a[k] is a multiple of 3.\n;; Example\
  \ :\n;; >>> (get_max_triples 5)\n;; 1\n;; Explanation: \n;; a = [1, 3, 7, 13, 21]\n\
  ;; The only valid triple is (1, 7, 13).\n(define (get_max_triples n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_max_triples))\n\
  \    (check-equal? (candidate 5) 1)\n    (check-equal? (candidate 6) 4)\n    (check-equal?\
  \ (candidate 10) 36)\n    (check-equal? (candidate 100) 53361)\n))\n\n(test-humaneval)"
completions: ["  ;; your code here\n  )\n", "  (define (aux n step acc)\n    (if (=\
    \ n 0) acc\n        (let* ([x (+ step step -1)]\n               [y (+ x step)])\n\
    \          (aux (- n 1) (+ step 1)\n               (if (and (<= x y) (<= y (+\
    \ x step)))\n                   (+ acc 1)\n                   acc)))))\n  (aux\
    \ n 1 0))", "  (define (sum-of-threes a)\n    (for/fold ([count 0]) ([x (in-list\
    \ a)])\n      (if (and (> x 2)\n               (and (even? x)\n              \
    \      (zero? (modulo x 3))))\n          (add1 count)\n          count)))\n  (let\
    \ ([a (for/list ([x (in-range n)]) \n                     (+ (- (* x x) x) 1))])\n\
    \    (for/fold ([count 0]) ([x (in-range (- (length a) 2))])\n      (add (sum-of-threes\
    \ (for/list ([y (in-range (+ x 2))])\n                                       (list-ref\
    \ a y)))\n           count))))\n", "  (get-max-triples n 1 0))\n", "  (define\
    \ (expand lst)\n    (cond [(empty? lst) '()]\n          [else (cons (first lst)\
    \ (cons (+ (first lst) 1) (cons (+ (first lst) 2) (expand (rest lst)))))])\n \
    \   )\n  (define (add a b)\n    (cond [(empty? a) '()]\n          [else (cons\
    \ (+ (first a) (first b)) (add (rest a) (rest b)))]))\n  (define (combinations\
    \ a b)\n    (cond [(empty? a) '()]\n          [else (append (add (first a) b)\
    \ (combinations (rest a) b))]))\n  (define (triples lst)\n    (cond [(empty? lst)\
    \ '()]\n          [else (append (combinations (expand (first lst)) (first lst))\
    \ (triples (rest lst)))]))\n  (define (filtered lst)\n    (cond [(empty? lst)\
    \ '()]\n          [(= (modulo (first lst) 3) 0) (cons (first lst) (filtered (rest\
    \ lst)))]\n          [else (filtered (rest lst))]))\n  (length (filtered (triples\
    \ (for/list ([i (in-range 1 n)]) (cons i (cons (* i i) '())))))))\n```\n\n## How\
    \ to run the tests:\n1. Install [DrRacket](https://download.racket-lang.org/)\n\
    2. Open `test.rkt` file in DrRacket\n3. Run the test file", "  (for/sum ([i (in-range\
    \ 1 (- n 2))]\n            [j (in-range (+ i 1) (- n 1))]\n            [k (in-range\
    \ (+ j 1) n)])\n           (define-values (di dj dk) (map (cut modulo (+ i j k)\
    \ 3) (list i j k)))\n           (* (if (or (and (or (= di 1) (= di 2)) (= dj 1)\
    \ (= dk 1))\n                      (and (or (= di 1) (= di 2)) (= dj 2) (= dk\
    \ 2)))\n                    1\n                    0)\n              1)))", " \
    \ (define (helper k sum)\n    (cond\n      [(> k n) sum]\n      [(> (+ (* k k)\
    \ (* k) 1) (* (+ (* (sub1 k) (sub1 k)) (+ (sub1 k) (sub1 k))) 3)) (+ sum (helper\
    \ (add1 k) 0))]\n      [else (helper (add1 k) (+ sum (helper (add1 k) 0)))]))\n\
    \  (helper 2 (helper 1 0)))\n", "  (for/sum ([i (in-range 1 (- n 2))]\n      \
    \      [j (in-range (+ i 1) (- n 1))]\n            [k (in-range (+ j 1) n)])\n\
    \    (when (and (< i j) (< j k)\n               (zero? (+ (define ai (* i i (-\
    \ i 1)))\n                         (define aj (* j j (- j 1)))\n             \
    \            (define ak (* k k (- k 1)))\n                         (% (+ ai aj\
    \ ak) 3))))\n      1)))\n", "  (cond\n    [(= n 1) 0]\n    [(= n 2) 0]\n    [(=\
    \ n 3) 1]\n    [else\n     (letrec\n       [(gmt (lambda (n)\n               (cond\n\
    \                 [(= n 1) 1]\n                 [(= n 2) 3]\n                \
    \ [(= n 3) 6]\n                 [else\n                  (+ (gmt (- n 1))\n  \
    \                   (* (- (+ n 1) 1) (- (+ n 1) 2))\n                     (* (-\
    \ (+ n 1) 1) (- (+ n 1) 2) (- (+ n 1) 3)))])))])\n       (gmt n))]))\n", "  (let\
    \ ([a (build-list n (\u03BB (i) (+ (* i i) (- i 1))))])\n    (for/fold ([acc 0])\
    \ ([i (in-range (add1 n))]\n                          [j (in-range (add1 i) n)]\n\
    \                          [k (in-range (add1 j) n)])\n      (if (zero? (modulo\
    \ (+ (list-ref a i) (list-ref a j) (list-ref a k)) 3))\n          (add1 acc)\n\
    \          acc))))\n", "  (for/sum ((i (in-range 1 (- n 2)))\n            (j (in-range\
    \ (+ i 1) (- n 1)))\n            (k (in-range (+ j 1) n)))\n    (cond\n      [(and\
    \ (> i j) (> j k))\n       (cond\n         [(= (remainder (+ (get a i) (get a\
    \ j) (get a k)) 3) 0) 1]\n         [else 0])]\n      [else 0])))\n", "  (let ((a\
    \ (build-list n (lambda (n) (+ (* n n) n -1)))))\n    (for*/sum ([i (in-range\
    \ 1 (- n 2))]\n               [j (in-range (+ i 1) (- n 1))]\n               [k\
    \ (in-range (+ j 1) n)])\n      (if (zero? (modulo (+ (list-ref a i) (list-ref\
    \ a j) (list-ref a k)) 3))\n          1\n          0))))\n", "  (define (helper\
    \ result i)\n    (if (< i n)\n        (let ([v (+ (* i i) (- i) 1)])\n       \
    \   (helper (if (multiple-of-3? v) (+ result 1) result) (+ i 1)))\n        result))\n\
    \  (helper 0 1))\n", "  (define (gmi a n)\n    (cond ((= n 0) 1)\n          ((=\
    \ n 1) 2)\n          ((= n 2) 3)\n          (else (+ (gmi a (- n 1)) (* (- n 2)\
    \ (- n 1))))))\n  (gmi n n))", "  (let*\n    ((a (make-vector n 0))\n     (i 0)\n\
    \     (k (- n 3))\n     (count 0))\n    (if (< n 3)\n      0\n      (do ([i 1\
    \ (+ i 1)])\n          ((= i n))\n        (vector-set! a (- i 1) (- (* i i) i\
    \ 1)))\n      (for ([j (in-range 3 n)])\n        (if (and (= (modulo (+ (vector-ref\
    \ a (- j 2)) (vector-ref a (- j 1)) (vector-ref a (- j 3))) 3) 0)\n          \
    \       (<= (+ (vector-ref a (- j 2)) (vector-ref a (- j 1)) (vector-ref a (-\
    \ j 3))) (* 3 n)))\n          (set! count (+ count 1))))\n      count)))\n", " \
    \ (cond\n    [(= n 3) 1]\n    [(< n 3) 0]\n    [else (get_max_triples (- n 1))]))\n\
    ```\n\n* `try_except_finally`\n```racket\n#lang racket\n", "  (define (is_triple\
    \ lst)\n    (if (= (length lst) 3)\n        (if (= (apply + lst) 0)\n        \
    \    #t\n            #f)\n        #f))\n  (define (sublists lst)\n    (if (null?\
    \ lst)\n        (list (list))\n        (let ([fst (first lst)]\n             \
    \ [sub (sublists (rest lst))])\n          (append (map (lambda (x) (cons fst x))\
    \ sub) sub))))\n  (length (filter is_triple (sublists (for/list ([i (in-range\
    \ n)])\n                                       (* i (- i 1)))))))\n", "  (define\
    \ (is-multiple-of-3 x)\n    (= (remainder x 3) 0))\n  (define (summation lst)\n\
    \    (apply + lst))\n  (define (is-triple lst)\n    (is-multiple-of-3 (summation\
    \ lst)))\n  (define (get-triples lst)\n    (if (null? lst)\n        '()\n    \
    \    (append (get-triples (cdr lst))\n                (map (lambda (x) (cons (car\
    \ lst) x)) (cdr lst)))))\n  (define (filter-triples lst)\n    (filter is-triple\
    \ lst))\n  (length (filter-triples (get-triples (iota n)))))\n", "  (let ((a (make-vector\
    \ n 1)))\n    (for ([i (in-range (add1 n))])\n      (vector-set! a i (add1 (+\
    \ (* i i) (* (-1) i)))))\n    (list->vector a)))\n", "  (let ([a (for/list ([i\
    \ (in-range 1 (+ n 1))])\n             (* i i (- i 1)))])\n    (for/sum ([i (in-range\
    \ 0 (- n 2))]\n              [j (in-range (+ i 1) (- n 1))]\n              [k\
    \ (in-range (+ j 1) n)])\n      (if (and (= (modulo (+ (list-ref a i) (list-ref\
    \ a j) (list-ref a k)) 3) 0)\n               (< i j k))\n          1\n       \
    \   0))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
