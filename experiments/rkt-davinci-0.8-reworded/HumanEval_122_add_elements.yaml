name: HumanEval_122_add_elements
language: rkt
prompt: "#lang racket\n\n;; Given a non-empty list of integers arr and an integer\
  \ k, return\n;; the sum of the elements with at most two digits from the first k\
  \ elements of arr.\n;; Example:\n;; >>> (add_elements (list 111 21 3 4000 5 6 7\
  \ 8 9) 4)\n;; 24\n;; Constraints:\n;; 1. 1 <= len(arr) <= 100\n;; 2. 1 <= k <= len(arr)\n\
  (define (add_elements arr k)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add_elements))\n\
  \    (check-equal? (candidate (list 1 -2 -3 41 57 76 87 88 99) 3) -4)\n    (check-equal?\
  \ (candidate (list 111 121 3 4000 5 6) 2) 0)\n    (check-equal? (candidate (list\
  \ 11 21 3 90 5 6 7 8 9) 4) 125)\n    (check-equal? (candidate (list 111 21 3 4000\
  \ 5 6 7 8 9) 4) 24)\n    (check-equal? (candidate (list 1) 1) 1)\n))\n\n(test-humaneval)"
completions: ["  (let loop ([arr arr] [k k] [sum 0])\n    (cond\n      [(zero? k)\
    \ sum]\n      [(< (abs (car arr)) 100) (loop (cdr arr) (- k 1) (+ sum (car arr)))]\n\
    \      [else (loop (cdr arr) (- k 1) sum)])))", "  (let loop ([arr arr] [k k]\
    \ [sum 0])\n    (cond [(and (not (empty? arr)) (= k 0)) sum]\n          [(and\
    \ (not (empty? arr)) (= 1 (floor (log (car arr) 10))))\n           (loop (cdr\
    \ arr) (- k 1) (+ sum (car arr)))]\n          [(and (not (empty? arr)) (= 2 (floor\
    \ (log (car arr) 10))))\n           (loop (cdr arr) (- k 1) (+ sum (car arr)))]\n\
    \          [else (loop (cdr arr) (- k 1) sum)])))\n", "  (cond\n    [(= k 0) 0]\n\
    \    [(and (or (< (car arr) 10) (< (car arr) 100)) (< k (length arr)))\n     (+\
    \ (car arr) (add_elements (cdr arr) (- k 1)))]\n    [else (add_elements (cdr arr)\
    \ (- k 1))]))\n", "  (cond\n    [(zero? k) 0]\n    [(< (length (list->string (list-ref\
    \ arr 0))) 3)\n     (+ (list-ref arr 0) (add_elements (rest arr) (- k 1)))]\n\
    \    [else (add_elements (rest arr) (- k 1))]))\n```\n\n[Test Program](https://wandbox.org/permlink/7VQONyTjq9mQTcPa)",
  "  (cond\n    [(zero? k) 0]\n    [(< 10 (car arr)) (+ (car arr) (add_elements (cdr\
    \ arr) (- k 1)))]\n    [(< 100 (car arr)) (+ (car arr) (add_elements (cdr arr)\
    \ (- k 1)))]\n    [else (add_elements (cdr arr) (- k 1))]))\n", "  (apply +\n\
    \    (filter (lambda (x)\n\t       (or (<= 10 x) (<= 100 x)))\n      (take k arr))))\n",
  "  (foldl + 0\n         (map (\u03BB (n) (if (> n 99) 100 n))\n              (take\
    \ arr k))))\n", "  (define (is_two_digits n)\n    (< 10 n 100))\n  (apply + (filter\
    \ is_two_digits (take arr k))))\n", "  (cond ((= 1 k) (add-list (list-head k arr)))\n\
    \        ((&lt; 1 k) (add (add-list (list-head k arr))\n                     \
    \ (add_elements (list-tail k arr) (- k 1))))))\n", "  (cond\n    [(= k 0) 0]\n\
    \    [(&lt;= (quotient (car arr) 100) 1)\n     (+ (car arr) (add_elements (cdr\
    \ arr) (- k 1)))]\n    [else (add_elements (cdr arr) (- k 1))]))\n", "  (define\
    \ (add-rec lst sum)\n    (cond ((= k 0) sum)\n          ((> (string-length (number->string\
    \ (car lst))) 2) (add-rec (cdr lst) sum))\n          (else (add-rec (cdr lst)\
    \ (+ sum (car lst))))))\n  (add-rec arr 0))\n", "  (cond\n    [(null? arr) 0]\n\
    \    [(not (integer? (car arr))) (add_elements (cdr arr) k)]\n    [(>= k 0) (+\
    \ (car arr) (add_elements (cdr arr) (- k 1)))]\n    [else 0]))\n```\n\n```scheme\n\
    #lang racket\n", "  (if (null? arr)\n      0\n      (if (&lt; (count-digits (car\
    \ arr)) 3)\n          (+ (car arr) (add_elements (cdr arr) (- k 1)))\n       \
    \   (add_elements (cdr arr) (- k 1)))))\n", "  (cond [(null? arr) 0]\n       \
    \ [(or (= 1 (modulo (car arr) 100)) (= 1 (modulo (car arr) 1000)))\n         (+\
    \ (car arr) (add_elements (cdr arr) (- k 1)))]\n        [else (add_elements (cdr\
    \ arr) (- k 1))]))\n", "  (cond [(empty? arr) 0]\n        [(and (= (length arr)\
    \ k)\n              (>= (length (number->string (first arr))) 3))\n         (add_elements\
    \ (rest arr) (- k 1))]\n        [else (+ (first arr) (add_elements (rest arr)\
    \ (- k 1)))]))\n```\n\n```scheme\n#lang racket\n", "  (cond\n    [(<= k 0) 0]\n\
    \    [(<= (modulo (car arr) 100) 9)\n     (+ (modulo (car arr) 100) (add_elements\
    \ (cdr arr) (- k 1)))]\n    [else\n     (+ (car arr) (add_elements (cdr arr) (-\
    \ k 1)))]))\n", "  (let loop ([arr arr] [k k] [sum 0])\n    (cond\n      [(empty?\
    \ arr) sum]\n      [(> k 0)\n       (let ([i (first arr)])\n         (if (<= i\
    \ 99)\n             (loop (rest arr) (- k 1) (+ sum i))\n             (loop (rest\
    \ arr) k sum)))])))\n", "  (apply + (map (compose (lambda (n) (if (&lt; n 100)\
    \ n 0)) number-&gt;string) (take arr k))))\n</code>\n", "  (cond [(zero? k) 0]\n\
    \        [(number-&gt;string (car arr) 2)\n         (+ (car arr) (add_elements\
    \ (cdr arr) (- k 1)))]\n        [else (add_elements (cdr arr) (- k 1))]))\n</code>\n",
  "  (cond [(= k 0) 0]\n        [(>= (length (number->string (car arr))) 3) (add_elements\
    \ (cdr arr) (- k 1))]\n        [else (+ (car arr) (add_elements (cdr arr) (- k\
    \ 1)))]))", "  (cond\n    [(and (= k 0) (empty? arr)) 0]\n    [(= k 0) 0]\n  \
    \  [(<= (length (number->string (first arr))) 2)\n     (+ (first arr) (add_elements\
    \ (rest arr) (- k 1)))]\n    [else (add_elements (rest arr) (- k 1))]))\n", " \
    \ (cond\n    [(empty? arr) 0]\n    [(and (<= 1 (length arr)) (<= (length arr)\
    \ 100))\n     (cond\n       [(<= 1 k) (cond\n                  [(<= k (length\
    \ arr))\n                   (define (helper l n)\n                     (cond\n\
    \                       [(= n 0) 0]\n                       [(< 10 (car l)) (car\
    \ l) + (helper (cdr l) (- n 1))]\n                       [(< 100 (car l)) (car\
    \ l) + (helper (cdr l) (- n 1))]\n                       [else (helper (cdr l)\
    \ (- n 1))]))\n                   (helper arr k)]\n                  [else (error\
    \ \"Invalid k\")])]\n       [else (error \"Invalid length for arr\")])]\n    [else\
    \ (error \"Invalid length for arr\")]))", '  (apply + (take (filter (lambda (x)
    (< 10 x 100)) arr) k)))', "  (define (two-digit? x)\n    (and (<= 10 x) (<= x\
    \ 99)))\n  (accumulate + 0 (take arr k) two-digit?))\n</code>\n", "  (sum\n  \
    \ (map\n    (lambda (x)\n      (cond\n        [(< 10 x) x]\n        [(< 100 x)\
    \ (remainder x 10)]\n        [else 0]))\n    (take k arr))))\n", "  (for/sum ([e\
    \ (in-list arr)])\n    (match e\n      [(? (lambda (x) (<= x 9))) e]\n      [(?\
    \ (lambda (x) (<= x 99))) e]\n      [_ 0])))\n```\n\n### \u0423\u0441\u043B\u043E\
    \u0432\u0438\u0435 \u0437\u0430\u0434\u0430\u0447\u0438:\n\n> For example, given\
    \ the array [-2, -1, 2, 1] and target = 1, the output should be\n> twoSum(inputArray,\
    \ target) = [2, 3].\n\n```scheme\n#lang racket\n", "  (cond [(null? arr) 0]\n\
    \        [(> (string-length (number->string (car arr))) 2) (add_elements (cdr\
    \ arr) k)]\n        [else (+ (car arr) (add_elements (cdr arr) k))]))\n", '  (apply
    + (take k (filter (lambda (x) (<= x 99)) arr))))', "  (define (loop lst k sum)\n\
    \    (cond\n      [(or (= k 0) (null? lst)) sum]\n      [(<= (length (number->string\
    \ (car lst))) 2)\n       (loop (cdr lst) (- k 1) (+ sum (car lst)))]\n      [else\
    \ (loop (cdr lst) (- k 1) sum)]))\n  (loop arr k 0))", "  (cond\n    [(= k 0)\
    \ 0]\n    [(= (string-length (number->string (list-ref arr (- k 1)))) 1)\n   \
    \  (+ (list-ref arr (- k 1)) (add_elements arr (- k 1)))]\n    [(= (string-length\
    \ (number->string (list-ref arr (- k 1)))) 2)\n     (+ (list-ref arr (- k 1))\
    \ (add_elements arr (- k 1)))]\n    [else (add_elements arr (- k 1))]))", "  (let\
    \ ([s (foldl + 0 arr)])\n    (if (&lt; (count-digits s) 3)\n        s\n      \
    \  (+ (add-digits s) (car arr)))))\n", "  (cond\n    [(empty? arr) 0]\n    [(<\
    \ (count-digits (first arr)) 3)\n     (+ (first arr) (add_elements (rest arr)\
    \ (- k 1)))]\n    [else (add_elements (rest arr) (- k 1))]))\n", "  (match arr\n\
    \    [(list x y)\n     (if (&lt; (number-&gt;string x) 3)\n         (+ x y)\n\
    \         y)]\n    [(list x y z ...)\n     (add_elements (list y z ...) k)]))\n\
    </code>\nThe problem is the <code>if</code> statement. I'm trying to check if\
    \ the first element is less than three digits. If it is, add it to the second\
    \ element and return it. If it isn't, don't add it to the second element and just\
    \ return the second element.\nI keep getting the following error:\n<code>application:\
    \ not a procedure;\n expected a procedure that can be applied to arguments\n \
    \ given: #&lt;syntax:exn:fail:contract&gt;\n  arguments...:\n   0: #&lt;syntax:exn:fail:contract&gt;\n\
    \   1: #f\n   2: #f\n   3: #f\n   4: #f\n   5: \"Procedure is not a procedure;\\\
    n expected a procedure that can be applied to arguments\\n  given: #&lt;syntax:exn:fail:contract&gt;\\\
    n  arguments...:\\n   0: #&lt;syntax:exn:fail:contract&gt;\\n   1: #f\\n   2:\
    \ #f\\n   3: #f\\n   4: #f\\n\"\n</code>\nI have no idea what this means. I thought\
    \ it was a syntax error but I don't see one. What am I doing wrong?\n\n\nA:\n\n\
    You'll find a few errors in your code, but one of them is the way you're writing\
    \ your <code>if</code> expression.\nYour code:\n<code>(if (&lt; (number-&gt;string\
    \ x) 3)\n    (+ x y)\n    y)\n</code>\nIt's easier to understand if you expand\
    \ it using parentheses:\n<code>(if (&lt; (number-&gt;string x) 3)\n    (+ x y)\n\
    \    y)\n</code>\nThe problem is that <code>if</code> is a special form that expects\
    \ 3 arguments, an expression that returns a boolean, another", "  (apply + (filter\
    \ (lambda (x) (<= x 99)) (take arr k))))\n", "  (if (or (empty? arr) (&lt;= k\
    \ 0))\n      0\n      (let ([n (car arr)])\n        (+ n (add_elements (cdr arr)\
    \ (- k 1))))))\n</code>\n", "  (cond [(empty? arr) 0]\n        [(< (length (number->string\
    \ (first arr))) 3) (+ (first arr) (add_elements (rest arr) (- k 1)))]\n      \
    \  [else (add_elements (rest arr) (- k 1))]))", "  (define (add_elements-helper\
    \ arr k acc)\n    (cond\n      [(zero? k) acc]\n      [(and (&lt; k 100) (&gt;\
    \ k 9)) (+ acc (first arr))]\n      [else (add_elements-helper (rest arr) (- k\
    \ 1) (+ acc (first arr)))]))\n  (add_elements-helper arr k 0))\n", "  (define\
    \ (helper arr k acc)\n    (cond ((zero? k) acc)\n          ((<= 10 (car arr))\
    \ (+ acc (car arr)))\n          ((<= 100 (car arr)) (+ acc (car arr)))\n     \
    \     (else (helper (cdr arr) (- k 1) acc))))\n  (helper arr k 0))\n", "  (cond\n\
    \    [(= 1 k) (cond\n               [(< arr 10) arr]\n               [(< arr 100)\
    \ arr])]\n    [else (+ (cond\n               [(< (first arr) 10) (first arr)]\n\
    \               [(< (first arr) 100) (first arr)])\n             (add_elements\
    \ (rest arr) (- k 1)))]))", "  (list-ref arr k))\n", "  (let loop ([arr arr] [k\
    \ k] [sum 0])\n    (cond [(= k 0) sum]\n          [(< (log arr) 2) (+ sum (car\
    \ arr))]\n          [else (loop (cdr arr) (- k 1) (+ sum (car arr)))])))\n", " \
    \ (cond\n    [(null? arr) 0]\n    [(not (number? (car arr))) (add_elements (cdr\
    \ arr) k)]\n    [(and (<= k 0) (number? (car arr))) (add_elements (cdr arr) k)]\n\
    \    [(and (<= k 0) (not (number? (car arr)))) (add_elements (cdr arr) k)]\n \
    \   [(and (not (number? (car arr))) (> k 0)) (add_elements (cdr arr) k)]\n   \
    \ [(and (number? (car arr)) (> k 0)) (+ (car arr) (add_elements (cdr arr) (- k\
    \ 1)))]))\n", "  (if (null? arr)\n      0\n      (if (< (length (number->string\
    \ (car arr))) 3)\n          (+ (car arr) (add_elements (cdr arr) (- k 1)))\n \
    \         (add_elements (cdr arr) (- k 1)))))\n```\n\n`(add_elements (list 111\
    \ 21 3 4000 5 6 7 8 9) 4)`\n\n```racket\n24\n```\n\n---\n\n## Task\nGiven a non-empty\
    \ list of integers arr and an integer k, return the sum of the elements with at\
    \ most two digits from the first k elements of arr.\n\n### Example\n```racket\n\
    >>> (add_elements (list 111 21 3 4000 5 6 7 8 9) 4)\n24\n```\n\n### Constraints\n\
    - 1 <= len(arr) <= 100\n- 1 <= k <= len(arr)", "  (let loop ([cur 0] [arr arr])\n\
    \    (if (or (null? arr) (= cur k))\n        0\n        (if (&lt;= (length (number-&gt;string\
    \ (car arr))) 2)\n            (+ (car arr) (loop (+ cur 1) (cdr arr)))\n     \
    \       (loop (+ cur 1) (cdr arr))))))\n</code>\n", "  (define (loop arr k sum)\n\
    \    (cond [(= k 0) sum]\n          [(>= (number->string (car arr)) \"99\") (loop\
    \ (cdr arr) (- k 1) sum)]\n          [else (loop (cdr arr) (- k 1) (+ sum (car\
    \ arr)))]))\n  (loop arr k 0))\n```\n\n## [Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\
    \ (Medium)\n\n```racket\n#lang racket\n", "  (cond\n    [(= k 0) 0]\n    [(> (length\
    \ arr) 1)\n     (+ (car arr) (add_elements (cdr arr) (- k 1)))]\n    [else (car\
    \ arr)]))\n", "  (cond [(empty? arr) 0]\n        [(>= (length arr) k) (cons (add_two\
    \ (car arr)) (add_elements (cdr arr) k))]\n        [else (cons (add_two (car arr))\
    \ (add_elements (cdr arr) k))]))\n", "  (if (= 0 k)\n      0\n      (let ([el\
    \ (car arr)])\n        (+ (if (or (= 1 (length (number->string el)))\n       \
    \           (= 2 (length (number->string el))))\n             el\n           \
    \  0)\n           (add_elements (cdr arr) (- k 1))))))", "  (define (add-elements-aux\
    \ arr k acc)\n    (cond ((null? arr) acc)\n          ((= k 0) acc)\n         \
    \ ((and (&lt;= 1 (number-&gt;string (car arr)) 10)\n                (&lt;= 1 (number-&gt;string\
    \ (car arr)) 99))\n           (add-elements-aux (cdr arr) (- k 1) (+ acc (car\
    \ arr))))\n          (else (add-elements-aux (cdr arr) (- k 1) acc))))\n  (add-elements-aux\
    \ arr k 0))\n", "  (apply + (filter\n            (lambda (x)\n              (and\
    \ (positive? x)\n                   (or (= (length (number->string x)) 1)\n  \
    \                     (= (length (number->string x)) 2))))\n            (take\
    \ arr k))))\n", "  (define n (length arr))\n  (cond [(= k 0) 0]\n        [(< k\
    \ 0) (error \"add_elements: k < 0\")]\n        [(= k n) (+ (add_elements arr (-\
    \ k 1)) (car arr))]\n        [else (cond [(< (car arr) 100) (+ (add_elements arr\
    \ (- k 1)) (car arr))]\n                     [else (add_elements arr (- k 1))])]))",
  '  (apply + (map number->string (take arr k))))', "  (define (sum so-far (first\
    \ rest))\n    (cond [(empty? rest) so-far]\n          [(or (< first 10)\n    \
    \           (< first 100))\n           (sum (+ so-far first) (first rest))]\n\
    \          [else\n           (sum so-far (first rest))]))\n  (if (empty? arr)\n\
    \      '()\n      (sum 0 (first arr))))\n", "  (apply + (map \n            (lambda\
    \ (x) (cond ((<= x 10) x)\n                              ((<= x 100) x)\n    \
    \                          (else 0)))\n            (take arr k))))\n```", "  (apply\
    \ + (filter (\u03BB (x) (<= x 99)) (take arr k))))", "  (cond [(= k 0) 0]\n  \
    \      [(<= (digit-count (car arr)) 2) (+ (car arr) (add_elements (cdr arr) (-\
    \ k 1)))]\n        [else (add_elements (cdr arr) (- k 1))]))\n", "  (define (add_elements_iter\
    \ arr k sum)\n    (cond [(or (null? arr) (= k 0)) sum]\n          [(< (list-ref\
    \ arr 0) 100) (add_elements_iter (cdr arr) (- k 1) (+ sum (list-ref arr 0)))]\n\
    \          [else (add_elements_iter (cdr arr) (- k 1) sum)]))\n  (add_elements_iter\
    \ arr k 0))\n", "  (define (helper n lst)\n    (cond ((= n 0) lst)\n         \
    \ ((< (car lst) 10) (helper (- n 1) (cdr lst)))\n          ((< (car lst) 100)\
    \ (helper (- n 1) (cdr lst)))\n          (else (helper (- n 1) (cdr lst)))))\n\
    \  (apply + (helper k arr)))\n", "  (foldl + 0 (map number->string (take arr k))))\n",
  '  (foldl + 0 (filter (lambda (x) (< x 100)) (take arr k))))', "  (cond\n    [(<=\
    \ (length arr) k) (apply + arr)]\n    [(<= k 0) 0]\n    [else\n     (cond\n  \
    \     [(> (abs (car arr)) 99) (car arr)]\n       [else 0])\n     (add_elements\
    \ (cdr arr) (- k 1))]))\n", "  (cond\n    [(= 1 k) (car arr)]\n    [(= 2 k) (+\
    \ (car arr) (car (cdr arr)))]\n    [else (define a (car arr))\n           (define\
    \ b (car (cdr arr)))\n           (define c (car (cdr (cdr arr))))\n          \
    \ (cond\n             [(= 10 a) (+ b c)]\n             [(= 100 a) (+ b c)]\n \
    \            [else (+ a b c)])]))\n", "  (match arr\n    [() 0]\n    [(cons (and\
    \ (integer? f) (integer? s)) r) (+ (* f s) (add_elements r k))]))\n", "  (if (=\
    \ 0 k)\n      0\n      (if (< 10 (car arr))\n          (+ (car arr) (add_elements\
    \ (cdr arr) (- k 1)))\n          (add_elements (cdr arr) (- k 1)))))", "  (sum\
    \ (take arr k)))\n", "  (define (sum lst)\n    (cond ((null? lst) 0)\n       \
    \   ((&lt; (list-ref lst 0) 100) (+ (list-ref lst 0) (sum (cdr lst))))\n     \
    \     (else (sum (cdr lst)))))\n  (sum (take arr k)))\n", "  (cond ((null? arr)\
    \ 0)\n        ((> (length (number->string (car arr))) 2) (add_elements (cdr arr)\
    \ k))\n        ((= k 0) 0)\n        (else (+ (car arr) (add_elements (cdr arr)\
    \ (- k 1))))))\n```\n## Python Version\n```py\n#lang python\n\n# Given a non-empty\
    \ list of integers arr and an integer k, return\n# the sum of the elements with\
    \ at most two digits from the first k elements of arr.\n# Example:\n# >>> add_elements([111,\
    \ 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n# 24\n# Constraints:\n# 1. 1 <= len(arr) <=\
    \ 100\n# 2. 1 <= k <= len(arr)\ndef add_elements(arr, k):\n    if len(arr) ==\
    \ 0:\n        return 0\n    if len(str(arr[0])) > 2:\n        return add_elements(arr[1:],\
    \ k)\n    if k == 0:\n        return 0\n    return arr[0] + add_elements(arr[1:],\
    \ k - 1)\n```\n## Java Version\n```java\n// Given a non-empty list of integers\
    \ arr and an integer k, return\n// the sum of the elements with at most two digits\
    \ from the first k elements of arr.\n// Example:\n// >>> add_elements(new int[]{111,\
    \ 21, 3, 4000, 5, 6, 7, 8, 9}, 4)\n// 24\n// Constraints:\n// 1. 1 <= len(arr)\
    \ <= 100\n// 2. 1 <= k <= len(arr)\npublic class Solution {\n    public static\
    \ int add_elements(int[] arr, int k) {\n        if (arr.length == 0)\n       \
    \     return 0;\n        if (String.valueOf(arr[0]).length() > 2)\n          \
    \  return add_elements(Arrays.copyOfRange(arr, 1, arr.length), k);\n        if\
    \ (k == 0)\n            return 0;\n        return arr[0] + add_elements(Arrays.copyOfRange(arr,\
    \ 1", "  (cond\n    [(null? arr) 0]\n    [(null? (cdr arr))\n     (cond\n    \
    \   [(> (car arr) 99) 0]\n       [else (car arr)])]\n    [else\n     (cond\n \
    \      [(> (car arr) 99) (add_elements (cdr arr) k)]\n       [else (+ (car arr)\
    \ (add_elements (cdr arr) (- k 1)))])]))", "  (define result 0)\n  (for ([elem\
    \ arr]\n        [i (in-range k)])\n    (if (< (number->string elem) 3)\n     \
    \   (set! result (+ result elem))))\n  result)", "  (define (add_helper arr k\
    \ sum i)\n    (cond [(= i k) sum]\n          [(>= (length (number->string (car\
    \ arr))) 3) (add_helper (cdr arr) k sum (+ i 1))]\n          [else (add_helper\
    \ (cdr arr) k (+ sum (car arr)) (+ i 1))]))\n  (add_helper arr k 0 0))\n", " \
    \ (define (sum lst)\n    (if (empty? lst)\n        0\n        (+ (car lst) (sum\
    \ (cdr lst)))))\n  (let loop ((lst arr) (count k) (list '()))\n    (if (&lt; count\
    \ 0)\n        (sum list)\n        (if (&lt; (length (symbol-&gt;string (car lst)))\
    \ 3)\n            (loop (cdr lst) (- count 1) (cons (car lst) list))\n       \
    \     (loop (cdr lst) (- count 1) list)))))\n</code>\nAnd here is my Python code:\n\
    <code># Given a non-empty list of integers arr and an integer k, return\n# the\
    \ sum of the elements with at most two digits from the first k elements of arr.\n\
    # Example:\n# &gt;&gt;&gt; add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n\
    # 24\n# Constraints:\n# 1. 1 &lt;= len(arr) &lt;= 100\n# 2. 1 &lt;= k &lt;= len(arr)\n\
    \ndef add_elements(arr, k):\n    list = []\n    count = k\n    for item in arr:\n\
    \        if count &lt;= 0:\n            break\n        if len(str(item)) &lt;\
    \ 3:\n            list.append(item)\n            count -= 1\n        else:\n \
    \           count -= 1\n    return sum(list)\n</code>\nI am sure that there are\
    \ better ways to do it, but I was wondering if there are any more Pythonic ways.\n\
    \n\nA:\n\nYou can use <code>itertools.islice</code> in the Python 3 version:\n\
    <code>from itertools import islice\n\ndef add_elements(arr, k):\n    return sum(x\
    \ for x in islice(arr, k) if len(str(x)) &lt; 3)\n</code>\n", "  (apply + (keep\
    \ (lambda (x) (and (<= 1 (count x)) (<= (count x) 2))) (take arr k))))\n", " \
    \ (define (iter i acc lst)\n    (cond [(= i k) acc]\n          [(< 10 (abs (car\
    \ lst))) (iter (+ i 1) (+ acc (car lst)) (cdr lst))]\n          [else (iter (+\
    \ i 1) acc (cdr lst))]))\n  (iter 0 0 arr))", "  (apply + (filter (lambda (x)\
    \ (< x 100)) (take arr k))))\n", "  (apply + (filter (lambda (n) (&lt;= 10 n 99))\
    \ (take arr k))))\n", "  (define (is-two-digit x)\n    (>= x 10))\n  (define (sum\
    \ lst)\n    (cond\n      [(null? lst) 0]\n      [(is-two-digit (car lst)) (+ (car\
    \ lst) (sum (cdr lst)))]\n      [else (sum (cdr lst))]))\n  (if (is-two-digit\
    \ (car arr))\n      (sum (take arr k))\n      (sum (take (cdr arr) (- k 1)))))\n\
    ```\n\n```\n#lang racket\n", "  (apply + (map number->string (take arr k))))\n",
  "  (let/cc return\n    (define (helper arr k sum)\n      (if (zero? k)\n       \
    \   (return sum)\n          (if (and (not (zero? (remainder (car arr) 100)))\n\
    \                   (not (zero? (remainder (car arr) 10))))\n              (helper\
    \ (cdr arr) (- k 1) (+ sum (car arr)))\n              (helper (cdr arr) (- k 1)\
    \ sum))))\n    (helper arr k 0)))\n```\n\n```racket\n#lang racket\n", "  (define\
    \ (add_elements_helper arr k total)\n    (cond ((= k 0) total)\n          ((>\
    \ (length (number->string (car arr))) 2)\n           (add_elements_helper (cdr\
    \ arr) k total))\n          (else (add_elements_helper (cdr arr) (- k 1) (+ total\
    \ (car arr))))))\n  (add_elements_helper arr k 0))", "  (apply + (filter (lambda\
    \ (x) (or (<= x 9)\n                                   (<= x 99)))\n         \
    \          (take arr k))))\n```\n\n```\n#lang racket\n", "  (if (or (null? arr)\
    \ (zero? k))\n      0\n      (let* ([a (car arr)]\n             [k (sub1 k)])\n\
    \        (cond [(> a 99) (add_elements (cdr arr) k)]\n              [else (+ a\
    \ (add_elements (cdr arr) k))]))))\n", "  (cond ((empty? arr) 0)\n        ((=\
    \ 1 (length arr)) (apply + arr))\n        ((>= (length arr) k) (apply + (take\
    \ k arr)))\n        (else (apply + arr))))\n", "  (apply + (map (lambda (x) (if\
    \ (< x 100) x 0)) (take arr k))))\n", "  (foldl + 0 (map (lambda (x) (if (< 10\
    \ x 100) x 0)) (take arr k))))\n", "  (define arr (map (lambda (x) (cond [(>=\
    \ x 100) 100]\n                                     [(>= x 10) 10]\n         \
    \                            [else x]))\n                    arr))\n  (define\
    \ (add_elements_iter arr k acc)\n    (cond [(= k 0) acc]\n          [else (add_elements_iter\
    \ (cdr arr) (- k 1) (+ acc (car arr)))]))\n  (add_elements_iter arr k 0))\n",
  "  (define (loop arr k sum)\n    (cond [(empty? arr) sum]\n          [(< (count-digits\
    \ (first arr)) 3) (loop (rest arr) (- k 1) (+ sum (first arr)))]\n          [else\
    \ (loop (rest arr) (- k 1) sum)]))\n  (loop arr k 0))\n", "  (cond\n    [(zero?\
    \ k) 0]\n    [(> (length arr) 0)\n     (+ (if (<= (length (number->string (car\
    \ arr))) 2)\n            (car arr)\n            0)\n        (add_elements (cdr\
    \ arr) (- k 1)))]))", "  (cond\n    [(= k 0) 0]\n    [(and (&lt;= 10 (first arr))\
    \ (&lt;= (first arr) 99))\n     (+ (first arr) (add_elements (rest arr) (- k 1)))]\n\
    \    [else (add_elements (rest arr) (- k 1))]))\n</code>\nI expect this should\
    \ take 3 stack frames and therefore the worst case complexity should be O(3n).\n\
    If I run this in the racket REPL I get the following error after a short time.\n\
    <code>Welcome to DrRacket, version 6.9 [3m].\nLanguage: racket [custom]; memory\
    \ limit: 100 MB.\ncpu-time: user: 3.89 secs, system: 0.00 secs, real: 3.89 secs\n\
    cpu-usage: user: 1.51%, system: 0.04%, real: 1.51%\ngc-time: 0.00 secs\n</code>\n\
    I expected this to run in O(n) time. I am confused. Can someone explain what is\
    \ going on here? I've used the same approach in other languages and they have\
    \ all done what I expected. Is there some sort of implicit recursion in racket?\n\
    \n\nA:\n\nIt looks like you're using Racket's <code>first</code> and <code>rest</code>\
    \ procedures which are not constant time like the <code>car</code> and <code>cdr</code>\
    \ in Scheme, which I think is what you expect.\n", '  (accumulate + 0 (map (lambda
    (n) (if (< n 100) n 0)) (take arr k))))', "  (add_elements-internal arr 0 k))\n",
  "  (define (f lst n)\n    (cond\n      [(null? lst) n]\n      [(= (length (number->string\
    \ (car lst))) 2) (f (cdr lst) (+ n (car lst)))]\n      [(= (length (number->string\
    \ (car lst))) 1) (f (cdr lst) (+ n (car lst)))]\n      [else (f (cdr lst) n)]))\n\
    \  (f arr 0))\n", "  (define (add_elements-iter arr k sum)\n    (cond\n      [(=\
    \ k 0) sum]\n      [(< (length (number->string (car arr))) 3)\n       (add_elements-iter\
    \ (cdr arr) (- k 1) (+ sum (car arr)))]\n      [else (add_elements-iter (cdr arr)\
    \ (- k 1) sum)]))\n  (add_elements-iter arr k 0))\n", "  (if (or (empty? arr)\
    \ (= 0 k))\n      0\n      (if (&lt;= (apply + (map string-&gt;number (map (lambda\
    \ (x) (regexp-replace #rx\"\\\\D\" x \"\")) (list-&gt;string (car arr))))) 100)\n\
    \          (+ (apply + (map string-&gt;number (map (lambda (x) (regexp-replace\
    \ #rx\"\\\\D\" x \"\")) (list-&gt;string (car arr))))) (add_elements (cdr arr)\
    \ (- k 1)))\n          (add_elements (cdr arr) (- k 1)))))\n</code>\nThis function\
    \ seems to work for the test cases I threw at it.\n", "  (cond ((null? arr) 0)\n\
    \        ((> (length (number->string (car arr))) 2) (add_elements (cdr arr) k))\n\
    \        ((= 0 k) 0)\n        (else (+ (car arr) (add_elements (cdr arr) (- k\
    \ 1))))))\n", "  (sum (map\n        (lambda (x)\n          (if (and (<= 1 (number->string\
    \ x) 2))\n              x\n              0))\n        (take arr k))))", "  (cond\n\
    \    [(empty? arr) 0]\n    [(empty? (cdr arr)) (car arr)]\n    [(< (length (number->string\
    \ (car arr))) 3)\n     (+ (car arr) (add_elements (cdr arr) (- k 1)))]\n    [else\
    \ (add_elements (cdr arr) (- k 1))]))", "  (let ([sum 0])\n    (for ([i (in-range\
    \ 0 (sub1 k))])\n      (let ([v (vector-ref arr i)])\n        (when (or (< v 10)\
    \ (and (< v 100) (not (number? v))))\n          (set! sum (+ sum v)))))\n    sum))\n",
  "  (define (is-two-digit? x) (< x 100))\n  (define (add-elements-iter list count\
    \ sum)\n    (cond\n      [(= count k) sum]\n      [(is-two-digit? (car list))\
    \ (add-elements-iter (cdr list) (+ count 1) (+ sum (car list)))]\n      [else\
    \ (add-elements-iter (cdr list) (+ count 1) sum)]))\n  (add-elements-iter arr\
    \ 0 0))\n", "  (define (rem_two_digits x)\n    (cond\n      [(> x 99) x]\n   \
    \   [else (rem_two_digits (remainder x 100))]))\n  (define (add_elements_aux arr\
    \ k i sum)\n    (cond\n      [(= i k) sum]\n      [else (add_elements_aux arr\
    \ k (+ i 1) (+ sum (rem_two_digits (list-ref arr i))))]))\n  (add_elements_aux\
    \ arr k 0 0))\n", "  (let lp ((acc 0) (pos 0) (arr arr))\n    (cond ((>= pos k)\
    \ acc)\n          ((< (length (number->string (car arr))) 3)\n           (lp (+\
    \ acc (car arr)) (+ pos 1) (cdr arr)))\n          (else (lp acc (+ pos 1) (cdr\
    \ arr))))))\n", "  (cond\n    [(empty? arr) 0]\n    [(>= (count-digits (first\
    \ arr)) 3)\n     (add_elements (rest arr) k)]\n    [(= k 1)\n     (first arr)]\n\
    \    [else\n     (+ (first arr) (add_elements (rest arr) (- k 1)))]))\n", "  (if\
    \ (zero? k)\n      0\n      (if (< 10 (car arr))\n          (+ (car arr) (add_elements\
    \ (cdr arr) (- k 1)))\n          (if (< 100 (car arr))\n              (+ (quotient\
    \ (car arr) 10) (add_elements (cdr arr) (- k 1)))\n              (add_elements\
    \ (cdr arr) (- k 1))))))\n", "  (cond [(empty? arr) 0]\n        [(= 1 (length\
    \ arr)) (car arr)]\n        [(< (car arr) 100) (+ (car arr) (add_elements (cdr\
    \ arr) (- k 1)))]\n        [else (add_elements (cdr arr) (- k 1))]))\n```\n\n\
    We need to take care that if the list is empty or the `k` parameter is 0, the\
    \ function must return 0.\nAlso, we need to make sure that the `k` parameter is\
    \ valid.\nAlso, the first item of the list may have more than 2 digits (even if\
    \ it's empty).\n\n```racket", "  (define sum 0)\n  (for ([i (in-range k)])\n \
    \   (if (and (> arr[i] 9) (< arr[i] 100))\n        (set! sum (+ sum arr[i]))\n\
    \        (when (> arr[i] 99)\n          (set! sum (+ sum (remainder arr[i] 100))))))\n\
    \  sum)\n", "  (apply + (map (\u03BB (el)\n                  (if (and (integer?\
    \ el) (> el 99)) el 0))\n                (take arr k))))\n", "  (define (two-digits?\
    \ x)\n    (and (number? x)\n         (<= 10 x)\n         (<= x 99)))\n  (define\
    \ (sum ls)\n    (cond [(empty? ls) 0]\n          [else (+ (first ls) (sum (rest\
    \ ls)))]))\n  (sum (filter two-digits? (take arr k))))\n", "  (define (smallish?\
    \ n)\n    (and (integer? n)\n         (&lt;= n 99)))\n  (apply + (filter smallish?\
    \ (take arr k))))\n", "  (cond\n    [(empty? arr) 0]\n    [(&lt; (remainder (length\
    \ arr) 10) 3)\n     (+ (add_elements (rest arr) k) (first arr))]\n    [else (add_elements\
    \ (rest arr) k)]))\n</code>\nOne approach I have taken was to create a procedure\
    \ that finds the amount of elements in a list that is less than or equal to 2\
    \ digits. I then remove those elements from the list and recursively call the\
    \ function with the new list. After the list is empty I return the accumulator.\n\
    <code>#lang racket\n", "  (let ([carr (cons 0 arr)])\n    (foldl + 0\n       \
    \     (take k\n                  (map (\u03BB (x)\n                         (if\
    \ (and (>= x 0)\n                                  (<= x 99))\n              \
    \               x\n                             0))\n                       carr)))))\n",
  "  (cond\n    [(zero? k) 0]\n    [(or\n      (= 2 (count-digits (first arr)))\n\
    \      (= 1 (count-digits (first arr))))\n     (+ (first arr) (add_elements (rest\
    \ arr) (- k 1)))]\n    [else (add_elements (rest arr) (- k 1))]))\n", "  (cond\n\
    \    [(empty? arr) 0]\n    [(> (length arr) k)\n     (add_elements (rest arr)\
    \ k)]\n    [(<= (length (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (list->string\
    \ (list->string (list->string (list->string (list->string (list->string (", " \
    \ (cond\n    [(empty? arr) 0]\n    [(empty? (tail arr)) (cond\n              \
    \             [(<= (length (number->string (head arr))) 2) (head arr)]\n     \
    \                      [else 0])]\n    [else (cond\n           [(<= (length (number->string\
    \ (head arr))) 2) (+ (head arr) (add_elements (tail arr) (- k 1)))]\n        \
    \   [else (add_elements (tail arr) (- k 1))])]))", "  (define (to_digits n)\n\
    \    (cond\n      [(< n 10) (list n)]\n      [else (cons (modulo n 10) (to_digits\
    \ (quotient n 10)))]))\n  (define (sum_digits digits)\n    (cond\n      [(null?\
    \ digits) 0]\n      [else (+ (car digits) (sum_digits (cdr digits)))]))\n  (define\
    \ (add_elements-iter lst curr-sum curr-k)\n    (cond\n      [(null? lst) curr-sum]\n\
    \      [(<= k curr-k) curr-sum]\n      [else (add_elements-iter (cdr lst) (+ curr-sum\
    \ (sum_digits (to_digits (car lst)))) (+ curr-k 1))]))\n  (add_elements-iter arr\
    \ 0 0))\n", "  (foldl + 0\n         (map (lambda (x) (if (&lt;= (log10 x) 1) x\
    \ 0))\n              (take arr k))))\n</code>\nI get this error:\n<code>Type Checker:\
    \ Polymorphic function `map' could not be applied to arguments:", "  (define (helper\
    \ arr k sum)\n    (cond ((empty? arr) sum)\n          ((> (length (number->string\
    \ (first arr))) 2) (helper (rest arr) (- k 1) sum))\n          (else (helper (rest\
    \ arr) (- k 1) (+ sum (first arr))))))\n  (helper arr k 0))\n", "  (define len\
    \ (list-length arr))\n  (cond\n    [(= 1 len) (if (< (list-ref arr 0) 10)\n  \
    \                 (list-ref arr 0)\n                   (list-ref arr 0 % 100))]\n\
    \    [(= 2 len) (+ (list-ref arr 0 % 100)\n                  (if (< (list-ref\
    \ arr 1) 10)\n                      (list-ref arr 1)\n                      (list-ref\
    \ arr 1 % 100)))]\n    [else (+ (add_elements (list-ref arr 0 % 100)\n       \
    \                    k)\n             (add_elements (list-ref arr 1 % len)\n \
    \                          (- k 1)))]))", "  (cond ((null? arr) 0)\n        ((not\
    \ (and (>= (car arr) 0) (<= (car arr) 999)))\n         (add_elements (cdr arr)\
    \ k))\n        ((> k 0) (+ (car arr) (add_elements (cdr arr) (- k 1))))\n    \
    \    (else 0)))\n", "  (let loop ([arr arr] [k k] [acc 0])\n    (cond\n      [(or\
    \ (empty? arr) (&lt;= k 0)) acc]\n      [(&lt; 10 (length (number-&gt;string (car\
    \ arr))))\n       (loop (cdr arr) (- k 1) (+ acc (car arr)))]\n      [else (loop\
    \ (cdr arr) (- k 1) acc)])))\n</code>\nMy problem is that my solution is quite\
    \ long and it looks a bit ugly. Is there a way to make it shorter, cleaner? Is\
    \ there a way to make it more Racket-style?\n\n\nA:\n\nThere are two big changes\
    \ that you could make, one stylistic and one about the algorithms.\nStylistically,\
    \ you could use <code>for/fold</code> to make your code flow better, especially\
    \ since <code>fold</code> is a little more idiomatic than <code>loop</code>.\n\
    <code>(define (add-elements arr k)\n  (for/fold ([sum 0])\n            ([element\
    \ (in-list arr)])\n    (if (&lt; 10 (length (number-&gt;string element)))\n  \
    \      sum\n        (+ sum element))))\n</code>\nThe algorithm is a little awkward\
    \ because you only want to stop after <code>k</code> elements instead of the whole\
    \ list. So you need to count how many elements you've looked at and stop at the\
    \ right time.\nInstead, you could slice the list, take the first <code>k</code>\
    \ elements, and then add only the appropriate elements of that.\n<code>(define\
    \ (add-elements arr k)\n  (define (add-two-digits-element? e)\n    (&lt; 10 (length\
    \ (number-&gt;string e))))\n  (apply + (filter add-two-digits-element? (take arr\
    \ k))))\n</code>\n", "  (local ((define (less-than-two-digits n)\n           \
    \  (and (< n 10) (< n 100))))\n    (apply + (filter less-than-two-digits (take\
    \ arr k)))))\n```\n\n```racket\n#lang racket\n", "  (define (sum_digits n)\n \
    \   (cond\n      ((< n 10) n)\n      ((< n 100) (+ (modulo n 10) (quotient n 10)))\n\
    \      (else (+ (modulo n 10) (modulo (quotient n 10) 10) (quotient (quotient\
    \ n 10) 10)))))\n  (define (sum-up lst)\n    (cond\n      ((null? lst) 0)\n  \
    \    (else (+ (sum_digits (car lst)) (sum-up (cdr lst))))))\n  (sum-up (take arr\
    \ k)))\n", "  (if (empty? arr)\n      0\n      (if (&lt; (length (number-&gt;string\
    \ (first arr))) 3)\n          (+ (first arr) (add_elements (rest arr) (- k 1)))\n\
    \          (add_elements (rest arr) (- k 1)))))\n</code>\nHow would I refactor\
    \ this code to use a helper function?\n\n\nA:\n\nI would just move your first-k-elements\
    \ code into a helper function:\n<code>(define (add-elements arr k)\n  (add-k-elements\
    \ (first-k-elements arr k) 0))\n", "  (letrec ([inner (lambda (k sum arr)\n  \
    \                  (cond [(empty? arr) sum]\n                          [(< (length\
    \ (number->string (first arr))) 3)\n                           (inner (- k 1)\
    \ (+ sum (first arr)) (rest arr))]\n                          [else (inner (-\
    \ k 1) sum (rest arr))]))])\n    (inner k 0 arr)))\n", "  (cond\n    [(= 1 k)\
    \ (if (<= 1 (length (number->string (list-ref arr 0))))\n                 (list-ref\
    \ arr 0)\n                 0)]\n    [else (+ (if (<= 1 (length (number->string\
    \ (list-ref arr 0))))\n                (list-ref arr 0)\n                0)\n\
    \             (add_elements (rest arr) (- k 1)))]))", "  (apply +\n         (filter\
    \ (lambda (x)\n                   (and (integer? x)\n                        (<=\
    \ 10 x)\n                        (<= x 99)))\n                 (take arr k))))\n",
  "  (cond\n    [(= k 0) 0]\n    [(or (< (car arr) 10) (< (car arr) 100)) (+ (car\
    \ arr) (add_elements (cdr arr) (- k 1)))]\n    [else (add_elements (cdr arr) (-\
    \ k 1))]))\n```\n\n```racket\n#lang racket\n", "  (define (helper lst acc cnt)\n\
    \    (cond [(= k cnt) acc]\n          [(> (number->string (car lst)) 2)\n    \
    \       (helper (cdr lst) (+ acc (car lst)) (+ cnt 1))]\n          [else (helper\
    \ (cdr lst) acc (+ cnt 1))]))\n  (helper arr 0 0))\n```\n\n## Reverse a Linked\
    \ List\n\n``` #lang racket", "  (for/sum ([val (in-list arr)]\n            #:when\
    \ (<= 1 (length (number->string val)) 2))\n    val))\n", "  (accumulate + 0 (map\
    \ display->number (take arr k))))\n", "  (define (add_elements_tr arr sum k)\n\
    \    (if (&lt;= k 0)\n        sum\n        (add_elements_tr (cdr arr) (+ sum (if\
    \ (&lt;= (car arr) 99) (car arr) 0)) (- k 1))))\n  (add_elements_tr arr 0 k))\n\
    </code>\nBut I'm not sure that's the way to go. What's the real Racket way?\n\n\
    \nA:\n\nIf you know the length of the list, like you do in your problem, then\
    \ the <code>take</code> function is good, but it's much better if you don't need\
    \ to know the length of the list in advance, so the <code>take-while</code> function\
    \ is better in the general case. This solution is short, idiomatic and easy to\
    \ understand:\n<code>(define (add-elements arr k)\n  (apply + (take-while (lambda\
    \ (num) (&lt;= num 99)) arr k)))\n</code>\n", "  (let loop ([arr arr] [sum 0]\
    \ [i 0])\n    (cond [(null? arr) sum]\n          [(= i k) sum]\n          [(>\
    \ (length (number->string (car arr))) 2)\n           (loop (cdr arr) sum i)]\n\
    \          [else (loop (cdr arr) (+ sum (car arr)) (+ i 1))])))\n```\n\n### Bit\
    \ Operation\n\n```racket\n#lang racket\n", "  (cond [(= k 0) 0]\n        [(< (car\
    \ arr) 100) (+ (car arr) (add_elements (cdr arr) (- k 1)))]\n        [else (add_elements\
    \ (cdr arr) (- k 1))]))\n", "  (define (add_elements_iter xs k)\n    (if (and\
    \ (not (empty? xs)) (&lt;= k 0))\n        0\n        (add-two-digits (car xs)\
    \ (add_elements_iter (cdr xs) (- k 1)))))\n  (add_elements_iter arr k))\n", " \
    \ (cond\n    [(empty? arr) 0]\n    [(< (length (number->string (first arr))) 3)\n\
    \     (+ (first arr) (add_elements (rest arr) k))]\n    [else (add_elements (rest\
    \ arr) k)]))\n", "  (cond [(empty? arr) 0]\n        [(< (length (number->string\
    \ (first arr))) 3)\n         (+ (first arr) (add_elements (rest arr) (- k 1)))]\n\
    \        [else (add_elements (rest arr) (- k 1))]))\n", "  (define (aux arr acc)\n\
    \    (if (null? arr)\n        acc\n        (let ([n (car arr)])\n          (if\
    \ (<= n 99)\n              (aux (cdr arr) (+ acc n))\n              (aux (cdr\
    \ arr) acc)))))\n  (aux (take arr k) 0))\n", "  (let ((sum 0))\n    (for ((index\
    \ k)\n          (element arr))\n      (when (<= (length (number->string element))\
    \ 2)\n        (set! sum (+ sum element))))\n    sum))\n", "  (define (add_elements-core\
    \ arr k acc)\n    (cond\n      [(empty? arr) acc]\n      [(or (< (first arr) 10)\
    \ (< (first arr) 100))\n       (add_elements-core (rest arr) (sub1 k) (+ acc (first\
    \ arr)))]\n      [else (add_elements-core (rest arr) (sub1 k) acc)]))\n  (add_elements-core\
    \ arr k 0))\n", "  (cond\n    [(empty? arr) 0]\n    [(= k 0) 0]\n    [else\n \
    \    (if (< (length (number->string (first arr))) 3)\n         (+ (first arr)\
    \ (add_elements (rest arr) (- k 1)))\n         (add_elements (rest arr) (- k 1)))]))\n\
    \n```\n\n```racket\n#lang racket\n", "  (if (zero? k)\n      0\n      (if (or\
    \ (>= (count-digits (car arr)) 3)\n              (empty? arr))\n          (add_elements\
    \ (cdr arr) (- k 1))\n          (+ (car arr) (add_elements (cdr arr) (- k 1))))))\n",
  "  (letrec ([sum 0]\n           [add (lambda (list)\n                   (if (empty?\
    \ list)\n                       sum\n                       (let ([i (car list)])\n\
    \                         (if (and (<= i 100)\n                              \
    \    (>= i -99))\n                             (set! sum (+ sum i))\n        \
    \                     (void))\n                         (add (cdr list))))))])\n\
    \    (add (take arr k))))\n", "  (accumulate + 0 (filter (lambda (x)\n       \
    \                     (or (= 2 (string-length (number->string x)))\n         \
    \                       (= 1 (string-length (number->string x)))))\n         \
    \                 (take arr k))))\n", "  (define (double-digit? n)\n    (<= 10\
    \ n))\n  (define (sum-k-elements k acc)\n    (if (&lt;= k 0)\n        acc\n  \
    \      (let ((next-element (car arr)))\n          (if (double-digit? next-element)\n\
    \              (sum-k-elements (- k 1) (+ acc next-element))\n              (sum-k-elements\
    \ (- k 1) (+ acc (modulo next-element 10)))))))\n  (sum-k-elements k 0))\n</code>\n",
  "  (cond\n    [(zero? k) 0]\n    [(or (= (remainder (abs (car arr)) 100) 0)\n  \
    \        (= (remainder (abs (car arr)) 100) (abs (car arr))))\n     (+ (car arr)\
    \ (add_elements (cdr arr) (- k 1)))]\n    [else (add_elements (cdr arr) (- k 1))]))\n",
  "  (apply + (map (\u03BB (n) (if (< n 100) n 0)) (take arr k))))\n```\n\n```racket\n\
    #lang racket\n", "  (if (empty? arr)\n      0\n      (let ([n (first arr)])\n\
    \        (+ (if (< n 10)\n               n\n               (if (< n 100)\n   \
    \                n\n                   0))\n           (add_elements (rest arr)\
    \ (- k 1))))))\n", "  (if (= k 0)\n      0\n      (let ([x (car arr)])\n     \
    \   (+ (if (< x 100) x 0)\n           (add_elements (cdr arr) (- k 1))))))\n```\n\
    \n``` #lang racket", "  (if (= k 0)\n      0\n      (if (or (and (<= arr 0) (>=\
    \ arr 10))\n              (and (<= arr 100) (>= arr 1000)))\n          (+ (car\
    \ arr) (add_elements (cdr arr) (- k 1)))\n          (add_elements (cdr arr) (-\
    \ k 1)))))\n", "  (apply +\n         (filter (lambda (a) (&lt;= 10 a 99))\n  \
    \               (take arr k))))\n", "  (define (sum-two-digit lst)\n    (if (null?\
    \ lst)\n        0\n        (let* ([x (car lst)]\n               [sum (if (< x\
    \ 100)\n                        x\n                        (+ (modulo x 100)\n\
    \                           (quotient x 100)))])\n          (+ sum (sum-two-digit\
    \ (cdr lst))))))\n  (sum-two-digit (take arr k)))\n", "  (match k\n    [(cons\
    \ v l) (cons v (add_elements l (+ k 1)))]\n    [_ 0]))\n", "  (define (helper\
    \ arr k res)\n    (cond\n      [(null? arr) res]\n      [(<= k 0) res]\n     \
    \ [(< (abs (car arr)) 100) (helper (cdr arr) (- k 1) (+ res (car arr)))]\n   \
    \   [else (helper (cdr arr) (- k 1) res)]))\n  (helper arr k 0))\n", "  (define\
    \ (process x acc)\n    (cond\n      [(= 1 x) (+ acc x)]\n      [(= 2 x) (+ acc\
    \ x)]\n      [else acc]))\n  (if (= k 0)\n      0\n      (process (car arr) (add_elements\
    \ (cdr arr) (- k 1)))))\n", "  (cond\n    [(empty? arr) 0]\n    [(not (empty?\
    \ arr))\n     (if (and (<= 1 (length arr))\n              (<= (length arr) 100)\n\
    \              (<= 1 k)\n              (<= k (length arr)))\n         (cond\n\
    \           [(empty? (rest arr)) (first arr)]\n           [(<= (length (string->number\
    \ (number->string (first arr)))) 2)\n            (+ (first arr) (add_elements\
    \ (rest arr) (- k 1)))]\n           [else (add_elements (rest arr) (- k 1))])\n\
    \         'error)])\n  )\n", "  (if (or (= 0 k) (null? arr))\n      0\n      (if\
    \ (and (<= 10 (car arr)) (<= (car arr) 99))\n          (+ (car arr) (add_elements\
    \ (cdr arr) (- k 1)))\n          (add_elements (cdr arr) (- k 1)))))\n", "  (foldl\
    \ + 0\n         (map (lambda (x)\n                (if (< (abs x) 100)\n      \
    \              x\n                    0))\n              (take arr k))))\n```\n\
    \n#### Problem 4.14\n\nWrite a function that takes a non-empty list of integers,\
    \ and an integer\nk and returns the sum of the k integers which have the greatest\n\
    absolute value.\n\n```scheme\n#lang racket\n", "  (define (add_elements2 arr)\n\
    \    (cond ((null? arr) 0)\n          ((< (length (number->string (car arr)))\
    \ 3)\n           (+ (car arr) (add_elements2 (cdr arr))))\n          (else (add_elements2\
    \ (cdr arr)))))\n  (add_elements2 (take arr k)))\n", "  (apply + (filter (lambda\
    \ (x) (and (>= x 10) (<= x 99))) (take arr k))))\n", "  (accumulate + 0 (filter-k\
    \ (lambda (x)\n                              (or (= 1 (string-length (number->string\
    \ x)))\n                                  (= 2 (string-length (number->string\
    \ x)))))\n                            arr\n                            k)))\n",
  "  (if (zero? k)\n      0\n      (if (or (= 1 (floor (log10 (abs (car arr)))) )\n\
    \              (= 2 (floor (log10 (abs (car arr)))) ))\n          (+ (car arr)\
    \ (add_elements (cdr arr) (- k 1)))\n          (add_elements (cdr arr) (- k 1)))))\n",
  "  (define lst (list->numbers arr))\n  (define sum 0)\n  (define (add_elements-iter\
    \ lst k sum)\n    (cond ((zero? k) sum)\n          ((< (number->string (car lst))\
    \ \"99\")\n           (add_elements-iter (cdr lst) (- k 1) (+ sum (car lst))))\n\
    \          (else (add_elements-iter (cdr lst) (- k 1) sum))))\n  (add_elements-iter\
    \ lst k sum))", "  (define (sum arr k)\n    (if (zero? k)\n        0\n       \
    \ (+ (sum (cdr arr) (- k 1))\n           (if (<= (number->string (car arr)) \"\
    99\")\n               (car arr)\n               0))))\n  (sum arr k))", "  (apply\
    \ + (filter (lambda (e) (<= e 99)) (take arr k))))\n", "  (define (add n)\n  \
    \  (cond\n      [(> n 9) (+ (remainder n 10) (add (quotient n 10)))]\n      [else\
    \ n]))\n  (cond\n    [(zero? k) 0]\n    [else (+ (add_elements (cdr arr) (- k\
    \ 1)) (add (car arr)))]))", "  (let ([nk (min k (length arr))])\n    (let loop\
    \ ([acc 0] [i 0])\n      (cond\n        [(= i nk) acc]\n        [(not (pair? (car\
    \ arr))) (loop (+ acc (car arr)) (+ i 1))]\n        [(= (length (car arr)) 1)\
    \ (loop (+ acc (car arr)) (+ i 1))]\n        [(= (length (car arr)) 2) (loop (+\
    \ acc (car arr)) (+ i 1))]\n        [else (loop acc (+ i 1))]))))\n</code>\nIt\
    \ is a little bit disappointing that Racket has no built-in support for this.\
    \ I would expect something like:\n<code>(define (add_elements arr k)\n  (let ([nk\
    \ (min k (length arr))])\n    (let loop ([acc 0] [i 0])\n      (cond\n       \
    \ [(= i nk) acc]\n        [(not (pair? (car arr))) (loop (+ acc (car arr)) (+\
    \ i 1))]\n        [(number&lt;= (car arr) 99) (loop (+ acc (car arr)) (+ i 1))]\n\
    \        [else (loop acc (+ i 1))]))))\n</code>\nOf course, this is easy to implement:\n\
    <code>(define (number&lt;= n1 n2)\n  (&lt;= (length (number-&gt;string n1)) (length\
    \ (number-&gt;string n2))))\n</code>\nwhich is a classic case of boilerplate.\
    \ So, please, choose whichever one you prefer, but in any case I suggest to avoid\
    \ the \"re-inventing of the wheel\".\n", "  (if (= k 0)\n      0\n      (let ([x\
    \ (car arr)])\n        (+ (if (< 100 x) 0 x)\n           (add_elements (cdr arr)\
    \ (- k 1))))))\n```\n\n```racket\n#lang racket\n", "  (add_elements-helper arr\
    \ k 0))\n", "  (define (loop i res)\n    (cond\n      [(= i k) res]\n      [(>\
    \ (length (number->string (list-ref arr i))) 2) (loop (+ i 1) res)]\n      [else\
    \ (loop (+ i 1) (+ res (list-ref arr i)))]))\n  (loop 0 0))\n", "  (cond\n   \
    \ [(empty? arr) 0]\n    [(= (length arr) 1) (first arr)]\n    [(or (= (length\
    \ arr) 2) (= k 2)) (+ (first arr) (second arr))]\n    [else (add_elements (rest\
    \ arr) (- k 1))]))\n", '  (sum (take arr k)))', "  (cond ((= 0 k) 0)\n       \
    \ ((< 10 (car arr)) (+ (car arr) (add_elements (cdr arr) (- k 1))))\n        ((<\
    \ 100 (car arr)) (+ (car arr) (add_elements (cdr arr) (- k 1))))\n        (else\
    \ (add_elements (cdr arr) (- k 1)))))", "  (define (loop arr k acc)\n    (cond\n\
    \      [(= k 0) acc]\n      [(= 1 (length (number->string (car arr)))) (loop (cdr\
    \ arr) (- k 1) (+ acc (car arr)))]\n      [(= 2 (length (number->string (car arr))))\
    \ (loop (cdr arr) (- k 1) (+ acc (car arr)))]\n      [else (loop (cdr arr) (-\
    \ k 1) acc)]))\n  (loop arr k 0))\n", "  (cond\n    ((= k 0) 0)\n    ((and (<=\
    \ k (length arr)) (>= (car arr) 1) (<= (car arr) 99))\n     (+ (car arr) (add_elements\
    \ (cdr arr) (- k 1))))\n    (else (add_elements (cdr arr) (- k 1)))))\n", "  (define\
    \ els (flatten (map number->list (take arr k))))\n  (define (at-most-two-digits?\
    \ lst)\n    (cond [(empty? lst) #t]\n          [(< (length lst) 3) #t]\n     \
    \     [else #f]))\n  (apply + (filter at-most-two-digits? els)))\n", "  (define\
    \ (add_element_i item acc)\n    (let ((str-item (number->string item)))\n    \
    \  (if (> (string-length str-item) 2)\n          acc\n          (+ acc item))))\n\
    \  (foldl add_element_i 0 (range arr k)))\n", "  (if (equal? (length arr) 0)\n\
    \      0\n      (if (equal? (length arr) 1)\n          (if (equal? (length (number->string\
    \ (car arr))) 2)\n              (car arr)\n              0)\n          (if (and\
    \ (<= (length (number->string (car arr))) 2) (<= (length (number->string (cadr\
    \ arr))) 2))\n              (+ (car arr) (cadr arr))\n              (if (<= (length\
    \ (number->string (car arr))) 2)\n                  (car arr)\n              \
    \    (if (<= (length (number->string (cadr arr))) 2)\n                      (cadr\
    \ arr)\n                      0)))))))\n\n```\n\n```scheme\n#lang racket\n", " \
    \ (foldl + 0 (map length (take k arr))))\n", "  (define (add_elements-rec arr\
    \ k sum)\n    (cond\n      [(= k 0) sum]\n      [(not (fixnum? (car arr))) (add_elements-rec\
    \ (cdr arr) (- k 1) sum)]\n      [(> (car arr) 99) (add_elements-rec (cdr arr)\
    \ (- k 1) sum)]\n      [else (add_elements-rec (cdr arr) (- k 1) (+ sum (car arr)))]))\n\
    \  (add_elements-rec arr k 0))\n```\n\n#### Example 2\n\n```\n#lang racket\n",
  "  (define (has_two_digits x)\n    (and (<= 10 x) (<= x 99)))\n  (define (add_digits\
    \ acc num)\n    (if (has_two_digits num)\n        (+ acc num)\n        acc))\n\
    \  (accumulate add_digits 0 (take arr k)))\n```\n\n```\n#lang racket\n", "  (define\
    \ (get-digits n)\n    (let loop ([n n] [digits '()])\n      (if (= n 0)\n    \
    \      digits\n          (loop (quotient n 10) (cons (remainder n 10) digits)))))\n\
    \  (define (all-digits-less-than-2 digits)\n    (cond\n      [(null? digits) #t]\n\
    \      [(<= (car digits) 1) (all-digits-less-than-2 (cdr digits))]\n      [else\
    \ #f]))\n  (define (aux arr k sum)\n    (cond\n      [(= k 0) sum]\n      [(all-digits-less-than-2\
    \ (get-digits (car arr))) (aux (cdr arr) (- k 1) (+ sum (car arr)))]\n      [else\
    \ (aux (cdr arr) (- k 1) sum)]))\n  (aux arr k 0))\n```\n\n```racket\n#lang racket\n",
  "  (define (two-digits? n)\n    (or (= n (+ (* 10 (quotient n 10)) (remainder n\
    \ 10)))\n        (= n (+ (* 100 (quotient n 100)) (remainder n 100)))))\n  (cond\
    \ ((= k 0) 0)\n        ((two-digits? (car arr)) (+ (car arr) (add_elements (cdr\
    \ arr) (- k 1))))\n        (else (add_elements (cdr arr) (- k 1)))))\n", "  (accumulate\
    \ + 0\n              (map (lambda (x) (if (&lt;= x 99) x 0))\n               \
    \    (take arr k))))\n</code>\n", "  (define (get-first-k items k)\n    (cond\
    \ ((zero? k) '())\n          (else (cons (car items) (get-first-k (cdr items)\
    \ (- k 1))))))\n  (define (get-first-two-digits num)\n    (list (quotient num\
    \ 100) (remainder num 100)))\n  (define (sum-two-digits lst)\n    (apply + lst))\n\
    \  (sum-two-digits (map get-first-two-digits (get-first-k arr k))))", "  (if (or\
    \ (= k 0)\n          (null? arr))\n      0\n      (if (&lt;= (length (number-&gt;string\
    \ (car arr))) 2)\n          (+ (car arr) (add_elements (cdr arr) (- k 1)))\n \
    \         (add_elements (cdr arr) (- k 1)))))\n</code>\nTest Cases:\n<code>#lang\
    \ racket\n", "  (for/sum ([x (in-list arr)])\n    (if (or (= (quotient x 100)\
    \ 0) (= (quotient x 10) 0))\n        x\n        0)))\n\n```\n\n### Basic Python\n\
    ```py\n#!/usr/bin/env python3\n\n# Given a non-empty list of integers arr and\
    \ an integer k, return\n# the sum of the elements with at most two digits from\
    \ the first k elements of arr.\n# Example:\n# >>> (add_elements (list 111 21 3\
    \ 4000 5 6 7 8 9) 4)\n# 24\n# Constraints:\n# 1. 1 <= len(arr) <= 100\n# 2. 1\
    \ <= k <= len(arr)\ndef add_elements(arr, k):\n    return sum(x for x in arr[:k]\
    \ if x < 100)\n\n```\n\n### Javascript\n```js\n#!/usr/bin/env node\n\n// Given\
    \ a non-empty list of integers arr and an integer k, return\n// the sum of the\
    \ elements with at most two digits from the first k elements of arr.\n// Example:\n\
    // >>> (add_elements (list 111 21 3 4000 5 6 7 8 9) 4)\n// 24\n// Constraints:\n\
    // 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nfunction add_elements(arr,\
    \ k) {\n    return arr.slice(0, k).filter(x => x < 100).reduce((x, y) => x + y,\
    \ 0);\n}\n\n```\n\n### C++\n```cpp\n#include <iostream>\n#include <algorithm>\n\
    #include <vector>\n\nusing namespace std;\n\nint main() {\n    vector<int> arr\
    \ = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    int k = 4;\n    int sum = 0;\n   \
    \ for (int i = 0; i < k; i++) {\n        if (arr[i] < 100) {\n            sum\
    \ += arr[i];\n        }\n    }\n    cout << sum << endl;\n    return 0;\n}\n\n\
    ```", "  (let loop ([arr arr] [k k] [acc 0])\n    (cond [(empty? arr) acc]\n \
    \         [(zero? k) acc]\n          [(< (length (number->string (first arr)))\
    \ 3)\n           (loop (rest arr) (sub1 k) (+ acc (first arr)))]\n          [else\
    \ (loop (rest arr) (sub1 k) acc)])))", "  (cond [(= k 0) 0]\n        [(<= (quotient\
    \ (car arr) 100) 1) (car arr) (add_elements (cdr arr) (- k 1))]\n        [else\
    \ (add_elements (cdr arr) (- k 1))]))\n```\n\n```racket\n#lang racket\n", "  (cond\
    \ [(= 1 k) (cond [(< 10 (list-ref arr 0)) (list-ref arr 0)]\n                \
    \         [else (add_elements (cdr arr) (- k 1))])]\n        [else (cond [(< 10\
    \ (list-ref arr 0)) (+ (list-ref arr 0) (add_elements (cdr arr) (- k 1)))]\n \
    \                   [else (add_elements (cdr arr) (- k 1))])]))\n", "  (define\
    \ (sum_nums nums)\n    (cond\n      [(empty? nums) 0]\n      [(zero? (length (number->string\
    \ (first nums)))) 0]\n      [(<= (length (number->string (first nums))) 2)\n \
    \      (+ (first nums) (sum_nums (rest nums)))]\n      [else (sum_nums (rest nums))]))\n\
    \  (sum_nums (take arr k)))\n", "  (let loop ([i 0] [sum 0])\n    (cond [(= i\
    \ k) sum]\n          [(> (length (number->string (list-ref arr i))) 2)\n     \
    \      (loop (+ i 1) sum)]\n          [else\n           (loop (+ i 1) (+ sum (list-ref\
    \ arr i)))])))\n", "  (apply + (filter (lambda (x) (< x 100)) (take arr k))))\n",
  "  (define (f n)\n    (cond\n      [(= n (length arr)) 0]\n      [(> (length (number->string\
    \ n)) 2) (f (+ n 1))]\n      [else (+ n (f (+ n 1)))]))\n  (f 0))\n```\n\n#####\
    \ Explanation\n\nThere are two small steps to this problem:\n\n1. Check the number\
    \ of digits in an integer\n2. Filter a list of numbers to only include those with\
    \ at most two digits\n\nFor the first step, we can take advantage of the `number->string`\
    \ function to turn our integer into a string. Then we can use the string's length\
    \ to get the number of digits.\n\nFor the second step, we can use `cond` to filter\
    \ our list one item at a time, either including the element or not.\n\n##### Examples\n\
    \n```racket", "  (match arr\n    ['() 0]\n    [(cons item (cons next xs))\n  \
    \   (cond\n       [(or (= item 0) (> item 99)) (add_elements xs k)]\n       [(=\
    \ k 1) (+ item (add_elements xs 0))]\n       [else (+ item (add_elements xs (-\
    \ k 1)))])]))\n</code>\n", "  (define (add-elements-helper l n sum)\n    (cond\
    \ ((= n k) sum)\n          ((or (= (length (number->string (car l))) 1)\n    \
    \           (= (length (number->string (car l))) 2))\n           (add-elements-helper\
    \ (cdr l) (+ n 1) (+ sum (car l))))\n          (else (add-elements-helper (cdr\
    \ l) (+ n 1) sum))))\n  (add-elements-helper arr 0 0))\n", "  (let lp ((arr arr)\
    \ (k k) (acc 0))\n    (cond ((= k 0) acc)\n          ((< 10 (abs (car arr))) (lp\
    \ (cdr arr) (sub1 k) (add1 acc)))\n          (else (lp (cdr arr) (sub1 k) (add1\
    \ acc))))))\n", "  (define (loop acc i)\n    (cond [(> i k) acc]\n          [(<\
    \ i k)\n           (let ([sum (+ acc (list-ref arr i))])\n             (loop (if\
    \ (< 10 (list-ref arr i)) sum (+ sum (list-ref arr i))) (+ i 1)))]))\n  (loop\
    \ 0 0))\n", "  (if (or (empty? arr) (= k 0))\n      0\n      (if (< (list-ref\
    \ arr 0) 100)\n          (+ (list-ref arr 0) (add_elements (cdr arr) (- k 1)))\n\
    \          (add_elements (cdr arr) (- k 1)))))\n", "  (cond [(empty? arr) 0]\n\
    \        [(empty? (cdr arr)) (if (< 10 (car arr))\n                          \
    \      (car arr)\n                                0)]\n        [(empty? (cddr\
    \ arr)) (if (< 10 (car arr))\n                                 (car arr)\n   \
    \                              (+ (car arr) (cadr arr)))]\n        [else (+ (car\
    \ arr) (cadr arr) (caddr arr))]))\n", "  (define (add_elements_helper arr k i\
    \ result)\n    (cond\n      [(> i k) result]\n      [(<= 10 (list-ref arr i) 99)\
    \ (add_elements_helper arr k (+ i 1) (+ result (list-ref arr i)))]\n      [else\
    \ (add_elements_helper arr k (+ i 1) result)]))\n  (add_elements_helper arr k\
    \ 0 0))\n", "  (letrec ((sum-of-up-to-two-digit-numbers\n            (lambda (list-of-numbers)\n\
    \              (match list-of-numbers\n                [(cons (? integer? n) (?\
    \ (listof integer?)))\n                 (cond [(>= n 100) (sum-of-up-to-two-digit-numbers\
    \ (cdr list-of-numbers))]\n                       [else (+ n (sum-of-up-to-two-digit-numbers\
    \ (cdr list-of-numbers)))]\n                       )]\n                [else 0]))))\n\
    \    (sum-of-up-to-two-digit-numbers (take arr k))))\n", "  (define (add_elements-impl\
    \ arr-impl total)\n    (cond\n      [(empty? arr-impl) total]\n      [(< (length\
    \ (symbol->string (car arr-impl))) 3)\n       (add_elements-impl (cdr arr-impl)\
    \ (+ total (car arr-impl)))]\n      [else (add_elements-impl (cdr arr-impl) total)]))\n\
    \  (add_elements-impl (take arr k) 0))"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
