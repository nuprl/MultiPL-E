name: HumanEval_122_add_elements
language: rkt
prompt: "#lang racket\n\n;; Given a non-empty list of integers arr and an integer\
  \ k, return\n;; the sum of the elements with at most two digits from the first k\
  \ elements of arr.\n;; Example:\n;; >>> (add_elements (list 111 21 3 4000 5 6 7\
  \ 8 9) 4)\n;; 24\n;; Constraints:\n;; 1. 1 <= len(arr) <= 100\n;; 2. 1 <= k <= len(arr)\n\
  (define (add_elements arr k)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add_elements))\n\
  \    (check-equal? (candidate (list 1 -2 -3 41 57 76 87 88 99) 3) -4)\n    (check-equal?\
  \ (candidate (list 111 121 3 4000 5 6) 2) 0)\n    (check-equal? (candidate (list\
  \ 11 21 3 90 5 6 7 8 9) 4) 125)\n    (check-equal? (candidate (list 111 21 3 4000\
  \ 5 6 7 8 9) 4) 24)\n    (check-equal? (candidate (list 1) 1) 1)\n))\n\n(test-humaneval)"
completions: ["  (let loop ([arr arr] [k k] [sum 0])\n    (cond\n      [(zero? k)\
    \ sum]\n      [(< (abs (car arr)) 100) (loop (cdr arr) (- k 1) (+ sum (car arr)))]\n\
    \      [else (loop (cdr arr) (- k 1) sum)])))", "  (let loop ([arr arr] [k k]\
    \ [sum 0])\n    (cond [(and (not (empty? arr)) (= k 0)) sum]\n          [(and\
    \ (not (empty? arr)) (= 1 (floor (log (car arr) 10))))\n           (loop (cdr\
    \ arr) (- k 1) (+ sum (car arr)))]\n          [(and (not (empty? arr)) (= 2 (floor\
    \ (log (car arr) 10))))\n           (loop (cdr arr) (- k 1) (+ sum (car arr)))]\n\
    \          [else (loop (cdr arr) (- k 1) sum)])))\n", "  (cond\n    [(= k 0) 0]\n\
    \    [(and (or (< (car arr) 10) (< (car arr) 100)) (< k (length arr)))\n     (+\
    \ (car arr) (add_elements (cdr arr) (- k 1)))]\n    [else (add_elements (cdr arr)\
    \ (- k 1))]))\n", "  (cond\n    [(zero? k) 0]\n    [(< (length (list->string (list-ref\
    \ arr 0))) 3)\n     (+ (list-ref arr 0) (add_elements (rest arr) (- k 1)))]\n\
    \    [else (add_elements (rest arr) (- k 1))]))\n```\n\n[Test Program](https://wandbox.org/permlink/7VQONyTjq9mQTcPa)",
  "  (cond\n    [(zero? k) 0]\n    [(< 10 (car arr)) (+ (car arr) (add_elements (cdr\
    \ arr) (- k 1)))]\n    [(< 100 (car arr)) (+ (car arr) (add_elements (cdr arr)\
    \ (- k 1)))]\n    [else (add_elements (cdr arr) (- k 1))]))\n", "  (apply +\n\
    \    (filter (lambda (x)\n\t       (or (<= 10 x) (<= 100 x)))\n      (take k arr))))\n",
  "  (foldl + 0\n         (map (\u03BB (n) (if (> n 99) 100 n))\n              (take\
    \ arr k))))\n", "  (define (is_two_digits n)\n    (< 10 n 100))\n  (apply + (filter\
    \ is_two_digits (take arr k))))\n", "  (cond ((= 1 k) (add-list (list-head k arr)))\n\
    \        ((&lt; 1 k) (add (add-list (list-head k arr))\n                     \
    \ (add_elements (list-tail k arr) (- k 1))))))\n", "  (cond\n    [(= k 0) 0]\n\
    \    [(&lt;= (quotient (car arr) 100) 1)\n     (+ (car arr) (add_elements (cdr\
    \ arr) (- k 1)))]\n    [else (add_elements (cdr arr) (- k 1))]))\n", "  (define\
    \ (add-rec lst sum)\n    (cond ((= k 0) sum)\n          ((> (string-length (number->string\
    \ (car lst))) 2) (add-rec (cdr lst) sum))\n          (else (add-rec (cdr lst)\
    \ (+ sum (car lst))))))\n  (add-rec arr 0))\n", "  (cond\n    [(null? arr) 0]\n\
    \    [(not (integer? (car arr))) (add_elements (cdr arr) k)]\n    [(>= k 0) (+\
    \ (car arr) (add_elements (cdr arr) (- k 1)))]\n    [else 0]))\n```\n\n```scheme\n\
    #lang racket\n", "  (if (null? arr)\n      0\n      (if (&lt; (count-digits (car\
    \ arr)) 3)\n          (+ (car arr) (add_elements (cdr arr) (- k 1)))\n       \
    \   (add_elements (cdr arr) (- k 1)))))\n", "  (cond [(null? arr) 0]\n       \
    \ [(or (= 1 (modulo (car arr) 100)) (= 1 (modulo (car arr) 1000)))\n         (+\
    \ (car arr) (add_elements (cdr arr) (- k 1)))]\n        [else (add_elements (cdr\
    \ arr) (- k 1))]))\n", "  (cond [(empty? arr) 0]\n        [(and (= (length arr)\
    \ k)\n              (>= (length (number->string (first arr))) 3))\n         (add_elements\
    \ (rest arr) (- k 1))]\n        [else (+ (first arr) (add_elements (rest arr)\
    \ (- k 1)))]))\n```\n\n```scheme\n#lang racket\n", "  (cond\n    [(<= k 0) 0]\n\
    \    [(<= (modulo (car arr) 100) 9)\n     (+ (modulo (car arr) 100) (add_elements\
    \ (cdr arr) (- k 1)))]\n    [else\n     (+ (car arr) (add_elements (cdr arr) (-\
    \ k 1)))]))\n", "  (let loop ([arr arr] [k k] [sum 0])\n    (cond\n      [(empty?\
    \ arr) sum]\n      [(> k 0)\n       (let ([i (first arr)])\n         (if (<= i\
    \ 99)\n             (loop (rest arr) (- k 1) (+ sum i))\n             (loop (rest\
    \ arr) k sum)))])))\n", "  (apply + (map (compose (lambda (n) (if (&lt; n 100)\
    \ n 0)) number-&gt;string) (take arr k))))\n</code>\n", "  (cond [(zero? k) 0]\n\
    \        [(number-&gt;string (car arr) 2)\n         (+ (car arr) (add_elements\
    \ (cdr arr) (- k 1)))]\n        [else (add_elements (cdr arr) (- k 1))]))\n</code>\n",
  "  (cond [(= k 0) 0]\n        [(>= (length (number->string (car arr))) 3) (add_elements\
    \ (cdr arr) (- k 1))]\n        [else (+ (car arr) (add_elements (cdr arr) (- k\
    \ 1)))]))"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
