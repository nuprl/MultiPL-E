name: HumanEval_116_sort_array
language: rkt
prompt: "#lang racket\n\n;; In this Kata, you have to sort a list of non-negative\
  \ integers according to\n;; number of ones in their binary representation in ascending\
  \ order.\n;; For similar number of ones, sort based on decimal value.\n;; It must\
  \ be implemented like this:\n;; >>> (sort_array (list 1 5 2 3 4))\n;; (list 1 2\
  \ 3 4 5)\n;; >>> (sort_array (list -2 -3 -4 -5 -6))\n;; (list -6 -5 -4 -3 -2)\n\
  ;; >>> (sort_array (list 1 0 2 3 4))\n;; (list 0 1 2 3 4)\n(define (sort_array arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n\
  \    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))\n    (check-equal?\
  \ (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))\n    (check-equal? (candidate\
  \ (list 1 0 2 3 4)) (list 0 1 2 4 3))\n    (check-equal? (candidate (list )) (list\
  \ ))\n    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4\
  \ 3 3 5 5 5 7 77))\n    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32\
  \ 3 5 6 12 44))\n    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16\
  \ 32))\n    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))\n))\n\
  \n(test-humaneval)"
completions: ["  (define (popcnt n)\n    (if (zero? n)\n        0\n        (+ (popcnt\
    \ (quotient n 2)) (remainder n 2))))\n  (define (cmp a b)\n    (cond\n      [(and\
    \ (positive? a) (positive? b))\n       (cond\n         [(= (popcnt a) (popcnt\
    \ b)) (< a b)]\n         [else (< (popcnt a) (popcnt b))])]\n      [(and (negative?\
    \ a) (negative? b))\n       (cond\n         [(= (popcnt a) (popcnt b)) (> a b)]\n\
    \         [else (< (popcnt a) (popcnt b))])]\n      [(or (negative? a) (negative?\
    \ b))\n       (cond\n         [(= (popcnt a) (popcnt b)) (< (abs a) (abs b))]\n\
    \         [else (< (popcnt a) (popcnt b))])]))\n  (sort cmp arr))\n", "  (define\
    \ (count-ones n)\n    (let loop ([n n] [s 0])\n      (cond [(> n 0) (loop (quotient\
    \ n 2) (if (zero? (remainder n 2)) s (+ s 1)))]\n            [else s])))\n  (for/sort\
    \ ([x arr]) ([x 0] #:key count-ones) [y arr]\n            (if (= (count-ones x)\
    \ (count-ones y))\n                (cond [(< x y) x]\n                      [(>\
    \ x y) y]\n                      [else x])\n                (cond [(< (count-ones\
    \ x) (count-ones y)) x]\n                      [(> (count-ones x) (count-ones\
    \ y)) y]\n                      [else x]))))\n```\n\n```", "  (sort (lambda (x\
    \ y) (< x y))\n        (sort (lambda (x y) (< (ones x) (ones y))) arr)))\n", " \
    \ (sort < arr))\n", "  (define (ones n)\n    (if (zero? n)\n        0\n      \
    \  (+ (logand 1 n) (ones (bitshift-right n 1)))))\n  (sort (< (ones (car arr2))\
    \ (ones (car arr1))) arr))\n", "  (sort (map (lambda (x)\n               (cons\
    \ (count-ones x) x))\n             arr)\n        <))\n", "  (sort (make-list (\u03BB\
    \ (x)\n                     (cons (count-set-bits x) x))\n                   arr)\n\
    \        >\n        #:key car))\n", "  (sort (lambda (x y) (cond\n           \
    \             ((= (count-ones x) (count-ones y)) (< x y))\n                  \
    \      ((< (count-ones x) (count-ones y)) #t)\n                        (#t #f)))\n\
    \        arr))\n", "  (if (empty? arr)\n      '()\n      (merge (sort_array (filter-ones\
    \ arr 0))\n             (sort_array (filter-ones arr 1)))))\n", "  (define (count-ones\
    \ n)\n    (define (helper total n)\n      (cond [(zero? n) total]\n          \
    \  [(and (not (zero? n)) (zero? (remainder n 2))) (helper total (quotient n 2))]\n\
    \            [(and (not (zero? n)) (not (zero? (remainder n 2)))) (helper (+ total\
    \ 1) (quotient n 2))]))\n    (helper 0 n))\n  (sort (\u03BB (x y) (cond [(< (count-ones\
    \ x) (count-ones y)) #t]\n                         [(= (count-ones x) (count-ones\
    \ y)) (< x y)]\n                         [else #f])) arr))", "  (define (count-ones\
    \ n)\n    (define (loop acc n)\n      (cond [(= n 0) acc]\n            [(= (remainder\
    \ n 2) 1) (loop (+ acc 1) (quotient n 2))]\n            [else (loop acc (quotient\
    \ n 2))]))\n    (loop 0 n))\n  (define (sort-key x)\n    (cons (count-ones x)\
    \ x))\n  (define (sort-key-lt? key-a key-b)\n    (cond [(= (car key-a) (car key-b))\
    \ (< (cdr key-a) (cdr key-b))]\n          [else (< (car key-a) (car key-b))]))\n\
    \  (sort arr sort-key-lt?))", "  (define (ones x)\n    (if (zero? x)\n       \
    \ 0\n        (+ 1 (ones (bitwise-arithmetic-shift-right x 1)))))\n  (define (compare\
    \ a b)\n    (let ((a-ones (ones a))\n          (b-ones (ones b)))\n      (cond\
    \ ((zero? (- a-ones b-ones))\n             (cond ((= a b)\n                  \
    \  0)\n                   ((< a b)\n                    -1)\n                \
    \   (else\n                    1)))\n            ((< a-ones b-ones)\n        \
    \     -1)\n            (else\n             1))))\n  (sort compare arr))", "  (sort\
    \ arr >\n        (lambda (a b)\n          (cond\n            [(or (positive? a)\
    \ (positive? b))\n             (equal? (count-ones a) (count-ones b))]\n     \
    \       [else\n             (equal? a b)]))))\n", "  (sort arr (\u03BB (x y)\n\
    \             (let ([fx (bin-ones x)]\n                   [fy (bin-ones y)])\n\
    \               (or (< fx fy)\n                   (and (= fx fy)\n           \
    \             (< x y)))))))\n", "  (list-sort (lambda (a b) (or (< (ones a) (ones\
    \ b))\n                                (and (= (ones a) (ones b))\n          \
    \                           (< a b))))\n             arr))\n", "  (sort (lambda\
    \ (x y) (let ([x-ones (count-ones x)]\n                             [y-ones (count-ones\
    \ y)])\n                       (if (= x-ones y-ones)\n                       \
    \    (< x y)\n                           (< x-ones y-ones))))\n        arr))\n",
  "  (sort (map (compose string->number (compose string-append \"0\")) arr)\n    \
    \    <))\n", "  (sort (sort arr <)\n        (lambda (x y) (< (count-ones x) (count-ones\
    \ y)))))\n", "  (sort (sort arr (lambda (a b) (< (get-bits a) (get-bits b))))\
    \ <))\n", "  (sort (map (\u03BB (x) x) arr)\n        (\u03BB (x y)\n         \
    \ (< (how-many-ones x) (how-many-ones y)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
