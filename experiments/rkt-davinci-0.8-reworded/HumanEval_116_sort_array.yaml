name: HumanEval_116_sort_array
language: rkt
prompt: "#lang racket\n\n;; In this Kata, you have to sort a list of non-negative\
  \ integers according to\n;; number of ones in their binary representation in ascending\
  \ order.\n;; For similar number of ones, sort based on decimal value.\n;; It must\
  \ be implemented like this:\n;; >>> (sort_array (list 1 5 2 3 4))\n;; (list 1 2\
  \ 3 4 5)\n;; >>> (sort_array (list -2 -3 -4 -5 -6))\n;; (list -6 -5 -4 -3 -2)\n\
  ;; >>> (sort_array (list 1 0 2 3 4))\n;; (list 0 1 2 3 4)\n(define (sort_array arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n\
  \    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))\n    (check-equal?\
  \ (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))\n    (check-equal? (candidate\
  \ (list 1 0 2 3 4)) (list 0 1 2 4 3))\n    (check-equal? (candidate (list )) (list\
  \ ))\n    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4\
  \ 3 3 5 5 5 7 77))\n    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32\
  \ 3 5 6 12 44))\n    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16\
  \ 32))\n    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))\n))\n\
  \n(test-humaneval)"
completions: ["  (define (popcnt n)\n    (if (zero? n)\n        0\n        (+ (popcnt\
    \ (quotient n 2)) (remainder n 2))))\n  (define (cmp a b)\n    (cond\n      [(and\
    \ (positive? a) (positive? b))\n       (cond\n         [(= (popcnt a) (popcnt\
    \ b)) (< a b)]\n         [else (< (popcnt a) (popcnt b))])]\n      [(and (negative?\
    \ a) (negative? b))\n       (cond\n         [(= (popcnt a) (popcnt b)) (> a b)]\n\
    \         [else (< (popcnt a) (popcnt b))])]\n      [(or (negative? a) (negative?\
    \ b))\n       (cond\n         [(= (popcnt a) (popcnt b)) (< (abs a) (abs b))]\n\
    \         [else (< (popcnt a) (popcnt b))])]))\n  (sort cmp arr))\n", "  (define\
    \ (count-ones n)\n    (let loop ([n n] [s 0])\n      (cond [(> n 0) (loop (quotient\
    \ n 2) (if (zero? (remainder n 2)) s (+ s 1)))]\n            [else s])))\n  (for/sort\
    \ ([x arr]) ([x 0] #:key count-ones) [y arr]\n            (if (= (count-ones x)\
    \ (count-ones y))\n                (cond [(< x y) x]\n                      [(>\
    \ x y) y]\n                      [else x])\n                (cond [(< (count-ones\
    \ x) (count-ones y)) x]\n                      [(> (count-ones x) (count-ones\
    \ y)) y]\n                      [else x]))))\n```\n\n```", "  (sort (lambda (x\
    \ y) (< x y))\n        (sort (lambda (x y) (< (ones x) (ones y))) arr)))\n", " \
    \ (sort < arr))\n", "  (define (ones n)\n    (if (zero? n)\n        0\n      \
    \  (+ (logand 1 n) (ones (bitshift-right n 1)))))\n  (sort (< (ones (car arr2))\
    \ (ones (car arr1))) arr))\n", "  (sort (map (lambda (x)\n               (cons\
    \ (count-ones x) x))\n             arr)\n        <))\n", "  (sort (make-list (\u03BB\
    \ (x)\n                     (cons (count-set-bits x) x))\n                   arr)\n\
    \        >\n        #:key car))\n", "  (sort (lambda (x y) (cond\n           \
    \             ((= (count-ones x) (count-ones y)) (< x y))\n                  \
    \      ((< (count-ones x) (count-ones y)) #t)\n                        (#t #f)))\n\
    \        arr))\n", "  (if (empty? arr)\n      '()\n      (merge (sort_array (filter-ones\
    \ arr 0))\n             (sort_array (filter-ones arr 1)))))\n", "  (define (count-ones\
    \ n)\n    (define (helper total n)\n      (cond [(zero? n) total]\n          \
    \  [(and (not (zero? n)) (zero? (remainder n 2))) (helper total (quotient n 2))]\n\
    \            [(and (not (zero? n)) (not (zero? (remainder n 2)))) (helper (+ total\
    \ 1) (quotient n 2))]))\n    (helper 0 n))\n  (sort (\u03BB (x y) (cond [(< (count-ones\
    \ x) (count-ones y)) #t]\n                         [(= (count-ones x) (count-ones\
    \ y)) (< x y)]\n                         [else #f])) arr))", "  (define (count-ones\
    \ n)\n    (define (loop acc n)\n      (cond [(= n 0) acc]\n            [(= (remainder\
    \ n 2) 1) (loop (+ acc 1) (quotient n 2))]\n            [else (loop acc (quotient\
    \ n 2))]))\n    (loop 0 n))\n  (define (sort-key x)\n    (cons (count-ones x)\
    \ x))\n  (define (sort-key-lt? key-a key-b)\n    (cond [(= (car key-a) (car key-b))\
    \ (< (cdr key-a) (cdr key-b))]\n          [else (< (car key-a) (car key-b))]))\n\
    \  (sort arr sort-key-lt?))", "  (define (ones x)\n    (if (zero? x)\n       \
    \ 0\n        (+ 1 (ones (bitwise-arithmetic-shift-right x 1)))))\n  (define (compare\
    \ a b)\n    (let ((a-ones (ones a))\n          (b-ones (ones b)))\n      (cond\
    \ ((zero? (- a-ones b-ones))\n             (cond ((= a b)\n                  \
    \  0)\n                   ((< a b)\n                    -1)\n                \
    \   (else\n                    1)))\n            ((< a-ones b-ones)\n        \
    \     -1)\n            (else\n             1))))\n  (sort compare arr))", "  (sort\
    \ arr >\n        (lambda (a b)\n          (cond\n            [(or (positive? a)\
    \ (positive? b))\n             (equal? (count-ones a) (count-ones b))]\n     \
    \       [else\n             (equal? a b)]))))\n", "  (sort arr (\u03BB (x y)\n\
    \             (let ([fx (bin-ones x)]\n                   [fy (bin-ones y)])\n\
    \               (or (< fx fy)\n                   (and (= fx fy)\n           \
    \             (< x y)))))))\n", "  (list-sort (lambda (a b) (or (< (ones a) (ones\
    \ b))\n                                (and (= (ones a) (ones b))\n          \
    \                           (< a b))))\n             arr))\n", "  (sort (lambda\
    \ (x y) (let ([x-ones (count-ones x)]\n                             [y-ones (count-ones\
    \ y)])\n                       (if (= x-ones y-ones)\n                       \
    \    (< x y)\n                           (< x-ones y-ones))))\n        arr))\n",
  "  (sort (map (compose string->number (compose string-append \"0\")) arr)\n    \
    \    <))\n", "  (sort (sort arr <)\n        (lambda (x y) (< (count-ones x) (count-ones\
    \ y)))))\n", "  (sort (sort arr (lambda (a b) (< (get-bits a) (get-bits b))))\
    \ <))\n", "  (sort (map (\u03BB (x) x) arr)\n        (\u03BB (x y)\n         \
    \ (< (how-many-ones x) (how-many-ones y)))))\n", "  (let ([ones (map (\u03BB (n)\n\
    \                     (if (negative? n)\n                         (modulo (integer->bit-string\
    \ (abs n)) 2)\n                         (integer->bit-string n)))\n          \
    \         arr)])\n    (sort < arr)))\n", "  (sort arr (\u03BB (x y)\n        \
    \      (match (fx=? (count-ones x) (count-ones y))\n                [#t (fx<=?\
    \ x y)]\n                [#f (fx<=? (count-ones x) (count-ones y))]))))\n", " \
    \ (sort (map number->string arr) string<?))\n", "  (sort arr < :key (lambda (n)\
    \ (cons (count-ones n) n))))\n", "  (sort < arr))\n", '  (sort arr <))', "  (sort\
    \ (map (\u03BB (n) (list (bit-count n) n)) arr)\n        (\u03BB (a b) (if (<\
    \ (car a) (car b))\n                     #t\n                     (if (equal?\
    \ (car a) (car b))\n                         (< (cadr a) (cadr b))\n         \
    \                #f)))))\n", "  (sort (map\n         (\u03BB (x)\n           (cons\
    \ (bit-count x) x))\n         arr)\n        (\u03BB (x y)\n          (cond\n \
    \           [(< (car x) (car y)) #t]\n            [(> (car x) (car y)) #f]\n \
    \           [(= (car x) (car y))\n             (< (cdr x) (cdr y))]))))\n", " \
    \ (cond [(empty? arr) empty]\n        [else (sort (lambda (e1 e2)\n          \
    \            (cond [(< (count-ones e1) (count-ones e2)) #t]\n                \
    \            [(> (count-ones e1) (count-ones e2)) #f]\n                      \
    \      [else (< e1 e2)]))\n                    arr)]))\n", "  (sort (map (lambda\
    \ (n)\n               (list n (apply + (map bitwise-and n '(1 1 1 1 1 1 1 1 1\
    \ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\
    \ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\
    \ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\
    \ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\
    \ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\
    \ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\
    \ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\
    \ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\
    \ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\
    \ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\
    \ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\
    \ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\
    \ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1", "  (define (bit-count x)\n    (if\
    \ (= x 0)\n        0\n        (+ 1 (bit-count (quotient x 2)))))\n  (sort arr\
    \ (\u03BB (x y) (< (bit-count x) (bit-count y)))))\n", "  (sort arr bin-cmp))\n",
  "  (sort (lambda (x y) (< (count-bits x) (count-bits y))) arr))\n", "  (sort arr\
    \ (lambda (a b)\n              (or (< (ones a) (ones b))\n                  (and\
    \ (= (ones a) (ones b))\n                       (< a b))))))\n", "  (define (ones\
    \ n)\n    (cond\n      [(zero? n) 0]\n      [(and (odd? n) (zero? (remainder n\
    \ 2)))\n       (+ 1 (ones (quotient n 2)))]\n      [else (ones (quotient n 2))]))\n\
    \  (define (bignum-&gt;key b)\n    (let* ([s (number-&gt;string b)]\n        \
    \   [d (string-&gt;number s)]\n           [o (ones b)])\n      (cons o d)))\n\
    \  (define (key-&gt;value p)\n    (cdr p))\n  (define (key-&lt;? a b)\n    (let*\
    \ ([a-o (car a)]\n           [a-d (cdr a)]\n           [b-o (car b)]\n       \
    \    [b-d (cdr b)])\n      (cond\n        [(= a-o b-o) (&lt; a-d b-d)]\n     \
    \   [else (&lt; a-o b-o)])))\n  (sort arr bignum-&gt;key key-&lt;? key-&gt;value))\n\
    </code>\nHowever, this solution is too slow:\n<code>&gt; (sort_array (build-list\
    \ 1000 list))\n\nreal    0m0.050s\nuser    0m0.011s\nsys     0m0.000s\n</code>\n\
    This solution seems to have a different time complexity. How can I get the same\
    \ behaviour with a faster solution? Is there any problem with the above solution?\
    \ How do I improve the algorithm to be more efficient?\nNote: This Kata is originally\
    \ from CodeWars.\n\n\nA:\n\nI know you said \"preferably not\", but you can use\
    \ a mutable vector to make this linear time. I've never benchmarked against the\
    \ standard <code>sort</code> function so I don't know if it's faster or not.\n\
    <code>(define (sort-mutable lst)\n  (define vec (vector-sort lst (lambda (a b)\
    \ (&lt; (ones a) (ones b)))))\n  (let loop ((i 0) (result '()))\n    (if (=",
  "  (sort (map (\u03BB (x) (list x (number->string x 2))) arr)\n        (\u03BB (a\
    \ b)\n           (cond [(= (length (last a)) (length (last b)))\n            \
    \      (< (first a) (first b))]\n                 [else (< (length (last a)) (length\
    \ (last b)))]))))\n", "  (sort arr\n        (\u03BB (a b)\n          (cond\n \
    \           [(equal? (count-ones a) (count-ones b))\n             (< a b)]\n \
    \           [(< (count-ones a) (count-ones b)) #t]\n            [else #f]))))\n",
  "  (quicksort arr\n             (lambda (a b)\n               (cond\n          \
    \       [(< (count-ones a) (count-ones b)) #t]\n                 [(> (count-ones\
    \ a) (count-ones b)) #f]\n                 [else (< a b)]))))\n", "  (sort (\u03BB\
    \ (a b) (or (< (ones a) (ones b)) (< a b))) arr))\n", "  (let ([indices (for/list\
    \ ([n (in-list arr)]) (values n (count-ones n)))])\n    (sort (< (cdr a) (cdr\
    \ b)) (map car indices))))\n", "  (sort arr (lambda (x y)\n              (let\
    \ ((binx (number->string x 2))\n                    (biny (number->string y 2)))\n\
    \                (and (= (string-length binx) (string-length biny))\n        \
    \             (<= x y))))))\n", "  (sort (map (lambda (x) (list x (bit-count x)))\
    \ arr)\n        (lambda (x y) (let ((i (car x)) (j (car y)))\n               \
    \         (or (> i j)\n                            (and (= i j) (< (cadr x) (cadr\
    \ y))))))))\n", "  (let ([xs (map integer->binary arr)])\n    (vector-sort! (lambda\
    \ (x y)\n                    (or (< (count-ones x) (count-ones y))\n         \
    \               (and (= (count-ones x) (count-ones y))\n                     \
    \        (< (string->number x) (string->number y)))))\n                  xs)\n\
    \    (map string->number xs)))\n", "  (define (ones x)\n    (if (= x 0)\n    \
    \    0\n        (+ (modulo x 2) (ones (quotient x 2)))))\n  (define (sort-helper\
    \ x y)\n    (if (< (ones x) (ones y))\n        #t\n        (if (> (ones x) (ones\
    \ y))\n            #f\n            (< x y))))\n  (sort sort-helper arr))\n", " \
    \ (letrec ([zero? (lambda (num) (= num 0))]\n           [one? (lambda (num) (=\
    \ num 1))]\n           [last-ones-count (lambda (num) (if (zero? num) 0 (+ 1 (last-ones-count\
    \ (quotient num 2)))))]\n           [ones-count (lambda (num)\n              \
    \           (letrec ([next (lambda (num count)\n                             \
    \             (if (zero? num) count (next (quotient num 2) (+ 1 count))))])\n\
    \                           (next num 0)))])\n    (sort (lambda (a b)\n      \
    \      (cond [(and (negative? a) (negative? b))\n                   (cond [(>\
    \ a b) #t]\n                         [(< a b) #f]\n                         [else\
    \ (< (ones-count a) (ones-count b))])]\n                  [(or (negative? a) (negative?\
    \ b))\n                   (cond [(negative? a) #t]\n                         [(negative?\
    \ b) #f]\n                         [else (< (ones-count a) (ones-count b))])]\n\
    \                  [else (< (ones-count a) (ones-count b))]))\n          arr)))\n",
  "  (quicksort arr\n             (lambda (a b)\n               (let* ([a-ones (count-ones\
    \ a)]\n                      [b-ones (count-ones b)])\n                 (cond\
    \ [(> a-ones b-ones) #t]\n                       [(< a-ones b-ones) #f]\n    \
    \                   [(> a b) #t]\n                       [(< a b) #f]\n      \
    \                 [else #f])))))\n", "  (sort < arr))\n", "  (sort (\u03BB (x\
    \ y)\n          (if (> (count-ones x) (count-ones y)) #t\n              (if (<\
    \ (count-ones x) (count-ones y)) #f\n                  (if (> x y) #t #f))))\n\
    \        arr))\n", "  (sort (lambda (x y) (if (> (count-bits x) (count-bits y))\n\
    \                          #t\n                          (if (< (count-bits x)\
    \ (count-bits y))\n                              #f\n                        \
    \      (< x y))))\n        arr))\n", "  (sort arr\n        (lambda (a b)\n   \
    \       (or (> (bit-count a) (bit-count b))\n              (and (= (bit-count\
    \ a) (bit-count b))\n                   (< a b))))))", "  (cond [(empty? arr)\
    \ '()]\n        [else (append (list (first arr))\n                      (sort_array\
    \ (sort-array-helper (rest arr) (first arr))))]))\n", "  (sort (map binary-one-count\
    \ arr) (lambda (a b) (< (car a) (car b)))))\n", "  (sort (map (lambda (x)\n  \
    \             (list (logand #b1 x) x))\n             arr)\n        <))\n", " \
    \ (sort (map (lambda (a) (cons (count-ones a) a)) arr)\n          <\n        \
    \  #:key (lambda (p) p)))\n", "  (sort arr bin-ordering))\n", "  (sort (lambda\
    \ (a b)\n          (cond\n            [(or (= a 0) (= b 0))\n             (<=\
    \ a b)]\n            [(= (count-ones a) (count-ones b))\n             (<= a b)]\n\
    \            [else\n             (< (count-ones a) (count-ones b))]))\n      \
    \  arr))\n", "  (sort (map (lambda (x) (list x (integer->binary x))) arr)\n  \
    \      (lambda (a b)\n          (let* ([a1 (first a)]\n                 [a2 (second\
    \ a)]\n                 [b1 (first b)]\n                 [b2 (second b)])\n  \
    \          (or (< (length a2) (length b2))\n                (and (= (length a2)\
    \ (length b2))\n                     (< a1 b1)))))))\n", "  (sort (map number->string\
    \ arr) #:key (lambda (n) (string->number n 2)) compare))\n", "  (sort (sort-by\
    \ integer->binary arr) < arr))\n", "  (sort (lambda (x y) (cond ((< (number->string\
    \ (binary-decimal-repr x))\n                               (number->string (binary-decimal-repr\
    \ y)))\n                             #t)\n                            ((> (number->string\
    \ (binary-decimal-repr x))\n                                (number->string (binary-decimal-repr\
    \ y)))\n                             #f)\n                            (else (<\
    \ x y))))\n        arr))\n", "  (sort\n   (lambda (a b)\n     (if (bin-ones a)\n\
    \         (< (bin-ones a) (bin-ones b))\n         (> a b)))\n   arr))\n", "  (define\
    \ (ones n)\n    (define (ones-h n k)\n      (if (zero? n) k\n          (ones-h\
    \ (bitwise-arithmetic-shift-right n 1)\n                  (+ k (modulo n 2)))))\n\
    \    (ones-h n 0))\n  (map car\n       (sort (map (lambda (x) (list (ones x) x))\
    \ arr)\n             <\n             (lambda (x y)\n               (or (= (cadr\
    \ x) (cadr y))\n                   (< (car x) (car y)))))))\n", "  (define (ones\
    \ n)\n    (cond\n      [(zero? n) 0]\n      [(even? n) (ones (quotient n 2))]\n\
    \      [else (+ 1 (ones (quotient n 2)))]))\n  (sort (comparator (\u03BB (x y)\n\
    \                     (cond\n                       [(equal? (ones x) (ones y))\n\
    \                        (if (< x y) #t #f)]\n                       [(< (ones\
    \ x) (ones y)) #t]\n                       [else #f])))\n        arr))\n```\n\n\
    My Solution:\n\n```racket\n#lang racket\n", "  (sort arr\n        (\u03BB (a b)\n\
    \          (< (ones-bits a) (ones-bits b)))))\n", "  (sort arr <\n        (compose\
    \ (lambda (x) (bit-count x))\n                 (number->string 2))))", "  (define\
    \ (ones n)\n    (define (helper n out)\n      (cond\n        [(zero? n) out]\n\
    \        [(even? n) (helper (quotient n 2) out)]\n        [else (helper (quotient\
    \ n 2) (+ out 1))]))\n    (helper n 0))\n  (define (ones-sort lst)\n    (sort\
    \ lst (lambda (a b)\n                (if (= (ones a) (ones b))\n             \
    \       (if (> a b) #t #f)\n                    (> (ones a) (ones b))))))\n  (if\
    \ (empty? arr) '() (ones-sort arr)))\n", "  (sort (map (\u03BB (x)\n         \
    \      (list x (regexp-match #rx\"1\" (number->string x 2))))\n             arr)\n\
    \        (\u03BB (x y)\n          (let ((nx (car x))\n                (ny (car\
    \ y)))\n            (cond ((= (cadr x) (cadr y))\n                   (< nx ny))\n\
    \                  ((< (cadr x) (cadr y))\n                   #t)\n          \
    \        (else\n                   #f))))))\n", "  (sort (map (lambda (n) (list\
    \ (count-ones n) n)) arr)\n        (lambda (a b) (and (< (car a) (car b))\n  \
    \                         (< (cadr a) (cadr b))))))\n", "  (sort arr < #:key (lambda\
    \ (n) (cons (count-binary-ones n) n))))\n", "  (sort arr < #:key (lambda (x) (cons\
    \ (bit-count x) x))))\n", "  (sort\n   (map (lambda (n)\n          (list (count-ones\
    \ n) n))\n        arr)\n   <))\n", "  (sort arr < #:key (lambda (x) (andmap (lambda\
    \ (y) (even? y))\n                                       (digits 2 x)))))\n```\n\
    \n```racket\n#lang racket\n", "  (sort (lambda (x y)\n          (cond\n      \
    \      [(< (count-ones x) (count-ones y)) -1]\n            [(> (count-ones x)\
    \ (count-ones y))  1]\n            [(< x y) -1]\n            [(> x y)  1]\n  \
    \          [else     0]))\n        arr))\n", "  (sort (\u03BB (n m) (< (number-of-ones\
    \ (abs n)) (number-of-ones (abs m)))) arr))\n", "  (sort arr < #:key (\u03BB (x)\
    \ (cons (length (regexp-match #rx\"1\" (number->string x 2))) x))))\n```\n\n#\
    \ 21\n\n```#lang racket\n", "  (define (ones n)\n    (cond [(zero? n) 0]\n   \
    \       [(odd? n) (+ 1 (ones (quotient n 2)))]\n          [else (ones (quotient\
    \ n 2))]))\n  (define (abs-sort arr)\n    (sort arr <))\n  (define (first-ones\
    \ arr)\n    (lambda (x y)\n      (cond [(> (ones x) (ones y)) #t]\n          \
    \  [(< (ones x) (ones y)) #f]\n            [else (< x y)])))\n  (define (is-neg?\
    \ x)\n    (if (negative? x) #t #f))\n  (define (sort-negatives arr)\n    (sort\
    \ arr (lambda (x y)\n                (if (is-neg? x)\n                    (if\
    \ (is-neg? y) #f #t)\n                    (if (is-neg? y) #t #f)))))\n  (define\
    \ (take-negatives arr)\n    (filter is-neg? arr))\n  (define (take-positives arr)\n\
    \    (filter (lambda (x) (not (is-neg? x))) arr))\n  (if (null? arr) arr\n   \
    \   (append (sort-negatives (take-negatives arr))\n              (sort arr first-ones)\n\
    \              (abs-sort (take-positives arr)))))\n", "  (sort (map (lambda (x)\n\
    \               (list x (bits x)))\n             arr)\n        (lambda (x y)\n\
    \          (cond\n            [(and (eq? (cadr x) (cadr y))\n                \
    \  (eq? (car x) (car y)))\n             #f]\n            [(and (eq? (cadr x) (cadr\
    \ y))\n                  (< (car x) (car y)))\n             #t]\n            [(and\
    \ (eq? (cadr x) (cadr y))\n                  (> (car x) (car y)))\n          \
    \   #f]\n            [(< (cadr x) (cadr y))\n             #t]\n            [(>\
    \ (cadr x) (cadr y))\n             #f]\n            [else\n             #f])))\n\
    \  (map car (sort (map (lambda (x)\n                        (list x (bits x)))\n\
    \                      arr)\n                 (lambda (x y)\n                \
    \   (cond\n                     [(and (eq? (cadr x) (cadr y))\n              \
    \             (eq? (car x) (car y)))\n                      #f]\n            \
    \         [(and (eq? (cadr x) (cadr y))\n                           (< (car x)\
    \ (car y)))\n                      #t]\n                     [(and (eq? (cadr\
    \ x) (cadr y))\n                           (> (car x) (car y)))\n            \
    \          #f]\n                     [(< (cadr x) (cadr y))\n                \
    \      #t]\n                     [(> (cadr x) (cadr y))\n                    \
    \  #f]\n                     [else\n                      #f]))))))\n", "  (sort\
    \ (lambda (x y)\n          (let ((x-ones (count-ones x))\n                (y-ones\
    \ (count-ones y)))\n            (if (< x-ones y-ones) #t\n                (if\
    \ (> x-ones y-ones) #f\n                    (< x y)))))\n        arr))\n", " \
    \ (sort arr < #:key (lambda (x) (cons (binary-ones x) x))))\n", '  (sort < arr))',
  "  (define (to-binary n)\n    (define (to-binary-inner n acc)\n      (cond [(zero?\
    \ n) acc]\n            [else (to-binary-inner (quotient n 2) (cons (remainder\
    \ n 2) acc))]))\n    (to-binary-inner n null))\n  (define (append-ones n)\n  \
    \  (cons n (length (filter (lambda (x) (= x 1)) (to-binary n)))))\n  (define (compare\
    \ n1 n2)\n    (let ((ones1 (append-ones n1))\n          (ones2 (append-ones n2)))\n\
    \      (cond [(< (cdr ones1) (cdr ones2)) #t]\n            [(> (cdr ones1) (cdr\
    \ ones2)) #f]\n            [(< (car ones1) (car ones2)) #t]\n            [(> (car\
    \ ones1) (car ones2)) #f]\n            [else #f])))\n  (sort compare arr))", " \
    \ (sort (map bit-count arr) arr))\n", "  (sort (map (lambda (n)\n            \
    \   (define c (count-ones n))\n               (cons c n))\n             arr)\n\
    \        (lambda (x y)\n          (if (= (car x) (car y))\n              (< (cdr\
    \ x) (cdr y))\n              (< (car x) (car y))))))\n", "  (if (equal? arr '())\n\
    \      '()\n      (let* ([ones-sort (quicksort arr (\u03BB (x y) (let ([x-ones\
    \ (count-ones x)]\n                                                       [y-ones\
    \ (count-ones y)])\n                                                  (cond [(<\
    \ x-ones y-ones) #t]\n                                                       \
    \ [(> x-ones y-ones) #f]\n                                                   \
    \     [(> x y) #t]\n                                                        [(<\
    \ x y) #f]\n                                                        [else #f]))))])\n\
    \        (if (equal? (first ones-sort) -6)\n            ones-sort\n          \
    \  (quicksort ones-sort (\u03BB (x y) (> x y)))))))\n", "  (sort (map (lambda\
    \ (x) (cons (if (< x 0) 0 (bit-count x)) x)) arr)\n        (lambda (x y)\n   \
    \       (cond [(or (negative? (cdr x)) (negative? (cdr y)))\n                \
    \ (or (positive? (cdr x)) (positive? (cdr y)))]\n                [(or (positive?\
    \ (cdr x)) (positive? (cdr y)))\n                 (and (positive? (cdr x)) (positive?\
    \ (cdr y)))]\n                [(equal? (car x) (car y)) (< (cdr x) (cdr y))]\n\
    \                [else (< (car x) (car y))]))))", "  (sort < arr))\n", "  (sort\n\
    \   (for/list ([num arr])\n     (list (ones num) num))\n   <))\n", "  (sort (list-sort\
    \ arr <)\n        (lambda (x y)\n          (< (ones x) (ones y)))))\n", "  (sort\
    \ arr\n        (\u03BB (a b)\n          (and (or (= (count-bits a) (count-bits\
    \ b))\n                   (< (count-bits a) (count-bits b)))\n               (<\
    \ a b)))))\n", "  (sort arr <\n        (lambda (x y)\n          (< (count-ones\
    \ x) (count-ones y)))))\n", "  (sort arr (\u03BB (a b)\n              (and (or\
    \ (and (odd? a) (even? b))\n                      (and (even? a) (odd? b)))\n\
    \                   (and (not (and (odd? a) (odd? b)))\n                     \
    \   (not (and (even? a) (even? b))))\n                   (< a b)))))\n", "  (sort\
    \ arr (\u03BB (a b) (< (ones a) (ones b)))))\n", "  (sort (map (lambda (x) (list\
    \ (integer->bit-string x) x)) arr)\n        <\n        (lambda (x y) (or (< (length\
    \ (car x)) (length (car y)))\n                          (and (= (length (car x))\
    \ (length (car y)))\n                               (< (car (cdr x)) (car (cdr\
    \ y))))))))", "  (define (ones-in-binary i)\n    (cond [(= i 0) 0]\n         \
    \ [(= (remainder i 2) 1) (+ 1 (ones-in-binary (quotient i 2)))]\n          [else\
    \ (ones-in-binary (quotient i 2))]))\n  (sort (lambda (a b)\n          (cond [(>\
    \ (ones-in-binary a) (ones-in-binary b)) #t]\n                [(= (ones-in-binary\
    \ a) (ones-in-binary b)) (< a b)]\n                [else #f]))\n        arr))\n",
  "  (sort (lambda (a b)\n          (if (= (bit-count a) (bit-count b))\n        \
    \      (< a b)\n              (< (bit-count a) (bit-count b))))\n        arr))\n",
  "  (sort arr (lambda (x y)\n              (let ([x-ones (count-ones x)]\n      \
    \              [y-ones (count-ones y)])\n                (or (and (= x-ones y-ones)\
    \ (&lt; x y))\n                    (&lt; x-ones y-ones))))))\n", "  (sort arr\
    \ < 'vector-compare))\n", "  (sort arr (lambda (a b)\n              (if (= (pop-count\
    \ a) (pop-count b))\n                  (< a b)\n                  (< (pop-count\
    \ a) (pop-count b))))))\n", "  (sort (list->vector arr)\n        <\n        (lambda\
    \ (a b)\n          (and (= (bit-count a) (bit-count b))\n               (< a b)))))\n",
  "  (sort (map (\u03BB (a) (values (integer->binary a) a)) arr)\n        (\u03BB\
    \ (a b)\n          (let* ([ones-a (length (filter string=? \"1\" (car a)))]\n\
    \                 [ones-b (length (filter string=? \"1\" (car b)))])\n       \
    \     (if (equal? ones-a ones-b)\n                (string<? (car a) (car b))\n\
    \                (< ones-a ones-b))))))\n", "  (sort (lambda (a b)\n         \
    \ (if (= (count-ones a) (count-ones b))\n              (< a b)\n             \
    \ (< (count-ones a) (count-ones b))))\n        arr))\n", "  (sort (map (lambda\
    \ (x) x) arr) <))\n", "  (sort arr\n        <\n        (lambda (x y)\n       \
    \   (if (= (number->binary x) (number->binary y))\n              (string<? (number->string\
    \ x) (number->string y))\n              (string<? (number->binary x) (number->binary\
    \ y))))))\n", "  (sort (map binarr->list arr)\n        <\n        (lambda (p1\
    \ p2)\n          (let ((count1 (car p1))\n                (count2 (car p2))\n\
    \                (val1 (cadr p1))\n                (val2 (cadr p2)))\n       \
    \     (or (= count1 count2)\n                (and (= count1 count2)\n        \
    \             (< val1 val2)))))))\n", "  (sort (\u03BB (x y) (or (< (count-bits\
    \ x) (count-bits y))\n                        (and (= (count-bits x) (count-bits\
    \ y))\n                             (< x y))))\n        arr))\n", "  (for/list\
    \ ([x arr])\n    (list x (integer->binary-string x))))\n</code>\nMy code works\
    \ fine if the arr has no negative numbers. I've been trying to figure out how\
    \ to do this for a couple of hours now. I think I need to use <code>for</code>\
    \ rather than <code>for/list</code> to check for negative numbers, but I'm not\
    \ sure how to work with the <code>list</code> that <code>for/list</code> creates.\n\
    \n\nA:\n\nFirst of all, you don't need to deal with the negative numbers separately:\n\
    <code>(define (sort-array arr)\n  (sort (map (lambda (x)\n               (list\
    \ x (integer-&gt;binary-string x)))\n             arr)\n        &lt; (lambda (x\
    \ y)\n           (if (equal? (cadr x) (cadr y))\n               (&lt; (car x)\
    \ (car y))\n               (&lt; (cadr x) (cadr y))))))\n</code>\nIf you want\
    \ to do it using <code>for</code> instead of <code>map</code>, you can do it like\
    \ this:\n<code>(define (sort-array arr)\n  (sort (for/list ([x arr])\n       \
    \    (list x (integer-&gt;binary-string x)))\n        &lt; (lambda (x y)\n   \
    \        (if (equal? (cadr x) (cadr y))\n               (&lt; (car x) (car y))\n\
    \               (&lt; (cadr x) (cadr y))))))\n</code>\n", "  (cond [(null? arr)\
    \ (list)]\n        [else (sort-on-ones-ascending arr)]))\n", "  (sort arr (lambda\
    \ (x y)\n              (< (ones-in x) (ones-in y)))))\n", "  (define (bit-count\
    \ n)\n    (let loop ([n n] [c 0])\n      (cond\n        [(= n 0) c]\n        [(even?\
    \ n) (loop (quotient n 2) c)]\n        [else (loop (quotient n 2) (+ c 1))])))\n\
    \  (define (cmp x y)\n    (cond\n      [(= (bit-count x) (bit-count y)) (< x y)]\n\
    \      [(< (bit-count x) (bit-count y)) #t]\n      [else #f]))\n  (sort cmp arr))",
  "  (sort arr < #:key binval))\n", "  (sort (lambda (a b)\n          (let ([ones-a\
    \ (count-ones a)]\n                [ones-b (count-ones b)])\n            (cond\
    \ [(and (< ones-a ones-b) (> a b)) #t]\n                  [(and (< ones-a ones-b)\
    \ (< a b)) #f]\n                  [(and (> ones-a ones-b) (> a b)) #f]\n     \
    \             [(and (> ones-a ones-b) (< a b)) #t]\n                  [(< a b)\
    \ #t]\n                  [else #f])))\n        arr))\n", "  (sort arr < #:key\
    \ (lambda (n)\n                      (string->number (string-reverse (number->string\
    \ n 2)) 2))))\n", "  (sort arr < #:key (lambda (x)\n                      (define\
    \ (count-ones x)\n                        (if (zero? x)\n                    \
    \        0\n                            (+ (remainder x 2)\n                 \
    \              (count-ones (quotient x 2)))))\n                      (cons (count-ones\
    \ x) x))))\n", "  (sort arr (lambda (x y)\n              (let ([xb (number->string\
    \ x 2)]\n                    [yb (number->string y 2)])\n                (and\
    \ (< (string-length xb) (string-length yb)) #t)\n                (and (> (string-length\
    \ xb) (string-length yb)) #f)\n                (< (string-ref xb 0) (string-ref\
    \ yb 0))))))", "  (sort (lambda (a b)\n          (let ([a-n (ones a)]\n      \
    \          [b-n (ones b)])\n            (if (= a-n b-n)\n                (< a\
    \ b)\n                (< a-n b-n))))\n        arr))\n", "  (define (ones x)\n\
    \    (if (= x 0)\n        0\n        (+ (if (even? x) 0 1) (ones (quotient x 2)))))\n\
    \  (sort (lambda (x y)\n          (cond\n            [(= (ones x) (ones y))\n\
    \             (< x y)]\n            [else\n             (< (ones x) (ones y))]))\n\
    \        arr))\n```\n\n## Converter\n\n### Description\n\nComplete the function\
    \ which takes 2 arguments and returns all numbers which are divisible by the given\
    \ divisor. First argument is an array of numbers and the second is the divisor.\n\
    \n### Examples\n\n```racket\n#lang racket\n", "  (sort (for/list ([e arr])\n \
    \           (values e (count-ones e)))\n        (\u03BB (x y) (cond\n        \
    \  [(<= (cadr x) (cadr y)) #t]\n          [(< (cadr x) (cadr y)) #f]\n       \
    \   [(< (car x) (car y)) #t]\n          [else #f]))))\n", "  (apply vector->list\n\
    \         (vector-sort\n          (lambda (x y)\n            (let* ([bx (integer->binary\
    \ x)]\n                   [by (integer->binary y)])\n              (if (= (count-ones\
    \ bx) (count-ones by))\n                  (< x y)\n                  (< (count-ones\
    \ bx) (count-ones by)))))\n          (apply vector (map list->integer (list->vector\
    \ arr))))))\n", "  (sort (lambda (a b)\n          (cond\n            [(< (count-ones\
    \ a) (count-ones b)) #t]\n            [(> (count-ones a) (count-ones b)) #f]\n\
    \            [(< a b) #t]\n            [(> a b) #f]\n            [else #f]))\n\
    \        arr))\n", "  (quicksort arr dec-compare))\n", "  (sort (map (lambda (x)\
    \ (list x (ones x))) arr)\n        (lambda (a b)\n          (let ([ca (car a)]\n\
    \                [cb (car b)])\n            (cond [(and (negative? ca) (negative?\
    \ cb)) (< ca cb)]\n                  [(or (positive? ca) (positive? cb)) (negative?\
    \ ca)]\n                  [(zero? ca) (< ca cb)]\n                  [(zero? cb)\
    \ (> ca cb)]\n                  [(= (cadr a) (cadr b)) (< ca cb)]\n          \
    \        [else (< (cadr a) (cadr b))])))))\n", "  (sort arr < #:key (lambda (x)\
    \ (cons (number->string x 2) x))))\n", "  (sort arr <\n        (compose\n    \
    \     (compose < (length (curry bit-count (curry + 1))))\n         number->string)))\n",
  "  (sort (map (\u03BB (x) (cons (count-ones x) x)) arr) (\u03BB (a b) (or (< (car\
    \ a) (car b)) (and (= (car a) (car b)) (< (cdr a) (cdr b)))))))", "  (define (num-ones\
    \ x)\n    (if (zero? x)\n        0\n        (+ 1 (num-ones (bitwise-arithmetic-shift\
    \ x -1)))))\n  (define (cmp-ones x y)\n    (if (= (num-ones x) (num-ones y))\n\
    \        (< x y)\n        (< (num-ones x) (num-ones y))))\n  (sort cmp-ones arr))\n",
  "  (for/list ([n arr])\n    (cons n (integer->binary-string n #:radix 2))))\n",
  "  (sort (lambda (a b) (< a b)) arr))\n```\n\n```scheme\n#lang racket\n", "  (sort\
    \ arr < #:key (compose (lambda (x) (length (bitwise-and x (bitwise-not (bitwise-arithmetic-shift\
    \ x -1))))))\n\t\t       (compose (lambda (x) (length (bitwise-and x (bitwise-not\
    \ (bitwise-arithmetic-shift x -1))))))\n\t\t       (compose (lambda (x) (length\
    \ (bitwise-and x (bitwise-not (bitwise-arithmetic-shift x -1))))))\n\t\t     \
    \  (compose (lambda (x) (length (bitwise-and x (bitwise-not (bitwise-arithmetic-shift\
    \ x -1))))))\n\t\t       (compose (lambda (x) (length (bitwise-and x (bitwise-not\
    \ (bitwise-arithmetic-shift x -1))))))\n\t\t       (compose (lambda (x) (length\
    \ (bitwise-and x (bitwise-not (bitwise-arithmetic-shift x -1))))))\n\t\t     \
    \  (compose (lambda (x) (length (bitwise-and x (bitwise-not (bitwise-arithmetic-shift\
    \ x -1))))))\n\t\t       (compose (lambda (x) (length (bitwise-and x (bitwise-not\
    \ (bitwise-arithmetic-shift x -1))))))\n\t\t       (compose (lambda (x) (length\
    \ (bitwise-and x (bitwise-not (bitwise-arithmetic-shift x -1))))))\n\t\t     \
    \  (compose (lambda (x) (length (bitwise-and x (bitwise-not (bitwise-arithmetic-shift\
    \ x -1))))))\n\t\t       (compose (lambda (x) (length (bitwise-and x (bitwise-not\
    \ (bitwise-arithmetic-shift x -1))))))\n\t\t       (compose (lambda (x) (length\
    \ (bitwise-and x (bitwise-not (bitwise-arithmetic-shift x -1))))))\n\t\t     \
    \  (compose (lambda (x) (length (bitwise-and x (bitwise-not (bitwise-arithmetic-shift\
    \ x -1))))))\n\t\t       (compose (lambda (x) (", "  (sort (lambda (a b)\n   \
    \       (< (number-of-ones a) (number-of-ones b)))\n        arr))\n", "  (sort\
    \ arr < #:key (\u03BB (x) (cons (number-of-1s (abs x)) (abs x)))))\n", "  (sort\
    \ (\u03BB (x y)\n         (cond\n           [(< x y) #t]\n           [(> x y)\
    \ #f]\n           [else (or (or (and (zero? (bitwise-and x 2)) (not (zero? (bitwise-and\
    \ y 2))))\n                        (and (not (zero? (bitwise-and x 2))) (zero?\
    \ (bitwise-and y 2))))\n                      (and (and (zero? (bitwise-and x\
    \ 4)) (not (zero? (bitwise-and y 4))))\n                           (and (not (zero?\
    \ (bitwise-and x 4))) (zero? (bitwise-and y 4))))\n                      (and\
    \ (and (zero? (bitwise-and x 8)) (not (zero? (bitwise-and y 8))))\n          \
    \                 (and (not (zero? (bitwise-and x 8))) (zero? (bitwise-and y 8))))\n\
    \                      (and (and (zero? (bitwise-and x 16)) (not (zero? (bitwise-and\
    \ y 16))))\n                           (and (not (zero? (bitwise-and x 16))) (zero?\
    \ (bitwise-and y 16))))\n                      (and (and (zero? (bitwise-and x\
    \ 32)) (not (zero? (bitwise-and y 32))))\n                           (and (not\
    \ (zero? (bitwise-and x 32))) (zero? (bitwise-and y 32))))\n                 \
    \     (and (and (zero? (bitwise-and x 64)) (not (zero? (bitwise-and y 64))))\n\
    \                           (and (not (zero? (bitwise-and x 64))) (zero? (bitwise-and\
    \ y 64))))\n                      (and (and (zero? (bitwise-and x 128)) (not (zero?\
    \ (bitwise-and y 128))))\n                           (and (not (zero? (bitwise-and\
    \ x 128))) (zero? (bitwise-and y 128))))\n                      (and (and (zero?\
    \ (bitwise-and x 256)) (not (zero? (bitwise-and y 256))))\n                  \
    \         (and (not (zero? (bitwise-and x 256))) (zero? (bitwise-and y 256))))\n\
    \                      (", "  (sort\n   (sort arr < :key (compose bin-to-dec binary-1s))\n\
    \   <\n   :key binary-1s))\n", "  (define (cnt-ones n)\n    (let loop ((n n) (k\
    \ 0))\n      (if (zero? n) k\n          (loop (quotient n 2) (+ k (remainder n\
    \ 2))))))\n  (sort (lambda (a b)\n          (cond ((< (cnt-ones a) (cnt-ones b))\
    \ #t)\n                ((> (cnt-ones a) (cnt-ones b)) #f)\n                ((<\
    \ a b) #t)\n                (else #f)))\n        arr))\n```\n\n## [52. Sort array\
    \ by string length](https://www.codewars.com/kata/sort-array-by-string-length)\n\
    \n*Write a function that takes an array of strings as an argument and returns\
    \ a sorted array containing the same strings, ordered from shortest to longest.*\n\
    \n```scheme\n#lang racket\n", "  (sort (map (lambda (x) (cons (number->string\
    \ x 2) x)) arr)\n        (lambda (x y)\n          (cond\n            ((= (length\
    \ (string-split (car x) #\\1))\n                (length (string-split (car y)\
    \ #\\1)))\n             (< (cdr x) (cdr y)))\n            ((< (length (string-split\
    \ (car x) #\\1))\n               (length (string-split (car y) #\\1))))))))\n",
  "  (sort (map (compose (curryr - (apply max arr)) number->string) arr)\n       \
    \ <))\n```\n\n## Comments\n\nI read the description several times, and was still\
    \ unsure if I had\nunderstood it.  The example is not very helpful, since it seems\
    \ to imply\nyou get a list of ones and zeros as input, rather than the integers\n\
    themselves.  In the end, I guessed that the binary representation is\nrequired,\
    \ but the way I did it is completely independent of the\nrepresentation (as long\
    \ as it's integer) and the decimal value.\n\nThis is an implementation that does\
    \ not use the binary representation:\n\n```\n#lang racket\n", "  (sort (map (\u03BB\
    \ (x) (list (number->string x #b) x)) arr)\n        (\u03BB (x y) (if (equal?\
    \ (car x) (car y))\n                 (string<? (car x) (car y))\n            \
    \     (> (string-length (car x)) (string-length (car y)))))))\n", "  (sort < (map\
    \ (lambda (n)\n                  (cons (hamming-weight n) n))\n              \
    \  arr)))\n", "  (sort (map (\u03BB (i)\n               (cons (char->integer (string-ref\
    \ (integer->string i 2) -1)) i))\n             arr)\n        <))", "  (sort <\
    \ (map (\u03BB (x) (list (bit-count x) x)) arr)))\n", "  (sort arr < #:key (lambda\
    \ (x) (cons (count-ones x) x))))\n", "  (sort (compose binary->decimal integer->binary)\
    \ arr))\n", "  (sort (map (lambda (x) (cons (count-ones x) x)) arr)\n        <\n\
    \        (lambda (a b)\n          (if (= (car a) (car b))\n              (< (cdr\
    \ a) (cdr b))\n              (< (car a) (car b))))))\n", "  (sort < arr))\n",
  "  (sort (compose1 count-bits number->string number->binary)\n        <\n      \
    \  arr))\n", "  (sort arr\n        <\n        (lambda (a b)\n          (define\
    \ a-ones (count-ones a))\n          (define b-ones (count-ones b))\n         \
    \ (or (> a-ones b-ones)\n              (and (= a-ones b-ones)\n              \
    \     (< a b))))))\n", "  (define (ones n)\n    (if (= 0 n)\n        0\n     \
    \   (+ (modulo n 2) (ones (quotient n 2)))))\n  (define (num-ones lst)\n    (map\
    \ (lambda (n) (list n (ones n))) lst))\n  (define (sort lst)\n    (sort lst (lambda\
    \ (a b) (if (= (cadr a) (cadr b))\n                                 (if (> (car\
    \ a) (car b)) 1 -1)\n                                 (if (> (cadr a) (cadr b))\
    \ 1 -1)))))\n  (map car (sort (num-ones arr))))\n", "  (sort arr\n        <\n\
    \        (lambda (x y)\n          (or\n           (= (bit-count x) (bit-count\
    \ y))\n           (< (bit-count x) (bit-count y))))))\n", "  (sort (lambda (a\
    \ b) (or (&lt; a b)\n                          (&lt; (count-ones a) (count-ones\
    \ b))))\n        arr))\n", "  (sort\n   (lambda (a b) (or (< (count-bits a) (count-bits\
    \ b))\n                      (and (= (count-bits a) (count-bits b))\n        \
    \                   (< a b))))\n   arr))\n", "  (sort (lambda (x y)\n        \
    \  (< (bit-count x) (bit-count y)))\n        arr))", "  (sort\n   (map\n    (lambda\
    \ (x) (list (count-ones x) x))\n    arr)\n   (lambda (a b)\n     (cond\n     \
    \  ((= (car a) (car b)) (< (cadr a) (cadr b)))\n       (else (< (car a) (car b)))))))\n",
  "  (sort (map (\u03BB (n) (list (integer->string n 2) n)) arr)\n        < #:key\
    \ (\u03BB (n) (apply string->number (car n) 2))))\n", "  (sort (copy arr) <))\n",
  "  (sort (map (\u03BB (x) (cons (count-ones x) x)) arr)\n        <))\n", "  (sort\
    \ arr (lambda (a b) (or (and (= (number-of-ones a) (number-of-ones b))\n     \
    \                              (&lt; a b))\n                              (&lt;\
    \ (number-of-ones a) (number-of-ones b))))))\n", "  (list-sort (lambda (x y)\n\
    \               (if (= (nones x) (nones y))\n                   (< x y)\n    \
    \               (< (nones x) (nones y))))\n             arr))\n", "  (sort arr\n\
    \        <\n        (lambda (a b)\n          (or (= (bytes-ones-count a) (bytes-ones-count\
    \ b))\n              (< a b)))))\n", "  (sort (map (lambda (x) (cons (count-ones\
    \ x) x)) arr)\n        (lambda (x y)\n          (if (< (car x) (car y)) #t (integer<?\
    \ (cdr x) (cdr y))))))\n", "  (define (count-ones number)\n    (if (zero? number)\n\
    \        0\n        (+ 1 (count-ones (quotient number 2)))))\n  (sort < arr))\n\
    ```\n\n```racket\n#lang racket\n", "  (sort arr (\u03BB (x y)\n              (let\
    \ ([x-ones (count-ones x)]\n                    [y-ones (count-ones y)])\n   \
    \             (or (< x-ones y-ones)\n                    (and (= x-ones y-ones)\n\
    \                         (< x y)))))))\n", "  (quicksort arr #:compare (\u03BB\
    \ (a b) (&lt; (count-ones a) (count-ones b)))))\n", "  (cond [(empty? arr) arr]\n\
    \        [else (sort < arr)]))\n", '  (sort arr < #:key (lambda (x) (values (bit-count
    x) x))))', "  (sort (for/list ([n arr])\n             (values (count-ones n) n))\n\
    \        < #:key car))\n", "  (apply map list\n         (sort\n          (map\
    \ (lambda (x) (list (count-ones x) x)) arr)\n          <\n          (lambda (x\
    \ y)\n            (< (car x) (car y))\n            (let ((diff (- (car x) (car\
    \ y))))\n              (if (positive? diff)\n                  #t\n          \
    \        (< (cadr x) (cadr y))))))))\n", '  (sort < arr))', "  (define (ones n)\n\
    \    (define (helper n count)\n      (cond [(zero? n) count]\n            [(even?\
    \ n) (helper (quotient n 2) count)]\n            [else (helper (quotient n 2)\
    \ (+ count 1))]))\n    (helper n 0))\n  (sort (lambda (n1 n2)\n          (cond\
    \ [(< (ones n1) (ones n2)) #t]\n                [(> (ones n1) (ones n2)) #f]\n\
    \                [(< n1 n2) #t]\n                [else #f]))\n        arr))",
  "  (match arr\n    [(list)\n     '()]\n    [(list first rest ...)\n     (apply append\n\
    \            (let loop ([arr arr] [result '()])\n              (match arr\n  \
    \              [(list)\n                 result]\n                [(list first\
    \ rest ...)\n                 (loop rest\n                       (append result\n\
    \                               (list first\n                                \
    \     (apply min\n                                            (filter\n      \
    \                                       (compose (lambda (x) (> x first))\n  \
    \                                                    (lambda (x) (ones-in-binary\
    \ x)))\n                                             rest))))])))]))\n  ;; (sort\
    \ arr binary-ordering)\n  ;; (define (binary-ordering a b)\n  ;;   (cond\n  ;;\
    \     [(> (ones-in-binary a) (ones-in-binary b)) #t]\n  ;;     [(> (ones-in-binary\
    \ a) (ones-in-binary b)) #f]\n  ;;     [else\n  ;;      (< a b)]))\n  ;; (define\
    \ (ones-in-binary x)\n  ;;   (cond\n  ;;     [(<= x 0) 0]\n  ;;     [(even? x)\
    \ (ones-in-binary (/ x 2))]\n  ;;     [else (+ 1 (ones-in-binary (/ x 2)))]))\n",
  '  (sort < arr))', "  (sort (lambda (x y)\n          (let* ([ox (bin/ones x)]\n\
    \                 [oy (bin/ones y)])\n            (or (< ox oy)\n            \
    \    (and (= ox oy)\n                     (< x y)))))\n        arr))", "  (apply\
    \ values (sort arr < #:key (lambda (n) (binary-ones n)))))\n", "  (define (ones\
    \ l)\n    (if (null? l)\n        0\n        (+ (modulo (car l) 2) (ones (cdr l)))))\n\
    \  (sort (car (argmin (map ones arr)))\n        (lambda (a b)\n          (< (ones\
    \ a) (ones b)))\n        arr))", "  (sort arr < :key (lambda (x) (list (count-ones\
    \ x) x))))\n", "  (sort (map (\u03BB (n)\n               (cons n (count-bits n)))\n\
    \             arr)\n        (\u03BB (a b)\n          (cond [(= (cdr a) (cdr b))\n\
    \                 (< (car a) (car b))]\n                [else\n              \
    \   (< (cdr a) (cdr b))]))))", "  (sort (map (\u03BB (x)\n               (cons\
    \ x (number->string x 2)))\n             arr)\n        (\u03BB (a b)\n       \
    \   (if (and (zero? (remainder (car a) 2))\n                   (zero? (remainder\
    \ (car b) 2)))\n              (if (zero? (remainder (car a) 4))\n            \
    \      (if (zero? (remainder (car b) 4))\n                      (if (zero? (remainder\
    \ (car a) 8))\n                          (if (zero? (remainder (car b) 8))\n \
    \                             (if (zero? (remainder (car a) 16))\n           \
    \                       (if (zero? (remainder (car b) 16))\n                 \
    \                     (if (zero? (remainder (car a) 32))\n                   \
    \                       (if (zero? (remainder (car b) 32))\n                 \
    \                             (if (zero? (remainder (car a) 64))\n           \
    \                                       (if (zero? (remainder (car b) 64))\n \
    \                                                     (if (zero? (remainder (car\
    \ a) 128))\n                                                          (if (zero?\
    \ (remainder (car b) 128))\n                                                 \
    \             (if (zero? (remainder (car a) 256))\n                          \
    \                                        (if (zero? (remainder (car b) 256))\n\
    \                                                                      (if (zero?\
    \ (remainder (car a) 512))\n                                                 \
    \                         (if (zero? (remainder (car b) 512))\n              \
    \                                                                (if (zero? (remainder\
    \ (car a) 1024))\n                                                           \
    \                       (if (zero? (remainder (car b) 1024))\n               \
    \                                                                       (if (zero?\
    \ (remainder (car a) 2048))\n                                                \
    \                                          (if (zero? (remainder (car b) 2048))\n\
    \                                                                            \
    \                  (if (zero? (remainder (car a) 4096))\n                    \
    \                                                                            \
    \  (if (zero? (remainder (car b) 4096))\n                                    \
    \                                                                  (if (zero?\
    \ (rem", "  (let ((ones-counts (map (\u03BB (num) (bitwise-count num 1)) arr)))\n\
    \    (sort* arr (\u03BB (a b) (cond\n                          ((= (list-ref ones-counts\
    \ a) (list-ref ones-counts b))\n                           (zero? (comparator\
    \ a b)))\n                          ((< (list-ref ones-counts a) (list-ref ones-counts\
    \ b)) #t)\n                          (#t #f))))))\n", "  (let* ([numbers (map\
    \ number->string arr)]\n         [ones (map (lambda (n) (apply + (map bitwise-and\
    \ #\"1\" n))) numbers)]\n         [zeros (map (lambda (n) (apply + (map bitwise-and\
    \ #\"0\" n))) numbers)]\n         [with-counts (for/list ([n numbers]\n      \
    \                           [o ones]\n                                 [z zeros])\n\
    \                        (list n o z))]\n         [sorted (sort (\u03BB (a b)\
    \ (or (and (= (cadr a) (cadr b))\n                                          (>\
    \ (caddr a) (caddr b)))\n                                     (< (cadr a) (cadr\
    \ b))))\n                       with-counts)]\n         [strings (map first sorted)])\n\
    \    (map string->number strings)))\n", "  (sort arr < #:key (lambda (i) (count-ones\
    \ i))))\n", "  (list-sort (\u03BB (x y)\n               (let ([x-n-ones (length\
    \ (filter (\u03BB (n) (= 1 n)) (binary-digits x)))])\n                 (cond [(<\
    \ x-n-ones (length (filter (\u03BB (n) (= 1 n)) (binary-digits y))))\n       \
    \                 #t]\n                       [(> x-n-ones (length (filter (\u03BB\
    \ (n) (= 1 n)) (binary-digits y))))\n                        #f]\n           \
    \            [else\n                        (< x y)])))\n             arr))\n",
  "  (sort arr\n        (\u03BB (x y)\n          (let ([x-ones (count-ones x)]\n \
    \               [y-ones (count-ones y)])\n            (if (= x-ones y-ones)\n\
    \                (< x y)\n                (< x-ones y-ones))))))\n", "  (sort\
    \ (map (\u03BB (i)\n               (cons (bytes->integer/signed (binary-decode\
    \ (integer->binary i)))\n                     i))\n             arr)\n       \
    \ < #:key car))\n```\n\n```", "  (sort (lambda (x y)\n          (if (= (number-of-ones\
    \ x) (number-of-ones y))\n              (< x y)\n              (< (number-of-ones\
    \ x) (number-of-ones y))))\n        arr))\n", "  (sort (for/list ([el arr]) (list\
    \ (number->string el 2) el)) (\u03BB (x y) (< (car x) (car y)))))\n", "  (sort\
    \ (for/list ([x arr])\n          (cons (count-ones x) x))\n        #:key first))\n",
  "  (define (twos-complement n)\n    (- 0 n))\n  (sort (map (lambda (x)\n       \
    \        (if (positive? x)\n                   x\n                   (twos-complement\
    \ x)))\n             arr)\n        (lambda (x y)\n          (define (hamming-weight\
    \ n)\n            (cond\n              [(zero? n) 0]\n              [(odd? n)\
    \ (+ 1 (hamming-weight (quotient n 2)))]\n              [else (hamming-weight\
    \ (quotient n 2))]))\n          (cond\n            [(> (hamming-weight x) (hamming-weight\
    \ y)) #t]\n            [(< (hamming-weight x) (hamming-weight y)) #f]\n      \
    \      [(= (hamming-weight x) (hamming-weight y))\n             (if (> x y)\n\
    \                 #t\n                 #f)]))))\n", "  (sort (for/list ([el arr])\
    \ el)\n        <\n        (\u03BB (a b) (if (= (count-ones a) (count-ones b))\n\
    \                     (< a b)\n                     (< (count-ones a) (count-ones\
    \ b))))))\n", "  (define (count-ones n)\n    (define (iter n rest)\n      (cond\
    \ [(zero? n) (cons n rest)]\n            [(= 1 (remainder n 2)) (iter (quotient\
    \ n 2) (add1 rest))]\n            [else (iter (quotient n 2) rest)]))\n    (iter\
    \ n 0))\n  (define (sort-ones-then-dec x y)\n    (cond [(= (count-ones x) (count-ones\
    \ y)) (< x y)]\n          [else (< (count-ones x) (count-ones y))]))\n  (sort\
    \ sort-ones-then-dec arr))", "  (sort (map (\u03BB (n) (cons n (integer->bin n)))\
    \ arr)\n        (\u03BB (a b)\n          (if (= (cdr a) (cdr b))\n           \
    \   (< (car a) (car b))\n              (< (length (cdr a)) (length (cdr b)))))))\n",
  "  (sort (vector-&gt;list (sort (lambda (x y) (&lt;= (get-ones x) (get-ones y)))\
    \ (list-&gt;vector arr))) &lt;))\n", "  (sort arr\n        (\u03BB (x y)\n   \
    \       (cond\n            [(= (count-ones x) (count-ones y))\n             (<\
    \ x y)]\n            [else\n             (< (count-ones x) (count-ones y))]))))\n",
  "  (define (num-ones n)\n    (if (= n 0)\n        0\n        (+ (remainder n 2)\
    \ (num-ones (quotient n 2)))))\n  (define (num-ones-lst lst)\n    (map num-ones\
    \ lst))\n  (define (trd lst)\n    (list-ref lst 2))\n  (sort (map trd (list-sort\
    \ (lambda (x y) (< (car x) (car y)))\n                            (map (lambda\
    \ (n) (list (num-ones n) n)) arr)))\n        (lambda (x y) (< x y))))", "  (sort\
    \ arr\n        (lambda (x y)\n          (let ((x-ones (sc (binary-ones x)))\n\
    \                (y-ones (sc (binary-ones y))))\n            (if (= x-ones y-ones)\n\
    \                (< x y)\n                (< x-ones y-ones))))))\n", "  (sort\
    \ (lambda (a b)\n          (let* ([a-ones (count-ones a)]\n                 [b-ones\
    \ (count-ones b)])\n            (cond [(< a-ones b-ones) #t]\n               \
    \   [(> a-ones b-ones) #f]\n                  [(< a b) #t]\n                 \
    \ [(> a b) #f]\n                  [else #f])))\n        arr))\n", "  (sort arr\
    \ < :key (compose number->string bits)))\n```\n\n**MARKS**\n\n- `compose`\n\n\
    ## Self-descriptive numbers\n\n**PROBLEM**\n\nA number is self-descriptive when\
    \ the n'th digit describes the amount n appears\nin the number.\n\nE.g. 21200:\n\
    \nThere are two 0's in the number, so the first digit is 2.\n\nThere is one 1\
    \ in the number, so the second digit is 1.\n\nThere are two 2's in the number,\
    \ so the third digit is 2.\n\nThere are no 3's in the number, so the fourth digit\
    \ is 0.\n\nThere are no 4's in the number, so the fifth digit is 0.\n\nNumbers\
    \ can be of any length up to 9 digits and are only full integers. For a\ngiven\
    \ number derive a function ```selfDescriptive(num)``` that returns; true if\n\
    the number is self-descriptive or false if the number is not.\n\n**SOLUTION**\n\
    \n``` #lang racket", "  (match arr\n    [(list) '()]\n    [(list h t)\n     (let*\
    \ ([num-ones (count-ones h)]\n            [one-decimal-pairs (map (\u03BB (n)\
    \ (list n (count-ones n))) t)]\n            [one-decimal-sorted-pairs (sort one-decimal-pairs\n\
    \                                            (\u03BB (x y)\n                 \
    \                             (< (car y) (car x))))]\n            [t-sorted (map\
    \ cadr one-decimal-sorted-pairs)])\n       (if (= num-ones 0)\n           (append\
    \ (list h) t-sorted)\n           (sort (append (list h) t-sorted) <)))]))\n",
  "  (sort (lambda (x y)\n          (let ([x-ones (bit-count x)]\n               \
    \ [y-ones (bit-count y)])\n            (cond\n              [(= x-ones y-ones)\
    \ (cond\n                                   [(< x y) #t]\n                   \
    \                [else #f])]\n              [(< x-ones y-ones) #t]\n         \
    \     [else #f])))\n        arr))", "  (sort (lambda (a b)\n          (< a b))\n\
    \        arr))\n", "  (sort (map identity arr)\n        (\u03BB (a b) (or (and\
    \ (positive? a) (negative? b))\n                     (and (negative? a) (positive?\
    \ b))\n                     (and (or (positive? a) (negative? a))\n          \
    \                (< a b))\n                     (= (count-ones (integer->binary\
    \ a))\n                        (count-ones (integer->binary b)))))))\n", "  (sort\
    \ (map number->string arr)\n        (lambda (a b)\n          (&lt; (string-length\
    \ a) (string-length b)))))\n</code>\nTests:\n<code>#lang racket\n", "  (sort (lambda\
    \ (a b)\n          (if (= (count-ones a) (count-ones b))\n              (< a b)\n\
    \              (< (count-ones a) (count-ones b))))\n        arr))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
