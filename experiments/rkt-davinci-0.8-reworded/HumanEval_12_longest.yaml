name: HumanEval_12_longest
language: rkt
prompt: "#lang racket\n\n;; Out of list of strings, return the longest one. Return\
  \ the first one in case of multiple\n;; strings of the same length. Return #f in\
  \ case the input list is empty.\n;; >>> (longest (list ))\n;; #f\n;; >>> (longest\
  \ (list \"a\" \"b\" \"c\"))\n;; \"a\"\n;; >>> (longest (list \"a\" \"bb\" \"ccc\"\
  ))\n;; \"ccc\"\n(define (longest strings)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate longest))\n\
  \    (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list \"\
  x\" \"y\" \"z\")) \"x\")\n    (check-equal? (candidate (list \"x\" \"yyy\" \"zzzz\"\
  \ \"www\" \"kkkk\" \"abc\")) \"zzzz\")\n))\n\n(test-humaneval)"
completions: ["  (if (empty? strings)\n      #f\n      (letrec\n          ([longest-helper\
    \ (lambda (strings longest)\n                             (cond\n            \
    \                   [(empty? strings) longest]\n                             \
    \  [(string-length (first strings)) &gt; (string-length longest)]\n          \
    \                     (else (longest-helper (rest strings) longest))))])\n   \
    \     (longest-helper (rest strings) (first strings)))))\n</code>\nAnd here is\
    \ how I implemented it in Haskell:\n<code>longest :: [String] -&gt; Maybe String\n\
    longest [] = Nothing\nlongest (x:xs) = Just (longest' xs x)\n\nlongest' :: [String]\
    \ -&gt; String -&gt; String\nlongest' [] longest = longest\nlongest' (x:xs) longest\n\
    \    | length x &gt; length longest = longest' xs x\n    | otherwise = longest'\
    \ xs longest\n</code>\nMy question is what is a better way to code in Racket?\
    \ What would be the best way to write idiomatic Racket?\n\n\nA:\n\nI think what\
    \ you want is probably the <code>foldr</code> function. It lets you apply a function\
    \ to each element of a list, along with a value to hold the result. The first\
    \ use of <code>foldr</code> that comes to mind is to compute the length of a list:\n\
    <code>(foldr (lambda (x y) (+ 1 y)) 0 '(1 2 3))", "  (cond\n    [(empty? strings)\
    \ #f]\n    [(null? (cdr strings)) (car strings)]\n    [else\n     (let ([l (car\
    \ strings)]\n           [r (longest (cdr strings))])\n       (if (&gt; (string-length\
    \ l) (string-length r))\n           l\n           r))]))\n</code>\nNow let's look\
    \ at your code.\n<code>(define (longest list)\n  (cond\n    [(empty? list) #f]\n\
    \    [(null? (cdr list)) (car list)]\n    [else\n     (let ([l (car list)]\n \
    \          [r (longest (cdr list))])\n       (if (&gt; (string-length l) (string-length\
    \ r))\n           l\n           r))]))\n</code>\nYou're missing <code>strings</code>\
    \ in the first line. What you have here is a recursive call to the function itself.\n\
    <code>(define (longest list)\n  (cond\n    [(empty? list) #f]\n    [(null? (cdr\
    \ list)) (car list)]\n    [else\n     (let ([l (car list)]\n           [r (longest\
    \ (cdr list))])\n       (if (&gt; (string-length l) (string-length r))\n     \
    \      l\n           r))]))\n</code>\nNotice how it says <code>define (longest\
    \ list)</code> at the top. We're defining a function called <code>longest</code>\
    \ that takes one argument called <code>list</code>. What I did was change <code>list</code>\
    \ to <code>strings</code>. Here is what you're code looks like after that change.\n\
    <code>(define (longest list)\n  (cond\n    [(empty? list) #f]\n    [(null? (cdr\
    \ list)) (car list)]\n    [else\n     (let ([l (car list)]\n           [r (longest\
    \ (cdr list))])\n       (if (&gt; (string-length l) (string-length r))\n     \
    \      l\n           r))]))\n</code>\nCan you see the differences between the\
    \ two now?\n", "  (if (empty? strings)\n      #f\n      (if (or (empty? (rest\
    \ strings))\n              (string&gt;? (first strings) (longest (rest strings))))\n\
    \          (first strings)\n          (longest (rest strings)))))\n</code>\n",
  "  (cond\n    [(empty? strings) #f]\n    [(empty? (rest strings)) (first strings)]\n\
    \    [else\n     (if (&gt; (string-length (first strings)) (string-length (longest\
    \ (rest strings))))\n         (first strings)\n         (longest (rest strings)))]))\n\
    </code>\n", "  (if (null? strings)\n      #f\n      (letrec ([l (length (car strings))]\n\
    \               [curr strings]\n               [next (cdr strings)])\n       \
    \ (if (null? next)\n            (car curr)\n            (if (> (length (car next))\
    \ l)\n                (longest next)\n                (longest curr))))))\n",
  "  (if (null? strings)\n      #f\n      (letrec ([longest-so-far (car strings)]\n\
    \               [remaining (cdr strings)]\n               [longest-string (if\
    \ (null? remaining) longest-so-far\n                                 (let ([next-string\
    \ (car remaining)])\n                                   (if (> (string-length\
    \ next-string) (string-length longest-so-far))\n                             \
    \          (recur next-string (cdr remaining))\n                             \
    \          (recur longest-so-far (cdr remaining))))))])\n        longest-string)))\n\
    ```\n\n```racket\n#lang racket\n", "  (if (null? strings)\n      #f\n      (if\
    \ (null? (cdr strings))\n          (car strings)\n          (if (> (string-length\
    \ (car strings)) (string-length (longest (cdr strings))))\n              (car\
    \ strings)\n              (longest (cdr strings))))))\n", "  (if (empty? strings)\n\
    \      #f\n      (reduce (lambda (a b)\n                (if (> (string-length\
    \ a) (string-length b))\n                    a\n                    b))\n    \
    \          strings)))\n", "  (if (null? strings)\n      #f\n      (define (aux\
    \ current rest)\n        (if (null? rest)\n            current\n            (if\
    \ (> (string-length current) (string-length (car rest)))\n                (aux\
    \ current (cdr rest))\n                (aux (car rest) (cdr rest)))))\n      (aux\
    \ (car strings) (cdr strings))))\n\n", "  (cond ((empty? strings) #f)\n      \
    \  ((null? (cdr strings)) (car strings))\n        (else (let* ([shortest (longest\
    \ (cdr strings))]\n                     [this (car strings)])\n              \
    \ (if (&gt; (string-length this) (string-length shortest))\n                 \
    \  this\n                   shortest)))))\n</code>\nOf course, it is possible\
    \ to write the same solution in one line, but I feel my version is more readable.\
    \ What do you think?\n\n\nA:\n\nIt is more readable, although in style you could\
    \ use <code>let</code> instead of <code>let*</code> as the variables are not bound\
    \ to each other.\n<code>(define (longest strings)\n  (cond ((empty? strings) #f)\n\
    \        ((null? (cdr strings)) (car strings))\n        (else (let ([shortest\
    \ (longest (cdr strings))]\n                    [this (car strings)])\n      \
    \         (if (&gt; (string-length this) (string-length shortest))\n         \
    \          this\n                   shortest)))))\n</code>\nNote also that you\
    \ can write this equivalently as\n<code>(define (longest strings)\n  (if (null?\
    \ strings)\n      #f\n      (let loop ([strings strings]\n                 [prev\
    \ (car strings)])\n        (if (null? (cdr strings))\n            prev\n     \
    \       (loop (cdr strings)\n                  (if (&gt; (string-length (car strings))\n\
    \                         (string-length prev))\n                      (car strings)\n\
    \                      prev))))))\n</code>\n", "  (cond ((empty? strings) #f)\n\
    \        ((null? (cdr strings)) (car strings))\n        (else (cond ((> (string-length\
    \ (car strings)) (string-length (cadr strings)))\n                     (longest\
    \ (cons (car strings) (cddr strings))))\n                    (else (longest (cons\
    \ (cadr strings) (cddr strings))))))))\n", "  (if (null? strings)\n      #f\n\
    \      (let ([longest-string (first strings)])\n        (for ([string (rest strings)])\n\
    \          (if (> (string-length string) (string-length longest-string))\n   \
    \           (set! longest-string string)))\n        longest-string)))\n", "  (if\
    \ (null? strings)\n      #f\n      (let* ([cur (car strings)]\n             [next\
    \ (cdr strings)]\n             [next-longest (longest next)])\n        (if (and\
    \ (string? cur) (string? next-longest))\n            (if (> (string-length cur)\
    \ (string-length next-longest))\n                cur\n                next-longest)\n\
    \            (if (string? cur)\n                cur\n                (if (string?\
    \ next-longest)\n                    next-longest\n                    #f)))))\n\
    \  )\n", "  (cond [(empty? strings) #f]\n        [else (let ([first (first strings)]\n\
    \                    [rest (rest strings)])\n                (cond [(empty? rest)\
    \ first]\n                      [else (longest-of-two first (longest rest))]))]))\n",
  "  (cond\n    [(empty? strings) #f]\n    [(empty? (rest strings)) (first strings)]\n\
    \    [else\n     (if (< (string-length (first strings)) (string-length (second\
    \ strings)))\n         (longest (cons (second strings) (rest (rest strings))))\n\
    \         (longest (cons (first strings) (rest (rest strings)))))]))\n", "  (let\
    \ ([max-len 0]\n        [max-len-strings '()])\n    (for ([s strings])\n     \
    \ (if (> (string-length s) max-len)\n          (begin\n            (set! max-len\
    \ (string-length s))\n            (set! max-len-strings (list s)))))\n    (if\
    \ (null? max-len-strings)\n        #f\n        (car max-len-strings))))\n```\n\
    \n```\n#lang racket\n", "  (cond ((not (empty? strings))\n         (let loop ((remaining\
    \ (cdr strings))\n                    (current-longest (car strings)))\n     \
    \      (cond ((empty? remaining)\n                  current-longest)\n       \
    \          ((&gt; (string-length (car remaining))\n                     (string-length\
    \ current-longest))\n                  (loop (cdr remaining)\n               \
    \         (car remaining)))\n                 (else\n                  (loop (cdr\
    \ remaining)\n                        current-longest)))))\n        (else\n  \
    \       #f)))\n</code>\nThe problem I am having is that every single time I try\
    \ to run this function I get the exact same output.\n<code>&gt; (longest (list\
    \ \"a\" \"bb\" \"ccc\"))\n\"a\"\n&gt; (longest (list \"a\" \"bb\" \"ccc\"))\n\"\
    a\"\n&gt; (longest (list \"a\" \"bb\" \"ccc\"))\n\"a\"\n&gt; (longest (list \"\
    a\" \"bb\" \"ccc\"))\n\"a\"\n&gt; (longest (list \"a\" \"bb\" \"ccc\"))\n\"a\"\
    \n&gt; (longest (list \"a\" \"bb\" \"ccc\"))\n\"a\"\n&gt; (longest (list \"a\"\
    \ \"bb\" \"ccc\"))\n\"a\"\n&gt; (longest (list \"a\" \"bb\" \"ccc\"))\n\"a\"\n\
    &gt; (longest (list \"a\" \"bb\" \"ccc\"))\n\"a\"\n&gt; (longest (list \"a\" \"\
    bb\" \"ccc\"))\n\"a\"\n&gt; (longest (list \"a\" \"bb\" \"ccc\"))\n\"a\"\n&gt;\
    \ (longest (list \"a\" \"bb\" \"ccc\"))\n\"a\"\n&gt; (longest (list \"a\" \"bb\"\
    \ \"ccc\"))\n\"a\"\n&gt; (longest (list \"a\" \"bb\" \"ccc\"))\n\"a\"\n&gt; (longest\
    \ (list \"a\" \"bb\" \"ccc\"))\n\"a\"\n&gt; (longest (list \"a\" \"bb\"", "  (if\
    \ (empty? strings)\n      #f\n      (apply max-len strings)))\n", "  (if (null?\
    \ strings)\n      #f\n      (if (null? (cdr strings))\n          (car strings)\n\
    \          (let* ([longest-tail (longest (cdr strings))]\n                 [this-len\
    \ (string-length (car strings))]\n                 [that-len (string-length longest-tail)])\n\
    \            (if (&gt; this-len that-len)\n                (car strings)\n   \
    \             longest-tail)))))\n</code>\nAbove code is written in Racket (dialect\
    \ of Scheme).  What's the easiest way to convert it to Clojure?\nMy attempt:\n\
    <code>(defn longest\n  [strings]\n  (if (nil? strings)\n    false\n    (if (nil?\
    \ (rest strings))\n      (first strings)\n      (let [longest-tail (longest (rest\
    \ strings))\n            this-len (count (first strings))\n            that-len\
    \ (count longest-tail)]\n        (if (&gt; this-len that-len)\n          (first\
    \ strings)\n          longest-tail)))))\n</code>\nBut I have to replace <code>string-length</code>\
    \ with <code>count</code>.  Is this the right thing to do?\nWhat if I wanted to\
    \ convert the following code to Clojure? \n<code>(define (max-score xs)\n  (if\
    \ (null? xs)\n      (error \"max-score: empty list\")\n      (if (null? (cdr xs))\n\
    \          (car xs)\n          (let* ([longest-tail (max-score (cdr xs))]\n  \
    \               [this-score (score (car xs))]\n                 [that-score (score\
    \ longest-tail)])\n            (if (&gt; this-score that-score)\n            \
    \    (car xs)\n                longest-tail)))))\n</code>\nIn Clojure, I'm not\
    \ sure how to use <code>error</code> or <code>score</code> or <code>car</code>\
    \ or <code>cdr</code>.  Is it possible to convert the above code without changing\
    \ too much of the logic?\n\n\nA:\n\nIn Clojure we don't need a special <code>if</code>",
  "  (apply max (map string-length strings)))\n", "  (cond\n    [(empty? strings)\
    \ #f]\n    [(empty? (rest strings)) (first strings)]\n    [else\n     (define\
    \ (longest-aux current-longest other-strings)\n       (cond\n         [(empty?\
    \ other-strings) current-longest]\n         [else\n          (define current-longest\
    \ (max current-longest (string-length (first other-strings))))\n          (longest-aux\
    \ current-longest (rest other-strings))]))\n     (longest-aux (string-length (first\
    \ strings)) (rest strings))]))\n", "  (cond\n    [(empty? strings) #f]\n    [(and\
    \ (pair? strings) (empty? (cdr strings))) (car strings)]\n    [else (longest-loop\
    \ (car strings) (cdr strings))]))\n", "  (letrec ([aux (lambda (strings longest)\n\
    \                  (cond [(empty? strings) longest]\n                        [(>\
    \ (string-length (first strings)) (string-length longest))\n                 \
    \        (aux (rest strings) (first strings))]\n                        [else\
    \ (aux (rest strings) longest)]))])\n    (if (empty? strings)\n        #f\n  \
    \      (aux (rest strings) (first strings)))))\n", "  (cond\n    [(empty? strings)\
    \ #f]\n    [(empty? (rest strings)) (first strings)]\n    [else\n     (let ([next-longest\
    \ (longest (rest strings))])\n       (if (> (string-length (first strings)) (string-length\
    \ next-longest))\n           (first strings)\n           next-longest))]))\n",
  "  (if (null? strings)\n      #f\n      (let ([longest-so-far (car strings)])\n\
    \        (for ([s (cdr strings)])\n          (when (&gt; (string-length s) (string-length\
    \ longest-so-far))\n            (set! longest-so-far s)))\n        longest-so-far)))\n\
    </code>\n", "  (let ([acc (list)]\n        [str (car strings)])\n    (if (null?\
    \ strings)\n        #f\n        (for ([s (in-list (cdr strings))])\n         \
    \ (set! acc (cons (max str s) acc))\n          (set! str (max str s)))\n     \
    \   (apply min acc))))\n", "  (cond\n    [(empty? strings)\n     #f]\n    [(empty?\
    \ (rest strings))\n     (first strings)]\n    [else\n     (if (&gt; (string-length\
    \ (first strings)) (string-length (longest (rest strings))))\n         (first\
    \ strings)\n         (longest (rest strings)))]))\n</code>\nHere is the code after\
    \ refactoring:\n<code>#lang racket\n", "  (cond ((null? strings) #f)\n       \
    \ ((null? (cdr strings)) (car strings))\n        (else (longest-helper (car strings)\
    \ (cdr strings)))))\n", "  (if (empty? strings)\n      #f\n      (foldl\n    \
    \   (lambda (curr-max str)\n         (if (&gt; (string-length str) (string-length\
    \ curr-max))\n             str\n             curr-max))\n       (first strings)\n\
    \       (rest strings))))\n</code>\nHere's a more interesting one.\n<code>#lang\
    \ racket\n", "  (cond\n    ((null? strings) #f)\n    ((null? (cdr strings)) (car\
    \ strings))\n    (else\n      (let ((a (car strings))\n            (b (longest\
    \ (cdr strings))))\n        (if (> (string-length a) (string-length b))\n    \
    \        a\n            b)))))\n", "  (cond [(empty? strings) #f]\n        [else\
    \ (cond [(empty? (rest strings)) (first strings)]\n                    [else (if\
    \ (> (string-length (first strings)) (string-length (longest (rest strings))))\n\
    \                              (first strings)\n                             \
    \ (longest (rest strings)))]\n                    )\n              ]\n       \
    \ )\n  )\n", "  (if (empty? strings)\n      #f\n      (letrec ([longest-in (lambda\
    \ (strings longest)\n                             (if (empty? strings)\n     \
    \                            longest\n                                 (if (&gt;\
    \ (string-length (first strings)) (string-length longest))\n                 \
    \                    (longest-in (rest strings) (first strings))\n           \
    \                          (longest-in (rest strings) longest))))])\n        (longest-in\
    \ strings (first strings)))))\n</code>\nTest cases:\n<code>#lang racket\n", " \
    \ (if (null? strings)\n      #f\n      (let ((longest (car strings)))\n      \
    \  (for ([s (cdr strings)])\n          (if (> (string-length s) (string-length\
    \ longest))\n              (set! longest s)))\n        longest)))\n", "  (match\
    \ strings\n    [() #f]\n    [(cons s rest-strings)\n     (let ([longest-rest (longest\
    \ rest-strings)])\n       (if (string>? s longest-rest)\n           s\n      \
    \     longest-rest))]))\n", "  (local [(define (find-longest strs)\n         \
    \   (cond [(empty? strs) (void)]\n                  [(empty? (rest strs)) (first\
    \ strs)]\n                  [(> (string-length (first strs)) (string-length (second\
    \ strs)))\n                   (find-longest (cons (first strs) (rest (rest strs))))]\n\
    \                  [else (find-longest (cons (second strs) (rest (rest strs))))]))]\n\
    \    (find-longest strings)))\n", "  (if (null? strings)\n      #f\n      (let\
    \ loop ((str strings)\n                 (longest-str (car strings)))\n       \
    \ (if (null? str)\n            longest-str\n            (if (> (string-length\
    \ (car str)) (string-length longest-str))\n                (loop (cdr str) (car\
    \ str))\n                (loop (cdr str) longest-str))))))\n", "  (if (null? strings)\n\
    \      #f\n      (max-length strings)))\n", "  (cond [(empty? strings) #f]\n \
    \       [else (max-str (first strings) (longest (rest strings)))]))\n", "  (if\
    \ (null? strings)\n      #f\n      (if (null? (cdr strings))\n          (car strings)\n\
    \          (if (&gt; (string-length (car strings)) (string-length (longest (cdr\
    \ strings))))\n              (car strings)\n              (longest (cdr strings))))))\n\
    </code>\n", "  (cond\n    [(empty? strings) #f]\n    [(empty? (rest strings))\
    \ (first strings)]\n    [else\n     (let* [(first-string (first strings))\n  \
    \          (first-string-length (string-length first-string))\n            (second-string\
    \ (longest (rest strings)))\n            (second-string-length (string-length\
    \ second-string))]\n       (if (> first-string-length second-string-length)\n\
    \           first-string\n           second-string))]))\n", "  (let loop ([current-longest\
    \ (first strings)]\n             [rest (rest strings)])\n    (cond [(null? rest)\
    \ current-longest]\n          [(string>? (first rest) current-longest)\n     \
    \      (loop (first rest) (rest rest))]\n          [else (loop current-longest\
    \ (rest rest))])))\n", "  (let* ([len (apply max (map string-length strings))]\n\
    \         [test (lambda (s) (= (string-length s) len))])\n    (first (filter test\
    \ strings))))\n", "  (let ((max-length 0)\n        (longest-item #f))\n    (for\
    \ ([s strings])\n      (if (> (string-length s) max-length)\n          (begin\n\
    \            (set! max-length (string-length s))\n            (set! longest-item\
    \ s))))\n    longest-item))\n", "  (cond\n    [(empty? strings) #f]\n    [(empty?\
    \ (rest strings)) (first strings)]\n    [else\n     (let* ([str1 (first strings)]\n\
    \            [str2 (first (rest strings))]\n            [rest (rest (rest strings))])\n\
    \       (longest (cons (if (&gt; (string-length str1) (string-length str2)) str1\
    \ str2) rest)))]))\n</code>\nI can't see the issue here, but I'm getting an error:\n\
    <code>longest.rkt:2:7: string-length: expects argument of type &lt;string&gt;;\
    \ given (string-length str1)\n</code>\nWhat is wrong?\n\n\nA:\n\nYour error is\
    \ caused by the fact that you are passing <code>(string-length str1)</code> to\
    \ <code>&gt;</code>, and <code>&gt;</code> only accepts numbers.\nAs for the solution,\
    \ I'll give you some hints:\n\nYour code is unnecessarily complicated because\
    \ you call <code>first</code> and <code>rest</code> several times, and <code>rest</code>\
    \ twice in a row.\nDon't use <code>let*</code> - it is a mistake to use it here.\n\
    Instead of <code>if</code>, use <code>cond</code>.\nIf you replace your implementation\
    \ with this <code>cond</code> clause, the program will probably stop complaining:\n\
    <code>(else\n  (cond\n    [(&gt; (string-length str1) (string-length str2)) str1]\n\
    \    [else str2]))\n</code>\n\nBut the code is still not correct. My advice is\
    \ to start over, and make your code a lot simpler.\n", "  (if (empty? strings)\n\
    \      #f\n      (define (lhelper ls longest)\n        (if (empty? ls)\n     \
    \       longest\n            (if (> (string-length (first ls)) (string-length\
    \ longest))\n                (lhelper (rest ls) (first ls))\n                (lhelper\
    \ (rest ls) longest))))\n      (lhelper (rest strings) (first strings))))\n",
  "  (cond\n    [(empty? strings) (displayln \"empty list\")]\n    [(= (length (first\
    \ strings)) (length (last strings))) (displayln \"possible longest\")]\n    [(string>?\
    \ (first strings) (last strings)) (longest (rest strings))]\n    [else (first\
    \ strings)]))\n\n", "  (if (null? strings)\n      #f\n      (if (null? (cdr strings))\n\
    \          (car strings)\n          (if (< (string-length (car strings)) (string-length\
    \ (cadr strings)))\n              (longest (cdr strings))\n              (longest\
    \ (cons (car strings) (cddr strings)))))))\n", "  (cond\n    ((null? strings)\
    \ #f)\n    ((null? (cdr strings)) (car strings))\n    (else\n      (let* ([longest-so-far\
    \ (longest (cdr strings))]\n             [longest-so-far-length (string-length\
    \ longest-so-far)])\n        (if (> longest-so-far-length (string-length (car\
    \ strings)))\n            longest-so-far\n            (car strings))))))\n", " \
    \ (cond [(empty? strings) #f]\n        [else (foldl max (first strings) (rest\
    \ strings))]))\n", "  (cond\n    [(empty? strings) #f]\n    [(= (length (first\
    \ strings)) (length (apply max-length strings))) (first strings)]\n    [else (longest\
    \ (rest strings))]))\n</code>\nThis function is taking a list of strings, it checks\
    \ if the input list is empty, if it is, then it returns <code>#f</code>, if it\
    \ is not empty, then it compares the length of the first element of the list,\
    \ with the length of all the elements of the list, if they are the same, then\
    \ it returns the first element of the list, if they are not the same, then it\
    \ calls the <code>longest</code> function again, with the rest of the list, and\
    \ the new list will be the first element of the input list removed.\nThe <code>apply\
    \ max-length strings</code> is doing the work of getting the length of the longest\
    \ string in the list.\nI hope this helped.\n", "  (cond\n    [(empty? strings)\
    \ #f]\n    [(empty? (rest strings)) (first strings)]\n    [else\n     (cond\n\
    \       [(> (string-length (first strings)) (string-length (longest (rest strings))))\n\
    \        (first strings)]\n       [else (longest (rest strings))])]))\n\n", " \
    \ (if (null? strings)\n      #f\n      (if (null? (cdr strings))\n          (car\
    \ strings)\n          (if (&gt; (string-length (car strings)) (string-length (cadr\
    \ strings)))\n              (longest (cons (car strings) (cddr strings)))\n  \
    \            (longest (cons (cadr strings) (cddr strings)))))))\n</code>\nHowever,\
    \ I'm having trouble understanding the way the final <code>else</code> is constructed\
    \ in the recursive part.\n<code>(if (&gt; (string-length (car strings)) (string-length\
    \ (cadr strings)))\n    (longest (cons (car strings) (cddr strings)))\n    (longest\
    \ (cons (cadr strings) (cddr strings))))\n</code>\nThe <code>car</code> becomes\
    \ <code>cons</code>ed with the <code>cddr</code> in one branch, and the <code>cadr</code>\
    \ is <code>cons</code>ed with the <code>cddr</code> in the other branch. To me,\
    \ it seems like it should be the other way around. \nIn the scenario that the\
    \ <code>car</code> is larger, it is kept, so the <code>car</code> becomes the\
    \ first value of the new list that is the input to the next recursive call. \n\
    In the scenario that the <code>cadr</code> is larger, it should be the value that\
    \ is kept, so the <code>cadr</code> should become the first value of the new list\
    \ that is the input to the next recursive call. \nSo, why are we <code>cons</code>ing\
    \ the smaller of the two strings to the front of the list in each branch?\n",
  "  (define (length-compare s1 s2)\n    (< (string-length s1) (string-length s2)))\n\
    \  (if (list? strings)\n      (let ([longest (apply max strings length-compare)])\n\
    \        (if (string? longest)\n            longest\n            #f))\n      #f))\n",
  "  (if (null? strings)\n      #f\n      (let loop ((strings strings)\n         \
    \        (longest (car strings)))\n        (if (null? strings)\n            longest\n\
    \            (if (> (string-length (car strings)) (string-length longest))\n \
    \               (loop (cdr strings) (car strings))\n                (loop (cdr\
    \ strings) longest))))))\n", "  (cond [(empty? strings) #f]\n        [else (let*\
    \ ([strings-lengths (map (lambda (str) (string-length str)) strings)]\n      \
    \               [max-length (apply max strings-lengths)]\n                   \
    \  [indices (find-all (lambda (x) (= max-length x)) strings-lengths)])\n     \
    \           (list-ref strings (first indices)))]))\n</code>\nThis is how I would\
    \ do it in Haskell:\n<code>longest :: [String] -&gt; Maybe String\nlongest []\
    \ = Nothing\nlongest xs = Just $ maximumBy (comparing length) xs\n</code>\nWhich\
    \ is much shorter. \nI'd like to understand:\n\nWhat's the idiomatic way to do\
    \ it in Racket?\nHow can I rewrite my function to be more concise and readable?\n\
    \n\n\nA:\n\nThere are a couple of things I'd change about this.\nFirst, for the\
    \ purpose of comparing lengths, the strings don't need to be converted to <code>string-length</code>\
    \ values.\nSecond, once we know what the maximum length is, we only need to look\
    \ at the first string that has that length.\nThird, instead of <code>apply</code>ing\
    \ <code>max</code>, we can use <code>maximum</code>.\nThis gives\n<code>(define\
    \ (longest strings)\n  (cond [(empty? strings) #f]\n        [else (let* ([max-length\
    \ (maximum (map string-length strings))]\n                     [first-longest\
    \ (first (filter (\u03BB (s) (= (string-length s) max-length)) strings))])\n \
    \               first-longest)]))\n</code>\n", "  (if (null? strings)\n      #f\n\
    \      (let ((ret (first strings)))\n        (for ((x (rest strings)))\n     \
    \     (if (> (string-length x) (string-length ret))\n              (set! ret x)))\n\
    \        ret)))\n", "  (cond [(empty? strings) #f]\n        [else\n         (let\
    \ ([l (length (first strings))])\n           (cond [(empty? (rest strings)) (first\
    \ strings)]\n                 [else\n                  (if (< l (length (first\
    \ (rest strings))))\n                      (longest (rest strings))\n        \
    \              (first strings))]))]))\n", "  (if (null? strings)\n      #f\n \
    \     (let loop ((strings strings)\n                 (longest-string (car strings)))\n\
    \        (if (null? strings)\n            longest-string\n            (let ((current-string\
    \ (car strings)))\n              (if (> (string-length current-string)\n     \
    \                (string-length longest-string))\n                  (loop (cdr\
    \ strings)\n                        current-string)\n                  (loop (cdr\
    \ strings)\n                        longest-string)))))))\n", "  (cond\n    [(empty?\
    \ strings)\n     #f]\n    [(empty? (rest strings))\n     (first strings)]\n  \
    \  [else\n     (define current-longest (first strings))\n     (define current-longest-length\
    \ (string-length current-longest))\n     (define (iter remaining-strings)\n  \
    \     (cond\n         [(empty? remaining-strings)\n          current-longest]\n\
    \         [else\n          (define head (first remaining-strings))\n         \
    \ (define head-length (string-length head))\n          (if (> head-length current-longest-length)\n\
    \              (begin\n                (set! current-longest head)\n         \
    \       (set! current-longest-length head-length))\n              (void))\n  \
    \        (iter (rest remaining-strings))]))\n     (iter (rest strings))]))\n```\n\
    \n```", "  (if (empty? strings)\n      #f\n      (let loop ((strings strings)\n\
    \                 (longest (first strings)))\n        (if (empty? strings)\n \
    \           longest\n            (let ((current (first strings)))\n          \
    \    (if (&gt; (string-length current) (string-length longest))\n            \
    \      (loop (rest strings) current)\n                  (loop (rest strings) longest)))))))\n\
    </code>\nThe code checks that the input is not empty and takes the first string\
    \ as the longest, then checks every other string. If a string is longer than the\
    \ current longest string, it becomes the new longest string.\n", "  (define (find-longest\
    \ strings longest-found)\n    (cond\n      [(empty? strings) longest-found]\n\
    \      [(string>? (first strings) longest-found) (find-longest (rest strings)\
    \ (first strings))]\n      [else (find-longest (rest strings) longest-found)]))\n\
    \  (if (empty? strings)\n      #f\n      (find-longest (rest strings) (first strings))))\n",
  "  (if (empty? strings)\n      #f\n      (letrec ([longest-rec (lambda (strings)\n\
    \                              (if (empty? (rest strings))\n                 \
    \                 (first strings)\n                                  (if (&gt;\
    \ (string-length (first strings))\n                                          (string-length\
    \ (longest-rec (rest strings))))\n                                      (first\
    \ strings)\n                                      (longest-rec (rest strings)))))])\n\
    \        (longest-rec strings))))\n</code>\nIs there any way to improve this code?\n\
    \n\nA:\n\nYou could write a version of <code>reduce</code> that gives you the\
    \ first instead of the last (or longest instead of shortest) element of the list.\
    \ Then you could write\n<code>(define (longest strings)\n  (let ([longest-string\
    \ (reduce (lambda (s1 s2)\n                                  (if (&gt; (string-length\
    \ s1)\n                                         (string-length s2))\n        \
    \                              s1\n                                      s2))\n\
    \                                '()\n                                strings)])\n\
    \    (if (string? longest-string)\n        longest-string\n        #f)))\n</code>\n\
    or using an <code>if</code> with <code>cond</code>:\n<code>(define (longest strings)\n\
    \  (if (empty? strings)\n      #f\n      (reduce (lambda (s1 s2)\n           \
    \     (if (&gt; (string-length s1)\n                       (string-length s2))\n\
    \                    s1\n                    s2))\n              '()\n       \
    \       strings)))\n</code>\nor if you use the <code>pairof</code> helper to make\
    \ the <code>lambda</code> more readable, you get\n<code>(define (longest strings)\n\
    \  (if (empty? strings)\n      #f\n      (reduce (pairof string-length &gt;)\n\
    \              '()\n              strings)))\n</code>\n", "  (cond\n    ((null?\
    \ strings)\n     #f)\n    ((null? (cdr strings))\n     (car strings))\n    (else\n\
    \     (let ([head (car strings)]\n           [tail (cdr strings)])\n       (if\
    \ (> (string-length head) (string-length (longest tail)))\n           head\n \
    \          (longest tail))))))\n", "  (if (empty? strings)\n      #f\n      (let\
    \ lp ((ss strings) (acc (first ss)))\n        (if (empty? ss)\n            acc\n\
    \            (let ((next (first ss)))\n              (if (> (string-length next)\
    \ (string-length acc))\n                  (lp (rest ss) next)\n              \
    \    (lp (rest ss) acc)))))))\n", "  (if (null? strings)\n      #f\n      (foldl\
    \ (lambda (next longest)\n               (if (&gt; (string-length next) (string-length\
    \ longest))\n                   next\n                   longest))\n         \
    \    (car strings)\n             (cdr strings))))\n</code>\n", "  (match strings\n\
    \    [(list) #f]\n    [(list head tail ...)\n     (let ([longest-tail (longest\
    \ tail)])\n       (if (string>? longest-tail head)\n           longest-tail\n\
    \           head))]))\n\n", "  (if (empty? strings)\n      #f\n      (if (empty?\
    \ (rest strings))\n          (first strings)\n          (let ([str1 (first strings)]\n\
    \                [str2 (longest (rest strings))])\n            (if (> (string-length\
    \ str1) (string-length str2))\n                str1\n                str2)))))\n",
  "  (cond\n    [(empty? strings) #f]\n    [(empty? (rest strings)) (first strings)]\n\
    \    [else\n     (if (> (string-length (first strings)) (string-length (longest\
    \ (rest strings))))\n         (first strings)\n         (longest (rest strings)))]))\n",
  "  (cond [(empty? strings) #f]\n        [else (apply max (map length strings))]))\n",
  "  (cond\n    [(empty? strings) #f]\n    [(empty? (rest strings)) (first strings)]\n\
    \    [else\n     (let* ([one (first strings)]\n            [two (longest (rest\
    \ strings))])\n       (if (> (string-length one) (string-length two))\n      \
    \     one\n           two))]))\n\n", "  (if (null? strings)\n      #f\n      (foldr\
    \ (lambda (string longest)\n               (if (&gt; (string-length string) (string-length\
    \ longest))\n                   string\n                   longest))\n       \
    \      (car strings)\n             (cdr strings))))\n</code>\nSince you haven't\
    \ learned about <code>foldr</code> and <code>lambda</code> yet, here's the implementation\
    \ with <code>for/fold</code>:\n<code>#lang racket\n", "  (cond ((null? strings)\
    \ #f)\n        ((null? (cdr strings)) (car strings))\n        (else (let ([longer\
    \ (longest (cdr strings))])\n                (if (> (string-length (car strings))\
    \ (string-length longer))\n                    (car strings)\n               \
    \     longer)))))\n</code>\nYou might want to use <code>strings-&gt;list</code>\
    \ for input for this.\n", "  (if (empty? strings)\n      #f\n      (if (null?\
    \ (cdr strings))\n          (car strings)\n          (if (> (string-length (car\
    \ strings)) (string-length (longest (cdr strings))))\n              (car strings)\n\
    \              (longest (cdr strings))))))\n", "  (if (null? strings)\n      #f\n\
    \      (let* ((longest-length (apply max (map string-length strings)))\n     \
    \        (longest-string-candidates (filter (lambda (x) (= longest-length (string-length\
    \ x))) strings)))\n        (car longest-string-candidates))))\n", "  (cond\n \
    \   [(empty? strings) #f]\n    [(= (length (car strings)) (length (longest (cdr\
    \ strings)))) (car strings)]\n    [else (longest (cdr strings))]))\n", "  (apply\
    \ max (map length strings)))\n", "  (if (null? strings)\n      #f\n      (apply\
    \ max strings)\n  )\n)\n", "  (cond\n    [(empty? strings) #f]\n    [(= (length\
    \ (first strings)) (length (longest (rest strings)))) (first strings)]\n    [(>\
    \ (length (first strings)) (length (longest (rest strings)))) (first strings)]\n\
    \    [else (longest (rest strings))]))\n\n", "  (if (null? strings)\n      #f\n\
    \      (foldr (lambda (str max-so-far)\n               (if (> (string-length str)\
    \ (string-length max-so-far))\n                   str\n                   max-so-far))\n\
    \             (car strings)\n             (cdr strings))))\n", "  (cond\n    [(empty?\
    \ strings) #f]\n    [(empty? (rest strings)) (first strings)]\n    [else\n   \
    \  (if (&gt; (string-length (first strings)) (string-length (longest (rest strings))))\n\
    \         (first strings)\n         (longest (rest strings)))]))\n</code>\nSo,\
    \ my own implementation is completely functional, while the example in <code>HTDP</code>\
    \ is not. Since in <code>HTDP</code> they use mutable variables, which are not\
    \ supported in <code>Racket</code>, I had to figure out a way to implement the\
    \ <code>longest</code> function completely functionally.\nI believe that the solution\
    \ I found is good enough. However, I'm not 100% sure, so my question is: Is my\
    \ own implementation better than the one in <code>HTDP</code>? Or maybe both solutions\
    \ are good, and it's just a matter of preference?\n\n\nA:\n\nBoth solutions are\
    \ functional, but yours has a pointlessly high runtime complexity, as it does\
    \ twice as many comparisons as is necessary. That is, if the first string is longer\
    \ than the second, you still compare the first string to the third, fourth, etc.,\
    \ and this is not necessary, you could have stopped the recursion immediately,\
    \ without checking the rest of the strings.\nSince you have not specified a runtime\
    \ complexity requirement, this is not a problem per se, but it is a problem if\
    \ the runtime complexity requirement is specified or if you want to write a fast\
    \ algorithm. This can be fixed by using an iterative solution:\n<code>(define\
    \ (longest strings)\n  (define (help strings longest)\n    (cond\n      [(empty?\
    \ strings) longest]\n      [(string&gt;? (first strings) longest) (help (rest\
    \ strings) (first strings))]\n      [else (help (rest strings) longest)]))\n \
    \ (if (empty? strings)\n      #f\n      (help (rest strings) (first strings))))\n\
    </code>\nYou may want to make a helper function for string comparison, as I did\
    \ here, <code>string&gt;?</code>, which takes two strings and returns <code>#t</code>\
    \ if the first string is longer than the second, and <code>#f</code> otherwise.\
    \ This", "  (if (null? strings)\n      #f\n      (let ([curr (car strings)]\n\
    \            [rest (cdr strings)])\n        (if (null? rest)\n            curr\n\
    \            (let ([next (longest rest)])\n              (if (> (string-length\
    \ curr) (string-length next))\n                  curr\n                  next))))))\n",
  "  (if (null? strings)\n      #f\n      (let ([longest-so-far (car strings)])\n\
    \        (for ([s (cdr strings)])\n          (when (> (string-length s) (string-length\
    \ longest-so-far))\n            (set! longest-so-far s)))\n        longest-so-far)))\n",
  "  (match strings\n    [(list) #f]\n    [(list s) s]\n    [(list s1 (cons s2 rest))\n\
    \     (if (&gt; (string-length s1) (string-length s2))\n         s1\n        \
    \ (longest (cons s2 rest)))]))\n</code>\nWhen I run the script it works as expected:\n\
    <code>&gt;&gt; (longest (list ))\n#f\n&gt;&gt; (longest (list \"a\" \"b\" \"c\"\
    ))\n\"a\"\n&gt;&gt; (longest (list \"a\" \"bb\" \"ccc\"))\n\"ccc\"\n</code>\n\
    But when I run it with the <code>#lang racket</code> I'm getting an error:\n<code>&gt;&gt;\
    \ (longest (list ))\nlongest: unbound identifier in module in: longest\n&gt;&gt;\
    \ (longest (list \"a\" \"b\" \"c\"))\nlongest: unbound identifier in module in:\
    \ longest\n&gt;&gt; (longest (list \"a\" \"bb\" \"ccc\"))\nlongest: unbound identifier\
    \ in module in: longest\n</code>\nI've also tried to use the <code>#lang racket/base</code>\
    \ instead of the <code>#lang racket</code>, but it didn't help.\n\n\nA:\n\nThe\
    \ problem is the the <code>#lang racket</code> doesn't import the functions that\
    \ are available in the REPL.\nYou need to use <code>#lang racket/base</code>.\n",
  "  (cond [(empty? strings)\n         (void)]\n        [(empty? (rest strings))\n\
    \         (first strings)]\n        [else\n         (if (&gt; (string-length (first\
    \ strings))\n                (string-length (first (rest strings))))\n       \
    \      (first strings)\n             (longest (rest strings)))]))\n</code>\nThe\
    \ thing I'm not sure is what should I do in the case where the list is empty.\
    \ Should I return <code>#f</code> or <code>(void)</code>?\nAfter I read the posted\
    \ answers and comments, I decided to change <code>(void)</code> to <code>#f</code>\
    \ since <code>(void)</code> will not cause any errors, but it is better to make\
    \ a clear decision than to leave it vague.\n\n\nA:\n\nIt depends on what you want\
    \ to do later with the result.\nIf you want to return an error message if the\
    \ input list is empty, you would use <code>#f</code>, but if you want to use the\
    \ result in an <code>if</code> expression, you would use <code>(void)</code>.\n\
    <code>(if (longest (list \"a\" \"bb\" \"ccc\"))\n    (printf \"the longest string\
    \ is ~a~n\" (longest (list \"a\" \"bb\" \"ccc\")))\n    (printf \"the input list\
    \ is empty\"))\n</code>\nwill print\n<code>the longest string is ccc\n</code>\n\
    but\n<code>(if (longest (list ))\n    (printf \"the longest string is ~a~n\" (longest\
    \ (list \"a\" \"bb\" \"ccc\")))\n    (printf \"the input list is empty\"))\n</code>\n\
    will print\n<code>the input list is empty\n</code>\nwhile the following code\n\
    <code>(if (longest (list ))\n    (printf \"the longest string is ~a~n\" (longest\
    \ (list \"a\" \"bb\" \"ccc\")))\n    (printf \"the input list is empty\"))\n</code>\n\
    will not print anything.\nEDIT\nAs Martin's comment suggested, if you need to\
    \ use the result of <code>longest</code> somewhere else in your code, you can",
  "  (if (null? strings)\n      #f\n      (let ((first (car strings))\n          \
    \  (rest (cdr strings)))\n        (if (null? rest)\n            first\n      \
    \      (if (&gt; (string-length first) (string-length (longest rest)))\n     \
    \           first\n                (longest rest))))))\n</code>\nThe code works\
    \ as intended, but it looks a bit ugly. I feel like I'm abusing <code>let</code>\
    \ bindings, and I do not like the fact that the code can not return <code>#f</code>\
    \ in case of an empty list unless I add an explicit predicate for this case.\n\
    I don't quite understand what's wrong with my code, or if it's correct in the\
    \ first place. Any hints or advice would be greatly appreciated.\n\n\nA:\n\nThe\
    \ code looks fine to me. Since you're still studying Racket, I'll give you some\
    \ useful tips. Take the following function, for example:\n<code>(define (longest-with-accumulator\
    \ strings accumulator)\n  (cond ((null? strings)\n         accumulator)\n    \
    \    ((string-length (car strings)) &gt; (string-length accumulator))\n      \
    \   (longest-with-accumulator (cdr strings) (car strings)))\n        (else\n \
    \        (longest-with-accumulator (cdr strings) accumulator))))\n</code>\nInstead\
    \ of using an explicit predicate to decide if <code>strings</code> is empty, we\
    \ can use the <code>cond</code> special form which allows us to write a conditional\
    \ expression (with a default clause) without having to use <code>if</code> expressions.\
    \ Try to avoid using <code>if</code> expressions, even if they are allowed in\
    \ Racket, because they are harder to read and understand.\nWe can also use an\
    \ accumulator to compute the longest string, instead of using recursion. Just\
    \ add a new parameter to the function and pass the current longest string, using\
    \ the accumulator as the \"starting value\" for the first call of the function.\n",
  "  (if (empty? strings)\n      #f\n      (cond\n        [(null? (cdr strings)) (car\
    \ strings)]\n        [else (let [first (car strings)\n                    second\
    \ (car (cdr strings))]\n                (if (> (string-length first) (string-length\
    \ second))\n                    (longest (cons first (cdr (cdr strings))))\n \
    \                   (longest (cons second (cdr (cdr strings))))))])))\n", "  (if\
    \ (null? strings)\n      #f\n      (foldl (lambda (a b)\n               (if (&gt;\
    \ (string-length a) (string-length b))\n                   a\n               \
    \    b))\n             (car strings)\n             (cdr strings))))\n</code>\n",
  "  (cond\n    [(empty? strings) (void)]\n    [(null? (cdr strings)) (car strings)]\n\
    \    [else (max (car strings) (longest (cdr strings)))]))\n", "  (if (null? strings)\n\
    \      #f\n      (letrec ([longest-str (lambda (strs longest-so-far)\n       \
    \                       (if (null? strs)\n                                  longest-so-far\n\
    \                                  (if (< (string-length (car strs)) (string-length\
    \ longest-so-far))\n                                      (longest-str (cdr strs)\
    \ longest-so-far)\n                                      (longest-str (cdr strs)\
    \ (car strs)))))]\n               [first-str (car strings)])\n        (longest-str\
    \ (cdr strings) first-str))))\n", "  (cond\n    [(empty? strings) #f]\n    [(null?\
    \ (cdr strings)) (car strings)]\n    [else\n     (cond\n       [(> (string-length\
    \ (car strings)) (string-length (cadr strings)))\n        (longest (cons (car\
    \ strings) (cddr strings)))]\n       [else\n        (longest (cons (cadr strings)\
    \ (cddr strings)))])]))\n", "  (foldr (lambda (x res)\n           (if (> (string-length\
    \ x) (string-length res))\n               x\n               res))\n         '#f\n\
    \         strings))\n", "  (cond ((null? strings) #f)\n        ((null? (cdr strings))\
    \ (car strings))\n        (else (if (> (string-length (car strings)) (string-length\
    \ (cadr strings)))\n                  (longest (cons (car strings) (cddr strings)))\n\
    \                  (longest (cons (cadr strings) (cddr strings)))))))\n", "  (if\
    \ (null? strings)\n      #f\n      (foldl max strings (lambda (x y) (if (> (string-length\
    \ x) (string-length y)) x y)))))\n\n", "  (if (null? strings)\n      #f\n    \
    \  (if (null? (cdr strings))\n          (car strings)\n          (let ([max-so-far\
    \ (car strings)]\n                [max-so-far-length (string-length max-so-far)])\n\
    \            (for ([s (cdr strings)])\n              (if (> (string-length s)\
    \ max-so-far-length)\n                  (begin\n                    (set! max-so-far\
    \ s)\n                    (set! max-so-far-length (string-length s)))))\n    \
    \        max-so-far))))\n", "  (if (null? strings)\n      #f\n      (if (null?\
    \ (cdr strings))\n          (car strings)\n          (if (> (string-length (car\
    \ strings)) (string-length (longest (cdr strings))))\n              (car strings)\n\
    \              (longest (cdr strings))))))\n", "  (if (null? strings)\n      #f\n\
    \      (let* ([current-longest (car strings)]\n             [other-strings (cdr\
    \ strings)])\n        (if (null? other-strings)\n            current-longest\n\
    \            (let ([longest-other-string (longest other-strings)])\n         \
    \     (if (&gt; (string-length current-longest) (string-length longest-other-string))\n\
    \                  current-longest\n                  longest-other-string))))))\n\
    </code>\nI was hoping to get some feedback to find out how I could improve the\
    \ code to be more concise, easier to read, or more idiomatic.\n\n\nA:\n\nNice\
    \ job!  You certainly know the ropes of recursion and the Racket list-processing\
    \ functions.  In fact, your code is so good that it's hard to say anything useful\
    \ about it.  :-)\nI can offer a few suggestions, though.\n\nI agree with the others\
    \ that your use of <code>let*</code> is questionable.  First, it's probably not\
    \ doing what you think it is, since it's not establishing a lexical scope for\
    \ the bindings.  Second, you don't need to use a <code>let*</code> for this at\
    \ all.  Just make <code>current-longest</code> and <code>other-strings</code>\
    \ a <code>let</code>-binding with multiple binding forms:\n<code>(let ([current-longest\
    \ (car strings)]\n      [other-strings (cdr strings)])\n  \u2026)\n</code>\nOn\
    \ a stylistic note, you've hit on the Racket community's least favorite language\
    \ feature, so you'd probably do well to avoid it in any code you want to share\
    \ with the community at large.\nYou could also use a <code>match</code> here.\
    \  I'd probably write it something like this:\n<code>(define (longest strings)\n\
    \  (match strings\n    [(list first-string (rest \u2026))\n     (let ([rest-longest\
    \ (longest rest)])\n       (if (&gt; (string-length first-string) (string-length\
    \ rest-longest))\n           first-string\n           rest-longest))]\n    [(list\
    \ first-string) first-string]", "  (cond [(empty? strings) #f]\n        [else\
    \ (max-longest (car strings) (cdr strings))]))\n", "  (cond\n    [(empty? strings)\
    \ #f]\n    [(empty? (rest strings)) (first strings)]\n    [else\n     (let\n \
    \      ([first-string (first strings)]\n        [first-length (string-length first-string)]\n\
    \        [rest-longest (longest (rest strings))]\n        [rest-length (string-length\
    \ rest-longest)])\n       (if (> first-length rest-length)\n           first-string\n\
    \           rest-longest))]))\n", "  (if (empty? strings)\n      #f\n      (longest-not-empty\
    \ strings (first strings))))\n", "  (local ((define (pick-longest x y)\n     \
    \       (if (&gt; (string-length x) (string-length y))\n                x\n  \
    \              y)))\n    (cond\n      [(empty? strings) #f]\n      [(empty? (rest\
    \ strings)) (first strings)]\n      [else (foldl pick-longest (first strings)\
    \ (rest strings))])))\n</code>\n", "  (if (empty? strings)\n      #f\n      (if\
    \ (null? (cdr strings))\n          (car strings)\n          (if (&gt; (string-length\
    \ (car strings)) (string-length (longest (cdr strings))))\n              (car\
    \ strings)\n              (longest (cdr strings))))))\n</code>\n", "  (if (null?\
    \ strings)\n      #f\n      (longest-iter (car strings) (cdr strings))))\n", " \
    \ (cond\n    [(empty? strings) #f]\n    [(empty? (rest strings)) (first strings)]\n\
    \    [else\n     (let* ([longest-so-far (first strings)]\n            [current-longest\
    \ (first strings)])\n       (for ([s (rest strings)])\n         (cond\n      \
    \     [(> (string-length s) (string-length current-longest))\n            (set!\
    \ current-longest s)]))\n       current-longest)]))\n", "  (if (null? strings)\n\
    \      #f\n      (foldl (lambda (x y) (if (&gt; (string-length x) (string-length\
    \ y)) x y)) (car strings) (cdr strings))))\n", "  (cond\n    [(empty? strings)\
    \ #f]\n    [(null? (cdr strings)) (car strings)]\n    [else\n     (let [first-item\
    \ (car strings)\n           first-length (string-length first-item)\n        \
    \   second-length (string-length (longest (cdr strings)))]\n       (if (> first-length\
    \ second-length)\n           first-item\n           (longest (cdr strings))))]))\n",
  "  (cond ((null? strings) #f)\n        ((null? (cdr strings)) (car strings))\n \
    \       (else (cond ((> (string-length (car strings)) (string-length (cadr strings)))\n\
    \                     (longest (cons (car strings) (cddr strings))))\n       \
    \             (else (longest (cons (cadr strings) (cddr strings))))))))\n", " \
    \ (cond [(empty? strings)\n         (void)]\n        [(not (list? strings))\n\
    \         (error \"Input is not a list\")]\n        [(not (every string? strings))\n\
    \         (error \"Input is not a list of strings\")]\n        [else\n       \
    \  (define (inner length acc result)\n           (cond [(null? length)\n     \
    \             (if (null? acc)\n                      #f\n                    \
    \  (car acc))]\n                 [(equal? (length (car length)) (length (car acc)))\n\
    \                  (inner (cdr length) (cons (car length) acc) (car length))]\n\
    \                 [(> (length (car length)) (length (car acc)))\n            \
    \      (inner (cdr length) (list (car length)) (car length))]\n              \
    \   [else\n                  (inner (cdr length) acc result)]))\n         (inner\
    \ strings (list (car strings)) (car strings))]))\n", "  (cond\n    [(empty? strings)\
    \ #f]\n    [(empty? (rest strings)) (first strings)]\n    [else\n     (let ([longest\
    \ (first strings)])\n       (for ([str (rest strings)])\n         (when (> (string-length\
    \ str) (string-length longest))\n           (set! longest str)))\n       longest)]))\n\
    ```\n\n```racket\n#lang racket\n", "  (cond ((null? strings) #f)\n        ((equal?\
    \ 1 (length strings)) (car strings))\n        (else (if (&gt; (length (car strings))\
    \ (length (cadr strings)))\n                  (longest (cons (car strings) (cddr\
    \ strings)))\n                  (longest (cons (cadr strings) (cddr strings)))))))\n\
    </code>\n\nThe code above passed all the test cases (about 20), and it was praised\
    \ as an \"elegant\" solution, but it was graded as a 0. \nThe professor said that\
    \ it was \"inefficient\" and he \"does not like it\".\nThen I asked him to show\
    \ me a better solution, and he cannot.\nBut he said he cannot show me because\
    \ he want us to \"think like a computer scientist\", and do not want us to copy\
    \ his code.\nI am just curious, why would he want a worse code?\nI mean, after\
    \ all, the professor did not explicitly say that we should not use recursion in\
    \ our code.\nThe code is pretty self-explanatory, and it's easy to generalize\
    \ it to solve other similar problems.\n\n\nA:\n\n<blockquote>\n<p>I mean, after\
    \ all, the professor did not explicitly say that we should not use recursion in\
    \ our code.</p>\n</blockquote>\nWell, recursion is a pretty fundamental algorithm\
    \ technique. It's pretty clear from his response that your professor intends to\
    \ teach you how to use recursion to solve problems.\n<blockquote>\n<p>I am just\
    \ curious, why would he want a worse code?</p>\n</blockquote>\nThis question is\
    \ a little difficult to answer because I don't know what your professor had in\
    \ mind or how he graded your code. I will take a shot at it and say that your\
    \ professor was probably looking for something like this:\n<code>(define (longest\
    \ strings)\n  (cond ((null? strings) #f)\n        ((null? (cdr strings)) (car\
    \ strings))\n        (else (if (&gt; (length (car strings)) (length (cadr strings)))\n\
    \                  (longest (cons (car strings) (cddr strings)))\n           \
    \       (longest (cons (cadr strings) (cddr strings)))))))\n</code>\nThis function\
    \ works with all", "  (cond [(empty? strings) #f]\n        [else (foldr (\u03BB\
    \ (a b) (if (> (string-length a) (string-length b)) a b))\n                  \
    \   (first strings)\n                     (rest strings))]))\n", "  (define (longest-helper\
    \ strings longest-found)\n    (cond [(empty? strings) longest-found]\n       \
    \   [(> (string-length (first strings)) (string-length longest-found))\n     \
    \      (longest-helper (rest strings) (first strings))]\n          [else (longest-helper\
    \ (rest strings) longest-found)]))\n  (if (empty? strings)\n      #f\n      (longest-helper\
    \ (rest strings) (first strings))))\n", "  (if (null? strings)\n      #f\n   \
    \   (let loop ((rest strings)\n                 (candidate (car strings)))\n \
    \       (if (null? rest)\n            candidate\n            (let ((next (car\
    \ rest)))\n              (if (&gt; (string-length next) (string-length candidate))\n\
    \                  (loop (cdr rest) next)\n                  (loop (cdr rest)\
    \ candidate)))))))\n</code>\n", "  (if (null? strings)\n      #f\n      (cond\
    \ ((null? (cdr strings))\n             (car strings))\n            ((> (string-length\
    \ (car strings))\n                (string-length (cadr strings)))\n          \
    \   (longest (cons (car strings) (cddr strings))))\n            (else\n      \
    \       (longest (cons (cadr strings) (cddr strings)))))))\n", "  (cond\n    [(empty?\
    \ strings) #f]\n    [(equal? (length (first strings)) (length (longest (rest strings))))\
    \ (first strings)]\n    [else (longest (rest strings))]))\n", "  (cond\n    [(empty?\
    \ strings) #f]\n    [(empty? (rest strings)) (first strings)]\n    [else\n   \
    \  (let* ([first (first strings)]\n            [rest (rest strings)]\n       \
    \     [longest-rest (longest rest)])\n       (if (< (string-length first) (string-length\
    \ longest-rest))\n           longest-rest\n           first))]))\n", "  (cond\n\
    \    [(empty? strings) #f]\n    [(empty? (rest strings)) (first strings)]\n  \
    \  [else\n     (let ([next (longest (rest strings))])\n       (if (&gt; (string-length\
    \ (first strings)) (string-length next))\n           (first strings)\n       \
    \    next))]))\n</code>\n", "  (cond\n    [(empty? strings)\n     #f]\n    [(empty?\
    \ (rest strings))\n     (first strings)]\n    [else\n     (longest-helper strings\n\
    \                     (first strings))]))\n", "  (cond\n    ((null? strings) #f)\n\
    \    ((= (length (first strings))\n        (length (apply max (map length strings))))\n\
    \     (first strings))))\n", "  (cond\n    [(empty? strings) (error \"List is\
    \ empty!\")]\n    [(null? (cdr strings)) (car strings)]\n    [else\n     (let*\
    \ ([s1 (car strings)]\n            [s2 (car (cdr strings))]\n            [s3 (longest\
    \ (cdr strings))])\n       (if (> (string-length s2) (string-length s1))\n   \
    \        (if (> (string-length s3) (string-length s2))\n               s3\n  \
    \             s2)\n           (if (> (string-length s3) (string-length s1))\n\
    \               s3\n               s1)))]))\n", "  (if (null? strings)\n     \
    \ #f\n      (let ([longest (car strings)])\n        (for ([str (cdr strings)])\n\
    \          (when (> (string-length str) (string-length longest))\n           \
    \ (set! longest str)))\n        longest)))\n", "  (cond\n    [(empty? strings)\
    \ #f]\n    [(empty? (rest strings)) (first strings)]\n    [else\n     (let ([longest-so-far\
    \ (first strings)]\n           [current-longest (longest (rest strings))])\n \
    \      (if (&gt; (string-length longest-so-far) (string-length current-longest))\n\
    \           longest-so-far\n           current-longest))]))\n</code>\n", "  (cond\
    \ [(empty? strings) #f]\n        [else\n         (apply max (map (compose length\
    \ string-&gt;symbol) strings))]))\n</code>\n", "  (if (null? strings)\n      #f\n\
    \      (reduce\n       (lambda (x y)\n         (if (> (string-length x) (string-length\
    \ y))\n             x\n             y))\n       strings)))\n", "  (foldl (lambda\
    \ (x acc) (if (&gt; (string-length x) (string-length acc)) x acc)) \n        \
    \ #f \n         strings))\n</code>\n", "  (cond [(empty? strings) #f]\n      \
    \  [else (let ( [len (length (first strings))]\n                     [current\
    \ (first strings)] )\n                 (for-each (lambda (e)\n               \
    \              (if (> (length e) len)\n                                 (set!\
    \ len (length e))\n                                 (set! current e) ) )\n   \
    \                        (rest strings) )\n                 current ) ] ) )\n",
  "  (if (null? strings)\n      #f\n      (define (longest-inner strings longest-seen)\n\
    \        (if (null? strings)\n            longest-seen\n            (if (> (string-length\
    \ (car strings)) (string-length longest-seen))\n                (longest-inner\
    \ (cdr strings) (car strings))\n                (longest-inner (cdr strings) longest-seen))))\n\
    \      (longest-inner (cdr strings) (car strings))))\n", "  (define (longest-internal\
    \ strings longest-so-far)\n    (cond ((null? strings) longest-so-far)\n      \
    \    ((< (string-length (car strings)) (string-length longest-so-far))\n     \
    \      (longest-internal (cdr strings) longest-so-far))\n          (else (longest-internal\
    \ (cdr strings) (car strings)))))\n  (if (null? strings)\n      #f\n      (longest-internal\
    \ (cdr strings) (car strings))))\n```\n\n```\n#lang racket\n", "  (cond [(empty?\
    \ strings) #f]\n        [else (reduce (lambda (longest-so-far next)\n        \
    \                (if (&gt; (string-length longest-so-far) (string-length next))\n\
    \                            longest-so-far\n                            next))\n\
    \                      strings)]))\n", "  (cond\n    [(empty? strings) #f]\n \
    \   [(= (length (first strings)) (length (longest (rest strings)))) (first strings)]\n\
    \    [(> (length (first strings)) (length (longest (rest strings)))) (first strings)]\n\
    \    [else (longest (rest strings))]))\n", "  (cond ((null? strings) #f)\n   \
    \     ((null? (cdr strings)) (car strings))\n        (else (let ((longest-tail\
    \ (longest (cdr strings))))\n                (if (> (string-length (car strings))\
    \ (string-length longest-tail))\n                    (car strings)\n         \
    \           longest-tail)))))\n", "  (cond ((empty? strings) #f)\n        ((null?\
    \ (cdr strings)) (car strings))\n        (else (let ((first (car strings))\n \
    \                   (rest (cdr strings)))\n                (if (&gt; (string-length\
    \ first) (string-length (longest rest)))\n                    first\n        \
    \            (longest rest))))))\n", "  (if (null? strings)\n      #f\n      (let\
    \ loop ((min-len (length (car strings)))\n                 (longest-str (car strings))\n\
    \                 (rest (cdr strings)))\n        (if (null? rest)\n          \
    \  longest-str\n            (let ((l (length (car rest))))\n              (if\
    \ (&gt; l min-len)\n                  (loop l (car rest) (cdr rest))\n       \
    \           (loop min-len longest-str (cdr rest))))))))\n</code>\nA different\
    \ approach is to sort the list of strings in decreasing order of length and return\
    \ the first one:\n<code>#lang racket\n", "  (if (null? strings)\n      #f\n  \
    \    (reduce max-length strings)))\n", "  (cond ((null? strings)\n         #f)\n\
    \        ((null? (cdr strings))\n         (car strings))\n        (else\n    \
    \     (if (> (string-length (car strings))\n                (string-length (longest\
    \ (cdr strings))))\n             (car strings)\n             (longest (cdr strings))))))\n",
  "  (cond\n    [(empty? strings) #f]\n    [(empty? (rest strings)) (first strings)]\n\
    \    [else\n     (cond\n       [(> (string-length (first strings)) (string-length\
    \ (longest (rest strings))))\n        (first strings)]\n       [else (longest\
    \ (rest strings))])]))\n", "  (cond\n    [(empty? strings) (error \"Empty input\"\
    )]\n    [(empty? (rest strings)) (first strings)]\n    [else\n     (let loop ([rest\
    \ strings] [lngest (first strings)])\n       (cond\n         [(empty? rest) lngest]\n\
    \         [(> (string-length (first rest)) (string-length lngest))\n         \
    \ (loop (rest rest) (first rest))]\n         [else (loop (rest rest) lngest)]))]))\n",
  "  (if (null? strings)\n      #f\n      (let loop ((strings strings)\n         \
    \        (longest (car strings)))\n        (if (null? strings)\n            longest\n\
    \            (let ((current (car strings)))\n              (if (> (string-length\
    \ current) (string-length longest))\n                  (loop (cdr strings) current)\n\
    \                  (loop (cdr strings) longest)))))))\n", "  (if (null? strings)\n\
    \      #f\n      (letrec\n        ([longest (lambda (l)\n                    \
    \  (if (null? (cdr l))\n                          (car l)\n                  \
    \        (if (> (string-length (car l)) (string-length (cadr l)))\n          \
    \                    (longest (cons (car l) (cddr l)))\n                     \
    \         (longest (cdr l)))))])\n        (longest strings))))\n</code>\nMy question\
    \ is, am I missing some built-in function in racket which can be used to implement\
    \ this exercise in a more elegant way?\n\n\nA:\n\nTL;DR: The simplest and most\
    \ idiomatic way to solve this problem is to use <code>for/fold</code>.\n\nThe\
    \ problem with your solution is that it's not tail-recursive.\nThe answer given\
    \ by @Alex Hars\xE1nyi can also be problematic if the input list is too large,\
    \ because it will build a potentially large intermediate list of pairs.\nAnother\
    \ option is to use <code>foldl</code>, but in this case it's not tail-recursive\
    \ either (or at least not by default), so it's not an improvement.\nMy personal\
    \ favorite solution is to use <code>for/fold</code>, this is a highly useful tool\
    \ when you need to accumulate the result of a loop that traverses a sequence.\n\
    <code>(define (longest strings)\n  (for/fold ([result #f])\n            ([s strings])\n\
    \            (if (or (null? result)\n                    (&gt; (string-length\
    \ s) (string-length result)))\n                s\n                result)))\n\
    </code>\n", "  (cond\n    ((null? strings) '())\n    ((null? (cdr strings)) (car\
    \ strings))\n    (else\n      (let ((longest-string (longest (cdr strings))))\n\
    \        (if (&gt; (string-length (car strings)) (string-length longest-string))\n\
    \            (car strings)\n            longest-string)))))\n</code>\nIs there\
    \ a better way to write this?\n\n\nA:\n\nUsually, a good starting point is to\
    \ find a pattern in the code that can be simplified and replaced with a more generic\
    \ solution. Here's a simple example:\n<code>(define (longest strings)\n  (cond\n\
    \    ((null? strings) '())\n    ((null? (cdr strings)) (car strings))\n    (else\n\
    \      (let ((longest-string (longest (cdr strings))))\n        (if (&gt; (string-length\
    \ (car strings)) (string-length longest-string))\n            (car strings)\n\
    \            longest-string)))))\n</code>\nThe repeated calls to <code>string-length</code>\
    \ can be simplified by creating a helper procedure:\n<code>(define (longest strings)\n\
    \  (cond\n    ((null? strings) '())\n    ((null? (cdr strings)) (car strings))\n\
    \    (else\n      (let ((longest-string (longest (cdr strings))))\n        (cond\n\
    \          ((&gt; (string-length (car strings)) (string-length longest-string))\n\
    \           (car strings))\n          (else longest-string))))))\n</code>\nThe\
    \ pattern used in <code>cond</code>'s predicate can be simplified by using <code>&gt;</code>'s\
    \ optional argument:\n<code>(define (longest strings)\n  (cond\n    ((null? strings)\
    \ '())\n    ((null? (cdr strings)) (car strings))\n    (else\n      (let ((longest-string\
    \ (longest (cdr strings))))\n        (cond\n          ((&gt; (string-length (car\
    \ strings))\n              (string-length longest-string)\n              (car\
    \ strings))\n           longest-string))))))\n</code>\nThen, since <code>cond</code>'s\
    \ predicate is", "  (if (null? strings)\n      #f\n      (define (longest-helper\
    \ strings longest-so-far)\n        (if (null? strings)\n            longest-so-far\n\
    \            (if (> (string-length (car strings)) (string-length longest-so-far))\n\
    \                (longest-helper (cdr strings) (car strings))\n              \
    \  (longest-helper (cdr strings) longest-so-far))))\n      (longest-helper (cdr\
    \ strings) (car strings))))\n", "  (cond\n    [(empty? strings) #f]\n    [(null?\
    \ (cdr strings)) (car strings)]\n    [else\n     (let ([curr (car strings)]\n\
    \           [rest (cdr strings)])\n       (if (> (string-length curr) (string-length\
    \ (longest rest)))\n           curr\n           (longest rest)))]))\n", "  (if\
    \ (null? strings)\n      #f\n      (reduce (lambda (s1 s2)\n                (if\
    \ (< (string-length s1) (string-length s2))\n                    s2\n        \
    \            s1))\n              strings)))\n", "  (cond\n    [(empty? strings)\
    \ #f]\n    [(and (empty? (rest strings)) (string? (first strings))) (first strings)]\n\
    \    [(and\n       (string? (first strings))\n       (string? (first (rest strings)))\n\
    \       (> (string-length (first strings)) (string-length (first (rest strings)))))\n\
    \     (longest (cons (first strings) (rest (rest strings))))]\n    [(and\n   \
    \    (string? (first strings))\n       (string? (first (rest strings)))\n    \
    \   (<= (string-length (first strings)) (string-length (first (rest strings)))))\n\
    \     (longest (cons (first (rest strings)) (rest (rest strings))))]\n    [else\n\
    \     (longest (rest strings))]))\n\n", "  (cond [(empty? strings) #f]\n     \
    \   [else (reduce (lambda (s1 s2)\n                        (if (&gt; (string-length\
    \ s1) (string-length s2))\n                            s1\n                  \
    \          s2))\n                      strings)]))\n", "  (let-values ([(longest-str\
    \ len)\n                (foldl (lambda (s1 s2)\n                         (let*\
    \ ([len1 (string-length s1)]\n                                [len2 (string-length\
    \ s2)])\n                           (if (> len1 len2) (values s1 len1) (values\
    \ s2 len2))))\n                       strings\n                       (list (car\
    \ strings) (string-length (car strings))))])\n    (if (zero? len) #f longest-str)))\n",
  "  (cond\n    ((null? strings)\n     #f)\n    ((null? (cdr strings))\n     (car\
    \ strings))\n    (else\n     (letrec\n         ((longest-tail\n           (lambda\
    \ (longest current rest)\n             (cond\n               ((null? rest)\n \
    \               longest)\n               ((> (string-length current) (string-length\
    \ longest))\n                (longest-tail current (car rest) (cdr rest)))\n \
    \              (else\n                (longest-tail longest (car rest) (cdr rest)))))))\n\
    \       (longest-tail (car strings) (car (cdr strings)) (cdr (cdr strings)))))))\n",
  "  (if (null? strings)\n      #f\n      (longest-t (car strings) (cdr strings))))\n",
  "  (cond\n    [(empty? strings) #f]\n    [(= (length (car strings)) (length (list-ref\
    \ strings 1))) (car strings)]\n    [else (longest (cdr strings))]))\n", "  (if\
    \ (null? strings)\n      #f\n      (for/fold ([longest-string (car strings)])\n\
    \                ([string (cdr strings)])\n                (if (&gt; (string-length\
    \ string) (string-length longest-string))\n                    string\n      \
    \              longest-string))))\n</code>\nAnd here is my attempt at the solution:\n\
    <code>#lang racket\n", "  (cond\n    ((null? strings) #f)\n    ((null? (cdr strings))\
    \ (car strings))\n    (else\n      (if (&gt; (string-length (car strings)) (string-length\
    \ (cadr strings)))\n        (longest (cons (car strings) (cddr strings)))\n  \
    \      (longest (cons (cadr strings) (cddr strings)))))))\n</code>\nI am not sure\
    \ if I am using the right functions, I am still new to this lisp and racket.\n\
    \n\nA:\n\nFirst, if you use <code>cadr</code> you can skip the <code>cddr</code>\
    \ in the recursive call.\nSecond, you can use <code>car</code> in the recursive\
    \ call, instead of recreating the list, as you are doing.\nThird, you can use\
    \ a local binding for the first element of the list and compare it to the first\
    \ element of the rest of the list.\nThus:\n<code>(define (longest strings)\n \
    \ (cond\n    ((null? strings) #f)\n    ((null? (cdr strings)) (car strings))\n\
    \    (else\n      (let ((first (car strings)))\n        (if (&gt; (string-length\
    \ first) (string-length (car (cdr strings))))\n            (longest (cons first\
    \ (cdr strings)))\n            (longest (cdr strings)))))))\n</code>\nThe initial\
    \ version called <code>string-length</code> on every element of the list in every\
    \ recursive call, while the version above calls it only on the first elements\
    \ of the list in every recursive call, which is more efficient.\nThen you can\
    \ go a step further and have a pair of local bindings for the first element of\
    \ the list and its length, and compare the length of the string, instead of the\
    \ string itself, to the first element of the rest of the list.\nThus:\n<code>(define\
    \ (longest strings)\n  (cond\n    ((null? strings) #f)\n    ((null? (cdr strings))\
    \ (car strings))\n    (else\n      (let ((first (car strings))\n            (first-length\
    \ (string-length first)))\n        (if (&gt; first-length (string-length (car\
    \ (cdr strings))))", "  (if (null? strings)\n      #f\n      (let ((longest-string\
    \ (car strings)))\n        (for ([item (cdr strings)])\n          (if (> (string-length\
    \ item) (string-length longest-string))\n              (set! longest-string item)))\n\
    \        longest-string)))\n", "  (cond\n    [(empty? strings) #f]\n    [(equal?\
    \ (length (first strings)) (length (longest (rest strings)))) (first strings)]\n\
    \    [else (longest (rest strings))]))\n", "  (cond ((null? strings) #f)\n   \
    \     ((null? (cdr strings)) (car strings))\n        (else (let ((string-lengths\
    \ (map (\u03BB (s) (string-length s)) strings)))\n                (let ((longest-index\
    \ (argmax string-lengths))\n                      (longest-length (list-ref string-lengths\
    \ longest-index)))\n                  (list-ref strings longest-index))))))\n",
  "  (if (null? strings)\n      #f\n      (if (null? (cdr strings))\n          (car\
    \ strings)\n          (if (&gt; (string-length (car strings)) (string-length (longest\
    \ (cdr strings))))\n              (car strings)\n              (longest (cdr strings))))))\n\
    </code>\nSo I tried to use the same algorithm in Haskell:\n<code>longest :: [[Char]]\
    \ -&gt; [Char]\nlongest [] = \"\"\nlongest (a:b:cs) = if (length a) &gt; (length\
    \ (longest cs)) then a else longest cs\n</code>\nThis works for the first 2 cases\
    \ but for the third one, it returns \"a\". I am not sure what I am doing wrong.\n\
    \n\nA:\n\n<code>longest (a:b:cs) = if (length a) &gt; (length (longest cs)) then\
    \ a else longest cs\n</code>\nYou need to drop <code>b</code> if you want to use\
    \ your algorithm, right now the recursion consumes only one element per call,\
    \ so the the longest element in <code>a:b:cs</code> will always be <code>a</code>.\n\
    <code>longest (a:cs) = if (length a) &gt; (length (longest cs)) then a else longest\
    \ cs\n</code>\n", "  (let ([first-string (first strings)])\n    (if (null? strings)\n\
    \        #f\n        (letrec ([longest-of-rest (lambda (next-string)\n       \
    \                             (if (null? next-string)\n                      \
    \                  first-string\n                                        (if (>\
    \ (string-length first-string) (string-length next-string))\n                \
    \                            (longest-of-rest (rest next-string))\n          \
    \                                  (longest-of-rest (rest next-string)))))])\n\
    \          (longest-of-rest (rest strings))))))\n", "  (if (null? strings)\n \
    \     #f\n      (define-values (maxmax max)\n        (for/fold ([max #f] [maxmax\
    \ 0]) ([s strings])\n          (if (> (string-length s) maxmax)\n            \
    \  (values (string-length s) s)\n              (values maxmax max))))\n      max))\n",
  "  (cond\n    [(empty? strings) #f]\n    [(empty? (rest strings)) (first strings)]\n\
    \    [else\n     (if (> (string-length (first strings)) (string-length (longest\
    \ (rest strings))))\n         (first strings)\n         (longest (rest strings)))]))\n\
    \n", "  (if (empty? strings)\n      #f\n      (for/fold ([longest-string (first\
    \ strings)])\n                ([string (in-list (rest strings))])\n        (if\
    \ (> (string-length string) (string-length longest-string))\n            string\n\
    \            longest-string))))\n", "  (match strings\n        [(list) #f]\n \
    \       [(list s) s]\n        [(list s1 s2)\n         (if (&gt; (string-length\
    \ s1) (string-length s2))\n             s1\n             s2)]\n        [(list\
    \ s1 s2 s3 . rest)\n         (cond\n           [(&gt; (string-length s1) (string-length\
    \ s2))\n            (longest (list s1 s3 . rest))]\n           [(&gt; (string-length\
    \ s2) (string-length s3))\n            (longest (list s2 s3 . rest))]\n      \
    \     [else\n            (longest (list s3 . rest))])]))\n</code>\nI feel that\
    \ there has to be a more idiomatic way to do it.\nP.S. It is the first time I\
    \ post a question on StackOverflow, so please forgive me if it is not what is\
    \ expected.\n\n\nA:\n\nYou can also use builtin procedures:\n<code>(define (longest\
    \ strings)\n  (if (null? strings)\n      #f\n      (car (reduce (lambda (x y)\
    \ (if (&gt; (string-length x) (string-length y)) x y))\n                   strings))))\n\
    </code>\n", "  (let loop ([strings strings]\n             [longest #f])\n    (cond\
    \ [(empty? strings) longest]\n          [(or (not longest) (> (string-length (first\
    \ strings)) (string-length longest)))\n           (loop (rest strings) (first\
    \ strings))]\n          [else (loop (rest strings) longest)])))\n", "  (cond\n\
    \    [(empty? strings) #f]\n    [(empty? (rest strings)) (first strings)]\n  \
    \  [else\n     (let ([longest-so-far (first strings)]\n           [rest-of-strings\
    \ (rest strings)])\n       (cond\n         [(&gt; (string-length longest-so-far)\
    \ (string-length (first rest-of-strings)))\n          (longest (cons longest-so-far\
    \ (rest rest-of-strings)))]\n         [else\n          (longest (cons (first rest-of-strings)\
    \ (rest rest-of-strings)))]))]))\n</code>\nHowever, this seems to be wrong because\
    \ it doesn't work as expected:\n<code>&gt; (longest (list ))\n#f\n&gt; (longest\
    \ (list \"a\" \"b\" \"c\"))\n\"a\"\n&gt; (longest (list \"a\" \"bb\" \"ccc\"))\n\
    \"ccc\"\n&gt; (longest (list \"a\" \"bb\" \"ccc\" \"dddd\"))\n\"ccc\"\n</code>\n\
    The issue seems to be that I am not correctly cons-ing the strings to form a new\
    \ list. Please see my solution for the same problem in Python here: longest.py\n\
    EDIT: I figured it out. Thanks to @Sylwester for commenting that I am not actually\
    \ cons-ing on the string, but on the length of the string. The fix was to replace\
    \ <code>(cons longest-so-far (rest rest-of-strings))</code> with <code>(cons (first\
    \ rest-of-strings) (cons longest-so-far (rest rest-of-strings)))</code> and <code>(cons\
    \ (first rest-of-strings) (rest rest-of-strings))</code> with <code>(cons longest-so-far\
    \ (cons (first rest-of-strings) (rest rest-of-strings)))</code>.\n", "  (if (empty?\
    \ strings)\n      #f\n      (define (max-length x y)\n        (if (> (string-length\
    \ x) (string-length y))\n            x\n            y))\n      (foldl max-length\
    \ (first strings) (rest strings))))\n", "  (if (null? strings)\n      #f\n   \
    \   (if (null? (cdr strings))\n          (car strings)\n          (if (&gt; (string-length\
    \ (car strings)) (string-length (longest (cdr strings))))\n              (car\
    \ strings)\n              (longest (cdr strings))))))\n</code>\nDoes it check\
    \ all the boxes of a typical good Racket code?\n\n\nA:\n\nI think you could have\
    \ a good start. If I were to check my code, these are the things I would look\
    \ for:\n\nConsistent indentation\nI'd say your indentation is alright. You should\
    \ make sure to indent at least 4 spaces per level, so the code is easier to read.\n\
    For example, this should be indented as:\n<code>(define (longest strings)\n  (if\
    \ (null? strings)\n      #f\n      (if (null? (cdr strings))\n          (car strings)\n\
    \          (if (&gt; (string-length (car strings)) (string-length (longest (cdr\
    \ strings))))\n              (car strings)\n              (longest (cdr strings))))))\n\
    </code>\nReading the code is a huge part of the learning experience. I'd suggest\
    \ you follow the standard indentation rules for Racket, so you can make your code\
    \ easier to read, not only for you, but for others that might read your code as\
    \ well.\nUse of <code>cond</code>\nTo make your code easier to read, I'd suggest\
    \ you use <code>cond</code> instead of nesting <code>if</code> expressions. It's\
    \ a matter of preference, but I think it makes your code a lot easier to read.\n\
    <code>(define (longest strings)\n  (cond\n    [(null? strings)\n     #f]\n   \
    \ [(null? (cdr strings))\n     (car strings)]\n    [else\n     (if (&gt; (string-length\
    \ (car strings)) (string-length (longest (cdr strings))))\n         (car strings)\n\
    \         (longest (cdr strings)))]))\n</code>\nYou can also make the code a bit\
    \ shorter by using the <code>cond</code> directly inside the <code>if</code> expression:\n\
    <code>(define (", "  (cond\n    [(empty? strings) #f]\n    [(empty? (rest strings))\
    \ (first strings)]\n    [else\n     (if (&gt; (string-length (first strings))\
    \ (string-length (longest (rest strings))))\n         (first strings)\n      \
    \   (longest (rest strings)))]))\n</code>\nNow, I have to make my custom <code>&gt;</code>\
    \ function only accept 2 arguments:\n<code>#lang racket\n", "  (cond ((null? strings)\
    \ #f)\n        ((null? (cdr strings)) (car strings))\n        (else (let ([longest-so-far\
    \ (longest (cdr strings))])\n                 (if (&gt; (string-length (car strings))\
    \ (string-length longest-so-far))\n                     (car strings)\n      \
    \               longest-so-far)))))\n</code>\n", "  (cond [(empty? strings) #f]\n\
    \        [else (foldl (lambda (string max-string)\n                       (if\
    \ (&gt; (string-length string) (string-length max-string))\n                 \
    \          string\n                           max-string))\n                 \
    \    (first strings)\n                     (rest strings))]))\n</code>\nFrom the\
    \ example, given a list of strings <code>strings</code>, we use <code>foldl</code>\
    \ to get the longest string among them and give it to the lambda function. The\
    \ lambda function compares it with the next string in the list and returns the\
    \ longer one. If the next string is longer, the lambda function uses the new string\
    \ instead of the previous one.\n", "  (define (longest-sub string1 string2)\n\
    \    (if (< (string-length string1) (string-length string2))\n        string2\n\
    \        string1))\n  (let loop ((strings strings) (acc \"\"))\n    (if (null?\
    \ strings)\n        acc\n        (loop (cdr strings) (longest-sub acc (car strings))))))\n\
    ```\n\n```\n#lang racket\n", "  (cond [(empty? strings) #f]\n        [else (apply\
    \ max (map string-length strings))]))\n</code>\n", "  (cond\n    [(empty? strings)\
    \ #f]\n    [(null? (cdr strings)) (car strings)]\n    [else\n     (let* ([longest-tail\
    \ (longest (cdr strings))]\n            [longest-head (car strings)])\n      \
    \ (if (> (string-length longest-head) (string-length longest-tail))\n        \
    \   longest-head\n           longest-tail))]))\n", "  (if (null? strings)\n  \
    \    #f\n      (apply max (map string-length strings))))\n", "  (cond [(empty?\
    \ strings) #f]\n        [else (reduce longest-1 (rest strings) (first strings))]))",
  "  (cond [(empty? strings) #f]\n        [else\n         (foldl (lambda (s1 s2)\n\
    \                  (if (&gt; (string-length s1) (string-length s2))\n        \
    \              s1\n                      s2))\n                (first strings)\n\
    \                (rest strings))]))\n</code>\nThe only thing that I'm not sure\
    \ about is the <code>if</code> statement. Racket's if statement seems to require\
    \ at least one argument. So, I just used <code>true</code> as the argument here.\n\
    \n\nA:\n\nYour code is a bit hard to read, though it is correct.  I think that\
    \ <code>cond</code> is not the best way to handle this situation.  Rather than\
    \ checking if the list is empty, you can check if it has only one element, and\
    \ the that element can be returned.  This makes it easier to read.\nThe <code>if</code>\
    \ statement doesn't need the true value, and you can use <code>&gt;</code> with\
    \ strings.\n<code>(define (longest strings)\n  (cond [(empty? strings) #f]\n \
    \       [(empty? (rest strings)) (first strings)]\n        [else\n         (foldl\
    \ (lambda (s1 s2)\n                  (if (&gt; s1 s2)\n                      s1\n\
    \                      s2))\n                (first strings)\n               \
    \ (rest strings))]))\n</code>\nOr more concisely:\n<code>(define (longest strings)\n\
    \  (cond [(empty? strings) #f]\n        [(empty? (rest strings)) (first strings)]\n\
    \        [else\n         (foldl (lambda (s1 s2)\n                  (if (&gt; s1\
    \ s2)\n                      s1\n                      s2))\n                (first\
    \ strings)\n                (rest strings))]))\n</code>\n", "  (cond\n    [(empty?\
    \ strings) #f]\n    [(null? (cdr strings)) (car strings)]\n    [else\n     (cond\n\
    \       [(> (string-length (car strings)) (string-length (cadr strings)))\n  \
    \      (longest (cons (car strings) (cddr strings)))]\n       [else (longest (cons\
    \ (cadr strings) (cddr strings)))]\n       )]\n    ))\n", "  (cond ((null? strings)\
    \ #f)\n        ((null? (cdr strings)) (car strings))\n        (else (if (> (string-length\
    \ (car strings)) (string-length (longest (cdr strings))))\n                  (car\
    \ strings)\n                  (longest (cdr strings))))))", "  (let loop ([strings\
    \ strings]\n             [maxStr #f])\n    (if (null? strings)\n        maxStr\n\
    \        (let ([currentStr (car strings)])\n          (if (or (null? maxStr)\n\
    \                  (< (string-length currentStr) (string-length maxStr)))\n  \
    \            (loop (cdr strings) currentStr)\n              (loop (cdr strings)\
    \ maxStr))))))\n\n\n", "  (cond ((empty? strings) #f)\n        ((empty? (rest\
    \ strings)) (first strings))\n        (else (if (> (string-length (first strings))\
    \ (string-length (second strings)))\n                  (longest (cons (first strings)\
    \ (rest (rest strings))))\n                  (longest (cons (second strings) (rest\
    \ (rest strings))))))))\n", "  (cond ((null? strings) #f)\n        ((null? (cdr\
    \ strings)) (car strings))\n        (else (let ((first (car strings))\n      \
    \              (rest (cdr strings)))\n                (if (> (string-length first)\
    \ (string-length (longest rest)))\n                    first\n               \
    \     (longest rest))))))\n", "  (if (empty? strings)\n      #f\n      (define\
    \ first-string (first strings))\n      (define longest-so-far first-string)\n\
    \      (for ([item (in-list (rest strings))])\n        (if (> (string-length item)\
    \ (string-length longest-so-far))\n            (set! longest-so-far item)))\n\
    \      longest-so-far))\n", "  (if (empty? strings)\n      #f\n      (let ((first\
    \ (first strings))\n            (rest (rest strings)))\n        (if (empty? rest)\n\
    \            first\n            (let ((longest-rest (longest rest)))\n       \
    \       (if (< (string-length first) (string-length longest-rest))\n         \
    \         longest-rest\n                  first))))))\n\n", "  (cond [(empty?\
    \ strings) #f]\n        [else (first (sort (compose length string>) strings))]))\n",
  "  (if (null? strings)\n      #f\n      (letrec ([longest-so-far (car strings)]\n\
    \               [f (lambda (s)\n                    (when (> (string-length s)\
    \ (string-length longest-so-far))\n                      (set! longest-so-far\
    \ s)))])\n        (for-each f strings)\n        longest-so-far)))\n", "  (if (null?\
    \ strings)\n      #f\n      (let loop ((strings strings)\n                 (longest-so-far\
    \ (car strings)))\n        (if (null? strings)\n            longest-so-far\n \
    \           (if (> (string-length (car strings)) (string-length longest-so-far))\n\
    \                (loop (cdr strings) (car strings))\n                (loop (cdr\
    \ strings) longest-so-far))))))\n```\n\n```racket\n#lang racket\n", "  (cond ((null?\
    \ strings) #f)\n        ((null? (cdr strings)) (car strings))\n        (else (if\
    \ (> (string-length (car strings)) (string-length (cadr strings)))\n         \
    \         (longest (cons (car strings) (cddr strings)))\n                  (longest\
    \ (cons (cadr strings) (cddr strings)))))))\n", "  (cond ((null? strings) #f)\n\
    \        ((null? (cdr strings)) (car strings))\n        (else (let ([ls (longest\
    \ (cdr strings))])\n                 (if (&gt; (string-length (car strings)) (string-length\
    \ ls))\n                     (car strings)\n                     ls)))))\n</code>\n",
  "  (if (empty? strings)\n      #f\n      (cond ((empty? (rest strings)) (first strings))\n\
    \            ((> (string-length (first strings)) (string-length (longest (rest\
    \ strings))))\n             (first strings))\n            (else (longest (rest\
    \ strings))))))\n", "  (if (null? strings)\n      #f\n      (longest/helper strings\n\
    \                      (first strings))))\n", "  (if (empty? strings)\n      #f\n\
    \      (foldl (lambda (a b)\n               (if (> (string-length a) (string-length\
    \ b))\n                   a\n                   b))\n             (first strings)\n\
    \             (rest strings))))", "  (cond ((null? strings) #f)\n        ((null?\
    \ (cdr strings)) (car strings))\n        (else (if (> (string-length (car strings))\
    \ (string-length (cadr strings)))\n                  (longest (cons (car strings)\
    \ (cddr strings)))\n                  (longest (cons (cadr strings) (cddr strings)))))))\n",
  "  (foldl \n   (lambda (s1 s2) (if (&gt; (string-length s1) (string-length s2))\
    \ s1 s2))\n   (car strings)\n   (cdr strings)))\n", "  (if (empty? strings)\n\
    \      #f\n      (let ((longest (first strings)))\n        (for-each (lambda (s)\n\
    \                    (if (> (string-length s) (string-length longest))\n     \
    \                   (set! longest s)))\n                  (rest strings))\n  \
    \      longest)))\n", "  (cond\n    [(empty? strings) #f]\n    [(= (length (first\
    \ strings)) (length (second strings))) (first strings)]\n    [(> (length (first\
    \ strings)) (length (second strings))) (longest (cons (first strings) (rest (rest\
    \ strings))))]\n    [else (longest (cons (second strings) (rest (rest strings))))]))\n\
    ```\n\n## \u8AB2\u984C\n\n1. \u30D0\u30B0\u3068\u306F\u306A\u306B\u304B\n2. \u30B3\
    \u30FC\u30C9\u306B\u30D0\u30B0\u304C\u3042\u308B\u3053\u3068\u3092\u767A\u898B\
    \u3059\u308B\u306B\u306F\u3069\u3046\u3059\u308C\u3070\u3088\u3044\u304B\n3. \u30B3\
    \u30FC\u30C9\u306B\u30D0\u30B0\u304C\u3042\u308B\u5834\u5408\u306B\u3001\u4FEE\
    \u6B63\u3059\u308B\u306B\u306F\u3069\u3046\u3059\u308C\u3070\u3088\u3044\u304B",
  "  (if (null? strings)\n      #f\n      (let loop ((current (car strings))\n   \
    \              (rest (cdr strings)))\n        (if (null? rest)\n            current\n\
    \            (if (> (string-length current) (string-length (car rest)))\n    \
    \            (loop current (cdr rest))\n                (loop (car rest) (cdr\
    \ rest)))))))\n", "  (cond\n    [(empty? strings)\n     #f]\n    [(= (length (first\
    \ strings)) (length (longest (rest strings))))\n     (first strings)]\n    [else\n\
    \     (longest (rest strings))]))\n", "  (if (empty? strings)\n      #f\n    \
    \  (local [(define (longest-loop items longest-sofar)\n                (if (empty?\
    \ items)\n                    longest-sofar\n                    (local [(define\
    \ (current-is-longer? item)\n                              (if (&gt; (string-length\
    \ item) (string-length longest-sofar))\n                                  #t\n\
    \                                  #f))]\n                          (longest-loop\
    \ (rest items)\n                                        (if (current-is-longer?\
    \ (first items))\n                                            (first items)\n\
    \                                            longest-sofar)))))\n            \
    \  ]\n        (longest-loop (rest strings) (first strings)))))\n</code>\nI guess\
    \ that a recursive solution is possible but I don't know if I can use tail call\
    \ optimization in this case. Also I guess that a non-recursive solution would\
    \ be possible but in that case, I'm missing a list to walk over.\nAlso, I'm not\
    \ sure if I should use <code>max</code> with some <code>map</code> or <code>filter</code>\
    \ usage.\nAny help?\n\n\nA:\n\nI'm not sure what you're asking for. If you're\
    \ just looking for the length of the longest string, the code is simple.\n<code>(define\
    \ (longest-string strings)\n  (if (null? strings)\n      -1\n      (max (string-length\
    \ (car strings))\n           (longest-string (cdr strings)))))\n</code>\nIf you\
    \ want to get the string itself, then you need to keep track of that, too. It's\
    \ a little more complicated, but not by much.\n<code>(define (longest-string strings)\n\
    \  (if (null? strings)\n      (values -1 \"\")\n      (let ((len (string-length\
    \ (car strings))))\n        (if (&gt; len (length (cdr strings)))\n          \
    \  (values len (car strings))\n            (let-values (((len str) (longest-string\
    \ (cdr strings))))\n              (values len str))))))\n</code>\nI don't see\
    \ how either of these solutions requires using <code>filter</code> or <code>map</code>\
    \ (unless you're using this exercise as a", "  (if (null? strings)\n      #f\n\
    \      (apply max-length strings)))\n", "  (if (empty? strings)\n      #f\n  \
    \    (foldl (lambda (longest-so-far str)\n               (if (&gt; (string-length\
    \ str) (string-length longest-so-far))\n                   str\n             \
    \      longest-so-far))\n             (first strings)\n             (rest strings))))\n\
    </code>\n", "  (if (empty? strings)\n      #f\n      (let* ((len (length (first\
    \ strings)))\n             (fst (first strings))\n             (my (lambda (xs\
    \ len)\n                   (if (empty? xs)\n                       fst\n     \
    \                  (let* ((xs-len (length (first xs)))\n                     \
    \         (xs-str (first xs)))\n                         (if (> xs-len len)\n\
    \                             (my (rest xs) xs-len)\n                        \
    \     (my (rest xs) len)))))))\n        (my (rest strings) len))))\n", "  (cond\n\
    \    [(empty? strings) #f]\n    [(= (length (first strings)) (length (longest\
    \ (rest strings)))) (first strings)]\n    [(> (length (first strings)) (length\
    \ (longest (rest strings)))) (first strings)]\n    [else (longest (rest strings))]))\n",
  "  (cond\n    [(empty? strings) #f]\n    [(= (length (first strings)) (apply max\
    \ (map length strings))) (first strings)]\n    [else (longest (rest strings))]))\n",
  "  (if (null? strings)\n      #f\n      (let ([longest-one (car strings)])\n   \
    \     (for ([s (cdr strings)])\n          (when (> (string-length s) (string-length\
    \ longest-one))\n            (set! longest-one s)))\n        longest-one)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
