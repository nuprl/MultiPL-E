name: HumanEval_79_decimal_to_binary
language: rkt
prompt: "#lang racket\n\n;; You will be given a number in decimal form and your task\
  \ is to convert it to\n;; binary format. The function should return a string, with\
  \ each character representing a binary\n;; number. Each character in the string\
  \ will be '0' or '1'.\n;; There will be an extra couple of characters 'db' at the\
  \ beginning and at the end of the string.\n;; The extra characters are there to\
  \ help with the format.\n;; Examples:\n;; >>> (decimal_to_binary 15)\n;; \"db1111db\"\
  \n;; >>> (decimal_to_binary 32)\n;; \"db100000db\"\n(define (decimal_to_binary decimal)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate decimal_to_binary))\n\
  \    (check-equal? (candidate 0) \"db0db\")\n    (check-equal? (candidate 32) \"\
  db100000db\")\n    (check-equal? (candidate 103) \"db1100111db\")\n    (check-equal?\
  \ (candidate 15) \"db1111db\")\n))\n\n(test-humaneval)"
completions: ["  (number->string\n   (string->number\n    (string-append \"db\"\n\
    \                   (number->string (exact->inexact\n                        \
    \            (integer->exact (log2 (string->number decimal)))))\n            \
    \       \"db\"))))\n", "  (string-append \"db\" (number->string decimal 2) \"\
    db\"))\n", "  (define (helper decimal)\n    (if (= decimal 0)\n        (list)\n\
    \        (append (helper (quotient decimal 2)) (list (modulo decimal 2)))))\n\
    \  (string-append \"db\" (number->string (reverse (helper decimal))) \"db\"))\n",
  "  \"Given a decimal number, return a string with each character representing a\
    \ binary number.\"\n  (let loop ((decimal decimal)\n             (string \"db\"\
    ))\n    (if (zero? decimal)\n        (string-append string \"db\")\n        (loop\
    \ (quotient decimal 2)\n              (string-append string (number->string (remainder\
    \ decimal 2)))))))\n```\n\nOutput:\n\n```\n> (decimal_to_binary 100)\n\"db1100100db\"\
    \n> (decimal_to_binary 15)\n\"db1111db\"\n> (decimal_to_binary 32)\n\"db100000db\"\
    \n```\n\nHere is a test suite:\n\n```racket\n#lang racket\n", "  (string-append\
    \ \"db\"\n                 (cond\n                   [(zero? decimal) \"\"]\n\
    \                   [else (string-append (decimal_to_binary (quotient decimal\
    \ 2))\n                                        (number->string (remainder decimal\
    \ 2)))])\n                 \"db\"))", '  (number->string (string->number (number->string
    decimal) 2)))', "  (string-append \"db\"\n                 (number->string decimal\
    \ 2)\n                 \"db\"))\n", "  (string-append \"db\" (number->string decimal\
    \ 2) \"db\"))\n", "  (string-append \"db\"\n\t\t (number->string (integer->decimal-string\
    \ decimal 2))\n\t\t \"db\"))\n", "  (string-append \"db\" (number->string decimal\
    \ 2) \"db\"))\n", "  (string-append \"db\" (number->string decimal 2) \"db\"))\n",
  "  (define (decimal_to_binary-aux number acc)\n    (if (= number 0)\n        (string-append\
    \ \"db\" acc \"db\")\n        (decimal_to_binary-aux (/ number 2) (string-append\
    \ (number->string (remainder number 2)) acc))))\n  (decimal_to_binary-aux decimal\
    \ \"\"))\n", "  (string-append \"db\"\n                 (integer->string decimal\
    \ 2)\n                 \"db\"))\n", "  (string-append \"db\"\n               \
    \  (if (= decimal 0)\n                     \"0\"\n                     (let loop\
    \ ((decimal decimal)\n                                (binary \"\"))\n       \
    \                (if (= decimal 0)\n                           binary\n      \
    \                     (loop (quotient decimal 2)\n                           \
    \      (string-append (number->string (remainder decimal 2))\n               \
    \                                 binary))))))\n                 \"db\"))\n",
  "  (string-append \"db\" (number->string decimal 2) \"db\"))\n", "  (string-append\
    \ \"db\" (number->string decimal 2) \"db\"))\n", "  (string-append \"db\"\n  \
    \               (integer->string (integer->binary decimal))\n                \
    \ \"db\"))\n```\n\n## Solution\n\n```racket\n#lang racket\n", "  (number->string\
    \ (number->string (integer->char (string->number (string-append \"0b\" (int-&gt;bits\
    \ decimal)) 2)) 16)))\n", "  (define (int-&gt;string n)\n    (if (= n 0)\n   \
    \     \"\"\n        (int-&gt;string (- n 1))\n        (number-&gt;string n)))\n\
    \  (string-append \"db\" (int-&gt;string decimal) \"db\"))\n", "  (string-append\
    \ \"db\" (number->string decimal 2) \"db\"))\n", "  (string-append \"db\"\n  \
    \               (number->string decimal 2)\n                 \"db\"))\n", "  (list->string\
    \ (reverse (list-&gt;string (append '(#\\d #\\b) (decimal-&gt;string decimal 0\
    \ 2) '(#\\d #\\b))))))\n", "  (define (decimal_to_binary_helper decimal)\n   \
    \ (cond\n      [(= decimal 0) \"\"]\n      [else (append (decimal_to_binary_helper\
    \ (quotient decimal 2)) (string (modulo decimal 2)))]))\n  (append \"db\" (decimal_to_binary_helper\
    \ decimal) \"db\"))", "  (string-append \"db\" (integer->string decimal 2) \"\
    db\"))\n", "  (string-append \"db\"\n                 (integer->string (integer->char\
    \ (string->number (string-append \"0b\" (number->string decimal)))) \"binary\"\
    )\n                 \"db\"))\n```\n\n```lisp", "  (string-append \"db\" (number->string\
    \ decimal 2) \"db\"))\n```\n\nRUN\n```\n\"db1111db\"\n\"db100000db\"\n```\n\n\
    ## to-radix\n\nGiven a number and an integer, return a string that represents\
    \ the number in radix form (base = integer)\n\n```\n#lang racket\n", "  (define\
    \ (d-t-b n)\n    (cond\n      [(= n 0) \"\"]\n      [else\n       (string (remainder\
    \ n 2))\n       (d-t-b (quotient n 2))]))\n  (string-append \"db\" (d-t-b decimal)\
    \ \"db\"))\n", "  (string-append \"db\"\n                 (number->string (quotient\
    \ decimal 2))\n                 \"db\"))\n", "  (string-append \"db\" (apply string\
    \ (reverse (let loop ([n (exact->inexact (/ decimal 2))] [l '()])\n          \
    \                                      (if (= n 0)\n                         \
    \                           l\n                                              \
    \      (loop (exact->inexact (/ n 2)) (cons (if (= n (* 2 (exact->inexact (/ n\
    \ 2))))\n                                                                    \
    \                           #\\0\n                                           \
    \                                                    #\\1)\n                 \
    \                                                                          l))))))\n\
    \                 \"db\"))\n```\n\n## [Unicode converter](https://www.codewars.com/kata/unicode-converter)\n\
    \n```racket\n#lang racket\n", "  (string-append \"db\"\n                 (number->string\
    \ (string->number (number->string (convert-number-to-binary decimal) 2) 10))\n\
    \                 \"db\"))", "  \"Convert decimal to binary, returning a string.\"\
    \n  (string-append \"db\" (integer->string decimal 2) \"db\"))\n", "  (format\
    \ \"db~adb\" (number->string decimal 2)))\n", "  (string-append \"db\" (integer->string\
    \ decimal 2) \"db\"))\n```\n\n```racket\n#lang racket\n", "  (define (helper x)\n\
    \    (if (= x 0)\n        \"\"\n        (string-append (helper (/ x 2)) (number->string\
    \ (% x 2)))))\n  (string-append \"db\" (helper decimal) \"db\"))\n", "  (list->string\
    \ (cons #\\d (cons #\\b (reverse (binary-string-list (quotient decimal 2) (list\
    \ (remainder decimal 2))))))))\n", "    (string-append \"db\"\n              \
    \     (reverse\n                    (let loop ((decimal decimal)\n           \
    \                    (binary (list)))\n                      (cond ((&lt; decimal\
    \ 2) (cons #\\0 binary))\n                            ((= decimal 2) (cons #\\\
    1 binary))\n                            (else (loop (quotient decimal 2)\n   \
    \                                     (cons (if (odd? decimal) #\\1 #\\0) binary))))))\n\
    \                   \"db\"))\n", "  (string-append \"db\" (number->string decimal\
    \ 2) \"db\"))\n", "  (string-append \"db\" (number->string decimal 2) \"db\"))\n",
  "  (string-append \"db\" (number->string decimal 2) \"db\"))\n", "  (string-append\
    \ \"db\"\n                 (integer->string decimal 2)\n                 \"db\"\
    ))\n", "  (let ((binary (number->string decimal 2)))\n    (string-append \"db\"\
    \ binary \"db\")))\n", "    (display (string-append \"db\" (integer->string (string->number\
    \ (number->string decimal 2))) \"db\")))\n", "  (string-append \"db\" (number->string\
    \ decimal 2) \"db\"))\n", "  (cond [(= decimal 0) \"db0db\"]\n        [else (string-append\
    \ \"db\" (decimal_to_binary (- decimal (logand decimal 1))))]))\n</code>\nI don't\
    \ know why but my logic is not working well.\nFor example, it passes this test:\n\
    <code>(check-equal? (decimal_to_binary 10) \"db1010db\")\n</code>\nBut it fails\
    \ this one:\n<code>(check-equal? (decimal_to_binary 31) \"db11111db\")\n</code>\n\
    How can I improve my code?\n\n\nA:\n\nThe conversion of decimal to binary is not\
    \ what you wrote, you have to divide the number by 2 and keep the remainders until\
    \ you reach 0. And then reverse the order of the remainders.\nAn example of this\
    \ algorithm in Racket is:\n<code>(define (to-binary n)\n  (if (zero? n)\n    \
    \  '()\n      (cons (remainder n 2) (to-binary (quotient n 2)))))\n</code>\nAnd\
    \ then you can join the result in a string:\n<code>(string-append \"db\" (apply\
    \ string-append (reverse (to-binary 31))) \"db\")", "  (define (aux acc n)\n \
    \   (cond ((= n 0) acc)\n          ((= n 1) (string-append \"1\" acc))\n     \
    \     (else (aux (string-append acc\n                                    (number->string\
    \ (remainder n 2)))\n                     (quotient n 2)))))\n  (string-append\
    \ \"db\" (aux \"\" decimal) \"db\"))\n", '  (string-append "db" (number->string
    decimal 2) "db"))', "  (string-append \"db\"\n                 (number->string\
    \ (integer->char-list decimal #2))\n                 \"db\"))", "  (string-append\
    \ \"db\" (number->string decimal 2) \"db\"))\n", "  (cond\n    [(= decimal 0)\n\
    \     \"db0db\"]\n    [else\n     (string-append\n      \"db\"\n      (number->string\
    \ decimal)\n      \"db\")]))\n", "  (define (decimal-to-binary-helper dec)\n \
    \   (cond ((= dec 0) \"\")\n          ((= dec 1) \"1\")\n          (else (string-append\
    \ (decimal-to-binary-helper (quotient dec 2))\n                              \
    \ (number->string (remainder dec 2))))))\n  (string-append \"db\" (decimal-to-binary-helper\
    \ decimal) \"db\"))\n", "  (display \"db\")\n  (decimal-&gt;binary-string-rec\
    \ decimal)\n  (display \"db\")\n  (newline))\n", "  (let ([binary (number->string\
    \ decimal 2)])\n    (string-append \"db\" binary \"db\")))\n", "  (string-append\
    \ \"db\"\n                 (number->string decimal 2)\n                 \"db\"\
    ))\n", "  (let ((result (number->string decimal 2)))\n    (string-append \"db\"\
    \ result \"db\")))\n", "  (string-append \"db\" (number->string decimal 2) \"\
    db\"))\n", "  (string-append \"db\"\n                 (integer->string\n     \
    \             (string->integer\n                   (number->string\n         \
    \           (truncate (string->number\n                               (substring\
    \ (integer->string\n                                           (string->integer\n\
    \                                            (number->string\n               \
    \                              (expt 2 32))))\n                              \
    \            1)\n                               (substring (integer->string\n\
    \                                           (string->integer\n               \
    \                             (number->string\n                              \
    \               (expt 2 32))))\n                                          0 1))))\n\
    \                               decimal)))\n                 \"db\"))\n", "  (string-append\
    \ \"db\" (integer->string decimal 2) \"db\"))\n", "  (string-append \"db\" (number->string\
    \ decimal 2) \"db\"))\n", "  (string-append \"db\" (integer->string decimal 2)\
    \ \"db\"))\n", "  (define (reverse ls)\n    (cond\n      [(empty? ls) empty]\n\
    \      [else (append (reverse (rest ls)) (list (first ls)))]))\n  (define (part-decimal-to-binary\
    \ decimal)\n    (cond\n      [(= decimal 0) empty]\n      [(< decimal 2) (list\
    \ decimal)]\n      [else (append (part-decimal-to-binary (quotient decimal 2))\
    \ (list (remainder decimal 2)))]))\n  (string-append \"db\" (list->string (reverse\
    \ (part-decimal-to-binary decimal))) \"db\"))", "  (let loop ((decimal decimal)\n\
    \             (accumulator \"\"))\n    (cond\n      ((= decimal 0) (string-append\
    \ \"db\" accumulator \"db\"))\n      (else (loop (quotient decimal 2)\n      \
    \            (string-append (number->string (remainder decimal 2)) accumulator))))))\n",
  "  (string-append \"db\" (number->string decimal 2) \"db\"))\n", "  (string-append\
    \ \"db\"\n                 (if (zero? decimal)\n                     #f\n    \
    \                 (string-reverse\n                      (string-append (decimal_to_binary\
    \ (quotient decimal 2))\n                                     (number->string\
    \ (remainder decimal 2)))))\n                 \"db\"))\n", "  (string-append \"\
    db\"\n                 (integer->string\n                  (integer-valued-quotient\
    \ decimal 2))\n                 \"db\"))\n", "  (cond\n    [(= decimal 0) \"db0db\"\
    ]\n    [else (string-append \"db\" (reverse (binary_helper decimal 0)) \"db\"\
    )]))\n", "  (string-append \"db\" (integer->string decimal 2) \"db\"))\n", " \
    \ (string-append \"db\"\n                 (number->string (integer->exact-integer\
    \ (expt 2 decimal)))\n                 \"db\"))\n", "  (string-append \"db\" (number->string\
    \ decimal 2) \"db\"))\n```\n\n### Testing\n\nI'm going to be honest, my testing\
    \ skills are a little rusty. I haven't done any in this repository.\nThat said,\
    \ I created a few functions to help with testing.\n\nIf you want to run your own\
    \ tests, you can define them in a file like `test.rkt` and evaluate them\nwith\
    \ `test/eval`. The function accepts a number of files as arguments and runs them\
    \ one after the\nother.\n\n```racket\n#lang racket\n", "  (string-append \"db\"\
    \n                 (number->string decimal 2)\n                 \"db\"))\n", " \
    \ (local ((define db \"db\"))\n    (string-append db (decimal->binary decimal\
    \ #:base 2) db)))\n", "  (define (repeat s n)\n    (if (= n 0) '()\n        (cons\
    \ s (repeat s (- n 1)))))\n  (string-append\n   \"db\"\n   (apply string-append\n\
    \          (for/list ([c (repeat \"0\" (- decimal 1))])\n            (string-append\
    \ \"1\" c)))\n   \"db\"))\n", "  (string-append \"db\" (number->string decimal\
    \ 2) \"db\"))\n```\n\n```racket\n#lang racket\n", "  (letrec ((d2b\n         \
    \   (lambda (dec)\n              (cond\n                [(< dec 2) dec]\n    \
    \            (else (let ([bin (d2b (/ dec 2))])\n                        (string-append\
    \ (number->string (modulo dec 2)) bin)))))))\n    (let ([bin (d2b decimal)])\n\
    \      (string-append \"db\" bin \"db\"))))\n", "  (string-append \"db\"\n   \
    \              (number->string (inexact->exact (floor (expt 2 decimal))))\n  \
    \               \"db\"))\n", "  (let* ([binary (list->string (reverse (decimal-&gt;binary\
    \ decimal)))]\n         [db (string \"db\")])\n    (if (string=? binary \"\")\n\
    \        (string-append db \"0\" db)\n        (string-append db binary db))))\n",
  "  (define (iter-decimal_to_binary decimal num-str)\n    (if (eq? decimal 0) (string-append\
    \ \"db\" num-str \"db\")\n        (iter-decimal_to_binary (quotient decimal 2)\
    \ (string-append num-str (number->string (remainder decimal 2))))))\n  (iter-decimal_to_binary\
    \ decimal \"\"))\n", "  (cond [(zero? decimal) \"db0db\"]\n        [else (append\
    \ (decimal_to_binary (quotient decimal 2))\n                      (list (integer->char\
    \ (+ 48 (remainder decimal 2)))))]))", "  (format \"db~a\" (integer->binary decimal)))\n\
    ```\n\n### Python:\n\n```python\n# You will be given a number in decimal form\
    \ and your task is to convert it to\n# binary format. The function should return\
    \ a string, with each character representing a binary\n# number. Each character\
    \ in the string will be '0' or '1'.\n# There will be an extra couple of characters\
    \ 'db' at the beginning and at the end of the string.\n# The extra characters\
    \ are there to help with the format.\n# Examples:\n# >>> decimal_to_binary(15)\n\
    # \"db1111db\"\n# >>> decimal_to_binary(32)\n# \"db100000db\"\ndef decimal_to_binary(decimal):\n\
    \    return \"db\" + bin(decimal)[2:] + \"db\"\n```\n\n### Ruby:\n\n```ruby\n\
    # You will be given a number in decimal form and your task is to convert it to\n\
    # binary format. The function should return a string, with each character representing\
    \ a binary\n# number. Each character in the string will be '0' or '1'.\n# There\
    \ will be an extra couple of characters 'db' at the beginning and at the end of\
    \ the string.\n# The extra characters are there to help with the format.\n# Examples:\n\
    # >>> decimal_to_binary(15)\n# \"db1111db\"\n# >>> decimal_to_binary(32)\n# \"\
    db100000db\"\ndef decimal_to_binary(decimal)\n  \"db\" + decimal.to_s(2) + \"\
    db\"\nend\n```\n\n### Javascript:\n\n```javascript\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"\
    db100000db", "  (string-append \"db\" (number->string decimal 2) \"db\"))\n",
  "    (string-append \"db\" (number->string decimal 2) \"db\"))\n", '  (string-append
    "db" (number->string decimal 2) "db"))', "\t(string-append \"db\" (number->string\
    \ (logand decimal 65535)) \"db\"))\n", "  (string-append \"db\" (number->string\
    \ decimal 2) \"db\"))\n", "  (string-append \"db\"\n                 (number->string\
    \ (integer->exact-integer (expt 2 (if (zero? decimal) 0 (floor (log 2 decimal))))))\n\
    \                 \"db\"))\n", "  (string-append \"db\" (integer->string decimal\
    \ 2) \"db\"))\n", "  (string-append \"db\" (number->string decimal 2) \"db\"))\n",
  "  (local ((define (decimal_to_binary-iter d acc)\n            (if (zero? d)\n \
    \               (list->string (reverse acc))\n                (decimal_to_binary-iter\
    \ (quotient d 2) (cons (remainder d 2) acc)))))\n    (string-append \"db\" (decimal_to_binary-iter\
    \ decimal '()) \"db\")))\n", "  (string-append \"db\" (number->string decimal\
    \ 2) \"db\"))\n", "  (string-append \"db\" (let loop ((decimal decimal) (result\
    \ \"\"))\n                      (cond ((= decimal 0) result)\n               \
    \             (else (loop (quotient decimal 2) (string-append (string (modulo\
    \ decimal 2)) result)))))))", "  (string-append \"db\"\n                 (number->string\
    \ decimal 2)\n                 \"db\"))\n", "  (let ([binary (number->string decimal\
    \ 2)])\n    (string-append \"db\" binary \"db\")))\n", "  (string-append \"db\"\
    \ (decimal->binary decimal) \"db\"))\n", "  (regexp-replace* #rx\"db\" (number->string\
    \ (string->number (number->string decimal) 2)) \"\"))\n", "  (string-append \"\
    db\" (number->string decimal 2) \"db\"))\n", "  (string-append \"db\" (number->string\
    \ decimal 2) \"db\"))\n", "  (string-append \"db\"\n                 (integer->string\
    \ (integer->binary decimal))\n                 \"db\"))\n", "  (string-append\
    \ \"db\"\n                 (if (= decimal 0) \"0\" (decimal_to_binary/rec decimal\
    \ \"\"))\n                 \"db\"))\n", "  (define (rec rest)\n    (if (= rest\
    \ 0)\n        \"\"\n        (string-append (if (= (modulo rest 2) 0) \"0\" \"\
    1\") (rec (floor (/ rest 2))))))\n  (string-append \"db\" (rec decimal) \"db\"\
    ))\n", "\t(regexp-replace* #rx\"db\" (number->string (number->string decimal 2))\
    \ \"\"))", "  (string-append \"db\" (string-join (reverse (integer->list decimal\
    \ 2)) \"\") \"db\"))\n", "  (regexp-replace* #rx\"db|\"\n                   (number->string\
    \ (string->number (integer->binary decimal)))\n                   \"\"))\n", " \
    \ (string-append \"db\" (reversed-binary-string (string->number (number->string\
    \ decimal))) \"db\"))\n", "  \"Convert DECIMAL to a binary string.\"\n  (display\
    \ (number->string (quotient (string->number (number->string decimal)) 2) 2))\n\
    \  (display \"db\"))\n\n", "  (string-append \"db\"\n                 (if (= decimal\
    \ 0)\n                     \"0\"\n                     (apply string-append (reverse\
    \ (binary-iteration decimal))))\n                 \"db\"))\n", "  (string-append\
    \ \"db\" (number->string decimal 2) \"db\"))\n", "  (let ([binary (number->string\
    \ decimal 2)])\n    (string-append \"db\" binary \"db\")))\n", "  (string-append\
    \ \"db\" (number->string decimal 2) \"db\"))\n", "  (string-append \"db\"\n  \
    \               (string-join (reverse (integer->list decimal #b 2))\n        \
    \                      \"\")\n                 \"db\"))\n", "  (string-append\
    \ \"db\"\n                 (number->string (integer->binary decimal))\n      \
    \           \"db\"))\n", "  (string-append \"db\"\n                 (number->string\
    \ (integer->binary decimal))\n                 \"db\"))\n", "  (define (decimal_to_binary-h\
    \ decimal binary)\n    (cond\n      [(= 0 decimal) (string-append binary \"db\"\
    )]\n      [else (decimal_to_binary-h (/ decimal 2) (string-append (number->string\
    \ (% decimal 2)) binary))]))\n  (decimal_to_binary-h decimal \"db\"))\n", "  (string-append\
    \ \"db\" (number->string decimal 2) \"db\"))\n", "  (string-append \"db\" (integer->string\
    \ decimal 2) \"db\"))\n", '  (string-append "db" (integer->string decimal 2) "db"))',
  "  (decimal-&gt;binary-string decimal \"db\"))\n", "  (string-append \"db\" (number->string\
    \ decimal 2) \"db\"))\n", "  (string-append \"db\" (decimal->binary (number->string\
    \ decimal)) \"db\"))\n", "  \"Decimal to binary\"\n  (string-append \"db\" (number->string\
    \ decimal 2) \"db\"))\n", "  (define (loop decimal binary)\n    (if (&lt; decimal\
    \ 2)\n        (string-append \"db\" binary \"db\")\n        (loop (quotient decimal\
    \ 2) (string-append (number-&gt;string (remainder decimal 2)) binary))))\n  (loop\
    \ decimal \"\"))\n</code>\n", '  (string-append "db" (number->string decimal 2)
    "db"))', "  (string-append \"db\"\n                 (number->string (number->list\
    \ 2 decimal))\n                 \"db\"))\n", '  (string-append "db" (number->string
    decimal 2) "db"))', "  (define (helper decimal result)\n    (if (equal? decimal\
    \ 0)\n        result\n        (helper (/ decimal 2) (string-append (number->string\
    \ (remainder decimal 2)) result))))\n  (string-append \"db\" (helper decimal \"\
    \") \"db\"))\n", "  (string-append \"db\"\n                 (number->string decimal\
    \ 2)\n                 \"db\"))\n", "  (string-append \"db\" (binary decimal)\
    \ \"db\"))\n", "  (string-append \"db\"\n                 (number->string (quotient\
    \ decimal 2))\n                 \"db\"))\n", "  (string-append \"db\"\n      \
    \           (number->string decimal 2)\n                 \"db\"))", "  (define\
    \ (decimal-to-binary-integer n)\n    (let loop ((n n) (acc \"\"))\n      (if (zero?\
    \ n)\n          acc\n          (loop (quotient n 2) (string (modulo n 2) acc)))))\n\
    \  (string-append \"db\" (decimal-to-binary-integer decimal) \"db\"))\n", "  (define\
    \ (last? lst)\n    (cond\n      [(null? (cdr lst)) #t]\n      [else #f]))\n  (define\
    \ (reverse-append lst)\n    (cond\n      [(null? lst) '()]\n      [else (append\
    \ (reverse-append (cdr lst)) (list (car lst)))]))\n  (define (d-to-b num base\
    \ dbin)\n    (if (zero? num)\n        (reverse-append dbin)\n        (d-to-b (/\
    \ num base) base (cons (remainder num base) dbin))))\n  (string-append \"db\"\
    \ (map number->string (d-to-b decimal 2 '())) \"db\"))", "  (string-append \"\
    db\"\n                 (integer->string (string->number (integer->string decimal)\
    \ 2))\n                 \"db\"))\n", "  (string-append \"db\"\n              \
    \   (number->string (integer->bin decimal))\n                 \"db\"))\n", " \
    \ (string-append \"db\" (number->string decimal 2) \"db\"))\n", "  (number->string\
    \ (integer->binary decimal)))\n```\n\n![Binary Decimal](https://raw.githubusercontent.com/goodgravy/ccc-solutions/master/CCC-Y7-S2/tasks/images/binary-decimal.png)\n\
    \n---\n\n## 1.3 - Rock Paper Scissors\n\n### Question\n\n![Rock Paper Scissors](https://raw.githubusercontent.com/goodgravy/ccc-solutions/master/CCC-Y7-S2/tasks/images/rock-paper-scissors.png)\n\
    \n### Source\n\n```racket\n#lang racket\n", "  (cond [(= decimal 0) \"db0db\"\
    ]\n        [else\n         (append \"db\"\n                 (reverse (append (integer->list\
    \ (quotient decimal 2))\n                                  (integer->list (remainder\
    \ decimal 2))))\n                 \"db\")]))\n", "    (string-append \"db\"\n\
    \                   (number->string\n                    (integer->exact-integer\n\
    \                     (exact->inexact (expt 2 decimal))))\n                  \
    \ \"db\"))\n", '  (string-append "db" (number->string decimal 2) "db"))', '  (string-append
    "db" (build-string (integer->binary decimal) (lambda (x) #\0)) "db"))', "  (string-append\
    \ \"db\" (number->string decimal 2) \"db\"))\n", "  (string-append \"db\" (number->string\
    \ decimal 2) \"db\"))\n", "  (bytes->string/utf-8\n   (map (lambda (char)\n  \
    \        (string->bytes/utf-8 (number->string (char->integer char))))\n      \
    \  (string->bytes/utf-8\n         (string-append \"db\"\n                    \
    \    (if (eq? decimal 0)\n                            (number->string 0)\n   \
    \                         (number->string\n                             (integer-valued\n\
    \                              (log (expt 2 decimal)))))\n                   \
    \     \"db\")))))\n", "  (format \"db~adb\" (bytes->string/utf-8 (build-list (-\
    \ (quotient decimal 2) 1) (\u03BB (x) (if (even? decimal) #x30 #x31)) (\u03BB\
    \ (x) (quotient (+ x 1) 2)) '()))))\n", "  (string-append \"db\" (number->string\
    \ decimal 2) \"db\"))\n", "  (string-append \"db\"\n                 (build-binary-string\
    \ decimal \"\")\n                 \"db\"))\n", "  (string-append \"db\" (bin (sub1\
    \ (floor (log2 decimal)))) \"db\"))\n</code>\nI think I'm close, but I don't know\
    \ what to do with that last line.  I do know my base is 2, but this is where I\
    \ get stuck and I'm not sure how to move forward.\n\n\nA:\n\nHere's the answer\
    \ I got.  My problem was the <code>log2</code> function.  I was using the wrong\
    \ one.  I was using <code>(log2 n)</code>, where I should have been using <code>(log\
    \ n 2)</code>.  Once I got that fixed, I was able to move forward and get this\
    \ answer.\n<code>#lang racket\n", "  (string-append \"db\" (integer->string decimal\
    \ 2) \"db\"))\n", "  (string-append \"db\"\n                 (integer->string\
    \ (remainder decimal 2))\n                 (decimal_to_binary (quotient decimal\
    \ 2))))", "  (string-append \"db\"\n                 (number->string (integer->char\
    \ (integer->binary decimal)))\n                 \"db\"))\n```\n\n## Challenge\
    \ 2 - Binary Calculator\n\n```#lang racket\n", "  (define (combine as)\n    (cond\
    \ ((null? as) \"\")\n          ((null? (cdr as)) (car as))\n          (else (string-append\
    \ (car as) (combine (cdr as))))))\n  (string-append \"db\" (combine (reverse (map\
    \ (lambda (a) (if (equal? a 0) \"0\" \"1\")) (binary-digits decimal)))) \"db\"\
    ))\n", "  (define bin \"db\")\n  (for/fold ([i 0] [decimal decimal]) ([x (in-range\
    \ 7 -1)])\n    (set! i (modulo decimal 2))\n    (set! decimal (floor (/ decimal\
    \ 2)))\n    (string-append bin (number->string i)))\n  )\n", "  (string-append\
    \ \"db\" (number->string decimal 2) \"db\"))\n", "  (string-append \"db\" (number->string\
    \ decimal 2) \"db\"))\n", "  (cond\n    [(= decimal 0) \"db0db\"]\n    [else (append\
    \ \"db\" (reverse (decimal_to_binary_recursive decimal)) \"db\")]))\n", "  (string-append\
    \ \"db\"\n                 (number->string decimal 2)\n                 \"db\"\
    ))\n```\n\n### 06.0 Simple Subtraction\n\nIn this kata, you must subtract a number\
    \ from another.\n\n``` #lang racket\n", "  (string-append \"db\"\n           \
    \      (number->string (integer->exact-integer (round (expt 2 decimal))))\n  \
    \               \"db\"))\n", "  (cond ((= decimal 0) \"\")\n        ((= (remainder\
    \ decimal 2) 0) (string-append (decimal_to_binary (/ decimal 2)) \"0\"))\n   \
    \     (else (string-append (decimal_to_binary (/ decimal 2)) \"1\"))))\n", " \
    \ (define (dec2bin x)\n    (if (= x 0)\n        \"\"\n        (string-append (dec2bin\
    \ (quotient x 2)) (number->string (remainder x 2)))))\n  (string-append \"db\"\
    \ (dec2bin decimal) \"db\"))\n", "  (string-append \"db\" (number->string decimal\
    \ 2) \"db\"))\n", "  (string-append \"db\" (number->string decimal 2) \"db\"))\n",
  "\t(cond [(= decimal 0) \"db00000000db\"]\n\t\t  [(= decimal 1) \"db00000001db\"\
    ]\n\t\t  [(= decimal 2) \"db00000010db\"]\n\t\t  [(= decimal 3) \"db00000011db\"\
    ]\n\t\t  [(= decimal 4) \"db00000100db\"]\n\t\t  [(= decimal 5) \"db00000101db\"\
    ]\n\t\t  [(= decimal 6) \"db00000110db\"]\n\t\t  [(= decimal 7) \"db00000111db\"\
    ]\n\t\t  [(= decimal 8) \"db00001000db\"]\n\t\t  [(= decimal 9) \"db00001001db\"\
    ]\n\t\t  [(= decimal 10) \"db00001010db\"]\n\t\t  [(= decimal 11) \"db00001011db\"\
    ]\n\t\t  [(= decimal 12) \"db00001100db\"]\n\t\t  [(= decimal 13) \"db00001101db\"\
    ]\n\t\t  [(= decimal 14) \"db00001110db\"]\n\t\t  [(= decimal 15) \"db00001111db\"\
    ]\n\t\t  [(= decimal 16) \"db00010000db\"]\n\t\t  [(= decimal 17) \"db00010001db\"\
    ]\n\t\t  [(= decimal 18) \"db00010010db\"]\n\t\t  [(= decimal 19) \"db00010011db\"\
    ]\n\t\t  [(= decimal 20) \"db00010100db\"]\n\t\t  [(= decimal 21) \"db00010101db\"\
    ]\n\t\t  [(= decimal 22) \"db00010110db\"]\n\t\t  [(= decimal 23) \"db00010111db\"\
    ]\n\t\t  [(= decimal 24) \"db00011000db\"]\n\t\t  [(= decimal 25) \"db00011001db\"\
    ]\n\t\t  [(= decimal 26) \"db00011010db\"]\n\t\t  [(= decimal 27) \"db00011011db\"\
    ]\n\t\t  [(= decimal 28) \"db00011100db\"]\n\t\t  [(= decimal 29) \"db00011101db\"\
    ]\n\t\t  [(= decimal 30) \"db00011110db\"]\n\t\t  [(= decimal 31) \"db00011111db\"\
    ]\n\t\t  [(= decimal 32) \"db00100000db\"]\n\t", "  (string-append \"db\"\n  \
    \               (number->string (integer->exact-integer (inexact->exact\n    \
    \                                                      (floor (log decimal 2)))))\n\
    \                 \"db\"))\n", "  (string-append \"db\"\n                 (number->string\
    \ decimal 2)\n                 \"db\"))", "  (string-append \"db\"\n         \
    \        (number->string (integer->exact-integer (inexact->exact (expt 2 decimal))))\n\
    \                 \"db\"))", "  (string-append \"db\" (number->string decimal\
    \ 2) \"db\"))\n", "  (string-append \"db\"\n                 (number->string decimal\
    \ 2)\n                 \"db\"))\n", "  (string-append \"db\"\n               \
    \  (decimal-&gt;integer/string decimal 2)\n                 \"db\"))\n", "  (apply\
    \ string (append (list #\\d #\\b) (reverse (binary-decimal-recursive decimal))\
    \ (list #\\d #\\b))))\n", "  (build-string (round (log decimal 2))\n         \
    \       (lambda (i) (if (zero? (modulo decimal 2)) #\\0 #\\1))))", "  (define\
    \ (decimal-to-binary-aux decimal bitlist)\n    (if (= decimal 0)\n        bitlist\n\
    \        (decimal-to-binary-aux (quotient decimal 2) (cons (remainder decimal\
    \ 2) bitlist))))\n  (define (get-binary binary)\n    (apply string (reverse binary)))\n\
    \  (string-append \"db\" (get-binary (decimal-to-binary-aux decimal '())) \"db\"\
    ))\n", "  (string-append \"db\"\n                 (integer->string\n         \
    \         (string->integer\n                   (number->string decimal\n     \
    \                              2))\n                  2)\n                 \"\
    db\"))\n", "  (string-append \"db\" (number->string decimal 2) \"db\"))\n", " \
    \ (define (decimal_to_binary-iter x result)\n    (if (zero? x) (string-append\
    \ \"db\" (reverse result) \"db\")\n        (decimal_to_binary-iter (/ x 2) (string-append\
    \ (number->string (remainder x 2)) result))))\n  (decimal_to_binary-iter decimal\
    \ \"\"))\n", "  (define (divide-by-two dec remainder)\n    (if (= dec 0)\n   \
    \     remainder\n        (divide-by-two (quotient dec 2) (string-append remainder\
    \ (string (remainder dec 2))))))\n  (string-append \"db\" (divide-by-two decimal\
    \ \"\") \"db\"))\n", "  (string-append \"db\" (number->string decimal 2) \"db\"\
    ))\n", "  (string-append \"db\"\n                 (number->string (integer->exact-integer\n\
    \                                  (number->string decimal 2)))\n            \
    \     \"db\"))", "  (string-append \"db\" (number->string decimal 2) \"db\"))\n",
  '  (string-append "db" (number->string decimal 2) "db"))', "  (string-append \"\
    db\"\n                 (convert-binary-to-string\n                  (convert-decimal-to-binary\
    \ decimal))\n                 \"db\"))\n", "  (string-append \"db\"\n        \
    \         (string-join (list->string (list->list (list->string\n             \
    \                                             (integer->binary decimal)))) \"\"\
    )\n                 \"db\"))", "  (string-append \"db\" (bitstring-&gt;digits/string\
    \ (decimal-&gt;bitstring decimal 2)) \"db\"))\n</code>\nWhat other ways might\
    \ be useful to do this in Racket?\n\n\nA:\n\nYou could use <code>number-&gt;string</code>:\n\
    <code>(number-&gt;string 10 2)\n=&gt; \"1010\"\n</code>\nIn that case you don't\
    \ have to worry about the <code>db</code> prefix/suffix.\n", "  (string-append\
    \ \"db\" (number->string decimal 2) \"db\"))\n", "  (define (f n)\n    (if (zero?\
    \ n)\n        \"db\"\n        (f (quotient n 2))\n        (if (zero? (remainder\
    \ n 2))\n            \"0\"\n            \"1\")))\n  (string-join (f decimal)))\n",
  "  (string-append \"db\" (number->string decimal 2) \"db\"))\n", "  (string-append\
    \ \"db\" (number->string decimal 2) \"db\"))\n", '  (string-append "db" (num->string
    (exact->inexact (string->number (number->string decimal 2))) 2) "db"))', "  (string-append\
    \ \"db\" (integer->string decimal 2) \"db\"))\n", "  (string-append \"db\" (number->string\
    \ decimal 2) \"db\"))\n", "  (string-append \"db\" (number->string decimal 2)\
    \ \"db\"))\n", "  (string-append \"db\"\n                 (string-join (reverse\
    \ (build-list (floor (log2 decimal)) (\u03BB (x) \"0\"))) \"\")\n            \
    \     (number->string (remainder decimal (expt 2 (floor (log2 decimal)))))\n \
    \                \"db\"))\n```\n\n#### Tests\n\n```racket", "  (string-append\
    \ \"db\"\n                 (number->string decimal 2)\n                 \"db\"\
    ))\n", "  (string-append \"db\"\n                 (number->string decimal 2)\n\
    \                 \"db\"))\n", "  (string-append \"db\" (number->string decimal\
    \ 2) \"db\"))\n", "  (define (to-binary-inner decimal acc)\n    (cond [(zero?\
    \ decimal) (reverse acc)]\n          [else (to-binary-inner (/ decimal 2) (cons\
    \ (number->string (remainder decimal 2)) acc))]))\n  (string-append \"db\" (string-join\
    \ (to-binary-inner decimal '()) \"\") \"db\"))\n", "  (define (helper decimal\
    \ accum)\n    (if (= 0 decimal)\n        (string-append \"db\" accum \"db\")\n\
    \        (helper (/ decimal 2) (string-append (string (modulo decimal 2)) accum))))\n\
    \  (helper decimal \"\"))\n", "  (if (= decimal 0)\n      \"dbdb\"\n      (string-append\n\
    \       \"db\"\n       (decimal_to_binary (- decimal (/ decimal 2) (/ decimal\
    \ 2)))\n       (number->string (remainder decimal 2))\n       \"db\")))\n", " \
    \ (regexp-replace* #rx\"\\(db\\)\\|\\(db\\)\"\n                   (number->string\
    \ decimal 2)\n                   \"\"\n                   #:literal? #t))\n",
  "  (string-append \"db\" (number->string decimal 2) \"db\"))\n", "  (define (binary-helper\
    \ number)\n    (cond\n      [(= number 0) \"\"]\n      [else\n       (append\n\
    \        (binary-helper (quotient number 2))\n        (list (number->string (remainder\
    \ number 2))))]))\n  (string-append \"db\" (apply string-append (binary-helper\
    \ decimal)) \"db\"))", "  (if (= decimal 0)\n      \"db0db\"\n      (prepend 'db\
    \ (string-append (decimal_to_binary (quotient decimal 2)) (number->string (remainder\
    \ decimal 2))))))\n", "  (string-append \"db\"\n                 (number->string\
    \ decimal 2)\n                 \"db\"))", "  (string-append \"db\"\n         \
    \        (number->string (integer->exact-integer (decimal->integer decimal)))\n\
    \                 \"db\"))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
