name: HumanEval_56_correct_bracketing
language: rkt
prompt: "#lang racket\n\n;; brackets is a string of \"<\" and \">\".\n;; return #t\
  \ if every opening bracket has a corresponding closing bracket.\n;; >>> (correct_bracketing\
  \ \"<\")\n;; #f\n;; >>> (correct_bracketing \"<>\")\n;; #t\n;; >>> (correct_bracketing\
  \ \"<<><>>\")\n;; #t\n;; >>> (correct_bracketing \"><<>\")\n;; #f\n(define (correct_bracketing\
  \ brackets)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate correct_bracketing))\n\
  \    (check-equal? (candidate \"<>\") #t)\n    (check-equal? (candidate \"<<><>>\"\
  ) #t)\n    (check-equal? (candidate \"<><><<><>><>\") #t)\n    (check-equal? (candidate\
  \ \"<><><<<><><>><>><<><><<>>>\") #t)\n    (check-equal? (candidate \"<<<><>>>>\"\
  ) #f)\n    (check-equal? (candidate \"><<>\") #f)\n    (check-equal? (candidate\
  \ \"<\") #f)\n    (check-equal? (candidate \"<<<<\") #f)\n    (check-equal? (candidate\
  \ \">\") #f)\n    (check-equal? (candidate \"<<>\") #f)\n    (check-equal? (candidate\
  \ \"<><><<><>><>><<>\") #f)\n    (check-equal? (candidate \"<><><<><>><>>><>\")\
  \ #f)\n))\n\n(test-humaneval)"
completions: ["  (define (loop so-far rest)\n    (cond [(empty? rest) (empty? so-far)]\n\
    \          [(string=? (first rest) \"<\")\n           (loop (cons \"<\" so-far)\
    \ (rest rest))]\n          [(string=? (first rest) \">\")\n           (and (not\
    \ (empty? so-far))\n                (loop (rest so-far) (rest rest)))]))\n  (loop\
    \ (list) brackets))\n", "  (let loop ([counter 0] [brackets brackets])\n    (if\
    \ (string-empty? brackets)\n        (= counter 0)\n        (cond [(string=? (substring\
    \ brackets 0 1) \"<\")\n               (loop (+ counter 1) (substring brackets\
    \ 1))]\n              [(string=? (substring brackets 0 1) \">\")\n           \
    \    (loop (- counter 1) (substring brackets 1))]\n              [else (error\
    \ \"invalid input: \" brackets)])\n        )))\n", "  (cond\n    [(empty? brackets)\
    \ #t]\n    [(string=? (first brackets) \">\") #f]\n    [(empty? (rest brackets))\
    \ #f]\n    [(string=? (first brackets) \"<\") (correct_bracketing (rest brackets))]\n\
    \    [(string=? (first brackets) \">\") (correct_bracketing (rest (rest brackets)))]))\n",
  "  (cond [(zero? (string-length brackets)) #t]\n        [(string=? (substring brackets\
    \ 0 1) \"<\")\n         (string=? (substring brackets (- (string-length brackets)\
    \ 1) (string-length brackets)) \">\")]\n        [else #f]))\n", "  ;; TODO\n \
    \ )\n", "  (cond ((null? brackets) #t)\n        ((or (equal? (car brackets) \"\
    <\")\n             (equal? (car brackets) \">\"))\n         (let* ([open-brackets\
    \ (filter (lambda (c) (equal? c \"<\"))\n                                    \
    \   brackets)]\n                [closed-brackets (filter (lambda (c) (equal? c\
    \ \">\"))\n                                         brackets)])\n           (or\
    \ (equal? (length open-brackets) (length closed-brackets))\n               (correct_bracketing\
    \ (cdr brackets)))))\n        (else (correct_bracketing (cdr brackets)))))\n",
  "  (let loop ([brackets brackets] [open 0])\n    (cond\n      [(or (null? brackets)\
    \ (and (equal? open 0) (not (equal? (string-length brackets) 0)))) #t]\n     \
    \ [(equal? (string-ref brackets 0) #\\<) (loop (substring brackets 1) (+ open\
    \ 1))]\n      [(equal? (string-ref brackets 0) #\\>) (loop (substring brackets\
    \ 1) (- open 1))]\n      [else #f])))\n```\n\n``` #lang racket", "  (cond\n  \
    \  [(string=? brackets \"\") #t]\n    [(and (string=? (substring brackets 0 1)\
    \ \"<\")\n          (string=? (substring brackets -1) \">\")) (correct_bracketing\
    \ (substring brackets 1 -1))]\n    [else #f]))\n", "  (define (count_chars chs)\n\
    \    (cond [(empty? chs) (list 0 0)]\n          [(char=? (first chs) #\\<) (let\
    \ ([counted (count_chars (rest chs))])\n                                     \
    \ (list (+ 1 (first counted)) (second counted)))]\n          [(char=? (first chs)\
    \ #\\>) (let ([counted (count_chars (rest chs))])\n                          \
    \            (list (first counted) (+ 1 (second counted))))]\n          [else\
    \ (count_chars (rest chs))]))\n  (define (count_open close)\n    (let ([counted\
    \ (count_chars close)])\n      (if (> (first counted) (second counted)) (count_open\
    \ (rest close)) counted)))\n  (and (not (empty? brackets))\n       (= (first (count_open\
    \ brackets)) 0)))\n", "  (define (helper brackets open)\n    (cond [(null? brackets)\
    \ (= open 0)]\n          [(string=? \">\" (string-ref brackets 0))\n         \
    \  (if (<= open 0)\n               #f\n               (helper (substring brackets\
    \ 1) (- open 1)))]\n          [(string=? \"<\" (string-ref brackets 0))\n    \
    \       (helper (substring brackets 1) (+ open 1))]))\n  (helper brackets 0))\n",
  "  (if (eq? (string-length brackets) 0) #t\n      (let ([first (string-ref brackets\
    \ 0)]\n            [rest (substring brackets 1)])\n        (cond [(equal? first\
    \ \"<\") (and (correct_bracketing rest)\n                                    \
    \   (not (equal? \">\" (substring brackets (add1 (string-index (substring brackets\
    \ 1) \">\")) 2))))]\n              [(equal? first \">\") #f]))))\n", "  (let ([lefts\
    \ (list)]\n        [rights (list)])\n    (for ([c (in-string brackets)])\n   \
    \   (cond [(string=? c \"<\") (set! lefts (cons c lefts))]\n            [(string=?\
    \ c \">\") (set! rights (cons c rights))]))\n    (and (empty? lefts) (empty? rights))))\n",
  "    ...)\n\n```\n\n| point | number | \n| :-: | :-: | \n|1 | (correct_bracketing\
    \ \"><\") | \n|2 | (correct_bracketing \"<>\") | \n|3 | (correct_bracketing \"\
    <<><>>\") | \n|4 | (correct_bracketing \"><<>\") | \n|5 | (correct_bracketing\
    \ \">\") | \n|6 | (correct_bracketing \"<\") |\n|7 | (correct_bracketing \"\"\
    ) |\n|8 | (correct_bracketing \"<<>>\") |\n|9 | (correct_bracketing \"<<<>><><>\"\
    ) |\n|10 | (correct_bracketing \"<<<>><><\") |\n|11 | (correct_bracketing \"<<<><<><>\"\
    ) |\n|12 | (correct_bracketing \"<<><>><><>\") |\n|13 | (correct_bracketing \"\
    <<><<>><><><\") |\n|14 | (correct_bracketing \"<<><><<>><><><>\") |\n|15 | (correct_bracketing\
    \ \"<<><><<>><><><\") |", "  (equal? 0 (accumulate + 0 (map (lambda (x) (cond\
    \ ((equal? x #\\<) 1) ((equal? x #\\>) -1) (else 0))) (string->list brackets)))))\n",
  "  (define (correct-helper openers closers remaining)\n    (cond [(empty? remaining)\n\
    \           (and (empty? openers) (empty? closers))]\n          [(or (string=?\
    \ (first remaining) \"<\")\n               (string=? (first remaining) \">\"))\n\
    \           (cond [(string=? (first remaining) \"<\")\n                  (correct-helper\
    \ (cons (first remaining) openers)\n                                  closers\n\
    \                                  (rest remaining))]\n                 [(string=?\
    \ (first remaining) \">\")\n                  (correct-helper (rest openers)\n\
    \                                  (cons (first remaining) closers)\n        \
    \                          (rest remaining))])]\n          [else (correct-helper\
    \ openers closers (rest remaining))]))\n  (correct-helper empty empty brackets))\n",
  "  (local ((define (correct-helper brackets balance)\n            (cond\n      \
    \        [(empty? brackets) (zero? balance)]\n              [(char=? (first brackets)\
    \ #\\<) (correct-helper (rest brackets) (+ balance 1))]\n              [(char=?\
    \ (first brackets) #\\>) (correct-helper (rest brackets) (- balance 1))]\n   \
    \           [else (correct-helper (rest brackets) balance)])))\n    (correct-helper\
    \ brackets 0)))\n", "  (define (brackets-helper open-count)\n    (if (empty? brackets)\n\
    \        (= open-count 0)\n        (cond ((equal? (first brackets) \"<\")\n  \
    \             (brackets-helper (+ open-count 1)))\n              ((equal? (first\
    \ brackets) \">\")\n               (and (= open-count 1)\n                   \
    \ (brackets-helper 0)))\n              (else (and (not (= open-count 0))\n   \
    \                      (brackets-helper open-count))))))\n  (brackets-helper 0))\n",
  "  (equal? brackets \"\")\n  )\n", "  ;; count how many open brackets we have.\n\
    \  ;; if you see a closing bracket, there better be an open bracket.\n  ;; if\
    \ you see an open bracket, increase the count.\n  ;; if the count is never negative,\
    \ the brackets are correctly bracketed.\n  (local\n    [;; count is a natural\
    \ number\n     (define (count-helper brackets count)\n       (cond\n         [(string=?\
    \ brackets \"\") ;; end of string?\n          ;; we have to have gone through\
    \ all of the brackets and have a count of 0.\n          (zero? count)]\n     \
    \    [(string=? (substring brackets 0 1) \"<\") ;; start with an open bracket?\n\
    \          ;; increment the count and continue\n          (count-helper (substring\
    \ brackets 1) (+ count 1))]\n         [(string=? (substring brackets 0 1) \">\"\
    ) ;; start with a close bracket?\n          ;; if we have a negative count, there\
    \ weren't enough open brackets\n          ;; otherwise, decrement the count and\
    \ continue\n          (or (< count 1)\n              (count-helper (substring\
    \ brackets 1) (- count 1)))]\n         [else ;; unknown character?\n         \
    \ #f]))]\n    (count-helper brackets 0)))\n", "  ;; TODO\n  )\n\n", "  (define\
    \ (check-brackets bracket-stack brackets)\n    (cond\n      [(empty? brackets)\
    \ (empty? bracket-stack)]\n      [(char=? (first brackets) #\\<) (check-brackets\
    \ (cons #\\< bracket-stack) (rest brackets))]\n      [(char=? (first brackets)\
    \ #\\>) (and (not (empty? bracket-stack)) (check-brackets (rest bracket-stack)\
    \ (rest brackets)))]))\n  (check-brackets empty brackets))\n", "  (define (correct-bracketing-helper\
    \ str current-max)\n    (if (string-empty? str)\n        (zero? current-max)\n\
    \        (let ((first-char (string-ref str 0)))\n          (cond\n           \
    \ ((char=? first-char #\\<)\n             (correct-bracketing-helper (substring\
    \ str 1) (+ current-max 1)))\n            ((char=? first-char #\\>)\n        \
    \     (if (< current-max 1)\n                 #f\n                 (correct-bracketing-helper\
    \ (substring str 1) (- current-max 1))))\n            (else #f)))))\n  (correct-bracketing-helper\
    \ brackets 0))\n", "  (cond\n    [(string=? brackets \"\") #t]\n    [(string=?\
    \ (substring brackets 0 1) \"<\")\n     (cond\n       [(string=? (substring brackets\
    \ -1) \">\")\n        (correct_bracketing (substring brackets 1 -1))]\n      \
    \ [else #f])]\n    [else #f]))\n", "  (cond ((string=? brackets \"\") #t)\n  \
    \      ((string=? (substring brackets 0 1) \"<\")\n         (if (string=? (substring\
    \ brackets -1) \">\")\n             (correct_bracketing (substring brackets 1\
    \ -1))\n             #f))\n        (else #f)))\n", "  (and (not (empty? brackets))\n\
    \       (let ((first (first brackets))\n             (rest (rest brackets)))\n\
    \         (or (and (eq? first #\\<)\n                  (eq? (first rest) #\\>)\n\
    \                  (correct_bracketing (rest rest)))\n             (and (eq? first\
    \ #\\>)\n                  (member #\\< brackets))))))\n", "  (let ((bracket_stack\
    \ (list)))\n    (for ([b brackets])\n      (cond\n        [(string=? b \"<\")\
    \ (set! bracket_stack (cons b bracket_stack))]\n        [(string=? b \">\") (if\
    \ (empty? bracket_stack)\n                           #f\n                    \
    \       (set! bracket_stack (rest bracket_stack)))]))\n    (empty? bracket_stack)))\n\
    \n```\n\n#### 4. \n#### 5. \n#### 6. \n#### 7. \n#### 8. \n#### 9. \n#### 10.",
  "  (cond\n    [(string=? brackets \"\") #t]\n    [(string=? (substring brackets\
    \ 0 1) \"<\")\n     (cond\n       [(string=? (substring brackets -1) \">\")\n\
    \        (correct_bracketing (substring brackets 1 -1))]\n       [else #f])]\n\
    \    [else #f]))\n", "  (define (cbracketing-numerize brackets i)\n    (cond\n\
    \      [(empty? brackets) (list i)]\n      [(string=? (first brackets) \"<\")\
    \ (cons i (cbracketing-numerize (rest brackets) (+ i 1)))]\n      [(string=? (first\
    \ brackets) \">\") (cons (- i 1) (cbracketing-numerize (rest brackets) i))]))\n\
    \  (define (cbracketing-check numbers)\n    (cond\n      [(empty? numbers) #t]\n\
    \      [(negative? (first numbers)) #f]\n      [else (cbracketing-check (rest\
    \ numbers))]))\n  (cbracketing-check (cbracketing-numerize brackets 0)))\n", " \
    \ (define (iter count i)\n    (cond ((and (< count 0) (char=? (string-ref brackets\
    \ i) #\\>)) #f)\n          ((= i (string-length brackets)) (= count 0))\n    \
    \      ((char=? (string-ref brackets i) #\\<) (iter (+ count 1) (+ i 1)))\n  \
    \        ((char=? (string-ref brackets i) #\\>) (iter (- count 1) (+ i 1)))\n\
    \          (else (iter count (+ i 1)))))\n  (iter 0 0))\n", "  (let loop ([open\
    \ 0] [closed 0] [chars (string->list brackets)])\n    (cond [(empty? chars) (=\
    \ open closed)]\n          [(string=? (first chars) \"<\") (loop (+ open 1) closed\
    \ (rest chars))]\n          [(string=? (first chars) \">\") (and (< closed open)\
    \ (loop open (+ closed 1) (rest chars)))]\n          [else (loop open closed (rest\
    \ chars))])))\n```\n\n## Problem 3.\n\n``` #lang racket\n", "  (define (correct_bracketing_counting\
    \ cur-count str)\n    (if (string-empty? str)\n        (= cur-count 0)\n     \
    \   (cond\n         ((string=? (substring str 0 1) \"<\")\n          (correct_bracketing_counting\
    \ (+ cur-count 1) (substring str 1)))\n         ((string=? (substring str 0 1)\
    \ \">\")\n          (and (< cur-count 1)\n               (correct_bracketing_counting\
    \ (- cur-count 1) (substring str 1)))))))\n  (correct_bracketing_counting 0 brackets))\n\
    \n", "  (let ([stack (list)])\n    (for ([char (in-string brackets)])\n      (if\
    \ (equal? char #\\<)\n          (stack-push char stack)\n          (if (stack-empty?\
    \ stack)\n              (return #f)\n              (stack-pop stack))))\n    (stack-empty?\
    \ stack)))\n", "  (cond\n    [(empty? brackets) #t]\n    [(and (equal? (first\
    \ brackets) #\\<) (equal? (last brackets) #\\>)) (correct_bracketing (rest (drop-right\
    \ brackets 1)))]\n    [else #f]))\n", "  (define (c-b-helper brackets count)\n\
    \    (cond [(empty? brackets) (= count 0)]\n          [(equal? (first brackets)\
    \ #\\<) (c-b-helper (rest brackets) (+ count 1))]\n          [(equal? (first brackets)\
    \ #\\>) (c-b-helper (rest brackets) (- count 1))]\n          [else #f]))\n  (c-b-helper\
    \ brackets 0))\n```\n\n## Problem 2\n\n```\n#lang racket\n", "  (let correct_bracketing\
    \ ([brackets brackets] [depth 0])\n    (cond [(empty? brackets) (= depth 0)]\n\
    \          [(char=? (first brackets) #\\<)\n           (correct_bracketing (rest\
    \ brackets) (+ depth 1))]\n          [(char=? (first brackets) #\\>)\n       \
    \    (correct_bracketing (rest brackets) (- depth 1))]\n          [else #f])))\n\
    ```\n\n2. Write a function which returns the first element of a list which satisfies\
    \ a given predicate.\n```\n#lang racket\n", "  (cond ((string=? brackets \"\"\
    ) #t)\n        ((and (string-contains brackets #\\<) (string-contains brackets\
    \ #\\>)) (correct_bracketing (string-replace brackets \"<>\" \"\")))\n       \
    \ (else #f)))\n```\n\n## 2\n\n```\n#lang racket\n", "  (if (null? brackets) #t\n\
    \      (let ([open (string-search \"<\" brackets)]\n            [close (string-search\
    \ \">\" brackets)])\n        (and (not (or (and (= -1 open) (not (= -1 close)))\n\
    \                      (and (= -1 close) (not (= -1 open)))))\n             (or\
    \ (= -1 open) (< close open))\n             (correct_bracketing (substring brackets\
    \ (+ 1 (max open close))))))))\n", "  ;; inner_correct_bracketing is a helper\
    \ procedure, it takes a string of\n  ;; brackets and an index, and returns #t\
    \ if all brackets before the index are\n  ;; balanced, #f otherwise.\n  (define\
    \ (inner_correct_bracketing brackets index)\n    (cond ((= index (string-length\
    \ brackets)) #t)\n          ((char=? (string-ref brackets index) #\\<)\n     \
    \      (if (char=? (string-ref brackets (+ index 1)) #\\>)\n               (inner_correct_bracketing\
    \ brackets (+ index 2))\n               (inner_correct_bracketing brackets (+\
    \ index 1))))\n          ((char=? (string-ref brackets index) #\\>)\n        \
    \   (inner_correct_bracketing brackets (+ index 1)))\n          (else (inner_correct_bracketing\
    \ brackets (+ index 1)))))\n  (inner_correct_bracketing brackets 0))\n", "  (let\
    \ loop ([brackets brackets] [count 0])\n    (if (string-empty? brackets)\n   \
    \     (= count 0)\n        (cond\n          [(string=? (substring brackets 0 1)\
    \ \"<\")\n           (loop (substring brackets 1) (+ count 1))]\n          [(string=?\
    \ (substring brackets 0 1) \">\")\n           (loop (substring brackets 1) (-\
    \ count 1))]\n          [else #f]))))\n", "  (define (helper brackets count)\n\
    \    (cond\n      [(empty? brackets) (= count 0)]\n      [(char=? (first brackets)\
    \ #\\<) (helper (rest brackets) (+ count 1))]\n      [(char=? (first brackets)\
    \ #\\>) (helper (rest brackets) (- count 1))]))\n  (helper brackets 0))\n", " \
    \ (define (iter n res)\n    (cond\n      [(zero? n) res]\n      [(< n 0) #f]\n\
    \      [else (iter (- n 1) (string-append res (first brackets)))]))\n  (iter (string-length\
    \ brackets) \"\"))\n\n", "  (define (is_open? char)\n    (string=? char \"<\"\
    ))\n  (define (is_close? char)\n    (string=? char \">\"))\n  (define (match?\
    \ open close)\n    (string=? open \"<\")\n    (string=? close \">\"))\n  (let\
    \ loop ([brackets brackets] [open-count 0])\n    (cond\n      [(empty? brackets)\n\
    \       (= open-count 0)]\n      [(is_open? (first brackets))\n       (loop (rest\
    \ brackets) (+ open-count 1))]\n      [(is_close? (first brackets))\n       (and\
    \ (> open-count 0)\n            (loop (rest brackets) (- open-count 1)))])))\n\
    ```\n\n---\n\n## Section 2: Expression Evaluation\n\nDefine the following functions\
    \ that return the **value** of an expression.\n\n```#lang racket", "  (andmap\
    \ (lambda (x) (not (and (char=? x #\\<) (char=? (string-ref brackets (+ 1 (string-index\
    \ x brackets))) #\\>)))) (string->list brackets)))\n", "  (cond [(empty? brackets)\
    \ #t]\n        [(string=? (first brackets) \"<\")\n         (cond [(empty? (rest\
    \ brackets)) #f]\n               [(string=? (first (rest brackets)) \">\")\n \
    \               (correct_bracketing (rest (rest brackets)))]\n               [else\
    \ (correct_bracketing (rest brackets))])]\n        [else (correct_bracketing (rest\
    \ brackets))]))\n", "  (define (open_brackets? character)\n    (char=? character\
    \ #\\<))\n  (define (close_brackets? character)\n    (char=? character #\\>))\n\
    \  (define (count_brackets? open_count close_count character)\n    (cond\n   \
    \   [(empty? character) (equal? open_count close_count)]\n      [(open_brackets?\
    \ (first character))\n       (count_brackets? (+ open_count 1) close_count (rest\
    \ character))]\n      [(close_brackets? (first character))\n       (count_brackets?\
    \ open_count (+ close_count 1) (rest character))]\n      [else (count_brackets?\
    \ open_count close_count (rest character))]))\n  (count_brackets? 0 0 brackets))\n",
  "  (cond [(empty? brackets) true]\n        [(eq? (first brackets) #\\<)\n      \
    \   (if (correct_bracketing (rest brackets))\n             (if (eq? (first (rest\
    \ brackets)) #\\>)\n                 (correct_bracketing (rest (rest brackets)))\n\
    \                 false)\n             false)]\n        [else false]))\n", " \
    \ (define (helper chars num)\n    (cond [(empty? chars) (= num 0)]\n         \
    \ [(char=? (first chars) #\\<) (helper (rest chars) (+ num 1))]\n          [(char=?\
    \ (first chars) #\\>) (and (positive? num) (helper (rest chars) (- num 1)))]\n\
    \          [else (helper (rest chars) num)]))\n  (helper (string->list brackets)\
    \ 0))\n", "  (cond [(string=? brackets \"\") #t]\n        [(string=? (substring\
    \ brackets 0 1) \"<\")\n         (cond [(string=? (substring brackets -1) \">\"\
    )\n                (correct_bracketing (substring brackets 1 -1))]\n         \
    \      [else #f])]\n        [else #f]))\n", "  (if (string=? \"\" brackets)\n\
    \      #t\n      (if (string=? (substring brackets 0 1) \"<\")\n          (if\
    \ (string=? (substring brackets -1) \">\")\n              (correct_bracketing\
    \ (substring brackets 1 (- (string-length brackets) 1)))\n              #f)\n\
    \          #f)))\n", "  (cond\n    [(empty? brackets) #t]\n    [(str=? (first\
    \ brackets) \">\") #f]\n    [(str=? (first brackets) \"<\")\n     (correct_bracketing\
    \ (rest brackets))]))\n", "  (error \"correct_bracketing not implemented yet\"\
    ))\n", "  (define opening (list))\n  (define (correct_bracketing_h brackets closing)\n\
    \    (if (null? brackets)\n        (if (null? closing)\n            #t\n     \
    \       #f)\n        (if (equal? (car brackets) \"<\")\n            (correct_bracketing_h\
    \ (cdr brackets) (cons (car brackets) closing))\n            (if (null? closing)\n\
    \                #f\n                (correct_bracketing_h (cdr brackets) (cdr\
    \ closing))))))\n  (correct_bracketing_h brackets opening))\n", "  (let loop ([brackets\
    \ brackets] [open 0])\n    (cond\n      [(empty? brackets) (= open 0)]\n     \
    \ [(char=? (first brackets) #\\<) (loop (rest brackets) (+ open 1))]\n      [(char=?\
    \ (first brackets) #\\>) (loop (rest brackets) (- open 1))]\n      [else (error\
    \ \"not a bracket!\")])))\n", "  (cond ((empty? brackets) #t)\n        ((equal?\
    \ (first brackets) #\\<)\n         (let* ([closing (member #\\> brackets)]\n \
    \               [opening (member #\\< brackets)])\n           (cond ((= opening\
    \ closing) #t)\n                 (else #f))))\n        (else #f)))\n", "  ...)\n",
  "  (define (helper bs)\n    (cond ((null? bs) #t)\n          ((equal? (first bs)\
    \ #\\<)\n           (if (member (first bs) (rest bs)) #f (helper (rest bs))))\n\
    \          ((equal? (first bs) #\\>)\n           (if (member (first bs) (rest\
    \ bs)) #f (helper (rest bs))))\n          (else #f)))\n  (helper (string->list\
    \ brackets)))", "  (if (empty? brackets)\n      #t\n      (if (equal? (first brackets)\
    \ #\\<)\n          (if (correct_bracketing (rest brackets))\n              (let\
    \ ((open (count \"</\" brackets)))\n                (if (zero? open)\n       \
    \             #f\n                    (correct_bracketing (combine (build-list\
    \ open \">\"))))))\n          (correct_bracketing (rest brackets)))))\n", "  (let\
    \ ((stack (list)))\n    (for ([char (in-string brackets)])\n      (match char\n\
    \        [\"<\" (push \"<\" stack)]\n        [\">\" (and (not (empty? stack))\
    \ (pop stack))]))\n    (empty? stack)))\n", "  (cond\n    [(empty? brackets) #t]\n\
    \    [(empty? (cdr brackets)) #f]\n    [(string=? (car brackets) \">\") #f]\n\
    \    [(string=? (cadr brackets) \"<\") #f]\n    [else (correct_bracketing (cdr\
    \ brackets))]))\n", "  ...)\n```\n\n## Sample 2\n\n```racket\n#lang racket\n",
  "  (local ((define num-open 0)\n          (define (incr) (set! num-open (+ num-open\
    \ 1)))\n          (define (decr) (set! num-open (- num-open 1))))\n    (for/and\
    \ ([c (in-string brackets)])\n      (cond [(equal? c #\\<) (incr)]\n         \
    \   [(equal? c #\\>) (decr)]\n            [else (error \"bad char\")]))\n    (zero?\
    \ num-open)))\n", "  (correct_bracketing_iter brackets \"\"))\n", "  (cond\n \
    \   [(empty? brackets) true]\n    [(string=? (substring brackets 0 1) \"<\")\n\
    \     (correct_bracketing (substring brackets 1))]\n    [(string=? (substring\
    \ brackets 0 1) \">\")\n     (and\n       (not (empty? brackets))\n       (correct_bracketing\
    \ (substring brackets 1)))]))\n", "  (define (helper idx)\n    (cond\n      [(>=\
    \ idx (string-length brackets)) #t]\n      [(equal? (string-ref brackets idx)\
    \ #\\<) (helper (add1 idx))]\n      [(equal? (string-ref brackets idx) #\\>) (if\
    \ (zero? idx) #f (helper (sub1 idx)))]))\n  (helper 0))\n", "  (cond\n    [(empty?\
    \ brackets) #t]\n    [(empty? (tail brackets)) #f]\n    [(string=? (string-append\
    \ (substring brackets 0 1) (substring brackets -1 1)) \"><\")\n     (correct_bracketing\
    \ (substring brackets 1 (- (string-length brackets) 1)))]\n    [else (correct_bracketing\
    \ (tail brackets))]))\n", "  (if (empty? brackets)\n      #t\n      (let ((n (string-length\
    \ brackets)))\n        (if (string=? (substring brackets 0 1) \"<\")\n       \
    \     (if (string=? (substring brackets (- n 1) n) \">\")\n                (correct_bracketing\
    \ (substring brackets 1 (- n 1)))\n                #f)\n            #f))))\n",
  "  (define (check_bracketing str i count)\n    (cond\n      [(empty? str)\n    \
    \   (and (= count 0) (= i (string-length brackets)))]\n      [(string=? (string-ref\
    \ str i) #\\<)\n       (check_bracketing str (+ i 1) (+ count 1))]\n      [(string=?\
    \ (string-ref str i) #\\>)\n       (and (> count 0) (check_bracketing str (+ i\
    \ 1) (- count 1)))]\n      [else (check_bracketing str (+ i 1) count)]))\n  (check_bracketing\
    \ brackets 0 0))\n", "  (cond\n    [(empty? brackets) #t]\n    [(empty? (cdr brackets))\
    \ #f]\n    [(correct_bracketing (substring (cdr brackets) 1)) #t]))\n", "  (correct_bracketing_helper\
    \ brackets 0))\n", "  (define (helper str i)\n    (cond [(eq? i (string-length\
    \ str))\n           #t]\n          [(or (eq? (string-ref str i) #\\<)\n      \
    \         (eq? (string-ref str i) #\\>))\n           (if (eq? (string-ref str\
    \ i) #\\<)\n               (if (eq? (string-ref str (+ i 1)) #\\>)\n         \
    \          (helper str (+ i 2))\n                   (helper str (+ i 1)))\n  \
    \             (helper str (+ i 1)))]\n          [else #f]))\n  (helper brackets\
    \ 0))\n```\n\n```\n#lang racket\n", "  (let loop ([b brackets] [open 0])\n   \
    \ (cond [(empty? b) (zero? open)]\n          [(char=? (first b) #\\<) (loop (rest\
    \ b) (+ open 1))]\n          [(char=? (first b) #\\>) (loop (rest b) (- open 1))]\n\
    \          [else (loop (rest b) open)])))\n", "  (cond\n    [(empty? brackets)\
    \ #t]\n    [(empty? (rest brackets)) (equal? (first brackets) #\\<)]\n    [(equal?\
    \ (first brackets) #\\<) (correct_bracketing (rest brackets))]\n    [(equal? (first\
    \ brackets) #\\>) #f]))\n", "  (cond\n    [(null? brackets) #t]\n    [(string=?\
    \ (string-append brackets \" \") \">< \") #f]\n    [(string=? (string-append brackets\
    \ \" \") \"<> \") #t]\n    [(string=? (string-append brackets \" \") \"<<><>>\
    \ \") #t]\n    [(string=? (string-append brackets \" \") \"><<> \") #f]))\n",
  "  (define (is-opening? b) (eq? b #\\<))\n  (define (is-closing? b) (eq? b #\\>))\n\
    \  (let loop ([brackets (string->list brackets)]\n             [balance 0])\n\
    \    (if (null? brackets)\n        (zero? balance)\n        (if (is-opening? (car\
    \ brackets))\n            (loop (cdr brackets) (+ balance 1))\n            (if\
    \ (is-closing? (car brackets))\n                (loop (cdr brackets) (- balance\
    \ 1))\n                #f)))))\n\n", "  (cond\n    [(empty? brackets) (error \"\
    there are no brackets\")]\n    [(string=? (first brackets) \"<\") (correct_bracketing\
    \ (rest brackets))]\n    [(string=? (first brackets) \">\") #f]\n    [else (error\
    \ \"unexpected input\")]))\n", "  ;; You can use this function\n  (define (matches\
    \ c1 c2)\n    (and (char=? c1 #\\<) (char=? c2 #\\>)))\n  ;; Your code here\n\
    \  )\n```\n\n## Questions\n```racket\n#lang racket\n", "  (local [(define (count-left\
    \ string n)\n             (cond [(empty? string) n]\n                   [(char=?\
    \ (first string) #\\<) (count-left (rest string) (+ n 1))]\n                 \
    \  [else (count-left (rest string) n)]))\n          (define (count-right string\
    \ n)\n             (cond [(empty? string) n]\n                   [(char=? (first\
    \ string) #\\>) (count-right (rest string) (+ n 1))]\n                   [else\
    \ (count-right (rest string) n)]))]\n    (let ([s (string->list brackets)])\n\
    \      (and (= (count-left s 0) (count-right s 0))\n           (= (count-left\
    \ s 0) (count-right (reverse s) 0))))))", "  (define (helper str openings)\n \
    \   (cond\n      [(empty? str) (zero? openings)]\n      [(string=? (first str)\
    \ \">\") (and (> openings 0) (helper (rest str) (- openings 1)))]\n      [else\
    \ (helper (rest str) (+ openings 1))]))\n  (helper brackets 0))\n", "  (if (string-length\
    \ brackets)\n      (if (equal? (string-ref brackets 0) #\\<)\n          (correct_bracketing\
    \ (substring brackets 1 (string-length brackets)) 1)\n          (if (equal? (string-ref\
    \ brackets 0) #\\>)\n              (correct_bracketing (substring brackets 1 (string-length\
    \ brackets)) -1)\n              #f))\n      (if (zero? (string-length brackets))\n\
    \          #t\n          #f)))\n", "  (let ([open-brackets (in-string brackets\
    \ \"<\")]\n        [close-brackets (in-string brackets \">\")])\n    (and (= (string-length\
    \ open-brackets) (string-length close-brackets))\n         (andmap (lambda (a\
    \ b) (< a b)) open-brackets close-brackets))))\n", "  (cond [(string=? brackets\
    \ \"\") #t]\n        [(or (string=? (substring brackets 0 1) \"<\")\n        \
    \     (string=? (substring brackets 0 1) \">\"))\n         (if (string=? (substring\
    \ brackets 0 1) \"<\")\n             (correct_bracketing (substring brackets 1))\n\
    \             (string=? (substring brackets 0 1) \">\"))]\n        [else (string=?\
    \ brackets \"><\")]))\n", "  (cond\n    [(string=? brackets \"\") #t]\n    [(char=?\
    \ (string-ref brackets 0) #\\<)\n     (cond\n       [(char=? (string-ref brackets\
    \ (- (string-length brackets) 1)) #\\>)\n        (correct_bracketing (substring\
    \ brackets 1 (- (string-length brackets) 1)))]\n       [else #f])]\n    [else\
    \ #f]))\n", "  (define (correct_bracketing-helper open_count brackets_list)\n\
    \    (cond\n      ((null? brackets_list) (zero? open_count))\n      ((equal? (car\
    \ brackets_list) \"<\") (correct_bracketing-helper (+ open_count 1) (cdr brackets_list)))\n\
    \      ((equal? (car brackets_list) \">\") (correct_bracketing-helper (- open_count\
    \ 1) (cdr brackets_list)))\n      (else (error \"Unexpected character\"))))\n\
    \  (correct_bracketing-helper 0 (string->list brackets)))", "  (cond [(empty?\
    \ brackets) #t]\n        [(and (string=? (first brackets) \"<\")\n           \
    \   (string=? (last brackets) \">\"))\n         (correct_bracketing (substring\
    \ brackets 1 (- (string-length brackets) 1)))]\n        [else #f]))\n", "  (cond\
    \ [(string=? brackets \"\") #t]\n        [(string=? (substring brackets 0 1) \"\
    <\")\n         (cond [(string=? (substring brackets -1) \">\")\n             \
    \   (correct_bracketing (substring brackets 1 -1))]\n               [else #f])]\n\
    \        [else #f]))\n", "  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\
    \  ;; TODO: replace the #f with the appropriate code\n  #f\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\
    \  )\n```\n\n## Analyses that do not flow\n\n### Information Loss\n\nInformation\
    \ Loss is the notion that, when two variables are merged, the variable may be\
    \ set to a value that is not actually possible. For example, in the following\
    \ code, \n\n```racket\n#lang racket\n", "  (correct_bracketing_iter brackets 0))\n",
  "    (cond\n        [(empty? brackets) #t]\n        [(eq? (first brackets) #\\<)\
    \ (and (correct_bracketing (bf brackets))\n                                  \
    \        (not (empty? (bf (bf brackets)))))]\n        [(eq? (first brackets) #\\\
    >) #f]))\n", "  (cond\n    [(string=? brackets \"\") #t]\n    [(or (string=? (substring\
    \ brackets 0 1) \"<\")\n         (string=? (substring brackets 0 1) \">\"))\n\
    \     (correct_bracketing (substring brackets 1))]\n    [(and (string=? (substring\
    \ brackets 0 1) \"<\")\n          (string=? (substring brackets 1 1) \">\"))\n\
    \     (correct_bracketing (substring brackets 2))]\n    [else\n     #f]))\n",
  "  (if (eq? (string-length brackets) 0)\n      #t\n      (if (or (string=? (substring\
    \ brackets 0 1) \"<\")\n              (string=? (substring brackets 0 1) \">\"\
    ))\n          (if (or (string=? (substring brackets 0 1) \"<\")\n            \
    \      (and (string=? (substring brackets 0 1) \">\")\n                      \
    \ (or (string=? (substring brackets 1 1) \">\")\n                           (string=?\
    \ (substring brackets 1 1) \"<\"))))\n              (correct_bracketing (substring\
    \ brackets 1))\n              #f)\n          #f)))\n", "  (define (correct_helper\
    \ left_open left_close)\n    (cond ((null? brackets) (= left_open left_close))\n\
    \          ((char=? (car brackets) #\\<)\n           (correct_helper (+ left_open\
    \ 1) left_close))\n          ((char=? (car brackets) #\\>)\n           (correct_helper\
    \ left_open (+ left_close 1)))\n          (else (error \"invalid input\"))))\n\
    \  (correct_helper 0 0))\n```\n\n## Another Solution:\n\n```racket\n#lang racket\n",
  "  (equal? 0 (count_opening_closing_brackets brackets #f)))\n", "  (define (counter\
    \ s)\n    (cond\n      [(empty? s) 0]\n      [(equal? (first s) \"<\") (+ 1 (counter\
    \ (rest s)))]\n      [(equal? (first s) \">\") (- 1 (counter (rest s)))]))\n \
    \ (and (not (negative? (counter brackets))) (equal? (counter brackets) 0)))\n\n",
  "  (cond\n    [(zero? (string-length brackets)) #t]\n    [(and\n      (= (string-ref\
    \ brackets 0) #\\<)\n      (= (string-ref brackets (sub1 (string-length brackets)))\
    \ #\\>))\n      (correct_bracketing (substring brackets 1 (sub1 (string-length\
    \ brackets))))]\n    [else #f]))\n```\n\n### Exercise 23.2\n\n``` #lang racket\n",
  "  (cond\n    [(empty? brackets) #t]\n    [(char=? (first brackets) #\\<)\n    \
    \ (if (char=? (last brackets) #\\>)\n         (correct_bracketing (substring brackets\
    \ 1 (- (string-length brackets) 1)))\n         #f)]\n    [else #f]))\n```\n###\
    \ 3.3:\n\n```#lang racket\n", "  (define (count_brackets brackets count)\n   \
    \ (cond ((equal? count 0) #t)\n          ((or (equal? (first brackets) \"<\")\
    \ (equal? (first brackets) \">\"))\n           (count_brackets (rest brackets)\
    \ (+ count (if (equal? (first brackets) \"<\") 1 -1))))\n          (else (count_brackets\
    \ (rest brackets) count))))\n  (count_brackets brackets 0))\n", "  (if (= (string-length\
    \ brackets) 0)\n      #t\n      (cond ((string= (substring brackets 0 1) \"<\"\
    )\n             (cond ((string= (substring brackets -1) \">\")\n             \
    \       (correct_bracketing (substring brackets 1 -1)))\n                   (else\
    \ #f)))\n            (else #f))))\n```\n\n### `count_letters` ###\n\n```\n#lang\
    \ racket\n", "  (cond\n    [(string=? brackets \"\") #t]\n    [(and (string-index\
    \ brackets #\\<) (string-index brackets #\\>))\n     (let ([index (string-index\
    \ brackets #\\<)])\n       (correct_bracketing (string-drop brackets (add1 index)))]\n\
    \     )\n    [else #f]\n    )\n  )\n", "  (let loop ([brackets brackets] [stack\
    \ '()])\n    (cond [(empty? brackets)\n           (empty? stack)]\n          [(char=?\
    \ (first brackets) #\\<)\n           (loop (rest brackets) (cons #\\< stack))]\n\
    \          [(char=? (first brackets) #\\>)\n           (if (empty? stack)\n  \
    \             #f\n               (loop (rest brackets) (rest stack)))])))\n",
  "  (cond\n    [(empty? brackets) #t]\n    [(symbol=? (first brackets) \">\") #f]\n\
    \    [else (and (correct_bracketing (rest brackets))\n               (symbol=?\
    \ (first brackets) \"<\"))]))\n", "  (cond\n    [(empty? brackets) #t]\n    [(string=?\
    \ (first brackets) \">\") #f]\n    [(string=? (first brackets) \"<\")\n     (if\
    \ (empty? (rest brackets))\n         #f\n         (correct_bracketing (rest brackets)))]))\n",
  "  (cond\n    [(empty? brackets) #t]\n    [(string=? (first brackets) \"<\")\n \
    \    (cond\n       [(correct_bracketing (rest brackets)) #t]\n       [else #f])]\n\
    \    [(string=? (first brackets) \">\")\n     (cond\n       [(correct_bracketing\
    \ (rest brackets)) #t]\n       [else #f])]))\n", "  (if (string-length brackets)\n\
    \      (if (char=? (string-ref brackets 0) #\\<)\n          (if (char=? (string-ref\
    \ brackets (sub1 (string-length brackets))) #\\>)\n              (if (string-length\
    \ brackets)\n                  (if (char=? (string-ref brackets 0) #\\<)\n   \
    \                   (if (char=? (string-ref brackets (sub1 (string-length brackets)))\
    \ #\\>)\n                          (if (> (string-length brackets) 2)\n      \
    \                        (correct_bracketing (substring brackets 1 (sub1 (string-length\
    \ brackets))))\n                              #t)\n                          #f)\n\
    \                      #f)\n                  #t)\n              #f)\n       \
    \   #f)\n      #t))\n", "  (let* ((b-len (string-length brackets))\n\t (i 0)\n\
    \t (count 0))\n    (if (not (string= brackets \"\"))\n\t(if (string= (substring\
    \ brackets i (+ i 1)) \"<\")\n\t    (begin\n\t      (set! count (+ count 1))\n\
    \t      (set! i (+ i 1))\n\t      (correct_bracketing (substring brackets i b-len)))\n\
    \t    (if (string= (substring brackets i (+ i 1)) \">\")\n\t\t(begin\n\t\t  (set!\
    \ count (- count 1))\n\t\t  (set! i (+ i 1))\n\t\t  (correct_bracketing (substring\
    \ brackets i b-len)))\n\t\t(correct_bracketing (substring brackets i b-len))))\n\
    \t(if (= count 0)\n\t    #t\n\t    #f))))\n", "  ;; complete the body of this\
    \ function\n  )\n```\n\n```\n#lang racket\n", "  (cond [(empty? brackets) #t]\n\
    \        [(symbol=? (first brackets) '<)\n         (if (empty? (rest brackets))\n\
    \             #f\n             (correct_bracketing (rest brackets)))]\n      \
    \  [(symbol=? (first brackets) '>)\n         (if (empty? (rest brackets))\n  \
    \           #f\n             (correct_bracketing (rest brackets)))]))\n", "  (let\
    \ loop ([input (string->list brackets)]\n             [stack '()])\n    (if (null?\
    \ input)\n        (null? stack)\n        (if (eq? (car input) #\\<)\n        \
    \    (loop (cdr input) (cons #\\< stack))\n            (if (null? stack)\n   \
    \             #f\n                (loop (cdr input) (cdr stack)))))))\n", "  (cond\n\
    \    [(empty? brackets) #t]\n    [(and\n      (char=? (first brackets) #\\<)\n\
    \      (char=? (rest brackets) #\\>)) #t]\n    [else #f]))\n", "  (cond\n    [(null?\
    \ brackets) #t]\n    [(empty? (rest brackets)) #f]\n    [(correct_bracketing (string-tail\
    \ (string-tail brackets))) #t]))\n", "  (cond\n    [(empty? brackets) #t]\n  \
    \  [(and (string=? (first brackets) \"<\")\n          (string=? (last brackets)\
    \ \">\")) (correct_bracketing (substring brackets 1 (- (string-length brackets)\
    \ 1)))]\n    [else #f]))\n", "    (cond\n        ((null? brackets) #t)\n     \
    \   ((char=? (string-ref brackets 0) #\\<)\n         (correct_bracketing (string-tail\
    \ brackets)))\n        ((char=? (string-ref brackets 0) #\\>)\n         (correct_bracketing\
    \ (string-tail brackets)))\n        (else #f)))\n", "  (if (= (string-length brackets)\
    \ 0)\n      #t\n      (if (string= (substring brackets 0 1) \"<\")\n         \
    \ (if (string= (substring brackets -1) \">\")\n              (correct_bracketing\
    \ (substring brackets 1 -1))\n              #f)\n          #f)))\n", "  (cond\
    \ ((equal? brackets \"\") #t)\n        ((equal? (substring brackets 0 1) \"<\"\
    )\n         (if (equal? (substring brackets -1) \">\")\n             (correct_bracketing\
    \ (substring brackets 1 -1))\n             #f))\n        (else #f)))\n```", " \
    \ (cond ((zero? (string-length brackets)) #t)\n        ((equal? (string-ref brackets\
    \ 0) #\\<)\n         (cond ((zero? (string-length (substring brackets 1))) #f)\n\
    \               ((equal? (string-ref (substring brackets 1) 0) #\\>)\n       \
    \         (correct_bracketing (substring brackets 2)))\n               (else (correct_bracketing\
    \ (substring brackets 1)))))\n        (else (correct_bracketing (substring brackets\
    \ 1)))))\n", "  (cond [(empty? brackets) #t]\n        [(char=? (first brackets)\
    \ #\\<)\n         (cond [(empty? (rest brackets)) #f]\n               [(char=?\
    \ (first (rest brackets)) #\\>)\n                (correct_bracketing (rest (rest\
    \ brackets)))]\n               [else #f])]\n        [else #f]))\n", "  (cond [(string=?\
    \ brackets \"\") #t]\n        [(string=? (substring brackets 0 1) \"<\")\n   \
    \      (cond [(string=? (substring brackets -1) \">\")\n                (correct_bracketing\
    \ (substring brackets 1 -1))]\n               [else #f])]\n        [else #f]))\n",
  "  ;; In Racket, strings act like lists of characters.\n  ;; So you can use recursion\
    \ over a string the same way you would over a list.\n  ;; Hint: to test if a character\
    \ is #\\<, use (char=? c #\\<)\n  #true))\n", "  (define (iter count br)\n   \
    \ (cond\n      [(empty? br) (= count 0)]\n      [(first br) (iter (add1 count)\
    \ (rest br))]\n      [else (and (> count 0) (iter (sub1 count) (rest br)))]))\n\
    \  (iter 0 (map (\u03BB (b) (equal? b #\\<)) (string->list brackets))))\n```\n\
    \n`blanks` is a string of \"-\"s and \"+\"s.\nReturn #t if the pluses form a \"\
    rectangle\", i.e. there is a contiguous\nsequence of `n` pluses, followed by a\
    \ contiguous sequence of `n` pluses,\nwhere `n` is the width of the first contiguous\
    \ sequence.\n\n>>> (rectangle \"-++\")\n#t\n>>> (rectangle \"---+-\")\n#f\n>>>\
    \ (rectangle \"+--++\")\n#t\n>>> (rectangle \"---+---+---\")\n#t\n>>> (rectangle\
    \ \"---++--++-\")\n#f\n>>> (rectangle \"---+---+----\")\n#f\n>>> (rectangle \"\
    ++--++-\")\n#t\n\n```racket\n#lang racket\n", "  (and (not (eq? (char-&gt;integer\
    \ (string-ref brackets 0)) 60))\n       (not (eq? (char-&gt;integer (string-ref\
    \ brackets (sub1 (string-length brackets)))) 62))))\n</code>\nThe purpose of this\
    \ is to check if the first char is a <code>&lt;</code> and the last char is a\
    \ <code>&gt;</code>.\nI want to know if there is any way to improve this code?\n\
    In particular I don't like this line:\n<code>(eq? (char-&gt;integer (string-ref\
    \ brackets 0)) 60)\n</code>\nIs there any better way to compare the char? \nOr\
    \ maybe I can do this in a better way?\n\n\nA:\n\nNot that I would call this an\
    \ improvement, but maybe you want:\n<code>(define (correct_bracketing brackets)\n\
    \  (not (or (= (string-ref brackets 0) #\\&lt;)\n           (= (string-ref brackets\
    \ (sub1 (string-length brackets))) #\\&gt;))))\n</code>\nI don't see why you need\
    \ to convert the character to an integer. Also note that we can test for equality\
    \ with the <code>=</code> procedure.\nIf the only issue is that you're not happy\
    \ with the test for <code>&lt;</code> and <code>&gt;</code>, I'd have used a macro:\n\
    <code>(define-syntax matching-brackets?\n  (syntax-rules ()\n    [(_ &lt;) #t]\n\
    \    [(_ &gt;) #f]))\n", "  (define (helper brackets count)\n    (cond\n     \
    \ [(empty? brackets) (= count 0)]\n      [(char=? (first brackets) #\\<) (helper\
    \ (rest brackets) (+ count 1))]\n      [(char=? (first brackets) #\\>) (and (<\
    \ count 1) (helper (rest brackets) (- count 1)))]))\n  (helper brackets 0))\n\
    ```\n\n```racket", "  (cond\n    [(empty? brackets) #t]\n    [(empty? (rest brackets))\
    \ #f]\n    [(equal? (first brackets) \"<\")\n     (cond\n       [(equal? (first\
    \ (rest brackets)) \">\")\n        (correct_bracketing (rest (rest brackets)))]\n\
    \       [else\n        (correct_bracketing (cons (first (rest brackets)) (rest\
    \ (rest brackets))))])]\n    [else\n     (correct_bracketing (rest brackets))]))\n",
  "  ...)\n", "  (define (correct? brackets)\n    (cond\n      [(empty? brackets)\
    \ true]\n      [(or (equal? (first brackets) \"<\") (equal? (first brackets) \"\
    >\"))\n       (correct? (rest brackets))]\n      [(or (equal? (first brackets)\
    \ \"<>\") (equal? (first brackets) \"><\"))\n       (correct? (rest (rest brackets)))]\n\
    \      [else false]))\n  (correct? (list->string brackets)))\n", "  (cond\n  \
    \  [(empty? brackets)\n     #t]\n    [(or (equal? (first brackets) #\\<)\n   \
    \      (equal? (first brackets) #\\>))\n     (correct_bracketing (rest brackets))]\n\
    \    [else\n     #f]))\n", "  (if (empty? brackets) #t\n      (let ([left (string-take\
    \ brackets 1)]\n            [rest (string-drop brackets 1)])\n        (if (eq?\
    \ left \"<\")\n            (if (string-contains rest \">\")\n                (correct_bracketing\
    \ (string-replace rest \">\" \"\"))\n                #f)\n            #f))))\n",
  "  (cond\n    [(empty? brackets) #t]\n    [(string=? (first brackets) \"<\")\n \
    \    (correct_bracketing (rest brackets))]\n    [(string=? (first brackets) \"\
    >\")\n     (string=? (rest brackets) \"\")]\n    [else #f]))\n", "    (and\n \
    \    (and (correct_bracketing_helper brackets 0) (<= (correct_bracketing_helper\
    \ brackets 0) 0))\n     (and (correct_bracketing_helper brackets 1) (>= (correct_bracketing_helper\
    \ brackets 1) 0))))\n", "  (let loop ([brackets brackets] [count 0])\n    (if\
    \ (zero? count)\n        (if (empty? brackets)\n            #t\n            (if\
    \ (equal? (first brackets) #\\<)\n                (loop (rest brackets) (+ count\
    \ 1))\n                #f))\n        (if (empty? brackets)\n            #f\n \
    \           (if (equal? (first brackets) #\\>)\n                (loop (rest brackets)\
    \ (- count 1))\n                #f)))))\n", "  (cond ((null? brackets) #t)\n \
    \       ((string=? (substring brackets 0 1) \"<\")\n         (if (string=? (substring\
    \ brackets -1) \">\")\n             (correct_bracketing (substring brackets 1\
    \ -1))\n             #f))\n        (else #f)))\n", "  (cond\n    [(equal? brackets\
    \ \"\") #t]\n    [(equal? (substring brackets 0 1) \"<\")\n     (if (equal? (substring\
    \ brackets -1) \">\")\n         (correct_bracketing (substring brackets 1 -1))\n\
    \         #f)]\n    [else #f]))\n", "  ;; you must use an accumulator\n  )\n",
  "  (if (string-empty? brackets)\n      #t\n      (cond ((string=? (substring brackets\
    \ 0 1) \"<\")\n             (if (string=? (substring brackets -1) \">\")\n   \
    \              (correct_bracketing (substring brackets 1 -1))\n              \
    \   #f))\n            ((string=? (substring brackets 0 1) \">\")\n           \
    \  #f))))\n</code>\n\nExercise: Translating Scheme to Racket\n\n\nA:\n\nYour function\
    \ almost works, but it has two issues:\n\nIt's not tail-recursive. When calling\
    \ itself, you're passing a string 1 char shorter than the original one, but you're\
    \ not shortening the original one. When calling tail-recursively, you must call\
    \ it with an argument that is the same length as the input.\nA <code>&gt;</code>\
    \ after an <code>&lt;</code> is not an invalid bracketing. Try <code>&lt;&gt;</code>.\n\
    \nHere's a tail-recursive solution:\n<code>(define (correct-bracketing brackets)\n\
    \  (cond ((string-empty? brackets) #t)\n        ((string=? (substring brackets\
    \ 0 1) \"&gt;\") #f)\n        ((string=? (substring brackets -1) \"&lt;\") #f)\n\
    \        (else (correct-bracketing (substring brackets 1)))))\n</code>\nThe trick\
    \ is to remove one char from the beginning of the string in each call, and the\
    \ string is assumed to be valid unless proven otherwise.\n", "  (and (symbol=?\
    \ brackets \"\")\n       true))\n", "  ...)\n```\n\n### Search\n\n```#lang racket\n",
  "  (define (f brackets count)\n    (cond [(equal? brackets \"\") (= count 0)]\n\
    \          [(equal? (first brackets) \"<\") (f (rest brackets) (+ count 1))]\n\
    \          [(equal? (first brackets) \">\") (f (rest brackets) (- count 1))]\n\
    \          [else #f]))\n  (f brackets 0))\n", "  (cond\n    ((empty? brackets)\
    \ #t)\n    ((char=? (first brackets) #\\<)\n     (define new-brackets (rest brackets))\n\
    \     (cond\n       ((empty? new-brackets) #f)\n       ((char=? (first new-brackets)\
    \ #\\>)\n        (correct_bracketing (rest new-brackets)))\n       (else (correct_bracketing\
    \ new-brackets))))\n    (else (correct_bracketing (rest brackets)))))\n", "  (cond\n\
    \    [(empty? brackets)  #t]\n    [(empty? (rest brackets)) #f]\n    [(string=?\
    \ (first brackets) \"<\")\n     (cond\n       [(string=? (first (rest brackets))\
    \ \">\")\n        (correct_bracketing (rest (rest brackets)))]\n       [else (correct_bracketing\
    \ (rest brackets))])]\n    [else #f]))\n", "  (cond [(string=? brackets \"\")\
    \ #t]\n        [(string=? (substring brackets 0 1) \"<\") (correct_bracketing\
    \ (substring brackets 1))]\n        [(string=? (substring brackets 0 1) \">\"\
    ) (correct_bracketing (substring brackets 1))]\n        [else #f]))\n", "  (cond\n\
    \    [(empty? brackets) #t]\n    [(empty? (rest brackets)) (if (char=? (first\
    \ brackets) #\\<) #f #t)]\n    [(char=? (first brackets) #\\>) #f]\n    [else\
    \ (correct_bracketing (rest brackets))]))\n", "  (let\n    ([bracketing-helper\n\
    \      (lambda (chars count)\n        (cond\n          [(empty? chars) (zero?\
    \ count)]\n          [(char=? (first chars) #\\<) (bracketing-helper (rest chars)\
    \ (+ count 1))]\n          [(char=? (first chars) #\\>) (bracketing-helper (rest\
    \ chars) (- count 1))]\n          [else (bracketing-helper (rest chars) count)]))])\n\
    \    (bracketing-helper (string->list brackets) 0)))\n", "  (even? (length brackets)))\n",
  "  (cond [(empty? brackets) false]\n        [(equal? (first brackets) #\\<) (correct_bracketing\
    \ (rest brackets))]\n        [(equal? (first brackets) #\\>) false]\n        [else\
    \ (correct_bracketing (rest brackets))]))\n", "  ; TODO\n  #f)\n", "  (let ((stack\
    \ '()))\n    (do ((count 0 (+ count 1)))\n\t((= count (string-length brackets))\n\
    \t (if (empty? stack)\n\t     #t\n\t     #f))\n      (let ((current-char (string-ref\
    \ brackets count)))\n\t(cond\n\t ((= current-char #\\<)\n\t  (push 'less-than\
    \ stack))\n\t ((= current-char #\\>)\n\t  (if (empty? stack)\n\t      (push 'greater-than\
    \ stack)\n\t      (pop stack))))))))\n", "    (cond\n        [(string=? brackets\
    \ \"\") #t]\n        [(string=? (substring brackets 0 1) \"<\") (if (string=?\
    \ (substring brackets -1) \">\") (correct_bracketing (substring brackets 1 -1))\
    \ #f)]\n        [else #f]))\n```\n\n### More Recursion Practice\n\nTry these in\
    \ Racket.\n\n1. **Double every element in a list**\n\n  ```scheme\n  ;; double_list\
    \ is a list of numbers.\n  ;; return a list with every element of double_list\
    \ doubled.\n  ;; >>> (double_list (list 1 2 3))\n  ;; '(2 4 6)\n  ;; >>> (double_list\
    \ (list))\n  ;; '()\n  ;; >>> (double_list (list 1 2 3 4 5))\n  ;; '(2 4 6 8 10)\n\
    \  (define (double_list double_list)\n      (cond\n          [(empty? double_list)\
    \ '()]\n          [else (cons (* 2 (first double_list)) (double_list (rest double_list)))]))\n\
    \  ```\n\n2. **Reverse a list**\n\n  ```scheme\n  ;; lst is a list of items.\n\
    \  ;; return a list with the items of lst in reverse order.\n  ;; >>> (reverse\
    \ (list 1 2 3))\n  ;; '(3 2 1)\n  ;; >>> (reverse (list))\n  ;; '()\n  ;; >>>\
    \ (reverse (list 1 2 3 4 5))\n  ;; '(5 4 3 2 1)\n  (define (reverse lst)\n   \
    \   (cond\n          [(empty? lst) '()]\n          [else (append (reverse (rest\
    \ lst)) (list (first lst)))]))\n  ```\n\n3. **Check if a list is sorted**\n\n\
    \  ```scheme\n  ;; lst is a list of numbers.\n  ;; return #t if every pair of\
    \ consecutive elements in lst is in order,\n  ;; #f otherwise.\n  ;; >>> (is_sorted\
    \ (list 1 2 3))\n  ;; #t\n  ;; >>> (is_sorted (list 1 2 3 4 5))\n  ;; #t\n  ;;\
    \ >>> (is", "  (if (empty? brackets)\n      #t\n      (define num-openings (count\
    \ (\u03BB (c) (equal? c #\\<)) brackets))\n      (define num-closings (count (\u03BB\
    \ (c) (equal? c #\\>) brackets))\n      (equal? num-openings num-closings))\n\
    \      (if (empty? brackets)\n      #t\n      (define first-char (first brackets))\n\
    \      (if (equal? first-char #\\<)\n      (correct_bracketing (rest brackets))\n\
    \      #f))))\n", "  (cond\n    [(empty? brackets) #t]\n    [(or (equal? (first\
    \ brackets) #\\<) (equal? (first brackets) #\\>))\n     (correct_bracketing (rest\
    \ brackets))]\n    [else (and (equal? (first brackets) #\\<)\n               (and\
    \ (second brackets) (equal? (second brackets) #\\>))\n               (correct_bracketing\
    \ (rest (rest brackets))))]))\n", "  (define (helper brackets counter)\n    (cond\
    \ ((null? brackets) (= counter 0))\n          ((= (string-ref brackets 0) #\\\
    <) (helper (substring brackets 1) (+ counter 1)))\n          ((= (string-ref brackets\
    \ 0) #\\>) (and (> counter 0) (helper (substring brackets 1) (- counter 1))))))\n\
    \  (helper brackets 0))\n```\n\n## 3-2\n\n``` #lang racket\n", "  (define (bracket\
    \ helper count)\n    (cond\n      ((or (string=? count 0) (string=? brackets \"\
    \"))\n       #t)\n      ((string=? (string-ref brackets 0) #\\<)\n       (bracket\
    \ helper (string-append count #\\<)))\n      ((string=? (string-ref brackets 0)\
    \ #\\>)\n       (if (string=? count \"\")\n           #f\n           (bracket\
    \ helper (string-drop count 1))))\n      (else (bracket (string-drop brackets\
    \ 1) count))))\n  (bracket brackets \"\"))\n```\n\n```racket\n#lang racket\n",
  "  (define (correct_helper brackets counter)\n    (cond\n      [(empty? brackets)\
    \ (empty? counter)]\n      [(char=? (first brackets) #\\<) (correct_helper (rest\
    \ brackets) (cons 1 counter))]\n      [(char=? (first brackets) #\\>) (and (not\
    \ (empty? counter)) (correct_helper (rest brackets) (rest counter)))]))\n  (correct_helper\
    \ brackets empty))\n", "  (let loop ([i 0] [opening 0])\n    (cond\n      [(string=?\
    \ brackets \"\") (zero? opening)]\n      [(string=? (substring brackets i (+ i\
    \ 1)) \"<\")\n       (loop (+ i 1) (+ opening 1))]\n      [(string=? (substring\
    \ brackets i (+ i 1)) \">\")\n       (and (> opening 0) (loop (+ i 1) (- opening\
    \ 1)))]\n      [else (loop (+ i 1) opening)])))\n```\n\n```racket", "  (cond ((string=?\
    \ \"\" brackets) #t)\n        ((and (string=? (substring brackets 0 1) \"<\")\
    \ (string=? (substring brackets (sub1 (string-length brackets))) \">\"))\n   \
    \      (correct_bracketing (substring brackets 1 (sub1 (string-length brackets)))))\n\
    \        ((string=? (substring brackets 0 1) \"<\") (correct_bracketing (substring\
    \ brackets 1 (string-length brackets))))\n        (else #f)))\n", "  (letrec ([open\
    \ (\u03BB (c) (equal? c #\\<))]\n           [close (\u03BB (c) (equal? c #\\>))]\n\
    \           [is_open (\u03BB (n) (andmap open (string->list brackets)))]\n   \
    \        [is_close (\u03BB (n) (andmap close (string->list brackets)))]\n    \
    \       [count (\u03BB (bools) (length (filter bools (range (length bools)))))]\n\
    \           [count_open (\u03BB (n) (count is_open))]\n           [count_close\
    \ (\u03BB (n) (count is_close))])\n    (if (zero? (count_open))\n        #t\n\
    \        (if (zero? (count_close))\n            #f\n            (if (not (zero?\
    \ (count_open)))\n                (andmap open (string->list brackets))\n    \
    \            (andmap close (string->list brackets)))))))\n", "  (if (null? brackets)\n\
    \      #t\n      (if (or (string=? (first brackets) \"<\") (string=? (first brackets)\
    \ \">\"))\n          (if (string=? (first brackets) \"<\")\n              (correct_bracketing\
    \ (rest brackets))\n              (string=? (first (rest brackets)) \"<\"))\n\
    \          #f)))\n", "  (letrec ([bfs (queue '())]\n           [enqueue (lambda\
    \ (char)\n                      (enqueue! bfs char))]\n           [bfs-empty?\
    \ (lambda ()\n                         (empty? bfs))]\n           [dequeue (lambda\
    \ ()\n                      (dequeue! bfs))]\n           [explore (lambda (brackets)\n\
    \                      (cond [(empty? brackets)\n                            \
    \ #t]\n                            [(char=? (first brackets) #\\<)\n         \
    \                    (enqueue (first brackets))\n                            \
    \ (explore (rest brackets))]\n                            [(char=? (first brackets)\
    \ #\\>)\n                             (if (bfs-empty?)\n                     \
    \            #f\n                                 (begin\n                   \
    \                (dequeue)\n                                   (explore (rest\
    \ brackets))))]))])\n    (explore brackets)))\n", "  (define (helper brackets\
    \ left right)\n    (cond\n      [(empty? brackets) (eq? left right)]\n      [(char=?\
    \ (first brackets) #\\<) (helper (rest brackets) (+ left 1) right)]\n      [(char=?\
    \ (first brackets) #\\>) (helper (rest brackets) left (+ right 1))]\n      [else\
    \ (helper (rest brackets) left right)]))\n  (and (and (>= (string-length brackets)\
    \ 1)\n            (<= (string-length brackets) 50))\n       (helper brackets 0\
    \ 0)))\n", "  (let ([count 0])\n    (for ([ch (in-string brackets)])\n      (cond\
    \ [(char=? ch #\\<) (set! count (+ count 1))]\n            [(char=? ch #\\>) (set!\
    \ count (- count 1))]))\n    (= count 0)))\n", "  (define (matching-bracket? char)\n\
    \    (cond\n      [(equal? char #\\<) #\\>]\n      [(equal? char #\\>) #\\<]\n\
    \      [else (error \"unknown bracket\")]))\n  (define (bracket-queue char bracket-stack)\n\
    \    (cond\n      [(empty? bracket-stack) (append-to-stack bracket-stack char)]\n\
    \      [(equal? (first bracket-stack) (matching-bracket? char)) (rest bracket-stack)]\n\
    \      [else (append-to-stack bracket-stack char)]))\n  (equal? '() (foldl bracket-queue\
    \ '() brackets)))\n", "  (local [(define (helper brack output)\n            (cond\n\
    \              [(string=? brack \"\")\n               (if (equal? output 0)\n\
    \                   #t\n                   #f)]\n              [(string=? (substring\
    \ brack 0 1) \"<\")\n               (helper (substring brack 1) (+ output 1))]\n\
    \              [(string=? (substring brack 0 1) \">\")\n               (if (>\
    \ output 0)\n                   (helper (substring brack 1) (- output 1))\n  \
    \                 #f)]))]\n    (helper brackets 0)))\n", "  (equal? (count \"\
    <\" brackets) (count \">\" brackets)))\n", "  (if (empty? brackets)\n      #t\n\
    \      (define opening (string-ref brackets 0))\n      (define closing (string-ref\
    \ brackets (sub1 (string-length brackets))))\n      (if (and (char=? opening #\\\
    <) (char=? closing #\\>))\n          (correct_bracketing (substring brackets 1\
    \ (sub1 (string-length brackets))))\n          #f)))\n", "  ;;;\n  ;;; >>> (correct_bracketing_iter\
    \ \"\" \"><<>\")\n  ;;; #f\n  ;;; >>> (correct_bracketing_iter \"\" \"<>\")\n\
    \  ;;; #t\n  ;;; >>> (correct_bracketing_iter \"\" \"<><>\")\n  ;;; #t\n  ;;;\
    \ >>> (correct_bracketing_iter \"\" \"<><>>\")\n  ;;; #t\n  ;;; >>> (correct_bracketing_iter\
    \ \"\" \"<><><>>\")\n  ;;; #t\n  ;;; >>> (correct_bracketing_iter \"\" \"<><><><>>\"\
    )\n  ;;; #t\n  ;;; >>> (correct_bracketing_iter \"\" \"<><><><><>>\")\n  ;;; #t\n\
    \  ;;; >>> (correct_bracketing_iter \"\" \"<><><><><><>>\")\n  ;;; #t\n  ;;; >>>\
    \ (correct_bracketing_iter \"\" \"<><><><><><><>>\")\n  ;;; #t\n  ;;; >>> (correct_bracketing_iter\
    \ \"\" \"<><><><><><><><>>\")\n  ;;; #t\n  ;;; >>> (correct_bracketing_iter \"\
    \" \"<><><><><><><><><>>\")\n  ;;; #t\n  ;;; >>> (correct_bracketing_iter \"\"\
    \ \"<><><><><><><><><><>>\")\n  ;;; #t\n  ;;; >>> (correct_bracketing_iter \"\"\
    \ \"<><><><><><><><><><><>>\")\n  ;;; #t\n  ;;; >>> (correct_bracketing_iter \"\
    \" \"<><><><><><><><><><><><>>\")\n  ;;; #t\n  ;;; >>> (correct_bracketing_iter\
    \ \"\" \"<><><><><><><><><><><><><>>\")\n  ;;; #t\n  ;;; >>> (correct_bracketing_iter\
    \ \"\" \"<><><><><><><><><><><><><><>>\")\n  ;;; #t\n  ;;; >>> (correct_bracketing_iter\
    \ \"\" \"<><><><><><><><><><><><><><><>>\")\n  ;;; #t\n  ;;; >>> (correct_br",
  "  (define (brackets-iter count brackets)\n    (cond ((zero? count) #t)\n      \
    \    ((zero? (string-length brackets)) #f)\n          ((char=? (string-ref brackets\
    \ 0) #\\<)\n           (brackets-iter (+ count 1) (substring brackets 1)))\n \
    \         ((char=? (string-ref brackets 0) #\\>)\n           (brackets-iter (-\
    \ count 1) (substring brackets 1)))\n          (else (brackets-iter count (substring\
    \ brackets 1)))))\n  (brackets-iter 0 brackets))\n```\n\n# Problem 4\n\nCreate\
    \ the function `last`, which returns the last element of a list, or \"empty list\"\
    \ if the list is empty.\n\n## Example\n\n```racket\n#lang racket\n", "  (letrec\
    \ ([open-brackets-count (lambda (s)\n                                  (if (string=?\
    \ s \"\")\n                                      0\n                         \
    \             (if (string=? (substring s 0 1) \"<\")\n                       \
    \                   (+ 1 (open-brackets-count (substring s 1)))\n            \
    \                              (open-brackets-count (substring s 1)))))])\n  \
    \  (if (or (not (string=? (substring brackets 0 1) \"<\"))\n            (not (string=?\
    \ (substring brackets (sub1 (string-length brackets)))))\n            (> (open-brackets-count\
    \ brackets) (open-brackets-count (reverse brackets))))\n        #f\n        #t)))\n",
  "  (if (string-empty? brackets)\n      #t\n      (let ([open? (string=? (substring\
    \ brackets 0 1) \"<\")]\n            [remaining (substring brackets 1)])\n   \
    \     (if open?\n            (if (string-empty? remaining)\n                #f\n\
    \                (correct_bracketing (substring remaining 1)))\n            (correct_bracketing\
    \ remaining)))))\n", "  (if (empty? brackets)\n      #t\n      (let ([first (first\
    \ brackets)]\n            [rest (rest brackets)])\n        (cond\n         [(char=?\
    \ first #\\<)\n          (let ([corresponding (string-index rest #\\> (add1 (string-index\
    \ brackets #\\<)))]\n                [inner (substring brackets 1 corresponding)])\n\
    \            (and\n             (correct_bracketing inner)\n             (correct_bracketing\
    \ (substring brackets corresponding))))]\n         [(char=? first #\\>)\n    \
    \      #f]))))\n", "  (if (empty? brackets)\n      #t\n      (let* ([first-char\
    \ (first brackets)]\n             [rest-of-chars (rest brackets)]\n          \
    \   [matched-bracket (if (equal? first-char #\\<) #\\> #\\<)])\n        (if (and\
    \ (equal? first-char #\\<)\n                 (or (empty? rest-of-chars)\n    \
    \                 (not (equal? (first rest-of-chars) matched-bracket))))\n   \
    \         #f\n            (correct_bracketing rest-of-chars)))))\n\n", "  (cond\n\
    \    [(string=? brackets \"\") #t]\n    [(string=? (string-take brackets 1) \"\
    <\")\n     (if (string=? (string-drop brackets (string-length brackets) -1) \"\
    >\")\n         (correct_bracketing (string-drop brackets 1 (string-length brackets)\
    \ -1))\n         #f)]\n    [else #f]))\n", "  (letrec ((brackets-balancer (lambda\
    \ (brackets)\n                                (cond\n                        \
    \          [(null? brackets) #t]\n                                  [(eq? (first\
    \ brackets) '<) (brackets-balancer (rest brackets))]\n                       \
    \           [(eq? (first brackets) '>) #f]))))\n    (brackets-balancer (parse\
    \ brackets))))\n", "  (cond [(string=? brackets \"\") #t]\n        [(string=?\
    \ (substring brackets 0 1) \"<\")\n         (if (string=? (substring brackets\
    \ (sub1 (string-length brackets)) (string-length brackets)) \">\")\n         \
    \    (correct_bracketing (substring brackets 1 (sub1 (string-length brackets))))\n\
    \             #f)]\n        [else #f]))\n\n", "  (cond ((null? brackets) '#t)\n\
    \        ((and (not (null? (cdr brackets)))\n              (eq? (car brackets)\
    \ (cadr brackets)))\n         (correct_bracketing (cddr brackets)))\n        ((and\
    \ (not (null? (cdr brackets)))\n              (eq? (car brackets) #\\<)\n    \
    \          (eq? (cadr brackets) #\\>))\n         (correct_bracketing (cddr brackets)))\n\
    \        (else '#f)))\n", "  (letrec ([empty? (lambda (s) (string=? s \"\"))]\n\
    \           [pop-left (lambda (s) (substring s 1 (string-length s)))]\n      \
    \     [pop-right (lambda (s) (substring s 0 (- (string-length s) 1)))]\n     \
    \      [bracket-at-front? (lambda (s) (and (not (empty? s)) (string=? (substring\
    \ s 0 1) \"<\")))]\n           [bracket-at-back? (lambda (s) (and (not (empty?\
    \ s)) (string=? (substring s (- (string-length s) 1) (string-length s)) \">\"\
    )))])\n    (let loop ([s brackets])\n      (if (empty? s)\n          #t\n    \
    \      (if (bracket-at-front? s)\n              (loop (pop-left s))\n        \
    \      (if (bracket-at-back? s)\n                  (loop (pop-right s))\n    \
    \              #f))))))\n", "  (let loop ([brackets brackets] [stack '()])\n \
    \   (cond\n      [(null? brackets)\n       (null? stack)]\n      [(string=? (string-take\
    \ brackets 1) \"<\")\n       (loop (string-drop brackets 1) (cons \">\" stack))]\n\
    \      [(string=? (string-take brackets 1) \">\")\n       (and (not (null? stack))\n\
    \            (loop (string-drop brackets 1) (cdr stack)))])))", "  (cond ((string=?\
    \ brackets \"\") #t)\n        ((or (string=? (substring brackets 0 1) \"<\")\n\
    \             (string=? (substring brackets 0 1) \">\"))\n         (and (correct_bracketing\
    \ (substring brackets 1))\n              (correct_bracketing (substring brackets\
    \ 1))))\n        ((string=? (substring brackets 0 1) \"<\")\n         (and (correct_bracketing\
    \ (substring brackets 1))\n              (correct_bracketing (substring brackets\
    \ 1))))\n        ((string=? (substring brackets 0 1) \">\")\n         (and (correct_bracketing\
    \ (substring brackets 1))\n              (correct_bracketing (substring brackets\
    \ 1))))))\n", "  (cond\n    [(empty? brackets) #t]\n    [(not (find (first brackets)\
    \ (list #\\< #\\>))) #f]\n    [(string=? \"<\" (first brackets))\n     (if (=\
    \ 0 (string-length (rest brackets)))\n         #f\n         (correct_bracketing\
    \ (string-append (rest brackets) \">\")))]\n    [(string=? \">\" (first brackets))\n\
    \     (if (= 0 (string-length (rest brackets)))\n         #f\n         (correct_bracketing\
    \ (string-append \"<\" (rest brackets))))]))\n", "  (if (string-empty? brackets)\n\
    \      #t\n      (match brackets\n             [(substring \"<\" (sub1 (string-length\
    \ brackets)))\n              (if (match brackets\n                         [(substring\
    \ \">\" (sub1 (string-length brackets)))\n                          #t\n     \
    \                     \"\" #f])\n                  (correct_bracketing (substring\
    \ brackets 1 (sub1 (string-length brackets))))\n                  #f)]\n     \
    \        [else #f])))\n```\n\n``` #lang racket\n", "  (cond\n    [(empty? brackets)\
    \ true]\n    [(char=? (first brackets) #\\<)\n     (cond\n       [(empty? (rest\
    \ brackets)) false]\n       [(char=? (first (rest brackets)) #\\>)\n        (correct_bracketing\
    \ (rest (rest brackets)))]\n       [else false])]\n    [else (correct_bracketing\
    \ (rest brackets))]))\n", "  (... brackets))\n```\n\n## Quiz 4\n\n``` #lang racket\n",
  "  (cond\n    [(empty? brackets) #t]\n    [(= (count \"<\" brackets) (count \">\"\
    \ brackets)) #t]\n    [else #f]))\n```\n\nTo test that they are correct, you can\
    \ run `racket check.rkt` to see if they pass all of the tests.  You should see\
    \ something like:\n\n```\nChecking corrections for <...>\n9/9\nChecking corrections\
    \ for split...\n3/3\nChecking corrections for reverse...\n2/2\nChecking corrections\
    \ for sum...\n1/1\nChecking corrections for longest...\n7/7\nChecking corrections\
    \ for correct_bracketing...\n5/5\n```\n\n**Problem 2.**  [30 points] Write a Scheme\
    \ program to solve the following problem.  You may use any built-in Scheme functions.\
    \  The length of the list to process will be small enough that performance is\
    \ not an issue.\n\nA palindrome is a word that reads the same backward as forward.\
    \  The following are all palindromes:\n\n```\nracecar\nnoon\nredivider\n```\n\n\
    All of these words have the same letters in reverse order.  They are also case\
    \ insensitive, so \"Racecar\" is a palindrome.  A palindrome also has no spaces.\
    \  The following are not palindromes:\n\n```\nraces\nnooner\nredividerr\n```\n\
    \nA palindrome is a word, but can also be a phrase.  For example, \"nurses run\"\
    \ is a palindrome, but \"nurses run.\" is not (since the period is not a letter).\
    \  However, \"nurses, run\" is a palindrome.  A palindrome can also contain other\
    \ characters, such as \"nurses, run! +-\" is a palindrome.\n\nWrite a function\
    \ `palindrome?` that takes a single string and returns `#t` if it is a palindrome,\
    \ or `#f` if it is not.  The function `palindrome?` should be case insensitive\
    \ and ignore all non-letters and non-numbers.  Thus, to test if a string is a\
    \ palindrome, you need to remove all punctuation, remove all spaces, convert to\
    \ lower case, and", "  (let ([st (make-stack)])\n    (for ([ch (in-string brackets)])\n\
    \      (cond\n        [(eq? ch #\\<) (stack-push st #\\<)]\n        [(eq? ch #\\\
    >) (or (stack-empty? st) (stack-pop st))]))\n    (stack-empty? st)))\n", "  (let\
    \ loop ([brackets brackets] [count 0])\n    (cond\n      [(zero? count) #t]\n\
    \      [(zero? (string-length brackets))\n       (not (zero? count))]\n      [else\n\
    \       (let ([b (string-ref brackets 0)])\n         (cond\n           [(char=?\
    \ b #\\<)\n            (loop (substring brackets 1) (+ count 1))]\n          \
    \ [(char=? b #\\>)\n            (loop (substring brackets 1) (- count 1))]\n \
    \          [else\n            (loop (substring brackets 1) count)]))])))\n```\n\
    \n```racket\n#lang racket\n", "  (cond\n    [(empty? brackets) #t]\n    [(not\
    \ (every (lambda (b) (char=? b #\\<) (char=? b #\\>)) brackets)) #f]\n    [else\
    \ (correct_bracketing (substring brackets 1))]))\n", "  (define (balance left\
    \ right)\n    (cond\n      [(empty? left) (and (empty? right) #t)]\n      [(empty?\
    \ right) #f]\n      [else (balance (rest left) (rest right))]))\n  (define (open-brackets\
    \ rest)\n    (cond\n      [(empty? rest) '()]\n      [(string=? (first rest) #\\\
    <) (cons (first rest) (open-brackets (rest rest)))]\n      [else (open-brackets\
    \ (rest rest))]))\n  (define (close-brackets rest)\n    (cond\n      [(empty?\
    \ rest) '()]\n      [(string=? (first rest) #\\>) (cons (first rest) (close-brackets\
    \ (rest rest)))]\n      [else (close-brackets (rest rest))]))\n  (balance (open-brackets\
    \ brackets) (close-brackets brackets)))\n", "  (define (bracket-helper brackets\
    \ bracket-count)\n    (cond ((string=? brackets \"\") (= bracket-count 0))\n \
    \         ((string=? (substring brackets 0 1) \"<\")\n           (bracket-helper\
    \ (substring brackets 1) (+ bracket-count 1)))\n          ((string=? (substring\
    \ brackets 0 1) \">\")\n           (bracket-helper (substring brackets 1) (- bracket-count\
    \ 1)))\n          (else (error \"Invalid bracketing\"))))\n  (bracket-helper brackets\
    \ 0))\n", "  (let [open 0]\n    (if (zero? (string-length brackets))\n      #t\n\
    \      (let [head (string-ref brackets 0)]\n        (if (equal? head #\\<)\n \
    \         (set! open (+ open 1))\n          (set! open (- open 1)))\n        (if\
    \ (zero? open)\n          (correct_bracketing (substring brackets 1))\n      \
    \    #f)))))\n```\n\n## Exercise 4: Binary Trees\n\n```racket\n#lang racket\n",
  "  (define (iter counter str)\n    (cond\n      [(null? str) (= counter 0)]\n  \
    \    [(string=? (car str) \"<\") (iter (add1 counter) (cdr str))]\n      [(string=?\
    \ (car str) \">\") (iter (sub1 counter) (cdr str))]\n      [else #f]))\n  (iter\
    \ 0 brackets))\n", "  (cond\n    [(empty? brackets) true]\n    [(equal? (first\
    \ brackets) #\\<) (and (correct_bracketing (rest brackets)) (or (search \">\"\
    \ brackets) (empty? brackets)))]\n    [(equal? (first brackets) #\\>) (and (correct_bracketing\
    \ (rest brackets)))]\n    [else (correct_bracketing (rest brackets))]))\n", " \
    \ (cond [(empty? brackets) #t]\n        [(and (equal? (first brackets) \"<\")\n\
    \              (equal? (last brackets) \">\"))\n         (correct_bracketing (substring\
    \ (rest (butlast brackets)) 1))]\n        [else #f]))\n", "  ;; helper function\
    \ to return #t if the first char of string\n  ;; is a left bracket, and #f otherwise\n\
    \  (define (first-left? s)\n    (if (string=? (substring s 0 1) \"<\")\n     \
    \   #t\n        #f))\n  ;; helper function to return #t if the first char of string\n\
    \  ;; is a right bracket, and #f otherwise\n  (define (first-right? s)\n    (if\
    \ (string=? (substring s 0 1) \">\")\n        #t\n        #f))\n  ;; helper function\
    \ to remove the first char of string\n  (define (remove-first s)\n    (substring\
    \ s 1 (string-length s)))\n  ;; helper function that returns #t if the first left\
    \ bracket\n  ;; has a corresponding right bracket, #f otherwise\n  (define (match-bracket\
    \ s)\n    (if (first-left? s)\n        (let ([new-string (remove-first s)])\n\
    \          (if (first-right? new-string)\n              #t\n              (match-bracket\
    \ new-string)))\n        #f))\n  ;; body of main function\n  (if (empty? brackets)\n\
    \      #t\n      (match-bracket brackets)))\n", "  (local\n    ;; count the number\
    \ of open and closed brackets.\n    ;; return the difference.\n    [(define (count\
    \ s n)\n       (cond\n         [(empty? s) n]\n         [(equal? (first s) #\\\
    <) (count (rest s) (add1 n))]\n         [(equal? (first s) #\\>) (count (rest\
    \ s) (sub1 n))]\n         [else (count (rest s) n)]))]\n    (equal? (count brackets\
    \ 0) 0)))\n", "  (cond\n    [(empty? brackets) #t]\n    [(pair? (first brackets))\
    \ (correct_bracketing (rest brackets))]\n    [(eq? (first brackets) #\\<) (if\
    \ (correct_bracketing (rest brackets))\n                                    (if\
    \ (or (empty? (rest brackets))\n                                            (pair?\
    \ (first (rest brackets))))\n                                        #f\n    \
    \                                    (if (eq? (first (rest brackets)) #\\>)\n\
    \                                            (correct_bracketing (rest (rest brackets)))\n\
    \                                            #f))\n                          \
    \          #f)]\n    [else #f]))\n", "  ...)\n```\n\n## Question 2.2\n``` #lang\
    \ racket\n", "  (cond\n    [(empty? brackets) #t]\n    [(empty? (rest brackets))\
    \ #f]\n    [(not (same? (first brackets) (first (rest brackets))))\n     (correct_bracketing\
    \ (rest brackets))]\n    [else (correct_bracketing (rest (rest brackets)))]))\n",
  "  (cond\n    [(empty? brackets) #t]\n    [(empty? (rest brackets)) #f]\n    [(empty?\
    \ (rest (rest brackets))) #f]\n    [else\n     (correct_bracketing (rest (rest\
    \ brackets)))]))\n", "  (empty? brackets))\n", "  (define (brackets-helper cs\
    \ ns result)\n    (cond\n      [(empty? cs) (not (empty? result))]\n      [(or\
    \ (char=? (first cs) #\\<) (char=? (first cs) #\\>)) (if (char=? (first cs) #\\\
    <) (brackets-helper (rest cs) (add1 ns) (cons #\\< result)) (if (and (not (empty?\
    \ result)) (char=? (first result) #\\<)) (brackets-helper (rest cs) (sub1 ns)\
    \ (rest result)) #f))]\n      [else (brackets-helper (rest cs) ns result)]))\n\
    \  (brackets-helper (string->list brackets) 0 '()))\n", "  (define (recur open-brackets\
    \ remaining-brackets)\n    (cond\n      [(string=? remaining-brackets \"\")\n\
    \       (string=? open-brackets \"\")]\n      [(string=? (substring remaining-brackets\
    \ 0 1) \"<\")\n       (recur (string-append open-brackets \"<\")\n           \
    \   (substring remaining-brackets 1))]\n      [(string=? (substring remaining-brackets\
    \ 0 1) \">\")\n       (and (not (string=? open-brackets \"\"))\n            (recur\
    \ (substring open-brackets 0 -1)\n                   (substring remaining-brackets\
    \ 1)))]))\n  (recur \"\" brackets))\n", "  (if (empty? brackets)\n      #t\n \
    \     (define (brackets-helper brackets count)\n        (if (empty? brackets)\n\
    \            (= count 0)\n            (cond ((eq? (first brackets) #\\<)\n   \
    \                (brackets-helper (rest brackets) (+ count 1)))\n            \
    \      ((eq? (first brackets) #\\>)\n                   (brackets-helper (rest\
    \ brackets) (- count 1)))\n                  (else\n                   #f))))\n\
    \      (brackets-helper brackets 0)))\n\n", "  (define (helper str count)\n  \
    \  (cond\n      [(empty? str)\n       (equal? count 0)]\n      [(equal? (first\
    \ str) #\\<)\n       (helper (rest str) (+ count 1))]\n      [(equal? (first str)\
    \ #\\>)\n       (helper (rest str) (- count 1))]))\n  (helper (string->list brackets)\
    \ 0))\n", "  (let ([open-count 0])\n    (for ([c (in-string brackets)])\n    \
    \  (cond\n        [(char=? c #\\<) (set! open-count (+ open-count 1))]\n     \
    \   [(char=? c #\\>) (set! open-count (- open-count 1))]))\n    (= open-count\
    \ 0)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
